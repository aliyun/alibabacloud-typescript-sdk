// This file is auto-generated, don't edit it
/**
 */
import Util, * as $Util from '@alicloud/tea-util';
import OSS, * as $OSS from '@alicloud/oss-client';
import OpenPlatform, * as $OpenPlatform from '@alicloud/openplatform20191219';
import OSSUtil, * as $OSSUtil from '@alicloud/oss-util';
import FileForm, * as $FileForm from '@alicloud/tea-fileform';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import { Readable } from 'stream';
import * as $tea from '@alicloud/tea-typescript';

export class WafBatchRuleShared extends $tea.Model {
  action?: string;
  actions?: WafBatchRuleSharedActions;
  crossSiteId?: number;
  expression?: string;
  match?: WafRuleMatch2;
  mode?: string;
  name?: string;
  target?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      actions: 'Actions',
      crossSiteId: 'CrossSiteId',
      expression: 'Expression',
      match: 'Match',
      mode: 'Mode',
      name: 'Name',
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      actions: WafBatchRuleSharedActions,
      crossSiteId: 'number',
      expression: 'string',
      match: WafRuleMatch2,
      mode: 'string',
      name: 'string',
      target: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafQuotaInteger extends $tea.Model {
  equal?: number;
  greaterThan?: number;
  greaterThanOrEqual?: number;
  lessThan?: number;
  lessThanOrEqual?: number;
  static names(): { [key: string]: string } {
    return {
      equal: 'Equal',
      greaterThan: 'GreaterThan',
      greaterThanOrEqual: 'GreaterThanOrEqual',
      lessThan: 'LessThan',
      lessThanOrEqual: 'LessThanOrEqual',
    };
  }

  static types(): { [key: string]: any } {
    return {
      equal: 'number',
      greaterThan: 'number',
      greaterThanOrEqual: 'number',
      lessThan: 'number',
      lessThanOrEqual: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafQuotaString extends $tea.Model {
  regexp?: string;
  static names(): { [key: string]: string } {
    return {
      regexp: 'Regexp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regexp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfig extends $tea.Model {
  action?: string;
  actions?: WafRuleConfigActions;
  appPackage?: WafRuleConfigAppPackage;
  appSdk?: WafRuleConfigAppSdk;
  expression?: string;
  id?: number;
  managedGroupId?: number;
  managedList?: string;
  managedRulesets?: WafRuleConfigManagedRulesets[];
  match?: WafRuleMatch;
  name?: string;
  rateLimit?: WafRuleConfigRateLimit;
  sigchl?: string[];
  status?: string;
  timer?: WafTimer;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      actions: 'Actions',
      appPackage: 'AppPackage',
      appSdk: 'AppSdk',
      expression: 'Expression',
      id: 'Id',
      managedGroupId: 'ManagedGroupId',
      managedList: 'ManagedList',
      managedRulesets: 'ManagedRulesets',
      match: 'Match',
      name: 'Name',
      rateLimit: 'RateLimit',
      sigchl: 'Sigchl',
      status: 'Status',
      timer: 'Timer',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      actions: WafRuleConfigActions,
      appPackage: WafRuleConfigAppPackage,
      appSdk: WafRuleConfigAppSdk,
      expression: 'string',
      id: 'number',
      managedGroupId: 'number',
      managedList: 'string',
      managedRulesets: { 'type': 'array', 'itemType': WafRuleConfigManagedRulesets },
      match: WafRuleMatch,
      name: 'string',
      rateLimit: WafRuleConfigRateLimit,
      sigchl: { 'type': 'array', 'itemType': 'string' },
      status: 'string',
      timer: WafTimer,
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleMatch extends $tea.Model {
  convertToLower?: boolean;
  criteria?: WafRuleMatch[];
  logic?: string;
  matchOperator?: string;
  matchType?: string;
  matchValue?: any;
  negate?: boolean;
  static names(): { [key: string]: string } {
    return {
      convertToLower: 'ConvertToLower',
      criteria: 'Criteria',
      logic: 'Logic',
      matchOperator: 'MatchOperator',
      matchType: 'MatchType',
      matchValue: 'MatchValue',
      negate: 'Negate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      convertToLower: 'boolean',
      criteria: { 'type': 'array', 'itemType': WafRuleMatch },
      logic: 'string',
      matchOperator: 'string',
      matchType: 'string',
      matchValue: 'any',
      negate: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleMatch2 extends $tea.Model {
  convertToLower?: boolean;
  criteria?: WafRuleMatch2Criteria[];
  logic?: string;
  matchOperator?: string;
  matchType?: string;
  matchValue?: any;
  negate?: boolean;
  static names(): { [key: string]: string } {
    return {
      convertToLower: 'ConvertToLower',
      criteria: 'Criteria',
      logic: 'Logic',
      matchOperator: 'MatchOperator',
      matchType: 'MatchType',
      matchValue: 'MatchValue',
      negate: 'Negate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      convertToLower: 'boolean',
      criteria: { 'type': 'array', 'itemType': WafRuleMatch2Criteria },
      logic: 'string',
      matchOperator: 'string',
      matchType: 'string',
      matchValue: 'any',
      negate: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafSiteSettings extends $tea.Model {
  addBotProtectionHeaders?: WafSiteSettingsAddBotProtectionHeaders;
  addSecurityHeaders?: WafSiteSettingsAddSecurityHeaders;
  clientIpIdentifier?: WafSiteSettingsClientIpIdentifier;
  securityLevel?: WafSiteSettingsSecurityLevel;
  static names(): { [key: string]: string } {
    return {
      addBotProtectionHeaders: 'AddBotProtectionHeaders',
      addSecurityHeaders: 'AddSecurityHeaders',
      clientIpIdentifier: 'ClientIpIdentifier',
      securityLevel: 'SecurityLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addBotProtectionHeaders: WafSiteSettingsAddBotProtectionHeaders,
      addSecurityHeaders: WafSiteSettingsAddSecurityHeaders,
      clientIpIdentifier: WafSiteSettingsClientIpIdentifier,
      securityLevel: WafSiteSettingsSecurityLevel,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafTimer extends $tea.Model {
  periods?: WafTimerPeriods[];
  scopes?: string;
  weeklyPeriods?: WafTimerWeeklyPeriods[];
  zone?: number;
  static names(): { [key: string]: string } {
    return {
      periods: 'Periods',
      scopes: 'Scopes',
      weeklyPeriods: 'WeeklyPeriods',
      zone: 'Zone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      periods: { 'type': 'array', 'itemType': WafTimerPeriods },
      scopes: 'string',
      weeklyPeriods: { 'type': 'array', 'itemType': WafTimerWeeklyPeriods },
      zone: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class HttpDeliveryHeaderParamValue extends $tea.Model {
  /**
   * @remarks
   * The static variable.
   * 
   * @example
   * alicdn
   */
  staticValue?: string;
  static names(): { [key: string]: string } {
    return {
      staticValue: 'StaticValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      staticValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class HttpDeliveryQueryParamValue extends $tea.Model {
  /**
   * @remarks
   * The static variable.
   * 
   * @example
   * alicdn
   */
  staticValue?: string;
  static names(): { [key: string]: string } {
    return {
      staticValue: 'StaticValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      staticValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FieldContentValue extends $tea.Model {
  /**
   * @remarks
   * The sequence number of the fields.
   * 
   * @example
   * 1
   */
  sortOrder?: number;
  /**
   * @remarks
   * The fields.
   */
  fieldList?: FieldContentValueFieldList[];
  static names(): { [key: string]: string } {
    return {
      sortOrder: 'SortOrder',
      fieldList: 'FieldList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sortOrder: 'number',
      fieldList: { 'type': 'array', 'itemType': FieldContentValueFieldList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuotaListItemsValue extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the item type is configured in the custom list.
   */
  enable?: boolean;
  /**
   * @remarks
   * The format restrictions for the item type in the custom list.
   */
  value?: WafQuotaString;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
      value: WafQuotaString,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuotaPageContentTypesValue extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the custom error pages of the Content-Type are configured.
   */
  enable?: boolean;
  /**
   * @remarks
   * The maximum length of the custom error pages of the Content-Type.
   */
  contentLength?: WafQuotaInteger;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      contentLength: 'ContentLength',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
      contentLength: WafQuotaInteger,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ActivateClientCertificateRequest extends $tea.Model {
  /**
   * @remarks
   * The certificate ID, which can be obtained by calling the [ListClientCertificates](https://help.aliyun.com/document_detail/2852848.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * babaded901474b9693acf530e0fb****
   */
  id?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ActivateClientCertificateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The certificate ID.
   * 
   * @example
   * babaded901474b9693acf530e0fb****
   */
  id?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
      siteId: 'SiteId',
      siteName: 'SiteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
      siteId: 'number',
      siteName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ActivateClientCertificateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ActivateClientCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ActivateClientCertificateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsRequest extends $tea.Model {
  /**
   * @remarks
   * The list of DNS records to be created.
   * 
   * This parameter is required.
   */
  recordList?: BatchCreateRecordsRequestRecordList[];
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      recordList: 'RecordList',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordList: { 'type': 'array', 'itemType': BatchCreateRecordsRequestRecordList },
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The list of DNS records to be created.
   * 
   * This parameter is required.
   */
  recordListShrink?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      recordListShrink: 'RecordList',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordListShrink: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The records that have been created and failed to be created.
   */
  recordResultList?: BatchCreateRecordsResponseBodyRecordResultList;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2430E05E-1340-5773-B5E1-B743929F46F2
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recordResultList: 'RecordResultList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordResultList: BatchCreateRecordsResponseBodyRecordResultList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchCreateRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchCreateRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateWafRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The configurations of the rules.
   */
  configs?: WafRuleConfig[];
  /**
   * @remarks
   * The WAF rule category.
   * 
   * @example
   * http_custom
   */
  phase?: string;
  /**
   * @remarks
   * The configurations shared by multiple rules.
   */
  shared?: WafBatchRuleShared;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      phase: 'Phase',
      shared: 'Shared',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: { 'type': 'array', 'itemType': WafRuleConfig },
      phase: 'string',
      shared: WafBatchRuleShared,
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateWafRulesShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The configurations of the rules.
   */
  configsShrink?: string;
  /**
   * @remarks
   * The WAF rule category.
   * 
   * @example
   * http_custom
   */
  phase?: string;
  /**
   * @remarks
   * The configurations shared by multiple rules.
   */
  sharedShrink?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configsShrink: 'Configs',
      phase: 'Phase',
      sharedShrink: 'Shared',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configsShrink: 'string',
      phase: 'string',
      sharedShrink: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateWafRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The IDs of the WAF rules.[](~~2850237~~)
   */
  ids?: number[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the WAF ruleset.[](~~2850233~~)
   * 
   * @example
   * 10000001
   */
  rulesetId?: number;
  static names(): { [key: string]: string } {
    return {
      ids: 'Ids',
      requestId: 'RequestId',
      rulesetId: 'RulesetId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ids: { 'type': 'array', 'itemType': 'number' },
      requestId: 'string',
      rulesetId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateWafRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchCreateWafRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchCreateWafRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteKvRequest extends $tea.Model {
  /**
   * @remarks
   * The keys that you want to delete. You can delete a maximum of 10,000 key-value pairs at a time.
   * 
   * This parameter is required.
   */
  keys?: string[];
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      keys: 'Keys',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keys: { 'type': 'array', 'itemType': 'string' },
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteKvShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The keys that you want to delete. You can delete a maximum of 10,000 key-value pairs at a time.
   * 
   * This parameter is required.
   */
  keysShrink?: string;
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      keysShrink: 'Keys',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keysShrink: 'string',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteKvResponseBody extends $tea.Model {
  /**
   * @remarks
   * The keys that failed to be deleted.
   */
  failKeys?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The keys that are deleted.
   */
  successKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      failKeys: 'FailKeys',
      requestId: 'RequestId',
      successKeys: 'SuccessKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failKeys: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
      successKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteKvResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchDeleteKvResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchDeleteKvResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteKvWithHighCapacityRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * The download URL of the key-value pairs that you want to delete. This parameter is automatically filled in when you use the SDK to call the operation.
   * 
   * This parameter is required.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteKvWithHighCapacityAdvanceRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * The download URL of the key-value pairs that you want to delete. This parameter is automatically filled in when you use the SDK to call the operation.
   * 
   * This parameter is required.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  urlObject?: Readable;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
      urlObject: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
      urlObject: 'Readable',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteKvWithHighCapacityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The keys that failed to be deleted.
   */
  failKeys?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The keys that are deleted.
   */
  successKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      failKeys: 'FailKeys',
      requestId: 'RequestId',
      successKeys: 'SuccessKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failKeys: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
      successKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteKvWithHighCapacityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchDeleteKvWithHighCapacityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchDeleteKvWithHighCapacityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetExpressionFieldsRequest extends $tea.Model {
  /**
   * @remarks
   * The regular expressions.
   * 
   * @example
   * http_bot
   */
  expressions?: BatchGetExpressionFieldsRequestExpressions[];
  /**
   * @remarks
   * The WAF rule category.
   * 
   * @example
   * http_bot
   */
  phase?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      expressions: 'Expressions',
      phase: 'Phase',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expressions: { 'type': 'array', 'itemType': BatchGetExpressionFieldsRequestExpressions },
      phase: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetExpressionFieldsShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The regular expressions.
   * 
   * @example
   * http_bot
   */
  expressionsShrink?: string;
  /**
   * @remarks
   * The WAF rule category.
   * 
   * @example
   * http_bot
   */
  phase?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      expressionsShrink: 'Expressions',
      phase: 'Phase',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expressionsShrink: 'string',
      phase: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetExpressionFieldsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The fields that match the regular expressions.
   */
  fields?: BatchGetExpressionFieldsResponseBodyFields[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      fields: 'Fields',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fields: { 'type': 'array', 'itemType': BatchGetExpressionFieldsResponseBodyFields },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetExpressionFieldsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchGetExpressionFieldsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchGetExpressionFieldsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutKvRequest extends $tea.Model {
  /**
   * @remarks
   * The key-value pairs that you want to configure at a time. The total size can be up to 2 MB (2 × 1000 × 1000).
   * 
   * This parameter is required.
   */
  kvList?: BatchPutKvRequestKvList[];
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      kvList: 'KvList',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      kvList: { 'type': 'array', 'itemType': BatchPutKvRequestKvList },
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutKvShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The key-value pairs that you want to configure at a time. The total size can be up to 2 MB (2 × 1000 × 1000).
   * 
   * This parameter is required.
   */
  kvListShrink?: string;
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      kvListShrink: 'KvList',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      kvListShrink: 'string',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutKvResponseBody extends $tea.Model {
  /**
   * @remarks
   * The keys that failed to be written.
   */
  failKeys?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The keys that were written.
   */
  successKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      failKeys: 'FailKeys',
      requestId: 'RequestId',
      successKeys: 'SuccessKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failKeys: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
      successKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutKvResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchPutKvResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchPutKvResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutKvWithHighCapacityRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * The download URL of the key-value pairs that you want to configure. This parameter is automatically filled in when you use the SDK to call the operation.
   * 
   * This parameter is required.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutKvWithHighCapacityAdvanceRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * The download URL of the key-value pairs that you want to configure. This parameter is automatically filled in when you use the SDK to call the operation.
   * 
   * This parameter is required.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  urlObject?: Readable;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
      urlObject: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
      urlObject: 'Readable',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutKvWithHighCapacityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The keys that failed to be written.
   */
  failKeys?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The keys that were written.
   */
  successKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      failKeys: 'FailKeys',
      requestId: 'RequestId',
      successKeys: 'SuccessKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failKeys: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
      successKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutKvWithHighCapacityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchPutKvWithHighCapacityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchPutKvWithHighCapacityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateWafRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The configurations of rules.
   */
  configs?: WafRuleConfig[];
  /**
   * @remarks
   * The WAF rule category.
   * 
   * @example
   * http_custom
   */
  phase?: string;
  /**
   * @remarks
   * The ID of the WAF ruleset, which can be obtained by calling the [ListWafRulesets](https://help.aliyun.com/document_detail/2850233.html) operation.
   * 
   * @example
   * 10000001
   */
  rulesetId?: number;
  /**
   * @remarks
   * The configurations shared by multiple rules.
   */
  shared?: WafBatchRuleShared;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      phase: 'Phase',
      rulesetId: 'RulesetId',
      shared: 'Shared',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: { 'type': 'array', 'itemType': WafRuleConfig },
      phase: 'string',
      rulesetId: 'number',
      shared: WafBatchRuleShared,
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateWafRulesShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The configurations of rules.
   */
  configsShrink?: string;
  /**
   * @remarks
   * The WAF rule category.
   * 
   * @example
   * http_custom
   */
  phase?: string;
  /**
   * @remarks
   * The ID of the WAF ruleset, which can be obtained by calling the [ListWafRulesets](https://help.aliyun.com/document_detail/2850233.html) operation.
   * 
   * @example
   * 10000001
   */
  rulesetId?: number;
  /**
   * @remarks
   * The configurations shared by multiple rules.
   */
  sharedShrink?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configsShrink: 'Configs',
      phase: 'Phase',
      rulesetId: 'RulesetId',
      sharedShrink: 'Shared',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configsShrink: 'string',
      phase: 'string',
      rulesetId: 'number',
      sharedShrink: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateWafRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateWafRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchUpdateWafRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchUpdateWafRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BlockObjectRequest extends $tea.Model {
  /**
   * @remarks
   * The content to block.
   * 
   * This parameter is required.
   */
  content?: string[];
  /**
   * @remarks
   * The blocking period that you can extend. Set the value to 2year.
   * 
   * @example
   * 2year
   */
  extension?: string;
  /**
   * @remarks
   * The period of time during which the URL is blocked. Unit: seconds. Specify this parameter if Type is set to block.
   * 
   * @example
   * 864000
   */
  maxage?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * BlockObject
   */
  siteId?: number;
  /**
   * @remarks
   * The type. Valid values:
   * 
   * *   **block**
   * *   **unblock**
   * 
   * This parameter is required.
   * 
   * @example
   * block
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      extension: 'Extension',
      maxage: 'Maxage',
      siteId: 'SiteId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'array', 'itemType': 'string' },
      extension: 'string',
      maxage: 'number',
      siteId: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BlockObjectShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The content to block.
   * 
   * This parameter is required.
   */
  contentShrink?: string;
  /**
   * @remarks
   * The blocking period that you can extend. Set the value to 2year.
   * 
   * @example
   * 2year
   */
  extension?: string;
  /**
   * @remarks
   * The period of time during which the URL is blocked. Unit: seconds. Specify this parameter if Type is set to block.
   * 
   * @example
   * 864000
   */
  maxage?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * BlockObject
   */
  siteId?: number;
  /**
   * @remarks
   * The type. Valid values:
   * 
   * *   **block**
   * *   **unblock**
   * 
   * This parameter is required.
   * 
   * @example
   * block
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      contentShrink: 'Content',
      extension: 'Extension',
      maxage: 'Maxage',
      siteId: 'SiteId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentShrink: 'string',
      extension: 'string',
      maxage: 'number',
      siteId: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BlockObjectResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  /**
   * @remarks
   * The blocking task ID.
   * 
   * @example
   * 15940956620
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BlockObjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BlockObjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BlockObjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeResourceGroupRequest extends $tea.Model {
  ownerId?: number;
  /**
   * @remarks
   * The ID of the resource group to which you want to move the website.
   * 
   * This parameter is required.
   * 
   * @example
   * rg-axxxxxx
   */
  resourceGroupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceGroupId: 'ResourceGroupId',
      securityToken: 'SecurityToken',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceGroupId: 'string',
      securityToken: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeResourceGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F8AA0364-0FDB-4AD5-AC74-D69FAB8924ED
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeResourceGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ChangeResourceGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ChangeResourceGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckSiteNameRequest extends $tea.Model {
  /**
   * @remarks
   * The website name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  static names(): { [key: string]: string } {
    return {
      siteName: 'SiteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckSiteNameResponseBody extends $tea.Model {
  /**
   * @remarks
   * The description of the verification result. Valid values:
   * 
   * *   **success**: The verification is successful.
   * *   **Site.AlreadyExist**: The website domain name has already been added.
   * *   **Site.InvalidName**: Invalid website domain name.
   * *   **Site.SubSiteUnavailable**: Subdomains are not allowed.
   * *   **Site.InternalError**: An internal error occurs.
   * 
   * @example
   * success
   */
  description?: string;
  /**
   * @remarks
   * Indicates whether a subdomain is specified. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * false
   */
  isSubSite?: boolean;
  /**
   * @remarks
   * The verification message.
   */
  messeage?: string;
  /**
   * @remarks
   * Indicates whether the verification passed.
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  passed?: boolean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-280B-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      isSubSite: 'IsSubSite',
      messeage: 'Messeage',
      passed: 'Passed',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      isSubSite: 'boolean',
      messeage: 'string',
      passed: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckSiteNameResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CheckSiteNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CheckSiteNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckSiteProjectNameRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the real-time log delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * user_log
   */
  projectName?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 12312312213212
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      projectName: 'ProjectName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectName: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckSiteProjectNameResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the task name is valid. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  check?: boolean;
  /**
   * @remarks
   * The result description.
   * 
   * @example
   * project name pass the check
   */
  description?: string;
  /**
   * @remarks
   * The name of the real-time log delivery task.
   * 
   * @example
   * dcdn_waf_userAccount_log
   */
  projectName?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34DCBC8A-****-****-****-6DAA11D7DDBD
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      check: 'Check',
      description: 'Description',
      projectName: 'ProjectName',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      check: 'boolean',
      description: 'string',
      projectName: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckSiteProjectNameResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CheckSiteProjectNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CheckSiteProjectNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckUserProjectNameRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the real-time log delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * ali-dcdn-log-56
   */
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckUserProjectNameResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the name is valid. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  check?: boolean;
  /**
   * @remarks
   * The reason why the name passed or failed the check.
   * 
   * @example
   * project name pass the check
   */
  description?: string;
  /**
   * @remarks
   * The name of the real-time log delivery task.
   * 
   * @example
   * ali-dcdn-log-56
   */
  projectName?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34DCBC8A-****-****-****-6DAA11D7DDBD
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      check: 'Check',
      description: 'Description',
      projectName: 'ProjectName',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      check: 'boolean',
      description: 'string',
      projectName: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckUserProjectNameResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CheckUserProjectNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CheckUserProjectNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CommitRoutineStagingCodeRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the code version.
   * 
   * @example
   * description of this code ver
   */
  codeDescription?: string;
  /**
   * @remarks
   * The routine name.
   * 
   * @example
   * CommitRoutineStagingCode
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      codeDescription: 'CodeDescription',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeDescription: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CommitRoutineStagingCodeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The version number of the newly generated code.
   * 
   * @example
   * 1710120201067203242
   */
  codeVersion?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      codeVersion: 'CodeVersion',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeVersion: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CommitRoutineStagingCodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CommitRoutineStagingCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CommitRoutineStagingCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCustomScenePolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The time when the policy expires.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-11-07T18:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The policy name.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The IDs of the websites that you want to associate with the policy. Separate multiple IDs with commas (,).
   * 
   * @example
   * 7096621098****
   */
  objects?: string;
  /**
   * @remarks
   * The time when the policy takes effect.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-11-07T17:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The name of the policy template. Valid value:
   * 
   * *   **promotion**: major events.
   * 
   * This parameter is required.
   * 
   * @example
   * promotion
   */
  template?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      name: 'Name',
      objects: 'Objects',
      startTime: 'StartTime',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      name: 'string',
      objects: 'string',
      startTime: 'string',
      template: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCustomScenePolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time when the policy expires.
   * 
   * The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2021-11-07T18:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The policy name.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The IDs of websites associated.
   */
  objects?: string[];
  /**
   * @remarks
   * The policy ID.
   * 
   * @example
   * 1
   */
  policyId?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  /**
   * @remarks
   * The time when the policy takes effect.
   * 
   * The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2021-11-07T17:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The name of the policy template.
   * 
   * @example
   * promotion
   */
  template?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      name: 'Name',
      objects: 'Objects',
      policyId: 'PolicyId',
      requestId: 'RequestId',
      startTime: 'StartTime',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      name: 'string',
      objects: { 'type': 'array', 'itemType': 'string' },
      policyId: 'number',
      requestId: 'string',
      startTime: 'string',
      template: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCustomScenePolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateCustomScenePolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCustomScenePolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppRequest extends $tea.Model {
  /**
   * @remarks
   * The number of consecutive failed health checks required for an application to be considered as unhealthy. Valid values: 1 to 10. Default value: 5.
   * 
   * @example
   * 3
   */
  healthCheckFailTimes?: number;
  /**
   * @remarks
   * The domain name that is used for health checks. This parameter is empty by default.
   * 
   * @example
   * www.aliyun.com
   */
  healthCheckHost?: string;
  /**
   * @remarks
   * The HTTP status code returned for a successful health check. Valid values:
   * 
   * *   **http_2xx** (default)
   * *   **http_3xx**
   * 
   * @example
   * http_2xx
   */
  healthCheckHttpCode?: string;
  /**
   * @remarks
   * The interval between two consecutive health checks. Unit: seconds. Valid values: **1** to **50**. Default value: **5**.
   * 
   * @example
   * 5
   */
  healthCheckInterval?: number;
  /**
   * @remarks
   * The HTTP request method for health checks. Valid values:
   * 
   * *   **HEAD** (default): requests the headers of the resource.
   * *   **GET**: requests the specified resource and returns both the headers and entity body.
   * 
   * @example
   * HEAD
   */
  healthCheckMethod?: string;
  /**
   * @remarks
   * The port used for health checks. Valid values: 1 to 65535. Default value: 80.
   * 
   * @example
   * 80
   */
  healthCheckPort?: number;
  /**
   * @remarks
   * The number of consecutive successful health checks required for an application to be considered as healthy. Valid values: 1 to 10. Default value: 2.
   * 
   * @example
   * 2
   */
  healthCheckSuccTimes?: number;
  /**
   * @remarks
   * The timeout period of a health check response. If a backend ECS instance does not respond within the specified timeout period, the ECS instance fails the health check. Unit: seconds.\\
   * Valid values: **1** to **100**.\\
   * Default value: **3**.
   * 
   * @example
   * 5
   */
  healthCheckTimeout?: number;
  /**
   * @remarks
   * The health check type. By default, this parameter is left empty.
   * 
   * Valid values:
   * 
   * *   **l4**: Layer 4 health check.
   * *   **l7**: Layer 7 health check.
   * 
   * @example
   * l7
   */
  healthCheckType?: string;
  /**
   * @remarks
   * The URI used for health checks. The URI must be **1** to **80** characters in length. Default value: "/".
   * 
   * @example
   * /health_check
   */
  healthCheckURI?: string;
  /**
   * @remarks
   * The name of the application. The name must start with a lowercase letter and can contain lowercase letters, digits, and hyphens (-). The name must be 6 to 128 characters in length.
   * 
   * This parameter is required.
   * 
   * @example
   * app-test
   */
  name?: string;
  /**
   * @remarks
   * The remarks. This parameter is empty by default.
   * 
   * @example
   * test app
   */
  remarks?: string;
  /**
   * @remarks
   * The server port. Valid values: 1 to 65535.
   * 
   * This parameter is required.
   * 
   * @example
   * 80
   */
  servicePort?: number;
  /**
   * @remarks
   * The backend port, which is also the service port of the application. Valid values: 1 to 65535.
   * 
   * This parameter is required.
   * 
   * @example
   * 80
   */
  targetPort?: number;
  static names(): { [key: string]: string } {
    return {
      healthCheckFailTimes: 'HealthCheckFailTimes',
      healthCheckHost: 'HealthCheckHost',
      healthCheckHttpCode: 'HealthCheckHttpCode',
      healthCheckInterval: 'HealthCheckInterval',
      healthCheckMethod: 'HealthCheckMethod',
      healthCheckPort: 'HealthCheckPort',
      healthCheckSuccTimes: 'HealthCheckSuccTimes',
      healthCheckTimeout: 'HealthCheckTimeout',
      healthCheckType: 'HealthCheckType',
      healthCheckURI: 'HealthCheckURI',
      name: 'Name',
      remarks: 'Remarks',
      servicePort: 'ServicePort',
      targetPort: 'TargetPort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      healthCheckFailTimes: 'number',
      healthCheckHost: 'string',
      healthCheckHttpCode: 'string',
      healthCheckInterval: 'number',
      healthCheckMethod: 'string',
      healthCheckPort: 'number',
      healthCheckSuccTimes: 'number',
      healthCheckTimeout: 'number',
      healthCheckType: 'string',
      healthCheckURI: 'string',
      name: 'string',
      remarks: 'string',
      servicePort: 'number',
      targetPort: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the application that is created.
   * 
   * @example
   * app-880688675783794688
   */
  appId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateEdgeContainerAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEdgeContainerAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppRecordRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The associated domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * a.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 5407498413****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      recordName: 'RecordName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      recordName: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppRecordResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppRecordResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateEdgeContainerAppRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEdgeContainerAppRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppVersionRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The container group to be deployed for this version, which contains information about images.\\
   * The image data contains the image address, startup command, parameters, environment variables, and probe rules. You can specify one or more images. The parameter value is a JSON string.
   * 
   * This parameter is required.
   * 
   * @example
   * [
   *       {
   *             "Name": "container1",
   *             "Image": "image1",
   *             "Spec": "1C2G",
   *             "Command": "/bin/sh",
   *             "Args": "-c hello",
   *             "ProbeType": "tcpSocket",
   *             "ProbeContent": "{\\"Port\\":8080}"
   *       },
   *       {
   *             "Name": "container2",
   *             "Image": "image2",
   *             "Spec": "2C4G",
   *             "ProbeType": "httpGet",
   *             "ProbeContent": "{\\"Path\\":\\"/\\",\\"Port\\":80,\\"InitialDelaySeconds\\":10}"
   *       }
   * ]
   */
  containers?: CreateEdgeContainerAppVersionRequestContainers[];
  /**
   * @remarks
   * The version name, which must be 6 to 128 characters in length.
   * 
   * This parameter is required.
   * 
   * @example
   * verson1
   */
  name?: string;
  /**
   * @remarks
   * The description of the version.
   * 
   * @example
   * test app
   */
  remarks?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      containers: 'Containers',
      name: 'Name',
      remarks: 'Remarks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      containers: { 'type': 'array', 'itemType': CreateEdgeContainerAppVersionRequestContainers },
      name: 'string',
      remarks: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppVersionShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The container group to be deployed for this version, which contains information about images.\\
   * The image data contains the image address, startup command, parameters, environment variables, and probe rules. You can specify one or more images. The parameter value is a JSON string.
   * 
   * This parameter is required.
   * 
   * @example
   * [
   *       {
   *             "Name": "container1",
   *             "Image": "image1",
   *             "Spec": "1C2G",
   *             "Command": "/bin/sh",
   *             "Args": "-c hello",
   *             "ProbeType": "tcpSocket",
   *             "ProbeContent": "{\\"Port\\":8080}"
   *       },
   *       {
   *             "Name": "container2",
   *             "Image": "image2",
   *             "Spec": "2C4G",
   *             "ProbeType": "httpGet",
   *             "ProbeContent": "{\\"Path\\":\\"/\\",\\"Port\\":80,\\"InitialDelaySeconds\\":10}"
   *       }
   * ]
   */
  containersShrink?: string;
  /**
   * @remarks
   * The version name, which must be 6 to 128 characters in length.
   * 
   * This parameter is required.
   * 
   * @example
   * verson1
   */
  name?: string;
  /**
   * @remarks
   * The description of the version.
   * 
   * @example
   * test app
   */
  remarks?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      containersShrink: 'Containers',
      name: 'Name',
      remarks: 'Remarks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      containersShrink: 'string',
      name: 'string',
      remarks: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppVersionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the created version.
   * 
   * @example
   * ver-87962637161651****
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      versionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppVersionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateEdgeContainerAppVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEdgeContainerAppVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateKvNamespaceRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the namespace.
   * 
   * @example
   * this is a test namespace.
   */
  description?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateKvNamespaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The description of the namespace.
   * 
   * @example
   * this is a test namespace.
   */
  description?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 657717877171818496
   */
  namespaceId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the namespace. Valid values:
   * 
   * *   **online**: working as expected.
   * *   **delete**: pending deletion.
   * *   **deleting**: being deleted.
   * *   **deleted**: deleted.
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      namespace: 'Namespace',
      namespaceId: 'NamespaceId',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      namespace: 'string',
      namespaceId: 'string',
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateKvNamespaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateKvNamespaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateKvNamespaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateListRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the list that you want to create.
   * 
   * @example
   * a custom list
   */
  description?: string;
  /**
   * @remarks
   * The items in the list that you want to create.
   * 
   * @example
   * a custom list
   */
  items?: string[];
  /**
   * @remarks
   * The type of the list that you want to create.
   * 
   * @example
   * ip
   */
  kind?: string;
  /**
   * @remarks
   * The name of the list that you want to create.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      items: 'Items',
      kind: 'Kind',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      items: { 'type': 'array', 'itemType': 'string' },
      kind: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateListShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the list that you want to create.
   * 
   * @example
   * a custom list
   */
  description?: string;
  /**
   * @remarks
   * The items in the list that you want to create.
   * 
   * @example
   * a custom list
   */
  itemsShrink?: string;
  /**
   * @remarks
   * The type of the list that you want to create.
   * 
   * @example
   * ip
   */
  kind?: string;
  /**
   * @remarks
   * The name of the list that you want to create.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      itemsShrink: 'Items',
      kind: 'Kind',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      itemsShrink: 'string',
      kind: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the custom list.[](~~2850217~~)
   * 
   * @example
   * 40000001
   */
  id?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOriginProtectionRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOriginProtectionResponseBody extends $tea.Model {
  /**
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOriginProtectionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOriginProtectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOriginProtectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePageRequest extends $tea.Model {
  /**
   * @remarks
   * The Base64-encoded page content. Example: "PGh0bWw+aGVsbG8gcGFnZTwvaHRtbD4=", which indicates "hello page".
   * 
   * @example
   * PGh0bWw+aGVsbG8gcGFnZTwvaHRtbD4=
   */
  content?: string;
  /**
   * @remarks
   * The Content-Type field in the HTTP header. Valid values:
   * 
   * *   text/html
   * *   application/json
   * 
   * This parameter is required.
   * 
   * @example
   * text/html
   */
  contentType?: string;
  /**
   * @remarks
   * The description of the page.
   * 
   * @example
   * a custom deny page
   */
  description?: string;
  /**
   * @remarks
   * The name of the custom error page.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      contentType: 'ContentType',
      description: 'Description',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      contentType: 'string',
      description: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the custom error page.[](~~2850223~~)
   * 
   * @example
   * 50000001
   */
  id?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRecordRequest extends $tea.Model {
  /**
   * @remarks
   * The origin authentication information of the CNAME record.
   */
  authConf?: CreateRecordRequestAuthConf;
  /**
   * @remarks
   * The business scenario of the record for acceleration. Leave the parameter empty if your record is not proxied. Valid values:
   * 
   * *   **image_video**: video and image.
   * *   **api**: API.
   * *   **web**: web page.
   * 
   * @example
   * web
   */
  bizName?: string;
  /**
   * @remarks
   * The comment of the record. The maximum length is 100 characters.
   * 
   * @example
   * This is a remark.
   */
  comment?: string;
  /**
   * @remarks
   * The DNS record information. The format of this field varies based on the record type. For more information, see [References](https://www.alibabacloud.com/help/doc-detail/2708761.html) .
   * 
   * This parameter is required.
   * 
   * @example
   * {
   *     "value":"2.2.2.2"
   * }
   */
  data?: CreateRecordRequestData;
  /**
   * @remarks
   * The origin host policy. This policy takes effect when the record type is CNAME. You can set the policy in two modes:
   * 
   * *   **follow_hostname**: Follow the host record.
   * *   **follow_origin_domain**: match the origin\\"s domain name.
   * 
   * @example
   * follow_origin_domain
   */
  hostPolicy?: string;
  /**
   * @remarks
   * Specifies whether to proxy the record. Only CNAME and A/AAAA records can be proxied. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  proxied?: boolean;
  /**
   * @remarks
   * The record name.
   * 
   * This parameter is required.
   * 
   * @example
   * www.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The origin type for the CNAME record. This parameter is required when you add a CNAME record. Valid values:
   * 
   * *   **OSS**: OSS bucket.
   * *   **S3**: S3 bucket.
   * *   **LB**: load balancer.
   * *   **OP**: origin pool.
   * *   **Domain**: domain name.
   * 
   * If you do not pass this parameter or if you leave its value empty, Domain is used by default.
   * 
   * @example
   * OSS
   */
  sourceType?: string;
  /**
   * @remarks
   * The TTL of the record. Unit: seconds. If the value is 1, the TTL of the record is determined by the system.
   * 
   * @example
   * 30
   */
  ttl?: number;
  /**
   * @remarks
   * The type of the DNS record. For example, A/AAAA, TXT, MX, or CNAME.
   * 
   * This parameter is required.
   * 
   * @example
   * A/AAAA
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      authConf: 'AuthConf',
      bizName: 'BizName',
      comment: 'Comment',
      data: 'Data',
      hostPolicy: 'HostPolicy',
      proxied: 'Proxied',
      recordName: 'RecordName',
      siteId: 'SiteId',
      sourceType: 'SourceType',
      ttl: 'Ttl',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authConf: CreateRecordRequestAuthConf,
      bizName: 'string',
      comment: 'string',
      data: CreateRecordRequestData,
      hostPolicy: 'string',
      proxied: 'boolean',
      recordName: 'string',
      siteId: 'number',
      sourceType: 'string',
      ttl: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRecordShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The origin authentication information of the CNAME record.
   */
  authConfShrink?: string;
  /**
   * @remarks
   * The business scenario of the record for acceleration. Leave the parameter empty if your record is not proxied. Valid values:
   * 
   * *   **image_video**: video and image.
   * *   **api**: API.
   * *   **web**: web page.
   * 
   * @example
   * web
   */
  bizName?: string;
  /**
   * @remarks
   * The comment of the record. The maximum length is 100 characters.
   * 
   * @example
   * This is a remark.
   */
  comment?: string;
  /**
   * @remarks
   * The DNS record information. The format of this field varies based on the record type. For more information, see [References](https://www.alibabacloud.com/help/doc-detail/2708761.html) .
   * 
   * This parameter is required.
   * 
   * @example
   * {
   *     "value":"2.2.2.2"
   * }
   */
  dataShrink?: string;
  /**
   * @remarks
   * The origin host policy. This policy takes effect when the record type is CNAME. You can set the policy in two modes:
   * 
   * *   **follow_hostname**: Follow the host record.
   * *   **follow_origin_domain**: match the origin\\"s domain name.
   * 
   * @example
   * follow_origin_domain
   */
  hostPolicy?: string;
  /**
   * @remarks
   * Specifies whether to proxy the record. Only CNAME and A/AAAA records can be proxied. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  proxied?: boolean;
  /**
   * @remarks
   * The record name.
   * 
   * This parameter is required.
   * 
   * @example
   * www.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The origin type for the CNAME record. This parameter is required when you add a CNAME record. Valid values:
   * 
   * *   **OSS**: OSS bucket.
   * *   **S3**: S3 bucket.
   * *   **LB**: load balancer.
   * *   **OP**: origin pool.
   * *   **Domain**: domain name.
   * 
   * If you do not pass this parameter or if you leave its value empty, Domain is used by default.
   * 
   * @example
   * OSS
   */
  sourceType?: string;
  /**
   * @remarks
   * The TTL of the record. Unit: seconds. If the value is 1, the TTL of the record is determined by the system.
   * 
   * @example
   * 30
   */
  ttl?: number;
  /**
   * @remarks
   * The type of the DNS record. For example, A/AAAA, TXT, MX, or CNAME.
   * 
   * This parameter is required.
   * 
   * @example
   * A/AAAA
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      authConfShrink: 'AuthConf',
      bizName: 'BizName',
      comment: 'Comment',
      dataShrink: 'Data',
      hostPolicy: 'HostPolicy',
      proxied: 'Proxied',
      recordName: 'RecordName',
      siteId: 'SiteId',
      sourceType: 'SourceType',
      ttl: 'Ttl',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authConfShrink: 'string',
      bizName: 'string',
      comment: 'string',
      dataShrink: 'string',
      hostPolicy: 'string',
      proxied: 'boolean',
      recordName: 'string',
      siteId: 'number',
      sourceType: 'string',
      ttl: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRecordResponseBody extends $tea.Model {
  /**
   * @remarks
   * The record ID.
   * 
   * @example
   * 1234567890123
   */
  recordId?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F61CDR30-E83C-4FDA-BF73-9A94CDD44229
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recordId: 'RecordId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordId: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRecordResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineRequest extends $tea.Model {
  /**
   * @remarks
   * The routine description.
   * 
   * @example
   * the description of this routine
   */
  description?: string;
  /**
   * @remarks
   * The routine name, which must be unique in the same account.
   * 
   * @example
   * test-routine1
   */
  name?: string;
  /**
   * @remarks
   * The specification of the routine.
   * 
   * @example
   * 5ms
   */
  specName?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      specName: 'SpecName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      specName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the operation is successful.
   * 
   * @example
   * OK
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateRoutineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRoutineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineRelatedRecordRequest extends $tea.Model {
  /**
   * @remarks
   * The routine name.
   * 
   * @example
   * CreateRoutineRelatedRecord
   */
  name?: string;
  /**
   * @remarks
   * The record name.
   * 
   * @example
   * test-record-1.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 54362329990032
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      recordName: 'RecordName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      recordName: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineRelatedRecordResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the operation is successful.
   * 
   * @example
   * OK
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineRelatedRecordResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateRoutineRelatedRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRoutineRelatedRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineRelatedRouteRequest extends $tea.Model {
  /**
   * @remarks
   * The routine name.
   * 
   * @example
   * CreateRoutineRelatedRoute
   */
  name?: string;
  /**
   * @remarks
   * The route.
   * 
   * @example
   * *.example.com/path1*
   */
  route?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 54362329990032
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      route: 'Route',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      route: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineRelatedRouteResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the operation is successful.
   * 
   * @example
   * OK
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineRelatedRouteResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateRoutineRelatedRouteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRoutineRelatedRouteResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduledPreloadExecutionsRequest extends $tea.Model {
  /**
   * @remarks
   * The scheduled prefetch plans to create.
   * 
   * This parameter is required.
   */
  executions?: CreateScheduledPreloadExecutionsRequestExecutions[];
  /**
   * @remarks
   * The ID of the prefetch task, which is generated by calling the [CreateScheduledPreloadJob](https://help.aliyun.com/document_detail/2850459.html) operation.
   * 
   * @example
   * CreateScheduledPreloadExecutions
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      executions: 'Executions',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      executions: { 'type': 'array', 'itemType': CreateScheduledPreloadExecutionsRequestExecutions },
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduledPreloadExecutionsShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The scheduled prefetch plans to create.
   * 
   * This parameter is required.
   */
  executionsShrink?: string;
  /**
   * @remarks
   * The ID of the prefetch task, which is generated by calling the [CreateScheduledPreloadJob](https://help.aliyun.com/document_detail/2850459.html) operation.
   * 
   * @example
   * CreateScheduledPreloadExecutions
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      executionsShrink: 'Executions',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      executionsShrink: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduledPreloadExecutionsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about prefetch plans that failed to be created.
   */
  failedExecutions?: CreateScheduledPreloadExecutionsResponseBodyFailedExecutions[];
  /**
   * @remarks
   * The information about plan failures.
   */
  failedMessages?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F61CDR30-E83C-4FDA-BF73-9A94CDD44229
   */
  requestId?: string;
  /**
   * @remarks
   * The number of prefetch plans that are created.
   * 
   * @example
   * 12
   */
  successCount?: number;
  /**
   * @remarks
   * The information about created prefetch plans.
   */
  successExecutions?: CreateScheduledPreloadExecutionsResponseBodySuccessExecutions[];
  /**
   * @remarks
   * The total number of new plans requested.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      failedExecutions: 'FailedExecutions',
      failedMessages: 'FailedMessages',
      requestId: 'RequestId',
      successCount: 'SuccessCount',
      successExecutions: 'SuccessExecutions',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedExecutions: { 'type': 'array', 'itemType': CreateScheduledPreloadExecutionsResponseBodyFailedExecutions },
      failedMessages: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
      successCount: 'number',
      successExecutions: { 'type': 'array', 'itemType': CreateScheduledPreloadExecutionsResponseBodySuccessExecutions },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduledPreloadExecutionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateScheduledPreloadExecutionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateScheduledPreloadExecutionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduledPreloadJobRequest extends $tea.Model {
  /**
   * @remarks
   * The method to submit URLs to be prefetched.
   * 
   * Valid values:
   * 
   * *   **textBox**
   * *   **oss**
   * 
   * This parameter is required.
   * 
   * @example
   * oss
   */
  insertWay?: string;
  /**
   * @remarks
   * The name of the scheduled prefetch task.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The URL of the OSS object that stores the URLs to be prefetched.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  ossUrl?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 190007158391808
   */
  siteId?: number;
  /**
   * @remarks
   * The URLs to be prefetched. This parameter is required if you set InsertWay to textBox.
   * 
   * @example
   * http://testurl.com/a.txt
   * http://testurl.com/b.txt
   */
  urlList?: string;
  static names(): { [key: string]: string } {
    return {
      insertWay: 'InsertWay',
      name: 'Name',
      ossUrl: 'OssUrl',
      siteId: 'SiteId',
      urlList: 'UrlList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      insertWay: 'string',
      name: 'string',
      ossUrl: 'string',
      siteId: 'number',
      urlList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduledPreloadJobResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 15685865xxx14622
   */
  aliUid?: string;
  /**
   * @remarks
   * The time when the task was created.
   * 
   * @example
   * 2023-06-05T10:04:20+0800
   */
  createdAt?: string;
  /**
   * @remarks
   * The domain names to be prefetched.
   * 
   * @example
   * testurl.com
   */
  domains?: string;
  /**
   * @remarks
   * The error message. Multiple error messages are separated by commas (,). Valid values:
   * 
   * *   **InvalidUrl**: The URL format is invalid.
   * *   **InvalidDomain**: The domain name fails the domain ownership verification.
   * *   **QuotaExcess**: the quota limit has been reached.
   * *   **OtherErrors**: other errors.
   * 
   * @example
   * InvalidDomain
   */
  errorInfo?: string;
  /**
   * @remarks
   * The URL of the OSS object that stores a list of URLs that failed the conditional check for prefetching.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  failedFileOss?: string;
  /**
   * @remarks
   * The ID of the URL list file, which can be used during downloads.
   * 
   * @example
   * 665d3b48621bccf3fe29e1a7
   */
  fileId?: string;
  /**
   * @remarks
   * The ID of the scheduled prefetch task.
   * 
   * @example
   * 665d3af3621bccf3fe29e1a4
   */
  id?: string;
  /**
   * @remarks
   * The method to submit the URLs to be prefetched.
   * 
   * @example
   * oss
   */
  insertWay?: string;
  /**
   * @remarks
   * The task name.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247B78
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 190007158391808
   */
  siteId?: number;
  /**
   * @remarks
   * The number of submitted prefetch tasks.
   * 
   * @example
   * 1
   */
  taskSubmitted?: number;
  /**
   * @remarks
   * The task type (refresh or preload).
   * 
   * @example
   * preload
   */
  taskType?: string;
  /**
   * @remarks
   * The total number of URLs.
   * 
   * @example
   * 2
   */
  urlCount?: number;
  /**
   * @remarks
   * The number of submitted URLs.
   * 
   * @example
   * 1
   */
  urlSubmitted?: number;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      createdAt: 'CreatedAt',
      domains: 'Domains',
      errorInfo: 'ErrorInfo',
      failedFileOss: 'FailedFileOss',
      fileId: 'FileId',
      id: 'Id',
      insertWay: 'InsertWay',
      name: 'Name',
      requestId: 'RequestId',
      siteId: 'SiteId',
      taskSubmitted: 'TaskSubmitted',
      taskType: 'TaskType',
      urlCount: 'UrlCount',
      urlSubmitted: 'UrlSubmitted',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'string',
      createdAt: 'string',
      domains: 'string',
      errorInfo: 'string',
      failedFileOss: 'string',
      fileId: 'string',
      id: 'string',
      insertWay: 'string',
      name: 'string',
      requestId: 'string',
      siteId: 'number',
      taskSubmitted: 'number',
      taskType: 'string',
      urlCount: 'number',
      urlSubmitted: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduledPreloadJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateScheduledPreloadJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateScheduledPreloadJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteRequest extends $tea.Model {
  /**
   * @remarks
   * The DNS setup. Valid values:
   * 
   * *   **NS**
   * *   **CNAME**
   * 
   * This parameter is required.
   * 
   * @example
   * NS
   */
  accessType?: string;
  /**
   * @remarks
   * The service location. Valid values:
   * 
   * *   **domestic**: the Chinese mainland
   * *   **global**: global
   * *   **overseas**: outside the Chinese mainland
   * 
   * This parameter is required.
   * 
   * @example
   * domestic
   */
  coverage?: string;
  /**
   * @remarks
   * The instance ID, which can be obtained by calling the [ListUserRatePlanInstances](https://help.aliyun.com/document_detail/2852398.html) operation. Specify at least one of the instance ID and website ID. If you specify both of them, the instance ID is used.
   * 
   * This parameter is required.
   * 
   * @example
   * dbaudit-cn-nwy349jdb03
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the resource group. If you leave this parameter empty, the system uses the default resource group ID.
   * 
   * @example
   * rg-acfmw4znnok****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The website name.
   * 
   * This parameter is required.
   * 
   * @example
   * CreateSite
   */
  siteName?: string;
  static names(): { [key: string]: string } {
    return {
      accessType: 'AccessType',
      coverage: 'Coverage',
      instanceId: 'InstanceId',
      resourceGroupId: 'ResourceGroupId',
      siteName: 'SiteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessType: 'string',
      coverage: 'string',
      instanceId: 'string',
      resourceGroupId: 'string',
      siteName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteResponseBody extends $tea.Model {
  /**
   * @remarks
   * The nameservers assigned by ESA. The values are separated by commas (,). This parameter is returned if you set AccessType to NS. In this case, you must change the nameservers of your domain to the assigned ones. Then, you can verify the domain ownership and activate your website.
   * 
   * @example
   * ns1.example.com,ns2.example.com
   */
  nameServerList?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-3C82-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The verification code for the website. If you set AccessType to CNAME, you need to add a TXT record whose hostname is **_esaauth.[websiteDomainName]** and record value is the value of VerifyCode to the DNS records of your domain. ****Then, you can verify the domain ownership and activate your website.
   * 
   * @example
   * verify_aah9dioasmov****
   */
  verifyCode?: string;
  static names(): { [key: string]: string } {
    return {
      nameServerList: 'NameServerList',
      requestId: 'RequestId',
      siteId: 'SiteId',
      verifyCode: 'VerifyCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameServerList: 'string',
      requestId: 'string',
      siteId: 'number',
      verifyCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSiteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSiteResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteCustomLogRequest extends $tea.Model {
  /**
   * @remarks
   * The cookie fields.
   */
  cookies?: string[];
  /**
   * @remarks
   * The request header fields.
   */
  requestHeaders?: string[];
  /**
   * @remarks
   * The response header fields.
   */
  responseHeaders?: string[];
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 11223
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      cookies: 'Cookies',
      requestHeaders: 'RequestHeaders',
      responseHeaders: 'ResponseHeaders',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cookies: { 'type': 'array', 'itemType': 'string' },
      requestHeaders: { 'type': 'array', 'itemType': 'string' },
      responseHeaders: { 'type': 'array', 'itemType': 'string' },
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteCustomLogShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The cookie fields.
   */
  cookiesShrink?: string;
  /**
   * @remarks
   * The request header fields.
   */
  requestHeadersShrink?: string;
  /**
   * @remarks
   * The response header fields.
   */
  responseHeadersShrink?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 11223
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      cookiesShrink: 'Cookies',
      requestHeadersShrink: 'RequestHeaders',
      responseHeadersShrink: 'ResponseHeaders',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cookiesShrink: 'string',
      requestHeadersShrink: 'string',
      responseHeadersShrink: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteCustomLogResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 073bd613-6e72-4461-b6bc-19326dfc6a9c
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteCustomLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSiteCustomLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSiteCustomLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteDeliveryTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   **dcdn_log_access_l1** (default): access logs.
   * *   **dcdn_log_er**: Edge Routine logs.
   * *   **dcdn_log_waf**: firewall logs.
   * *   **dcdn_log_ipa**: TCP/UDP proxy logs.
   * 
   * This parameter is required.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The data center. Valid values:
   * 
   * *   cn: the Chinese mainland.
   * *   oversea: outside the Chinese mainland.
   * 
   * This parameter is required.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The destination of the delivery. Valid values:
   * 
   * *   sls: Alibaba Cloud Simple Log Service (SLS).
   * *   http: HTTP server.
   * *   aws3: Amazon Simple Storage Service (S3).
   * *   oss: Alibaba Cloud Object Storage Service (OSS).
   * *   kafka: Kafka.
   * *   aws3cmpt: S3-compatible storage service.
   * 
   * This parameter is required.
   * 
   * @example
   * sls
   */
  deliveryType?: string;
  /**
   * @remarks
   * The discard rate. Default value: 0.
   * 
   * @example
   * 0.0
   */
  discardRate?: number;
  /**
   * @remarks
   * The log fields, which are separated by commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * user_agent,ip_adress,ip_port
   */
  fieldName?: string;
  /**
   * @remarks
   * The configurations for delivery to an HTTP server.
   */
  httpDelivery?: CreateSiteDeliveryTaskRequestHttpDelivery;
  /**
   * @remarks
   * The configurations for delivery to Kafka.
   */
  kafkaDelivery?: CreateSiteDeliveryTaskRequestKafkaDelivery;
  /**
   * @remarks
   * The configurations for delivery to OSS.
   */
  ossDelivery?: CreateSiteDeliveryTaskRequestOssDelivery;
  /**
   * @remarks
   * The configurations for delivery to Amazon S3 or an S3-compatible service.
   */
  s3Delivery?: CreateSiteDeliveryTaskRequestS3Delivery;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 12312312112***
   */
  siteId?: number;
  /**
   * @remarks
   * The configurations for delivery to SLS.
   */
  slsDelivery?: CreateSiteDeliveryTaskRequestSlsDelivery;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * dcdn-test-task
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      dataCenter: 'DataCenter',
      deliveryType: 'DeliveryType',
      discardRate: 'DiscardRate',
      fieldName: 'FieldName',
      httpDelivery: 'HttpDelivery',
      kafkaDelivery: 'KafkaDelivery',
      ossDelivery: 'OssDelivery',
      s3Delivery: 'S3Delivery',
      siteId: 'SiteId',
      slsDelivery: 'SlsDelivery',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      dataCenter: 'string',
      deliveryType: 'string',
      discardRate: 'number',
      fieldName: 'string',
      httpDelivery: CreateSiteDeliveryTaskRequestHttpDelivery,
      kafkaDelivery: CreateSiteDeliveryTaskRequestKafkaDelivery,
      ossDelivery: CreateSiteDeliveryTaskRequestOssDelivery,
      s3Delivery: CreateSiteDeliveryTaskRequestS3Delivery,
      siteId: 'number',
      slsDelivery: CreateSiteDeliveryTaskRequestSlsDelivery,
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteDeliveryTaskShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   **dcdn_log_access_l1** (default): access logs.
   * *   **dcdn_log_er**: Edge Routine logs.
   * *   **dcdn_log_waf**: firewall logs.
   * *   **dcdn_log_ipa**: TCP/UDP proxy logs.
   * 
   * This parameter is required.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The data center. Valid values:
   * 
   * *   cn: the Chinese mainland.
   * *   oversea: outside the Chinese mainland.
   * 
   * This parameter is required.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The destination of the delivery. Valid values:
   * 
   * *   sls: Alibaba Cloud Simple Log Service (SLS).
   * *   http: HTTP server.
   * *   aws3: Amazon Simple Storage Service (S3).
   * *   oss: Alibaba Cloud Object Storage Service (OSS).
   * *   kafka: Kafka.
   * *   aws3cmpt: S3-compatible storage service.
   * 
   * This parameter is required.
   * 
   * @example
   * sls
   */
  deliveryType?: string;
  /**
   * @remarks
   * The discard rate. Default value: 0.
   * 
   * @example
   * 0.0
   */
  discardRate?: number;
  /**
   * @remarks
   * The log fields, which are separated by commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * user_agent,ip_adress,ip_port
   */
  fieldName?: string;
  /**
   * @remarks
   * The configurations for delivery to an HTTP server.
   */
  httpDeliveryShrink?: string;
  /**
   * @remarks
   * The configurations for delivery to Kafka.
   */
  kafkaDeliveryShrink?: string;
  /**
   * @remarks
   * The configurations for delivery to OSS.
   */
  ossDeliveryShrink?: string;
  /**
   * @remarks
   * The configurations for delivery to Amazon S3 or an S3-compatible service.
   */
  s3DeliveryShrink?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 12312312112***
   */
  siteId?: number;
  /**
   * @remarks
   * The configurations for delivery to SLS.
   */
  slsDeliveryShrink?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * dcdn-test-task
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      dataCenter: 'DataCenter',
      deliveryType: 'DeliveryType',
      discardRate: 'DiscardRate',
      fieldName: 'FieldName',
      httpDeliveryShrink: 'HttpDelivery',
      kafkaDeliveryShrink: 'KafkaDelivery',
      ossDeliveryShrink: 'OssDelivery',
      s3DeliveryShrink: 'S3Delivery',
      siteId: 'SiteId',
      slsDeliveryShrink: 'SlsDelivery',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      dataCenter: 'string',
      deliveryType: 'string',
      discardRate: 'number',
      fieldName: 'string',
      httpDeliveryShrink: 'string',
      kafkaDeliveryShrink: 'string',
      ossDeliveryShrink: 'string',
      s3DeliveryShrink: 'string',
      siteId: 'number',
      slsDeliveryShrink: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteDeliveryTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data center. Valid values:
   * 
   * *   cn: the Chinese mainland.
   * *   oversea: outside the Chinese mainland.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9358E852-992D-5BC7-8BD7-975CA02773A8
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.[](~~2850189~~)
   * 
   * @example
   * 123456****
   */
  siteId?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * @example
   * er-oss
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      dataCenter: 'DataCenter',
      requestId: 'RequestId',
      siteId: 'SiteId',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataCenter: 'string',
      requestId: 'string',
      siteId: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteDeliveryTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSiteDeliveryTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSiteDeliveryTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequest extends $tea.Model {
  cacheReserve?: CreateSiteFunctionRequestCacheReserve[];
  cacheRules?: CreateSiteFunctionRequestCacheRules[];
  cacheTags?: CreateSiteFunctionRequestCacheTags[];
  cnameFlattening?: CreateSiteFunctionRequestCnameFlattening[];
  compressionRules?: CreateSiteFunctionRequestCompressionRules[];
  crossBorderOptimization?: CreateSiteFunctionRequestCrossBorderOptimization[];
  developmentMode?: CreateSiteFunctionRequestDevelopmentMode[];
  httpRequestHeaderModificationRules?: CreateSiteFunctionRequestHttpRequestHeaderModificationRules[];
  httpResponseHeaderModificationRules?: CreateSiteFunctionRequestHttpResponseHeaderModificationRules[];
  httpsApplicationConfiguration?: CreateSiteFunctionRequestHttpsApplicationConfiguration[];
  httpsBasicConfiguration?: CreateSiteFunctionRequestHttpsBasicConfiguration[];
  imageTransform?: CreateSiteFunctionRequestImageTransform[];
  ipv6?: CreateSiteFunctionRequestIpv6[];
  managedTransforms?: CreateSiteFunctionRequestManagedTransforms[];
  networkOptimization?: CreateSiteFunctionRequestNetworkOptimization[];
  originProtection?: CreateSiteFunctionRequestOriginProtection[];
  originRules?: CreateSiteFunctionRequestOriginRules[];
  redirectRules?: CreateSiteFunctionRequestRedirectRules[];
  rewriteUrlRules?: CreateSiteFunctionRequestRewriteUrlRules[];
  seoBypass?: CreateSiteFunctionRequestSeoBypass[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * CreateSiteFunction
   */
  siteId?: number;
  siteNameExclusive?: CreateSiteFunctionRequestSiteNameExclusive[];
  sitePause?: CreateSiteFunctionRequestSitePause[];
  siteVersion?: number;
  tieredCache?: CreateSiteFunctionRequestTieredCache[];
  static names(): { [key: string]: string } {
    return {
      cacheReserve: 'CacheReserve',
      cacheRules: 'CacheRules',
      cacheTags: 'CacheTags',
      cnameFlattening: 'CnameFlattening',
      compressionRules: 'CompressionRules',
      crossBorderOptimization: 'CrossBorderOptimization',
      developmentMode: 'DevelopmentMode',
      httpRequestHeaderModificationRules: 'HttpRequestHeaderModificationRules',
      httpResponseHeaderModificationRules: 'HttpResponseHeaderModificationRules',
      httpsApplicationConfiguration: 'HttpsApplicationConfiguration',
      httpsBasicConfiguration: 'HttpsBasicConfiguration',
      imageTransform: 'ImageTransform',
      ipv6: 'Ipv6',
      managedTransforms: 'ManagedTransforms',
      networkOptimization: 'NetworkOptimization',
      originProtection: 'OriginProtection',
      originRules: 'OriginRules',
      redirectRules: 'RedirectRules',
      rewriteUrlRules: 'RewriteUrlRules',
      seoBypass: 'SeoBypass',
      siteId: 'SiteId',
      siteNameExclusive: 'SiteNameExclusive',
      sitePause: 'SitePause',
      siteVersion: 'SiteVersion',
      tieredCache: 'TieredCache',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheReserve: { 'type': 'array', 'itemType': CreateSiteFunctionRequestCacheReserve },
      cacheRules: { 'type': 'array', 'itemType': CreateSiteFunctionRequestCacheRules },
      cacheTags: { 'type': 'array', 'itemType': CreateSiteFunctionRequestCacheTags },
      cnameFlattening: { 'type': 'array', 'itemType': CreateSiteFunctionRequestCnameFlattening },
      compressionRules: { 'type': 'array', 'itemType': CreateSiteFunctionRequestCompressionRules },
      crossBorderOptimization: { 'type': 'array', 'itemType': CreateSiteFunctionRequestCrossBorderOptimization },
      developmentMode: { 'type': 'array', 'itemType': CreateSiteFunctionRequestDevelopmentMode },
      httpRequestHeaderModificationRules: { 'type': 'array', 'itemType': CreateSiteFunctionRequestHttpRequestHeaderModificationRules },
      httpResponseHeaderModificationRules: { 'type': 'array', 'itemType': CreateSiteFunctionRequestHttpResponseHeaderModificationRules },
      httpsApplicationConfiguration: { 'type': 'array', 'itemType': CreateSiteFunctionRequestHttpsApplicationConfiguration },
      httpsBasicConfiguration: { 'type': 'array', 'itemType': CreateSiteFunctionRequestHttpsBasicConfiguration },
      imageTransform: { 'type': 'array', 'itemType': CreateSiteFunctionRequestImageTransform },
      ipv6: { 'type': 'array', 'itemType': CreateSiteFunctionRequestIpv6 },
      managedTransforms: { 'type': 'array', 'itemType': CreateSiteFunctionRequestManagedTransforms },
      networkOptimization: { 'type': 'array', 'itemType': CreateSiteFunctionRequestNetworkOptimization },
      originProtection: { 'type': 'array', 'itemType': CreateSiteFunctionRequestOriginProtection },
      originRules: { 'type': 'array', 'itemType': CreateSiteFunctionRequestOriginRules },
      redirectRules: { 'type': 'array', 'itemType': CreateSiteFunctionRequestRedirectRules },
      rewriteUrlRules: { 'type': 'array', 'itemType': CreateSiteFunctionRequestRewriteUrlRules },
      seoBypass: { 'type': 'array', 'itemType': CreateSiteFunctionRequestSeoBypass },
      siteId: 'number',
      siteNameExclusive: { 'type': 'array', 'itemType': CreateSiteFunctionRequestSiteNameExclusive },
      sitePause: { 'type': 'array', 'itemType': CreateSiteFunctionRequestSitePause },
      siteVersion: 'number',
      tieredCache: { 'type': 'array', 'itemType': CreateSiteFunctionRequestTieredCache },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionShrinkRequest extends $tea.Model {
  cacheReserveShrink?: string;
  cacheRulesShrink?: string;
  cacheTagsShrink?: string;
  cnameFlatteningShrink?: string;
  compressionRulesShrink?: string;
  crossBorderOptimizationShrink?: string;
  developmentModeShrink?: string;
  httpRequestHeaderModificationRulesShrink?: string;
  httpResponseHeaderModificationRulesShrink?: string;
  httpsApplicationConfigurationShrink?: string;
  httpsBasicConfigurationShrink?: string;
  imageTransformShrink?: string;
  ipv6Shrink?: string;
  managedTransformsShrink?: string;
  networkOptimizationShrink?: string;
  originProtectionShrink?: string;
  originRulesShrink?: string;
  redirectRulesShrink?: string;
  rewriteUrlRulesShrink?: string;
  seoBypassShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * CreateSiteFunction
   */
  siteId?: number;
  siteNameExclusiveShrink?: string;
  sitePauseShrink?: string;
  siteVersion?: number;
  tieredCacheShrink?: string;
  static names(): { [key: string]: string } {
    return {
      cacheReserveShrink: 'CacheReserve',
      cacheRulesShrink: 'CacheRules',
      cacheTagsShrink: 'CacheTags',
      cnameFlatteningShrink: 'CnameFlattening',
      compressionRulesShrink: 'CompressionRules',
      crossBorderOptimizationShrink: 'CrossBorderOptimization',
      developmentModeShrink: 'DevelopmentMode',
      httpRequestHeaderModificationRulesShrink: 'HttpRequestHeaderModificationRules',
      httpResponseHeaderModificationRulesShrink: 'HttpResponseHeaderModificationRules',
      httpsApplicationConfigurationShrink: 'HttpsApplicationConfiguration',
      httpsBasicConfigurationShrink: 'HttpsBasicConfiguration',
      imageTransformShrink: 'ImageTransform',
      ipv6Shrink: 'Ipv6',
      managedTransformsShrink: 'ManagedTransforms',
      networkOptimizationShrink: 'NetworkOptimization',
      originProtectionShrink: 'OriginProtection',
      originRulesShrink: 'OriginRules',
      redirectRulesShrink: 'RedirectRules',
      rewriteUrlRulesShrink: 'RewriteUrlRules',
      seoBypassShrink: 'SeoBypass',
      siteId: 'SiteId',
      siteNameExclusiveShrink: 'SiteNameExclusive',
      sitePauseShrink: 'SitePause',
      siteVersion: 'SiteVersion',
      tieredCacheShrink: 'TieredCache',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheReserveShrink: 'string',
      cacheRulesShrink: 'string',
      cacheTagsShrink: 'string',
      cnameFlatteningShrink: 'string',
      compressionRulesShrink: 'string',
      crossBorderOptimizationShrink: 'string',
      developmentModeShrink: 'string',
      httpRequestHeaderModificationRulesShrink: 'string',
      httpResponseHeaderModificationRulesShrink: 'string',
      httpsApplicationConfigurationShrink: 'string',
      httpsBasicConfigurationShrink: 'string',
      imageTransformShrink: 'string',
      ipv6Shrink: 'string',
      managedTransformsShrink: 'string',
      networkOptimizationShrink: 'string',
      originProtectionShrink: 'string',
      originRulesShrink: 'string',
      redirectRulesShrink: 'string',
      rewriteUrlRulesShrink: 'string',
      seoBypassShrink: 'string',
      siteId: 'number',
      siteNameExclusiveShrink: 'string',
      sitePauseShrink: 'string',
      siteVersion: 'number',
      tieredCacheShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBody extends $tea.Model {
  configs?: CreateSiteFunctionResponseBodyConfigs;
  /**
   * @remarks
   * Id of the request
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: CreateSiteFunctionResponseBodyConfigs,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSiteFunctionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSiteFunctionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserDeliveryTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   dcdn_log_access_l1 (default): access logs.
   * *   dcdn_log_er: Edge Routine logs.
   * *   dcdn_log_waf: firewall logs.
   * *   dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * This parameter is required.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The data center. Valid values:
   * 
   * *   cn: the Chinese mainland.
   * *   sg: outside the Chinese mainland.
   * 
   * This parameter is required.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The destination of the delivery. Valid values:
   * 
   * 1.  sls: Alibaba Cloud SLS.
   * 2.  http: HTTP server.
   * 3.  aws3: Amazon S3.
   * 4.  oss: Alibaba Cloud OSS.
   * 5.  kafka: Kafka.
   * 6.  aws3cmpt: S3-compatible storage service.
   * 
   * This parameter is required.
   * 
   * @example
   * sls
   */
  deliveryType?: string;
  /**
   * @remarks
   * The discard rate. Default value: 0.
   * 
   * @example
   * 0
   */
  discardRate?: number;
  /**
   * @remarks
   * The log field. If you specify multiple fields, separate them with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * user_agent,ip_address,ip_port
   */
  fieldName?: string;
  /**
   * @remarks
   * The configurations for delivery to an HTTP server.
   */
  httpDelivery?: CreateUserDeliveryTaskRequestHttpDelivery;
  /**
   * @remarks
   * The configurations for delivery to Kafka.
   */
  kafkaDelivery?: CreateUserDeliveryTaskRequestKafkaDelivery;
  /**
   * @remarks
   * The configurations for delivery to OSS.
   */
  ossDelivery?: CreateUserDeliveryTaskRequestOssDelivery;
  /**
   * @remarks
   * The configurations for delivery to Amazon S3 or an S3-compatible service.
   */
  s3Delivery?: CreateUserDeliveryTaskRequestS3Delivery;
  /**
   * @remarks
   * The configurations for delivery to SLS.
   */
  slsDelivery?: CreateUserDeliveryTaskRequestSlsDelivery;
  /**
   * @remarks
   * The task name.
   * 
   * This parameter is required.
   * 
   * @example
   * test_project
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      dataCenter: 'DataCenter',
      deliveryType: 'DeliveryType',
      discardRate: 'DiscardRate',
      fieldName: 'FieldName',
      httpDelivery: 'HttpDelivery',
      kafkaDelivery: 'KafkaDelivery',
      ossDelivery: 'OssDelivery',
      s3Delivery: 'S3Delivery',
      slsDelivery: 'SlsDelivery',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      dataCenter: 'string',
      deliveryType: 'string',
      discardRate: 'number',
      fieldName: 'string',
      httpDelivery: CreateUserDeliveryTaskRequestHttpDelivery,
      kafkaDelivery: CreateUserDeliveryTaskRequestKafkaDelivery,
      ossDelivery: CreateUserDeliveryTaskRequestOssDelivery,
      s3Delivery: CreateUserDeliveryTaskRequestS3Delivery,
      slsDelivery: CreateUserDeliveryTaskRequestSlsDelivery,
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserDeliveryTaskShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   dcdn_log_access_l1 (default): access logs.
   * *   dcdn_log_er: Edge Routine logs.
   * *   dcdn_log_waf: firewall logs.
   * *   dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * This parameter is required.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The data center. Valid values:
   * 
   * *   cn: the Chinese mainland.
   * *   sg: outside the Chinese mainland.
   * 
   * This parameter is required.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The destination of the delivery. Valid values:
   * 
   * 1.  sls: Alibaba Cloud SLS.
   * 2.  http: HTTP server.
   * 3.  aws3: Amazon S3.
   * 4.  oss: Alibaba Cloud OSS.
   * 5.  kafka: Kafka.
   * 6.  aws3cmpt: S3-compatible storage service.
   * 
   * This parameter is required.
   * 
   * @example
   * sls
   */
  deliveryType?: string;
  /**
   * @remarks
   * The discard rate. Default value: 0.
   * 
   * @example
   * 0
   */
  discardRate?: number;
  /**
   * @remarks
   * The log field. If you specify multiple fields, separate them with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * user_agent,ip_address,ip_port
   */
  fieldName?: string;
  /**
   * @remarks
   * The configurations for delivery to an HTTP server.
   */
  httpDeliveryShrink?: string;
  /**
   * @remarks
   * The configurations for delivery to Kafka.
   */
  kafkaDeliveryShrink?: string;
  /**
   * @remarks
   * The configurations for delivery to OSS.
   */
  ossDeliveryShrink?: string;
  /**
   * @remarks
   * The configurations for delivery to Amazon S3 or an S3-compatible service.
   */
  s3DeliveryShrink?: string;
  /**
   * @remarks
   * The configurations for delivery to SLS.
   */
  slsDeliveryShrink?: string;
  /**
   * @remarks
   * The task name.
   * 
   * This parameter is required.
   * 
   * @example
   * test_project
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      dataCenter: 'DataCenter',
      deliveryType: 'DeliveryType',
      discardRate: 'DiscardRate',
      fieldName: 'FieldName',
      httpDeliveryShrink: 'HttpDelivery',
      kafkaDeliveryShrink: 'KafkaDelivery',
      ossDeliveryShrink: 'OssDelivery',
      s3DeliveryShrink: 'S3Delivery',
      slsDeliveryShrink: 'SlsDelivery',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      dataCenter: 'string',
      deliveryType: 'string',
      discardRate: 'number',
      fieldName: 'string',
      httpDeliveryShrink: 'string',
      kafkaDeliveryShrink: 'string',
      ossDeliveryShrink: 'string',
      s3DeliveryShrink: 'string',
      slsDeliveryShrink: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserDeliveryTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data center. Valid values:
   * 
   * *   cn: the Chinese mainland.
   * *   sg: outside the Chinese mainland.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2CCD40B1-3F20-5FF0-8A67-E3F34B87744F
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the delivery task.
   * 
   * @example
   * online
   */
  status?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * @example
   * er-http
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      dataCenter: 'DataCenter',
      requestId: 'RequestId',
      status: 'Status',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataCenter: 'string',
      requestId: 'string',
      status: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserDeliveryTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateUserDeliveryTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateUserDeliveryTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWafRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The configuration of the rule that you want to create.
   */
  config?: WafRuleConfig;
  /**
   * @remarks
   * The WAF rule category.
   * 
   * This parameter is required.
   * 
   * @example
   * http_custom
   */
  phase?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      phase: 'Phase',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: WafRuleConfig,
      phase: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWafRuleShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The configuration of the rule that you want to create.
   */
  configShrink?: string;
  /**
   * @remarks
   * The WAF rule category.
   * 
   * This parameter is required.
   * 
   * @example
   * http_custom
   */
  phase?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configShrink: 'Config',
      phase: 'Phase',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configShrink: 'string',
      phase: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWafRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the WAF rule.[](~~2850237~~)
   * 
   * @example
   * 20000001
   */
  id?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the WAF ruleset.[](~~2850233~~)
   * 
   * @example
   * 10000001
   */
  rulesetId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
      rulesetId: 'RulesetId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      requestId: 'string',
      rulesetId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWafRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWafRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWafRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the custom cookie.
   * 
   * This parameter is required.
   * 
   * @example
   * __aliwaitingroom_example
   */
  cookieName?: string;
  /**
   * @remarks
   * The content of the custom waiting room page. You must specify this parameter if you set WaitingRoomType to custom. The content must be Base64-encoded.
   * 
   * @example
   * Hello%20world!
   */
  customPageHtml?: string;
  /**
   * @remarks
   * The description of the waiting room.
   */
  description?: string;
  /**
   * @remarks
   * Specifies whether to disable session renewal. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  disableSessionRenewalEnable?: string;
  /**
   * @remarks
   * Specifies whether to enable the waiting room. Valid values:
   * 
   * *   on
   * *   off
   * 
   * This parameter is required.
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * The hostname and path.
   * 
   * This parameter is required.
   */
  hostNameAndPath?: CreateWaitingRoomRequestHostNameAndPath[];
  /**
   * @remarks
   * Specifies whether to enable JSON response. If you set this parameter to on, a JSON body is returned for requests to the waiting room with the header Accept: application/json. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  jsonResponseEnable?: string;
  /**
   * @remarks
   * The language of the waiting room page. You must specify this parameter if you set WaitingRoomType to default. Valid values:
   * 
   * *   enus: English.
   * *   zhcn: Simplified Chinese.
   * *   zhhk: Traditional Chinese.
   * 
   * @example
   * enus
   */
  language?: string;
  /**
   * @remarks
   * The name of the waiting room.
   * 
   * This parameter is required.
   * 
   * @example
   * waitingroom_example
   */
  name?: string;
  /**
   * @remarks
   * The maximum number of new users per minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 200
   */
  newUsersPerMinute?: string;
  /**
   * @remarks
   * Specifies whether to queue all requests. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  queueAllEnable?: string;
  /**
   * @remarks
   * The queuing method. Valid values:
   * 
   * *   random: Users gain access to the origin randomly, regardless of the arrival time.
   * *   fifo: Users gain access to the origin in order of arrival.
   * *   passthrough: Users pass through the waiting room and go straight to the origin.
   * *   reject-all: Users are blocked from reaching the origin.
   * 
   * This parameter is required.
   * 
   * @example
   * fifo
   */
  queuingMethod?: string;
  /**
   * @remarks
   * The HTTP status code to return while a user is in the queue. Valid values:
   * 
   * *   200
   * *   202
   * *   429
   * 
   * This parameter is required.
   * 
   * @example
   * 200
   */
  queuingStatusCode?: string;
  /**
   * @remarks
   * The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.
   * 
   * This parameter is required.
   * 
   * @example
   * 5
   */
  sessionDuration?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The maximum number of active users.
   * 
   * This parameter is required.
   * 
   * @example
   * 300
   */
  totalActiveUsers?: string;
  /**
   * @remarks
   * The type of the waiting room. Valid values:
   * 
   * *   default
   * *   custom
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  waitingRoomType?: string;
  static names(): { [key: string]: string } {
    return {
      cookieName: 'CookieName',
      customPageHtml: 'CustomPageHtml',
      description: 'Description',
      disableSessionRenewalEnable: 'DisableSessionRenewalEnable',
      enable: 'Enable',
      hostNameAndPath: 'HostNameAndPath',
      jsonResponseEnable: 'JsonResponseEnable',
      language: 'Language',
      name: 'Name',
      newUsersPerMinute: 'NewUsersPerMinute',
      queueAllEnable: 'QueueAllEnable',
      queuingMethod: 'QueuingMethod',
      queuingStatusCode: 'QueuingStatusCode',
      sessionDuration: 'SessionDuration',
      siteId: 'SiteId',
      totalActiveUsers: 'TotalActiveUsers',
      waitingRoomType: 'WaitingRoomType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cookieName: 'string',
      customPageHtml: 'string',
      description: 'string',
      disableSessionRenewalEnable: 'string',
      enable: 'string',
      hostNameAndPath: { 'type': 'array', 'itemType': CreateWaitingRoomRequestHostNameAndPath },
      jsonResponseEnable: 'string',
      language: 'string',
      name: 'string',
      newUsersPerMinute: 'string',
      queueAllEnable: 'string',
      queuingMethod: 'string',
      queuingStatusCode: 'string',
      sessionDuration: 'string',
      siteId: 'number',
      totalActiveUsers: 'string',
      waitingRoomType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the custom cookie.
   * 
   * This parameter is required.
   * 
   * @example
   * __aliwaitingroom_example
   */
  cookieName?: string;
  /**
   * @remarks
   * The content of the custom waiting room page. You must specify this parameter if you set WaitingRoomType to custom. The content must be Base64-encoded.
   * 
   * @example
   * Hello%20world!
   */
  customPageHtml?: string;
  /**
   * @remarks
   * The description of the waiting room.
   */
  description?: string;
  /**
   * @remarks
   * Specifies whether to disable session renewal. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  disableSessionRenewalEnable?: string;
  /**
   * @remarks
   * Specifies whether to enable the waiting room. Valid values:
   * 
   * *   on
   * *   off
   * 
   * This parameter is required.
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * The hostname and path.
   * 
   * This parameter is required.
   */
  hostNameAndPathShrink?: string;
  /**
   * @remarks
   * Specifies whether to enable JSON response. If you set this parameter to on, a JSON body is returned for requests to the waiting room with the header Accept: application/json. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  jsonResponseEnable?: string;
  /**
   * @remarks
   * The language of the waiting room page. You must specify this parameter if you set WaitingRoomType to default. Valid values:
   * 
   * *   enus: English.
   * *   zhcn: Simplified Chinese.
   * *   zhhk: Traditional Chinese.
   * 
   * @example
   * enus
   */
  language?: string;
  /**
   * @remarks
   * The name of the waiting room.
   * 
   * This parameter is required.
   * 
   * @example
   * waitingroom_example
   */
  name?: string;
  /**
   * @remarks
   * The maximum number of new users per minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 200
   */
  newUsersPerMinute?: string;
  /**
   * @remarks
   * Specifies whether to queue all requests. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  queueAllEnable?: string;
  /**
   * @remarks
   * The queuing method. Valid values:
   * 
   * *   random: Users gain access to the origin randomly, regardless of the arrival time.
   * *   fifo: Users gain access to the origin in order of arrival.
   * *   passthrough: Users pass through the waiting room and go straight to the origin.
   * *   reject-all: Users are blocked from reaching the origin.
   * 
   * This parameter is required.
   * 
   * @example
   * fifo
   */
  queuingMethod?: string;
  /**
   * @remarks
   * The HTTP status code to return while a user is in the queue. Valid values:
   * 
   * *   200
   * *   202
   * *   429
   * 
   * This parameter is required.
   * 
   * @example
   * 200
   */
  queuingStatusCode?: string;
  /**
   * @remarks
   * The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.
   * 
   * This parameter is required.
   * 
   * @example
   * 5
   */
  sessionDuration?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The maximum number of active users.
   * 
   * This parameter is required.
   * 
   * @example
   * 300
   */
  totalActiveUsers?: string;
  /**
   * @remarks
   * The type of the waiting room. Valid values:
   * 
   * *   default
   * *   custom
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  waitingRoomType?: string;
  static names(): { [key: string]: string } {
    return {
      cookieName: 'CookieName',
      customPageHtml: 'CustomPageHtml',
      description: 'Description',
      disableSessionRenewalEnable: 'DisableSessionRenewalEnable',
      enable: 'Enable',
      hostNameAndPathShrink: 'HostNameAndPath',
      jsonResponseEnable: 'JsonResponseEnable',
      language: 'Language',
      name: 'Name',
      newUsersPerMinute: 'NewUsersPerMinute',
      queueAllEnable: 'QueueAllEnable',
      queuingMethod: 'QueuingMethod',
      queuingStatusCode: 'QueuingStatusCode',
      sessionDuration: 'SessionDuration',
      siteId: 'SiteId',
      totalActiveUsers: 'TotalActiveUsers',
      waitingRoomType: 'WaitingRoomType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cookieName: 'string',
      customPageHtml: 'string',
      description: 'string',
      disableSessionRenewalEnable: 'string',
      enable: 'string',
      hostNameAndPathShrink: 'string',
      jsonResponseEnable: 'string',
      language: 'string',
      name: 'string',
      newUsersPerMinute: 'string',
      queueAllEnable: 'string',
      queuingMethod: 'string',
      queuingStatusCode: 'string',
      sessionDuration: 'string',
      siteId: 'number',
      totalActiveUsers: 'string',
      waitingRoomType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 85H66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWaitingRoomResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWaitingRoomResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomEventRequest extends $tea.Model {
  /**
   * @remarks
   * The content of the custom waiting room page. You must specify this parameter if you set WaitingRoomType to custom. The content must be Base64-encoded.
   * 
   * @example
   * Hello%20world!
   */
  customPageHtml?: string;
  /**
   * @remarks
   * The description of the waiting room.
   */
  description?: string;
  /**
   * @remarks
   * Specifies whether to disable session renewal. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  disableSessionRenewalEnable?: string;
  /**
   * @remarks
   * Specifies whether to enable the waiting room. Valid values:
   * 
   * *   on
   * *   off
   * 
   * This parameter is required.
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * The end time of the event. This value is a UNIX timestamp.
   * 
   * This parameter is required.
   * 
   * @example
   * 1719849600
   */
  endTime?: string;
  /**
   * @remarks
   * Specifies whether to enable JSON response. If you set this parameter to on, a JSON body is returned for requests to the waiting room with the header Accept: application/json. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  jsonResponseEnable?: string;
  /**
   * @remarks
   * The language of the waiting room page. You must specify this parameter if you set WaitingRoomType to default. Valid values:
   * 
   * *   enus: English.
   * *   zhcn: Simplified Chinese.
   * *   zhhk: Traditional Chinese.
   * 
   * @example
   * zhcn
   */
  language?: string;
  /**
   * @remarks
   * The name of the waiting room event.
   * 
   * This parameter is required.
   * 
   * @example
   * waitingroom_example
   */
  name?: string;
  /**
   * @remarks
   * The maximum number of new users per minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  newUsersPerMinute?: string;
  /**
   * @remarks
   * Specifies whether to enable pre-queuing.
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  preQueueEnable?: string;
  /**
   * @remarks
   * The start time for pre-queuing.
   * 
   * @example
   * 1719763200
   */
  preQueueStartTime?: string;
  /**
   * @remarks
   * The queuing method. Valid values:
   * 
   * *   random: Users gain access to the origin randomly, regardless of the arrival time.
   * *   fifo: Users gain access to the origin in order of arrival.
   * *   passthrough: Users pass through the waiting room and go straight to the origin.
   * *   reject-all: Users are blocked from reaching the origin.
   * 
   * This parameter is required.
   * 
   * @example
   * random
   */
  queuingMethod?: string;
  /**
   * @remarks
   * The HTTP status code to return while a user is in the queue. Valid values:
   * 
   * *   200
   * *   202
   * *   429
   * 
   * This parameter is required.
   * 
   * @example
   * 202
   */
  queuingStatusCode?: string;
  /**
   * @remarks
   * Specifies whether to enable random queuing.
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  randomPreQueueEnable?: string;
  /**
   * @remarks
   * The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.
   * 
   * This parameter is required.
   * 
   * @example
   * 5
   */
  sessionDuration?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The start time of the event. This value is a UNIX timestamp.
   * 
   * This parameter is required.
   * 
   * @example
   * 1719763200
   */
  startTime?: string;
  /**
   * @remarks
   * The maximum number of active users.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  totalActiveUsers?: string;
  /**
   * @remarks
   * The ID of the waiting room, which can be obtained by calling the [ListWaitingRooms](https://help.aliyun.com/document_detail/2850279.html) operation.
   * 
   * @example
   * 6a51d5bc6460887abd1291dc7d4db28b
   */
  waitingRoomId?: string;
  /**
   * @remarks
   * The type of the waiting room. Valid values:
   * 
   * *   default
   * *   custom
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  waitingRoomType?: string;
  static names(): { [key: string]: string } {
    return {
      customPageHtml: 'CustomPageHtml',
      description: 'Description',
      disableSessionRenewalEnable: 'DisableSessionRenewalEnable',
      enable: 'Enable',
      endTime: 'EndTime',
      jsonResponseEnable: 'JsonResponseEnable',
      language: 'Language',
      name: 'Name',
      newUsersPerMinute: 'NewUsersPerMinute',
      preQueueEnable: 'PreQueueEnable',
      preQueueStartTime: 'PreQueueStartTime',
      queuingMethod: 'QueuingMethod',
      queuingStatusCode: 'QueuingStatusCode',
      randomPreQueueEnable: 'RandomPreQueueEnable',
      sessionDuration: 'SessionDuration',
      siteId: 'SiteId',
      startTime: 'StartTime',
      totalActiveUsers: 'TotalActiveUsers',
      waitingRoomId: 'WaitingRoomId',
      waitingRoomType: 'WaitingRoomType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customPageHtml: 'string',
      description: 'string',
      disableSessionRenewalEnable: 'string',
      enable: 'string',
      endTime: 'string',
      jsonResponseEnable: 'string',
      language: 'string',
      name: 'string',
      newUsersPerMinute: 'string',
      preQueueEnable: 'string',
      preQueueStartTime: 'string',
      queuingMethod: 'string',
      queuingStatusCode: 'string',
      randomPreQueueEnable: 'string',
      sessionDuration: 'string',
      siteId: 'number',
      startTime: 'string',
      totalActiveUsers: 'string',
      waitingRoomId: 'string',
      waitingRoomType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomEventResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A123425345
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomEventResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWaitingRoomEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWaitingRoomEventResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The rule content, which is a policy or conditional expression.
   * 
   * This parameter is required.
   * 
   * @example
   * (http.request.uri.path.file_name eq \\"jpg\\")
   */
  rule?: string;
  /**
   * @remarks
   * Specifies whether to enable the rule. Valid values:
   * 
   * *   on
   * *   off
   * 
   * This parameter is required.
   * 
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @remarks
   * The rule name.
   * 
   * This parameter is required.
   * 
   * @example
   * waitingroom_example
   */
  ruleName?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The ID of the waiting room to be bypassed.
   * 
   * This parameter is required.
   * 
   * @example
   * 25133f536f1b1f6b6091f6a92c614dd4
   */
  waitingRoomId?: string;
  static names(): { [key: string]: string } {
    return {
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      waitingRoomId: 'WaitingRoomId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
      waitingRoomId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWaitingRoomRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWaitingRoomRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCustomScenePolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The policy ID, which can be obtained by calling the [DescribeCustomScenePolicies](https://help.aliyun.com/document_detail/2850508.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  policyId?: number;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCustomScenePolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The policy ID.
   * 
   * @example
   * 1
   */
  policyId?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 5CC228B4-7A67-4016-9C9F-4A4133494A91
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCustomScenePolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteCustomScenePolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCustomScenePolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeContainerAppRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * @example
   * app-1232321454***
   */
  appId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeContainerAppResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  /**
   * @remarks
   * Specifies whether the deletion is successful.
   * 
   * @example
   * ok
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeContainerAppResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteEdgeContainerAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteEdgeContainerAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeContainerAppRecordRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The associated domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * a.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 5407498413****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      recordName: 'RecordName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      recordName: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeContainerAppRecordResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeContainerAppRecordResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteEdgeContainerAppRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteEdgeContainerAppRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeContainerAppVersionRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * app-96253477062511****
   */
  appId?: string;
  /**
   * @remarks
   * The ID of the version that you want to delete. To obtain the version ID, call the [ListEdgeContainerAppVersions](~~ListEdgeContainerAppVersions~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * ver-89884764010378****
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      versionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeContainerAppVersionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * b021e538-9dde-46ed-a1f2-9469da8f3e77
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeContainerAppVersionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteEdgeContainerAppVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteEdgeContainerAppVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteKvRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the key that you want to delete.
   * 
   * This parameter is required.
   * 
   * @example
   * test_key
   */
  key?: string;
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteKvResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteKvResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteKvResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteKvResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteKvNamespaceRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteKvNamespaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteKvNamespaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteKvNamespaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteKvNamespaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteListRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the custom list, which can be obtained by calling the [ListLists](https://help.aliyun.com/document_detail/2850217.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 40000001
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOriginProtectionRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOriginProtectionResponseBody extends $tea.Model {
  /**
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOriginProtectionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteOriginProtectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteOriginProtectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePageRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the custom error page, which can be obtained by calling the [ListPages](https://help.aliyun.com/document_detail/2850223.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 50000001
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the custom error page.[](~~2850223~~)
   * 
   * @example
   * 50000001
   */
  id?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeletePageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeletePageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRecordRequest extends $tea.Model {
  /**
   * @remarks
   * The record ID, which can be obtained by calling [ListRecords](https://help.aliyun.com/document_detail/2850265.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  recordId?: number;
  static names(): { [key: string]: string } {
    return {
      recordId: 'RecordId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRecordResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F61CDR30-E83C-4FDA-BF73-9A94CDD44229
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRecordResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineRequest extends $tea.Model {
  /**
   * @remarks
   * The routine name.
   * 
   * @example
   * test-routine1
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the operation is successful.
   * 
   * @example
   * OK
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRoutineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRoutineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineCodeVersionRequest extends $tea.Model {
  /**
   * @remarks
   * The code version.
   * 
   * @example
   * 1710120201067203242
   */
  codeVersion?: string;
  /**
   * @remarks
   * The routine name.
   * 
   * @example
   * test-routine1
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      codeVersion: 'CodeVersion',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeVersion: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineCodeVersionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the operation is successful.
   * 
   * @example
   * OK
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineCodeVersionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRoutineCodeVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRoutineCodeVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineRelatedRecordRequest extends $tea.Model {
  /**
   * @remarks
   * The routine name.
   * 
   * @example
   * DeleteRoutineRelatedRecord
   */
  name?: string;
  /**
   * @remarks
   * The record ID.
   * 
   * @example
   * 12345
   */
  recordId?: number;
  /**
   * @remarks
   * The record name.
   * 
   * @example
   * test-xxx.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 12345
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      recordId: 'RecordId',
      recordName: 'RecordName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      recordId: 'number',
      recordName: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineRelatedRecordResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the operation is successful.
   * 
   * *   OK
   * *   Fail
   * 
   * @example
   * OK
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineRelatedRecordResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRoutineRelatedRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRoutineRelatedRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineRelatedRouteRequest extends $tea.Model {
  /**
   * @remarks
   * The routine name.
   * 
   * @example
   * DeleteRoutineRelatedRoute
   */
  name?: string;
  /**
   * @remarks
   * The route URL.
   * 
   * @example
   * *.example.com/path1*
   */
  route?: string;
  /**
   * @remarks
   * The route ID.
   * 
   * @example
   * 0c3b82a3d1524e9f750da11d0cc0be0a
   */
  routeId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 54362329990032
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      route: 'Route',
      routeId: 'RouteId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      route: 'string',
      routeId: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineRelatedRouteResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the operation is successful.
   * 
   * @example
   * OK
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineRelatedRouteResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRoutineRelatedRouteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRoutineRelatedRouteResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScheduledPreloadExecutionRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the prefetch plan.
   * 
   * This parameter is required.
   * 
   * @example
   * DeleteScheduledPreloadExecution
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScheduledPreloadExecutionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScheduledPreloadExecutionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteScheduledPreloadExecutionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteScheduledPreloadExecutionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScheduledPreloadJobRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the scheduled prefetch task.
   * 
   * This parameter is required.
   * 
   * @example
   * DeleteScheduledPreloadJob
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScheduledPreloadJobResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C370DAF1-C838-4288-A1A0-9A87633D248E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScheduledPreloadJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteScheduledPreloadJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteScheduledPreloadJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSiteRequest extends $tea.Model {
  ownerId?: number;
  securityToken?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      securityToken: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSiteResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247B78
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSiteResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteSiteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSiteResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSiteDeliveryTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456******
   */
  siteId?: number;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * cdn-test-task
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSiteDeliveryTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F61CDR30-E83C-4FDA-BF73-9A94CDD44229
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSiteDeliveryTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteSiteDeliveryTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSiteDeliveryTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSiteFunctionRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 33793140540****,33793140540****
   */
  configIds?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 611133661****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configIds: 'ConfigIds',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configIds: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSiteFunctionResponseBody extends $tea.Model {
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSiteFunctionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteSiteFunctionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSiteFunctionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserDeliveryTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * test-project
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserDeliveryTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 952ea16b-1f05-4a76-bb32-420282d8aeb9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserDeliveryTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteUserDeliveryTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteUserDeliveryTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWafRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the WAF rule, which can be obtained by calling the [ListWafRules](https://help.aliyun.com/document_detail/2850237.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 20000001
   */
  id?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 1
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWafRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWafRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWafRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWafRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWafRulesetRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the WAF ruleset, which can be obtained by calling the [ListWafRulesets](https://help.aliyun.com/document_detail/2850233.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000001
   */
  id?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 1
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWafRulesetResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWafRulesetResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWafRulesetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWafRulesetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaitingRoomRequest extends $tea.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The waiting room ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 25133f536f1b1f6b6091f6a92c614dd4
   */
  waitingRoomId?: string;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      waitingRoomId: 'WaitingRoomId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      waitingRoomId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaitingRoomResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A123425345
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaitingRoomResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWaitingRoomResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWaitingRoomResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaitingRoomEventRequest extends $tea.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The ID of the waiting room event.
   * 
   * @example
   * 302909890***
   */
  waitingRoomEventId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      waitingRoomEventId: 'WaitingRoomEventId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      waitingRoomEventId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaitingRoomEventResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaitingRoomEventResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWaitingRoomEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWaitingRoomEventResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaitingRoomRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The ID of the waiting room bypass rule.
   * 
   * @example
   * 3672886****
   */
  waitingRoomRuleId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      waitingRoomRuleId: 'WaitingRoomRuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      waitingRoomRuleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaitingRoomRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaitingRoomRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWaitingRoomRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWaitingRoomRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomScenePoliciesRequest extends $tea.Model {
  /**
   * @remarks
   * The page number. Valid values: 1 to 100000.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Valid values: 5, 10, and 20.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the policy, which can be obtained by calling the [ListWafRulesets](https://help.aliyun.com/document_detail/2850233.html) operation.
   * 
   * @example
   * 1234****
   */
  policyId?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      policyId: 'PolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      policyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomScenePoliciesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The scenario-specific policies.
   */
  dataModule?: DescribeCustomScenePoliciesResponseBodyDataModule[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The policy quota.
   * 
   * @example
   * 10
   */
  quota?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 85H66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      quota: 'Quota',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeCustomScenePoliciesResponseBodyDataModule },
      pageNumber: 'number',
      pageSize: 'number',
      quota: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomScenePoliciesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCustomScenePoliciesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCustomScenePoliciesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDoSAllEventListRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The maximum time range is 31 days.
   * 
   * If you do not configure this parameter, the current time is used as the end of the time range to query.
   * 
   * @example
   * 2023-02-22T15:59:59Z
   */
  endTime?: string;
  /**
   * @remarks
   * The type of DDoS attacks to query. Valid values:
   * 
   * *   **web-cc**: web resource exhaustion attacks.
   * *   **cc**: connection flood attacks.
   * *   **traffic**: volumetric attacks.
   * 
   * Default value: web-cc.
   * 
   * @example
   * web-cc
   */
  eventType?: string;
  /**
   * @remarks
   * The page number. Valid values: **1** to **100000**.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: **10**. Valid values: 5, 10, and 20.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 7096621098****
   */
  siteId?: number;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-02-12T15:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      eventType: 'EventType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      siteId: 'SiteId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      eventType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      siteId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDoSAllEventListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The DDoS attack events.
   */
  dataList?: DescribeDDoSAllEventListResponseBodyDataList[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * D73A4243-CFBD-5110-876F-09237E77ECBD
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 7096621098****
   */
  siteId?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dataList: 'DataList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      siteId: 'SiteId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataList: { 'type': 'array', 'itemType': DescribeDDoSAllEventListResponseBodyDataList },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      siteId: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDoSAllEventListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDDoSAllEventListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDDoSAllEventListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHttpDDoSAttackIntelligentProtectionRequest extends $tea.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHttpDDoSAttackIntelligentProtectionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The mode of smart HTTP DDoS protection. Valid values:
   * 
   * *   **observe**: alert.
   * *   **defense**: block.
   * 
   * @example
   * defense
   */
  aiMode?: string;
  /**
   * @remarks
   * The level of smart HTTP DDoS protection. Valid values:
   * 
   * *   **level0**: very loose.
   * *   **level30**: loose.
   * *   **level60**: normal.
   * *   **level90**: strict.
   * 
   * @example
   * level60
   */
  aiTemplate?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-3C82-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      aiMode: 'AiMode',
      aiTemplate: 'AiTemplate',
      requestId: 'RequestId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aiMode: 'string',
      aiTemplate: 'string',
      requestId: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHttpDDoSAttackIntelligentProtectionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeHttpDDoSAttackIntelligentProtectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeHttpDDoSAttackIntelligentProtectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHttpDDoSAttackProtectionRequest extends $tea.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHttpDDoSAttackProtectionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The level of HTTP DDoS attack protection. Valid values:
   * 
   * *   **very weak**: very loose.
   * *   **weak**: loose.
   * *   **default**: normal.
   * *   **hard**: strict.
   * 
   * @example
   * default
   */
  globalMode?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 35C66C7B-671H-4297-9187-2C4477247A78
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      globalMode: 'GlobalMode',
      requestId: 'RequestId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      globalMode: 'string',
      requestId: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHttpDDoSAttackProtectionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeHttpDDoSAttackProtectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeHttpDDoSAttackProtectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeKvAccountStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether Edge KV is activated for the Alibaba Cloud account.
   * 
   * *   **online**
   * *   **offline**
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeKvAccountStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeKvAccountStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeKvAccountStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePreloadTasksRequest extends $tea.Model {
  /**
   * @remarks
   * The content to prefetch. Exact match is supported.
   * 
   * @example
   * http://a.com/1.jpg?b=2
   */
  content?: string;
  /**
   * @remarks
   * The end time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * >  The end time must be later than the start time.
   * 
   * @example
   * 2023-03-23T06:23:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The page number. Valid values: **1** to **100000**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 20. Valid values: 1 to 50.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  /**
   * @remarks
   * The start time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2023-03-22T17:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The task status. Valid values:
   * 
   * *   **Complete**: The task is complete.
   * *   **Refreshing**: The task is running.
   * *   **Failed**: The task failed.
   * 
   * @example
   * Complete
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      endTime: 'EndTime',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      siteId: 'SiteId',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      endTime: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      siteId: 'number',
      startTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePreloadTasksResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  /**
   * @remarks
   * The tasks.
   */
  tasks?: DescribePreloadTasksResponseBodyTasks[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 83
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      tasks: 'Tasks',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      tasks: { 'type': 'array', 'itemType': DescribePreloadTasksResponseBodyTasks },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePreloadTasksResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePreloadTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePreloadTasksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurgeTasksRequest extends $tea.Model {
  /**
   * @remarks
   * The content to purge. Exact match is supported.
   * 
   * @example
   * http://a.com/1.jpg?b=1
   */
  content?: string;
  /**
   * @remarks
   * The end time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * >  The end time must be later than the start time.
   * 
   * @example
   * 2022-11-18T15:59:59Z
   */
  endTime?: string;
  /**
   * @remarks
   * The page number. Valid values: 1 to 100000.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 20. Valid values: 1 to 50.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  /**
   * @remarks
   * The start time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2022-11-16T05:33:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The task status. Valid values:
   * 
   * *   **Complete**: The task is complete.
   * *   **Refreshing**: The task is in progress.
   * *   **Failed**: The task failed.
   * 
   * @example
   * Complete
   */
  status?: string;
  /**
   * @remarks
   * The task type. Valid values:
   * 
   * *   **file** (default): purges the cache by file.
   * *   **cachetag**: purges the cache by cache tag.
   * *   **directory**: purges the cache by directory.
   * *   **ignoreParams**: purges the cache by URL with specified parameters ignored.
   * *   **hostname**: purges the cache by hostname.
   * *   **purgeall**: purges all cache.
   * 
   * @example
   * file
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      endTime: 'EndTime',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      siteId: 'SiteId',
      startTime: 'StartTime',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      endTime: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      siteId: 'number',
      startTime: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurgeTasksResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A123425345
   */
  requestId?: string;
  /**
   * @remarks
   * The tasks.
   */
  tasks?: DescribePurgeTasksResponseBodyTasks[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 15
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      tasks: 'Tasks',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      tasks: { 'type': 'array', 'itemType': DescribePurgeTasksResponseBodyTasks },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurgeTasksResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePurgeTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePurgeTasksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableCustomScenePolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The policy ID, which can be obtained by calling the [DescribeCustomScenePolicies](https://help.aliyun.com/document_detail/2850508.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 100001
   */
  policyId?: number;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableCustomScenePolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the disabled policy.
   * 
   * @example
   * 100001
   */
  policyId?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9732E117-8A37-49FD-A36F-ABBB87556CA7
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableCustomScenePolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DisableCustomScenePolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DisableCustomScenePolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditSiteWafSettingsRequest extends $tea.Model {
  /**
   * @remarks
   * The WAF configuration of the website in the JSON format.
   */
  settings?: WafSiteSettings;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      settings: 'Settings',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      settings: WafSiteSettings,
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditSiteWafSettingsShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The WAF configuration of the website in the JSON format.
   */
  settingsShrink?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      settingsShrink: 'Settings',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      settingsShrink: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditSiteWafSettingsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditSiteWafSettingsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EditSiteWafSettingsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EditSiteWafSettingsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableCustomScenePolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The policy ID, which can be obtained by calling the [DescribeCustomScenePolicies](https://help.aliyun.com/document_detail/2850508.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  policyId?: number;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableCustomScenePolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The policy ID.
   * 
   * @example
   * 1
   */
  policyId?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 65C66B7B-671A-8297-9187-2R5477247B76
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableCustomScenePolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EnableCustomScenePolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableCustomScenePolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportRecordsRequest extends $tea.Model {
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportRecordsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The exported DNS records.
   * 
   * @example
   * ;; site:example.com.\\n;; Exported:2024-01-24 15:54:35\\n\\n;; A Records\\na1.example.com. 30 IN A 1.1.1.1 direct\\na2.example.com. 30 IN A 1.1.1.1 direct\\na3.example.com. 30 IN A 1.1.1.1 direct\\n
   */
  content?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C69B5894-D1BA-592C-95D0-DADBE7AEAC63
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportRecordsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExportRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCacheReserveSpecificationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The capacities of cache reserve instances that can be created.
   */
  cacheReserveCapacity?: string[];
  /**
   * @remarks
   * The regions in which cache reserve instances can be created.
   */
  cacheReserveRegion?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      cacheReserveCapacity: 'CacheReserveCapacity',
      cacheReserveRegion: 'CacheReserveRegion',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheReserveCapacity: { 'type': 'array', 'itemType': 'string' },
      cacheReserveRegion: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCacheReserveSpecificationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetCacheReserveSpecificationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCacheReserveSpecificationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppResponseBody extends $tea.Model {
  /**
   * @remarks
   * The basic information about the application.
   */
  app?: GetEdgeContainerAppResponseBodyApp;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 156A6B-677B1A-4297B7-9187B7-2B44792
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: GetEdgeContainerAppResponseBodyApp,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetEdgeContainerAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetEdgeContainerAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The release environment. Valid values: prod and staging.
   * 
   * @example
   * staging
   */
  publishEnv?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      publishEnv: 'PublishEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      publishEnv: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status of the application.
   */
  appStatus?: GetEdgeContainerAppStatusResponseBodyAppStatus;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247B78
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      appStatus: 'AppStatus',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appStatus: GetEdgeContainerAppStatusResponseBodyAppStatus,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetEdgeContainerAppStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetEdgeContainerAppStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppVersionRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The version ID, which can be obtained by calling the [ListEdgeContainerAppVersions](~~ListEdgeContainerAppVersions~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * ver-87962637161651****
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      versionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppVersionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the version.
   */
  version?: GetEdgeContainerAppVersionResponseBodyVersion;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      version: GetEdgeContainerAppVersionResponseBodyVersion,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppVersionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetEdgeContainerAppVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetEdgeContainerAppVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerDeployRegionsRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * @example
   * GetEdgeContainerDeployRegions
   */
  appId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerDeployRegionsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The regions.
   */
  regions?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      regions: 'Regions',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regions: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerDeployRegionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetEdgeContainerDeployRegionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetEdgeContainerDeployRegionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerLogsRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The number of log entries to output.
   * 
   * This parameter is required.
   * 
   * @example
   * 500
   */
  lines?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      lines: 'Lines',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      lines: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerLogsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The logs.
   */
  items?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247B78
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerLogsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetEdgeContainerLogsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetEdgeContainerLogsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerStagingDeployStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * @example
   * GetEdgeContainerStagingDeployStatus
   */
  appId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerStagingDeployStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the container is ready.
   * 
   * *   ok
   * *   unready
   * 
   * @example
   * ok
   */
  containersReady?: string;
  /**
   * @remarks
   * The time when the container was created. The value is a timestamp.
   * 
   * @example
   * 2024-09-24T06:46:35Z
   */
  creationTimestamp?: string;
  /**
   * @remarks
   * The initialization status of the container.
   * 
   * *   ok
   * *   unready
   * 
   * @example
   * ok
   */
  initialized?: string;
  /**
   * @remarks
   * The status of the container in the staging environment.
   * 
   * *   NoContainer: created.
   * *   Running: running.
   * *   Failed: abnormal.
   * 
   * @example
   * Running
   */
  phase?: string;
  /**
   * @remarks
   * The details of container restart.
   */
  podRestartState?: GetEdgeContainerStagingDeployStatusResponseBodyPodRestartState;
  /**
   * @remarks
   * Indicates whether domain names are associated with the container.
   * 
   * *   ok
   * *   unready
   * 
   * @example
   * ok
   */
  ready?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2F2C992B-3FE2-5EBB-A61F-F9DD4EB257DA
   */
  requestId?: string;
  /**
   * @remarks
   * The scheduling status of the container.
   * 
   * *   ok
   * *   unready
   * 
   * @example
   * ok
   */
  scheduled?: string;
  /**
   * @remarks
   * The virtual IP addresses.
   */
  VIPs?: string[];
  static names(): { [key: string]: string } {
    return {
      containersReady: 'ContainersReady',
      creationTimestamp: 'CreationTimestamp',
      initialized: 'Initialized',
      phase: 'Phase',
      podRestartState: 'PodRestartState',
      ready: 'Ready',
      requestId: 'RequestId',
      scheduled: 'Scheduled',
      VIPs: 'VIPs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      containersReady: 'string',
      creationTimestamp: 'string',
      initialized: 'string',
      phase: 'string',
      podRestartState: GetEdgeContainerStagingDeployStatusResponseBodyPodRestartState,
      ready: 'string',
      requestId: 'string',
      scheduled: 'string',
      VIPs: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerStagingDeployStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetEdgeContainerStagingDeployStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetEdgeContainerStagingDeployStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerTerminalRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerTerminalResponseBody extends $tea.Model {
  /**
   * @remarks
   * The cluster name.
   * 
   * @example
   * c497b44c2a59f4ae0bd2826edc40a2c6e
   */
  cluster?: string;
  /**
   * @remarks
   * The container name.
   * 
   * @example
   * worker0
   */
  container?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * @example
   * ns1
   */
  namespace?: string;
  /**
   * @remarks
   * The name of the container group.
   * 
   * @example
   * 1775b9e0-8463-457e-89e8-fb7b6d125b2e
   */
  pod?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9732E117-8A37-49FD-A36F-ABBB87556CA7
   */
  requestId?: string;
  /**
   * @remarks
   * The session ID.
   * 
   * @example
   * af22f4xxxxxxxxxxxxxxxxxx
   */
  sessionId?: string;
  /**
   * @remarks
   * The information about the shared token.
   * 
   * @example
   * af22f4-xxxxx-xxxx-xxxx-xxxx
   */
  token?: string;
  static names(): { [key: string]: string } {
    return {
      cluster: 'Cluster',
      container: 'Container',
      namespace: 'Namespace',
      pod: 'Pod',
      requestId: 'RequestId',
      sessionId: 'SessionId',
      token: 'Token',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cluster: 'string',
      container: 'string',
      namespace: 'string',
      pod: 'string',
      requestId: 'string',
      sessionId: 'string',
      token: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerTerminalResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetEdgeContainerTerminalResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetEdgeContainerTerminalResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetErServiceRequest extends $tea.Model {
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetErServiceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The billing mode. Valid values:
   * 
   * *   er_paymode: billed for customers on the China site.
   * *   er_freemode: free for customers on the China site.
   * *   er_paymodeintl: billed for customers on the International site.
   * *   err_freemodeintl: free for customers on the International site
   * 
   * @example
   * er_paymode
   */
  planName?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The service status. Valid values:
   * 
   * *   Creating
   * *   Running
   * *   NotOpened
   * 
   * @example
   * Running
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      planName: 'PlanName',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      planName: 'string',
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetErServiceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetErServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetErServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKvRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to decode the value by using Base 64. If you call the [PutKv](https://help.aliyun.com/document_detail/2850482.html) operation and set the Base64 parameter to true, set this parameter to true to read the original content.
   * 
   * @example
   * true
   */
  base64?: boolean;
  /**
   * @remarks
   * The key name for the query.
   * 
   * This parameter is required.
   * 
   * @example
   * test_key
   */
  key?: string;
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      base64: 'Base64',
      key: 'Key',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      base64: 'boolean',
      key: 'string',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKvResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The value of the key.
   * 
   * @example
   * test_value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKvResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetKvResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetKvResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKvAccountResponseBody extends $tea.Model {
  /**
   * @remarks
   * The available capacity of all namespaces in the account. Unit: bytes.
   * 
   * @example
   * 1073741824
   */
  capacity?: number;
  /**
   * @remarks
   * The available capacity of all namespaces in the account.
   * 
   * @example
   * 1 GB
   */
  capacityString?: string;
  /**
   * @remarks
   * The used capacity of all namespaces in the account. Unit: bytes.
   * 
   * @example
   * 10048576
   */
  capacityUsed?: number;
  /**
   * @remarks
   * The used capacity of all namespaces in the account.
   * 
   * @example
   * 100 MB
   */
  capacityUsedString?: string;
  /**
   * @remarks
   * The namespaces in the account.
   */
  namespaceList?: GetKvAccountResponseBodyNamespaceList[];
  /**
   * @remarks
   * The maximum number of namespaces that can be created in the account.
   * 
   * @example
   * 10
   */
  namespaceQuota?: number;
  /**
   * @remarks
   * The number of created namespaces that store key-value data in the account.
   * 
   * @example
   * 1
   */
  namespaceUsed?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether Edge KV is activated for the Alibaba Cloud account.
   * 
   * *   **online**
   * *   **offline**
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      capacity: 'Capacity',
      capacityString: 'CapacityString',
      capacityUsed: 'CapacityUsed',
      capacityUsedString: 'CapacityUsedString',
      namespaceList: 'NamespaceList',
      namespaceQuota: 'NamespaceQuota',
      namespaceUsed: 'NamespaceUsed',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacity: 'number',
      capacityString: 'string',
      capacityUsed: 'number',
      capacityUsedString: 'string',
      namespaceList: { 'type': 'array', 'itemType': GetKvAccountResponseBodyNamespaceList },
      namespaceQuota: 'number',
      namespaceUsed: 'number',
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKvAccountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetKvAccountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetKvAccountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKvNamespaceRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKvNamespaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The available capacity of the namespace. Unit: bytes.
   * 
   * @example
   * 1073741824
   */
  capacity?: number;
  /**
   * @remarks
   * The available capacity of the namespace.
   * 
   * @example
   * 1 GB
   */
  capacityString?: string;
  /**
   * @remarks
   * The used capacity of the namespace. Unit: bytes.
   * 
   * @example
   * 10048576
   */
  capacityUsed?: number;
  /**
   * @remarks
   * The used capacity of the namespace.
   * 
   * @example
   * 100 MB
   */
  capacityUsedString?: string;
  /**
   * @remarks
   * The description of the namespace.
   * 
   * @example
   * this is a test namespace.
   */
  description?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 643355322374688768
   */
  namespaceId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the namespace. Valid values:
   * 
   * *   **online**: working as expected.
   * *   **delete**: pending deletion.
   * *   **deleting**: being deleted.
   * *   **deleted**: deleted.
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      capacity: 'Capacity',
      capacityString: 'CapacityString',
      capacityUsed: 'CapacityUsed',
      capacityUsedString: 'CapacityUsedString',
      description: 'Description',
      namespace: 'Namespace',
      namespaceId: 'NamespaceId',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacity: 'number',
      capacityString: 'string',
      capacityUsed: 'number',
      capacityUsedString: 'string',
      description: 'string',
      namespace: 'string',
      namespaceId: 'string',
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKvNamespaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetKvNamespaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetKvNamespaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetListRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the custom list, which can be obtained by calling the [ListLists](https://help.aliyun.com/document_detail/2850217.html) operation.
   * 
   * @example
   * 40000001
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The description of the custom list.
   * 
   * @example
   * a custom list
   */
  description?: string;
  /**
   * @remarks
   * The ID of the custom list.[](~~2850217~~)
   * 
   * @example
   * 40000001
   */
  id?: number;
  /**
   * @remarks
   * The items in the custom list, which are displayed as an array.
   */
  items?: string[];
  /**
   * @remarks
   * The type of the custom list.
   * 
   * @example
   * ip
   */
  kind?: string;
  /**
   * @remarks
   * The name of the custom list.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The time when the custom list was last modified.
   * 
   * @example
   * 2024-01-01T00:00:00Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      id: 'Id',
      items: 'Items',
      kind: 'Kind',
      name: 'Name',
      requestId: 'RequestId',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      id: 'number',
      items: { 'type': 'array', 'itemType': 'string' },
      kind: 'string',
      name: 'string',
      requestId: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginProtectionRequest extends $tea.Model {
  /**
   * @example
   * 123456789****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginProtectionResponseBody extends $tea.Model {
  currentIPWhitelist?: GetOriginProtectionResponseBodyCurrentIPWhitelist;
  diffIPWhitelist?: GetOriginProtectionResponseBodyDiffIPWhitelist;
  latestIPWhitelist?: GetOriginProtectionResponseBodyLatestIPWhitelist;
  /**
   * @example
   * true
   */
  needUpdate?: boolean;
  /**
   * @example
   * on
   */
  originConverge?: string;
  /**
   * @example
   * on
   */
  originProtection?: string;
  /**
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      currentIPWhitelist: 'CurrentIPWhitelist',
      diffIPWhitelist: 'DiffIPWhitelist',
      latestIPWhitelist: 'LatestIPWhitelist',
      needUpdate: 'NeedUpdate',
      originConverge: 'OriginConverge',
      originProtection: 'OriginProtection',
      requestId: 'RequestId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentIPWhitelist: GetOriginProtectionResponseBodyCurrentIPWhitelist,
      diffIPWhitelist: GetOriginProtectionResponseBodyDiffIPWhitelist,
      latestIPWhitelist: GetOriginProtectionResponseBodyLatestIPWhitelist,
      needUpdate: 'boolean',
      originConverge: 'string',
      originProtection: 'string',
      requestId: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginProtectionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOriginProtectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOriginProtectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPageRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the custom error page, which can be obtained by calling the [ListPages](https://help.aliyun.com/document_detail/2850223.html) operation.
   * 
   * @example
   * 50000001
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The Base64-encoded content of the error page. The content type is specified by the Content-Type field.
   * 
   * This parameter is required.
   * 
   * @example
   * PGh0bWw+aGVsbG8gcGFnZTwvaHRtbD4=
   */
  content?: string;
  /**
   * @remarks
   * The Content-Type field in the HTTP header.
   * 
   * This parameter is required.
   * 
   * @example
   * text/html
   */
  contentType?: string;
  /**
   * @remarks
   * The description of the custom error page.
   * 
   * @example
   * a custom deny page
   */
  description?: string;
  /**
   * @remarks
   * The ID of the custom error page.[](~~2850223~~)
   * 
   * @example
   * 50000001
   */
  id?: number;
  /**
   * @remarks
   * The type of the custom response page.
   * 
   * @example
   * custom
   */
  kind?: string;
  /**
   * @remarks
   * The name of the custom response page.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The time when the custom error page was last modified.
   * 
   * @example
   * 2024-01-01T00:00:00Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      contentType: 'ContentType',
      description: 'Description',
      id: 'Id',
      kind: 'Kind',
      name: 'Name',
      requestId: 'RequestId',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      contentType: 'string',
      description: 'string',
      id: 'number',
      kind: 'string',
      name: 'string',
      requestId: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPurgeQuotaRequest extends $tea.Model {
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  /**
   * @remarks
   * The type of the purge task. Valid values:
   * 
   * *   **file** (default): purges the cache by file.
   * *   **cachetag**: purges the cache by cache tag.
   * *   **directory**: purges the cache by directory.
   * *   **ignoreParams**: purges the cache by URL with specific parameters ignored.
   * *   **hostname**: purges the cache by hostname.
   * *   **purgeall**: purges all cache.
   * 
   * @example
   * file
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPurgeQuotaResponseBody extends $tea.Model {
  /**
   * @remarks
   * The total quota.
   * 
   * @example
   * 100000
   */
  quota?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  /**
   * @remarks
   * The quota usage.
   * 
   * @example
   * 10
   */
  usage?: string;
  static names(): { [key: string]: string } {
    return {
      quota: 'Quota',
      requestId: 'RequestId',
      usage: 'Usage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quota: 'string',
      requestId: 'string',
      usage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPurgeQuotaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPurgeQuotaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPurgeQuotaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRealtimeDeliveryFieldRequest extends $tea.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   **dcdn_log_access_l1** (default): access logs.
   * *   **dcdn_log_er**: Edge Routine logs.
   * *   **dcdn_log_waf**: firewall logs.
   * *   **dcdn_log_ipa**: TCP/UDP proxy logs.
   * 
   * This parameter is required.
   * 
   * @example
   * dcdn_log_er
   */
  businessType?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRealtimeDeliveryFieldResponseBody extends $tea.Model {
  /**
   * @remarks
   * The fields returned.
   */
  fieldContent?: { [key: string]: FieldContentValue };
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247B78
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      fieldContent: 'FieldContent',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldContent: { 'type': 'map', 'keyType': 'string', 'valueType': FieldContentValue },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRealtimeDeliveryFieldResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRealtimeDeliveryFieldResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRealtimeDeliveryFieldResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRecordRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  recordId?: number;
  static names(): { [key: string]: string } {
    return {
      recordId: 'RecordId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRecordResponseBody extends $tea.Model {
  recordModel?: GetRecordResponseBodyRecordModel;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * F32C57AA-7BF8-49AE-A2CC-9F42390F5A19
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recordModel: 'RecordModel',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordModel: GetRecordResponseBodyRecordModel,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRecordResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineRequest extends $tea.Model {
  /**
   * @remarks
   * The routine name.
   * 
   * @example
   * GetRoutine
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineResponseBody extends $tea.Model {
  /**
   * @remarks
   * The code versions.
   */
  codeVersions?: GetRoutineResponseBodyCodeVersions[];
  /**
   * @remarks
   * The time when the routine was created.
   * 
   * @example
   * 2024-03-11T01:23:21Z
   */
  createTime?: string;
  /**
   * @remarks
   * The default record name to access.
   * 
   * @example
   * routine1.example.com
   */
  defaultRelatedRecord?: string;
  /**
   * @remarks
   * The description of the routine.
   * 
   * @example
   * ZWRpdCByb3V0aW5lIGNvbmZpZyBkZXNjcmlwdGlvbg
   */
  description?: string;
  /**
   * @remarks
   * The information about the environments.
   */
  envs?: GetRoutineResponseBodyEnvs[];
  /**
   * @remarks
   * The records associated with the routine.
   */
  relatedRecords?: GetRoutineResponseBodyRelatedRecords[];
  /**
   * @remarks
   * The routes associated with the routine.
   */
  relatedRoutes?: GetRoutineResponseBodyRelatedRoutes[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      codeVersions: 'CodeVersions',
      createTime: 'CreateTime',
      defaultRelatedRecord: 'DefaultRelatedRecord',
      description: 'Description',
      envs: 'Envs',
      relatedRecords: 'RelatedRecords',
      relatedRoutes: 'RelatedRoutes',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeVersions: { 'type': 'array', 'itemType': GetRoutineResponseBodyCodeVersions },
      createTime: 'string',
      defaultRelatedRecord: 'string',
      description: 'string',
      envs: { 'type': 'array', 'itemType': GetRoutineResponseBodyEnvs },
      relatedRecords: { 'type': 'array', 'itemType': GetRoutineResponseBodyRelatedRecords },
      relatedRoutes: { 'type': 'array', 'itemType': GetRoutineResponseBodyRelatedRoutes },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRoutineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRoutineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineStagingCodeUploadInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The code description.
   * 
   * @example
   * the description of code
   */
  codeDescription?: string;
  /**
   * @remarks
   * The routine name.
   * 
   * @example
   * GetRoutineStagingCodeUploadInfo
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      codeDescription: 'CodeDescription',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeDescription: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineStagingCodeUploadInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The code version.
   * 
   * @example
   * 1710120201067203242
   */
  codeVersion?: string;
  /**
   * @remarks
   * The configuration information that can be used to upload to OSS.
   * 
   * @example
   * {
   *             "Url": "http://oss_fake_bucket_url",
   *             "OSSAccessKeyId": "xxx",
   *             "key": "site_er_js/hello.1418586423220543.unstable.js",
   *             "callback": "xxx==",
   *             "x:codeDescription": "xxx=",
   *             "policy": "xxx",
   *             "Signature": "xxx="
   * }
   */
  ossPostConfig?: { [key: string]: any };
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      codeVersion: 'CodeVersion',
      ossPostConfig: 'OssPostConfig',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeVersion: 'string',
      ossPostConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineStagingCodeUploadInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRoutineStagingCodeUploadInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRoutineStagingCodeUploadInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineStagingEnvIpResponseBody extends $tea.Model {
  /**
   * @remarks
   * The IPv4 addresses.
   */
  IPV4?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      IPV4: 'IPV4',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      IPV4: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineStagingEnvIpResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRoutineStagingEnvIpResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRoutineStagingEnvIpResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineUserInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  /**
   * @remarks
   * The routines.
   */
  routines?: GetRoutineUserInfoResponseBodyRoutines[];
  /**
   * @remarks
   * The subdomains.
   */
  subdomains?: string[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      routines: 'Routines',
      subdomains: 'Subdomains',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      routines: { 'type': 'array', 'itemType': GetRoutineUserInfoResponseBodyRoutines },
      subdomains: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineUserInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRoutineUserInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRoutineUserInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetScheduledPreloadJobRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the scheduled prefetch task.
   * 
   * This parameter is required.
   * 
   * @example
   * GetScheduledPreloadJob
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetScheduledPreloadJobResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 15685865xxx14622
   */
  aliUid?: string;
  /**
   * @remarks
   * The time when the task was created.
   * 
   * @example
   * 2024-06-02T02:23:26Z
   */
  createdAt?: string;
  /**
   * @remarks
   * The domain names to be prefetched.
   * 
   * @example
   * testurl.com
   */
  domains?: string;
  /**
   * @remarks
   * The error message that is returned.
   * 
   * @example
   * invalid domain:test.com
   */
  errorInfo?: string;
  /**
   * @remarks
   * The URL of the OSS object that stores a list of URLs that failed the conditional check for prefetching.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  failedFileOss?: string;
  /**
   * @remarks
   * The ID of the URL list file, which can be used during downloads.
   * 
   * @example
   * 665d3b48621bccf3fe29e1a7
   */
  fileId?: string;
  /**
   * @remarks
   * The ID of the prefetch task.
   * 
   * @example
   * 665d3af3621bccf3fe29e1a4
   */
  id?: string;
  /**
   * @remarks
   * The method to submit the URLs to be prefetched.
   * 
   * @example
   * oss
   */
  insertWay?: string;
  /**
   * @remarks
   * The task name.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 190007158391808
   */
  siteId?: number;
  /**
   * @remarks
   * The number of submitted prefetch tasks.
   * 
   * @example
   * 1
   */
  taskSubmitted?: number;
  /**
   * @remarks
   * The task type. Valid values: refresh and preload.
   * 
   * @example
   * preload
   */
  taskType?: string;
  /**
   * @remarks
   * The total number of URLs.
   * 
   * @example
   * 2
   */
  urlCount?: number;
  /**
   * @remarks
   * The number of submitted URLs.
   * 
   * @example
   * 1
   */
  urlSubmitted?: number;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      createdAt: 'CreatedAt',
      domains: 'Domains',
      errorInfo: 'ErrorInfo',
      failedFileOss: 'FailedFileOss',
      fileId: 'FileId',
      id: 'Id',
      insertWay: 'InsertWay',
      name: 'Name',
      requestId: 'RequestId',
      siteId: 'SiteId',
      taskSubmitted: 'TaskSubmitted',
      taskType: 'TaskType',
      urlCount: 'UrlCount',
      urlSubmitted: 'UrlSubmitted',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'string',
      createdAt: 'string',
      domains: 'string',
      errorInfo: 'string',
      failedFileOss: 'string',
      fileId: 'string',
      id: 'string',
      insertWay: 'string',
      name: 'string',
      requestId: 'string',
      siteId: 'number',
      taskSubmitted: 'number',
      taskType: 'string',
      urlCount: 'number',
      urlSubmitted: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetScheduledPreloadJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetScheduledPreloadJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetScheduledPreloadJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteRequest extends $tea.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9732E117-8A37-49FD-A36F-ABBB87556CA7
   */
  requestId?: string;
  /**
   * @remarks
   * The queried website information.
   */
  siteModel?: GetSiteResponseBodySiteModel;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      siteModel: 'SiteModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      siteModel: GetSiteResponseBodySiteModel,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSiteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSiteResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteCurrentNSRequest extends $tea.Model {
  /**
   * @remarks
   * The website ID. It can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteCurrentNSResponseBody extends $tea.Model {
  /**
   * @remarks
   * The nameservers of the website.
   */
  NSList?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2430E05E-1340-5773-B5E1-B743929F46F2
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      NSList: 'NSList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      NSList: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteCurrentNSResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSiteCurrentNSResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSiteCurrentNSResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteCustomLogRequest extends $tea.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 11223***
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteCustomLogResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the custom log field configuration.
   * 
   * @example
   * 6befa4aa-2a94-4f51-a245-295787192d2c
   */
  configId?: number;
  /**
   * @remarks
   * Indicates whether the custom configuration exists.
   * 
   * @example
   * true
   */
  isExist?: boolean;
  /**
   * @remarks
   * The custom fields.
   */
  logCustomField?: GetSiteCustomLogResponseBodyLogCustomField;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6befa4aa-2a94-4f51-a245-295787192d2c
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 167026711***
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      isExist: 'IsExist',
      logCustomField: 'LogCustomField',
      requestId: 'RequestId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      isExist: 'boolean',
      logCustomField: GetSiteCustomLogResponseBodyLogCustomField,
      requestId: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteCustomLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSiteCustomLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSiteCustomLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteDeliveryTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 123456***
   */
  siteId?: number;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * cdn-test-task
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteDeliveryTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   dcdn_log_access_l1 (default): access logs.
   * *   dcdn_log_er: Edge Routine logs.
   * *   dcdn_log_waf: firewall logs.
   * *   dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The data center. Valid values:
   * 
   * 1.  cn: the Chinese mainland.
   * 2.  sg: outside the Chinese mainland.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The destination of the delivery. Valid values:
   * 
   * 1.  sls: Alibaba Cloud Simple Log Service (SLS).
   * 2.  http: HTTP server.
   * 3.  aws3: Amazon Simple Storage Service (S3).
   * 4.  oss: Alibaba Cloud Object Storage Service (OSS).
   * 5.  kafka: Kafka.
   * 6.  aws3cmpt: S3-compatible storage service.
   * 
   * @example
   * sls
   */
  deliveryType?: string;
  /**
   * @remarks
   * The discard rate.
   * 
   * @example
   * 0.0
   */
  discardRate?: number;
  /**
   * @remarks
   * The log fields.
   * 
   * @example
   * Client,UserAgent
   */
  fieldList?: string;
  /**
   * @remarks
   * The filtering rules.
   * 
   * @example
   * []
   */
  filterRules?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34DCBC8A-****-****-****-6DAA11D7DDBD
   */
  requestId?: string;
  /**
   * @remarks
   * The delivery configuration.
   * 
   * @example
   * {\\"Region\\": \\"cn-hangzhou\\", \\"Endpoint\\": \\"https://***.oss-cn-hangzhou.aliyuncs.com\\", \\"BucketPath\\": \\"hjy-test002/online-logs\\"}
   */
  sinkConfig?: any;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * test.***.com
   */
  siteName?: string;
  /**
   * @remarks
   * The status of the delivery task.
   * 
   * *   **online**
   * *   **offline**
   * 
   * @example
   * online
   */
  status?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * @example
   * cdn-test-task
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      dataCenter: 'DataCenter',
      deliveryType: 'DeliveryType',
      discardRate: 'DiscardRate',
      fieldList: 'FieldList',
      filterRules: 'FilterRules',
      requestId: 'RequestId',
      sinkConfig: 'SinkConfig',
      siteId: 'SiteId',
      siteName: 'SiteName',
      status: 'Status',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      dataCenter: 'string',
      deliveryType: 'string',
      discardRate: 'number',
      fieldList: 'string',
      filterRules: 'string',
      requestId: 'string',
      sinkConfig: 'any',
      siteId: 'number',
      siteName: 'string',
      status: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteDeliveryTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSiteDeliveryTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSiteDeliveryTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteLogDeliveryQuotaRequest extends $tea.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * 1.  dcdn_log_access_l1 (default): access logs.
   * 2.  dcdn_log_er: Edge Routine logs.
   * 3.  dcdn_log_waf: firewall logs.
   * 4.  dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * This parameter is required.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteLogDeliveryQuotaResponseBody extends $tea.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * 1.  dcdn_log_access_l1 (default): access logs.
   * 2.  dcdn_log_er: Edge Routine logs.
   * 3.  dcdn_log_waf: firewall logs.
   * 4.  dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The remaining quota.
   * 
   * @example
   * 3
   */
  freeQuota?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4C14840EF0EAAB6D97CDE0C5F6554ACE
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      freeQuota: 'FreeQuota',
      requestId: 'RequestId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      freeQuota: 'number',
      requestId: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteLogDeliveryQuotaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSiteLogDeliveryQuotaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSiteLogDeliveryQuotaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteWafSettingsRequest extends $tea.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteWafSettingsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The WAF configurations of the website.
   */
  settings?: WafSiteSettings;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      settings: 'Settings',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      settings: WafSiteSettings,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteWafSettingsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSiteWafSettingsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSiteWafSettingsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUploadTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The ID of the file upload task. This field is assigned after you call the [UploadFile](https://help.aliyun.com/document_detail/435925.html) operation.
   * 
   * @example
   * 159253299357****
   */
  uploadId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      uploadId: 'UploadId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      uploadId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUploadTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error message returned when the file upload task failed.
   * 
   * @example
   * invalid url
   */
  description?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * ET5BF670-09D5-4D0B-BEBY-D96A2A52****
   */
  requestId?: string;
  /**
   * @remarks
   * The task status.
   * 
   * *   **INIT**: The task is being initialized.
   * *   **activacted**: The task is activated.
   * *   **running**: The task is running.
   * *   **success**: The task is successful.
   * *   **partial**: The task is partially successful.
   * *   **fail**: The task failed.
   * 
   * @example
   * running
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUploadTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetUploadTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetUploadTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserDeliveryTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * test_project
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserDeliveryTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   **dcdn_log_access_l1** (default): access logs.
   * *   **dcdn_log_er**: Edge Routine logs.
   * *   **dcdn_log_waf**: firewall logs.
   * *   **dcdn_log_ipa**: TCP/UDP proxy logs.
   * 
   * @example
   * dcdn_log_er
   */
  businessType?: string;
  /**
   * @remarks
   * The data center. Valid values:
   * 
   * *   cn: the Chinese mainland.
   * *   sg: outside the Chinese mainland.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The destination of the delivery. Valid values:
   * 
   * *   sls: Alibaba Cloud Simple Log Service (SLS).
   * *   http: HTTP server.
   * *   aws3: Amazon Simple Storage Service (S3).
   * *   oss: Alibaba Cloud Object Storage Service (OSS).
   * *   kafka: Kafka.
   * *   aws3cmpt: S3-compatible storage service.
   * 
   * @example
   * oss
   */
  deliveryType?: string;
  /**
   * @remarks
   * The discard rate.
   * 
   * @example
   * 0
   */
  discardRate?: number;
  /**
   * @remarks
   * The fields.
   * 
   * @example
   * ClientRequestID,ClientRequestHost
   */
  fieldList?: string;
  /**
   * @remarks
   * The filtering rules.
   * 
   * @example
   * [{"ClientSSLProtocol": {"equals": ["TLSv1.3"]}}]
   */
  filterRules?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 7072132a-bd3c-46a6-9e81-aba3e0e3f861
   */
  requestId?: string;
  /**
   * @remarks
   * The delivery configuration.
   * 
   * @example
   * {\\"Project\\": \\"er-online-hjy-pro\\", \\"Logstore\\": \\"er-online-hjy-log\\", \\"Region\\": \\"cn-hangzhou\\", \\"Endpoint\\": \\"cn-hangzhou.log.aliyuncs.com\\", \\"Aliuid\\": \\"1077912128805410\\"}
   */
  sinkConfig?: any;
  /**
   * @remarks
   * The status of the delivery task.
   * 
   * @example
   * online
   */
  status?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * @example
   * testoss11
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      dataCenter: 'DataCenter',
      deliveryType: 'DeliveryType',
      discardRate: 'DiscardRate',
      fieldList: 'FieldList',
      filterRules: 'FilterRules',
      requestId: 'RequestId',
      sinkConfig: 'SinkConfig',
      status: 'Status',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      dataCenter: 'string',
      deliveryType: 'string',
      discardRate: 'number',
      fieldList: 'string',
      filterRules: 'string',
      requestId: 'string',
      sinkConfig: 'any',
      status: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserDeliveryTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetUserDeliveryTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetUserDeliveryTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserLogDeliveryQuotaRequest extends $tea.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   dcdn_log_access_l1 (default): access logs.
   * *   dcdn_log_er: Edge Routine logs.
   * *   dcdn_log_waf: firewall logs.
   * *   dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * This parameter is required.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserLogDeliveryQuotaResponseBody extends $tea.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   dcdn_log_access_l1 (default): access logs.
   * *   dcdn_log_er: Edge Routine logs.
   * *   dcdn_log_waf: firewall logs.
   * *   dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The remaining quota.
   * 
   * @example
   * 3
   */
  freeQuota?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34DCBC8A-****-****-****-6DAA11D7DDBD
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      freeQuota: 'FreeQuota',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      freeQuota: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserLogDeliveryQuotaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetUserLogDeliveryQuotaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetUserLogDeliveryQuotaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafBotAppKeyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The application key.
   * 
   * @example
   * example_appkey
   */
  appKey?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      appKey: 'AppKey',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appKey: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafBotAppKeyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWafBotAppKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWafBotAppKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafFilterRequest extends $tea.Model {
  /**
   * @remarks
   * The WAF rule category to which the filter conditions to query belong.
   * 
   * @example
   * http_bot
   */
  phase?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The condition for matching incoming requests.
   * 
   * @example
   * characteristics
   */
  target?: string;
  /**
   * @remarks
   * The rule type.
   * 
   * @example
   * http_custom_cc
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      phase: 'Phase',
      siteId: 'SiteId',
      target: 'Target',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      phase: 'string',
      siteId: 'number',
      target: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafFilterResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned match conditions.
   */
  filter?: GetWafFilterResponseBodyFilter;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      filter: 'Filter',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filter: GetWafFilterResponseBodyFilter,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafFilterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWafFilterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWafFilterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafQuotaRequest extends $tea.Model {
  /**
   * @remarks
   * The type of WAF resources. Valid values:
   * 
   * *   managed_rules_group: the managed rule group.
   * *   list: the custom list.
   * *   page: the custom error page.
   * *   scene_policy: the scenario-specific policy.
   * 
   * @example
   * page
   */
  paths?: string;
  static names(): { [key: string]: string } {
    return {
      paths: 'Paths',
    };
  }

  static types(): { [key: string]: any } {
    return {
      paths: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafQuotaResponseBody extends $tea.Model {
  /**
   * @remarks
   * The quota information returned.
   */
  quota?: GetWafQuotaResponseBodyQuota;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      quota: 'Quota',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quota: GetWafQuotaResponseBodyQuota,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafQuotaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWafQuotaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWafQuotaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the WAF rule, which can be obtained by calling the [ListWafRules](https://help.aliyun.com/document_detail/2850237.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 20000001
   */
  id?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The configuration of the rule.
   */
  config?: WafRuleConfig;
  /**
   * @remarks
   * The ID of the WAF rule.[](~~2850237~~)
   * 
   * @example
   * 2000001
   */
  id?: number;
  /**
   * @remarks
   * The rule name.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The WAF rule category.
   * 
   * This parameter is required.
   * 
   * @example
   * http_custom
   */
  phase?: string;
  /**
   * @remarks
   * The order of the rule in the ruleset.
   * 
   * @example
   * 1
   */
  position?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the rule is enabled.
   * 
   * @example
   * on
   */
  status?: string;
  /**
   * @remarks
   * The time when the rule was last modified.
   * 
   * @example
   * 2024-01-01T00:00:00Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      id: 'Id',
      name: 'Name',
      phase: 'Phase',
      position: 'Position',
      requestId: 'RequestId',
      status: 'Status',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: WafRuleConfig,
      id: 'number',
      name: 'string',
      phase: 'string',
      position: 'number',
      requestId: 'string',
      status: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWafRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWafRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafRulesetRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the WAF ruleset, which can be obtained by calling the [ListWafRulesets](https://help.aliyun.com/document_detail/2850233.html) operation.
   * 
   * @example
   * 10000001
   */
  id?: number;
  /**
   * @remarks
   * The WAF rule category of rulesets to query.
   * 
   * @example
   * http_bot
   */
  phase?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 1
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      phase: 'Phase',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      phase: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafRulesetResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ruleset ID.
   * 
   * @example
   * 10000001
   */
  id?: number;
  /**
   * @remarks
   * The ruleset name.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The WAF rule category of the ruleset.
   * 
   * This parameter is required.
   * 
   * @example
   * http_bot
   */
  phase?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The rule configurations in the ruleset.
   */
  rules?: WafRuleConfig[];
  /**
   * @remarks
   * The configurations shared by the rules in the ruleset.
   */
  shared?: WafBatchRuleShared;
  /**
   * @remarks
   * The ruleset status.
   * 
   * @example
   * on
   */
  status?: string;
  /**
   * @remarks
   * The time when the ruleset was last modified.
   * 
   * @example
   * 2024-01-01T00:00:00Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
      phase: 'Phase',
      requestId: 'RequestId',
      rules: 'Rules',
      shared: 'Shared',
      status: 'Status',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
      phase: 'string',
      requestId: 'string',
      rules: { 'type': 'array', 'itemType': WafRuleConfig },
      shared: WafBatchRuleShared,
      status: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafRulesetResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWafRulesetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWafRulesetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCacheReserveInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the cache reserve instance.
   * 
   * @example
   * sp-xcdn-96wblslz****
   */
  instanceId?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: **1 to 500**. Default value: **500**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The criterion by which you want to sort the queried instances. Valid values:
   * 
   * *   ExpireTime: sorts the instances by the time when the instances expire.
   * *   CreateTime: sorts the instances by the time when the instances were purchased.
   * 
   * @example
   * ExpireTime
   */
  sortBy?: string;
  /**
   * @remarks
   * The order by which you want to sort the queried instances. Valid values:
   * 
   * *   asc: in ascending order.
   * *   desc: in descending order.
   * 
   * @example
   * desc
   */
  sortOrder?: string;
  /**
   * @remarks
   * The status of the cache reserve instance. Valid values:
   * 
   * *   online: The instance is in service.
   * *   offline: The instance has expired within an allowable period. In this state, the plan is unavailable.
   * *   disable: The instance is released.
   * *   overdue: The instance is stopped due to overdue payments.
   * 
   * @example
   * ListCacheReserveInstances
   * 
   * **if can be null:**
   * false
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      sortBy: 'SortBy',
      sortOrder: 'SortOrder',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      sortBy: 'string',
      sortOrder: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCacheReserveInstancesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The cache reserve instances.
   */
  instanceInfo?: ListCacheReserveInstancesResponseBodyInstanceInfo[];
  /**
   * @remarks
   * The page number. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: **500**. Valid values: **1 to 500**.
   * 
   * @example
   * 500
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 65C66B7B-671A-8297-9187-2R5477247B76
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 16
   */
  totalCount?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 1
   */
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      instanceInfo: 'InstanceInfo',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceInfo: { 'type': 'array', 'itemType': ListCacheReserveInstancesResponseBodyInstanceInfo },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCacheReserveInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCacheReserveInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCacheReserveInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientCertificatesRequest extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The website ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientCertificatesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number returned.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  /**
   * @remarks
   * The client certificates.
   */
  result?: ListClientCertificatesResponseBodyResult[];
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The total number of entries.
   * 
   * @example
   * 5
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      result: 'Result',
      siteId: 'SiteId',
      siteName: 'SiteName',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListClientCertificatesResponseBodyResult },
      siteId: 'number',
      siteName: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientCertificatesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListClientCertificatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListClientCertificatesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppRecordsRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The sorting field. Valid values:
   * 
   * *   CreateTime: the time when the domain name was associated.
   * *   CreateTime: the time when the domain name was last modified.
   * 
   * @example
   * CreateTime
   */
  orderKey?: string;
  /**
   * @remarks
   * The order in which you want to sort the query results. Valid values:
   * 
   * *   ASC: in ascending order.
   * *   DESC: in descending order.
   * 
   * @example
   * DESC
   */
  orderType?: string;
  /**
   * @remarks
   * The page number. Valid values: **1** to **100000**. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 20. Valid values: 1 to 500.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The keyword that is used for the search.
   * 
   * @example
   * ver-1006157458290860032
   */
  searchKey?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      orderKey: 'OrderKey',
      orderType: 'OrderType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      orderKey: 'string',
      orderType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppRecordsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The details about the associated domain names.
   */
  records?: ListEdgeContainerAppRecordsResponseBodyRecords[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The number of domain names that are associated with the specified application.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      records: 'Records',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      records: { 'type': 'array', 'itemType': ListEdgeContainerAppRecordsResponseBodyRecords },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppRecordsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEdgeContainerAppRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEdgeContainerAppRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppVersionsRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The sorting field. Valid values:
   * 
   * *   Name: the version name.
   * *   CreateTime: the time when the version was created.
   * *   UpdateTime: the time when the version was last modified.
   * 
   * @example
   * Name
   */
  orderKey?: string;
  /**
   * @remarks
   * The order in which you want to sort the query results. Valid values:
   * 
   * *   ASC: in ascending order.
   * *   DESC: in descending order.
   * 
   * @example
   * DESC
   */
  orderType?: string;
  /**
   * @remarks
   * The page number. Valid values: 1 to 65535.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 1 to 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The keyword used for the search.
   * 
   * @example
   * ver-100568263967926****
   */
  searchKey?: string;
  /**
   * @remarks
   * The parameter used for fuzzy search. Valid values: VersionId and Name.
   * 
   * @example
   * VersionId
   */
  searchType?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      orderKey: 'OrderKey',
      orderType: 'OrderType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      searchType: 'SearchType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      orderKey: 'string',
      orderType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
      searchType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppVersionsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F61CDR30-E83C-4FDA-BF73-9A94CDD44229
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  /**
   * @remarks
   * The versions.
   */
  versions?: ListEdgeContainerAppVersionsResponseBodyVersions[];
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      versions: 'Versions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      versions: { 'type': 'array', 'itemType': ListEdgeContainerAppVersionsResponseBodyVersions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppVersionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEdgeContainerAppVersionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEdgeContainerAppVersionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppsRequest extends $tea.Model {
  /**
   * @remarks
   * The sorting field. This parameter is left empty by default. Valid values:
   * 
   * *   Name: the version name.
   * *   CreateTime: the time when the version was created.
   * *   UpdateTime: the time when the version was last modified.
   * 
   * @example
   * CreateTime
   */
  orderKey?: string;
  /**
   * @remarks
   * The order in which you want to sort the query results. This parameter is left empty by default. Valid values:
   * 
   * *   ASC: in ascending order.
   * *   DESC: in descending order.
   * 
   * @example
   * Asc
   */
  orderType?: string;
  /**
   * @remarks
   * The page number. Default value: **1**. Valid values: 1 to 65535.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: **20**. Valid values: 1 to 500.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * ver-1005682639679266816
   */
  searchKey?: string;
  /**
   * @remarks
   * The search criterion based on which you want to perform fuzzy search. Valid values:
   * 
   * *   Appid: the application ID.
   * *   Name: the application name.
   * 
   * @example
   * Appid
   */
  searchType?: string;
  static names(): { [key: string]: string } {
    return {
      orderKey: 'OrderKey',
      orderType: 'OrderType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      searchType: 'SearchType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderKey: 'string',
      orderType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
      searchType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The queried applications.
   */
  apps?: ListEdgeContainerAppsResponseBodyApps[];
  /**
   * @remarks
   * The page number. Default value: **1**. Valid values: 1 to 65535.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 1 to 500.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2430E05E-1340-5773-B5E1-B743929F46F2
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries.
   * 
   * @example
   * 10
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apps: 'Apps',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apps: { 'type': 'array', 'itemType': ListEdgeContainerAppsResponseBodyApps },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEdgeContainerAppsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEdgeContainerAppsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerRecordsRequest extends $tea.Model {
  /**
   * @remarks
   * The page number. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: **500**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The match mode to filter the record names:
   * 
   * *   **fuzzy**
   * *   **prefix**
   * *   **suffix**
   * *   **exact** (default)
   * 
   * @example
   * fuzzy
   */
  recordMatchType?: string;
  /**
   * @remarks
   * The record name.
   * 
   * @example
   * a.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      recordMatchType: 'RecordMatchType',
      recordName: 'RecordName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      recordMatchType: 'string',
      recordName: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerRecordsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The records.
   */
  records?: ListEdgeContainerRecordsResponseBodyRecords[];
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of records returned.
   * 
   * @example
   * 50
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      records: 'Records',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      records: { 'type': 'array', 'itemType': ListEdgeContainerRecordsResponseBodyRecords },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerRecordsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEdgeContainerRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEdgeContainerRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeRoutinePlansResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 1 to 500.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The plans.
   */
  planInfo?: ListEdgeRoutinePlansResponseBodyPlanInfo[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 12
   */
  totalCount?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 1
   */
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      planInfo: 'PlanInfo',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      planInfo: { 'type': 'array', 'itemType': ListEdgeRoutinePlansResponseBodyPlanInfo },
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeRoutinePlansResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEdgeRoutinePlansResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEdgeRoutinePlansResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeRoutineRecordsRequest extends $tea.Model {
  /**
   * @remarks
   * The page number. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: **500**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The match mode to filter the record names.
   * 
   * *   **fuzzy**: fuzzy match.
   * *   **prefix**: match by prefix.
   * *   **suffix**: match by suffix.
   * *   **exact** (default): exact match .
   * 
   * @example
   * fuzzy
   */
  recordMatchType?: string;
  /**
   * @remarks
   * The record name.
   * 
   * @example
   * a.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      recordMatchType: 'RecordMatchType',
      recordName: 'RecordName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      recordMatchType: 'string',
      recordName: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeRoutineRecordsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The list of records.
   */
  records?: ListEdgeRoutineRecordsResponseBodyRecords[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of records returned.
   * 
   * @example
   * 121
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      records: 'Records',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      records: { 'type': 'array', 'itemType': ListEdgeRoutineRecordsResponseBodyRecords },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeRoutineRecordsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEdgeRoutineRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEdgeRoutineRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceQuotasRequest extends $tea.Model {
  /**
   * @remarks
   * The plan ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * sp-xcdn-96wblslz****
   */
  instanceId?: string;
  /**
   * @remarks
   * The quota names in the plan. Separate multiple names with commas (,). Valid values:
   * 
   * *   **waf:phase:http_anti_scan:actions**: the actions in WAF scan protection rules.
   * *   **waf:phase:http_bot:actions**: all actions in WAF bot management rules.
   * *   **waf:phase:http_bot:http_custom_cc_dev:characteristic:fields**: the statistical objects for the custom device-based throttling in WAF bot management rules.
   * *   **waf:phase:http_bot:http_custom_cc_ip:characteristic:fields**: the statistical objects for the custom IP address-based throttling in WAF bot management rules.
   * *   ****waf:phase:http_bot:match:symbols****: the match operators in WAF bot management rules.
   * *   **waf:phase:http_bot:http_custom_cc:characteristic:fields**: the statistical objects for the custom session-based throttling in WAF bot management rules.
   * *   **waf:phase:http_bot:match:fields**: the match fields in WAF bot management rules.
   * *   **waf:phase:http_whitelist:match:symbols**: the match operators in WAF whitelist rules.
   * *   **waf:phase:http_whitelist:match:fields**: the match fields in WAF whitelist rules.
   * *   **waf:phase:http_anti_scan:http_directory_traversal:characteristic:fields**: the statistical objects for directory traversal blocking in WAF scan protection rules.
   * *   **waf:phase:http_anti_scan:http_high_frequency:characteristic:fields**: the statistical objects for high-frequency scanning blocking in WAF scan protection rules.
   * *   **waf:phase:http_anti_scan:match:symbols**: the match operators in WAF scan protection rules.
   * *   **waf:phase:http_anti_scan:match:fields**: the match fields in WAF scan protection rules.
   * *   **waf:phase:http_managed:actions**: the actions in WAF managed rules.
   * *   **waf:phase:http_managed:group:reference:ids**: the referenced rule groups in WAF managed rules.
   * *   **waf:phase:http_ratelimit:actions**: the actions in WAF rate limiting rules.
   * *   **waf:phase:http_ratelimit:ttls**: the action durations in WAF rate limiting rules.
   * *   **waf:phase:http_ratelimit:intervals**: the statistical durations in WAF rate limiting rules.
   * *   **waf:phase:http_ratelimit:http_ratelimit:characteristic:fields**: the match characteristics in WAF rate limiting rules.
   * *   **waf:phase:http_ratelimit:match:symbols**: the match operators in WAF rate limiting rules.
   * *   **waf:phase:http_ratelimit:match:fields**: the match fields in WAF rate limiting rules.
   * *   **waf:phase:http_custom:actions**: the actions in custom WAF rules.
   * *   **waf:phase:http_custom:match:symbols**: the match operators in custom WAF rules.
   * *   **waf:phase:http_custom:match:fields**: the match fields in custom WAF rules.
   * *   **waiting_room|queuing_method**: the queuing method in Waiting Room.
   * *   **origin_rules|origin_scheme**: the origin protocol in origin rules.
   * *   **origin_rules|origin_sni**: the origin Server Name Indication (SNI) in origin rules.
   * *   **origin_rules|origin_host**: the origin host in origin rules.
   * *   **fourlayeracceleration**: TCP/UDP proxy.
   * *   **rtlog_service**: the availability to collect real-time logs.
   * *   **dashboard_traffic**: the value-added capability of traffic analytics.
   * *   **custom_name_server**: the availability to configure custom nameservers.
   * *   **waf:phase:http_bot:enable**: the availability to enable WAF bot management.
   * *   **waf:phase:http_whitelist:enable**: the availability to configure WAF whitelist rules.
   * *   **instantlog**: the availability to collect instant logs.
   * *   **waf:phase:http_anti_scan:enable**: the availability to enable WAF scan protection.
   * *   **waf:phase:http_managed:group:reference:enable**: the availability to configure reference rule groups in WAF managed rules.
   * *   **waf:phase:http_managed:enable**: the availability to configure WAF managed rules.
   * *   **waf:phase:http_ratelimit:on_hit:enable**: the availability to configure whether to apply rate limiting to all requests that hit the cache.
   * *   **ddos**: DDoS mitigation.
   * *   **waf:phase:http_ratelimit:enable**: the availability to configure WAF rate limiting.
   * *   **waf:phase:http_custom:enable**: the availability to configure custom WAF rules.
   * *   **waf:phase:all:page:reference:enable**: the availability to configure custom error pages.
   * *   **rules_support_regex**: the support for regular expressions in rules engine.
   * *   **waiting_room_event**: scheduled events in Waiting Room.
   * *   **waiting_room_rule**: the availability to allow requests to bypass the waiting room.
   * *   **waiting_room|json_response**: the availability to enable JSON response in Waiting Room.
   * *   **waiting_room|disable_session_renewal**: the availability to disable session renewal in Waiting Room.
   * *   **origin_rules|dns_record**: DNS records in origin rules.
   * *   **managed_transforms|add_client_geolocation_headers**: the availability to configure whether to add geolocation headers in transform rules.
   * *   **tiered_cache|regional_enable**: regional tiered cache.
   * *   **real_client_ip_header**: the availability to configure whether to add the real IP address of a client to the request header.
   * *   **data_timerange**: minute-level time range for data query.
   * *   **cache_rules|edge_cache_ttl**: POP cache TTL.
   * *   **cache_rules|browser_cache_ttl**: browser cache TTL.
   * *   **fourLayerRecordCount**: the maximum number of records of websites for which TCP/UDP acceleration is enabled.
   * *   **waitingroomRuleCount**: the maximum number of rules per waiting room.
   * *   **waitingroomEventCount**: the maximum number of events per waiting room.
   * *   **waitingroom_custom_pathhost**: the availability to configure the hostname and path in Waiting Room.
   * *   **er_routers**: Edge Routine routes.
   * *   **cache_rules|rule_quota**: the maximum number of cache rules.
   * *   **configuration_rules|rule_quota**: the maximum number of configuration rules.
   * *   **redirect_rules|rule_quota**: the redirect rules.
   * *   **compression_rules|rule_quota**: the maximum number of compression rules.
   * *   **origin_rules|rule_quota**: the maximum number of origin rules.
   * *   **waf:phase:http_bot:rulesets_per_instance:less_than_or_equal**: the maximum number of rulesets in WAF bot management per plan.
   * *   **waf:phase:http_whitelist:rules_per_instance:less_than_or_equal**: the maximum number of WAF whitelist rules per plan.
   * *   **rtlog_quota**: the maximum number of real-time log delivery tasks.
   * *   **waf:phase:http_anti_scan:rulesets_per_instance:less_than_or_equal**: the maximum number of rulesets in WAF scan protection per plan.
   * *   **ddos_instance**: the number of Anti-DDoS Proxy instances.
   * *   **waf:phase:http_ratelimit:rules_per_instance:less_than_or_equal**: the maximum number of WAF rate limiting rules.
   * *   **waf:phase:http_custom:rules_per_instance:less_than_or_equal**: the maximum number of custom WAF rules per plan.
   * *   **ruleNestedConditionalCount**: the number of nested layers in a rule.
   * *   **waiting_room_rule**: Waiting Room.
   * *   **transition_rule**: the maximum number of transform rules.
   * *   **customHttpCert**: the maximum number of custom certificates.
   * *   **free_cert**: the maximum number of free certificates.
   * *   **preload**: prefetch.
   * *   **refresh_cache_tag**: purge by cache tag.
   * *   **refresh_ignore_param**: purge by URL with specified parameters ignored.
   * *   **refresh_directory**: purge by directory.
   * *   **refresh_hostname**: purge by hostname.
   * *   **refresh_all**: purge all cache.
   * *   **refresh_file**: purge by URL.
   * *   **wildcard**: the maximum number of wildcard domains.
   * *   **recordCount**: the maximum number of Layer 7 records.
   * *   **siteCount**: the maximum number of websites that can be associated with the plan.
   * *   **https|rule_quota**: the maximum number of SSL/TLS rules.
   * 
   * This parameter is required.
   * 
   * @example
   * preload, free_cert
   */
  quotaNames?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 2882900****
   * 
   * **if can be null:**
   * false
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      quotaNames: 'QuotaNames',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      quotaNames: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceQuotasResponseBody extends $tea.Model {
  /**
   * @remarks
   * The plan ID.
   * 
   * @example
   * sp-xcdn-96wblslz****
   */
  instanceId?: string;
  /**
   * @remarks
   * The quotas in the plan.
   */
  quotas?: ListInstanceQuotasResponseBodyQuotas[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247B78
   */
  requestId?: string;
  /**
   * @remarks
   * The plan status. Valid values:
   * 
   * *   online: The plan is in service.
   * *   offline: The plan has expired within an allowable period. In this state, the plan is unavailable.
   * *   disable: The plan is released.
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      quotas: 'Quotas',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      quotas: { 'type': 'array', 'itemType': ListInstanceQuotasResponseBodyQuotas },
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceQuotasResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListInstanceQuotasResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInstanceQuotasResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceQuotasWithUsageRequest extends $tea.Model {
  /**
   * @remarks
   * The plan ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * sp-xcdn-96wblslz****
   */
  instanceId?: string;
  /**
   * @remarks
   * The quota names in the plan. Separate the quota names with commas (,). You can query up to 10 quota names at a time. Valid values:
   * 
   * *   **customHttpCert**: the custom certificates.
   * *   **transition_rule**: the transform rules.
   * *   **waiting_room**: the waiting rooms.
   * *   **https|rule_quota**: the SSL/TLS rules.
   * *   **cache_rules|rule_quota**: the cache rules.
   * *   **configuration_rules|rule_quota**: the configuration rules.
   * *   **redirect_rules|rule_quota**: the redirect rules.
   * *   **compression_rules|rule_quota**: the compression rules.
   * *   **origin_rules|rule_quota**: the origin rules.
   * 
   * This parameter is required.
   * 
   * @example
   * customHttpCert
   */
  quotaNames?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 1232223****
   * 
   * **if can be null:**
   * false
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      quotaNames: 'QuotaNames',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      quotaNames: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceQuotasWithUsageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The plan ID.[](~~2850189~~)
   * 
   * @example
   * sp-xcdn-96wblslz****
   */
  instanceId?: string;
  /**
   * @remarks
   * The quotas and their actual usage in the plan.
   */
  quotas?: ListInstanceQuotasWithUsageResponseBodyQuotas[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 85H66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  /**
   * @remarks
   * The plan status. Valid values:
   * 
   * *   online: The plan is in service.
   * *   offline: The plan has expired within an allowable period. In this state, the plan is unavailable.
   * *   disable: The plan is released.
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      quotas: 'Quotas',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      quotas: { 'type': 'array', 'itemType': ListInstanceQuotasWithUsageResponseBodyQuotas },
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceQuotasWithUsageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListInstanceQuotasWithUsageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInstanceQuotasWithUsageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListKvsRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreatevNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * The page number. The product of PageNumber and PageSize cannot exceed 50,000.
   * 
   * @example
   * 10
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 50. Maximum value: 100.
   * 
   * @example
   * 50
   */
  pageSize?: number;
  /**
   * @remarks
   * The prefix to query.
   * 
   * @example
   * prefix-
   */
  prefix?: string;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      prefix: 'Prefix',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      prefix: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListKvsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The key-value pairs.
   */
  keys?: ListKvsResponseBodyKeys[];
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 100
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 50
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1024
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      keys: 'Keys',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keys: { 'type': 'array', 'itemType': ListKvsResponseBodyKeys },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListKvsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListKvsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListKvsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListListsRequest extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The query arguments in the JSON format, which contain filter conditions.
   * 
   * @example
   * ListLists
   */
  queryArgs?: ListListsRequestQueryArgs;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      queryArgs: 'QueryArgs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      queryArgs: ListListsRequestQueryArgs,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListListsShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The query arguments in the JSON format, which contain filter conditions.
   * 
   * @example
   * ListLists
   */
  queryArgsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      queryArgsShrink: 'QueryArgs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      queryArgsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListListsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The array that contains list information, including list data after paging.
   */
  lists?: ListListsResponseBodyLists[];
  /**
   * @remarks
   * The page number returned.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of filtered lists.
   * 
   * @example
   * 5
   */
  totalCount?: number;
  /**
   * @remarks
   * The number of created lists.
   * 
   * @example
   * 10
   */
  usage?: number;
  static names(): { [key: string]: string } {
    return {
      lists: 'Lists',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      usage: 'Usage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lists: { 'type': 'array', 'itemType': ListListsResponseBodyLists },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      usage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListListsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListListsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListListsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancerRegionsRequest extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 1024
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancerRegionsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 1024
   */
  pageSize?: number;
  /**
   * @remarks
   * The regions.
   */
  regions?: ListLoadBalancerRegionsResponseBodyRegions[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 81A5E222-24BF-17EF-9E80-A68D9B8F363D
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 12
   */
  totalCount?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 1
   */
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regions: 'Regions',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      regions: { 'type': 'array', 'itemType': ListLoadBalancerRegionsResponseBodyRegions },
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancerRegionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListLoadBalancerRegionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListLoadBalancerRegionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListManagedRulesGroupsRequest extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListManagedRulesGroupsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the managed rule groups.
   */
  managedRulesGroups?: ListManagedRulesGroupsResponseBodyManagedRulesGroups[];
  /**
   * @remarks
   * The page number returned.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of managed rule groups returned.
   * 
   * @example
   * 5
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      managedRulesGroups: 'ManagedRulesGroups',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      managedRulesGroups: { 'type': 'array', 'itemType': ListManagedRulesGroupsResponseBodyManagedRulesGroups },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListManagedRulesGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListManagedRulesGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListManagedRulesGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPagesRequest extends $tea.Model {
  /**
   * @remarks
   * The page number. Valid values: **1 to 100000**. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 20.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPagesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number returned.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The custom error pages. Each element in the array contains error page-specific information.
   */
  pages?: ListPagesResponseBodyPages[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The number of custom error pages after filtering.
   * 
   * @example
   * 10
   */
  totalCount?: number;
  /**
   * @remarks
   * The number of custom error pages that you created.
   * 
   * @example
   * 10
   */
  usage?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      pages: 'Pages',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      usage: 'Usage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      pages: { 'type': 'array', 'itemType': ListPagesResponseBodyPages },
      requestId: 'string',
      totalCount: 'number',
      usage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPagesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPagesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPagesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRecordsRequest extends $tea.Model {
  /**
   * @remarks
   * The business scenario of the record for acceleration. Valid values:
   * 
   * *   **image_video**: video and image.
   * *   **api**: API.
   * *   **web**: web page.
   * 
   * @example
   * web
   */
  bizName?: string;
  /**
   * @remarks
   * The page number. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: **500**.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * Filters by whether the record is proxied. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  proxied?: boolean;
  /**
   * @remarks
   * The match mode to search for the record name. Default value: exact. Valid values:
   * 
   * *   **prefix**: match by prefix.
   * *   **suffix**: match by suffix.
   * *   **exact**: exact match.
   * *   **fuzzy**: fuzzy match.
   * 
   * @example
   * fuzzy
   */
  recordMatchType?: string;
  /**
   * @remarks
   * The record name. This parameter specifies a filter condition for the query.
   * 
   * @example
   * www.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The origin type of the record. Only CNAME records can be filtered by using this field. Valid values:
   * 
   * *   **OSS**: OSS bucket.
   * *   **S3**: S3 bucket.
   * *   **LB**: load balancer.
   * *   **OP**: origin pool.
   * *   **Domain**: domain name.
   * 
   * @example
   * OSS
   */
  sourceType?: string;
  /**
   * @remarks
   * The DNS record type.
   * 
   * @example
   * CNAME
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      bizName: 'BizName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      proxied: 'Proxied',
      recordMatchType: 'RecordMatchType',
      recordName: 'RecordName',
      siteId: 'SiteId',
      sourceType: 'SourceType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      proxied: 'boolean',
      recordMatchType: 'string',
      recordName: 'string',
      siteId: 'number',
      sourceType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRecordsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number returned.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The DNS record information. The format of this field varies based on the record type. For more information, see Add DNS records.
   */
  records?: ListRecordsResponseBodyRecords[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of records returned.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      records: 'Records',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      records: { 'type': 'array', 'itemType': ListRecordsResponseBodyRecords },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRecordsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRoutineCanaryAreasResponseBody extends $tea.Model {
  /**
   * @remarks
   * The regions for canary release.
   */
  canaryAreas?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      canaryAreas: 'CanaryAreas',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canaryAreas: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRoutineCanaryAreasResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRoutineCanaryAreasResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRoutineCanaryAreasResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRoutineOptionalSpecsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1234567890ABCDEF01234567890ABCDEF
   */
  requestId?: string;
  /**
   * @remarks
   * The available specifications.
   */
  specs?: ListRoutineOptionalSpecsResponseBodySpecs[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      specs: 'Specs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      specs: { 'type': 'array', 'itemType': ListRoutineOptionalSpecsResponseBodySpecs },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRoutineOptionalSpecsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRoutineOptionalSpecsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRoutineOptionalSpecsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScheduledPreloadExecutionsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the scheduled prefetch task.
   * 
   * This parameter is required.
   * 
   * @example
   * ListScheduledPreloadExecutions
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScheduledPreloadExecutionsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about prefetch plans returned.
   */
  executions?: ListScheduledPreloadExecutionsResponseBodyExecutions[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * ET5BF670-09D5-4D0B-BEBY-D96A2A528000
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      executions: 'Executions',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      executions: { 'type': 'array', 'itemType': ListScheduledPreloadExecutionsResponseBodyExecutions },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScheduledPreloadExecutionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListScheduledPreloadExecutionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListScheduledPreloadExecutionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScheduledPreloadJobsRequest extends $tea.Model {
  /**
   * @remarks
   * The end time for querying the task creation time range. Specify the timestamp in milliseconds.
   * 
   * @example
   * 1717225277000
   */
  endTime?: number;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The website ID.
   * 
   * This parameter is required.
   * 
   * @example
   * ListScheduledPreloadJobs
   */
  siteId?: number;
  /**
   * @remarks
   * The beginning of the task creation time range to query. Specify the timestamp in milliseconds.
   * 
   * @example
   * 1717225276000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      siteId: 'SiteId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      siteId: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScheduledPreloadJobsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of the prefetch tasks.
   */
  jobs?: ListScheduledPreloadJobsResponseBodyJobs[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of tasks returned.
   * 
   * @example
   * 5
   */
  totalCount?: string;
  static names(): { [key: string]: string } {
    return {
      jobs: 'Jobs',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobs: { 'type': 'array', 'itemType': ListScheduledPreloadJobsResponseBodyJobs },
      requestId: 'string',
      totalCount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScheduledPreloadJobsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListScheduledPreloadJobsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListScheduledPreloadJobsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteDeliveryTasksRequest extends $tea.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   dcdn_log_access_l1 (default): access logs.
   * *   dcdn_log_er: Edge Routine logs.
   * *   dcdn_log_waf: firewall logs.
   * *   dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The page number. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 20.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456***
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteDeliveryTasksResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number. Default value: 0.
   * 
   * @example
   * 0
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: **1 to 500**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34DCBC8A-****-****-****-6DAA11D7DDBD
   */
  requestId?: string;
  /**
   * @remarks
   * The delivery tasks.
   */
  tasks?: ListSiteDeliveryTasksResponseBodyTasks[];
  /**
   * @remarks
   * The total number of log delivery tasks.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      tasks: 'Tasks',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      tasks: { 'type': 'array', 'itemType': ListSiteDeliveryTasksResponseBodyTasks },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteDeliveryTasksResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSiteDeliveryTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSiteDeliveryTasksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsRequest extends $tea.Model {
  configId?: number;
  configType?: string;
  functionName?: string;
  pageNumber?: number;
  pageSize?: number;
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ListSiteFunctions
   */
  siteId?: number;
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      functionName: 'FunctionName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      functionName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBody extends $tea.Model {
  configs?: ListSiteFunctionsResponseBodyConfigs;
  pageNumber?: number;
  pageSize?: number;
  /**
   * @remarks
   * Id of the request
   */
  requestId?: string;
  totalCount?: number;
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: ListSiteFunctionsResponseBodyConfigs,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSiteFunctionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSiteFunctionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSitesRequest extends $tea.Model {
  /**
   * @remarks
   * The DNS setup. Valid values:
   * 
   * *   **NS**
   * *   **CNAME**
   * 
   * @example
   * NS
   */
  accessType?: string;
  /**
   * @remarks
   * The service location. Valid values:
   * 
   * *   **domestic**: the Chinese mainland
   * *   **global**: global
   * *   **overseas**: outside the Chinese mainland
   * 
   * @example
   * global
   */
  coverage?: string;
  /**
   * @remarks
   * Specifies whether to query only websites on Enterprise plans. Valid values: **true and false**.
   * 
   * @example
   * false
   */
  onlyEnterprise?: boolean;
  /**
   * @remarks
   * The page number. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: **500**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The plan type. Valid values:
   * 
   * *   **basicplan**: Entrance (coming soon)
   * *   **standardplan**: Pro
   * *   **advancedplan**: Premium
   * *   **enterpriseplan**: Enterprise
   * 
   * @example
   * basicplan
   */
  planSubscribeType?: string;
  /**
   * @remarks
   * The ID of the resource group. This parameter specifies a filter condition for the query.
   * 
   * @example
   * rg-aekzd3styujvyei
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The website name. This parameter specifies a filter condition for the query.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The match mode to search for the website name. Default value: exact. Valid values:
   * 
   * *   **prefix**: match by prefix.
   * *   **suffix**: match by suffix.
   * *   **exact**: exact match.
   * *   **fuzzy**: fuzzy match.
   * 
   * @example
   * fuzzy
   */
  siteSearchType?: string;
  /**
   * @remarks
   * The website status. This parameter specifies a filter condition for the query.
   * 
   * @example
   * pending
   */
  status?: string;
  /**
   * @remarks
   * The tag filtering rule.
   */
  tagFilter?: ListSitesRequestTagFilter[];
  static names(): { [key: string]: string } {
    return {
      accessType: 'AccessType',
      coverage: 'Coverage',
      onlyEnterprise: 'OnlyEnterprise',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      planSubscribeType: 'PlanSubscribeType',
      resourceGroupId: 'ResourceGroupId',
      siteName: 'SiteName',
      siteSearchType: 'SiteSearchType',
      status: 'Status',
      tagFilter: 'TagFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessType: 'string',
      coverage: 'string',
      onlyEnterprise: 'boolean',
      pageNumber: 'number',
      pageSize: 'number',
      planSubscribeType: 'string',
      resourceGroupId: 'string',
      siteName: 'string',
      siteSearchType: 'string',
      status: 'string',
      tagFilter: { 'type': 'array', 'itemType': ListSitesRequestTagFilter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSitesShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The DNS setup. Valid values:
   * 
   * *   **NS**
   * *   **CNAME**
   * 
   * @example
   * NS
   */
  accessType?: string;
  /**
   * @remarks
   * The service location. Valid values:
   * 
   * *   **domestic**: the Chinese mainland
   * *   **global**: global
   * *   **overseas**: outside the Chinese mainland
   * 
   * @example
   * global
   */
  coverage?: string;
  /**
   * @remarks
   * Specifies whether to query only websites on Enterprise plans. Valid values: **true and false**.
   * 
   * @example
   * false
   */
  onlyEnterprise?: boolean;
  /**
   * @remarks
   * The page number. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: **500**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The plan type. Valid values:
   * 
   * *   **basicplan**: Entrance (coming soon)
   * *   **standardplan**: Pro
   * *   **advancedplan**: Premium
   * *   **enterpriseplan**: Enterprise
   * 
   * @example
   * basicplan
   */
  planSubscribeType?: string;
  /**
   * @remarks
   * The ID of the resource group. This parameter specifies a filter condition for the query.
   * 
   * @example
   * rg-aekzd3styujvyei
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The website name. This parameter specifies a filter condition for the query.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The match mode to search for the website name. Default value: exact. Valid values:
   * 
   * *   **prefix**: match by prefix.
   * *   **suffix**: match by suffix.
   * *   **exact**: exact match.
   * *   **fuzzy**: fuzzy match.
   * 
   * @example
   * fuzzy
   */
  siteSearchType?: string;
  /**
   * @remarks
   * The website status. This parameter specifies a filter condition for the query.
   * 
   * @example
   * pending
   */
  status?: string;
  /**
   * @remarks
   * The tag filtering rule.
   */
  tagFilterShrink?: string;
  static names(): { [key: string]: string } {
    return {
      accessType: 'AccessType',
      coverage: 'Coverage',
      onlyEnterprise: 'OnlyEnterprise',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      planSubscribeType: 'PlanSubscribeType',
      resourceGroupId: 'ResourceGroupId',
      siteName: 'SiteName',
      siteSearchType: 'SiteSearchType',
      status: 'Status',
      tagFilterShrink: 'TagFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessType: 'string',
      coverage: 'string',
      onlyEnterprise: 'boolean',
      pageNumber: 'number',
      pageSize: 'number',
      planSubscribeType: 'string',
      resourceGroupId: 'string',
      siteName: 'string',
      siteSearchType: 'string',
      status: 'string',
      tagFilterShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSitesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of websites per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  /**
   * @remarks
   * The queried websites.
   */
  sites?: ListSitesResponseBodySites[];
  /**
   * @remarks
   * The total number of websites.
   * 
   * @example
   * 40
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      sites: 'Sites',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      sites: { 'type': 'array', 'itemType': ListSitesResponseBodySites },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSitesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSitesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSitesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * The maximum number of tags to return.
   * 
   * @example
   * 20
   */
  maxItem?: number;
  /**
   * @remarks
   * The pagination token that is used in the next request to retrieve a new page of results.
   * 
   * >  This parameter is not required for the first request. If not all results are returned in one query, you can specify the token that is obtained from the previous query as the value of **NextToken**.
   * 
   * @example
   * AAAAAZjtYxxxxxxxx
   */
  nextToken?: string;
  ownerId?: number;
  /**
   * @remarks
   * The ID of the region where the resources reside.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The website information. Valid values of he number of website IDs: **1** to **50**.
   */
  resourceId?: string[];
  /**
   * @remarks
   * The resource type.
   * 
   * This parameter is required.
   * 
   * @example
   * site
   */
  resourceType?: string;
  securityToken?: string;
  /**
   * @remarks
   * A list of tags. You can enter up to 20 tags.
   */
  tag?: ListTagResourcesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      maxItem: 'MaxItem',
      nextToken: 'NextToken',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      securityToken: 'SecurityToken',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxItem: 'number',
      nextToken: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': ListTagResourcesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The pagination token that is used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists.
   * 
   * @example
   * AAAAAYwsxxxxxxx
   */
  nextToken?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-280B-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The tags of the resource.
   */
  tagResources?: ListTagResourcesResponseBodyTagResources[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 16
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      nextToken: 'NextToken',
      requestId: 'RequestId',
      tagResources: 'TagResources',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      requestId: 'string',
      tagResources: { 'type': 'array', 'itemType': ListTagResourcesResponseBodyTagResources },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUploadTasksRequest extends $tea.Model {
  /**
   * @remarks
   * The time when the task ends. Specify the time in the YYYY-MM-DDThh:mm:ssZ format.
   * 
   * @example
   * 2019-12-06T12:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The time when the task starts. Specify the time in the YYYY-MM-DDThh:mm:ssZ format.
   * 
   * @example
   * 2018-11-29T00:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The task type. Valid values:
   * 
   * *   **file**: purges the cache by file URL.
   * *   **preload**: prefetches files.
   * *   **directory**: purges the cache by directory.
   * *   **ignoreparams**: purges the cache by URL with specified parameters ignored.
   * 
   * @example
   * file
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      siteId: 'SiteId',
      startTime: 'StartTime',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      siteId: 'number',
      startTime: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUploadTasksResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6D****
   */
  requestId?: string;
  /**
   * @remarks
   * The file upload tasks.
   */
  tasks?: ListUploadTasksResponseBodyTasks[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tasks: 'Tasks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tasks: { 'type': 'array', 'itemType': ListUploadTasksResponseBodyTasks },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUploadTasksResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListUploadTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListUploadTasksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserDeliveryTasksRequest extends $tea.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * 1.  dcdn_log_access_l1 (default): access logs.
   * 2.  dcdn_log_er: Edge Routine logs.
   * 3.  dcdn_log_waf: firewall logs.
   * 4.  dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The page number. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 20.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserDeliveryTasksResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number returned.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1f94c47f-3a1a-4f69-8d6c-bfeee1b49aab
   */
  requestId?: string;
  /**
   * @remarks
   * The delivery tasks.
   */
  tasks?: ListUserDeliveryTasksResponseBodyTasks[];
  /**
   * @remarks
   * The total number of delivery tasks.
   * 
   * @example
   * 68
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      tasks: 'Tasks',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      tasks: { 'type': 'array', 'itemType': ListUserDeliveryTasksResponseBodyTasks },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserDeliveryTasksResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListUserDeliveryTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListUserDeliveryTasksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserRatePlanInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to query only the plans that have remaining quota for associating websites. Valid values:
   * 
   * *   true: queries only the plans that have remaining quota for associating websites.
   * *   false: queries all plans in your account.
   * 
   * @example
   * true
   */
  checkRemainingSiteQuota?: string;
  /**
   * @remarks
   * The plan ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * sp-xcdn-96wblslz****
   */
  instanceId?: string;
  /**
   * @remarks
   * The page number. Valid values: **1** to **100000**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 500
   */
  pageSize?: number;
  /**
   * @remarks
   * The sorting field. By default, the queried plans are sorted by purchase time. Valid values:
   * 
   * *   CreateTime: the time when the plans were purchased.
   * *   ExpireTime: the time when the plans expire.
   * 
   * @example
   * CreateTime
   */
  sortBy?: string;
  /**
   * @remarks
   * The order in which you want to sort the query results. Default value: desc. Valid values:
   * 
   * *   asc: in ascending order.
   * *   desc: in descending order.
   * 
   * @example
   * asc
   */
  sortOrder?: string;
  /**
   * @remarks
   * The plan status. Valid values:
   * 
   * *   online: The plan is in service.
   * *   offline: The plan has expired within an allowable period. In this state, the plan is unavailable.
   * *   disable: The plan is released.
   * *   overdue: The plan is stopped due to overdue payments.
   * 
   * @example
   * online
   * 
   * **if can be null:**
   * false
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      checkRemainingSiteQuota: 'CheckRemainingSiteQuota',
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      sortBy: 'SortBy',
      sortOrder: 'SortOrder',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkRemainingSiteQuota: 'string',
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      sortBy: 'string',
      sortOrder: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserRatePlanInstancesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The queried plans.
   */
  instanceInfo?: ListUserRatePlanInstancesResponseBodyInstanceInfo[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-3C82-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 68
   */
  totalCount?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 1
   */
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      instanceInfo: 'InstanceInfo',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceInfo: { 'type': 'array', 'itemType': ListUserRatePlanInstancesResponseBodyInstanceInfo },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserRatePlanInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListUserRatePlanInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListUserRatePlanInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafManagedRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The attack type. Valid values:
   * 
   * *   SQL injection
   * *   Cross-site scripting
   * *   Code execution
   * *   CRLF
   * *   Local file inclusion
   * *   Remote file inclusion
   * *   webshell
   * *   Cross-site request forgery
   * *   Others
   * *   SEMA
   * 
   * This parameter is required.
   * 
   * @example
   * 11
   */
  attackType?: number;
  /**
   * @remarks
   * The ID of the WAF rule, which can be obtained by calling the [ListWafRules](~~ListWafRules~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000001
   */
  id?: number;
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   **en**: English.
   * *   **zh**: Chinese.
   * 
   * @example
   * zh
   */
  language?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  protectionLevel?: number;
  /**
   * @remarks
   * The query conditions.
   */
  queryArgs?: ListWafManagedRulesRequestQueryArgs;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](~~ListSites~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      attackType: 'AttackType',
      id: 'Id',
      language: 'Language',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      protectionLevel: 'ProtectionLevel',
      queryArgs: 'QueryArgs',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attackType: 'number',
      id: 'number',
      language: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      protectionLevel: 'number',
      queryArgs: ListWafManagedRulesRequestQueryArgs,
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafManagedRulesShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The attack type. Valid values:
   * 
   * *   SQL injection
   * *   Cross-site scripting
   * *   Code execution
   * *   CRLF
   * *   Local file inclusion
   * *   Remote file inclusion
   * *   webshell
   * *   Cross-site request forgery
   * *   Others
   * *   SEMA
   * 
   * This parameter is required.
   * 
   * @example
   * 11
   */
  attackType?: number;
  /**
   * @remarks
   * The ID of the WAF rule, which can be obtained by calling the [ListWafRules](~~ListWafRules~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000001
   */
  id?: number;
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   **en**: English.
   * *   **zh**: Chinese.
   * 
   * @example
   * zh
   */
  language?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  protectionLevel?: number;
  /**
   * @remarks
   * The query conditions.
   */
  queryArgsShrink?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](~~ListSites~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      attackType: 'AttackType',
      id: 'Id',
      language: 'Language',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      protectionLevel: 'ProtectionLevel',
      queryArgsShrink: 'QueryArgs',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attackType: 'number',
      id: 'number',
      language: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      protectionLevel: 'number',
      queryArgsShrink: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafManagedRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The managed rules.
   */
  rules?: ListWafManagedRulesResponseBodyRules[];
  /**
   * @remarks
   * The total number of filtered rules.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      rules: 'Rules',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      rules: { 'type': 'array', 'itemType': ListWafManagedRulesResponseBodyRules },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafManagedRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWafManagedRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWafManagedRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafPhasesRequest extends $tea.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafPhasesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The WAF rule categories.
   */
  phases?: ListWafPhasesResponseBodyPhases[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      phases: 'Phases',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      phases: { 'type': 'array', 'itemType': ListWafPhasesResponseBodyPhases },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafPhasesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWafPhasesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWafPhasesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * http_custom
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 1
   */
  pageSize?: number;
  /**
   * @remarks
   * The WAF rule category. You can filter rules of a specific category.
   * 
   * @example
   * 0
   */
  phase?: string;
  /**
   * @remarks
   * The filter conditions.
   * 
   * @example
   * http_custom
   */
  queryArgs?: ListWafRulesRequestQueryArgs;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 1
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      phase: 'Phase',
      queryArgs: 'QueryArgs',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      phase: 'string',
      queryArgs: ListWafRulesRequestQueryArgs,
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafRulesShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * http_custom
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 1
   */
  pageSize?: number;
  /**
   * @remarks
   * The WAF rule category. You can filter rules of a specific category.
   * 
   * @example
   * 0
   */
  phase?: string;
  /**
   * @remarks
   * The filter conditions.
   * 
   * @example
   * http_custom
   */
  queryArgsShrink?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 1
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      phase: 'Phase',
      queryArgsShrink: 'QueryArgs',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      phase: 'string',
      queryArgsShrink: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The rule usage of the instance that corresponds to the website in the WAF rule category.
   * 
   * @example
   * 10
   */
  instanceUsage?: number;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The rules returned.
   */
  rules?: ListWafRulesResponseBodyRules[];
  /**
   * @remarks
   * The rule usage of the website.
   * 
   * @example
   * 5
   */
  siteUsage?: number;
  /**
   * @remarks
   * The total number of filtered rules.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      instanceUsage: 'InstanceUsage',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      rules: 'Rules',
      siteUsage: 'SiteUsage',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceUsage: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      rules: { 'type': 'array', 'itemType': ListWafRulesResponseBodyRules },
      siteUsage: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWafRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWafRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafRulesetsRequest extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The WAF rule category of rulesets to query.
   * 
   * @example
   * http_bot
   */
  phase?: string;
  /**
   * @remarks
   * The query arguments in the JSON format, which contain filter conditions.
   * 
   * @example
   * http_bot
   */
  queryArgs?: ListWafRulesetsRequestQueryArgs;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 1
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      phase: 'Phase',
      queryArgs: 'QueryArgs',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      phase: 'string',
      queryArgs: ListWafRulesetsRequestQueryArgs,
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafRulesetsShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The WAF rule category of rulesets to query.
   * 
   * @example
   * http_bot
   */
  phase?: string;
  /**
   * @remarks
   * The query arguments in the JSON format, which contain filter conditions.
   * 
   * @example
   * http_bot
   */
  queryArgsShrink?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 1
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      phase: 'Phase',
      queryArgsShrink: 'QueryArgs',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      phase: 'string',
      queryArgsShrink: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafRulesetsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The number of WAF rulesets that are used by the instance in the WAF rule category.
   * 
   * @example
   * 10
   */
  instanceUsage?: number;
  /**
   * @remarks
   * The page number returned.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The details of the rulesets.
   */
  rulesets?: ListWafRulesetsResponseBodyRulesets[];
  /**
   * @remarks
   * The number of WAF rulesets that are used by the website in the WAF rule category.
   * 
   * @example
   * 5
   */
  siteUsage?: number;
  /**
   * @remarks
   * The total number of filtered rulesets.
   * 
   * @example
   * 5
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      instanceUsage: 'InstanceUsage',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      rulesets: 'Rulesets',
      siteUsage: 'SiteUsage',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceUsage: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      rulesets: { 'type': 'array', 'itemType': ListWafRulesetsResponseBodyRulesets },
      siteUsage: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafRulesetsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWafRulesetsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWafRulesetsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafTemplateRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The WAF rule category, which is used to filter template rules of a specific category.
   * 
   * @example
   * http_anti_scan
   */
  phase?: string;
  /**
   * @remarks
   * The query parameter, which is used to filter template rules based on criteria such as the rule type.
   * 
   * @example
   * http_anti_scan
   */
  queryArgs?: ListWafTemplateRulesRequestQueryArgs;
  /**
   * @remarks
   * 站点ID，可通过调用[ListSites](https://help.aliyun.com/document_detail/2850189.html)接口获取。
   * 
   * @example
   * 1
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      phase: 'Phase',
      queryArgs: 'QueryArgs',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      phase: 'string',
      queryArgs: ListWafTemplateRulesRequestQueryArgs,
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafTemplateRulesShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The WAF rule category, which is used to filter template rules of a specific category.
   * 
   * @example
   * http_anti_scan
   */
  phase?: string;
  /**
   * @remarks
   * The query parameter, which is used to filter template rules based on criteria such as the rule type.
   * 
   * @example
   * http_anti_scan
   */
  queryArgsShrink?: string;
  /**
   * @remarks
   * 站点ID，可通过调用[ListSites](https://help.aliyun.com/document_detail/2850189.html)接口获取。
   * 
   * @example
   * 1
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      phase: 'Phase',
      queryArgsShrink: 'QueryArgs',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      phase: 'string',
      queryArgsShrink: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafTemplateRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The returned template rules.
   */
  rules?: ListWafTemplateRulesResponseBodyRules[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      rules: { 'type': 'array', 'itemType': ListWafTemplateRulesResponseBodyRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafTemplateRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWafTemplateRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWafTemplateRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafUsageOfRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The WAF rule category.
   * 
   * @example
   * http_anti_scan
   */
  phase?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * ListWafUsageOfRules
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      phase: 'Phase',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      phase: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafUsageOfRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The usage details of WAF rules of the website.
   */
  sites?: ListWafUsageOfRulesResponseBodySites[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      sites: 'Sites',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      sites: { 'type': 'array', 'itemType': ListWafUsageOfRulesResponseBodySites },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafUsageOfRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWafUsageOfRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWafUsageOfRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomEventsRequest extends $tea.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 7096621098****
   */
  siteId?: number;
  /**
   * @remarks
   * The ID of the waiting room event. This parameter is optional. You can specify this parameter to query a specific waiting room event.
   * 
   * @example
   * 89677721098****
   */
  waitingRoomEventId?: number;
  /**
   * @remarks
   * The unique ID of the waiting room, which can be obtained by calling the [ListWaitingRooms](https://help.aliyun.com/document_detail/2850279.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 6a51d5bc6460887abd129****
   */
  waitingRoomId?: string;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      waitingRoomEventId: 'WaitingRoomEventId',
      waitingRoomId: 'WaitingRoomId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      waitingRoomEventId: 'number',
      waitingRoomId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomEventsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID, which is used to trace a call.
   * 
   * @example
   * f3c3700a-4c0f-4a24-b576-fd7dbf9e7c55
   */
  requestId?: string;
  /**
   * @remarks
   * The details of the waiting room events.
   */
  waitingRoomEvents?: ListWaitingRoomEventsResponseBodyWaitingRoomEvents[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      waitingRoomEvents: 'WaitingRoomEvents',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      waitingRoomEvents: { 'type': 'array', 'itemType': ListWaitingRoomEventsResponseBodyWaitingRoomEvents },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomEventsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWaitingRoomEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWaitingRoomEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomRulesRequest extends $tea.Model {
  /**
   * @remarks
   * Optional. The rule name, which can be used to query a specific bypass rule.
   * 
   * @example
   * test
   */
  ruleName?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The ID of the waiting room to be bypassed, which can be obtained by calling the [ListWatingRooms](https://help.aliyun.com/document_detail/2850279.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 6a51d5bc6460887abd129****
   */
  waitingRoomId?: string;
  /**
   * @remarks
   * Optional. The rule ID, which can be used to query a specific rule.
   * 
   * @example
   * 37286782688****
   */
  waitingRoomRuleId?: number;
  static names(): { [key: string]: string } {
    return {
      ruleName: 'RuleName',
      siteId: 'SiteId',
      waitingRoomId: 'WaitingRoomId',
      waitingRoomRuleId: 'WaitingRoomRuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleName: 'string',
      siteId: 'number',
      waitingRoomId: 'string',
      waitingRoomRuleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID, which is used to trace a call.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A123425345
   */
  requestId?: string;
  /**
   * @remarks
   * The waiting room bypass rules.
   */
  waitingRoomRules?: ListWaitingRoomRulesResponseBodyWaitingRoomRules[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      waitingRoomRules: 'WaitingRoomRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      waitingRoomRules: { 'type': 'array', 'itemType': ListWaitingRoomRulesResponseBodyWaitingRoomRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWaitingRoomRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWaitingRoomRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomsRequest extends $tea.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 120876698010528
   */
  siteId?: number;
  /**
   * @remarks
   * The ID of the waiting room. Specify this parameter to query the information about a specific waiting room.
   * 
   * @example
   * 6a51d5bc6460887abd1291dc7d4d****
   */
  waitingRoomId?: string;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      waitingRoomId: 'WaitingRoomId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      waitingRoomId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID, which is used to trace a call.
   * 
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The waiting rooms.
   */
  waitingRooms?: ListWaitingRoomsResponseBodyWaitingRooms[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      waitingRooms: 'WaitingRooms',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      waitingRooms: { 'type': 'array', 'itemType': ListWaitingRoomsResponseBodyWaitingRooms },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWaitingRoomsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWaitingRoomsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreloadCachesRequest extends $tea.Model {
  /**
   * @remarks
   * The files to be prefetched.
   */
  content?: string[];
  /**
   * @remarks
   * By default, prefetch requests include the Accept-Encoding:gzip header. If you want a prefetch request to include other headers or implement multi-replica prefetch, you can specify a custom prefetch header by configuring the Headers parameter.
   */
  headers?: { [key: string]: string };
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      headers: 'Headers',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'array', 'itemType': 'string' },
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreloadCachesShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The files to be prefetched.
   */
  contentShrink?: string;
  /**
   * @remarks
   * By default, prefetch requests include the Accept-Encoding:gzip header. If you want a prefetch request to include other headers or implement multi-replica prefetch, you can specify a custom prefetch header by configuring the Headers parameter.
   */
  headersShrink?: string;
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      contentShrink: 'Content',
      headersShrink: 'Headers',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentShrink: 'string',
      headersShrink: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreloadCachesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9732E117-8A37-49FD-A36F-ABBB87556CA7
   */
  requestId?: string;
  /**
   * @remarks
   * The prefetch task ID.
   * 
   * @example
   * 16401427840
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreloadCachesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PreloadCachesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PreloadCachesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishEdgeContainerAppVersionRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * Specifies whether to fully release the version. This parameter takes effect only when PublishType is set to region.
   * 
   * @example
   * true
   */
  fullRelease?: boolean;
  /**
   * @remarks
   * The release percentage. Valid values: 1 to 100. Default value: 100.
   * 
   * @example
   * 100
   */
  percentage?: number;
  /**
   * @remarks
   * The environment to which you want to release the version. Valid values:
   * 
   * *   prod: the production environment.
   * *   staging: the staging environment.
   * 
   * This parameter is required.
   * 
   * @example
   * prod
   */
  publishEnv?: string;
  /**
   * @remarks
   * Specifies how the version is released. Valid values:
   * 
   * *   percentage: releases the version by percentage.
   * *   region: releases the version by region.
   * 
   * If you do not specify this parameter, the version is released by percentage by default.
   * 
   * @example
   * percentage
   */
  publishType?: string;
  /**
   * @remarks
   * The regions to which the version is released.
   */
  regions?: string[];
  /**
   * @remarks
   * The remarks. This parameter is empty by default.
   * 
   * @example
   * test publish app
   */
  remarks?: string;
  /**
   * @remarks
   * The time when the application version starts to be released. If you do not specify this parameter, the current time is used by default.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2023-06-05T16:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The version ID.
   * 
   * This parameter is required.
   * 
   * @example
   * ver-87962637161651****
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      fullRelease: 'FullRelease',
      percentage: 'Percentage',
      publishEnv: 'PublishEnv',
      publishType: 'PublishType',
      regions: 'Regions',
      remarks: 'Remarks',
      startTime: 'StartTime',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      fullRelease: 'boolean',
      percentage: 'number',
      publishEnv: 'string',
      publishType: 'string',
      regions: { 'type': 'array', 'itemType': 'string' },
      remarks: 'string',
      startTime: 'string',
      versionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishEdgeContainerAppVersionShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * Specifies whether to fully release the version. This parameter takes effect only when PublishType is set to region.
   * 
   * @example
   * true
   */
  fullRelease?: boolean;
  /**
   * @remarks
   * The release percentage. Valid values: 1 to 100. Default value: 100.
   * 
   * @example
   * 100
   */
  percentage?: number;
  /**
   * @remarks
   * The environment to which you want to release the version. Valid values:
   * 
   * *   prod: the production environment.
   * *   staging: the staging environment.
   * 
   * This parameter is required.
   * 
   * @example
   * prod
   */
  publishEnv?: string;
  /**
   * @remarks
   * Specifies how the version is released. Valid values:
   * 
   * *   percentage: releases the version by percentage.
   * *   region: releases the version by region.
   * 
   * If you do not specify this parameter, the version is released by percentage by default.
   * 
   * @example
   * percentage
   */
  publishType?: string;
  /**
   * @remarks
   * The regions to which the version is released.
   */
  regionsShrink?: string;
  /**
   * @remarks
   * The remarks. This parameter is empty by default.
   * 
   * @example
   * test publish app
   */
  remarks?: string;
  /**
   * @remarks
   * The time when the application version starts to be released. If you do not specify this parameter, the current time is used by default.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2023-06-05T16:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The version ID.
   * 
   * This parameter is required.
   * 
   * @example
   * ver-87962637161651****
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      fullRelease: 'FullRelease',
      percentage: 'Percentage',
      publishEnv: 'PublishEnv',
      publishType: 'PublishType',
      regionsShrink: 'Regions',
      remarks: 'Remarks',
      startTime: 'StartTime',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      fullRelease: 'boolean',
      percentage: 'number',
      publishEnv: 'string',
      publishType: 'string',
      regionsShrink: 'string',
      remarks: 'string',
      startTime: 'string',
      versionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishEdgeContainerAppVersionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishEdgeContainerAppVersionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PublishEdgeContainerAppVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PublishEdgeContainerAppVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishRoutineCodeVersionRequest extends $tea.Model {
  /**
   * @remarks
   * The regions for canary release.
   */
  canaryAreaList?: string[];
  /**
   * @remarks
   * The version number for canary release.
   * 
   * @example
   * 1710120201067203242
   */
  canaryCodeVersion?: string;
  /**
   * @remarks
   * The code version to be released.
   * 
   * @example
   * 1710120201067203242
   */
  codeVersion?: string;
  /**
   * @remarks
   * The environment name.
   * 
   * @example
   * production
   */
  env?: string;
  /**
   * @remarks
   * The routine name.
   * 
   * @example
   * PublishRoutineCodeVersion
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      canaryAreaList: 'CanaryAreaList',
      canaryCodeVersion: 'CanaryCodeVersion',
      codeVersion: 'CodeVersion',
      env: 'Env',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canaryAreaList: { 'type': 'array', 'itemType': 'string' },
      canaryCodeVersion: 'string',
      codeVersion: 'string',
      env: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishRoutineCodeVersionShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The regions for canary release.
   */
  canaryAreaListShrink?: string;
  /**
   * @remarks
   * The version number for canary release.
   * 
   * @example
   * 1710120201067203242
   */
  canaryCodeVersion?: string;
  /**
   * @remarks
   * The code version to be released.
   * 
   * @example
   * 1710120201067203242
   */
  codeVersion?: string;
  /**
   * @remarks
   * The environment name.
   * 
   * @example
   * production
   */
  env?: string;
  /**
   * @remarks
   * The routine name.
   * 
   * @example
   * PublishRoutineCodeVersion
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      canaryAreaListShrink: 'CanaryAreaList',
      canaryCodeVersion: 'CanaryCodeVersion',
      codeVersion: 'CodeVersion',
      env: 'Env',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canaryAreaListShrink: 'string',
      canaryCodeVersion: 'string',
      codeVersion: 'string',
      env: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishRoutineCodeVersionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The code version.
   * 
   * @example
   * 1710120201067203242
   */
  codeVersion?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      codeVersion: 'CodeVersion',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeVersion: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishRoutineCodeVersionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PublishRoutineCodeVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PublishRoutineCodeVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurgeCachesRequest extends $tea.Model {
  /**
   * @remarks
   * The content to purge.
   */
  content?: PurgeCachesRequestContent;
  /**
   * @remarks
   * Specifies whether to purge cached resources for edge computing. For example, purge the resources cached by the CacheAPI operation of Edge Routine.
   * 
   * @example
   * true
   */
  edgeComputePurge?: boolean;
  /**
   * @remarks
   * Specifies whether to purge resources in a directory if the resources requested are different from the resources on the origin server. Default value: false.
   * 
   * *   **true**: purges all resources in the directory.
   * *   **false**: purges only changed resources in the directory.
   * 
   * >  This configuration takes effect for the following purge task types: directory, cachetag, ignoreParams, hostname, and purgeall.
   * 
   * @example
   * true
   */
  force?: boolean;
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  /**
   * @remarks
   * The type of the purge task. Valid values:
   * 
   * *   **file** (default): purges the cache by file.
   * *   **cachetag**: purges the cache by cache tag.
   * *   **directory**: purges the cache by directory.
   * *   **ignoreParams**: purges the cache by URL with specific parameters ignored. This option ignores the question mark (?) and parameters after the question mark (?) in a request URL and purges the cache. After you call this operation with the request URL submitted, the system compares the submitted URL with the URL of the cached resource without specified parameters. If the URLs match, the POPs purge the cached resources.
   * *   **hostname**: purges the cache by hostname.
   * *   **purgeall**: purges all cache.
   * 
   * This parameter is required.
   * 
   * @example
   * file
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      edgeComputePurge: 'EdgeComputePurge',
      force: 'Force',
      siteId: 'SiteId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: PurgeCachesRequestContent,
      edgeComputePurge: 'boolean',
      force: 'boolean',
      siteId: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurgeCachesShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The content to purge.
   */
  contentShrink?: string;
  /**
   * @remarks
   * Specifies whether to purge cached resources for edge computing. For example, purge the resources cached by the CacheAPI operation of Edge Routine.
   * 
   * @example
   * true
   */
  edgeComputePurge?: boolean;
  /**
   * @remarks
   * Specifies whether to purge resources in a directory if the resources requested are different from the resources on the origin server. Default value: false.
   * 
   * *   **true**: purges all resources in the directory.
   * *   **false**: purges only changed resources in the directory.
   * 
   * >  This configuration takes effect for the following purge task types: directory, cachetag, ignoreParams, hostname, and purgeall.
   * 
   * @example
   * true
   */
  force?: boolean;
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  /**
   * @remarks
   * The type of the purge task. Valid values:
   * 
   * *   **file** (default): purges the cache by file.
   * *   **cachetag**: purges the cache by cache tag.
   * *   **directory**: purges the cache by directory.
   * *   **ignoreParams**: purges the cache by URL with specific parameters ignored. This option ignores the question mark (?) and parameters after the question mark (?) in a request URL and purges the cache. After you call this operation with the request URL submitted, the system compares the submitted URL with the URL of the cached resource without specified parameters. If the URLs match, the POPs purge the cached resources.
   * *   **hostname**: purges the cache by hostname.
   * *   **purgeall**: purges all cache.
   * 
   * This parameter is required.
   * 
   * @example
   * file
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      contentShrink: 'Content',
      edgeComputePurge: 'EdgeComputePurge',
      force: 'Force',
      siteId: 'SiteId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentShrink: 'string',
      edgeComputePurge: 'boolean',
      force: 'boolean',
      siteId: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurgeCachesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * ET5BF670-09D5-4D0B-BEBY-D96A2A528000
   */
  requestId?: string;
  /**
   * @remarks
   * The task ID, which is generated after you create a task.
   * 
   * @example
   * 15940956620
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurgeCachesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PurgeCachesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PurgeCachesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutKvRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether the content of the key is Base64-encoded. Set this parameter to true if you want to store the key content in binary format. When this parameter is set to true, the Value parameter must be Base64-encoded.
   * 
   * @example
   * true
   */
  base64?: boolean;
  /**
   * @remarks
   * The time when the key-value pair expires, which cannot be earlier than the current time. The value is a timestamp in seconds. If you specify both Expiration and ExpirationTtl, only ExpirationTtl takes effect.
   * 
   * @example
   * 1690081381
   */
  expiration?: number;
  /**
   * @remarks
   * The relative expiration time. Unit: seconds. If you specify both Expiration and ExpirationTtl, only ExpirationTtl takes effect.
   * 
   * @example
   * 3600
   */
  expirationTtl?: number;
  /**
   * @remarks
   * The key name. The name can be up to 512 characters in length and cannot contain spaces or backslashes (\\\\).
   * 
   * This parameter is required.
   * 
   * @example
   * test_key
   */
  key?: string;
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * The content of the key, which can be up to 2 MB (2 × 1000 × 1000). If the content is larger than 2 MB, call [PutKvWithHighCapacity](https://help.aliyun.com/document_detail/2850486.html).
   * 
   * This parameter is required.
   * 
   * @example
   * test_value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      base64: 'Base64',
      expiration: 'Expiration',
      expirationTtl: 'ExpirationTtl',
      key: 'Key',
      namespace: 'Namespace',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      base64: 'boolean',
      expiration: 'number',
      expirationTtl: 'number',
      key: 'string',
      namespace: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutKvResponseBody extends $tea.Model {
  /**
   * @remarks
   * The length of the value in the key-value pair.
   * 
   * @example
   * 4
   */
  length?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The content of the key. If the content has more than 256 characters in length, the system displays the first 100 and the last 100 characters, and omits the middle part.
   * 
   * @example
   * test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      length: 'Length',
      requestId: 'RequestId',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      length: 'string',
      requestId: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutKvResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutKvResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutKvResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutKvWithHighCapacityRequest extends $tea.Model {
  /**
   * @remarks
   * The key name. The name can be up to 512 characters in length and cannot contain spaces or backslashes (\\\\).
   * 
   * This parameter is required.
   * 
   * @example
   * test_key
   */
  key?: string;
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namesapce
   */
  namespace?: string;
  /**
   * @remarks
   * The download URL of the key-value pair that you want to upload. This parameter is automatically filled in when you use the SDK to call the operation.
   * 
   * This parameter is required.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      namespace: 'Namespace',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      namespace: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutKvWithHighCapacityAdvanceRequest extends $tea.Model {
  /**
   * @remarks
   * The key name. The name can be up to 512 characters in length and cannot contain spaces or backslashes (\\\\).
   * 
   * This parameter is required.
   * 
   * @example
   * test_key
   */
  key?: string;
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namesapce
   */
  namespace?: string;
  /**
   * @remarks
   * The download URL of the key-value pair that you want to upload. This parameter is automatically filled in when you use the SDK to call the operation.
   * 
   * This parameter is required.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  urlObject?: Readable;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      namespace: 'Namespace',
      urlObject: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      namespace: 'string',
      urlObject: 'Readable',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutKvWithHighCapacityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The length of the value in the key-value pair.
   * 
   * @example
   * 4
   */
  length?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The content of the key. If the content has more than 256 characters in length, the system displays the first 100 and the last 100 characters, and omits the middle part.
   * 
   * @example
   * test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      length: 'Length',
      requestId: 'RequestId',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      length: 'string',
      requestId: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutKvWithHighCapacityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutKvWithHighCapacityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutKvWithHighCapacityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RebuildEdgeContainerAppStagingEnvRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RebuildEdgeContainerAppStagingEnvResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-3C82-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RebuildEdgeContainerAppStagingEnvResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RebuildEdgeContainerAppStagingEnvResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RebuildEdgeContainerAppStagingEnvResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetScheduledPreloadJobRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the scheduled prefetch task.
   * 
   * @example
   * ResetScheduledPreloadJob
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetScheduledPreloadJobResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 15685865xxx14622
   */
  aliUid?: string;
  /**
   * @remarks
   * The time when the SQL task was created.
   * 
   * @example
   * 2024-06-02T02:23:26Z
   */
  createdAt?: string;
  /**
   * @remarks
   * The domain names to be prefetched.
   * 
   * @example
   * testurl.com
   */
  domains?: string;
  /**
   * @remarks
   * The error message that is returned.
   * 
   * @example
   * invalid domain:test.com
   */
  errorInfo?: string;
  /**
   * @remarks
   * The URL of the OSS object that stores a list of URLs that failed the conditional check for prefetching.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  failedFileOss?: string;
  /**
   * @remarks
   * The ID of the URL list file, which can be used during downloads.
   * 
   * @example
   * 665d3b48621bccf3fe29e1a7
   */
  fileId?: string;
  /**
   * @remarks
   * The ID of the prefetch task.
   * 
   * @example
   * 665d3af3621bccf3fe29e1a4
   */
  id?: string;
  /**
   * @remarks
   * The method to submit the URLs to be prefetched.
   * 
   * @example
   * oss
   */
  insertWay?: string;
  /**
   * @remarks
   * The delivery project name.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 190007158391808
   */
  siteId?: number;
  /**
   * @remarks
   * The number of submitted prefetch tasks.
   * 
   * @example
   * 1
   */
  taskSubmitted?: number;
  /**
   * @remarks
   * The task type. Valid values: refresh and preload.
   * 
   * @example
   * preload
   */
  taskType?: string;
  /**
   * @remarks
   * The total number of URLs.
   * 
   * @example
   * 2
   */
  urlCount?: number;
  /**
   * @remarks
   * The number of submitted URLs.
   * 
   * @example
   * 1
   */
  urlSubmitted?: number;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      createdAt: 'CreatedAt',
      domains: 'Domains',
      errorInfo: 'ErrorInfo',
      failedFileOss: 'FailedFileOss',
      fileId: 'FileId',
      id: 'Id',
      insertWay: 'InsertWay',
      name: 'Name',
      requestId: 'RequestId',
      siteId: 'SiteId',
      taskSubmitted: 'TaskSubmitted',
      taskType: 'TaskType',
      urlCount: 'UrlCount',
      urlSubmitted: 'UrlSubmitted',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'string',
      createdAt: 'string',
      domains: 'string',
      errorInfo: 'string',
      failedFileOss: 'string',
      fileId: 'string',
      id: 'string',
      insertWay: 'string',
      name: 'string',
      requestId: 'string',
      siteId: 'number',
      taskSubmitted: 'number',
      taskType: 'string',
      urlCount: 'number',
      urlSubmitted: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetScheduledPreloadJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ResetScheduledPreloadJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResetScheduledPreloadJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RollbackEdgeContainerAppVersionRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The remarks.
   * 
   * @example
   * test rollback app
   */
  remarks?: string;
  /**
   * @remarks
   * The ID of version that you want to roll back.
   * 
   * This parameter is required.
   * 
   * @example
   * ver-87962637161651****
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      remarks: 'Remarks',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      remarks: 'string',
      versionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RollbackEdgeContainerAppVersionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C370DAF1-C838-4288-A1A0-9A87633D248E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RollbackEdgeContainerAppVersionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RollbackEdgeContainerAppVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RollbackEdgeContainerAppVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCertificateRequest extends $tea.Model {
  /**
   * @remarks
   * The certificate ID on Certificate Management Service.
   * 
   * @example
   * 30000478
   */
  casId?: number;
  /**
   * @remarks
   * The certificate content.
   * 
   * @example
   * -----BEGIN CERTIFICATE-----
   */
  certificate?: string;
  /**
   * @remarks
   * The certificate ID on ESA.
   * 
   * @example
   * 30001303
   */
  id?: string;
  /**
   * @remarks
   * The certificate name.
   * 
   * @example
   * yourCertName
   */
  name?: string;
  ownerId?: number;
  /**
   * @remarks
   * The private key of the certificate.
   * 
   * @example
   * -----BEGIN PRIVATE KEY-----
   */
  privateKey?: string;
  /**
   * @remarks
   * The region.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  securityToken?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The certificate type. Valid values:
   * 
   * *   cas: a certificate purchased by using Certificate Management Service.
   * *   upload: a custom certificate that you upload.
   * 
   * This parameter is required.
   * 
   * @example
   * cas
   */
  type?: string;
  /**
   * @remarks
   * Specifies whether to update the certificate.
   * 
   * @example
   * true
   */
  update?: boolean;
  static names(): { [key: string]: string } {
    return {
      casId: 'CasId',
      certificate: 'Certificate',
      id: 'Id',
      name: 'Name',
      ownerId: 'OwnerId',
      privateKey: 'PrivateKey',
      region: 'Region',
      securityToken: 'SecurityToken',
      siteId: 'SiteId',
      type: 'Type',
      update: 'Update',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casId: 'number',
      certificate: 'string',
      id: 'string',
      name: 'string',
      ownerId: 'number',
      privateKey: 'string',
      region: 'string',
      securityToken: 'string',
      siteId: 'number',
      type: 'string',
      update: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCertificateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * A666D44F-19D6-490E-97CF-1A64AB962C57
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCertificateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetCertificateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetHttpDDoSAttackIntelligentProtectionRequest extends $tea.Model {
  /**
   * @remarks
   * The mode of smart HTTP DDoS protection. Valid values:
   * 
   * *   **observe**: alert.
   * *   **defense**: block.
   * 
   * This parameter is required.
   * 
   * @example
   * defense
   */
  aiMode?: string;
  /**
   * @remarks
   * The level of smart HTTP DDoS protection. Valid values:
   * 
   * *   **level0**: very loose.
   * *   **level30**: loose.
   * *   **level60**: normal.
   * *   **level90**: strict.
   * 
   * This parameter is required.
   * 
   * @example
   * level60
   */
  aiTemplate?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      aiMode: 'AiMode',
      aiTemplate: 'AiTemplate',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aiMode: 'string',
      aiTemplate: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetHttpDDoSAttackIntelligentProtectionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The mode of smart HTTP DDoS protection. Valid values:
   * 
   * *   **observe**: alert.
   * *   **defense**: block.
   * 
   * @example
   * defense
   */
  aiMode?: string;
  /**
   * @remarks
   * The level of smart HTTP DDoS protection. Valid values:
   * 
   * *   **level0**: very loose.
   * *   **level30**: loose.
   * *   **level60**: normal.
   * *   **level90**: strict.
   * 
   * @example
   * level60
   */
  aiTemplate?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 156A6B-677B1A-4297B7-9187B7-2B44792
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      aiMode: 'AiMode',
      aiTemplate: 'AiTemplate',
      requestId: 'RequestId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aiMode: 'string',
      aiTemplate: 'string',
      requestId: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetHttpDDoSAttackIntelligentProtectionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetHttpDDoSAttackIntelligentProtectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetHttpDDoSAttackIntelligentProtectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetHttpDDoSAttackProtectionRequest extends $tea.Model {
  /**
   * @remarks
   * The level of HTTP DDoS attack protection. Valid values:
   * 
   * *   **very weak**: very loose.
   * *   **weak**: loose.
   * *   **default**: normal.
   * *   **hard**: strict.
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  globalMode?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      globalMode: 'GlobalMode',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      globalMode: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetHttpDDoSAttackProtectionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The level of HTTP DDoS attack protection.
   * 
   * @example
   * default
   */
  globalMode?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C370DAF1-C838-4288-A1A0-9A87633D248E
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      globalMode: 'GlobalMode',
      requestId: 'RequestId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      globalMode: 'string',
      requestId: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetHttpDDoSAttackProtectionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetHttpDDoSAttackProtectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetHttpDDoSAttackProtectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartScheduledPreloadExecutionRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the prefetch plan.
   * 
   * This parameter is required.
   * 
   * @example
   * StartScheduledPreloadExecution
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartScheduledPreloadExecutionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 15685865xxx14622
   */
  aliUid?: string;
  /**
   * @remarks
   * The end time of the prefetch plan.
   * 
   * @example
   * 2024-05-31T18:10:48.849+08:00
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the prefetch plan.
   * 
   * @example
   * 665d3b48621bccf3fe29e1a7
   */
  id?: string;
  /**
   * @remarks
   * The time interval between each batch execution. Unit: seconds.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The ID of the prefetch task.
   * 
   * @example
   * 665d3af3621bccf3fe29e1a4
   */
  jobId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 65C66B7B-671A-8297-9187-2R5477247B76
   */
  requestId?: string;
  /**
   * @remarks
   * The number of URLs prefetched in each batch.
   * 
   * @example
   * 10
   */
  sliceLen?: number;
  /**
   * @remarks
   * The start time of the prefetch plan.
   * 
   * @example
   * 2024-05-31T17:10:48.849+08:00
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the prefetch plan. Valid values:
   * 
   * *   **waiting**
   * *   **running**
   * *   **finished**
   * *   **failed**
   * *   **stopped**
   * 
   * @example
   * waiting
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      endTime: 'EndTime',
      id: 'Id',
      interval: 'Interval',
      jobId: 'JobId',
      requestId: 'RequestId',
      sliceLen: 'SliceLen',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'string',
      endTime: 'string',
      id: 'string',
      interval: 'number',
      jobId: 'string',
      requestId: 'string',
      sliceLen: 'number',
      startTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartScheduledPreloadExecutionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StartScheduledPreloadExecutionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartScheduledPreloadExecutionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopScheduledPreloadExecutionRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the prefetch plan.
   * 
   * This parameter is required.
   * 
   * @example
   * StopScheduledPreloadExecution
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopScheduledPreloadExecutionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 15685865xxx14622
   */
  aliUid?: string;
  /**
   * @remarks
   * The end time of the prefetch plan.
   * 
   * @example
   * 2024-05-31T18:10:48.849+08:00
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the prefetch plan.
   * 
   * @example
   * 66599bd7397885b43804901c
   */
  id?: string;
  /**
   * @remarks
   * The time interval between each batch execution in the plan. Unit: seconds.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The ID of the prefetch task.
   * 
   * @example
   * 665d3af3621bccf3fe29e1a4
   */
  jobId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The number of URLs prefetched in each batch.
   * 
   * @example
   * 10
   */
  sliceLen?: number;
  /**
   * @remarks
   * The start time of the prefetch plan.
   * 
   * @example
   * 2024-05-31T17:10:48.849+08:00
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the prefetch plan. Valid values:
   * 
   * *   **waiting**
   * *   **running**
   * *   **finished**
   * *   **failed**
   * *   **stopped**
   * 
   * @example
   * stopped
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      endTime: 'EndTime',
      id: 'Id',
      interval: 'Interval',
      jobId: 'JobId',
      requestId: 'RequestId',
      sliceLen: 'SliceLen',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'string',
      endTime: 'string',
      id: 'string',
      interval: 'number',
      jobId: 'string',
      requestId: 'string',
      sliceLen: 'number',
      startTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopScheduledPreloadExecutionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopScheduledPreloadExecutionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopScheduledPreloadExecutionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to remove all tags. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * Default value: **false**.
   * 
   * @example
   * false
   */
  all?: boolean;
  ownerId?: number;
  /**
   * @remarks
   * The ID of the region where the resources reside. Set the value to **cn-hangzhou**.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of resource N. Valid values of N: **1** to **50**.
   * 
   * This parameter is required.
   */
  resourceId?: string[];
  /**
   * @remarks
   * The resource type.
   * 
   * This parameter is required.
   * 
   * @example
   * site
   */
  resourceType?: string;
  securityToken?: string;
  /**
   * @remarks
   * The key of tag N to remove from the resource. Valid values of N: **1** to **20**.
   */
  tagKey?: string[];
  static names(): { [key: string]: string } {
    return {
      all: 'All',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      securityToken: 'SecurityToken',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      all: 'boolean',
      ownerId: 'number',
      regionId: 'string',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      securityToken: 'string',
      tagKey: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 85H66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UntagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UntagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCustomScenePolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The time when the policy expires.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-03T19:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The policy name.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The IDs of the websites that you want to associate with the policy. Separate multiple IDs with commas (,).
   * 
   * @example
   * 123456****
   */
  objects?: string;
  /**
   * @remarks
   * The policy ID, which can be obtained by calling the [DescribeCustomScenePolicies](https://help.aliyun.com/document_detail/2850508.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  policyId?: number;
  /**
   * @remarks
   * The time when the policy takes effect.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-03T16:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The name of the policy template. Valid value:
   * 
   * *   **promotion**: major events.
   * 
   * This parameter is required.
   * 
   * @example
   * promotion
   */
  template?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      name: 'Name',
      objects: 'Objects',
      policyId: 'PolicyId',
      startTime: 'StartTime',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      name: 'string',
      objects: 'string',
      policyId: 'number',
      startTime: 'string',
      template: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCustomScenePolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time when the policy expires.
   * 
   * The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-04-03T19:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The policy name.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The IDs of websites associated.
   */
  objects?: string[];
  /**
   * @remarks
   * The policy ID.
   * 
   * @example
   * 1
   */
  policyId?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  /**
   * @remarks
   * The time when the policy takes effect.
   * 
   * The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-04-03T16:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The name of the policy template. Valid value:
   * 
   * *   **promotion**: major events.
   * 
   * @example
   * promotion
   */
  template?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      name: 'Name',
      objects: 'Objects',
      policyId: 'PolicyId',
      requestId: 'RequestId',
      startTime: 'StartTime',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      name: 'string',
      objects: { 'type': 'array', 'itemType': 'string' },
      policyId: 'number',
      requestId: 'string',
      startTime: 'string',
      template: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCustomScenePolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCustomScenePolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCustomScenePolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateKvNamespaceRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * ns1
   */
  namespace?: string;
  /**
   * @remarks
   * The new name of the namespace.
   * 
   * This parameter is required.
   * 
   * @example
   * new_ns
   */
  title?: string;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateKvNamespaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The description of the namespace.
   * 
   * @example
   * this is a test ns.
   */
  description?: string;
  /**
   * @remarks
   * The updated name of the namespace.
   * 
   * @example
   * new_ns1
   */
  namespace?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 643355322374688768
   */
  namespaceId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the namespace. Valid values:
   * 
   * *   **online**: normal.
   * *   **delete**: pending deletion.
   * *   **deleting**: being deleted.
   * *   **deleted**: deleted.
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      namespace: 'Namespace',
      namespaceId: 'NamespaceId',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      namespace: 'string',
      namespaceId: 'string',
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateKvNamespaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateKvNamespaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateKvNamespaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateListRequest extends $tea.Model {
  /**
   * @remarks
   * The new description of the list.
   * 
   * @example
   * a custom list
   */
  description?: string;
  /**
   * @remarks
   * The ID of the custom list, which can be obtained by calling the [ListLists](https://help.aliyun.com/document_detail/2850217.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 40000001
   */
  id?: number;
  /**
   * @remarks
   * The items in the updated list. The value is a JSON array.
   * 
   * @example
   * a custom list
   */
  items?: string[];
  /**
   * @remarks
   * The new name of the list.
   * 
   * @example
   * example
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      id: 'Id',
      items: 'Items',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      id: 'number',
      items: { 'type': 'array', 'itemType': 'string' },
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateListShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The new description of the list.
   * 
   * @example
   * a custom list
   */
  description?: string;
  /**
   * @remarks
   * The ID of the custom list, which can be obtained by calling the [ListLists](https://help.aliyun.com/document_detail/2850217.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 40000001
   */
  id?: number;
  /**
   * @remarks
   * The items in the updated list. The value is a JSON array.
   * 
   * @example
   * a custom list
   */
  itemsShrink?: string;
  /**
   * @remarks
   * The new name of the list.
   * 
   * @example
   * example
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      id: 'Id',
      itemsShrink: 'Items',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      id: 'number',
      itemsShrink: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOriginProtectionRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * on
   */
  originConverge?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      originConverge: 'OriginConverge',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originConverge: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOriginProtectionResponseBody extends $tea.Model {
  /**
   * @example
   * 4C6B5E5A-42FC-5DF2-986C-4DAAE3C55086
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOriginProtectionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateOriginProtectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateOriginProtectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOriginProtectionIpWhiteListRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOriginProtectionIpWhiteListResponseBody extends $tea.Model {
  /**
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOriginProtectionIpWhiteListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateOriginProtectionIpWhiteListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateOriginProtectionIpWhiteListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePageRequest extends $tea.Model {
  /**
   * @remarks
   * The Base64-encoded content of the error page. The content type is specified by the Content-Type field.
   * 
   * This parameter is required.
   * 
   * @example
   * PGh0bWw+aGVsbG8gcGFnZTwvaHRtbD4=
   */
  content?: string;
  /**
   * @remarks
   * The Content-Type field in the HTTP header. Valid values:
   * 
   * *   text/html
   * *   application/json
   * 
   * This parameter is required.
   * 
   * @example
   * text/html
   */
  contentType?: string;
  /**
   * @remarks
   * The description of the custom error page.
   * 
   * @example
   * a custom deny page
   */
  description?: string;
  /**
   * @remarks
   * The ID of the custom error page, which can be obtained by calling the [ListPages](https://help.aliyun.com/document_detail/2850223.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 50000001
   */
  id?: number;
  /**
   * @remarks
   * The name of the custom error page.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      contentType: 'ContentType',
      description: 'Description',
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      contentType: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdatePageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdatePageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRecordRequest extends $tea.Model {
  /**
   * @remarks
   * The origin authentication information of the CNAME record.
   */
  authConf?: UpdateRecordRequestAuthConf;
  /**
   * @remarks
   * The business scenario of the record for acceleration. Leave the parameter empty if your record is not proxied. Valid values:
   * 
   * *   **video_image**: video and image.
   * *   **api**: API.
   * *   **web**: web page.
   * 
   * @example
   * web
   */
  bizName?: string;
  /**
   * @remarks
   * The comments of the record.
   * 
   * @example
   * This is a remark.
   */
  comment?: string;
  /**
   * @remarks
   * The DNS record information. The format of this field varies based on the record type. For more information, see [Add DNS records](https://www.alibabacloud.com/help/doc-detail/2708761.html).
   * 
   * This parameter is required.
   * 
   * @example
   * {
   *     "value":"2.2.2.2"
   * }
   */
  data?: UpdateRecordRequestData;
  /**
   * @remarks
   * The origin host policy. This policy takes effect when the record type is CNAME. You can set the policy in two modes:
   * 
   * *   **follow_hostname**: match the requested domain name.
   * *   **follow_origin_domain**: match the origin\\"s domain name.
   * 
   * @example
   * follow_origin_domain
   */
  hostPolicy?: string;
  /**
   * @remarks
   * Specifies whether to proxy the record. Only CNAME and A/AAAA records can be proxied. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  proxied?: boolean;
  /**
   * @remarks
   * The record ID, which can be obtained by calling [ListRecords](https://help.aliyun.com/document_detail/2850265.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  recordId?: number;
  /**
   * @remarks
   * The type of the origin for the CNAME record. This parameter is required when you add a CNAME record. Valid values:
   * 
   * *   **OSS** : OSS origin.
   * *   **S3** : S3 origin.
   * *   **LB**: Load Balancer origin.
   * *   **OP**: origin in an origin pool.
   * *   **Domain**: common domain name.
   * 
   * If you leave the parameter empty or set its value as null, the default is Domain, which is common domain name.
   * 
   * @example
   * OSS
   */
  sourceType?: string;
  /**
   * @remarks
   * The TTL of the record. Unit: seconds. The range is 30 to 86,400, or 1. If the value is 1, the TTL of the record is determined by the system.
   * 
   * @example
   * 30
   */
  ttl?: number;
  static names(): { [key: string]: string } {
    return {
      authConf: 'AuthConf',
      bizName: 'BizName',
      comment: 'Comment',
      data: 'Data',
      hostPolicy: 'HostPolicy',
      proxied: 'Proxied',
      recordId: 'RecordId',
      sourceType: 'SourceType',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authConf: UpdateRecordRequestAuthConf,
      bizName: 'string',
      comment: 'string',
      data: UpdateRecordRequestData,
      hostPolicy: 'string',
      proxied: 'boolean',
      recordId: 'number',
      sourceType: 'string',
      ttl: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRecordShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The origin authentication information of the CNAME record.
   */
  authConfShrink?: string;
  /**
   * @remarks
   * The business scenario of the record for acceleration. Leave the parameter empty if your record is not proxied. Valid values:
   * 
   * *   **video_image**: video and image.
   * *   **api**: API.
   * *   **web**: web page.
   * 
   * @example
   * web
   */
  bizName?: string;
  /**
   * @remarks
   * The comments of the record.
   * 
   * @example
   * This is a remark.
   */
  comment?: string;
  /**
   * @remarks
   * The DNS record information. The format of this field varies based on the record type. For more information, see [Add DNS records](https://www.alibabacloud.com/help/doc-detail/2708761.html).
   * 
   * This parameter is required.
   * 
   * @example
   * {
   *     "value":"2.2.2.2"
   * }
   */
  dataShrink?: string;
  /**
   * @remarks
   * The origin host policy. This policy takes effect when the record type is CNAME. You can set the policy in two modes:
   * 
   * *   **follow_hostname**: match the requested domain name.
   * *   **follow_origin_domain**: match the origin\\"s domain name.
   * 
   * @example
   * follow_origin_domain
   */
  hostPolicy?: string;
  /**
   * @remarks
   * Specifies whether to proxy the record. Only CNAME and A/AAAA records can be proxied. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  proxied?: boolean;
  /**
   * @remarks
   * The record ID, which can be obtained by calling [ListRecords](https://help.aliyun.com/document_detail/2850265.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  recordId?: number;
  /**
   * @remarks
   * The type of the origin for the CNAME record. This parameter is required when you add a CNAME record. Valid values:
   * 
   * *   **OSS** : OSS origin.
   * *   **S3** : S3 origin.
   * *   **LB**: Load Balancer origin.
   * *   **OP**: origin in an origin pool.
   * *   **Domain**: common domain name.
   * 
   * If you leave the parameter empty or set its value as null, the default is Domain, which is common domain name.
   * 
   * @example
   * OSS
   */
  sourceType?: string;
  /**
   * @remarks
   * The TTL of the record. Unit: seconds. The range is 30 to 86,400, or 1. If the value is 1, the TTL of the record is determined by the system.
   * 
   * @example
   * 30
   */
  ttl?: number;
  static names(): { [key: string]: string } {
    return {
      authConfShrink: 'AuthConf',
      bizName: 'BizName',
      comment: 'Comment',
      dataShrink: 'Data',
      hostPolicy: 'HostPolicy',
      proxied: 'Proxied',
      recordId: 'RecordId',
      sourceType: 'SourceType',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authConfShrink: 'string',
      bizName: 'string',
      comment: 'string',
      dataShrink: 'string',
      hostPolicy: 'string',
      proxied: 'boolean',
      recordId: 'number',
      sourceType: 'string',
      ttl: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRecordResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRecordResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduledPreloadExecutionRequest extends $tea.Model {
  /**
   * @remarks
   * The end time of the prefetch plan.
   * 
   * @example
   * 2024-05-31T18:10:48.849+08:00
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the prefetch plan.
   * 
   * This parameter is required.
   * 
   * @example
   * UpdateScheduledPreloadExecution
   */
  id?: string;
  /**
   * @remarks
   * The time interval between each batch execution. Unit: seconds.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The number of URLs prefetched in each batch.
   * 
   * @example
   * 10
   */
  sliceLen?: number;
  /**
   * @remarks
   * The start time of the prefetch plan.
   * 
   * @example
   * 2024-05-31T17:10:48.849+08:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      id: 'Id',
      interval: 'Interval',
      sliceLen: 'SliceLen',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      id: 'string',
      interval: 'number',
      sliceLen: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduledPreloadExecutionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 15685865xxx14622
   */
  aliUid?: string;
  /**
   * @remarks
   * The end time of the prefetch plan.
   * 
   * @example
   * 2024-05-31T18:10:48.849+08:00
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the prefetch plan.
   * 
   * @example
   * 66599bd7397885b43804901c
   */
  id?: string;
  /**
   * @remarks
   * The time interval between each batch execution. Unit: seconds.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The ID of the prefetch task.
   * 
   * @example
   * 665d3af3621bccf3fe29e1a4
   */
  jobId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A123425345
   */
  requestId?: string;
  /**
   * @remarks
   * The number of URLs prefetched in each batch.
   * 
   * @example
   * 10
   */
  sliceLen?: number;
  /**
   * @remarks
   * The start time of the prefetch plan.
   * 
   * @example
   * 2024-05-31T17:10:48.849+08:00
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the prefetch plan. Valid values:
   * 
   * *   **waiting**
   * *   **running**
   * *   **finished**
   * *   **failed**
   * *   **stopped**
   * 
   * @example
   * running
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      endTime: 'EndTime',
      id: 'Id',
      interval: 'Interval',
      jobId: 'JobId',
      requestId: 'RequestId',
      sliceLen: 'SliceLen',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'string',
      endTime: 'string',
      id: 'string',
      interval: 'number',
      jobId: 'string',
      requestId: 'string',
      sliceLen: 'number',
      startTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduledPreloadExecutionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateScheduledPreloadExecutionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateScheduledPreloadExecutionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteAccessTypeRequest extends $tea.Model {
  /**
   * @remarks
   * The new DNS setup of the website. Valid values:
   * 
   * *   **NS**
   * *   **CNAME**
   * 
   * This parameter is required.
   * 
   * @example
   * NS
   */
  accessType?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      accessType: 'AccessType',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessType: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteAccessTypeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteAccessTypeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateSiteAccessTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSiteAccessTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteCoverageRequest extends $tea.Model {
  /**
   * @remarks
   * The desired service location. Valid values:
   * 
   * *   **domestic**: the Chinese mainland
   * *   **global**: global
   * *   **overseas**: outside the Chinese mainland
   * 
   * This parameter is required.
   * 
   * @example
   * global
   */
  coverage?: string;
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      coverage: 'Coverage',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coverage: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteCoverageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 65C66B7B-671A-8297-9187-2R5477247B76
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteCoverageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateSiteCoverageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSiteCoverageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteCustomLogRequest extends $tea.Model {
  /**
   * @remarks
   * The cookie fields.
   */
  cookies?: string[];
  /**
   * @remarks
   * The request header fields.
   */
  requestHeaders?: string[];
  /**
   * @remarks
   * The response header fields.
   */
  responseHeaders?: string[];
  /**
   * @remarks
   * site id
   * 
   * @example
   * 11223****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      cookies: 'Cookies',
      requestHeaders: 'RequestHeaders',
      responseHeaders: 'ResponseHeaders',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cookies: { 'type': 'array', 'itemType': 'string' },
      requestHeaders: { 'type': 'array', 'itemType': 'string' },
      responseHeaders: { 'type': 'array', 'itemType': 'string' },
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteCustomLogShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The cookie fields.
   */
  cookiesShrink?: string;
  /**
   * @remarks
   * The request header fields.
   */
  requestHeadersShrink?: string;
  /**
   * @remarks
   * The response header fields.
   */
  responseHeadersShrink?: string;
  /**
   * @remarks
   * site id
   * 
   * @example
   * 11223****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      cookiesShrink: 'Cookies',
      requestHeadersShrink: 'RequestHeaders',
      responseHeadersShrink: 'ResponseHeaders',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cookiesShrink: 'string',
      requestHeadersShrink: 'string',
      responseHeadersShrink: 'string',
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteCustomLogResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * ET5BF670-09D5-4D0B-BEBY-D96A2A528000
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteCustomLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateSiteCustomLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSiteCustomLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteDeliveryTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   dcdn_log_access_l1 (default): access logs.
   * *   dcdn_log_er: Edge Routine logs.
   * *   dcdn_log_waf: firewall logs.
   * *   dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * @example
   * dcdn_log_er
   */
  businessType?: string;
  /**
   * @remarks
   * The discard rate.
   * 
   * @example
   * 0.0
   */
  discardRate?: number;
  /**
   * @remarks
   * The log fields that you want to include in real-time logs to be delivered. Separate the log fields with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * ClientIP,UserAgent
   */
  fieldName?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * cdn-test-task
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      discardRate: 'DiscardRate',
      fieldName: 'FieldName',
      siteId: 'SiteId',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      discardRate: 'number',
      fieldName: 'string',
      siteId: 'number',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteDeliveryTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34DCBC8A-****-****-****-6DAA11D7DDBD
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteDeliveryTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateSiteDeliveryTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSiteDeliveryTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteDeliveryTaskStatusRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to enable the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * online
   */
  method?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * cdn-test-task
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      method: 'Method',
      siteId: 'SiteId',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      method: 'string',
      siteId: 'number',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteDeliveryTaskStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34DCBC8A-****-****-****-6DAA11D7DDBD
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the delivery task. Valid values:
   * 
   * *   **online**
   * *   **offline**
   * 
   * @example
   * online
   */
  status?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * @example
   * cdn-test-task
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteDeliveryTaskStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateSiteDeliveryTaskStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSiteDeliveryTaskStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequest extends $tea.Model {
  cacheReserve?: UpdateSiteFunctionRequestCacheReserve[];
  cacheRules?: UpdateSiteFunctionRequestCacheRules[];
  cacheTags?: UpdateSiteFunctionRequestCacheTags[];
  cnameFlattening?: UpdateSiteFunctionRequestCnameFlattening[];
  compressionRules?: UpdateSiteFunctionRequestCompressionRules[];
  crossBorderOptimization?: UpdateSiteFunctionRequestCrossBorderOptimization[];
  developmentMode?: UpdateSiteFunctionRequestDevelopmentMode[];
  httpRequestHeaderModificationRules?: UpdateSiteFunctionRequestHttpRequestHeaderModificationRules[];
  httpResponseHeaderModificationRules?: UpdateSiteFunctionRequestHttpResponseHeaderModificationRules[];
  httpsApplicationConfiguration?: UpdateSiteFunctionRequestHttpsApplicationConfiguration[];
  httpsBasicConfiguration?: UpdateSiteFunctionRequestHttpsBasicConfiguration[];
  imageTransform?: UpdateSiteFunctionRequestImageTransform[];
  ipv6?: UpdateSiteFunctionRequestIpv6[];
  managedTransforms?: UpdateSiteFunctionRequestManagedTransforms[];
  networkOptimization?: UpdateSiteFunctionRequestNetworkOptimization[];
  originRules?: UpdateSiteFunctionRequestOriginRules[];
  redirectRules?: UpdateSiteFunctionRequestRedirectRules[];
  rewriteUrlRules?: UpdateSiteFunctionRequestRewriteUrlRules[];
  seoBypass?: UpdateSiteFunctionRequestSeoBypass[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * UpdateSiteFunction
   */
  siteId?: number;
  siteNameExclusive?: UpdateSiteFunctionRequestSiteNameExclusive[];
  sitePause?: UpdateSiteFunctionRequestSitePause[];
  tieredCache?: UpdateSiteFunctionRequestTieredCache[];
  static names(): { [key: string]: string } {
    return {
      cacheReserve: 'CacheReserve',
      cacheRules: 'CacheRules',
      cacheTags: 'CacheTags',
      cnameFlattening: 'CnameFlattening',
      compressionRules: 'CompressionRules',
      crossBorderOptimization: 'CrossBorderOptimization',
      developmentMode: 'DevelopmentMode',
      httpRequestHeaderModificationRules: 'HttpRequestHeaderModificationRules',
      httpResponseHeaderModificationRules: 'HttpResponseHeaderModificationRules',
      httpsApplicationConfiguration: 'HttpsApplicationConfiguration',
      httpsBasicConfiguration: 'HttpsBasicConfiguration',
      imageTransform: 'ImageTransform',
      ipv6: 'Ipv6',
      managedTransforms: 'ManagedTransforms',
      networkOptimization: 'NetworkOptimization',
      originRules: 'OriginRules',
      redirectRules: 'RedirectRules',
      rewriteUrlRules: 'RewriteUrlRules',
      seoBypass: 'SeoBypass',
      siteId: 'SiteId',
      siteNameExclusive: 'SiteNameExclusive',
      sitePause: 'SitePause',
      tieredCache: 'TieredCache',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheReserve: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestCacheReserve },
      cacheRules: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestCacheRules },
      cacheTags: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestCacheTags },
      cnameFlattening: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestCnameFlattening },
      compressionRules: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestCompressionRules },
      crossBorderOptimization: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestCrossBorderOptimization },
      developmentMode: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestDevelopmentMode },
      httpRequestHeaderModificationRules: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestHttpRequestHeaderModificationRules },
      httpResponseHeaderModificationRules: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestHttpResponseHeaderModificationRules },
      httpsApplicationConfiguration: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestHttpsApplicationConfiguration },
      httpsBasicConfiguration: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestHttpsBasicConfiguration },
      imageTransform: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestImageTransform },
      ipv6: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestIpv6 },
      managedTransforms: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestManagedTransforms },
      networkOptimization: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestNetworkOptimization },
      originRules: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestOriginRules },
      redirectRules: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestRedirectRules },
      rewriteUrlRules: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestRewriteUrlRules },
      seoBypass: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestSeoBypass },
      siteId: 'number',
      siteNameExclusive: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestSiteNameExclusive },
      sitePause: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestSitePause },
      tieredCache: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestTieredCache },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionShrinkRequest extends $tea.Model {
  cacheReserveShrink?: string;
  cacheRulesShrink?: string;
  cacheTagsShrink?: string;
  cnameFlatteningShrink?: string;
  compressionRulesShrink?: string;
  crossBorderOptimizationShrink?: string;
  developmentModeShrink?: string;
  httpRequestHeaderModificationRulesShrink?: string;
  httpResponseHeaderModificationRulesShrink?: string;
  httpsApplicationConfigurationShrink?: string;
  httpsBasicConfigurationShrink?: string;
  imageTransformShrink?: string;
  ipv6Shrink?: string;
  managedTransformsShrink?: string;
  networkOptimizationShrink?: string;
  originRulesShrink?: string;
  redirectRulesShrink?: string;
  rewriteUrlRulesShrink?: string;
  seoBypassShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * UpdateSiteFunction
   */
  siteId?: number;
  siteNameExclusiveShrink?: string;
  sitePauseShrink?: string;
  tieredCacheShrink?: string;
  static names(): { [key: string]: string } {
    return {
      cacheReserveShrink: 'CacheReserve',
      cacheRulesShrink: 'CacheRules',
      cacheTagsShrink: 'CacheTags',
      cnameFlatteningShrink: 'CnameFlattening',
      compressionRulesShrink: 'CompressionRules',
      crossBorderOptimizationShrink: 'CrossBorderOptimization',
      developmentModeShrink: 'DevelopmentMode',
      httpRequestHeaderModificationRulesShrink: 'HttpRequestHeaderModificationRules',
      httpResponseHeaderModificationRulesShrink: 'HttpResponseHeaderModificationRules',
      httpsApplicationConfigurationShrink: 'HttpsApplicationConfiguration',
      httpsBasicConfigurationShrink: 'HttpsBasicConfiguration',
      imageTransformShrink: 'ImageTransform',
      ipv6Shrink: 'Ipv6',
      managedTransformsShrink: 'ManagedTransforms',
      networkOptimizationShrink: 'NetworkOptimization',
      originRulesShrink: 'OriginRules',
      redirectRulesShrink: 'RedirectRules',
      rewriteUrlRulesShrink: 'RewriteUrlRules',
      seoBypassShrink: 'SeoBypass',
      siteId: 'SiteId',
      siteNameExclusiveShrink: 'SiteNameExclusive',
      sitePauseShrink: 'SitePause',
      tieredCacheShrink: 'TieredCache',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheReserveShrink: 'string',
      cacheRulesShrink: 'string',
      cacheTagsShrink: 'string',
      cnameFlatteningShrink: 'string',
      compressionRulesShrink: 'string',
      crossBorderOptimizationShrink: 'string',
      developmentModeShrink: 'string',
      httpRequestHeaderModificationRulesShrink: 'string',
      httpResponseHeaderModificationRulesShrink: 'string',
      httpsApplicationConfigurationShrink: 'string',
      httpsBasicConfigurationShrink: 'string',
      imageTransformShrink: 'string',
      ipv6Shrink: 'string',
      managedTransformsShrink: 'string',
      networkOptimizationShrink: 'string',
      originRulesShrink: 'string',
      redirectRulesShrink: 'string',
      rewriteUrlRulesShrink: 'string',
      seoBypassShrink: 'string',
      siteId: 'number',
      siteNameExclusiveShrink: 'string',
      sitePauseShrink: 'string',
      tieredCacheShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionResponseBody extends $tea.Model {
  /**
   * @remarks
   * Id of the request
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateSiteFunctionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSiteFunctionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteVanityNSRequest extends $tea.Model {
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The custom nameserver names. You can specify two to five custom nameserver names. Separate multiple names with commas (,).
   * 
   * @example
   * ns1.example.com,ns2.example.com
   */
  vanityNSList?: string;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      vanityNSList: 'VanityNSList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      vanityNSList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteVanityNSResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteVanityNSResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateSiteVanityNSResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSiteVanityNSResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserDeliveryTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   dcdn_log_access_l1 (default): access logs.
   * *   dcdn_log_er: Edge Routine logs.
   * *   dcdn_log_waf: firewall logs.
   * *   dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * @example
   * dcdn_log_er
   */
  businessType?: string;
  /**
   * @remarks
   * The discard rate. Default value: 0.
   * 
   * @example
   * 0
   */
  discardRate?: number;
  /**
   * @remarks
   * The log fields that you want to include in logs to be delivered. Separate the log fields with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * ClientRequestID,ClientRequestHost
   */
  fieldName?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * test_project
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      discardRate: 'DiscardRate',
      fieldName: 'FieldName',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      discardRate: 'number',
      fieldName: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserDeliveryTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34DCBC8A-****-****-****-6DAA11D7DDBD
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserDeliveryTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateUserDeliveryTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateUserDeliveryTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserDeliveryTaskStatusRequest extends $tea.Model {
  /**
   * @remarks
   * Enables or disables the delivery task. Valid values: online and offline.
   * 
   * This parameter is required.
   * 
   * @example
   * online
   */
  method?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * test_project
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      method: 'Method',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      method: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserDeliveryTaskStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34DCBC8A-****-****-****-6DAA11D7DDBD
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the delivery task.
   * 
   * @example
   * online
   */
  status?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * @example
   * test_project
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserDeliveryTaskStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateUserDeliveryTaskStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateUserDeliveryTaskStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWafRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The configuration of the rule.
   */
  config?: WafRuleConfig;
  /**
   * @remarks
   * The ID of the WAF rule, which can be obtained by calling the [ListWafRules](https://help.aliyun.com/document_detail/2850237.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 20000001
   */
  id?: number;
  /**
   * @remarks
   * The order of the rule in the ruleset.
   * 
   * @example
   * 1
   */
  position?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  /**
   * @remarks
   * The status of the rule.
   * 
   * @example
   * on
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      id: 'Id',
      position: 'Position',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: WafRuleConfig,
      id: 'number',
      position: 'number',
      siteId: 'number',
      siteVersion: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWafRuleShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The configuration of the rule.
   */
  configShrink?: string;
  /**
   * @remarks
   * The ID of the WAF rule, which can be obtained by calling the [ListWafRules](https://help.aliyun.com/document_detail/2850237.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 20000001
   */
  id?: number;
  /**
   * @remarks
   * The order of the rule in the ruleset.
   * 
   * @example
   * 1
   */
  position?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  /**
   * @remarks
   * The status of the rule.
   * 
   * @example
   * on
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      configShrink: 'Config',
      id: 'Id',
      position: 'Position',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configShrink: 'string',
      id: 'number',
      position: 'number',
      siteId: 'number',
      siteVersion: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWafRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the WAF rule.[](~~2850237~~)
   * 
   * @example
   * 20000001
   */
  id?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWafRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateWafRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateWafRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWafRulesetRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the WAF ruleset, which can be obtained by calling the [ListWafRulesets](https://help.aliyun.com/document_detail/2850233.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000001
   */
  id?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 1
   */
  siteVersion?: number;
  /**
   * @remarks
   * The status to which you want to change the ruleset.
   * 
   * @example
   * on
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      siteId: 'number',
      siteVersion: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWafRulesetResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWafRulesetResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateWafRulesetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateWafRulesetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the custom cookie.
   * 
   * @example
   * __aliwaitingroom_example
   */
  cookieName?: string;
  /**
   * @remarks
   * The content of the custom waiting room page. You must specify this parameter if you set WaitingRoomType to custom. The content must be Base64-encoded.
   * 
   * @example
   * Hello%20world!
   */
  customPageHtml?: string;
  /**
   * @remarks
   * The description of the waiting room.
   */
  description?: string;
  /**
   * @remarks
   * Specifies whether to disable session renewal. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  disableSessionRenewalEnable?: string;
  /**
   * @remarks
   * Specifies whether to enable the waiting room. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * The hostname and path.
   */
  hostNameAndPath?: UpdateWaitingRoomRequestHostNameAndPath[];
  /**
   * @remarks
   * Specifies whether to enable JSON response. If JSON response is enabled, a JSON body is returned for requests to the waiting room with the header Accept: application/json. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  jsonResponseEnable?: string;
  /**
   * @remarks
   * The language of the waiting room page. You must specify this parameter if you set WaitingRoomType to default. Valid values:
   * 
   * *   enus: English.
   * *   zhcn: Simplified Chinese.
   * *   zhhk: Traditional Chinese.
   * 
   * @example
   * zhcn
   */
  language?: string;
  /**
   * @remarks
   * The name of the waiting room.
   */
  name?: string;
  /**
   * @remarks
   * The maximum number of new users per minute.
   * 
   * @example
   * 200
   */
  newUsersPerMinute?: string;
  /**
   * @remarks
   * Specifies whether to queue all requests. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  queueAllEnable?: string;
  /**
   * @remarks
   * The queuing method. Valid values:
   * 
   * *   random: Users gain access to the origin randomly, regardless of the arrival time.
   * *   fifo: Users gain access to the origin in order of arrival.
   * *   passthrough: Users pass through the waiting room and go straight to the origin.
   * *   reject-all: Users are blocked from reaching the origin.
   * 
   * @example
   * random
   */
  queuingMethod?: string;
  /**
   * @remarks
   * The HTTP status code to return while a user is in the queue. Valid values:
   * 
   * *   200
   * *   202
   * *   429
   * 
   * @example
   * 200
   */
  queuingStatusCode?: string;
  /**
   * @remarks
   * The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.
   * 
   * @example
   * 5
   */
  sessionDuration?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 7096621098****
   */
  siteId?: number;
  /**
   * @remarks
   * The maximum number of active users.
   * 
   * @example
   * 300
   */
  totalActiveUsers?: string;
  /**
   * @remarks
   * The ID of the waiting room, which can be obtained by calling the [ListWaitingRooms](https://help.aliyun.com/document_detail/2850279.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 6a51d5bc6460887abd129****
   */
  waitingRoomId?: string;
  /**
   * @remarks
   * The type of the waiting room. Valid values:
   * 
   * *   default
   * *   custom
   * 
   * @example
   * default
   */
  waitingRoomType?: string;
  static names(): { [key: string]: string } {
    return {
      cookieName: 'CookieName',
      customPageHtml: 'CustomPageHtml',
      description: 'Description',
      disableSessionRenewalEnable: 'DisableSessionRenewalEnable',
      enable: 'Enable',
      hostNameAndPath: 'HostNameAndPath',
      jsonResponseEnable: 'JsonResponseEnable',
      language: 'Language',
      name: 'Name',
      newUsersPerMinute: 'NewUsersPerMinute',
      queueAllEnable: 'QueueAllEnable',
      queuingMethod: 'QueuingMethod',
      queuingStatusCode: 'QueuingStatusCode',
      sessionDuration: 'SessionDuration',
      siteId: 'SiteId',
      totalActiveUsers: 'TotalActiveUsers',
      waitingRoomId: 'WaitingRoomId',
      waitingRoomType: 'WaitingRoomType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cookieName: 'string',
      customPageHtml: 'string',
      description: 'string',
      disableSessionRenewalEnable: 'string',
      enable: 'string',
      hostNameAndPath: { 'type': 'array', 'itemType': UpdateWaitingRoomRequestHostNameAndPath },
      jsonResponseEnable: 'string',
      language: 'string',
      name: 'string',
      newUsersPerMinute: 'string',
      queueAllEnable: 'string',
      queuingMethod: 'string',
      queuingStatusCode: 'string',
      sessionDuration: 'string',
      siteId: 'number',
      totalActiveUsers: 'string',
      waitingRoomId: 'string',
      waitingRoomType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the custom cookie.
   * 
   * @example
   * __aliwaitingroom_example
   */
  cookieName?: string;
  /**
   * @remarks
   * The content of the custom waiting room page. You must specify this parameter if you set WaitingRoomType to custom. The content must be Base64-encoded.
   * 
   * @example
   * Hello%20world!
   */
  customPageHtml?: string;
  /**
   * @remarks
   * The description of the waiting room.
   */
  description?: string;
  /**
   * @remarks
   * Specifies whether to disable session renewal. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  disableSessionRenewalEnable?: string;
  /**
   * @remarks
   * Specifies whether to enable the waiting room. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * The hostname and path.
   */
  hostNameAndPathShrink?: string;
  /**
   * @remarks
   * Specifies whether to enable JSON response. If JSON response is enabled, a JSON body is returned for requests to the waiting room with the header Accept: application/json. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  jsonResponseEnable?: string;
  /**
   * @remarks
   * The language of the waiting room page. You must specify this parameter if you set WaitingRoomType to default. Valid values:
   * 
   * *   enus: English.
   * *   zhcn: Simplified Chinese.
   * *   zhhk: Traditional Chinese.
   * 
   * @example
   * zhcn
   */
  language?: string;
  /**
   * @remarks
   * The name of the waiting room.
   */
  name?: string;
  /**
   * @remarks
   * The maximum number of new users per minute.
   * 
   * @example
   * 200
   */
  newUsersPerMinute?: string;
  /**
   * @remarks
   * Specifies whether to queue all requests. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  queueAllEnable?: string;
  /**
   * @remarks
   * The queuing method. Valid values:
   * 
   * *   random: Users gain access to the origin randomly, regardless of the arrival time.
   * *   fifo: Users gain access to the origin in order of arrival.
   * *   passthrough: Users pass through the waiting room and go straight to the origin.
   * *   reject-all: Users are blocked from reaching the origin.
   * 
   * @example
   * random
   */
  queuingMethod?: string;
  /**
   * @remarks
   * The HTTP status code to return while a user is in the queue. Valid values:
   * 
   * *   200
   * *   202
   * *   429
   * 
   * @example
   * 200
   */
  queuingStatusCode?: string;
  /**
   * @remarks
   * The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.
   * 
   * @example
   * 5
   */
  sessionDuration?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 7096621098****
   */
  siteId?: number;
  /**
   * @remarks
   * The maximum number of active users.
   * 
   * @example
   * 300
   */
  totalActiveUsers?: string;
  /**
   * @remarks
   * The ID of the waiting room, which can be obtained by calling the [ListWaitingRooms](https://help.aliyun.com/document_detail/2850279.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 6a51d5bc6460887abd129****
   */
  waitingRoomId?: string;
  /**
   * @remarks
   * The type of the waiting room. Valid values:
   * 
   * *   default
   * *   custom
   * 
   * @example
   * default
   */
  waitingRoomType?: string;
  static names(): { [key: string]: string } {
    return {
      cookieName: 'CookieName',
      customPageHtml: 'CustomPageHtml',
      description: 'Description',
      disableSessionRenewalEnable: 'DisableSessionRenewalEnable',
      enable: 'Enable',
      hostNameAndPathShrink: 'HostNameAndPath',
      jsonResponseEnable: 'JsonResponseEnable',
      language: 'Language',
      name: 'Name',
      newUsersPerMinute: 'NewUsersPerMinute',
      queueAllEnable: 'QueueAllEnable',
      queuingMethod: 'QueuingMethod',
      queuingStatusCode: 'QueuingStatusCode',
      sessionDuration: 'SessionDuration',
      siteId: 'SiteId',
      totalActiveUsers: 'TotalActiveUsers',
      waitingRoomId: 'WaitingRoomId',
      waitingRoomType: 'WaitingRoomType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cookieName: 'string',
      customPageHtml: 'string',
      description: 'string',
      disableSessionRenewalEnable: 'string',
      enable: 'string',
      hostNameAndPathShrink: 'string',
      jsonResponseEnable: 'string',
      language: 'string',
      name: 'string',
      newUsersPerMinute: 'string',
      queueAllEnable: 'string',
      queuingMethod: 'string',
      queuingStatusCode: 'string',
      sessionDuration: 'string',
      siteId: 'number',
      totalActiveUsers: 'string',
      waitingRoomId: 'string',
      waitingRoomType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0195619f-eab3-4a66-ac00-ed53d913e72e
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateWaitingRoomResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateWaitingRoomResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomEventRequest extends $tea.Model {
  /**
   * @remarks
   * The content of the custom waiting room page. You must specify this parameter if you set WaitingRoomType to custom. The content must be Base64-encoded.
   * 
   * @example
   * html-yets-maqi1111
   */
  customPageHtml?: string;
  /**
   * @remarks
   * The description of the waiting room.
   * 
   * @example
   * http://yywyyw.com
   */
  description?: string;
  /**
   * @remarks
   * Specifies whether to disable session renewal. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * off
   */
  disableSessionRenewalEnable?: string;
  /**
   * @remarks
   * Specifies whether to enable the waiting room event. Valid values:
   * 
   * *   `on`
   * *   `off`
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * The end time of the event. This value is a UNIX timestamp.
   * 
   * @example
   * 1719849600
   */
  endTime?: string;
  /**
   * @remarks
   * Specifies whether to enable JSON response. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * off
   */
  jsonResponseEnable?: string;
  /**
   * @remarks
   * The default language. Valid values:
   * 
   * *   `enus`: English.
   * *   `zhcn`: Simplified Chinese.
   * *   `zhhk`: Traditional Chinese.
   * 
   * @example
   * enus
   */
  language?: string;
  /**
   * @remarks
   * The name of the waiting room event.
   */
  name?: string;
  /**
   * @remarks
   * The maximum number of new users per minute.
   * 
   * @example
   * 300
   */
  newUsersPerMinute?: string;
  /**
   * @remarks
   * Specifies whether to enable pre-queuing.
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  preQueueEnable?: string;
  /**
   * @remarks
   * The start time for pre-queuing.
   * 
   * @example
   * 1719763200
   */
  preQueueStartTime?: string;
  /**
   * @remarks
   * The queuing method. Valid values:
   * 
   * *   random: Users gain access to the origin randomly, regardless of the arrival time.
   * *   fifo: Users gain access to the origin in order of arrival.
   * *   passthrough: Users pass through the waiting room and go straight to the origin.
   * *   reject-all: All requests are blocked from accessing the origin.
   * 
   * @example
   * fifo
   */
  queuingMethod?: string;
  /**
   * @remarks
   * The HTTP status code to return while a user is in the queue. Valid values:
   * 
   * *   200
   * *   202
   * *   429
   * 
   * @example
   * 200
   */
  queuingStatusCode?: string;
  /**
   * @remarks
   * Specifies whether to enable random queuing.
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  randomPreQueueEnable?: string;
  /**
   * @remarks
   * The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.
   * 
   * @example
   * 5
   */
  sessionDuration?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The start time of the event. This value is a UNIX timestamp.
   * 
   * @example
   * 1719763200
   */
  startTime?: string;
  /**
   * @remarks
   * The maximum number of active users.
   * 
   * @example
   * 200
   */
  totalActiveUsers?: string;
  /**
   * @remarks
   * The ID of the waiting room event, which can be obtained by calling the [ListWaitingRoomEvents](https://help.aliyun.com/document_detail/2850279.html) operation.
   * 
   * @example
   * 89677721098****
   */
  waitingRoomEventId?: number;
  /**
   * @remarks
   * The type of the waiting room. Valid values:
   * 
   * *   default
   * *   custom
   * 
   * @example
   * custom
   */
  waitingRoomType?: string;
  static names(): { [key: string]: string } {
    return {
      customPageHtml: 'CustomPageHtml',
      description: 'Description',
      disableSessionRenewalEnable: 'DisableSessionRenewalEnable',
      enable: 'Enable',
      endTime: 'EndTime',
      jsonResponseEnable: 'JsonResponseEnable',
      language: 'Language',
      name: 'Name',
      newUsersPerMinute: 'NewUsersPerMinute',
      preQueueEnable: 'PreQueueEnable',
      preQueueStartTime: 'PreQueueStartTime',
      queuingMethod: 'QueuingMethod',
      queuingStatusCode: 'QueuingStatusCode',
      randomPreQueueEnable: 'RandomPreQueueEnable',
      sessionDuration: 'SessionDuration',
      siteId: 'SiteId',
      startTime: 'StartTime',
      totalActiveUsers: 'TotalActiveUsers',
      waitingRoomEventId: 'WaitingRoomEventId',
      waitingRoomType: 'WaitingRoomType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customPageHtml: 'string',
      description: 'string',
      disableSessionRenewalEnable: 'string',
      enable: 'string',
      endTime: 'string',
      jsonResponseEnable: 'string',
      language: 'string',
      name: 'string',
      newUsersPerMinute: 'string',
      preQueueEnable: 'string',
      preQueueStartTime: 'string',
      queuingMethod: 'string',
      queuingStatusCode: 'string',
      randomPreQueueEnable: 'string',
      sessionDuration: 'string',
      siteId: 'number',
      startTime: 'string',
      totalActiveUsers: 'string',
      waitingRoomEventId: 'number',
      waitingRoomType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomEventResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0195619f-eab3-4a66-ac00-ed53d913e72e
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomEventResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateWaitingRoomEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateWaitingRoomEventResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The rule content, which is a policy or conditional expression.
   * 
   * This parameter is required.
   * 
   * @example
   * (http.request.uri.path.file_name eq \\"jpg\\")
   */
  rule?: string;
  /**
   * @remarks
   * Specifies whether to enable the rule. Valid values:
   * 
   * *   on
   * *   off
   * 
   * This parameter is required.
   * 
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @remarks
   * The rule name.
   * 
   * This parameter is required.
   * 
   * @example
   * test1
   */
  ruleName?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The ID of the waiting room bypass rule that you want to update. You can call [ListWaitingRoomRules](https://help.aliyun.com/document_detail/2850279.html) to obtain the ID.
   * 
   * @example
   * 8987739839****
   */
  waitingRoomRuleId?: number;
  static names(): { [key: string]: string } {
    return {
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      waitingRoomRuleId: 'WaitingRoomRuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
      waitingRoomRuleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID, which is used to trace a call.
   * 
   * @example
   * 9bfe9d95-7bf6-469d-a628-ed7bc9f25073
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateWaitingRoomRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateWaitingRoomRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadFileRequest extends $tea.Model {
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  /**
   * @remarks
   * The type of the purge or prefetch task. Valid values:
   * 
   * *   **file** (default): purges the cache by file.
   * *   **preload**: prefetches the file.
   * *   **directory**: purges the cache by directory.
   * *   **ignoreParams**: purges the cache by URL with specified parameters ignored.
   * 
   * This parameter is required.
   * 
   * @example
   * file
   */
  type?: string;
  /**
   * @remarks
   * The name of the upload task.
   * 
   * This parameter is required.
   * 
   * @example
   * purge_task_2024_11_11
   */
  uploadTaskName?: string;
  /**
   * @remarks
   * The OSS URL of the file that contains resources to be purged or prefetched.
   * 
   * This parameter is required.
   * 
   * @example
   * https://xxxxx.oss-cn-shenzhen.aliyuncs.com/test_oss_file?Expires=1708659191&OSSAccessKeyId=**********&Signature=**********
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      type: 'Type',
      uploadTaskName: 'UploadTaskName',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      type: 'string',
      uploadTaskName: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadFileAdvanceRequest extends $tea.Model {
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  /**
   * @remarks
   * The type of the purge or prefetch task. Valid values:
   * 
   * *   **file** (default): purges the cache by file.
   * *   **preload**: prefetches the file.
   * *   **directory**: purges the cache by directory.
   * *   **ignoreParams**: purges the cache by URL with specified parameters ignored.
   * 
   * This parameter is required.
   * 
   * @example
   * file
   */
  type?: string;
  /**
   * @remarks
   * The name of the upload task.
   * 
   * This parameter is required.
   * 
   * @example
   * purge_task_2024_11_11
   */
  uploadTaskName?: string;
  /**
   * @remarks
   * The OSS URL of the file that contains resources to be purged or prefetched.
   * 
   * This parameter is required.
   * 
   * @example
   * https://xxxxx.oss-cn-shenzhen.aliyuncs.com/test_oss_file?Expires=1708659191&OSSAccessKeyId=**********&Signature=**********
   */
  urlObject?: Readable;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      type: 'Type',
      uploadTaskName: 'UploadTaskName',
      urlObject: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      type: 'string',
      uploadTaskName: 'string',
      urlObject: 'Readable',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadFileResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 3C6CCEC4-6B88-4D4A-93E4-D47B3D92CF8F
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the file upload task. You can use this ID for task submission or query subsequently.
   * 
   * @example
   * 159253299357****
   */
  uploadId?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      uploadId: 'UploadId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      uploadId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UploadFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UploadFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class VerifySiteRequest extends $tea.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class VerifySiteResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the verification passed. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  passed?: boolean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 65C66B7B-671A-8297-9187-2R5477247B76
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      passed: 'Passed',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      passed: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class VerifySiteResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: VerifySiteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: VerifySiteResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafBatchRuleSharedActionsResponse extends $tea.Model {
  code?: number;
  id?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafBatchRuleSharedActions extends $tea.Model {
  response?: WafBatchRuleSharedActionsResponse;
  static names(): { [key: string]: string } {
    return {
      response: 'Response',
    };
  }

  static types(): { [key: string]: any } {
    return {
      response: WafBatchRuleSharedActionsResponse,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigActionsBypass extends $tea.Model {
  customRules?: number[];
  regularRules?: number[];
  regularTypes?: string[];
  skip?: string;
  tags?: string[];
  static names(): { [key: string]: string } {
    return {
      customRules: 'CustomRules',
      regularRules: 'RegularRules',
      regularTypes: 'RegularTypes',
      skip: 'Skip',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customRules: { 'type': 'array', 'itemType': 'number' },
      regularRules: { 'type': 'array', 'itemType': 'number' },
      regularTypes: { 'type': 'array', 'itemType': 'string' },
      skip: 'string',
      tags: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigActionsResponse extends $tea.Model {
  code?: number;
  id?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigActions extends $tea.Model {
  bypass?: WafRuleConfigActionsBypass;
  response?: WafRuleConfigActionsResponse;
  static names(): { [key: string]: string } {
    return {
      bypass: 'Bypass',
      response: 'Response',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bypass: WafRuleConfigActionsBypass,
      response: WafRuleConfigActionsResponse,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigAppPackagePackageSigns extends $tea.Model {
  name?: string;
  sign?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      sign: 'Sign',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      sign: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigAppPackage extends $tea.Model {
  packageSigns?: WafRuleConfigAppPackagePackageSigns[];
  static names(): { [key: string]: string } {
    return {
      packageSigns: 'PackageSigns',
    };
  }

  static types(): { [key: string]: any } {
    return {
      packageSigns: { 'type': 'array', 'itemType': WafRuleConfigAppPackagePackageSigns },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigAppSdkCustomSign extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigAppSdk extends $tea.Model {
  customSign?: WafRuleConfigAppSdkCustomSign;
  customSignStatus?: string;
  featureAbnormal?: string[];
  static names(): { [key: string]: string } {
    return {
      customSign: 'CustomSign',
      customSignStatus: 'CustomSignStatus',
      featureAbnormal: 'FeatureAbnormal',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customSign: WafRuleConfigAppSdkCustomSign,
      customSignStatus: 'string',
      featureAbnormal: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigManagedRulesetsManagedRules extends $tea.Model {
  action?: string;
  id?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      id: 'Id',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      id: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigManagedRulesets extends $tea.Model {
  action?: string;
  attackType?: number;
  managedRules?: WafRuleConfigManagedRulesetsManagedRules[];
  numberEnabled?: number;
  numberTotal?: number;
  protectionLevel?: number;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      attackType: 'AttackType',
      managedRules: 'ManagedRules',
      numberEnabled: 'NumberEnabled',
      numberTotal: 'NumberTotal',
      protectionLevel: 'ProtectionLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      attackType: 'number',
      managedRules: { 'type': 'array', 'itemType': WafRuleConfigManagedRulesetsManagedRules },
      numberEnabled: 'number',
      numberTotal: 'number',
      protectionLevel: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigRateLimitThresholdResponseStatus extends $tea.Model {
  code?: number;
  count?: number;
  ratio?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      count: 'Count',
      ratio: 'Ratio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      count: 'number',
      ratio: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigRateLimitThreshold extends $tea.Model {
  distinctManagedRules?: number;
  managedRulesBlocked?: number;
  request?: number;
  responseStatus?: WafRuleConfigRateLimitThresholdResponseStatus;
  traffic?: string;
  static names(): { [key: string]: string } {
    return {
      distinctManagedRules: 'DistinctManagedRules',
      managedRulesBlocked: 'ManagedRulesBlocked',
      request: 'Request',
      responseStatus: 'ResponseStatus',
      traffic: 'Traffic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distinctManagedRules: 'number',
      managedRulesBlocked: 'number',
      request: 'number',
      responseStatus: WafRuleConfigRateLimitThresholdResponseStatus,
      traffic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigRateLimit extends $tea.Model {
  characteristics?: WafRuleMatch2;
  interval?: number;
  onHit?: boolean;
  TTL?: number;
  threshold?: WafRuleConfigRateLimitThreshold;
  static names(): { [key: string]: string } {
    return {
      characteristics: 'Characteristics',
      interval: 'Interval',
      onHit: 'OnHit',
      TTL: 'TTL',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      characteristics: WafRuleMatch2,
      interval: 'number',
      onHit: 'boolean',
      TTL: 'number',
      threshold: WafRuleConfigRateLimitThreshold,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleMatch2CriteriaCriteriaCriteria extends $tea.Model {
  convertToLower?: boolean;
  matchOperator?: string;
  matchType?: string;
  matchValue?: any;
  negate?: boolean;
  static names(): { [key: string]: string } {
    return {
      convertToLower: 'ConvertToLower',
      matchOperator: 'MatchOperator',
      matchType: 'MatchType',
      matchValue: 'MatchValue',
      negate: 'Negate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      convertToLower: 'boolean',
      matchOperator: 'string',
      matchType: 'string',
      matchValue: 'any',
      negate: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleMatch2CriteriaCriteria extends $tea.Model {
  convertToLower?: boolean;
  criteria?: WafRuleMatch2CriteriaCriteriaCriteria[];
  logic?: string;
  matchOperator?: string;
  matchType?: string;
  matchValue?: any;
  negate?: boolean;
  static names(): { [key: string]: string } {
    return {
      convertToLower: 'ConvertToLower',
      criteria: 'Criteria',
      logic: 'Logic',
      matchOperator: 'MatchOperator',
      matchType: 'MatchType',
      matchValue: 'MatchValue',
      negate: 'Negate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      convertToLower: 'boolean',
      criteria: { 'type': 'array', 'itemType': WafRuleMatch2CriteriaCriteriaCriteria },
      logic: 'string',
      matchOperator: 'string',
      matchType: 'string',
      matchValue: 'any',
      negate: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleMatch2Criteria extends $tea.Model {
  convertToLower?: boolean;
  criteria?: WafRuleMatch2CriteriaCriteria[];
  logic?: string;
  matchOperator?: string;
  matchType?: string;
  matchValue?: any;
  negate?: boolean;
  static names(): { [key: string]: string } {
    return {
      convertToLower: 'ConvertToLower',
      criteria: 'Criteria',
      logic: 'Logic',
      matchOperator: 'MatchOperator',
      matchType: 'MatchType',
      matchValue: 'MatchValue',
      negate: 'Negate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      convertToLower: 'boolean',
      criteria: { 'type': 'array', 'itemType': WafRuleMatch2CriteriaCriteria },
      logic: 'string',
      matchOperator: 'string',
      matchType: 'string',
      matchValue: 'any',
      negate: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafSiteSettingsAddBotProtectionHeaders extends $tea.Model {
  enable?: boolean;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafSiteSettingsAddSecurityHeaders extends $tea.Model {
  enable?: boolean;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafSiteSettingsClientIpIdentifier extends $tea.Model {
  headers?: string[];
  mode?: string;
  static names(): { [key: string]: string } {
    return {
      headers: 'Headers',
      mode: 'Mode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'array', 'itemType': 'string' },
      mode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafSiteSettingsSecurityLevel extends $tea.Model {
  value?: string;
  static names(): { [key: string]: string } {
    return {
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafTimerPeriods extends $tea.Model {
  end?: string;
  start?: string;
  static names(): { [key: string]: string } {
    return {
      end: 'End',
      start: 'Start',
    };
  }

  static types(): { [key: string]: any } {
    return {
      end: 'string',
      start: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafTimerWeeklyPeriodsDailyPeriods extends $tea.Model {
  end?: string;
  start?: string;
  static names(): { [key: string]: string } {
    return {
      end: 'End',
      start: 'Start',
    };
  }

  static types(): { [key: string]: any } {
    return {
      end: 'string',
      start: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafTimerWeeklyPeriods extends $tea.Model {
  dailyPeriods?: WafTimerWeeklyPeriodsDailyPeriods[];
  days?: string;
  static names(): { [key: string]: string } {
    return {
      dailyPeriods: 'DailyPeriods',
      days: 'Days',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dailyPeriods: { 'type': 'array', 'itemType': WafTimerWeeklyPeriodsDailyPeriods },
      days: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FieldContentValueFieldList extends $tea.Model {
  /**
   * @remarks
   * The field name.
   * 
   * @example
   * ClientIp
   */
  fieldName?: string;
  /**
   * @remarks
   * The description of the field in English.
   * 
   * @example
   * IP address of the client.
   */
  description?: string;
  /**
   * @remarks
   * The description of the field in Chinese.
   */
  descriptionCn?: string;
  /**
   * @remarks
   * The category of the field.
   * 
   * @example
   * Client
   */
  category?: string;
  /**
   * @remarks
   * The data type of the field.
   * 
   * @example
   * String
   */
  dataType?: string;
  /**
   * @remarks
   * The sequence number of the field.
   * 
   * @example
   * 1
   */
  sortOrder?: number;
  /**
   * @remarks
   * Indicates whether the field is available by default.
   * 
   * @example
   * true
   */
  isDefault?: boolean;
  static names(): { [key: string]: string } {
    return {
      fieldName: 'FieldName',
      description: 'Description',
      descriptionCn: 'DescriptionCn',
      category: 'Category',
      dataType: 'DataType',
      sortOrder: 'SortOrder',
      isDefault: 'IsDefault',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldName: 'string',
      description: 'string',
      descriptionCn: 'string',
      category: 'string',
      dataType: 'string',
      sortOrder: 'number',
      isDefault: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsRequestRecordListAuthConf extends $tea.Model {
  accessKey?: string;
  authType?: string;
  region?: string;
  secretKey?: string;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      authType: 'AuthType',
      region: 'Region',
      secretKey: 'SecretKey',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      authType: 'string',
      region: 'string',
      secretKey: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsRequestRecordListData extends $tea.Model {
  /**
   * @remarks
   * The encryption algorithm used for the record. Valid values: 0 to 255. Applicable to CERT and SSHFP records.
   * 
   * @example
   * 0
   */
  algorithm?: number;
  /**
   * @remarks
   * The public key of the certificate. Applicable to CERT, SMIMEA, and TLSA records.
   * 
   * @example
   * dGVzdGFkYWxrcw==
   */
  certificate?: string;
  /**
   * @remarks
   * The public key fingerprint of the record. Applicable to SSHFP records.
   * 
   * @example
   * abcdef1234567890
   */
  fingerprint?: string;
  /**
   * @remarks
   * The Flag for a CAA record indicates its priority and how it is processed. Valid values: 0 to 255.
   * 
   * @example
   * 128
   */
  flag?: number;
  /**
   * @remarks
   * The public key identification for the record. Valid values: 0 to 65535. Applicable to CERT records.
   * 
   * @example
   * 0
   */
  keyTag?: number;
  /**
   * @remarks
   * The algorithm policy used to match or validate the certificate. Valid values: 0 to 255. Applicable to SMIMEA, and TLSA records.
   * 
   * @example
   * 0
   */
  matchingType?: number;
  /**
   * @remarks
   * The port of the record. Valid values: 0 to 65535. Exclusive to SRV records.
   * 
   * @example
   * 0
   */
  port?: number;
  /**
   * @remarks
   * The priority of the record. Valid values: 0 to 65535. A smaller value indicates a higher priority. This parameter is required when you add MX, SRV, and URI records.
   * 
   * @example
   * 2
   */
  priority?: number;
  /**
   * @remarks
   * The type of certificate or public key. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.
   * 
   * @example
   * 0
   */
  selector?: number;
  /**
   * @remarks
   * The tag of a CAA record, which indicates its specific type and purpose, such as issue, issuewild, and iodef.
   * 
   * @example
   * issue
   */
  tag?: string;
  /**
   * @remarks
   * The certificate type of the record (in CERT records), or the public key type (in SSHFP records).
   * 
   * @example
   * 0
   */
  type?: number;
  /**
   * @remarks
   * The usage identifier of the record. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.
   * 
   * @example
   * 0
   */
  usage?: number;
  /**
   * @remarks
   * The record value or part of the record content. A/AAAA: the IP address being pointed to. CNAME: the target domain name being pointed to. MX: valid target mail server domain name. TXT: valid text string. CAA: valid certificate authority domain name. SRV: valid target host domain name. URI: valid URI string.
   * 
   * @example
   * example.com
   */
  value?: string;
  /**
   * @remarks
   * The weight of the record. Valid values: 0 to 65,535. Applicable to SRV and URI records.
   * 
   * @example
   * 0
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      algorithm: 'Algorithm',
      certificate: 'Certificate',
      fingerprint: 'Fingerprint',
      flag: 'Flag',
      keyTag: 'KeyTag',
      matchingType: 'MatchingType',
      port: 'Port',
      priority: 'Priority',
      selector: 'Selector',
      tag: 'Tag',
      type: 'Type',
      usage: 'Usage',
      value: 'Value',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      algorithm: 'number',
      certificate: 'string',
      fingerprint: 'string',
      flag: 'number',
      keyTag: 'number',
      matchingType: 'number',
      port: 'number',
      priority: 'number',
      selector: 'number',
      tag: 'string',
      type: 'number',
      usage: 'number',
      value: 'string',
      weight: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsRequestRecordList extends $tea.Model {
  authConf?: BatchCreateRecordsRequestRecordListAuthConf;
  /**
   * @remarks
   * The business scenario of the record for acceleration. Valid values:
   * 
   * *   **image_video**
   * *   **api**
   * *   **web**
   * 
   * @example
   * web
   */
  bizName?: string;
  /**
   * @remarks
   * The DNS information of the record. Enter fields based on the record type.
   * 
   * This parameter is required.
   * 
   * @example
   * {
   *     "value":"2.2.2.2"
   * }
   */
  data?: BatchCreateRecordsRequestRecordListData;
  /**
   * @remarks
   * Specifies whether to proxy the record. Only CNAME and A/AAAA records can be proxied. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  proxied?: boolean;
  /**
   * @remarks
   * The record name.
   * 
   * This parameter is required.
   * 
   * @example
   * www.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The origin type for the CNAME record. This parameter is required when you add a CNAME record. Valid values:
   * 
   * *   **OSS**: OSS bucket.
   * *   **S3**: S3 bucket.
   * *   **LB**: load balancer.
   * *   **OP**: origin pool.
   * *   **Domain**: domain name.
   * 
   * If you do not pass this parameter or if you leave its value empty, Domain is used by default.
   * 
   * @example
   * OSS
   */
  sourceType?: string;
  /**
   * @remarks
   * The TTL of the record. Unit: seconds. If the value is 1, the TTL of the record is determined by the system.
   * 
   * This parameter is required.
   * 
   * @example
   * 60
   */
  ttl?: number;
  /**
   * @remarks
   * The DNS type of the record.
   * 
   * This parameter is required.
   * 
   * @example
   * A/AAAA
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      authConf: 'AuthConf',
      bizName: 'BizName',
      data: 'Data',
      proxied: 'Proxied',
      recordName: 'RecordName',
      sourceType: 'SourceType',
      ttl: 'Ttl',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authConf: BatchCreateRecordsRequestRecordListAuthConf,
      bizName: 'string',
      data: BatchCreateRecordsRequestRecordListData,
      proxied: 'boolean',
      recordName: 'string',
      sourceType: 'string',
      ttl: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsResponseBodyRecordResultListFailedData extends $tea.Model {
  /**
   * @remarks
   * The encryption algorithm used for the record. Valid values: 0 to 255. Applicable to CERT and SSHFP records.
   * 
   * @example
   * 0
   */
  algorithm?: number;
  /**
   * @remarks
   * The public key of the certificate. Applicable to CERT, SMIMEA, and TLSA records.
   * 
   * @example
   * dGVzdGFkYWxrcw==
   */
  certificate?: string;
  /**
   * @remarks
   * The public key fingerprint of the record. Applicable to SSHFP records.
   * 
   * @example
   * abcdef1234567890
   */
  fingerprint?: string;
  /**
   * @remarks
   * The flag bit of the record. Indicates its priority and handling method, used in CAA records.
   * 
   * @example
   * 128
   */
  flag?: number;
  /**
   * @remarks
   * The public key identification for the record. Valid values: 0 to 65535. Applicable to CERT records.
   * 
   * @example
   * 0
   */
  keyTag?: number;
  /**
   * @remarks
   * The algorithm policy used to match or validate the certificate. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.
   * 
   * @example
   * RSA
   */
  matchingType?: number;
  /**
   * @remarks
   * The port number of the record, associated with the SRV record. Exclusive to SRV records.
   * 
   * @example
   * 0
   */
  port?: number;
  /**
   * @remarks
   * The priority of the record. Valid values: 0 to 65535. A smaller value indicates a higher priority. Applicable to MX, SRV, and URI records.
   * 
   * @example
   * 10
   */
  priority?: number;
  /**
   * @remarks
   * The type of certificate or public key. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.
   * 
   * @example
   * 0
   */
  selector?: number;
  /**
   * @remarks
   * Indicates its priority and handling method, used in CAA records.
   * 
   * @example
   * issue
   */
  tag?: string;
  /**
   * @remarks
   * The certificate type of the record (in CERT records), or the public key type (in SSHFP records).
   * 
   * @example
   * 0
   */
  type?: number;
  /**
   * @remarks
   * The usage identifier of the record. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.
   * 
   * @example
   * 0
   */
  usage?: number;
  /**
   * @remarks
   * The record value or part of the record content. This value is returned when the record is A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, or URI. It has different meanings based on types of records:
   * 
   * *   **A/AAAA**: the IP addresses. IP addresses are separated by commas (,). There is at least one IPv4 address.
   * *   **CNAME**: the mapped domain name.
   * *   **NS**: the nameservers for the domain name.
   * *   **MX**: a valid domain name of the target mail server.
   * *   **TXT**: a valid text string.
   * *   **CAA**: a valid domain name of the certificate authority.
   * *   **SRV**: a valid domain name of the target host.
   * *   **URI**: a valid URI string.
   * 
   * @example
   * example.com
   */
  value?: string;
  /**
   * @remarks
   * The weight of the record. Applicable to SRV and URI records.
   * 
   * @example
   * 0
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      algorithm: 'Algorithm',
      certificate: 'Certificate',
      fingerprint: 'Fingerprint',
      flag: 'Flag',
      keyTag: 'KeyTag',
      matchingType: 'MatchingType',
      port: 'Port',
      priority: 'Priority',
      selector: 'Selector',
      tag: 'Tag',
      type: 'Type',
      usage: 'Usage',
      value: 'Value',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      algorithm: 'number',
      certificate: 'string',
      fingerprint: 'string',
      flag: 'number',
      keyTag: 'number',
      matchingType: 'number',
      port: 'number',
      priority: 'number',
      selector: 'number',
      tag: 'string',
      type: 'number',
      usage: 'number',
      value: 'string',
      weight: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsResponseBodyRecordResultListFailed extends $tea.Model {
  /**
   * @remarks
   * The business scenario of the record for acceleration. Valid values:
   * 
   * *   **image_video**
   * *   **api**
   * *   **web**
   * 
   * @example
   * web
   */
  bizName?: string;
  /**
   * @remarks
   * The DNS information about the record, which contains various types of record values and their related attributes.
   * 
   * @example
   * {"value":"2.2.2.2"}
   */
  data?: BatchCreateRecordsResponseBodyRecordResultListFailedData;
  /**
   * @remarks
   * The result description.
   */
  description?: string;
  /**
   * @remarks
   * Indicates whether the record is proxied. Only CNAME and A/AAAA records can be proxied. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  proxied?: boolean;
  /**
   * @remarks
   * The record ID.
   * 
   * @example
   * 1234567890123
   */
  recordId?: number;
  /**
   * @remarks
   * The record name.
   * 
   * @example
   * a.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The DNS type of the record, such as **A/AAAA, CNAME, and TXT**.
   * 
   * @example
   * A/AAAA
   */
  recordType?: string;
  /**
   * @remarks
   * The origin type of the CNAME record. This field is left empty for other types of records. The type of the origin server. Valid values:
   * 
   * *   **OSS**: OSS bucket.
   * *   **S3**: S3 bucket.
   * *   **LB**: load balancer.
   * *   **OP**: origin pool.
   * *   **Domain**: domain name.
   * 
   * @example
   * OSS
   */
  sourceType?: string;
  /**
   * @remarks
   * The TTL of the record. Unit: seconds. If the value is 1, the TTL of the record is determined by the system.
   * 
   * @example
   * 60
   */
  ttl?: number;
  static names(): { [key: string]: string } {
    return {
      bizName: 'BizName',
      data: 'Data',
      description: 'Description',
      proxied: 'Proxied',
      recordId: 'RecordId',
      recordName: 'RecordName',
      recordType: 'RecordType',
      sourceType: 'SourceType',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizName: 'string',
      data: BatchCreateRecordsResponseBodyRecordResultListFailedData,
      description: 'string',
      proxied: 'boolean',
      recordId: 'number',
      recordName: 'string',
      recordType: 'string',
      sourceType: 'string',
      ttl: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsResponseBodyRecordResultListSuccessData extends $tea.Model {
  /**
   * @remarks
   * The encryption algorithm used for the record. Valid values: 0 to 255. Applicable to CERT and SSHFP records.
   * 
   * @example
   * 0
   */
  algorithm?: number;
  /**
   * @remarks
   * The public key of the certificate. Applicable to CERT, SMIMEA, and TLSA records.
   * 
   * @example
   * dGVzdGFkYWxrcw==
   */
  certificate?: string;
  /**
   * @remarks
   * The public key fingerprint of the record. Applicable to SSHFP records.
   * 
   * @example
   * abcdef1234567890
   */
  fingerprint?: string;
  /**
   * @remarks
   * The flag bit of the record. Indicates its priority and handling method, used in CAA records.
   * 
   * @example
   * 128
   */
  flag?: number;
  /**
   * @remarks
   * The public key identification for the record. Valid values: 0 to 65535. Applicable to CERT records.
   * 
   * @example
   * 0
   */
  keyTag?: number;
  /**
   * @remarks
   * The algorithm policy used to match or validate the certificate. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.
   * 
   * @example
   * 0
   */
  matchingType?: number;
  /**
   * @remarks
   * The port of the record. Valid values: 0 to 65535. Exclusive to SRV records.
   * 
   * @example
   * 0
   */
  port?: number;
  /**
   * @remarks
   * The priority of the record. Valid values: 0 to 65535. A smaller value indicates a higher priority. Applicable to MX, SRV, and URI records.
   * 
   * @example
   * 10
   */
  priority?: number;
  /**
   * @remarks
   * The type of certificate or public key. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.
   * 
   * @example
   * 0
   */
  selector?: number;
  /**
   * @remarks
   * The label of a CAA record, which indicates its specific type and purpose, such as issue, issuewild, and iodef.
   * 
   * @example
   * issue
   */
  tag?: string;
  /**
   * @remarks
   * The certificate type of the record (in CERT records), or the public key type (in SSHFP records).
   * 
   * @example
   * 0
   */
  type?: number;
  /**
   * @remarks
   * The usage identifier of the record. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.
   * 
   * @example
   * 0
   */
  usage?: number;
  /**
   * @remarks
   * The record value or part of the record content. This value is returned when the record is A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, or URI. It has different meanings based on types of records:
   * 
   * *   **A/AAAA**: the IP addresses. Multiple IPs are separated by commas (,). There is at least one IPv4 address.
   * *   **CNAME**: the mapped domain name.
   * *   **NS**: the nameservers for the domain name.
   * *   **MX**: a valid domain name of the target mail server.
   * *   **TXT**: a valid text string.
   * *   **CAA**: a valid domain name of the certificate authority.
   * *   **SRV**: a valid domain name of the target host.
   * *   **URI**: a valid URI string.
   * 
   * @example
   * example.com
   */
  value?: string;
  /**
   * @remarks
   * The weight of the record. Valid values: 0 to 65535. Applicable to SRV and URI records.
   * 
   * @example
   * 0
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      algorithm: 'Algorithm',
      certificate: 'Certificate',
      fingerprint: 'Fingerprint',
      flag: 'Flag',
      keyTag: 'KeyTag',
      matchingType: 'MatchingType',
      port: 'Port',
      priority: 'Priority',
      selector: 'Selector',
      tag: 'Tag',
      type: 'Type',
      usage: 'Usage',
      value: 'Value',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      algorithm: 'number',
      certificate: 'string',
      fingerprint: 'string',
      flag: 'number',
      keyTag: 'number',
      matchingType: 'number',
      port: 'number',
      priority: 'number',
      selector: 'number',
      tag: 'string',
      type: 'number',
      usage: 'number',
      value: 'string',
      weight: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsResponseBodyRecordResultListSuccess extends $tea.Model {
  /**
   * @remarks
   * The business scenario of the record for acceleration. Valid values:
   * 
   * *   **image_video**
   * *   **api**
   * *   **web**
   * 
   * @example
   * web
   */
  bizName?: string;
  /**
   * @remarks
   * The DNS record information.
   * 
   * @example
   * {"value":"1.1.1.1"}
   */
  data?: BatchCreateRecordsResponseBodyRecordResultListSuccessData;
  /**
   * @remarks
   * The result description.
   * 
   * @example
   * success
   */
  description?: string;
  /**
   * @remarks
   * Indicates whether the record is proxied. Only CNAME and A/AAAA records can be proxied. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  proxied?: boolean;
  /**
   * @remarks
   * The record ID.
   * 
   * @example
   * 1234567890123
   */
  recordId?: number;
  /**
   * @remarks
   * The record name.
   * 
   * @example
   * www.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The DNS type of the record, such as **A/AAAA, CNAME, and TXT**.
   * 
   * @example
   * A/AAAA
   */
  recordType?: string;
  /**
   * @remarks
   * The origin type of the CNAME record. This field is left empty for other types of records. The type of the origin server. Valid values:
   * 
   * *   **OSS**: OSS bucket.
   * *   **S3**: S3 bucket.
   * *   **LB**: load balancer.
   * *   **OP**: origin pool.
   * *   **Domain**: domain name.
   * 
   * @example
   * OSS
   */
  sourceType?: string;
  /**
   * @remarks
   * The TTL of the record. Unit: seconds. If the value is 1, the TTL of the record is determined by the system.
   * 
   * @example
   * 60
   */
  ttl?: number;
  static names(): { [key: string]: string } {
    return {
      bizName: 'BizName',
      data: 'Data',
      description: 'Description',
      proxied: 'Proxied',
      recordId: 'RecordId',
      recordName: 'RecordName',
      recordType: 'RecordType',
      sourceType: 'SourceType',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizName: 'string',
      data: BatchCreateRecordsResponseBodyRecordResultListSuccessData,
      description: 'string',
      proxied: 'boolean',
      recordId: 'number',
      recordName: 'string',
      recordType: 'string',
      sourceType: 'string',
      ttl: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsResponseBodyRecordResultList extends $tea.Model {
  /**
   * @remarks
   * The records that failed to be created.
   */
  failed?: BatchCreateRecordsResponseBodyRecordResultListFailed[];
  /**
   * @remarks
   * The records that have been created.
   */
  success?: BatchCreateRecordsResponseBodyRecordResultListSuccess[];
  /**
   * @remarks
   * The total number of returned records.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      failed: 'Failed',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failed: { 'type': 'array', 'itemType': BatchCreateRecordsResponseBodyRecordResultListFailed },
      success: { 'type': 'array', 'itemType': BatchCreateRecordsResponseBodyRecordResultListSuccess },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetExpressionFieldsRequestExpressions extends $tea.Model {
  /**
   * @remarks
   * The content of the regular expression.
   * 
   * @example
   * ip.src eq 1.1.1.1
   */
  expression?: string;
  /**
   * @remarks
   * The ID of the regular expression.
   * 
   * @example
   * 1
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      expression: 'Expression',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expression: 'string',
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetExpressionFieldsResponseBodyFields extends $tea.Model {
  /**
   * @remarks
   * The fields that match the regular expression.
   */
  fields?: string[];
  /**
   * @remarks
   * The ID of the regular expression, which corresponds to the expression ID in the request parameter.
   * 
   * @example
   * 1
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      fields: 'Fields',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fields: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutKvRequestKvList extends $tea.Model {
  /**
   * @remarks
   * The time when the key-value pair expires, which cannot be earlier than the current time. The value is a timestamp in seconds. If you specify both Expiration and ExpirationTtl, only ExpirationTtl takes effect.
   * 
   * @example
   * 1690081381
   */
  expiration?: number;
  /**
   * @remarks
   * The relative expiration time. Unit: seconds. If you specify both Expiration and ExpirationTtl, only ExpirationTtl takes effect.
   * 
   * @example
   * 3600
   */
  expirationTtl?: number;
  /**
   * @remarks
   * The key name. The name can be up to 512 characters in length and cannot contain spaces or backslashes (\\\\).
   * 
   * This parameter is required.
   * 
   * @example
   * test_key
   */
  key?: string;
  /**
   * @remarks
   * The key content.
   * 
   * This parameter is required.
   * 
   * @example
   * test_value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      expiration: 'Expiration',
      expirationTtl: 'ExpirationTtl',
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expiration: 'number',
      expirationTtl: 'number',
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppVersionRequestContainersACRImageInfo extends $tea.Model {
  /**
   * @remarks
   * The domain name of the Container Registry image.
   * 
   * @example
   * 1500.***.net
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the Container Registry instance.
   * 
   * @example
   * xcdn-9axbo****
   */
  instanceId?: string;
  /**
   * @remarks
   * Specifies whether the image is an enterprise-level Container Registry image.
   * 
   * @example
   * false
   */
  isEnterpriseRegistry?: boolean;
  /**
   * @remarks
   * The regions in which the Container Registry instance resides.
   * 
   * @example
   * cn-shanghai
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the image repository.
   * 
   * @example
   * crr-h1ghghu60ct****
   */
  repoId?: string;
  /**
   * @remarks
   * The name of the image repository.
   * 
   * @example
   * test_71
   */
  repoName?: string;
  /**
   * @remarks
   * The namespace to which the image repository belongs.
   * 
   * @example
   * safeline
   */
  repoNamespace?: string;
  /**
   * @remarks
   * The tag of the Container Registry image.
   * 
   * @example
   * 3.40.2
   */
  tag?: string;
  /**
   * @remarks
   * The URL of the Container Registry image tag.
   */
  tagUrl?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      instanceId: 'InstanceId',
      isEnterpriseRegistry: 'IsEnterpriseRegistry',
      regionId: 'RegionId',
      repoId: 'RepoId',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      tag: 'Tag',
      tagUrl: 'TagUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      instanceId: 'string',
      isEnterpriseRegistry: 'boolean',
      regionId: 'string',
      repoId: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      tag: 'string',
      tagUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppVersionRequestContainersProbeContent extends $tea.Model {
  /**
   * @remarks
   * The command of the exec type probe.
   * 
   * @example
   * echo ok
   */
  command?: string;
  /**
   * @remarks
   * The number of consecutive failed health checks required for a container to be considered as unhealthy.
   * 
   * @example
   * 3
   */
  failureThreshold?: number;
  /**
   * @remarks
   * The domain name that is used for health checks.
   * 
   * @example
   * www.rewrite.com
   */
  host?: string;
  /**
   * @remarks
   * The request headers that are included in the container health check request.
   * 
   * @example
   * [{\\"Content-Type\\":\\"application/json\\"}]
   */
  httpHeaders?: string;
  /**
   * @remarks
   * The latency for container probe initialization.
   * 
   * @example
   * 1
   */
  initialDelaySeconds?: number;
  /**
   * @remarks
   * The health check path.
   * 
   * @example
   * /
   */
  path?: string;
  /**
   * @remarks
   * The interval between container health checks.
   * 
   * @example
   * 1
   */
  periodSeconds?: number;
  /**
   * @remarks
   * The health check port.
   * 
   * @example
   * 9991
   */
  port?: number;
  /**
   * @remarks
   * The protocol that the container health check request uses.
   * 
   * @example
   * http
   */
  scheme?: string;
  /**
   * @remarks
   * The number of consecutive successful health checks required for a container to be considered as healthy.
   * 
   * @example
   * 1
   */
  successThreshold?: number;
  /**
   * @remarks
   * The timeout period of the container health check.
   * 
   * @example
   * 1
   */
  timeoutSeconds?: number;
  static names(): { [key: string]: string } {
    return {
      command: 'Command',
      failureThreshold: 'FailureThreshold',
      host: 'Host',
      httpHeaders: 'HttpHeaders',
      initialDelaySeconds: 'InitialDelaySeconds',
      path: 'Path',
      periodSeconds: 'PeriodSeconds',
      port: 'Port',
      scheme: 'Scheme',
      successThreshold: 'SuccessThreshold',
      timeoutSeconds: 'TimeoutSeconds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      command: 'string',
      failureThreshold: 'number',
      host: 'string',
      httpHeaders: 'string',
      initialDelaySeconds: 'number',
      path: 'string',
      periodSeconds: 'number',
      port: 'number',
      scheme: 'string',
      successThreshold: 'number',
      timeoutSeconds: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppVersionRequestContainers extends $tea.Model {
  /**
   * @remarks
   * The information about the Container Registry image.
   */
  ACRImageInfo?: CreateEdgeContainerAppVersionRequestContainersACRImageInfo;
  /**
   * @remarks
   * The arguments that are passed to the container startup command. Separate the parameters with spaces.
   * 
   * @example
   * -a
   */
  args?: string;
  /**
   * @remarks
   * The command that is used to start the container. Separate the arguments with spaces.
   * 
   * @example
   * nginx
   */
  command?: string;
  /**
   * @remarks
   * The environment variables. Separate the environment variables with commas (,).
   * 
   * @example
   * VITE_APP_TITLE=My App
   */
  envVariables?: string;
  /**
   * @remarks
   * The address of the image.
   * 
   * This parameter is required.
   * 
   * @example
   * registry-vpc.cn-shenzhen.aliyuncs.com/lihe****h/ea****ts_serv****am:3.**
   */
  image?: string;
  /**
   * @remarks
   * Specifies whether the image is a Container Registry image.
   * 
   * This parameter is required.
   * 
   * @example
   * false
   */
  isACRImage?: boolean;
  /**
   * @remarks
   * The name of the container. The name must be unique in the same container group.
   * 
   * This parameter is required.
   * 
   * @example
   * lxg-demo-er
   */
  name?: string;
  /**
   * @remarks
   * The command that is run before the container is started. Separate the arguments with spaces.
   * 
   * @example
   * sh poststart.sh "echo hello world"
   */
  postStart?: string;
  /**
   * @remarks
   * The command that is run before the container is stopped. Separate the arguments with spaces.
   * 
   * @example
   * sh prestop.sh "echo hello world"
   */
  preStop?: string;
  /**
   * @remarks
   * The content of the container health probe.
   * 
   * This parameter is required.
   */
  probeContent?: CreateEdgeContainerAppVersionRequestContainersProbeContent;
  /**
   * @remarks
   * The type of the probe. Valid values:
   * 
   * *   exec: the command type.
   * *   tcpSocket: the TCP probe type.
   * *   httpGet: the HTTP access type.
   * 
   * This parameter is required.
   * 
   * @example
   * exec
   */
  probeType?: string;
  /**
   * @remarks
   * The compute specification of the container. Valid values: 1C2G, 2C4G, 2C8G, 4C8G, 4C16G, 8C16G, and 8C32G.
   * 
   * This parameter is required.
   * 
   * @example
   * 1C2G
   */
  spec?: string;
  /**
   * @remarks
   * The storage capacity. Valid values: 0.5G, 10G, 20G, and 30G.
   * 
   * This parameter is required.
   * 
   * @example
   * 0.5G
   */
  storage?: string;
  static names(): { [key: string]: string } {
    return {
      ACRImageInfo: 'ACRImageInfo',
      args: 'Args',
      command: 'Command',
      envVariables: 'EnvVariables',
      image: 'Image',
      isACRImage: 'IsACRImage',
      name: 'Name',
      postStart: 'PostStart',
      preStop: 'PreStop',
      probeContent: 'ProbeContent',
      probeType: 'ProbeType',
      spec: 'Spec',
      storage: 'Storage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ACRImageInfo: CreateEdgeContainerAppVersionRequestContainersACRImageInfo,
      args: 'string',
      command: 'string',
      envVariables: 'string',
      image: 'string',
      isACRImage: 'boolean',
      name: 'string',
      postStart: 'string',
      preStop: 'string',
      probeContent: CreateEdgeContainerAppVersionRequestContainersProbeContent,
      probeType: 'string',
      spec: 'string',
      storage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRecordRequestAuthConf extends $tea.Model {
  /**
   * @remarks
   * The access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_cross_account, or when the SourceType is S3 and AuthType is private.
   * 
   * @example
   * u0Nkg5gBK*******QF5wvKMM504JUHt
   */
  accessKey?: string;
  /**
   * @remarks
   * The authentication type of the origin server. Different origins support different authentication types. The type of origin refers to the SourceType parameter in this operation. If the type of origin is OSS or S3, you must specify the authentication type of the origin. Valid values:
   * 
   * *   **public**: public read. Select this value when the origin type is OSS or S3 and the origin access is public read.
   * *   **private**: private read. Select this value when the origin type is S3 and the origin access is private read.
   * *   **private_same_account**: private read under the same account. Select this value when the origin type is OSS, the origins belong to the same Alibaba Cloud account, and the origins have private read access.
   * *   **private_cross_account**: private read cross accounts. Select this value when the origin type is OSS, the origins belong to different Alibaba Cloud accounts, and the origins have private read access.
   * 
   * @example
   * private
   */
  authType?: string;
  /**
   * @remarks
   * The region of the origin. If the origin type is S3, you must specify this value. You can get the region information from the official website of S3.
   * 
   * @example
   * us-east-1
   */
  region?: string;
  /**
   * @remarks
   * The secret access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_same_account, or when the SourceType is S3 and AuthType is private.
   * 
   * @example
   * VIxuvJSA2S03f******kp208dy5w7
   */
  secretKey?: string;
  /**
   * @remarks
   * The version of the signature algorithm. This parameter is required when the origin type is S3 and AuthType is private. The following two types are supported:
   * 
   * *   **v2**
   * *   **v4**
   * 
   * If you leave this parameter empty, the default value v4 is used.
   * 
   * @example
   * v4
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      authType: 'AuthType',
      region: 'Region',
      secretKey: 'SecretKey',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      authType: 'string',
      region: 'string',
      secretKey: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRecordRequestData extends $tea.Model {
  /**
   * @remarks
   * The encryption algorithm used for the record, specified within the range from 0 to 255. This parameter is required when you add CERT or SSHFP records.
   * 
   * @example
   * 1
   */
  algorithm?: number;
  /**
   * @remarks
   * The public key of the certificate. This parameter is required when you add CERT, SMIMEA, or TLSA records.
   * 
   * @example
   * dGVzdGFkYWxrcw==
   */
  certificate?: string;
  /**
   * @remarks
   * The public key fingerprint of the record. This parameter is required when you add a SSHFP record.
   * 
   * @example
   * abcdef1234567890
   */
  fingerprint?: string;
  /**
   * @remarks
   * The flag bit of the record. The Flag for a CAA record indicates its priority and how it is processed, specified within the range of 0 to 255. This parameter is required when you add a CAA record.
   * 
   * @example
   * 128
   */
  flag?: number;
  /**
   * @remarks
   * The public key identification for the record, specified within the range of 0 to 65,535. This parameter is required when you add a CAA record.
   * 
   * @example
   * 0
   */
  keyTag?: number;
  /**
   * @remarks
   * The algorithm policy used to match or validate the certificate, specified within the range 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
   * 
   * @example
   * 1
   */
  matchingType?: number;
  /**
   * @remarks
   * The port of the record, specified within the range of 0 to 65,535. This parameter is required when you add an SRV record.
   * 
   * @example
   * 0
   */
  port?: number;
  /**
   * @remarks
   * The priority of the record, specified within the range of 0 to 65,535. A smaller value indicates a higher priority. This parameter is required when you add MX, SRV, and URI records.
   * 
   * @example
   * 10
   */
  priority?: number;
  /**
   * @remarks
   * The type of certificate or public key, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
   * 
   * @example
   * 1
   */
  selector?: number;
  /**
   * @remarks
   * The label of the record. The Tag of a CAA record indicate its specific type and usage. This parameter is required when you add a CAA record. Valid values:
   * 
   * *   **issue**: indicates that a CA is authorized to issue a certificate for the domain name. This is usually followed by the domain name of the CA.
   * *   **issuewild**: indicates that a CA is authorized to issue a wildcard certificate (such as \\*.example.com) for the domain name.
   * *   **iodef**: specifies a URI to receive reports about CAA record violations.
   * 
   * @example
   * issue
   */
  tag?: string;
  /**
   * @remarks
   * The certificate type of the record (in CERT records), or the public key type (in SSHFP records). This parameter is required when you add CERT or SSHFP records.
   * 
   * @example
   * RSA
   */
  type?: number;
  /**
   * @remarks
   * The usage identifier of the record, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
   * 
   * @example
   * 1
   */
  usage?: number;
  /**
   * @remarks
   * Record value or part of the record content. This parameter is required when you add A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI records. It has different meanings based on types of records:
   * 
   * *   **A/AAAA**: the IP address(es). Separate IP addresses with commas (,). You must have at least one IPv4 address.
   * *   **CNAME**: the target domain name.
   * *   **NS**: the name servers for the domain name.
   * *   **MX**: a valid domain name of the target mail server.
   * *   **TXT**: a valid text string.
   * *   **CAA**: a valid domain name of the certificate authority.
   * *   **SRV**: a valid domain name of the target host.
   * *   **URI**: a valid URI string.
   * 
   * @example
   * example.com
   */
  value?: string;
  /**
   * @remarks
   * The weight of the record, specified within the range of 0 to 65,535. This parameter is required when you add SRV or URI records.
   * 
   * @example
   * 0
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      algorithm: 'Algorithm',
      certificate: 'Certificate',
      fingerprint: 'Fingerprint',
      flag: 'Flag',
      keyTag: 'KeyTag',
      matchingType: 'MatchingType',
      port: 'Port',
      priority: 'Priority',
      selector: 'Selector',
      tag: 'Tag',
      type: 'Type',
      usage: 'Usage',
      value: 'Value',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      algorithm: 'number',
      certificate: 'string',
      fingerprint: 'string',
      flag: 'number',
      keyTag: 'number',
      matchingType: 'number',
      port: 'number',
      priority: 'number',
      selector: 'number',
      tag: 'string',
      type: 'number',
      usage: 'number',
      value: 'string',
      weight: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduledPreloadExecutionsRequestExecutions extends $tea.Model {
  /**
   * @remarks
   * The end time of the prefetch plans.
   * 
   * @example
   * 2024-06-04T02:02:09Z
   */
  endTime?: string;
  /**
   * @remarks
   * The time interval between each batch execution. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 30
   */
  interval?: number;
  /**
   * @remarks
   * The number of URLs prefetched in each batch.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  sliceLen?: number;
  /**
   * @remarks
   * The start time of the prefetch plans.
   * 
   * @example
   * 2024-06-03T16:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      interval: 'Interval',
      sliceLen: 'SliceLen',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      interval: 'number',
      sliceLen: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduledPreloadExecutionsResponseBodyFailedExecutions extends $tea.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 15685865xxx14622
   */
  aliUid?: string;
  /**
   * @remarks
   * The end time of the prefetch plans.
   * 
   * @example
   * 2024-06-03T02:43:35Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the prefetch plan.
   * 
   * @example
   * 66599bd7397885b43804901c
   */
  id?: string;
  /**
   * @remarks
   * The time interval between each batch execution. Unit: seconds.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The ID of the prefetch task.
   * 
   * @example
   * 665d3af3621bccf3fe29e1a4
   */
  jobId?: string;
  /**
   * @remarks
   * The number of URLs prefetched in each batch.
   * 
   * @example
   * 10
   */
  sliceLen?: number;
  /**
   * @remarks
   * The start time of the prefetch plans.
   * 
   * @example
   * 2024-06-02T02:43:35Z
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the prefetch plan. Valid values:
   * 
   * *   **waiting**
   * *   **running**
   * *   **finished**
   * *   **failed**
   * *   **stopped**
   * 
   * @example
   * running
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      endTime: 'EndTime',
      id: 'Id',
      interval: 'Interval',
      jobId: 'JobId',
      sliceLen: 'SliceLen',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'string',
      endTime: 'string',
      id: 'string',
      interval: 'number',
      jobId: 'string',
      sliceLen: 'number',
      startTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduledPreloadExecutionsResponseBodySuccessExecutions extends $tea.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 15685865xxx14622
   */
  aliUid?: string;
  /**
   * @remarks
   * The end time of the prefetch plans.
   * 
   * @example
   * 2024-06-03T02:43:35Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the prefetch plan.
   * 
   * @example
   * 66599bd7397885b43804901c
   */
  id?: string;
  /**
   * @remarks
   * The time interval between each batch execution. Unit: seconds.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The ID of the prefetch task.
   * 
   * @example
   * 665d3af3621bccf3fe29e1a4
   */
  jobId?: string;
  /**
   * @remarks
   * The number of URLs prefetched in each batch.
   * 
   * @example
   * 10
   */
  sliceLen?: number;
  /**
   * @remarks
   * The start time of the prefetch plans.
   * 
   * @example
   * 2024-06-02T02:43:35Z
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the prefetch plan. Valid values:
   * 
   * *   **waiting**
   * *   **running**
   * *   **finished**
   * *   **failed**
   * *   **stopped**
   * 
   * @example
   * failed
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      endTime: 'EndTime',
      id: 'Id',
      interval: 'Interval',
      jobId: 'JobId',
      sliceLen: 'SliceLen',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'string',
      endTime: 'string',
      id: 'string',
      interval: 'number',
      jobId: 'string',
      sliceLen: 'number',
      startTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteDeliveryTaskRequestHttpDeliveryStandardAuthParam extends $tea.Model {
  /**
   * @remarks
   * The validity period of the signature.
   * 
   * >  The value must be greater than 0. We recommend that you specify a value that is greater than 300.
   * 
   * @example
   * 300
   */
  expiredTime?: number;
  /**
   * @remarks
   * The private key.
   * 
   * @example
   * ***
   */
  privateKey?: string;
  /**
   * @remarks
   * The URI path for server authentication.
   * 
   * @example
   * v1/log/upload
   */
  urlPath?: string;
  static names(): { [key: string]: string } {
    return {
      expiredTime: 'ExpiredTime',
      privateKey: 'PrivateKey',
      urlPath: 'UrlPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expiredTime: 'number',
      privateKey: 'string',
      urlPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteDeliveryTaskRequestHttpDelivery extends $tea.Model {
  /**
   * @remarks
   * The compression method. By default, data is not compressed.
   * 
   * @example
   * gzip
   */
  compress?: string;
  /**
   * @remarks
   * The address of the HTTP server.
   * 
   * @example
   * http://xxx.aliyun.com/v1/log/upload
   */
  destUrl?: string;
  /**
   * @remarks
   * The custom headers.
   */
  headerParam?: { [key: string]: HttpDeliveryHeaderParamValue };
  /**
   * @remarks
   * The prefix of the log delivery package.
   * 
   * @example
   * cdnVersion:1.0
   */
  logBodyPrefix?: string;
  /**
   * @remarks
   * The suffix of the log delivery package.
   * 
   * @example
   * cdnVersion:1.0
   */
  logBodySuffix?: string;
  /**
   * @remarks
   * The maximum size of data for each delivery. Unit: MB.
   * 
   * @example
   * 5
   */
  maxBatchMB?: number;
  /**
   * @remarks
   * The maximum number of entries for each delivery.
   * 
   * @example
   * 1000
   */
  maxBatchSize?: number;
  /**
   * @remarks
   * The maximum number of retries.
   * 
   * @example
   * 3
   */
  maxRetry?: number;
  /**
   * @remarks
   * The custom query parameters.
   */
  queryParam?: { [key: string]: HttpDeliveryQueryParamValue };
  /**
   * @remarks
   * Specifies whether to use server authentication.
   * 
   * @example
   * true
   */
  standardAuthOn?: boolean;
  /**
   * @remarks
   * The authentication configurations.
   */
  standardAuthParam?: CreateSiteDeliveryTaskRequestHttpDeliveryStandardAuthParam;
  /**
   * @remarks
   * The timeout period. Unit: seconds.
   * 
   * @example
   * 10
   */
  transformTimeout?: number;
  static names(): { [key: string]: string } {
    return {
      compress: 'Compress',
      destUrl: 'DestUrl',
      headerParam: 'HeaderParam',
      logBodyPrefix: 'LogBodyPrefix',
      logBodySuffix: 'LogBodySuffix',
      maxBatchMB: 'MaxBatchMB',
      maxBatchSize: 'MaxBatchSize',
      maxRetry: 'MaxRetry',
      queryParam: 'QueryParam',
      standardAuthOn: 'StandardAuthOn',
      standardAuthParam: 'StandardAuthParam',
      transformTimeout: 'TransformTimeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      compress: 'string',
      destUrl: 'string',
      headerParam: { 'type': 'map', 'keyType': 'string', 'valueType': HttpDeliveryHeaderParamValue },
      logBodyPrefix: 'string',
      logBodySuffix: 'string',
      maxBatchMB: 'number',
      maxBatchSize: 'number',
      maxRetry: 'number',
      queryParam: { 'type': 'map', 'keyType': 'string', 'valueType': HttpDeliveryQueryParamValue },
      standardAuthOn: 'boolean',
      standardAuthParam: CreateSiteDeliveryTaskRequestHttpDeliveryStandardAuthParam,
      transformTimeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteDeliveryTaskRequestKafkaDelivery extends $tea.Model {
  /**
   * @remarks
   * The load balancing method.
   * 
   * @example
   * kafka.LeastBytes
   */
  balancer?: string;
  /**
   * @remarks
   * The brokers.
   */
  brokers?: string[];
  /**
   * @remarks
   * The compression method.
   * 
   * @example
   * gzip
   */
  compress?: string;
  /**
   * @remarks
   * The encryption method.
   * 
   * @example
   * plain
   */
  machanismType?: string;
  /**
   * @remarks
   * The password.
   * 
   * @example
   * ***
   */
  password?: string;
  /**
   * @remarks
   * The topic.
   * 
   * @example
   * dqc_test2
   */
  topic?: string;
  /**
   * @remarks
   * Specifies whether to enable authentication.
   * 
   * @example
   * true
   */
  userAuth?: boolean;
  /**
   * @remarks
   * The username.
   * 
   * @example
   * xxx
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      balancer: 'Balancer',
      brokers: 'Brokers',
      compress: 'Compress',
      machanismType: 'MachanismType',
      password: 'Password',
      topic: 'Topic',
      userAuth: 'UserAuth',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      balancer: 'string',
      brokers: { 'type': 'array', 'itemType': 'string' },
      compress: 'string',
      machanismType: 'string',
      password: 'string',
      topic: 'string',
      userAuth: 'boolean',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteDeliveryTaskRequestOssDelivery extends $tea.Model {
  /**
   * @remarks
   * The ID of your Alibaba Cloud account.
   * 
   * @example
   * 1234***
   */
  aliuid?: string;
  /**
   * @remarks
   * The name of the OSS bucket.
   * 
   * @example
   * test_rlog
   */
  bucketName?: string;
  /**
   * @remarks
   * The prefix of the path in which you want to store logs.
   * 
   * @example
   * logriver-test/log
   */
  prefixPath?: string;
  /**
   * @remarks
   * The region in which the bucket is located.
   * 
   * @example
   * cn-beijing
   */
  region?: string;
  static names(): { [key: string]: string } {
    return {
      aliuid: 'Aliuid',
      bucketName: 'BucketName',
      prefixPath: 'PrefixPath',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliuid: 'string',
      bucketName: 'string',
      prefixPath: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteDeliveryTaskRequestS3Delivery extends $tea.Model {
  /**
   * @remarks
   * The access key ID of your Amazon S3 account.
   * 
   * @example
   * LTAIKh***
   */
  accessKey?: string;
  /**
   * @remarks
   * The directory in the bucket.
   * 
   * @example
   * logriver-test/log
   */
  bucketPath?: string;
  /**
   * @remarks
   * The endpoint. This parameter is required when the S3Cmpt parameter is set to true.
   * 
   * @example
   * https://s3.oss-cn-hangzhou.aliyuncs.com
   */
  endpoint?: string;
  /**
   * @remarks
   * The prefix of the path in which you want to store logs.
   * 
   * @example
   * logriver-test/log
   */
  prefixPath?: string;
  /**
   * @remarks
   * The region ID of the service.
   * 
   * @example
   * cn-beijing
   */
  region?: string;
  /**
   * @remarks
   * Specifies whether the service is compatible with Amazon S3.
   * 
   * @example
   * true
   */
  s3Cmpt?: boolean;
  /**
   * @remarks
   * The secret access key of your Amazon S3 account.
   * 
   * @example
   * LDSIKh***
   */
  secretKey?: string;
  serverSideEncryption?: boolean;
  vertifyType?: string;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      bucketPath: 'BucketPath',
      endpoint: 'Endpoint',
      prefixPath: 'PrefixPath',
      region: 'Region',
      s3Cmpt: 'S3Cmpt',
      secretKey: 'SecretKey',
      serverSideEncryption: 'ServerSideEncryption',
      vertifyType: 'VertifyType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      bucketPath: 'string',
      endpoint: 'string',
      prefixPath: 'string',
      region: 'string',
      s3Cmpt: 'boolean',
      secretKey: 'string',
      serverSideEncryption: 'boolean',
      vertifyType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteDeliveryTaskRequestSlsDelivery extends $tea.Model {
  /**
   * @remarks
   * The name of the Logstore.
   * 
   * @example
   * accesslog-test
   */
  SLSLogStore?: string;
  /**
   * @remarks
   * The name of the SLS project.
   * 
   * @example
   * dcdn-test20240417
   */
  SLSProject?: string;
  /**
   * @remarks
   * The region in which the SLS project resides.
   * 
   * @example
   * cn-hangzhou
   */
  SLSRegion?: string;
  static names(): { [key: string]: string } {
    return {
      SLSLogStore: 'SLSLogStore',
      SLSProject: 'SLSProject',
      SLSRegion: 'SLSRegion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      SLSLogStore: 'string',
      SLSProject: 'string',
      SLSRegion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestCacheReserve extends $tea.Model {
  enable?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestCacheRules extends $tea.Model {
  additionalCacheablePorts?: string;
  browserCacheMode?: string;
  browserCacheTtl?: string;
  bypassCache?: string;
  cacheDeceptionArmor?: string;
  cacheReserveEligibility?: string;
  checkPresenceCookie?: string;
  checkPresenceHeader?: string;
  edgeCacheMode?: string;
  edgeCacheTtl?: string;
  edgeStatusCodeCacheTtl?: string;
  includeCookie?: string;
  includeHeader?: string;
  queryString?: string;
  queryStringMode?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  serveStale?: string;
  sortQueryStringForCache?: string;
  userDeviceType?: string;
  userGeo?: string;
  userLanguage?: string;
  static names(): { [key: string]: string } {
    return {
      additionalCacheablePorts: 'AdditionalCacheablePorts',
      browserCacheMode: 'BrowserCacheMode',
      browserCacheTtl: 'BrowserCacheTtl',
      bypassCache: 'BypassCache',
      cacheDeceptionArmor: 'CacheDeceptionArmor',
      cacheReserveEligibility: 'CacheReserveEligibility',
      checkPresenceCookie: 'CheckPresenceCookie',
      checkPresenceHeader: 'CheckPresenceHeader',
      edgeCacheMode: 'EdgeCacheMode',
      edgeCacheTtl: 'EdgeCacheTtl',
      edgeStatusCodeCacheTtl: 'EdgeStatusCodeCacheTtl',
      includeCookie: 'IncludeCookie',
      includeHeader: 'IncludeHeader',
      queryString: 'QueryString',
      queryStringMode: 'QueryStringMode',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      serveStale: 'ServeStale',
      sortQueryStringForCache: 'SortQueryStringForCache',
      userDeviceType: 'UserDeviceType',
      userGeo: 'UserGeo',
      userLanguage: 'UserLanguage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      additionalCacheablePorts: 'string',
      browserCacheMode: 'string',
      browserCacheTtl: 'string',
      bypassCache: 'string',
      cacheDeceptionArmor: 'string',
      cacheReserveEligibility: 'string',
      checkPresenceCookie: 'string',
      checkPresenceHeader: 'string',
      edgeCacheMode: 'string',
      edgeCacheTtl: 'string',
      edgeStatusCodeCacheTtl: 'string',
      includeCookie: 'string',
      includeHeader: 'string',
      queryString: 'string',
      queryStringMode: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      serveStale: 'string',
      sortQueryStringForCache: 'string',
      userDeviceType: 'string',
      userGeo: 'string',
      userLanguage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestCacheTags extends $tea.Model {
  caseInsensitive?: string;
  tagName?: string;
  static names(): { [key: string]: string } {
    return {
      caseInsensitive: 'CaseInsensitive',
      tagName: 'TagName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      caseInsensitive: 'string',
      tagName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestCnameFlattening extends $tea.Model {
  flattenMode?: string;
  static names(): { [key: string]: string } {
    return {
      flattenMode: 'FlattenMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flattenMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestCompressionRules extends $tea.Model {
  brotli?: string;
  gzip?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      brotli: 'Brotli',
      gzip: 'Gzip',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      brotli: 'string',
      gzip: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestCrossBorderOptimization extends $tea.Model {
  enable?: string;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestDevelopmentMode extends $tea.Model {
  enable?: string;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification extends $tea.Model {
  name?: string;
  operation?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      operation: 'Operation',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      operation: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestHttpRequestHeaderModificationRules extends $tea.Model {
  requestHeaderModification?: CreateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification[];
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      requestHeaderModification: 'RequestHeaderModification',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestHeaderModification: { 'type': 'array', 'itemType': CreateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification },
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification extends $tea.Model {
  name?: string;
  operation?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      operation: 'Operation',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      operation: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestHttpResponseHeaderModificationRules extends $tea.Model {
  responseHeaderModification?: CreateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification[];
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      responseHeaderModification: 'ResponseHeaderModification',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      responseHeaderModification: { 'type': 'array', 'itemType': CreateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification },
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestHttpsApplicationConfiguration extends $tea.Model {
  altSvc?: string;
  altSvcClear?: string;
  altSvcMa?: string;
  altSvcPersist?: string;
  hsts?: string;
  hstsIncludeSubdomains?: string;
  hstsMaxAge?: string;
  hstsPreload?: string;
  httpsForce?: string;
  httpsForceCode?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      altSvc: 'AltSvc',
      altSvcClear: 'AltSvcClear',
      altSvcMa: 'AltSvcMa',
      altSvcPersist: 'AltSvcPersist',
      hsts: 'Hsts',
      hstsIncludeSubdomains: 'HstsIncludeSubdomains',
      hstsMaxAge: 'HstsMaxAge',
      hstsPreload: 'HstsPreload',
      httpsForce: 'HttpsForce',
      httpsForceCode: 'HttpsForceCode',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      altSvc: 'string',
      altSvcClear: 'string',
      altSvcMa: 'string',
      altSvcPersist: 'string',
      hsts: 'string',
      hstsIncludeSubdomains: 'string',
      hstsMaxAge: 'string',
      hstsPreload: 'string',
      httpsForce: 'string',
      httpsForceCode: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestHttpsBasicConfiguration extends $tea.Model {
  ciphersuite?: string;
  ciphersuiteGroup?: string;
  http2?: string;
  http3?: string;
  https?: string;
  ocspStapling?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  tls10?: string;
  tls11?: string;
  tls12?: string;
  tls13?: string;
  static names(): { [key: string]: string } {
    return {
      ciphersuite: 'Ciphersuite',
      ciphersuiteGroup: 'CiphersuiteGroup',
      http2: 'Http2',
      http3: 'Http3',
      https: 'Https',
      ocspStapling: 'OcspStapling',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      tls10: 'Tls10',
      tls11: 'Tls11',
      tls12: 'Tls12',
      tls13: 'Tls13',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ciphersuite: 'string',
      ciphersuiteGroup: 'string',
      http2: 'string',
      http3: 'string',
      https: 'string',
      ocspStapling: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      tls10: 'string',
      tls11: 'string',
      tls12: 'string',
      tls13: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestImageTransform extends $tea.Model {
  enable?: string;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestIpv6 extends $tea.Model {
  enable?: string;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestManagedTransforms extends $tea.Model {
  addClientGeolocationHeaders?: string;
  addRealClientIpHeader?: string;
  static names(): { [key: string]: string } {
    return {
      addClientGeolocationHeaders: 'AddClientGeolocationHeaders',
      addRealClientIpHeader: 'AddRealClientIpHeader',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addClientGeolocationHeaders: 'string',
      addRealClientIpHeader: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestNetworkOptimization extends $tea.Model {
  grpc?: string;
  http2Origin?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  smartRouting?: string;
  uploadMaxFilesize?: string;
  websocket?: string;
  static names(): { [key: string]: string } {
    return {
      grpc: 'Grpc',
      http2Origin: 'Http2Origin',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      smartRouting: 'SmartRouting',
      uploadMaxFilesize: 'UploadMaxFilesize',
      websocket: 'Websocket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      grpc: 'string',
      http2Origin: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      smartRouting: 'string',
      uploadMaxFilesize: 'string',
      websocket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestOriginProtection extends $tea.Model {
  enable?: string;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestOriginRules extends $tea.Model {
  dnsRecord?: string;
  originHost?: string;
  originHttpPort?: string;
  originHttpsPort?: string;
  originScheme?: string;
  originSni?: string;
  range?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      dnsRecord: 'DnsRecord',
      originHost: 'OriginHost',
      originHttpPort: 'OriginHttpPort',
      originHttpsPort: 'OriginHttpsPort',
      originScheme: 'OriginScheme',
      originSni: 'OriginSni',
      range: 'Range',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnsRecord: 'string',
      originHost: 'string',
      originHttpPort: 'string',
      originHttpsPort: 'string',
      originScheme: 'string',
      originSni: 'string',
      range: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestRedirectRules extends $tea.Model {
  reserveQueryString?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  statusCode?: string;
  targetUrl?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      reserveQueryString: 'ReserveQueryString',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      statusCode: 'StatusCode',
      targetUrl: 'TargetUrl',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reserveQueryString: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      statusCode: 'string',
      targetUrl: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestRewriteUrlRules extends $tea.Model {
  queryString?: string;
  rewriteQueryStringType?: string;
  rewriteUriType?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  uri?: string;
  static names(): { [key: string]: string } {
    return {
      queryString: 'QueryString',
      rewriteQueryStringType: 'RewriteQueryStringType',
      rewriteUriType: 'RewriteUriType',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      uri: 'Uri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      queryString: 'string',
      rewriteQueryStringType: 'string',
      rewriteUriType: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      uri: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestSeoBypass extends $tea.Model {
  enable?: string;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestSiteNameExclusive extends $tea.Model {
  enable?: string;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestSitePause extends $tea.Model {
  paused?: string;
  static names(): { [key: string]: string } {
    return {
      paused: 'Paused',
    };
  }

  static types(): { [key: string]: any } {
    return {
      paused: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionRequestTieredCache extends $tea.Model {
  cacheArchitectureMode?: string;
  static names(): { [key: string]: string } {
    return {
      cacheArchitectureMode: 'CacheArchitectureMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheArchitectureMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsCacheReserve extends $tea.Model {
  configId?: number;
  enable?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsCacheRules extends $tea.Model {
  additionalCacheablePorts?: string;
  browserCacheMode?: string;
  browserCacheTtl?: string;
  bypassCache?: string;
  cacheDeceptionArmor?: string;
  cacheReserveEligibility?: string;
  checkPresenceCookie?: string;
  checkPresenceHeader?: string;
  configId?: number;
  edgeCacheMode?: string;
  edgeCacheTtl?: string;
  edgeStatusCodeCacheTtl?: string;
  includeCookie?: string;
  includeHeader?: string;
  queryString?: string;
  queryStringMode?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  sequence?: string;
  serveStale?: string;
  sortQueryStringForCache?: string;
  userDeviceType?: string;
  userGeo?: string;
  userLanguage?: string;
  static names(): { [key: string]: string } {
    return {
      additionalCacheablePorts: 'AdditionalCacheablePorts',
      browserCacheMode: 'BrowserCacheMode',
      browserCacheTtl: 'BrowserCacheTtl',
      bypassCache: 'BypassCache',
      cacheDeceptionArmor: 'CacheDeceptionArmor',
      cacheReserveEligibility: 'CacheReserveEligibility',
      checkPresenceCookie: 'CheckPresenceCookie',
      checkPresenceHeader: 'CheckPresenceHeader',
      configId: 'ConfigId',
      edgeCacheMode: 'EdgeCacheMode',
      edgeCacheTtl: 'EdgeCacheTtl',
      edgeStatusCodeCacheTtl: 'EdgeStatusCodeCacheTtl',
      includeCookie: 'IncludeCookie',
      includeHeader: 'IncludeHeader',
      queryString: 'QueryString',
      queryStringMode: 'QueryStringMode',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      serveStale: 'ServeStale',
      sortQueryStringForCache: 'SortQueryStringForCache',
      userDeviceType: 'UserDeviceType',
      userGeo: 'UserGeo',
      userLanguage: 'UserLanguage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      additionalCacheablePorts: 'string',
      browserCacheMode: 'string',
      browserCacheTtl: 'string',
      bypassCache: 'string',
      cacheDeceptionArmor: 'string',
      cacheReserveEligibility: 'string',
      checkPresenceCookie: 'string',
      checkPresenceHeader: 'string',
      configId: 'number',
      edgeCacheMode: 'string',
      edgeCacheTtl: 'string',
      edgeStatusCodeCacheTtl: 'string',
      includeCookie: 'string',
      includeHeader: 'string',
      queryString: 'string',
      queryStringMode: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'string',
      serveStale: 'string',
      sortQueryStringForCache: 'string',
      userDeviceType: 'string',
      userGeo: 'string',
      userLanguage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsCacheTags extends $tea.Model {
  caseInsensitive?: string;
  configId?: number;
  sequence?: string;
  tagName?: string;
  static names(): { [key: string]: string } {
    return {
      caseInsensitive: 'CaseInsensitive',
      configId: 'ConfigId',
      sequence: 'Sequence',
      tagName: 'TagName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      caseInsensitive: 'string',
      configId: 'number',
      sequence: 'string',
      tagName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsCnameFlattening extends $tea.Model {
  configId?: number;
  flattenMode?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      flattenMode: 'FlattenMode',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      flattenMode: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsCompressionRules extends $tea.Model {
  brotli?: string;
  configId?: number;
  gzip?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      brotli: 'Brotli',
      configId: 'ConfigId',
      gzip: 'Gzip',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      brotli: 'string',
      configId: 'number',
      gzip: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsCrossBorderOptimization extends $tea.Model {
  configId?: number;
  enable?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsDevelopmentMode extends $tea.Model {
  configId?: number;
  enable?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification extends $tea.Model {
  name?: string;
  operation?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      operation: 'Operation',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      operation: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRules extends $tea.Model {
  configId?: number;
  requestHeaderModification?: CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification[];
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      requestHeaderModification: 'RequestHeaderModification',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      requestHeaderModification: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification },
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification extends $tea.Model {
  name?: string;
  operation?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      operation: 'Operation',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      operation: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRules extends $tea.Model {
  configId?: number;
  responseHeaderModification?: CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification[];
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      responseHeaderModification: 'ResponseHeaderModification',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      responseHeaderModification: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification },
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsHttpsApplicationConfiguration extends $tea.Model {
  altSvc?: string;
  altSvcClear?: string;
  altSvcMa?: string;
  altSvcPersist?: string;
  configId?: number;
  hsts?: string;
  hstsIncludeSubdomains?: string;
  hstsMaxAge?: string;
  hstsPreload?: string;
  httpsForce?: string;
  httpsForceCode?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      altSvc: 'AltSvc',
      altSvcClear: 'AltSvcClear',
      altSvcMa: 'AltSvcMa',
      altSvcPersist: 'AltSvcPersist',
      configId: 'ConfigId',
      hsts: 'Hsts',
      hstsIncludeSubdomains: 'HstsIncludeSubdomains',
      hstsMaxAge: 'HstsMaxAge',
      hstsPreload: 'HstsPreload',
      httpsForce: 'HttpsForce',
      httpsForceCode: 'HttpsForceCode',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      altSvc: 'string',
      altSvcClear: 'string',
      altSvcMa: 'string',
      altSvcPersist: 'string',
      configId: 'number',
      hsts: 'string',
      hstsIncludeSubdomains: 'string',
      hstsMaxAge: 'string',
      hstsPreload: 'string',
      httpsForce: 'string',
      httpsForceCode: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsHttpsBasicConfiguration extends $tea.Model {
  ciphersuite?: string;
  ciphersuiteGroup?: string;
  configId?: number;
  http2?: string;
  http3?: string;
  https?: string;
  ocspStapling?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  sequence?: string;
  tls10?: string;
  tls11?: string;
  tls12?: string;
  tls13?: string;
  static names(): { [key: string]: string } {
    return {
      ciphersuite: 'Ciphersuite',
      ciphersuiteGroup: 'CiphersuiteGroup',
      configId: 'ConfigId',
      http2: 'Http2',
      http3: 'Http3',
      https: 'Https',
      ocspStapling: 'OcspStapling',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      tls10: 'Tls10',
      tls11: 'Tls11',
      tls12: 'Tls12',
      tls13: 'Tls13',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ciphersuite: 'string',
      ciphersuiteGroup: 'string',
      configId: 'number',
      http2: 'string',
      http3: 'string',
      https: 'string',
      ocspStapling: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'string',
      tls10: 'string',
      tls11: 'string',
      tls12: 'string',
      tls13: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsImageTransform extends $tea.Model {
  configId?: number;
  enable?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsIpv6 extends $tea.Model {
  configId?: number;
  enable?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsManagedTransforms extends $tea.Model {
  addClientGeolocationHeaders?: string;
  addRealClientIpHeader?: string;
  configId?: number;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      addClientGeolocationHeaders: 'AddClientGeolocationHeaders',
      addRealClientIpHeader: 'AddRealClientIpHeader',
      configId: 'ConfigId',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addClientGeolocationHeaders: 'string',
      addRealClientIpHeader: 'string',
      configId: 'number',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsNetworkOptimization extends $tea.Model {
  configId?: number;
  grpc?: string;
  http2Origin?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  sequence?: string;
  smartRouting?: string;
  uploadMaxFilesize?: string;
  websocket?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      grpc: 'Grpc',
      http2Origin: 'Http2Origin',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      smartRouting: 'SmartRouting',
      uploadMaxFilesize: 'UploadMaxFilesize',
      websocket: 'Websocket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      grpc: 'string',
      http2Origin: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'string',
      smartRouting: 'string',
      uploadMaxFilesize: 'string',
      websocket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsOriginRules extends $tea.Model {
  configId?: number;
  dnsRecord?: string;
  originHost?: string;
  originHttpPort?: string;
  originHttpsPort?: string;
  originScheme?: string;
  originSni?: string;
  range?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      dnsRecord: 'DnsRecord',
      originHost: 'OriginHost',
      originHttpPort: 'OriginHttpPort',
      originHttpsPort: 'OriginHttpsPort',
      originScheme: 'OriginScheme',
      originSni: 'OriginSni',
      range: 'Range',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      dnsRecord: 'string',
      originHost: 'string',
      originHttpPort: 'string',
      originHttpsPort: 'string',
      originScheme: 'string',
      originSni: 'string',
      range: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsRedirectRules extends $tea.Model {
  configId?: number;
  reserveQueryString?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  sequence?: string;
  statusCode?: string;
  targetUrl?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      reserveQueryString: 'ReserveQueryString',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      statusCode: 'StatusCode',
      targetUrl: 'TargetUrl',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      reserveQueryString: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'string',
      statusCode: 'string',
      targetUrl: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsRewriteUrlRules extends $tea.Model {
  configId?: number;
  queryString?: string;
  rewriteQueryStringType?: string;
  rewriteUriType?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  sequence?: string;
  uri?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      queryString: 'QueryString',
      rewriteQueryStringType: 'RewriteQueryStringType',
      rewriteUriType: 'RewriteUriType',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      uri: 'Uri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      queryString: 'string',
      rewriteQueryStringType: 'string',
      rewriteUriType: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'string',
      uri: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsSeoBypass extends $tea.Model {
  configId?: number;
  enable?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsSiteNameExclusive extends $tea.Model {
  configId?: number;
  enable?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsSitePause extends $tea.Model {
  configId?: number;
  paused?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      paused: 'Paused',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      paused: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigsTieredCache extends $tea.Model {
  cacheArchitectureMode?: string;
  configId?: number;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      cacheArchitectureMode: 'CacheArchitectureMode',
      configId: 'ConfigId',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheArchitectureMode: 'string',
      configId: 'number',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteFunctionResponseBodyConfigs extends $tea.Model {
  cacheReserve?: CreateSiteFunctionResponseBodyConfigsCacheReserve[];
  cacheRules?: CreateSiteFunctionResponseBodyConfigsCacheRules[];
  cacheTags?: CreateSiteFunctionResponseBodyConfigsCacheTags[];
  cnameFlattening?: CreateSiteFunctionResponseBodyConfigsCnameFlattening[];
  compressionRules?: CreateSiteFunctionResponseBodyConfigsCompressionRules[];
  crossBorderOptimization?: CreateSiteFunctionResponseBodyConfigsCrossBorderOptimization[];
  developmentMode?: CreateSiteFunctionResponseBodyConfigsDevelopmentMode[];
  httpRequestHeaderModificationRules?: CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRules[];
  httpResponseHeaderModificationRules?: CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRules[];
  httpsApplicationConfiguration?: CreateSiteFunctionResponseBodyConfigsHttpsApplicationConfiguration[];
  httpsBasicConfiguration?: CreateSiteFunctionResponseBodyConfigsHttpsBasicConfiguration[];
  imageTransform?: CreateSiteFunctionResponseBodyConfigsImageTransform[];
  ipv6?: CreateSiteFunctionResponseBodyConfigsIpv6[];
  managedTransforms?: CreateSiteFunctionResponseBodyConfigsManagedTransforms[];
  networkOptimization?: CreateSiteFunctionResponseBodyConfigsNetworkOptimization[];
  originRules?: CreateSiteFunctionResponseBodyConfigsOriginRules[];
  redirectRules?: CreateSiteFunctionResponseBodyConfigsRedirectRules[];
  rewriteUrlRules?: CreateSiteFunctionResponseBodyConfigsRewriteUrlRules[];
  seoBypass?: CreateSiteFunctionResponseBodyConfigsSeoBypass[];
  siteNameExclusive?: CreateSiteFunctionResponseBodyConfigsSiteNameExclusive[];
  sitePause?: CreateSiteFunctionResponseBodyConfigsSitePause[];
  tieredCache?: CreateSiteFunctionResponseBodyConfigsTieredCache[];
  static names(): { [key: string]: string } {
    return {
      cacheReserve: 'CacheReserve',
      cacheRules: 'CacheRules',
      cacheTags: 'CacheTags',
      cnameFlattening: 'CnameFlattening',
      compressionRules: 'CompressionRules',
      crossBorderOptimization: 'CrossBorderOptimization',
      developmentMode: 'DevelopmentMode',
      httpRequestHeaderModificationRules: 'HttpRequestHeaderModificationRules',
      httpResponseHeaderModificationRules: 'HttpResponseHeaderModificationRules',
      httpsApplicationConfiguration: 'HttpsApplicationConfiguration',
      httpsBasicConfiguration: 'HttpsBasicConfiguration',
      imageTransform: 'ImageTransform',
      ipv6: 'Ipv6',
      managedTransforms: 'ManagedTransforms',
      networkOptimization: 'NetworkOptimization',
      originRules: 'OriginRules',
      redirectRules: 'RedirectRules',
      rewriteUrlRules: 'RewriteUrlRules',
      seoBypass: 'SeoBypass',
      siteNameExclusive: 'SiteNameExclusive',
      sitePause: 'SitePause',
      tieredCache: 'TieredCache',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheReserve: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsCacheReserve },
      cacheRules: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsCacheRules },
      cacheTags: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsCacheTags },
      cnameFlattening: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsCnameFlattening },
      compressionRules: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsCompressionRules },
      crossBorderOptimization: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsCrossBorderOptimization },
      developmentMode: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsDevelopmentMode },
      httpRequestHeaderModificationRules: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRules },
      httpResponseHeaderModificationRules: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRules },
      httpsApplicationConfiguration: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsHttpsApplicationConfiguration },
      httpsBasicConfiguration: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsHttpsBasicConfiguration },
      imageTransform: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsImageTransform },
      ipv6: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsIpv6 },
      managedTransforms: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsManagedTransforms },
      networkOptimization: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsNetworkOptimization },
      originRules: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsOriginRules },
      redirectRules: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsRedirectRules },
      rewriteUrlRules: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsRewriteUrlRules },
      seoBypass: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsSeoBypass },
      siteNameExclusive: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsSiteNameExclusive },
      sitePause: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsSitePause },
      tieredCache: { 'type': 'array', 'itemType': CreateSiteFunctionResponseBodyConfigsTieredCache },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserDeliveryTaskRequestHttpDeliveryStandardAuthParam extends $tea.Model {
  /**
   * @remarks
   * The validity period of the signature.
   * 
   * @example
   * 300
   */
  expiredTime?: number;
  /**
   * @remarks
   * The private key.
   * 
   * @example
   * xxxx
   */
  privateKey?: string;
  /**
   * @remarks
   * The URL path.
   * 
   * @example
   * v1/log/upload
   */
  urlPath?: string;
  static names(): { [key: string]: string } {
    return {
      expiredTime: 'ExpiredTime',
      privateKey: 'PrivateKey',
      urlPath: 'UrlPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expiredTime: 'number',
      privateKey: 'string',
      urlPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserDeliveryTaskRequestHttpDelivery extends $tea.Model {
  /**
   * @remarks
   * The compression method.
   * 
   * @example
   * gzip
   */
  compress?: string;
  /**
   * @remarks
   * The address of the HTTP server.
   * 
   * @example
   * http://xxx.aliyun.com/v1/log/upload
   */
  destUrl?: string;
  /**
   * @remarks
   * The custom headers.
   */
  headerParam?: { [key: string]: HttpDeliveryHeaderParamValue };
  /**
   * @remarks
   * The ending separator.
   * 
   * @example
   * \\n
   */
  lastLogSplit?: string;
  /**
   * @remarks
   * The prefix of the log delivery package.
   * 
   * @example
   * cdnVersion:1.0
   */
  logBodyPrefix?: string;
  /**
   * @remarks
   * The suffix of the log delivery package.
   * 
   * @example
   * cdnVersion:1.0
   */
  logBodySuffix?: string;
  /**
   * @remarks
   * Specifies whether to enable log splitting. Default value: true.
   * 
   * @example
   * true
   */
  logSplit?: string;
  /**
   * @remarks
   * The log separator.
   * 
   * @example
   * \\n
   */
  logSplitWords?: string;
  /**
   * @remarks
   * The maximum backoff time. Unit: milliseconds.
   * 
   * @example
   * 1000
   */
  maxBackoffMS?: number;
  /**
   * @remarks
   * The maximum size of data for each delivery. Unit: MB.
   * 
   * @example
   * 5
   */
  maxBatchMB?: number;
  /**
   * @remarks
   * The maximum number of entries for each delivery.
   * 
   * @example
   * 1000
   */
  maxBatchSize?: number;
  /**
   * @remarks
   * The maximum number of retries.
   * 
   * @example
   * 3
   */
  maxRetry?: number;
  /**
   * @remarks
   * The minimum backoff time. Unit: milliseconds.
   * 
   * @example
   * 100
   */
  minBackoffMS?: number;
  /**
   * @remarks
   * The custom query parameters.
   */
  queryParam?: { [key: string]: HttpDeliveryQueryParamValue };
  /**
   * @remarks
   * The response field key used for success check.
   * 
   * @example
   * err_code
   */
  responseBodyKey?: string;
  /**
   * @remarks
   * Specifies whether to use server authentication.
   * 
   * @example
   * true
   */
  standardAuthOn?: boolean;
  /**
   * @remarks
   * The authentication configurations.
   */
  standardAuthParam?: CreateUserDeliveryTaskRequestHttpDeliveryStandardAuthParam;
  /**
   * @remarks
   * The custom code for a success.
   * 
   * @example
   * 200
   */
  successCode?: number;
  /**
   * @remarks
   * The timeout period. Unit: seconds.
   * 
   * @example
   * 10
   */
  transformTimeout?: number;
  static names(): { [key: string]: string } {
    return {
      compress: 'Compress',
      destUrl: 'DestUrl',
      headerParam: 'HeaderParam',
      lastLogSplit: 'LastLogSplit',
      logBodyPrefix: 'LogBodyPrefix',
      logBodySuffix: 'LogBodySuffix',
      logSplit: 'LogSplit',
      logSplitWords: 'LogSplitWords',
      maxBackoffMS: 'MaxBackoffMS',
      maxBatchMB: 'MaxBatchMB',
      maxBatchSize: 'MaxBatchSize',
      maxRetry: 'MaxRetry',
      minBackoffMS: 'MinBackoffMS',
      queryParam: 'QueryParam',
      responseBodyKey: 'ResponseBodyKey',
      standardAuthOn: 'StandardAuthOn',
      standardAuthParam: 'StandardAuthParam',
      successCode: 'SuccessCode',
      transformTimeout: 'TransformTimeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      compress: 'string',
      destUrl: 'string',
      headerParam: { 'type': 'map', 'keyType': 'string', 'valueType': HttpDeliveryHeaderParamValue },
      lastLogSplit: 'string',
      logBodyPrefix: 'string',
      logBodySuffix: 'string',
      logSplit: 'string',
      logSplitWords: 'string',
      maxBackoffMS: 'number',
      maxBatchMB: 'number',
      maxBatchSize: 'number',
      maxRetry: 'number',
      minBackoffMS: 'number',
      queryParam: { 'type': 'map', 'keyType': 'string', 'valueType': HttpDeliveryQueryParamValue },
      responseBodyKey: 'string',
      standardAuthOn: 'boolean',
      standardAuthParam: CreateUserDeliveryTaskRequestHttpDeliveryStandardAuthParam,
      successCode: 'number',
      transformTimeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserDeliveryTaskRequestKafkaDelivery extends $tea.Model {
  /**
   * @remarks
   * The load balancing method.
   * 
   * @example
   * kafka.LeastBytes
   */
  balancer?: string;
  /**
   * @remarks
   * The brokers.
   */
  brokers?: string[];
  /**
   * @remarks
   * The compression method. By default, data is not compressed.
   * 
   * @example
   * gzip
   */
  compress?: string;
  /**
   * @remarks
   * The encryption method.
   * 
   * @example
   * plain
   */
  machanismType?: string;
  /**
   * @remarks
   * The password.
   * 
   * @example
   * xxx
   */
  password?: string;
  /**
   * @remarks
   * The topic.
   * 
   * @example
   * dqc_test2
   */
  topic?: string;
  /**
   * @remarks
   * Specifies whether to enable authentication.
   * 
   * @example
   * true
   */
  userAuth?: boolean;
  /**
   * @remarks
   * The username.
   * 
   * @example
   * xxx
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      balancer: 'Balancer',
      brokers: 'Brokers',
      compress: 'Compress',
      machanismType: 'MachanismType',
      password: 'Password',
      topic: 'Topic',
      userAuth: 'UserAuth',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      balancer: 'string',
      brokers: { 'type': 'array', 'itemType': 'string' },
      compress: 'string',
      machanismType: 'string',
      password: 'string',
      topic: 'string',
      userAuth: 'boolean',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserDeliveryTaskRequestOssDelivery extends $tea.Model {
  /**
   * @remarks
   * The ID of your Alibaba Cloud account.
   * 
   * @example
   * 1234***
   */
  aliuid?: string;
  /**
   * @remarks
   * The name of the OSS bucket.
   * 
   * @example
   * test_rlog
   */
  bucketName?: string;
  /**
   * @remarks
   * The prefix of the path in which you want to store logs.
   * 
   * @example
   * logriver-test/log
   */
  prefixPath?: string;
  /**
   * @remarks
   * The region in which the bucket is located.
   * 
   * @example
   * cn-shanghai
   */
  region?: string;
  static names(): { [key: string]: string } {
    return {
      aliuid: 'Aliuid',
      bucketName: 'BucketName',
      prefixPath: 'PrefixPath',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliuid: 'string',
      bucketName: 'string',
      prefixPath: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserDeliveryTaskRequestS3Delivery extends $tea.Model {
  /**
   * @remarks
   * The access key ID of your Amazon S3 account.
   * 
   * @example
   * g0f46623ll0g0
   */
  accessKey?: string;
  /**
   * @remarks
   * The directory in the bucket.
   * 
   * @example
   * logriver-test/log
   */
  bucketPath?: string;
  /**
   * @remarks
   * The endpoint.
   * 
   * @example
   * https://s3.oss-cn-hangzhou.aliyuncs.com
   */
  endpoint?: string;
  /**
   * @remarks
   * The prefix of the path in which you want to store logs.
   * 
   * @example
   * logriver-test/log
   */
  prefixPath?: string;
  /**
   * @remarks
   * The region ID of the service.
   * 
   * @example
   * cn-shanghai
   */
  region?: string;
  /**
   * @remarks
   * Specifies whether the service is compatible with Amazon S3.
   * 
   * @example
   * true
   */
  s3Cmpt?: boolean;
  /**
   * @remarks
   * The secret access key of your Amazon S3 account.
   * 
   * @example
   * ***
   */
  secretKey?: string;
  serverSideEncryption?: boolean;
  vertifyType?: string;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      bucketPath: 'BucketPath',
      endpoint: 'Endpoint',
      prefixPath: 'PrefixPath',
      region: 'Region',
      s3Cmpt: 'S3Cmpt',
      secretKey: 'SecretKey',
      serverSideEncryption: 'ServerSideEncryption',
      vertifyType: 'VertifyType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      bucketPath: 'string',
      endpoint: 'string',
      prefixPath: 'string',
      region: 'string',
      s3Cmpt: 'boolean',
      secretKey: 'string',
      serverSideEncryption: 'boolean',
      vertifyType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserDeliveryTaskRequestSlsDelivery extends $tea.Model {
  /**
   * @remarks
   * The name of the SLS Logstore.
   * 
   * @example
   * accesslog-test
   */
  SLSLogStore?: string;
  /**
   * @remarks
   * The name of the SLS project.
   * 
   * @example
   * dcdn-test20240417
   */
  SLSProject?: string;
  /**
   * @remarks
   * The region in which the SLS project resides.
   * 
   * @example
   * cn-hangzhou
   */
  SLSRegion?: string;
  static names(): { [key: string]: string } {
    return {
      SLSLogStore: 'SLSLogStore',
      SLSProject: 'SLSProject',
      SLSRegion: 'SLSRegion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      SLSLogStore: 'string',
      SLSProject: 'string',
      SLSRegion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomRequestHostNameAndPath extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domain?: string;
  /**
   * @remarks
   * The path.
   * 
   * This parameter is required.
   * 
   * @example
   * /test
   */
  path?: string;
  /**
   * @remarks
   * The subdomain.
   * 
   * This parameter is required.
   * 
   * @example
   * test.
   */
  subdomain?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      path: 'Path',
      subdomain: 'Subdomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      path: 'string',
      subdomain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomScenePoliciesResponseBodyDataModule extends $tea.Model {
  /**
   * @remarks
   * The time when the policy expires.
   * 
   * The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-03-06T16:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The name of the scenario-specific policy.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The IDs of websites that are associated with the policy.
   */
  objects?: string[];
  /**
   * @remarks
   * The policy ID.
   * 
   * @example
   * 1234****
   */
  policyId?: number;
  /**
   * @remarks
   * The time when the policy takes effect.
   * 
   * The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-03-04T16:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the policy. Valid values:
   * 
   * *   **Disabled**
   * *   **Pending**
   * *   **Running**
   * *   **Expired**
   * 
   * @example
   * Expired
   */
  status?: string;
  /**
   * @remarks
   * The name of the policy template. Valid value:
   * 
   * *   **promotion**: major events.
   * 
   * @example
   * promotion
   */
  template?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      name: 'Name',
      objects: 'Objects',
      policyId: 'PolicyId',
      startTime: 'StartTime',
      status: 'Status',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      name: 'string',
      objects: { 'type': 'array', 'itemType': 'string' },
      policyId: 'number',
      startTime: 'string',
      status: 'string',
      template: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDoSAllEventListResponseBodyDataList extends $tea.Model {
  /**
   * @remarks
   * The peak of volumetric attacks. Unit: bit/s.
   * 
   * @example
   * 800
   */
  bps?: number;
  coverage?: string;
  /**
   * @remarks
   * The peak of connection flood attacks. Unit: connections per seconds (CPS).
   * 
   * @example
   * 50
   */
  cps?: number;
  /**
   * @remarks
   * The time when the DDoS attack ends.
   * 
   * The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-02-12T15:59:59Z
   */
  endTime?: string;
  /**
   * @remarks
   * The attack event ID.
   * 
   * @example
   * web-cc_1
   */
  eventId?: string;
  eventResult?: string;
  /**
   * @remarks
   * The type of DDoS attacks that was queried. Valid values:
   * 
   * *   **web-cc**: web resource exhaustion attacks.
   * *   **cc**: connection flood attacks.
   * *   **traffic**: volumetric attacks.
   * 
   * @example
   * web-cc
   */
  eventType?: string;
  /**
   * @remarks
   * The peak of volumetric attacks. Unit: packets per second (PPS).
   * 
   * @example
   * 12000
   */
  pps?: number;
  /**
   * @remarks
   * The peak QPS of web resource exhaustion attacks.
   * 
   * @example
   * 7692
   */
  qps?: number;
  /**
   * @remarks
   * The time when the DDoS attack starts.
   * 
   * The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-02-12T15:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The attack target.
   * 
   * @example
   * example.com
   */
  target?: string;
  /**
   * @remarks
   * The ID of the web resource exhaustion attack target.
   * 
   * @example
   * 000000000155****
   */
  targetId?: string;
  static names(): { [key: string]: string } {
    return {
      bps: 'Bps',
      coverage: 'Coverage',
      cps: 'Cps',
      endTime: 'EndTime',
      eventId: 'EventId',
      eventResult: 'EventResult',
      eventType: 'EventType',
      pps: 'Pps',
      qps: 'Qps',
      startTime: 'StartTime',
      target: 'Target',
      targetId: 'TargetId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bps: 'number',
      coverage: 'string',
      cps: 'number',
      endTime: 'string',
      eventId: 'string',
      eventResult: 'string',
      eventType: 'string',
      pps: 'number',
      qps: 'number',
      startTime: 'string',
      target: 'string',
      targetId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePreloadTasksResponseBodyTasks extends $tea.Model {
  /**
   * @remarks
   * The prefetched content.
   * 
   * @example
   * http://a.com/1.jpg?b=2
   */
  content?: string;
  /**
   * @remarks
   * The time when the task was created.
   * 
   * @example
   * 2023-03-28 14:28:57
   */
  createTime?: string;
  /**
   * @remarks
   * The error message returned upon a prefetch task failure. Valid values:
   * 
   * *   **Internal Error**
   * *   **Origin Timeout**
   * *   **Origin Return StatusCode 5XX**
   * 
   * @example
   * Internal Error
   */
  description?: string;
  /**
   * @remarks
   * The progress of the task, in percentage.
   * 
   * @example
   * 100%
   */
  process?: string;
  /**
   * @remarks
   * The task status.
   * 
   * *   **Complete**: The task is complete.
   * *   **Refreshing**: The task is in progress.
   * *   **Failed**: The task failed.
   * 
   * @example
   * Complete
   */
  status?: string;
  /**
   * @remarks
   * The ID of the queried task.
   * 
   * @example
   * 1597854579687428
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      createTime: 'CreateTime',
      description: 'Description',
      process: 'Process',
      status: 'Status',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      createTime: 'string',
      description: 'string',
      process: 'string',
      status: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurgeTasksResponseBodyTasks extends $tea.Model {
  /**
   * @remarks
   * The purged content.
   * 
   * @example
   * http://a.com/1.jpg?b=1
   */
  content?: string;
  /**
   * @remarks
   * The time when the task was created.
   * 
   * @example
   * 2023-07-26T01:56:15Z
   */
  createTime?: string;
  /**
   * @remarks
   * The error description returned when the purge task failed.
   * 
   * @example
   * Internal Error
   */
  description?: string;
  /**
   * @remarks
   * The progress of the task, in percentage.
   * 
   * @example
   * 100%
   */
  process?: string;
  /**
   * @remarks
   * The task status.
   * 
   * *   **Complete**: The task is complete.
   * *   **Refreshing**: The task is in progress.
   * *   **Failed**: The task failed.
   * 
   * @example
   * Complete
   */
  status?: string;
  /**
   * @remarks
   * The task ID.
   * 
   * @example
   * 16346513304
   */
  taskId?: string;
  /**
   * @remarks
   * The type of the purge task. Valid values:
   * 
   * *   **file** (default): purges the cache by file.
   * *   **cachetag**: purges the cache by cache tag.
   * *   **directory**: purges the cache by directory.
   * *   **ignoreParams**: purges the cache by URL with specified parameters ignored.
   * *   **hostname**: purges the cache by hostname.
   * *   **purgeall**: purges all cache.
   * 
   * @example
   * file
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      createTime: 'CreateTime',
      description: 'Description',
      process: 'Process',
      status: 'Status',
      taskId: 'TaskId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      createTime: 'string',
      description: 'string',
      process: 'string',
      status: 'string',
      taskId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppResponseBodyAppHealthCheck extends $tea.Model {
  /**
   * @remarks
   * The number of consecutive failed health checks required for an application to be considered as unhealthy.
   * 
   * @example
   * 5
   */
  failTimes?: number;
  /**
   * @remarks
   * The domain name that is used for health checks.
   * 
   * @example
   * test.com
   */
  host?: string;
  /**
   * @remarks
   * The range of health check status codes that indicate successful health checks.
   * 
   * @example
   * http_2xx
   */
  httpCode?: string;
  /**
   * @remarks
   * The interval between health checks. Unit: seconds.
   * 
   * @example
   * 5
   */
  interval?: number;
  /**
   * @remarks
   * The HTTP method that the health check request uses.
   * 
   * @example
   * HEAD
   */
  method?: string;
  /**
   * @remarks
   * The health check port.
   * 
   * @example
   * 80
   */
  port?: number;
  /**
   * @remarks
   * The number of consecutive successful health checks required for an application to be considered as healthy.
   * 
   * @example
   * 3
   */
  succTimes?: number;
  /**
   * @remarks
   * The timeout period of the health check. Unit: seconds.
   * 
   * @example
   * 60
   */
  timeout?: number;
  /**
   * @remarks
   * The health check type. Valid values:
   * 
   * *   l7
   * *   l4
   * 
   * @example
   * l7
   */
  type?: string;
  /**
   * @remarks
   * The health check URL.
   * 
   * @example
   * /health_check
   */
  uri?: string;
  static names(): { [key: string]: string } {
    return {
      failTimes: 'FailTimes',
      host: 'Host',
      httpCode: 'HttpCode',
      interval: 'Interval',
      method: 'Method',
      port: 'Port',
      succTimes: 'SuccTimes',
      timeout: 'Timeout',
      type: 'Type',
      uri: 'Uri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failTimes: 'number',
      host: 'string',
      httpCode: 'string',
      interval: 'number',
      method: 'string',
      port: 'number',
      succTimes: 'number',
      timeout: 'number',
      type: 'string',
      uri: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppResponseBodyApp extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The time when the application was created.
   * 
   * @example
   * 2023-07-25T05:58:05Z
   */
  createTime?: string;
  /**
   * @remarks
   * The domain name that is associated with the application. If no domain name is associated with the application, the value is an empty string.
   * 
   * @example
   * www.1feel.cn
   */
  domainName?: string;
  /**
   * @remarks
   * The type of the gateway. Valid values:
   * 
   * *   l7: Layer 7 gateway.
   * *   l4: Layer 4 gateway.
   * 
   * @example
   * l7
   */
  gatewayType?: string;
  /**
   * @remarks
   * The information about health checks.
   */
  healthCheck?: GetEdgeContainerAppResponseBodyAppHealthCheck;
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * test-app1
   */
  name?: string;
  /**
   * @remarks
   * Indicates whether QUIC is enabled.
   * 
   * @example
   * false
   */
  quicCid?: string;
  /**
   * @remarks
   * The remarks about the application.
   * 
   * @example
   * test app
   */
  remarks?: string;
  /**
   * @remarks
   * The server port. Valid values: 1 to 65535.
   * 
   * @example
   * 80
   */
  servicePort?: number;
  /**
   * @remarks
   * The status of the application. Valid values:
   * 
   * *   creating: The application is being created.
   * *   failed: The application failed to be created.
   * *   created: The application is created.
   * 
   * @example
   * created
   */
  status?: string;
  /**
   * @remarks
   * The backend port, which is also the service port of the application. Valid values: 1 to 65535.
   * 
   * @example
   * 80
   */
  targetPort?: number;
  /**
   * @remarks
   * The time when the application was last modified. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2023-03-26T02:35:58Z
   */
  updateTime?: string;
  /**
   * @remarks
   * The number of versions of the application.
   * 
   * @example
   * 1
   */
  versionCount?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      createTime: 'CreateTime',
      domainName: 'DomainName',
      gatewayType: 'GatewayType',
      healthCheck: 'HealthCheck',
      name: 'Name',
      quicCid: 'QuicCid',
      remarks: 'Remarks',
      servicePort: 'ServicePort',
      status: 'Status',
      targetPort: 'TargetPort',
      updateTime: 'UpdateTime',
      versionCount: 'VersionCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      createTime: 'string',
      domainName: 'string',
      gatewayType: 'string',
      healthCheck: GetEdgeContainerAppResponseBodyAppHealthCheck,
      name: 'string',
      quicCid: 'string',
      remarks: 'string',
      servicePort: 'number',
      status: 'string',
      targetPort: 'number',
      updateTime: 'string',
      versionCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppStatusResponseBodyAppStatusRegions extends $tea.Model {
  region?: string[];
  static names(): { [key: string]: string } {
    return {
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      region: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppStatusResponseBodyAppStatus extends $tea.Model {
  /**
   * @remarks
   * The base version of the application.
   * 
   * @example
   * ver-123123123123****
   */
  baseLineVersion?: string;
  /**
   * @remarks
   * The deployment status of the application.
   * 
   * *   **undeploy**: The application is not deployed.
   * *   **deploying**: The application is being deployed.
   * *   **deployed**: The application is deployed.
   * *   **undeploying**: The deployment is being canceled.
   * 
   * @example
   * undeploy
   */
  deployStatus?: string;
  /**
   * @remarks
   * The time when the application was deployed. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2024-07-25T05:58:05Z
   */
  deployTime?: string;
  /**
   * @remarks
   * The release version of the application.
   * 
   * @example
   * ver-123123123123****
   */
  deployedVersion?: string;
  /**
   * @remarks
   * The expected release percentage of the application.
   * 
   * @example
   * 50%
   */
  expectPercentage?: number;
  /**
   * @remarks
   * Specifies whether to fully release the version. This parameter takes effect only when PublishType is set to region.
   * 
   * @example
   * true
   */
  fullRelease?: boolean;
  /**
   * @remarks
   * The environment to which the application was released. Valid values:
   * 
   * *   **prod**: the production environment.
   * *   **staging**: the staging environment.
   * 
   * @example
   * prod
   */
  publishEnv?: string;
  /**
   * @remarks
   * The release percentage of the application.
   * 
   * @example
   * 50%
   */
  publishPercentage?: number;
  /**
   * @remarks
   * The release status of the application. Valid values:
   * 
   * *   **publishing**
   * *   **published**
   * *   **rollbacking**
   * *   **rollbacked**
   * 
   * @example
   * pubishing
   */
  publishStatus?: string;
  /**
   * @remarks
   * The time when the application was released. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2024-07-25T05:58:05Z
   */
  publishTime?: string;
  /**
   * @remarks
   * Specifies how the version is released. Valid values:
   * 
   * *   percentage: releases the version by percentage.
   * *   region: releases the version by region.
   * 
   * If you do not specify this parameter, the version is released by percentage by default.
   * 
   * @example
   * percentage
   */
  publishType?: string;
  /**
   * @remarks
   * The release version of the application.
   * 
   * @example
   * ver-123123123123****
   */
  publishingVersion?: string;
  /**
   * @remarks
   * The regions to which the version is released.
   */
  regions?: GetEdgeContainerAppStatusResponseBodyAppStatusRegions;
  /**
   * @remarks
   * The time when the last rollback was performed.
   * 
   * @example
   * 2024-07-25T05:58:05Z
   */
  rollbackTime?: string;
  /**
   * @remarks
   * The time when the application deployment was canceled. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2024-07-25T05:58:05Z
   */
  unDeployTime?: string;
  static names(): { [key: string]: string } {
    return {
      baseLineVersion: 'BaseLineVersion',
      deployStatus: 'DeployStatus',
      deployTime: 'DeployTime',
      deployedVersion: 'DeployedVersion',
      expectPercentage: 'ExpectPercentage',
      fullRelease: 'FullRelease',
      publishEnv: 'PublishEnv',
      publishPercentage: 'PublishPercentage',
      publishStatus: 'PublishStatus',
      publishTime: 'PublishTime',
      publishType: 'PublishType',
      publishingVersion: 'PublishingVersion',
      regions: 'Regions',
      rollbackTime: 'RollbackTime',
      unDeployTime: 'UnDeployTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baseLineVersion: 'string',
      deployStatus: 'string',
      deployTime: 'string',
      deployedVersion: 'string',
      expectPercentage: 'number',
      fullRelease: 'boolean',
      publishEnv: 'string',
      publishPercentage: 'number',
      publishStatus: 'string',
      publishTime: 'string',
      publishType: 'string',
      publishingVersion: 'string',
      regions: GetEdgeContainerAppStatusResponseBodyAppStatusRegions,
      rollbackTime: 'string',
      unDeployTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppVersionResponseBodyVersionContainersACRImageInfo extends $tea.Model {
  /**
   * @remarks
   * The domain name of the Container Registry image.
   * 
   * @example
   * *.mooc.seewo.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the Container Registry instance.
   * 
   * @example
   * xcdn-9ak2thl14z5s
   */
  instanceId?: string;
  /**
   * @remarks
   * Indicates whether the image is an enterprise-level image.
   * 
   * @example
   * false
   */
  isEnterpriseRegistry?: boolean;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the image repository.
   * 
   * @example
   * crr-zeu0xyk28alyxozh
   */
  repoId?: string;
  /**
   * @remarks
   * The name of the image repository.
   * 
   * @example
   * test_1
   */
  repoName?: string;
  /**
   * @remarks
   * The namespace to which the image repository belongs.
   * 
   * @example
   * wpy1
   */
  repoNamespace?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * test-healthy-100-soa-1710987653
   */
  tag?: string;
  /**
   * @remarks
   * The URL of the Container Registry image tag.
   * 
   * @example
   * registry-vpc.cn-shenzhen.aliyuncs.com/lihetech/easywits_server_exam:3.40.2
   */
  tagUrl?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      instanceId: 'InstanceId',
      isEnterpriseRegistry: 'IsEnterpriseRegistry',
      regionId: 'RegionId',
      repoId: 'RepoId',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      tag: 'Tag',
      tagUrl: 'TagUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      instanceId: 'string',
      isEnterpriseRegistry: 'boolean',
      regionId: 'string',
      repoId: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      tag: 'string',
      tagUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppVersionResponseBodyVersionContainersProbeContent extends $tea.Model {
  /**
   * @remarks
   * The probe command.
   * 
   * @example
   * sh test.sh
   */
  command?: string;
  /**
   * @remarks
   * The number of consecutive failed health checks required for a container to be considered as unhealthy.
   * 
   * @example
   * 3
   */
  failureThreshold?: number;
  /**
   * @remarks
   * The domain name that is used for health checks.
   * 
   * @example
   * test.com
   */
  host?: string;
  /**
   * @remarks
   * The request headers that are included in the container health check request.
   * 
   * @example
   * [{\\"Content-Type\\":\\"application/json
   */
  httpHeaders?: string;
  /**
   * @remarks
   * The latency for container probe initialization.
   * 
   * @example
   * 20
   */
  initialDelaySeconds?: number;
  /**
   * @remarks
   * The path of the container health check.
   * 
   * @example
   * /health_check
   */
  path?: string;
  /**
   * @remarks
   * The interval between container health checks.
   * 
   * @example
   * 5
   */
  periodSeconds?: number;
  /**
   * @remarks
   * The port of the container health check. Valid values: **1** to **65535**.
   * 
   * @example
   * 80
   */
  port?: number;
  /**
   * @remarks
   * The protocol that the container health check request uses.
   * 
   * @example
   * http
   */
  scheme?: string;
  /**
   * @remarks
   * The number of consecutive successful health checks required for a container to be considered as healthy.
   * 
   * @example
   * 1
   */
  successThreshold?: number;
  /**
   * @remarks
   * The timeout period of the container health check.
   * 
   * @example
   * 5
   */
  timeoutSeconds?: number;
  static names(): { [key: string]: string } {
    return {
      command: 'Command',
      failureThreshold: 'FailureThreshold',
      host: 'Host',
      httpHeaders: 'HttpHeaders',
      initialDelaySeconds: 'InitialDelaySeconds',
      path: 'Path',
      periodSeconds: 'PeriodSeconds',
      port: 'Port',
      scheme: 'Scheme',
      successThreshold: 'SuccessThreshold',
      timeoutSeconds: 'TimeoutSeconds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      command: 'string',
      failureThreshold: 'number',
      host: 'string',
      httpHeaders: 'string',
      initialDelaySeconds: 'number',
      path: 'string',
      periodSeconds: 'number',
      port: 'number',
      scheme: 'string',
      successThreshold: 'number',
      timeoutSeconds: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppVersionResponseBodyVersionContainers extends $tea.Model {
  /**
   * @remarks
   * The information about the Container Registry image.
   */
  ACRImageInfo?: GetEdgeContainerAppVersionResponseBodyVersionContainersACRImageInfo;
  /**
   * @remarks
   * The arguments that are passed to the container startup command.
   * 
   * @example
   * -c /path/config.toml
   */
  args?: string;
  /**
   * @remarks
   * The command that is used to start the container.
   * 
   * @example
   * sh abc.sh 1 2 3
   */
  command?: string;
  /**
   * @remarks
   * The environment variables.
   * 
   * @example
   * ENV=prod
   */
  envVariables?: string;
  /**
   * @remarks
   * The image address.
   * 
   * @example
   * nginx:1.14.0
   */
  image?: string;
  /**
   * @remarks
   * Indicates whether the image is a Container Registry image.
   * 
   * @example
   * false
   */
  isACRImage?: boolean;
  /**
   * @remarks
   * The version name.
   * 
   * @example
   * version01
   */
  name?: string;
  /**
   * @remarks
   * The command that is run before the container is started. Format: `{"exec":{"command":["cat","/etc/group"\\]}}`. If you want to cancel this configuration, set the parameter value to `""` or `{}`. If you do not specify this parameter, this configuration is ignored.
   * 
   * @example
   * {\\"exec\\":{\\"command\\":[\\"touch\\",\\"/home/admin/checkpoststartV1\\"]}}
   */
  postStart?: string;
  /**
   * @remarks
   * The command that is run before the container is stopped.
   * 
   * @example
   * sh prestop.sh "echo hello world"
   */
  preStop?: string;
  /**
   * @remarks
   * The probe content.
   */
  probeContent?: GetEdgeContainerAppVersionResponseBodyVersionContainersProbeContent;
  /**
   * @remarks
   * The probe type.
   * 
   * @example
   * httpGet
   */
  probeType?: string;
  /**
   * @remarks
   * The compute specification.
   * 
   * @example
   * 1C2G
   */
  spec?: string;
  /**
   * @remarks
   * The storage capacity of the container. Valid values: 0.5G, 10G, 20G, and 30G.
   */
  storage?: string;
  static names(): { [key: string]: string } {
    return {
      ACRImageInfo: 'ACRImageInfo',
      args: 'Args',
      command: 'Command',
      envVariables: 'EnvVariables',
      image: 'Image',
      isACRImage: 'IsACRImage',
      name: 'Name',
      postStart: 'PostStart',
      preStop: 'PreStop',
      probeContent: 'ProbeContent',
      probeType: 'ProbeType',
      spec: 'Spec',
      storage: 'Storage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ACRImageInfo: GetEdgeContainerAppVersionResponseBodyVersionContainersACRImageInfo,
      args: 'string',
      command: 'string',
      envVariables: 'string',
      image: 'string',
      isACRImage: 'boolean',
      name: 'string',
      postStart: 'string',
      preStop: 'string',
      probeContent: GetEdgeContainerAppVersionResponseBodyVersionContainersProbeContent,
      probeType: 'string',
      spec: 'string',
      storage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppVersionResponseBodyVersion extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The container images deployed for this version.
   */
  containers?: GetEdgeContainerAppVersionResponseBodyVersionContainers[];
  /**
   * @remarks
   * The time when the version was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2022-07-01T09:32:33Z
   */
  createTime?: string;
  /**
   * @remarks
   * The time when the version was last released. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2023-07-25T04:58:05Z
   */
  lastPublishTime?: string;
  /**
   * @remarks
   * The version name.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The time when the version was released. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2022-11-14T02:04:03Z
   */
  publishTime?: string;
  /**
   * @remarks
   * The remarks.
   * 
   * @example
   * aaa
   */
  remarks?: string;
  /**
   * @remarks
   * The status of the current version. Valid values:
   * 
   * *   created: The version is created.
   * *   failed: The version failed to be created.
   * *   creating: The version is being created.
   * 
   * @example
   * created
   */
  status?: string;
  /**
   * @remarks
   * The time when the version was last modified. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2021-12-03T10:52:52Z
   */
  updateTime?: string;
  /**
   * @remarks
   * The ID of the created version.
   * 
   * @example
   * ver-87962637161651****
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      containers: 'Containers',
      createTime: 'CreateTime',
      lastPublishTime: 'LastPublishTime',
      name: 'Name',
      publishTime: 'PublishTime',
      remarks: 'Remarks',
      status: 'Status',
      updateTime: 'UpdateTime',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      containers: { 'type': 'array', 'itemType': GetEdgeContainerAppVersionResponseBodyVersionContainers },
      createTime: 'string',
      lastPublishTime: 'string',
      name: 'string',
      publishTime: 'string',
      remarks: 'string',
      status: 'string',
      updateTime: 'string',
      versionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerStagingDeployStatusResponseBodyPodRestartState extends $tea.Model {
  /**
   * @remarks
   * The reason for the last restart.
   * 
   * @example
   * OOMKilled
   */
  lastTerminatedReason?: string;
  /**
   * @remarks
   * The number of times that the container restarted.
   * 
   * @example
   * 1
   */
  restartCount?: number;
  static names(): { [key: string]: string } {
    return {
      lastTerminatedReason: 'LastTerminatedReason',
      restartCount: 'RestartCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lastTerminatedReason: 'string',
      restartCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKvAccountResponseBodyNamespaceList extends $tea.Model {
  /**
   * @remarks
   * The available capacity of the namespace. Unit: bytes.
   * 
   * @example
   * 1073741824
   */
  capacity?: number;
  /**
   * @remarks
   * The available capacity of the namespace.
   * 
   * @example
   * 1 GB
   */
  capacityString?: string;
  /**
   * @remarks
   * The used capacity of the namespace. Unit: bytes.
   * 
   * @example
   * 100048576
   */
  capacityUsed?: number;
  /**
   * @remarks
   * The used capacity of the namespace.
   * 
   * @example
   * 100 MB
   */
  capacityUsedString?: string;
  /**
   * @remarks
   * The description of the namespace.
   * 
   * @example
   * the first namespace
   */
  description?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 643355322374688768
   */
  namespaceId?: string;
  /**
   * @remarks
   * The status of the namespace. Valid values:
   * 
   * *   **online**: normal.
   * *   **delete**: pending deletion.
   * *   **deleting**: being deleted.
   * *   **deleted**: deleted.
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      capacity: 'Capacity',
      capacityString: 'CapacityString',
      capacityUsed: 'CapacityUsed',
      capacityUsedString: 'CapacityUsedString',
      description: 'Description',
      namespace: 'Namespace',
      namespaceId: 'NamespaceId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacity: 'number',
      capacityString: 'string',
      capacityUsed: 'number',
      capacityUsedString: 'string',
      description: 'string',
      namespace: 'string',
      namespaceId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginProtectionResponseBodyCurrentIPWhitelist extends $tea.Model {
  IPv4?: string[];
  IPv6?: string[];
  static names(): { [key: string]: string } {
    return {
      IPv4: 'IPv4',
      IPv6: 'IPv6',
    };
  }

  static types(): { [key: string]: any } {
    return {
      IPv4: { 'type': 'array', 'itemType': 'string' },
      IPv6: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginProtectionResponseBodyDiffIPWhitelistAddedIPWhitelist extends $tea.Model {
  IPv4?: string[];
  IPv6?: string[];
  static names(): { [key: string]: string } {
    return {
      IPv4: 'IPv4',
      IPv6: 'IPv6',
    };
  }

  static types(): { [key: string]: any } {
    return {
      IPv4: { 'type': 'array', 'itemType': 'string' },
      IPv6: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginProtectionResponseBodyDiffIPWhitelistNoChangeIpWhitelist extends $tea.Model {
  IPv4?: string[];
  IPv6?: string[];
  static names(): { [key: string]: string } {
    return {
      IPv4: 'IPv4',
      IPv6: 'IPv6',
    };
  }

  static types(): { [key: string]: any } {
    return {
      IPv4: { 'type': 'array', 'itemType': 'string' },
      IPv6: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginProtectionResponseBodyDiffIPWhitelistRemovedIPWhitelist extends $tea.Model {
  IPv4?: string[];
  IPv6?: string[];
  static names(): { [key: string]: string } {
    return {
      IPv4: 'IPv4',
      IPv6: 'IPv6',
    };
  }

  static types(): { [key: string]: any } {
    return {
      IPv4: { 'type': 'array', 'itemType': 'string' },
      IPv6: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginProtectionResponseBodyDiffIPWhitelist extends $tea.Model {
  addedIPWhitelist?: GetOriginProtectionResponseBodyDiffIPWhitelistAddedIPWhitelist;
  noChangeIpWhitelist?: GetOriginProtectionResponseBodyDiffIPWhitelistNoChangeIpWhitelist;
  removedIPWhitelist?: GetOriginProtectionResponseBodyDiffIPWhitelistRemovedIPWhitelist;
  static names(): { [key: string]: string } {
    return {
      addedIPWhitelist: 'AddedIPWhitelist',
      noChangeIpWhitelist: 'NoChangeIpWhitelist',
      removedIPWhitelist: 'RemovedIPWhitelist',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addedIPWhitelist: GetOriginProtectionResponseBodyDiffIPWhitelistAddedIPWhitelist,
      noChangeIpWhitelist: GetOriginProtectionResponseBodyDiffIPWhitelistNoChangeIpWhitelist,
      removedIPWhitelist: GetOriginProtectionResponseBodyDiffIPWhitelistRemovedIPWhitelist,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginProtectionResponseBodyLatestIPWhitelist extends $tea.Model {
  IPv4?: string[];
  IPv6?: string[];
  static names(): { [key: string]: string } {
    return {
      IPv4: 'IPv4',
      IPv6: 'IPv6',
    };
  }

  static types(): { [key: string]: any } {
    return {
      IPv4: { 'type': 'array', 'itemType': 'string' },
      IPv6: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRecordResponseBodyRecordModelAuthConf extends $tea.Model {
  /**
   * @example
   * VIxuvJSA2S03f******kp208dy5w7
   */
  accessKey?: string;
  /**
   * @example
   * public
   */
  authType?: string;
  /**
   * @example
   * us-east-1
   */
  region?: string;
  /**
   * @example
   * u0Nkg5gBK*******QF5wvKMM504JUHt
   */
  secretKey?: string;
  /**
   * @example
   * v2
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      authType: 'AuthType',
      region: 'Region',
      secretKey: 'SecretKey',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      authType: 'string',
      region: 'string',
      secretKey: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRecordResponseBodyRecordModelData extends $tea.Model {
  /**
   * @example
   * 1
   */
  algorithm?: number;
  /**
   * @example
   * dGVzdGFkYWxrcw==
   */
  certificate?: string;
  /**
   * @example
   * abcdef1234567890
   */
  fingerprint?: string;
  /**
   * @example
   * 128
   */
  flag?: number;
  /**
   * @example
   * 1
   */
  keyTag?: number;
  /**
   * @example
   * 1
   */
  matchingType?: number;
  /**
   * @example
   * 8707
   */
  port?: number;
  /**
   * @example
   * 10
   */
  priority?: number;
  /**
   * @example
   * 1
   */
  selector?: number;
  /**
   * @example
   * issue
   */
  tag?: string;
  /**
   * @example
   * RSA
   */
  type?: number;
  /**
   * @example
   * 0
   */
  usage?: number;
  /**
   * @example
   * example.com
   */
  value?: string;
  /**
   * @example
   * 0
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      algorithm: 'Algorithm',
      certificate: 'Certificate',
      fingerprint: 'Fingerprint',
      flag: 'Flag',
      keyTag: 'KeyTag',
      matchingType: 'MatchingType',
      port: 'Port',
      priority: 'Priority',
      selector: 'Selector',
      tag: 'Tag',
      type: 'Type',
      usage: 'Usage',
      value: 'Value',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      algorithm: 'number',
      certificate: 'string',
      fingerprint: 'string',
      flag: 'number',
      keyTag: 'number',
      matchingType: 'number',
      port: 'number',
      priority: 'number',
      selector: 'number',
      tag: 'string',
      type: 'number',
      usage: 'number',
      value: 'string',
      weight: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRecordResponseBodyRecordModel extends $tea.Model {
  authConf?: GetRecordResponseBodyRecordModelAuthConf;
  /**
   * @example
   * image_video
   */
  bizName?: string;
  comment?: string;
  /**
   * @example
   * 2023-03-10T13:30:39Z
   */
  createTime?: string;
  /**
   * @example
   * {"value":"1.1.1.1"}
   */
  data?: GetRecordResponseBodyRecordModelData;
  hostPolicy?: string;
  /**
   * @example
   * true
   */
  proxied?: boolean;
  /**
   * @example
   * a.example.com.cnamezone.com
   */
  recordCname?: string;
  /**
   * @example
   * 1234567890123
   */
  recordId?: number;
  /**
   * @example
   * a.example.com
   */
  recordName?: string;
  /**
   * @example
   * OSS
   */
  recordSourceType?: string;
  /**
   * @example
   * A/AAAA
   */
  recordType?: string;
  /**
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @example
   * 20
   */
  ttl?: number;
  /**
   * @example
   * 2023-01-27T02:26:22Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      authConf: 'AuthConf',
      bizName: 'BizName',
      comment: 'Comment',
      createTime: 'CreateTime',
      data: 'Data',
      hostPolicy: 'HostPolicy',
      proxied: 'Proxied',
      recordCname: 'RecordCname',
      recordId: 'RecordId',
      recordName: 'RecordName',
      recordSourceType: 'RecordSourceType',
      recordType: 'RecordType',
      siteId: 'SiteId',
      siteName: 'SiteName',
      ttl: 'Ttl',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authConf: GetRecordResponseBodyRecordModelAuthConf,
      bizName: 'string',
      comment: 'string',
      createTime: 'string',
      data: GetRecordResponseBodyRecordModelData,
      hostPolicy: 'string',
      proxied: 'boolean',
      recordCname: 'string',
      recordId: 'number',
      recordName: 'string',
      recordSourceType: 'string',
      recordType: 'string',
      siteId: 'number',
      siteName: 'string',
      ttl: 'number',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineResponseBodyCodeVersions extends $tea.Model {
  /**
   * @remarks
   * The description of the code version.
   * 
   * @example
   * test ver code desc
   */
  codeDescription?: string;
  /**
   * @remarks
   * The code version.
   * 
   * @example
   * 1710120201067203242
   */
  codeVersion?: string;
  /**
   * @remarks
   * The time when the code version was created.
   * 
   * @example
   * 2024-03-11T01:23:21Z
   */
  createTime?: string;
  static names(): { [key: string]: string } {
    return {
      codeDescription: 'CodeDescription',
      codeVersion: 'CodeVersion',
      createTime: 'CreateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeDescription: 'string',
      codeVersion: 'string',
      createTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineResponseBodyEnvs extends $tea.Model {
  /**
   * @remarks
   * The regions for canary release.
   */
  canaryAreaList?: string[];
  /**
   * @remarks
   * The version number for canary release.
   * 
   * @example
   * 1710120201067577628
   */
  canaryCodeVersion?: string;
  /**
   * @remarks
   * The version number of the code in the environment.
   * 
   * @example
   * 1710120201067577628
   */
  codeVersion?: string;
  /**
   * @remarks
   * The environment type.
   * 
   * @example
   * production
   */
  env?: string;
  /**
   * @remarks
   * The specification.
   * 
   * @example
   * 5ms
   */
  specName?: string;
  static names(): { [key: string]: string } {
    return {
      canaryAreaList: 'CanaryAreaList',
      canaryCodeVersion: 'CanaryCodeVersion',
      codeVersion: 'CodeVersion',
      env: 'Env',
      specName: 'SpecName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canaryAreaList: { 'type': 'array', 'itemType': 'string' },
      canaryCodeVersion: 'string',
      codeVersion: 'string',
      env: 'string',
      specName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineResponseBodyRelatedRecords extends $tea.Model {
  /**
   * @remarks
   * The record ID.
   * 
   * @example
   * 509348423011904
   */
  recordId?: number;
  /**
   * @remarks
   * The record name.
   * 
   * @example
   * test-record-1.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 54362329990032
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  static names(): { [key: string]: string } {
    return {
      recordId: 'RecordId',
      recordName: 'RecordName',
      siteId: 'SiteId',
      siteName: 'SiteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordId: 'number',
      recordName: 'string',
      siteId: 'number',
      siteName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineResponseBodyRelatedRoutes extends $tea.Model {
  /**
   * @remarks
   * The route.
   * 
   * @example
   * *.example.com/path1*
   */
  route?: string;
  /**
   * @remarks
   * The route ID.
   * 
   * @example
   * d501cb8a2c951f32922d260040780c06
   */
  routeId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 54362329990032
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  static names(): { [key: string]: string } {
    return {
      route: 'Route',
      routeId: 'RouteId',
      siteId: 'SiteId',
      siteName: 'SiteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      route: 'string',
      routeId: 'string',
      siteId: 'number',
      siteName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineUserInfoResponseBodyRoutines extends $tea.Model {
  /**
   * @remarks
   * The time when the routine was created.
   * 
   * @example
   * 2024-03-11T01:23:02.883361712Z
   */
  createTime?: string;
  /**
   * @remarks
   * The routine description, which is Base64-encoded.
   * 
   * @example
   * ZWRpdCByb3V0aW5lIGNvbmZpZyBkZXNjcmlwdGlvbg
   */
  description?: string;
  /**
   * @remarks
   * The routine name.
   * 
   * @example
   * test-routine1
   */
  routineName?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      routineName: 'RoutineName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      description: 'string',
      routineName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteResponseBodySiteModel extends $tea.Model {
  /**
   * @remarks
   * The DNS setup option for the website. Valid values:
   * 
   * *   **NS**
   * *   **CNAME**
   * 
   * @example
   * NS
   */
  accessType?: string;
  /**
   * @remarks
   * The CNAME of the website domain. If you use CNAME setup when you add your website to ESA, the value is the CNAME that you configured then.
   * 
   * @example
   * example.cname.com
   */
  cnameZone?: string;
  /**
   * @remarks
   * The service location. Valid values:
   * 
   * *   **domestic**: the Chinese mainland.
   * *   **global**: global.
   * *   **overseas**: outside the Chinese mainland.
   * 
   * @example
   * domestic
   */
  coverage?: string;
  /**
   * @remarks
   * The time when the WEBsite was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format and is displayed in UTC.
   * 
   * @example
   * 2023-12-24T02:01:11Z
   */
  createTime?: string;
  /**
   * @remarks
   * The plan ID.
   * 
   * @example
   * cas-merge-q6h0bv
   */
  instanceId?: string;
  /**
   * @remarks
   * The nameservers assigned to the website domain. They are separated by commas (,).
   * 
   * @example
   * male1-1.ialicdn.com,female1-1.ialicdn.com
   */
  nameServerList?: string;
  /**
   * @remarks
   * The plan name.
   * 
   * @example
   * plan-168777532****
   */
  planName?: string;
  /**
   * @remarks
   * The specification of the plan associated with the website.
   * 
   * @example
   * normal
   */
  planSpecName?: string;
  /**
   * @remarks
   * The ID of your Alibaba Cloud resource group.
   * 
   * @example
   * rg-aek26g6i6se****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The website status. Valid values:
   * 
   * *   **pending**: The website is to be configured.
   * *   **active**: The website is active.
   * *   **offline**: The website is suspended.
   * *   **moved**: The website has been added and verified by another Alibaba Cloud account.
   * 
   * @example
   * pending
   */
  status?: string;
  /**
   * @remarks
   * The tags of the website.
   * 
   * @example
   * {"tag1":"value1"}
   */
  tags?: { [key: string]: any };
  /**
   * @remarks
   * The time when the WEBsite was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format and is displayed in UTC.
   * 
   * @example
   * 2023-12-24T02:01:11Z
   */
  updateTime?: string;
  /**
   * @remarks
   * The information about custom nameservers of the website domain. The key is a custom nameserver name, and the value is the IP address of the custom nameserver. Multiple IP addresses are separated by commas (,).
   */
  vanityNSList?: { [key: string]: string };
  /**
   * @remarks
   * The code that is used to verify the website domain ownership. As part of the verification TXT record, this parameter is returned for websites that use CNAME setup.
   * 
   * @example
   * verify_d516cb3740f81f0cef77d162edd1****
   */
  verifyCode?: string;
  /**
   * @remarks
   * The status of version management. If true is returned, version management is enabled for the website.
   * 
   * @example
   * true
   */
  versionManagement?: boolean;
  static names(): { [key: string]: string } {
    return {
      accessType: 'AccessType',
      cnameZone: 'CnameZone',
      coverage: 'Coverage',
      createTime: 'CreateTime',
      instanceId: 'InstanceId',
      nameServerList: 'NameServerList',
      planName: 'PlanName',
      planSpecName: 'PlanSpecName',
      resourceGroupId: 'ResourceGroupId',
      siteId: 'SiteId',
      siteName: 'SiteName',
      status: 'Status',
      tags: 'Tags',
      updateTime: 'UpdateTime',
      vanityNSList: 'VanityNSList',
      verifyCode: 'VerifyCode',
      versionManagement: 'VersionManagement',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessType: 'string',
      cnameZone: 'string',
      coverage: 'string',
      createTime: 'string',
      instanceId: 'string',
      nameServerList: 'string',
      planName: 'string',
      planSpecName: 'string',
      resourceGroupId: 'string',
      siteId: 'number',
      siteName: 'string',
      status: 'string',
      tags: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      updateTime: 'string',
      vanityNSList: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      verifyCode: 'string',
      versionManagement: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteCustomLogResponseBodyLogCustomField extends $tea.Model {
  /**
   * @remarks
   * The cookie fields.
   */
  cookies?: string[];
  /**
   * @remarks
   * The request header fields.
   */
  requestHeaders?: string[];
  /**
   * @remarks
   * The response header fields.
   */
  responseHeaders?: string[];
  static names(): { [key: string]: string } {
    return {
      cookies: 'Cookies',
      requestHeaders: 'RequestHeaders',
      responseHeaders: 'ResponseHeaders',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cookies: { 'type': 'array', 'itemType': 'string' },
      requestHeaders: { 'type': 'array', 'itemType': 'string' },
      responseHeaders: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafFilterResponseBodyFilterFieldsLogicsValidator extends $tea.Model {
  /**
   * @remarks
   * The error message when the validation fails.
   * 
   * @example
   * Enter a valid expression
   */
  errMsg?: string;
  /**
   * @remarks
   * The length of the value.
   */
  length?: WafQuotaInteger;
  /**
   * @remarks
   * The regular expression pattern of the value, which is used to validate strings.
   * 
   * @example
   * ^example$
   */
  pattern?: string;
  /**
   * @remarks
   * The range of the value, which is used to validate numbers.
   */
  range?: WafQuotaInteger;
  static names(): { [key: string]: string } {
    return {
      errMsg: 'ErrMsg',
      length: 'Length',
      pattern: 'Pattern',
      range: 'Range',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errMsg: 'string',
      length: WafQuotaInteger,
      pattern: 'string',
      range: WafQuotaInteger,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafFilterResponseBodyFilterFieldsLogics extends $tea.Model {
  /**
   * @remarks
   * A custom attribute. For example, this parameter can specify whether the value is case-sensitive.
   * 
   * @example
   * 1
   */
  attributes?: number;
  /**
   * @remarks
   * The type of the value input box. Valid values:
   * 
   * *   select:single
   * *   select:multi
   * *   input:single
   * *   input:multi
   * 
   * @example
   * input:single
   */
  kind?: string;
  /**
   * @remarks
   * Indicates whether the match result is inverted.
   */
  negative?: boolean;
  /**
   * @remarks
   * The displayed matching characters.
   * 
   * @example
   * Does not equal
   */
  operator?: string;
  /**
   * @remarks
   * The matching characters in the system.
   * 
   * @example
   * eq
   */
  symbol?: string;
  /**
   * @remarks
   * The tip on how to enter a valid value that is required by the rules.
   * 
   * @example
   * e.g. image/jpeg
   */
  tip?: string;
  /**
   * @remarks
   * The type of the value. Valid values:
   * 
   * *   integer
   * *   integer_slice
   * *   string
   * *   string_slice
   * 
   * @example
   * string
   */
  type?: string;
  /**
   * @remarks
   * The validator, which defines the validation rules for a value.
   */
  validator?: GetWafFilterResponseBodyFilterFieldsLogicsValidator;
  static names(): { [key: string]: string } {
    return {
      attributes: 'Attributes',
      kind: 'Kind',
      negative: 'Negative',
      operator: 'Operator',
      symbol: 'Symbol',
      tip: 'Tip',
      type: 'Type',
      validator: 'Validator',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attributes: 'number',
      kind: 'string',
      negative: 'boolean',
      operator: 'string',
      symbol: 'string',
      tip: 'string',
      type: 'string',
      validator: GetWafFilterResponseBodyFilterFieldsLogicsValidator,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafFilterResponseBodyFilterFieldsSelectorData extends $tea.Model {
  /**
   * @remarks
   * The label of the data.
   * 
   * @example
   * China
   */
  label?: string;
  /**
   * @remarks
   * The value of the data.
   * 
   * @example
   * CN
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      label: 'Label',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      label: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafFilterResponseBodyFilterFieldsSelector extends $tea.Model {
  /**
   * @remarks
   * The data. This parameter is available only when the value of the Kind parameter is data.
   */
  data?: GetWafFilterResponseBodyFilterFieldsSelectorData[];
  /**
   * @remarks
   * The type of selector. Valid values: data and others.
   * 
   * @example
   * data
   */
  kind?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      kind: 'Kind',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': GetWafFilterResponseBodyFilterFieldsSelectorData },
      kind: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafFilterResponseBodyFilterFields extends $tea.Model {
  /**
   * @remarks
   * The field for matched objects in the system.
   * 
   * @example
   * http.request.headers
   */
  key?: string;
  /**
   * @remarks
   * The label of the matched object.
   * 
   * @example
   * Header
   */
  label?: string;
  /**
   * @remarks
   * The logical conditions.
   */
  logics?: GetWafFilterResponseBodyFilterFieldsLogics[];
  /**
   * @remarks
   * The selector, which defines how to select a matched object.
   */
  selector?: GetWafFilterResponseBodyFilterFieldsSelector;
  /**
   * @remarks
   * Indicates whether the matched object contains a subfield.
   * 
   * @example
   * true
   */
  sub?: boolean;
  /**
   * @remarks
   * The tip on how to enter a subfield.
   * 
   * @example
   * e.g. Content-Type
   */
  subTip?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      label: 'Label',
      logics: 'Logics',
      selector: 'Selector',
      sub: 'Sub',
      subTip: 'SubTip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      label: 'string',
      logics: { 'type': 'array', 'itemType': GetWafFilterResponseBodyFilterFieldsLogics },
      selector: GetWafFilterResponseBodyFilterFieldsSelector,
      sub: 'boolean',
      subTip: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafFilterResponseBodyFilter extends $tea.Model {
  /**
   * @remarks
   * The matched objects and related properties.
   */
  fields?: GetWafFilterResponseBodyFilterFields[];
  /**
   * @remarks
   * The WAF rule category.
   * 
   * @example
   * http_bot
   */
  phase?: string;
  /**
   * @remarks
   * The condition for matching incoming requests.
   * 
   * @example
   * characteristics
   */
  target?: string;
  /**
   * @remarks
   * The rule type.
   * 
   * @example
   * http_custom_cc
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      fields: 'Fields',
      phase: 'Phase',
      target: 'Target',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fields: { 'type': 'array', 'itemType': GetWafFilterResponseBodyFilterFields },
      phase: 'string',
      target: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafQuotaResponseBodyQuotaList extends $tea.Model {
  /**
   * @remarks
   * Indicates whether custom lists are enabled.
   */
  enable?: boolean;
  /**
   * @remarks
   * The quota information about all item types in the custom lists.
   */
  items?: { [key: string]: QuotaListItemsValue };
  /**
   * @remarks
   * The maximum number of items in each custom list.
   */
  numberItemsPerList?: WafQuotaInteger;
  /**
   * @remarks
   * The maximum number of items in all custom lists.
   */
  numberItemsTotal?: WafQuotaInteger;
  /**
   * @remarks
   * The maximum number of custom lists.
   */
  numberTotal?: WafQuotaInteger;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      items: 'Items',
      numberItemsPerList: 'NumberItemsPerList',
      numberItemsTotal: 'NumberItemsTotal',
      numberTotal: 'NumberTotal',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
      items: { 'type': 'map', 'keyType': 'string', 'valueType': QuotaListItemsValue },
      numberItemsPerList: WafQuotaInteger,
      numberItemsTotal: WafQuotaInteger,
      numberTotal: WafQuotaInteger,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafQuotaResponseBodyQuotaManagedRulesGroup extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the WAF managed rule group is enabled.
   */
  enable?: boolean;
  /**
   * @remarks
   * The maximum number of WAF managed rule groups.
   */
  numberTotal?: WafQuotaInteger;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      numberTotal: 'NumberTotal',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
      numberTotal: WafQuotaInteger,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafQuotaResponseBodyQuotaPage extends $tea.Model {
  /**
   * @remarks
   * The quota information about custom error pages of all Content-Types.
   */
  contentTypes?: { [key: string]: QuotaPageContentTypesValue };
  /**
   * @remarks
   * Indicates whether custom error pages are enabled.
   */
  enable?: boolean;
  /**
   * @remarks
   * The maximum number of custom error pages.
   */
  numberTotal?: WafQuotaInteger;
  static names(): { [key: string]: string } {
    return {
      contentTypes: 'ContentTypes',
      enable: 'Enable',
      numberTotal: 'NumberTotal',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentTypes: { 'type': 'map', 'keyType': 'string', 'valueType': QuotaPageContentTypesValue },
      enable: 'boolean',
      numberTotal: WafQuotaInteger,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafQuotaResponseBodyQuotaScenePolicy extends $tea.Model {
  /**
   * @remarks
   * Indicates whether scenario-specific policies are enabled.
   */
  enable?: boolean;
  /**
   * @remarks
   * The maximum number of scenario-specific policies.
   */
  numberTotal?: WafQuotaInteger;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      numberTotal: 'NumberTotal',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
      numberTotal: WafQuotaInteger,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafQuotaResponseBodyQuota extends $tea.Model {
  /**
   * @remarks
   * The quota information about custom lists.
   */
  list?: GetWafQuotaResponseBodyQuotaList;
  /**
   * @remarks
   * The quota information about WAF managed rule groups.
   */
  managedRulesGroup?: GetWafQuotaResponseBodyQuotaManagedRulesGroup;
  /**
   * @remarks
   * The quota information about custom error pages.
   */
  page?: GetWafQuotaResponseBodyQuotaPage;
  /**
   * @remarks
   * The quota information about scenario-specific policies.
   */
  scenePolicy?: GetWafQuotaResponseBodyQuotaScenePolicy;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      managedRulesGroup: 'ManagedRulesGroup',
      page: 'Page',
      scenePolicy: 'ScenePolicy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: GetWafQuotaResponseBodyQuotaList,
      managedRulesGroup: GetWafQuotaResponseBodyQuotaManagedRulesGroup,
      page: GetWafQuotaResponseBodyQuotaPage,
      scenePolicy: GetWafQuotaResponseBodyQuotaScenePolicy,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCacheReserveInstancesResponseBodyInstanceInfo extends $tea.Model {
  /**
   * @remarks
   * The capacity of the cache reserve instance. Unit: GB.
   * 
   * @example
   * 512000
   */
  cacheReserveCapacity?: string;
  /**
   * @remarks
   * The region in which the cache reserve instance resides.
   * 
   * @example
   * HK
   */
  cacheReserveRegion?: string;
  /**
   * @remarks
   * The time when the cache reserve instance was purchased.
   * 
   * @example
   * 2024-04-12T05:41:51Z
   */
  createTime?: string;
  /**
   * @remarks
   * The subscription period of the cache reserve instance. Unit: months.
   * 
   * @example
   * 3
   */
  duration?: number;
  /**
   * @remarks
   * The time when the cache reserve instance expires.
   * 
   * @example
   * 2024-10-05T16:00:00Z
   */
  expireTime?: string;
  /**
   * @remarks
   * The ID of the cache reserve instance.
   * 
   * @example
   * sp-xcdn-96wblslz****
   */
  instanceId?: string;
  /**
   * @remarks
   * The status of the cache reserve instance. Valid values:
   * 
   * *   online: The instance is in service.
   * *   offline: The instance has expired within an allowable period. In this state, the plan is unavailable.
   * *   disable: The instance is released.
   * *   overdue: The service was stopped due to overdue payments.
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      cacheReserveCapacity: 'CacheReserveCapacity',
      cacheReserveRegion: 'CacheReserveRegion',
      createTime: 'CreateTime',
      duration: 'Duration',
      expireTime: 'ExpireTime',
      instanceId: 'InstanceId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheReserveCapacity: 'string',
      cacheReserveRegion: 'string',
      createTime: 'string',
      duration: 'number',
      expireTime: 'string',
      instanceId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientCertificatesResponseBodyResult extends $tea.Model {
  /**
   * @remarks
   * The ID of the CA certificate.
   * 
   * @example
   * baba39055622c008b90285a8838ed09a
   */
  CACertificateId?: string;
  /**
   * @remarks
   * The Common Name of the certificate.
   * 
   * @example
   * www.example.com
   */
  commonName?: string;
  /**
   * @remarks
   * The time when the certificate was created.
   * 
   * @example
   * 2024-06-24 07:48:51
   */
  createTime?: string;
  /**
   * @remarks
   * The certificate ID.
   * 
   * @example
   * babab9db65ee5efcca9f3d41d4b50d66
   */
  id?: string;
  /**
   * @remarks
   * The certificate authority (CA) that issued the certificate.
   * 
   * @example
   * GlobalSign nv-sa
   */
  issuer?: string;
  /**
   * @remarks
   * The certificate name.
   * 
   * @example
   * yourCertName
   */
  name?: string;
  /**
   * @remarks
   * The time when the certificate expires.
   * 
   * @example
   * 2024-03-31 02:08:00
   */
  notAfter?: string;
  /**
   * @remarks
   * The time when the certificate takes effect.
   * 
   * @example
   * 2023-03-31 02:08:00
   */
  notBefore?: string;
  /**
   * @remarks
   * The public key algorithm of the certificate.
   * 
   * @example
   * RSA
   */
  pubkeyAlgorithm?: string;
  /**
   * @remarks
   * The Subject Alternative Name (SAN) of the certificate.
   * 
   * @example
   * www.example.com,*.example.com
   */
  SAN?: string;
  /**
   * @remarks
   * The signature algorithm of the certificate.
   * 
   * @example
   * SHA256-RSA
   */
  signatureAlgorithm?: string;
  /**
   * @remarks
   * The certificate status.
   * 
   * @example
   * active
   */
  status?: string;
  /**
   * @remarks
   * The certificate type.
   * 
   * @example
   * dcdn
   */
  type?: string;
  /**
   * @remarks
   * The time when the certificate was updated.
   * 
   * @example
   * 2024-07-20 06:18:42
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      CACertificateId: 'CACertificateId',
      commonName: 'CommonName',
      createTime: 'CreateTime',
      id: 'Id',
      issuer: 'Issuer',
      name: 'Name',
      notAfter: 'NotAfter',
      notBefore: 'NotBefore',
      pubkeyAlgorithm: 'PubkeyAlgorithm',
      SAN: 'SAN',
      signatureAlgorithm: 'SignatureAlgorithm',
      status: 'Status',
      type: 'Type',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      CACertificateId: 'string',
      commonName: 'string',
      createTime: 'string',
      id: 'string',
      issuer: 'string',
      name: 'string',
      notAfter: 'string',
      notBefore: 'string',
      pubkeyAlgorithm: 'string',
      SAN: 'string',
      signatureAlgorithm: 'string',
      status: 'string',
      type: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppRecordsResponseBodyRecords extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The CNAME of the associated domain name.
   * 
   * @example
   * kdxceo****.yun****.com
   */
  cname?: string;
  /**
   * @remarks
   * The configuration ID of the associated domain name.
   * 
   * @example
   * 27522948436****
   */
  configId?: number;
  /**
   * @remarks
   * The time when the domain name was added. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2023-12-24T02:01:11Z
   */
  createTime?: string;
  /**
   * @remarks
   * The record ID of the associated domain name.
   * 
   * @example
   * 266****
   */
  recordId?: number;
  /**
   * @remarks
   * The associated domain name.
   * 
   * @example
   * a.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The scheduling domain ID of the associated domain name.
   * 
   * @example
   * 123456
   */
  schemdId?: number;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 5407498413****
   */
  siteId?: number;
  /**
   * @remarks
   * The time when the scheduling domain ID or CNAME was last modified. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2021-12-22T08:32:02Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      cname: 'Cname',
      configId: 'ConfigId',
      createTime: 'CreateTime',
      recordId: 'RecordId',
      recordName: 'RecordName',
      schemdId: 'SchemdId',
      siteId: 'SiteId',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      cname: 'string',
      configId: 'number',
      createTime: 'string',
      recordId: 'number',
      recordName: 'string',
      schemdId: 'number',
      siteId: 'number',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppVersionsResponseBodyVersionsContainersProbeContent extends $tea.Model {
  /**
   * @remarks
   * The probe command.
   * 
   * @example
   * openresty -g  "daemon off;
   */
  command?: string;
  /**
   * @remarks
   * The number of consecutive failed health checks required for a container to be considered as unhealthy.
   * 
   * @example
   * 3
   */
  failureThreshold?: number;
  /**
   * @remarks
   * The domain name that is used for health checks.
   * 
   * @example
   * test.com
   */
  host?: string;
  /**
   * @remarks
   * The request headers that are included in the container health check request.
   * 
   * @example
   * {\\"Content-Type\\":\\"application/json\\"}
   */
  httpHeaders?: string;
  /**
   * @remarks
   * The latency for container probe initialization.
   * 
   * @example
   * 10
   */
  initialDelaySeconds?: number;
  /**
   * @remarks
   * The path of the container health check.
   * 
   * @example
   * /health_check
   */
  path?: string;
  /**
   * @remarks
   * The interval between container health checks.
   * 
   * @example
   * 5
   */
  periodSeconds?: number;
  /**
   * @remarks
   * The port of the container health check.
   * 
   * @example
   * 80
   */
  port?: number;
  /**
   * @remarks
   * The protocol that the container health check request uses.
   * 
   * @example
   * http
   */
  scheme?: string;
  /**
   * @remarks
   * The number of consecutive successful health checks required for a container to be considered as healthy.
   * 
   * @example
   * 1
   */
  successThreshold?: number;
  /**
   * @remarks
   * The timeout period of the container health check.
   * 
   * @example
   * 30
   */
  timeoutSeconds?: number;
  static names(): { [key: string]: string } {
    return {
      command: 'Command',
      failureThreshold: 'FailureThreshold',
      host: 'Host',
      httpHeaders: 'HttpHeaders',
      initialDelaySeconds: 'InitialDelaySeconds',
      path: 'Path',
      periodSeconds: 'PeriodSeconds',
      port: 'Port',
      scheme: 'Scheme',
      successThreshold: 'SuccessThreshold',
      timeoutSeconds: 'TimeoutSeconds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      command: 'string',
      failureThreshold: 'number',
      host: 'string',
      httpHeaders: 'string',
      initialDelaySeconds: 'number',
      path: 'string',
      periodSeconds: 'number',
      port: 'number',
      scheme: 'string',
      successThreshold: 'number',
      timeoutSeconds: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppVersionsResponseBodyVersionsContainers extends $tea.Model {
  /**
   * @remarks
   * The arguments that are passed to the container startup command.
   * 
   * @example
   * -c a=1
   */
  args?: string;
  /**
   * @remarks
   * The command that is used to start the container.
   * 
   * @example
   * openresty -g \\"daemon off;\\"
   */
  command?: string;
  /**
   * @remarks
   * The environment variables of the container.
   * 
   * @example
   * ENV=prod
   */
  envVariables?: string;
  /**
   * @remarks
   * The address of the container image.
   * 
   * @example
   * nginx
   */
  image?: string;
  /**
   * @remarks
   * The container name.
   * 
   * @example
   * container1
   */
  name?: string;
  /**
   * @remarks
   * The command that is run before the container is started. Format: `{"exec":{"command":["cat","/etc/group"\\]}}`.
   * 
   * If you want to cancel this configuration, set the parameter value to `""` or `{}`. If you do not specify this parameter, this configuration is ignored.
   * 
   * @example
   * {\\"exec\\":{\\"command\\":[\\"bash\\",\\"-c\\",\\"cd /home/admin/
   */
  postStart?: string;
  /**
   * @remarks
   * The command that is run before the container is stopped.
   * 
   * @example
   * sh stop.sh
   */
  preStop?: string;
  /**
   * @remarks
   * The container probe content.
   */
  probeContent?: ListEdgeContainerAppVersionsResponseBodyVersionsContainersProbeContent;
  /**
   * @remarks
   * The probe type of the container.
   * 
   * @example
   * httpGet
   */
  probeType?: string;
  /**
   * @remarks
   * The compute specification of the container.
   * 
   * @example
   * 1C2G
   */
  spec?: string;
  static names(): { [key: string]: string } {
    return {
      args: 'Args',
      command: 'Command',
      envVariables: 'EnvVariables',
      image: 'Image',
      name: 'Name',
      postStart: 'PostStart',
      preStop: 'PreStop',
      probeContent: 'ProbeContent',
      probeType: 'ProbeType',
      spec: 'Spec',
    };
  }

  static types(): { [key: string]: any } {
    return {
      args: 'string',
      command: 'string',
      envVariables: 'string',
      image: 'string',
      name: 'string',
      postStart: 'string',
      preStop: 'string',
      probeContent: ListEdgeContainerAppVersionsResponseBodyVersionsContainersProbeContent,
      probeType: 'string',
      spec: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppVersionsResponseBodyVersions extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The containers in the version.
   */
  containers?: ListEdgeContainerAppVersionsResponseBodyVersionsContainers[];
  /**
   * @remarks
   * The time when the version was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2022-11-10T02:53:16Z
   */
  createTime?: string;
  /**
   * @remarks
   * The time when the version was last released. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2023-02-10T02:48:36Z
   */
  lastPublishTime?: string;
  /**
   * @remarks
   * The version name.
   * 
   * @example
   * version01
   */
  name?: string;
  /**
   * @remarks
   * The time when the version was released. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2023-02-10T02:48:36Z
   */
  publishTime?: string;
  /**
   * @remarks
   * The remarks.
   * 
   * @example
   * test version
   */
  remarks?: string;
  /**
   * @remarks
   * The status of the current version. Valid values:
   * 
   * *   **created**
   * *   **failed**
   * *   **creating**
   * 
   * @example
   * created
   */
  status?: string;
  /**
   * @remarks
   * The time when the version was last modified. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2023-04-16 10:51:00
   */
  updateTime?: string;
  /**
   * @remarks
   * The version ID.
   * 
   * @example
   * ver-87962637161651****
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      containers: 'Containers',
      createTime: 'CreateTime',
      lastPublishTime: 'LastPublishTime',
      name: 'Name',
      publishTime: 'PublishTime',
      remarks: 'Remarks',
      status: 'Status',
      updateTime: 'UpdateTime',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      containers: { 'type': 'array', 'itemType': ListEdgeContainerAppVersionsResponseBodyVersionsContainers },
      createTime: 'string',
      lastPublishTime: 'string',
      name: 'string',
      publishTime: 'string',
      remarks: 'string',
      status: 'string',
      updateTime: 'string',
      versionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppsResponseBodyAppsHealthCheck extends $tea.Model {
  /**
   * @remarks
   * The number of consecutive failed health checks for an application to be considered unhealthy.
   * 
   * @example
   * 5
   */
  failTimes?: number;
  /**
   * @remarks
   * The domain name that is used for health checks.
   * 
   * @example
   * test.com
   */
  host?: string;
  /**
   * @remarks
   * The range of health check status codes that indicate successful health checks.
   * 
   * @example
   * http_2XX
   */
  httpCode?: string;
  /**
   * @remarks
   * The interval between health checks. Unit: seconds.
   * 
   * @example
   * 5
   */
  interval?: number;
  /**
   * @remarks
   * The HTTP method used for health checks.
   * 
   * @example
   * GET
   */
  method?: string;
  /**
   * @remarks
   * The health check port.
   * 
   * @example
   * 8080
   */
  port?: number;
  /**
   * @remarks
   * The number of consecutive successful health checks for an application to be considered healthy.
   * 
   * @example
   * 1
   */
  succTimes?: number;
  /**
   * @remarks
   * The timeout period of health checks. Unit: seconds.
   * 
   * @example
   * 60
   */
  timeout?: number;
  /**
   * @remarks
   * The type of health checks. Valid values:
   * 
   * *   l7
   * *   l4
   * 
   * @example
   * l7
   */
  type?: string;
  /**
   * @remarks
   * The health check URL.
   * 
   * @example
   * /health_check
   */
  uri?: string;
  static names(): { [key: string]: string } {
    return {
      failTimes: 'FailTimes',
      host: 'Host',
      httpCode: 'HttpCode',
      interval: 'Interval',
      method: 'Method',
      port: 'Port',
      succTimes: 'SuccTimes',
      timeout: 'Timeout',
      type: 'Type',
      uri: 'Uri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failTimes: 'number',
      host: 'string',
      httpCode: 'string',
      interval: 'number',
      method: 'string',
      port: 'number',
      succTimes: 'number',
      timeout: 'number',
      type: 'string',
      uri: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppsResponseBodyApps extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The time when the version was created.
   * 
   * @example
   * 2022-12-01T16:16:27.418298794+08:00
   */
  createTime?: string;
  /**
   * @remarks
   * The domain name associated with the application.
   * 
   * @example
   * test.com
   */
  domainName?: string;
  /**
   * @remarks
   * The type of the gateway. Valid values:
   * 
   * *   l7: Layer 7 gateway.
   * *   l4: Layer 4 gateway.
   * 
   * @example
   * l7
   */
  gatewayType?: string;
  /**
   * @remarks
   * The information about health checks.
   */
  healthCheck?: ListEdgeContainerAppsResponseBodyAppsHealthCheck;
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * app-test
   */
  name?: string;
  /**
   * @remarks
   * The progress of the application creation task in percentage.
   * 
   * @example
   * 100
   */
  percentage?: number;
  /**
   * @remarks
   * Indicates whether QUIC is enabled.
   * 
   * @example
   * false
   */
  quicCid?: string;
  /**
   * @remarks
   * The remarks.
   * 
   * @example
   * test app
   */
  remarks?: string;
  /**
   * @remarks
   * The server port. Valid values: 1 to 65535.
   * 
   * @example
   * 80
   */
  servicePort?: number;
  /**
   * @remarks
   * The status of the application. Valid values:
   * 
   * *   creating: The application is being created.
   * *   failed: The application failed to be created.
   * *   created: The application is created.
   * 
   * @example
   * created
   */
  status?: string;
  /**
   * @remarks
   * The backend port, which is also the service port of the application. Valid values: 1 to 65535.
   * 
   * @example
   * 80
   */
  targetPort?: number;
  /**
   * @remarks
   * The time when the application was last modified. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2023-11-15T12:11:02Z
   */
  updateTime?: string;
  /**
   * @remarks
   * The number of versions of the application.
   * 
   * @example
   * 10
   */
  versionCount?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      createTime: 'CreateTime',
      domainName: 'DomainName',
      gatewayType: 'GatewayType',
      healthCheck: 'HealthCheck',
      name: 'Name',
      percentage: 'Percentage',
      quicCid: 'QuicCid',
      remarks: 'Remarks',
      servicePort: 'ServicePort',
      status: 'Status',
      targetPort: 'TargetPort',
      updateTime: 'UpdateTime',
      versionCount: 'VersionCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      createTime: 'string',
      domainName: 'string',
      gatewayType: 'string',
      healthCheck: ListEdgeContainerAppsResponseBodyAppsHealthCheck,
      name: 'string',
      percentage: 'number',
      quicCid: 'string',
      remarks: 'string',
      servicePort: 'number',
      status: 'string',
      targetPort: 'number',
      updateTime: 'string',
      versionCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerRecordsResponseBodyRecords extends $tea.Model {
  /**
   * @remarks
   * The time when the record was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-12-24T02:01:11Z
   */
  createTime?: string;
  /**
   * @remarks
   * The CNAME. If you use CNAME setup when you add your website to ESA, the value is the CNAME that you configured.
   * 
   * @example
   * a.example.com.cnamezone.com
   */
  recordCname?: string;
  /**
   * @remarks
   * The record name.
   * 
   * @example
   * a.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The time when the record was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2021-12-22T08:32:02Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      recordCname: 'RecordCname',
      recordName: 'RecordName',
      siteId: 'SiteId',
      siteName: 'SiteName',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      recordCname: 'string',
      recordName: 'string',
      siteId: 'number',
      siteName: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeRoutinePlansResponseBodyPlanInfo extends $tea.Model {
  /**
   * @remarks
   * The billing method. Valid values:
   * 
   * *   PREPAY: subscription.
   * *   POSTPAY: pay-as-you-go.
   * 
   * @example
   * POSTPAY
   */
  billingMode?: string;
  /**
   * @remarks
   * The maximum number of versions that each routine supports.
   * 
   * @example
   * 20
   */
  erRoutineCodeVersionQuota?: string;
  /**
   * @remarks
   * The maximum of routines that can be created.
   * 
   * @example
   * 100
   */
  erRoutineQuota?: string;
  /**
   * @remarks
   * The maximum number of websites with which each routine can be associated.
   * 
   * @example
   * 100
   */
  erRoutineRouteSiteCountQuota?: string;
  /**
   * @remarks
   * The payment method. Valid values:
   * 
   * *   er_free
   * *   er_pay
   * 
   * @example
   * er_free
   */
  paymentMethod?: string;
  /**
   * @remarks
   * The plan name.
   * 
   * @example
   * test_plan
   */
  planName?: string;
  static names(): { [key: string]: string } {
    return {
      billingMode: 'BillingMode',
      erRoutineCodeVersionQuota: 'ErRoutineCodeVersionQuota',
      erRoutineQuota: 'ErRoutineQuota',
      erRoutineRouteSiteCountQuota: 'ErRoutineRouteSiteCountQuota',
      paymentMethod: 'PaymentMethod',
      planName: 'PlanName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      billingMode: 'string',
      erRoutineCodeVersionQuota: 'string',
      erRoutineQuota: 'string',
      erRoutineRouteSiteCountQuota: 'string',
      paymentMethod: 'string',
      planName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeRoutineRecordsResponseBodyRecords extends $tea.Model {
  /**
   * @remarks
   * The time when the record was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-12-24T02:01:11Z
   */
  createTime?: string;
  /**
   * @remarks
   * The CNAME. If you use CNAME setup when you add your website to ESA, the value is the CNAME that you configured then.
   * 
   * @example
   * a.example.com.cnamezone.com
   */
  recordCname?: string;
  /**
   * @remarks
   * The record name.
   * 
   * @example
   * a.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 5407498413****
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The time when the record was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-12-22T08:32:02Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      recordCname: 'RecordCname',
      recordName: 'RecordName',
      siteId: 'SiteId',
      siteName: 'SiteName',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      recordCname: 'string',
      recordName: 'string',
      siteId: 'number',
      siteName: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceQuotasResponseBodyQuotas extends $tea.Model {
  /**
   * @remarks
   * The quota name.
   * 
   * @example
   * customHttpCert
   */
  quotaName?: string;
  /**
   * @remarks
   * The quota value.
   * 
   * @example
   * 10
   */
  quotaValue?: string;
  /**
   * @remarks
   * The threshold type of the quota. Valid values:
   * 
   * *   value: enumerates the values of the quota.
   * *   bool: specifies whether the quota is available.
   * *   num: the upper limit of the quota.
   * *   range: the value range for the quota.
   * *   custom: other types than the preceding four quota threshold types.
   * 
   * @example
   * bool
   */
  quotaValueType?: string;
  static names(): { [key: string]: string } {
    return {
      quotaName: 'QuotaName',
      quotaValue: 'QuotaValue',
      quotaValueType: 'QuotaValueType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quotaName: 'string',
      quotaValue: 'string',
      quotaValueType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceQuotasWithUsageResponseBodyQuotasSiteUsage extends $tea.Model {
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 34818329392****
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * test.top
   */
  siteName?: string;
  /**
   * @remarks
   * The quota usage of the website.
   * 
   * @example
   * 1
   */
  siteUsage?: string;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      siteName: 'SiteName',
      siteUsage: 'SiteUsage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      siteName: 'string',
      siteUsage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceQuotasWithUsageResponseBodyQuotas extends $tea.Model {
  /**
   * @remarks
   * The quota name.
   * 
   * @example
   * redirect_rules|rule_quota
   */
  quotaName?: string;
  /**
   * @remarks
   * The quota value.
   * 
   * @example
   * 10
   */
  quotaValue?: string;
  /**
   * @remarks
   * The usage of the quota in each website associated with the plan.
   */
  siteUsage?: ListInstanceQuotasWithUsageResponseBodyQuotasSiteUsage[];
  /**
   * @remarks
   * The quota usage.
   * 
   * @example
   * 3
   */
  usage?: string;
  static names(): { [key: string]: string } {
    return {
      quotaName: 'QuotaName',
      quotaValue: 'QuotaValue',
      siteUsage: 'SiteUsage',
      usage: 'Usage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quotaName: 'string',
      quotaValue: 'string',
      siteUsage: { 'type': 'array', 'itemType': ListInstanceQuotasWithUsageResponseBodyQuotasSiteUsage },
      usage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListKvsResponseBodyKeys extends $tea.Model {
  /**
   * @remarks
   * The key name.
   * 
   * @example
   * Key1
   */
  name?: string;
  /**
   * @remarks
   * The time when the key was last updated.
   * 
   * @example
   * 2021-12-13T07:46:03Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListListsRequestQueryArgs extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to sort the returned data in descending order.
   * 
   * @example
   * true
   */
  desc?: boolean;
  /**
   * @remarks
   * The list description for fuzzy search.
   * 
   * @example
   * a custom list
   */
  descriptionLike?: string;
  /**
   * @remarks
   * The list ID for fuzzy search.
   * 
   * @example
   * 40000001
   */
  idLike?: string;
  /**
   * @remarks
   * The list content for fuzzy search.
   * 
   * @example
   * 10.1.1.1
   */
  itemLike?: string;
  /**
   * @example
   * ip
   */
  kind?: string;
  /**
   * @remarks
   * The list name and content for fuzzy search.
   * 
   * @example
   * 10.1.1.1
   */
  nameItemLike?: string;
  /**
   * @remarks
   * The list name for fuzzy search.
   * 
   * @example
   * example
   */
  nameLike?: string;
  /**
   * @remarks
   * The column by which you want to sort the returned data.
   * 
   * @example
   * id
   */
  orderBy?: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      descriptionLike: 'DescriptionLike',
      idLike: 'IdLike',
      itemLike: 'ItemLike',
      kind: 'Kind',
      nameItemLike: 'NameItemLike',
      nameLike: 'NameLike',
      orderBy: 'OrderBy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'boolean',
      descriptionLike: 'string',
      idLike: 'string',
      itemLike: 'string',
      kind: 'string',
      nameItemLike: 'string',
      nameLike: 'string',
      orderBy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListListsResponseBodyLists extends $tea.Model {
  /**
   * @remarks
   * The list description.
   * 
   * @example
   * a custom list
   */
  description?: string;
  /**
   * @remarks
   * The ID of the custom list.[](~~2850217~~)
   * 
   * @example
   * 40000001
   */
  id?: number;
  /**
   * @remarks
   * The list type.
   * 
   * @example
   * ip
   */
  kind?: string;
  /**
   * @remarks
   * The length of the list information array, which indicates how many items the list contains.
   * 
   * @example
   * 100
   */
  length?: number;
  /**
   * @remarks
   * The list name.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The time when the list was last modified.
   * 
   * @example
   * 2024-01-01T00:00:00Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      id: 'Id',
      kind: 'Kind',
      length: 'Length',
      name: 'Name',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      id: 'number',
      kind: 'string',
      length: 'number',
      name: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancerRegionsResponseBodyRegionsSubRegions extends $tea.Model {
  /**
   * @remarks
   * The Chinese name of the region.
   */
  subRegionCnName?: string;
  /**
   * @remarks
   * The code of the subregion.
   * 
   * @example
   * ID
   */
  subRegionCode?: string;
  /**
   * @remarks
   * The English name of the subregion.
   * 
   * @example
   * Indonesia
   */
  subRegionEnName?: string;
  static names(): { [key: string]: string } {
    return {
      subRegionCnName: 'SubRegionCnName',
      subRegionCode: 'SubRegionCode',
      subRegionEnName: 'SubRegionEnName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subRegionCnName: 'string',
      subRegionCode: 'string',
      subRegionEnName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancerRegionsResponseBodyRegions extends $tea.Model {
  /**
   * @remarks
   * The Chinese name of the region.
   */
  regionCnName?: string;
  /**
   * @remarks
   * The code of the region.
   * 
   * @example
   * SEAS
   */
  regionCode?: string;
  /**
   * @remarks
   * The English name of the region.
   * 
   * @example
   * South East Asia
   */
  regionEnName?: string;
  /**
   * @remarks
   * The subregions of the region.
   */
  subRegions?: ListLoadBalancerRegionsResponseBodyRegionsSubRegions[];
  static names(): { [key: string]: string } {
    return {
      regionCnName: 'RegionCnName',
      regionCode: 'RegionCode',
      regionEnName: 'RegionEnName',
      subRegions: 'SubRegions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionCnName: 'string',
      regionCode: 'string',
      regionEnName: 'string',
      subRegions: { 'type': 'array', 'itemType': ListLoadBalancerRegionsResponseBodyRegionsSubRegions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListManagedRulesGroupsResponseBodyManagedRulesGroups extends $tea.Model {
  /**
   * @remarks
   * The name of the managed rule group.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The number of rules in the managed rule group.
   * 
   * @example
   * 1000
   */
  ruleCount?: number;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      ruleCount: 'RuleCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      ruleCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPagesResponseBodyPages extends $tea.Model {
  /**
   * @remarks
   * The Base64-encoded content of the error page. The content type is specified by the Content-Type field.
   * 
   * This parameter is required.
   * 
   * @example
   * PGh0bWw+aGVsbG8gcGFnZTwvaHRtbD4=
   */
  content?: string;
  /**
   * @remarks
   * The Content-Type field in the HTTP header.
   * 
   * This parameter is required.
   * 
   * @example
   * text/html
   */
  contentType?: string;
  /**
   * @remarks
   * The description of the custom error page.
   * 
   * @example
   * a custom deny page
   */
  description?: string;
  /**
   * @remarks
   * The ID of the custom error page.[](~~2850223~~)
   * 
   * @example
   * 50000001
   */
  id?: number;
  /**
   * @remarks
   * The type of the custom error page.
   * 
   * @example
   * custom
   */
  kind?: string;
  /**
   * @remarks
   * The name of the custom error page.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The time when the custom error page was last modified.
   * 
   * @example
   * 2024-01-01T00:00:00Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      contentType: 'ContentType',
      description: 'Description',
      id: 'Id',
      kind: 'Kind',
      name: 'Name',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      contentType: 'string',
      description: 'string',
      id: 'number',
      kind: 'string',
      name: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRecordsResponseBodyRecordsAuthConf extends $tea.Model {
  /**
   * @remarks
   * The access key of the account to which the origin server belongs. This value is returned when the SourceType is OSS, and AuthType is private_cross_account, or when the SourceType is S3 and AuthType is private.
   * 
   * @example
   * u0Nkg5gBK***QF5wvKMM504JUHt
   */
  accessKey?: string;
  /**
   * @remarks
   * The authentication type of the origin server. Different origins support different authentication types. The type of origin refers to the SourceType parameter in this operation. If the type of origin is OSS or S3, the authentication type of the origin must be specified. Valid values:
   * 
   * *   **public**: public read. This value is returned when the origin is a public OSS or S3 bucket.
   * *   **private**: private read. This value is returned when the origin is a private S3 bucket.
   * *   **private_same_account**: private read under the same account. This value is returned when the origin is a private OSS bucket in your Alibaba Cloud account.
   * *   **private_cross_account**: private read across accounts. This value is returned when the origin is a private OSS bucket in a different Alibaba Cloud account.
   * 
   * @example
   * private
   */
  authType?: string;
  /**
   * @remarks
   * The region of the origin. This parameter is returned if the origin type is S3. You can get the region information from the official website of Amazon S3.
   * 
   * @example
   * us-east-1
   */
  region?: string;
  /**
   * @remarks
   * The secret access key of the account to which the origin server belongs. This value is returned when the SourceType is OSS, and AuthType is private_same_account, or when the SourceType is S3 and AuthType is private.
   * 
   * @example
   * VIxuvJSA2S03f***kp208dy5w7
   */
  secretKey?: string;
  /**
   * @remarks
   * The version of the signature algorithm. This value is returned when the origin type is S3 and AuthType is private. Valid values:
   * 
   * *   **v2**
   * *   **v4**
   * 
   * If this parameter is left empty, the default value v4 is used.
   * 
   * @example
   * v4
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      authType: 'AuthType',
      region: 'Region',
      secretKey: 'SecretKey',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      authType: 'string',
      region: 'string',
      secretKey: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRecordsResponseBodyRecordsData extends $tea.Model {
  /**
   * @remarks
   * The encryption algorithm used for the record. Valid values: 0 to 255. Exclusive to CERT and SSHFP records.
   * 
   * @example
   * 0
   */
  algorithm?: number;
  /**
   * @remarks
   * The public key of the certificate. Exclusive to CERT, SMIMEA, and TLSA records.
   * 
   * @example
   * dGVzdGFkYWxrcw==
   */
  certificate?: string;
  /**
   * @remarks
   * The public key fingerprint of the record. Exclusive to SSHFP records.
   * 
   * @example
   * abcdef1234567890
   */
  fingerprint?: string;
  /**
   * @remarks
   * The flag bit of the record. The Flag for a CAA record indicates its priority and how it is processed. Valid values: 0 to 255. Exclusive to CAA records.
   * 
   * @example
   * 128
   */
  flag?: number;
  /**
   * @remarks
   * The public key identification for the record. Valid values: 0 to 65535. Exclusive to CERT records.
   * 
   * @example
   * 0
   */
  keyTag?: number;
  /**
   * @remarks
   * The algorithm policy used to match or validate the certificate. Valid values: 0 to 255. Exclusive to SMIMEA and TLSA records.
   * 
   * @example
   * 0
   */
  matchingType?: number;
  /**
   * @remarks
   * The port of the record. Valid values: 0 to 65535. Exclusive to SRV records.
   * 
   * @example
   * 80
   */
  port?: number;
  /**
   * @remarks
   * The priority of the record. Valid values: 0 to 65535. A smaller value indicates a higher priority. Exclusive to MX, SRV, and URI records.
   * 
   * @example
   * 0
   */
  priority?: number;
  /**
   * @remarks
   * The type of certificate or public key. Valid values: 0 to 255. Exclusive to SMIMEA, and TLSA records.
   * 
   * @example
   * 0
   */
  selector?: number;
  /**
   * @remarks
   * The tag of the record. The Tag of a CAA record indicate its specific type and usage. Exclusive to CAA records.
   * 
   * @example
   * issue
   */
  tag?: string;
  /**
   * @remarks
   * The certificate type of the record (in CERT records), or the public key type (in SSHFP records).
   * 
   * @example
   * 0
   */
  type?: number;
  /**
   * @remarks
   * The usage identifier of the record. Valid values: 0 to 255. Exclusive to SMIMEA, and TLSA records.
   * 
   * @example
   * 0
   */
  usage?: number;
  /**
   * @remarks
   * Record value or part of the record content. This value is returned when the record is A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, or URI. It has different meanings based on types of records:
   * 
   * *   **A/AAAA**: the IP addresses. IP addresses are separated by commas (,). There is at least one IPv4 address.
   * *   **CNAME**: the pointed/mapped domain name.
   * *   **NS**: the nameservers for the domain name.
   * *   **MX**: a valid domain name of the mail server.
   * *   **TXT**: a valid text string.
   * *   **CAA**: a valid domain name of the certificate authority.
   * *   **SRV**: a valid domain name of the target host.
   * *   **URI**: a valid URI string.
   * 
   * @example
   * CNAME
   */
  value?: string;
  /**
   * @remarks
   * The weight of the record. Valid values: 0 to 65535. Exclusive to SRV and URI records.
   * 
   * @example
   * 0
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      algorithm: 'Algorithm',
      certificate: 'Certificate',
      fingerprint: 'Fingerprint',
      flag: 'Flag',
      keyTag: 'KeyTag',
      matchingType: 'MatchingType',
      port: 'Port',
      priority: 'Priority',
      selector: 'Selector',
      tag: 'Tag',
      type: 'Type',
      usage: 'Usage',
      value: 'Value',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      algorithm: 'number',
      certificate: 'string',
      fingerprint: 'string',
      flag: 'number',
      keyTag: 'number',
      matchingType: 'number',
      port: 'number',
      priority: 'number',
      selector: 'number',
      tag: 'string',
      type: 'number',
      usage: 'number',
      value: 'string',
      weight: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRecordsResponseBodyRecords extends $tea.Model {
  /**
   * @remarks
   * The origin authentication information of the CNAME record.
   */
  authConf?: ListRecordsResponseBodyRecordsAuthConf;
  /**
   * @remarks
   * The business scenario of the record for acceleration. Valid values:
   * 
   * *   **image_video**: video and image.
   * *   **api**: API.
   * *   **web**: web page.
   * 
   * @example
   * web
   */
  bizName?: string;
  /**
   * @remarks
   * The comments of the record.
   * 
   * @example
   * this is a remark.
   */
  comment?: string;
  /**
   * @remarks
   * The time when the record was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-12-24T02:01:11Z
   */
  createTime?: string;
  /**
   * @remarks
   * The DNS record information. Different types of records contain different information.
   * 
   * @example
   * {"value":"1.1.1.1"}
   */
  data?: ListRecordsResponseBodyRecordsData;
  /**
   * @remarks
   * The origin host policy. This policy takes effect when the record type is CNAME. Valid values:
   * 
   * *   follow_hostname: matches the requested domain name.
   * *   follow_origin_domain: matches the origin\\"s domain name.
   * 
   * @example
   * follow_origin_domain
   */
  hostPolicy?: string;
  /**
   * @remarks
   * Indicates whether the record is proxied. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  proxied?: boolean;
  /**
   * @remarks
   * The CNAME. If you use CNAME setup when you add your website to ESA, the value is the CNAME that you configured then.
   * 
   * @example
   * a.example.com.cnamezone.com
   */
  recordCname?: string;
  /**
   * @remarks
   * The record ID.
   * 
   * @example
   * 1234567890123
   */
  recordId?: number;
  /**
   * @remarks
   * The record name.
   * 
   * @example
   * a.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The origin type for the CNAME record. This parameter is returned when you add a CNAME record. Valid values:
   * 
   * *   **OSS**: OSS bucket.
   * *   **S3**: S3 bucket.
   * *   **LB**: load balancer.
   * *   **OP**: origin pool.
   * *   **Domain**: domain name.
   * 
   * If you do not pass this parameter or if you leave its value empty, Domain is returned by default.
   * 
   * @example
   * OSS
   */
  recordSourceType?: string;
  /**
   * @remarks
   * The DNS type of the record, such as **A/AAAA, CNAME, and TXT**.
   * 
   * @example
   * A/AAAA
   */
  recordType?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The TTL of the record. Unit: seconds. If the value is 1, the TTL of the record is determined by the system.
   * 
   * @example
   * 30
   */
  ttl?: number;
  /**
   * @remarks
   * The time when the record was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-06-07T10:02:59Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      authConf: 'AuthConf',
      bizName: 'BizName',
      comment: 'Comment',
      createTime: 'CreateTime',
      data: 'Data',
      hostPolicy: 'HostPolicy',
      proxied: 'Proxied',
      recordCname: 'RecordCname',
      recordId: 'RecordId',
      recordName: 'RecordName',
      recordSourceType: 'RecordSourceType',
      recordType: 'RecordType',
      siteId: 'SiteId',
      siteName: 'SiteName',
      ttl: 'Ttl',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authConf: ListRecordsResponseBodyRecordsAuthConf,
      bizName: 'string',
      comment: 'string',
      createTime: 'string',
      data: ListRecordsResponseBodyRecordsData,
      hostPolicy: 'string',
      proxied: 'boolean',
      recordCname: 'string',
      recordId: 'number',
      recordName: 'string',
      recordSourceType: 'string',
      recordType: 'string',
      siteId: 'number',
      siteName: 'string',
      ttl: 'number',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRoutineOptionalSpecsResponseBodySpecs extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the specification is available. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  isAvailable?: boolean;
  /**
   * @remarks
   * The specification name.
   * 
   * @example
   * 5ms
   */
  specName?: string;
  static names(): { [key: string]: string } {
    return {
      isAvailable: 'IsAvailable',
      specName: 'SpecName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isAvailable: 'boolean',
      specName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScheduledPreloadExecutionsResponseBodyExecutions extends $tea.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 15685865xxx14622
   */
  aliUid?: string;
  /**
   * @remarks
   * The end time of the prefetch plan.
   * 
   * @example
   * 2024-05-31T18:10:48.849+08:00
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the prefetch plan.
   * 
   * @example
   * 66599bd7397885b43804901c
   */
  id?: string;
  /**
   * @remarks
   * The time interval between each batch execution in the plan. Unit: seconds.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The ID of the prefetch task.
   * 
   * @example
   * 665d3af3621bccf3fe29e1a4
   */
  jobId?: string;
  /**
   * @remarks
   * The number of URLs prefetched in each batch.
   * 
   * @example
   * 10
   */
  sliceLen?: number;
  /**
   * @remarks
   * The start time of the prefetch plan.
   * 
   * @example
   * 2024-05-31T17:10:48.849+08:00
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the prefetch plan. Valid values:
   * 
   * *   **waiting**
   * *   **running**
   * *   **finished**
   * *   **failed**
   * *   **stopped**
   * 
   * @example
   * running
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      endTime: 'EndTime',
      id: 'Id',
      interval: 'Interval',
      jobId: 'JobId',
      sliceLen: 'SliceLen',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'string',
      endTime: 'string',
      id: 'string',
      interval: 'number',
      jobId: 'string',
      sliceLen: 'number',
      startTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScheduledPreloadJobsResponseBodyJobs extends $tea.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 15685865xxx14622
   */
  aliUid?: string;
  /**
   * @remarks
   * The time when the task was created.
   * 
   * @example
   * 2024-06-01T08:53:13Z
   */
  createdAt?: string;
  /**
   * @remarks
   * The domain names to be prefetched.
   * 
   * @example
   * testurl.com
   */
  domains?: string;
  /**
   * @remarks
   * The error message that is returned.
   * 
   * @example
   * invalid domain:test.com
   */
  errorInfo?: string;
  /**
   * @remarks
   * The URL of the OSS object that stores a list of URLs that failed the conditional check for prefetching.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  failedFileOss?: string;
  /**
   * @remarks
   * The ID of the URL list file, which can be used during downloads.
   * 
   * @example
   * 665d3b48621bccf3fe29e1a7
   */
  fileId?: string;
  /**
   * @remarks
   * The ID of the prefetch task.
   * 
   * @example
   * 665d3af3621bccf3fe29e1a4
   */
  id?: string;
  /**
   * @remarks
   * The method to submit the URLs to be prefetched.
   * 
   * @example
   * oss
   */
  insertWay?: string;
  /**
   * @remarks
   * The task name.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 190007158391808
   */
  siteId?: number;
  /**
   * @remarks
   * The number of submitted prefetch tasks.
   * 
   * @example
   * 1
   */
  taskSubmitted?: number;
  /**
   * @remarks
   * The task type. Valid values: refresh and preload.
   * 
   * @example
   * preload
   */
  taskType?: string;
  /**
   * @remarks
   * The total number of URLs.
   * 
   * @example
   * 2
   */
  urlCount?: number;
  /**
   * @remarks
   * The number of submitted URLs.
   * 
   * @example
   * 1
   */
  urlSubmitted?: number;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      createdAt: 'CreatedAt',
      domains: 'Domains',
      errorInfo: 'ErrorInfo',
      failedFileOss: 'FailedFileOss',
      fileId: 'FileId',
      id: 'Id',
      insertWay: 'InsertWay',
      name: 'Name',
      siteId: 'SiteId',
      taskSubmitted: 'TaskSubmitted',
      taskType: 'TaskType',
      urlCount: 'UrlCount',
      urlSubmitted: 'UrlSubmitted',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'string',
      createdAt: 'string',
      domains: 'string',
      errorInfo: 'string',
      failedFileOss: 'string',
      fileId: 'string',
      id: 'string',
      insertWay: 'string',
      name: 'string',
      siteId: 'number',
      taskSubmitted: 'number',
      taskType: 'string',
      urlCount: 'number',
      urlSubmitted: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteDeliveryTasksResponseBodyTasks extends $tea.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   dcdn_log_access_l1 (default): access logs.
   * *   dcdn_log_er: Edge Routine logs.
   * *   dcdn_log_waf: firewall logs.
   * *   dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The data center. Valid values:
   * 
   * *   cn: the Chinese mainland.
   * *   sg: outside the Chinese mainland.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The destination of the delivery. Valid values:
   * 
   * 1.  sls: Alibaba Cloud Simple Log Service (SLS).
   * 2.  http: HTTP server.
   * 3.  aws3: Amazon Simple Storage Service (S3).
   * 4.  oss: Alibaba Cloud Object Storage Service (OSS).
   * 5.  kafka: Kafka.
   * 6.  aws3cmpt: S3-compatible storage service.
   * 
   * @example
   * sls
   */
  deliveryType?: string;
  /**
   * @remarks
   * The status of the delivery task.
   * 
   * *   **online**
   * *   **offline**
   * 
   * @example
   * online
   */
  status?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * @example
   * cdn-test-task
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      dataCenter: 'DataCenter',
      deliveryType: 'DeliveryType',
      status: 'Status',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      dataCenter: 'string',
      deliveryType: 'string',
      status: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsCacheReserve extends $tea.Model {
  configId?: number;
  enable?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsCacheRules extends $tea.Model {
  additionalCacheablePorts?: string;
  browserCacheMode?: string;
  browserCacheTtl?: string;
  bypassCache?: string;
  cacheDeceptionArmor?: string;
  cacheReserveEligibility?: string;
  checkPresenceCookie?: string;
  checkPresenceHeader?: string;
  configId?: number;
  edgeCacheMode?: string;
  edgeCacheTtl?: string;
  edgeStatusCodeCacheTtl?: string;
  includeCookie?: string;
  includeHeader?: string;
  queryString?: string;
  queryStringMode?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  sequence?: string;
  serveStale?: string;
  sortQueryStringForCache?: string;
  userDeviceType?: string;
  userGeo?: string;
  userLanguage?: string;
  static names(): { [key: string]: string } {
    return {
      additionalCacheablePorts: 'AdditionalCacheablePorts',
      browserCacheMode: 'BrowserCacheMode',
      browserCacheTtl: 'BrowserCacheTtl',
      bypassCache: 'BypassCache',
      cacheDeceptionArmor: 'CacheDeceptionArmor',
      cacheReserveEligibility: 'CacheReserveEligibility',
      checkPresenceCookie: 'CheckPresenceCookie',
      checkPresenceHeader: 'CheckPresenceHeader',
      configId: 'ConfigId',
      edgeCacheMode: 'EdgeCacheMode',
      edgeCacheTtl: 'EdgeCacheTtl',
      edgeStatusCodeCacheTtl: 'EdgeStatusCodeCacheTtl',
      includeCookie: 'IncludeCookie',
      includeHeader: 'IncludeHeader',
      queryString: 'QueryString',
      queryStringMode: 'QueryStringMode',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      serveStale: 'ServeStale',
      sortQueryStringForCache: 'SortQueryStringForCache',
      userDeviceType: 'UserDeviceType',
      userGeo: 'UserGeo',
      userLanguage: 'UserLanguage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      additionalCacheablePorts: 'string',
      browserCacheMode: 'string',
      browserCacheTtl: 'string',
      bypassCache: 'string',
      cacheDeceptionArmor: 'string',
      cacheReserveEligibility: 'string',
      checkPresenceCookie: 'string',
      checkPresenceHeader: 'string',
      configId: 'number',
      edgeCacheMode: 'string',
      edgeCacheTtl: 'string',
      edgeStatusCodeCacheTtl: 'string',
      includeCookie: 'string',
      includeHeader: 'string',
      queryString: 'string',
      queryStringMode: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'string',
      serveStale: 'string',
      sortQueryStringForCache: 'string',
      userDeviceType: 'string',
      userGeo: 'string',
      userLanguage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsCacheTags extends $tea.Model {
  caseInsensitive?: string;
  configId?: number;
  sequence?: string;
  tagName?: string;
  static names(): { [key: string]: string } {
    return {
      caseInsensitive: 'CaseInsensitive',
      configId: 'ConfigId',
      sequence: 'Sequence',
      tagName: 'TagName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      caseInsensitive: 'string',
      configId: 'number',
      sequence: 'string',
      tagName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsCnameFlattening extends $tea.Model {
  configId?: number;
  flattenMode?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      flattenMode: 'FlattenMode',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      flattenMode: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsCompressionRules extends $tea.Model {
  brotli?: string;
  configId?: number;
  gzip?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      brotli: 'Brotli',
      configId: 'ConfigId',
      gzip: 'Gzip',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      brotli: 'string',
      configId: 'number',
      gzip: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsCrossBorderOptimization extends $tea.Model {
  configId?: number;
  enable?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsDevelopmentMode extends $tea.Model {
  configId?: number;
  enable?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification extends $tea.Model {
  name?: string;
  operation?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      operation: 'Operation',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      operation: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRules extends $tea.Model {
  configId?: number;
  requestHeaderModification?: ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification[];
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      requestHeaderModification: 'RequestHeaderModification',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      requestHeaderModification: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification },
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification extends $tea.Model {
  name?: string;
  operation?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      operation: 'Operation',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      operation: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRules extends $tea.Model {
  configId?: number;
  responseHeaderModification?: ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification[];
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      responseHeaderModification: 'ResponseHeaderModification',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      responseHeaderModification: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification },
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsHttpsApplicationConfiguration extends $tea.Model {
  altSvc?: string;
  altSvcClear?: string;
  altSvcMa?: string;
  altSvcPersist?: string;
  configId?: number;
  hsts?: string;
  hstsIncludeSubdomains?: string;
  hstsMaxAge?: string;
  hstsPreload?: string;
  httpsForce?: string;
  httpsForceCode?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      altSvc: 'AltSvc',
      altSvcClear: 'AltSvcClear',
      altSvcMa: 'AltSvcMa',
      altSvcPersist: 'AltSvcPersist',
      configId: 'ConfigId',
      hsts: 'Hsts',
      hstsIncludeSubdomains: 'HstsIncludeSubdomains',
      hstsMaxAge: 'HstsMaxAge',
      hstsPreload: 'HstsPreload',
      httpsForce: 'HttpsForce',
      httpsForceCode: 'HttpsForceCode',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      altSvc: 'string',
      altSvcClear: 'string',
      altSvcMa: 'string',
      altSvcPersist: 'string',
      configId: 'number',
      hsts: 'string',
      hstsIncludeSubdomains: 'string',
      hstsMaxAge: 'string',
      hstsPreload: 'string',
      httpsForce: 'string',
      httpsForceCode: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsHttpsBasicConfiguration extends $tea.Model {
  ciphersuite?: string;
  ciphersuiteGroup?: string;
  configId?: number;
  http2?: string;
  http3?: string;
  https?: string;
  ocspStapling?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  sequence?: string;
  tls10?: string;
  tls11?: string;
  tls12?: string;
  tls13?: string;
  static names(): { [key: string]: string } {
    return {
      ciphersuite: 'Ciphersuite',
      ciphersuiteGroup: 'CiphersuiteGroup',
      configId: 'ConfigId',
      http2: 'Http2',
      http3: 'Http3',
      https: 'Https',
      ocspStapling: 'OcspStapling',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      tls10: 'Tls10',
      tls11: 'Tls11',
      tls12: 'Tls12',
      tls13: 'Tls13',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ciphersuite: 'string',
      ciphersuiteGroup: 'string',
      configId: 'number',
      http2: 'string',
      http3: 'string',
      https: 'string',
      ocspStapling: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'string',
      tls10: 'string',
      tls11: 'string',
      tls12: 'string',
      tls13: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsImageTransform extends $tea.Model {
  configId?: number;
  enable?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsIpv6 extends $tea.Model {
  configId?: number;
  enable?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsManagedTransforms extends $tea.Model {
  addClientGeolocationHeaders?: string;
  addRealClientIpHeader?: string;
  configId?: number;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      addClientGeolocationHeaders: 'AddClientGeolocationHeaders',
      addRealClientIpHeader: 'AddRealClientIpHeader',
      configId: 'ConfigId',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addClientGeolocationHeaders: 'string',
      addRealClientIpHeader: 'string',
      configId: 'number',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsNetworkOptimization extends $tea.Model {
  configId?: number;
  grpc?: string;
  http2Origin?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  sequence?: string;
  smartRouting?: string;
  uploadMaxFilesize?: string;
  websocket?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      grpc: 'Grpc',
      http2Origin: 'Http2Origin',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      smartRouting: 'SmartRouting',
      uploadMaxFilesize: 'UploadMaxFilesize',
      websocket: 'Websocket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      grpc: 'string',
      http2Origin: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'string',
      smartRouting: 'string',
      uploadMaxFilesize: 'string',
      websocket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsOriginRules extends $tea.Model {
  configId?: number;
  dnsRecord?: string;
  originHost?: string;
  originHttpPort?: string;
  originHttpsPort?: string;
  originScheme?: string;
  originSni?: string;
  range?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      dnsRecord: 'DnsRecord',
      originHost: 'OriginHost',
      originHttpPort: 'OriginHttpPort',
      originHttpsPort: 'OriginHttpsPort',
      originScheme: 'OriginScheme',
      originSni: 'OriginSni',
      range: 'Range',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      dnsRecord: 'string',
      originHost: 'string',
      originHttpPort: 'string',
      originHttpsPort: 'string',
      originScheme: 'string',
      originSni: 'string',
      range: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsRedirectRules extends $tea.Model {
  configId?: number;
  reserveQueryString?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  sequence?: string;
  statusCode?: string;
  targetUrl?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      reserveQueryString: 'ReserveQueryString',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      statusCode: 'StatusCode',
      targetUrl: 'TargetUrl',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      reserveQueryString: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'string',
      statusCode: 'string',
      targetUrl: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsRewriteUrlRules extends $tea.Model {
  configId?: number;
  queryString?: string;
  rewriteQueryStringType?: string;
  rewriteUriType?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  sequence?: string;
  uri?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      queryString: 'QueryString',
      rewriteQueryStringType: 'RewriteQueryStringType',
      rewriteUriType: 'RewriteUriType',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      uri: 'Uri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      queryString: 'string',
      rewriteQueryStringType: 'string',
      rewriteUriType: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'string',
      uri: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsSeoBypass extends $tea.Model {
  configId?: number;
  enable?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsSiteNameExclusive extends $tea.Model {
  configId?: number;
  enable?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsSitePause extends $tea.Model {
  configId?: number;
  paused?: string;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      paused: 'Paused',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      paused: 'string',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigsTieredCache extends $tea.Model {
  cacheArchitectureMode?: string;
  configId?: number;
  sequence?: string;
  static names(): { [key: string]: string } {
    return {
      cacheArchitectureMode: 'CacheArchitectureMode',
      configId: 'ConfigId',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheArchitectureMode: 'string',
      configId: 'number',
      sequence: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteFunctionsResponseBodyConfigs extends $tea.Model {
  cacheReserve?: ListSiteFunctionsResponseBodyConfigsCacheReserve[];
  cacheRules?: ListSiteFunctionsResponseBodyConfigsCacheRules[];
  cacheTags?: ListSiteFunctionsResponseBodyConfigsCacheTags[];
  cnameFlattening?: ListSiteFunctionsResponseBodyConfigsCnameFlattening[];
  compressionRules?: ListSiteFunctionsResponseBodyConfigsCompressionRules[];
  crossBorderOptimization?: ListSiteFunctionsResponseBodyConfigsCrossBorderOptimization[];
  developmentMode?: ListSiteFunctionsResponseBodyConfigsDevelopmentMode[];
  httpRequestHeaderModificationRules?: ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRules[];
  httpResponseHeaderModificationRules?: ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRules[];
  httpsApplicationConfiguration?: ListSiteFunctionsResponseBodyConfigsHttpsApplicationConfiguration[];
  httpsBasicConfiguration?: ListSiteFunctionsResponseBodyConfigsHttpsBasicConfiguration[];
  imageTransform?: ListSiteFunctionsResponseBodyConfigsImageTransform[];
  ipv6?: ListSiteFunctionsResponseBodyConfigsIpv6[];
  managedTransforms?: ListSiteFunctionsResponseBodyConfigsManagedTransforms[];
  networkOptimization?: ListSiteFunctionsResponseBodyConfigsNetworkOptimization[];
  originRules?: ListSiteFunctionsResponseBodyConfigsOriginRules[];
  redirectRules?: ListSiteFunctionsResponseBodyConfigsRedirectRules[];
  rewriteUrlRules?: ListSiteFunctionsResponseBodyConfigsRewriteUrlRules[];
  seoBypass?: ListSiteFunctionsResponseBodyConfigsSeoBypass[];
  siteNameExclusive?: ListSiteFunctionsResponseBodyConfigsSiteNameExclusive[];
  sitePause?: ListSiteFunctionsResponseBodyConfigsSitePause[];
  tieredCache?: ListSiteFunctionsResponseBodyConfigsTieredCache[];
  static names(): { [key: string]: string } {
    return {
      cacheReserve: 'CacheReserve',
      cacheRules: 'CacheRules',
      cacheTags: 'CacheTags',
      cnameFlattening: 'CnameFlattening',
      compressionRules: 'CompressionRules',
      crossBorderOptimization: 'CrossBorderOptimization',
      developmentMode: 'DevelopmentMode',
      httpRequestHeaderModificationRules: 'HttpRequestHeaderModificationRules',
      httpResponseHeaderModificationRules: 'HttpResponseHeaderModificationRules',
      httpsApplicationConfiguration: 'HttpsApplicationConfiguration',
      httpsBasicConfiguration: 'HttpsBasicConfiguration',
      imageTransform: 'ImageTransform',
      ipv6: 'Ipv6',
      managedTransforms: 'ManagedTransforms',
      networkOptimization: 'NetworkOptimization',
      originRules: 'OriginRules',
      redirectRules: 'RedirectRules',
      rewriteUrlRules: 'RewriteUrlRules',
      seoBypass: 'SeoBypass',
      siteNameExclusive: 'SiteNameExclusive',
      sitePause: 'SitePause',
      tieredCache: 'TieredCache',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheReserve: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsCacheReserve },
      cacheRules: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsCacheRules },
      cacheTags: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsCacheTags },
      cnameFlattening: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsCnameFlattening },
      compressionRules: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsCompressionRules },
      crossBorderOptimization: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsCrossBorderOptimization },
      developmentMode: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsDevelopmentMode },
      httpRequestHeaderModificationRules: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRules },
      httpResponseHeaderModificationRules: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRules },
      httpsApplicationConfiguration: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsHttpsApplicationConfiguration },
      httpsBasicConfiguration: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsHttpsBasicConfiguration },
      imageTransform: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsImageTransform },
      ipv6: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsIpv6 },
      managedTransforms: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsManagedTransforms },
      networkOptimization: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsNetworkOptimization },
      originRules: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsOriginRules },
      redirectRules: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsRedirectRules },
      rewriteUrlRules: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsRewriteUrlRules },
      seoBypass: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsSeoBypass },
      siteNameExclusive: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsSiteNameExclusive },
      sitePause: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsSitePause },
      tieredCache: { 'type': 'array', 'itemType': ListSiteFunctionsResponseBodyConfigsTieredCache },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSitesRequestTagFilter extends $tea.Model {
  /**
   * @remarks
   * The tag key. This parameter specifies a filter condition for the query.
   * 
   * @example
   * tag1
   */
  key?: string;
  /**
   * @remarks
   * The tag value. This parameter specifies a filter condition for the query.
   * 
   * @example
   * aaa
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSitesResponseBodySites extends $tea.Model {
  /**
   * @remarks
   * The DNS setup for the website. Valid values:
   * 
   * *   **NS**
   * *   **CNAME**
   * 
   * @example
   * NS
   */
  accessType?: string;
  /**
   * @remarks
   * The CNAME of the website domain. If you use CNAME setup when you add your website to ESA, the value is the CNAME that you configured then.
   * 
   * @example
   * example.cname.com
   */
  cnameZone?: string;
  /**
   * @remarks
   * The service location for the website. Valid values:
   * 
   * *   **domestic**: the Chinese mainland
   * *   **global**: global
   * *   **overseas**: outside the Chinese mainland
   * 
   * @example
   * domestic
   */
  coverage?: string;
  /**
   * @remarks
   * The time when the website was added. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-12-24T02:01:11Z
   */
  createTime?: string;
  /**
   * @remarks
   * The ID of the plan associated with the website.
   * 
   * @example
   * onBvtlmIyeXLbiDw81F9
   */
  instanceId?: string;
  /**
   * @remarks
   * The nameservers assigned to the website domain, which are separated by commas (,).
   * 
   * @example
   * male1-1.ialicdn.com,female1-1.ialicdn.com
   */
  nameServerList?: string;
  /**
   * @remarks
   * The plan name.
   * 
   * @example
   * plan-168656498****
   */
  planName?: string;
  /**
   * @remarks
   * The plan associated with the website.
   * 
   * @example
   * normal
   */
  planSpecName?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-aek26g6i6se6pna
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The website status. Valid values:
   * 
   * *   **pending**: The website is to be configured.
   * *   **active**: The website is active.
   * *   **offline**: The website is suspended.
   * *   **moved**: The website has been added and verified by another Alibaba Cloud account.
   * 
   * @example
   * pending
   */
  status?: string;
  /**
   * @remarks
   * The tags of the website.
   * 
   * @example
   * {"tag1":"value1"}
   */
  tags?: { [key: string]: any };
  /**
   * @remarks
   * The time when the website was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-12-24T02:01:11Z
   */
  updateTime?: string;
  /**
   * @remarks
   * The code that is used to verify the website domain ownership. As part of the verification TXT record, this parameter is returned for websites that use CNAME setup.
   * 
   * @example
   * verify_d516cb3740f81f0cef77d162edd1****
   */
  verifyCode?: string;
  static names(): { [key: string]: string } {
    return {
      accessType: 'AccessType',
      cnameZone: 'CnameZone',
      coverage: 'Coverage',
      createTime: 'CreateTime',
      instanceId: 'InstanceId',
      nameServerList: 'NameServerList',
      planName: 'PlanName',
      planSpecName: 'PlanSpecName',
      resourceGroupId: 'ResourceGroupId',
      siteId: 'SiteId',
      siteName: 'SiteName',
      status: 'Status',
      tags: 'Tags',
      updateTime: 'UpdateTime',
      verifyCode: 'VerifyCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessType: 'string',
      cnameZone: 'string',
      coverage: 'string',
      createTime: 'string',
      instanceId: 'string',
      nameServerList: 'string',
      planName: 'string',
      planSpecName: 'string',
      resourceGroupId: 'string',
      siteId: 'number',
      siteName: 'string',
      status: 'string',
      tags: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      updateTime: 'string',
      verifyCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesRequestTag extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponseBodyTagResources extends $tea.Model {
  /**
   * @remarks
   * The resource ID.
   * 
   * @example
   * example.com
   */
  resourceId?: string;
  /**
   * @remarks
   * The resource type.
   * 
   * @example
   * site
   */
  resourceType?: string;
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * env
   */
  tagKey?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * value
   */
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: 'string',
      resourceType: 'string',
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUploadTasksResponseBodyTasks extends $tea.Model {
  /**
   * @remarks
   * The time when the task was created.
   * 
   * @example
   * 2023-07-26T01:56:15Z
   */
  createTime?: string;
  /**
   * @remarks
   * The error message returned when the file upload task failed.
   * 
   * @example
   * invalid url
   */
  description?: string;
  /**
   * @remarks
   * The error code. Multiple error codes are separated by commas (,).
   * 
   * *   **InvalidUrl**: The URL format is incorrect.
   * *   **InvalidDomain**: The domain ownership fails to be verified.
   * *   **QuotaExcess**: The quota limit has been reached.
   * *   **OtherErrors**: Other errors.
   * 
   * @example
   * InvalidUrl,InvalidDomain
   */
  errorCode?: string;
  /**
   * @remarks
   * The task status.
   * 
   * *   **Complete**: The task is complete.
   * *   **Refreshing**: The task is in progress.
   * *   **Failed**: The task failed.
   * 
   * @example
   * Complete
   */
  status?: string;
  /**
   * @remarks
   * The task type. Valid values:
   * 
   * *   **file**: purges the cache by file URL.
   * *   **preload**: prefetches files.
   * *   **directory**: purges the cache by directory.
   * *   **ignoreparams**: purges the cache by URL with specified parameters ignored.
   * 
   * @example
   * file
   */
  type?: string;
  /**
   * @remarks
   * The ID of the file upload task.
   * 
   * @example
   * 159253299357****
   */
  uploadId?: string;
  /**
   * @remarks
   * The name of the file upload task.
   * 
   * @example
   * purge_file_task
   */
  uploadTaskName?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      errorCode: 'ErrorCode',
      status: 'Status',
      type: 'Type',
      uploadId: 'UploadId',
      uploadTaskName: 'UploadTaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      description: 'string',
      errorCode: 'string',
      status: 'string',
      type: 'string',
      uploadId: 'string',
      uploadTaskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserDeliveryTasksResponseBodyTasks extends $tea.Model {
  /**
   * @remarks
   * The log category.
   * 
   * @example
   * dcdn_log_er
   */
  businessType?: string;
  /**
   * @remarks
   * The data center. Valid values:
   * 
   * 1.  cn: the Chinese mainland.
   * 2.  sg: outside the Chinese mainland.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The delivery destination.
   * 
   * @example
   * oss
   */
  deliveryType?: string;
  /**
   * @remarks
   * The status of the delivery task.
   * 
   * @example
   * online
   */
  status?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * @example
   * testoss11
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      dataCenter: 'DataCenter',
      deliveryType: 'DeliveryType',
      status: 'Status',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      dataCenter: 'string',
      deliveryType: 'string',
      status: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserRatePlanInstancesResponseBodyInstanceInfoSites extends $tea.Model {
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The website status. Valid values:
   * 
   * *   pending: The website is to be configured.
   * *   active: The website is active.
   * *   offline: The website is suspended.
   * *   moved: The website has been added and verified by another Alibaba Cloud account.
   * 
   * @example
   * pending
   */
  siteStatus?: string;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      siteName: 'SiteName',
      siteStatus: 'SiteStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      siteName: 'string',
      siteStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserRatePlanInstancesResponseBodyInstanceInfo extends $tea.Model {
  /**
   * @remarks
   * The billing method. Valid values:
   * 
   * *   PREPAY: subscription.
   * *   POSTPAY: pay-as-you-go.
   * 
   * @example
   * PREPAY
   */
  billingMode?: string;
  botInstanceLevel?: string;
  /**
   * @remarks
   * The service locations for the websites that can be associated with the plan. Multiple values are separated by commas (,). Valid values:
   * 
   * *   domestic: the Chinese mainland.
   * *   overseas: outside the Chinese mainland.
   * *   global: global.
   * 
   * @example
   * domestic,overseas
   */
  coverages?: string;
  /**
   * @remarks
   * The time when the plan was purchased.
   * 
   * @example
   * YYYY-MM-DDThh:mm:ssZ
   */
  createTime?: string;
  crossborderTraffic?: string;
  ddosBurstableDomesticProtection?: string;
  ddosBurstableOverseasProtection?: string;
  ddosInstanceLevel?: string;
  /**
   * @remarks
   * The subscription duration of the plan. Unit: month.
   * 
   * @example
   * 3
   */
  duration?: number;
  edgeRoutineRquest?: string;
  edgeWafRequest?: string;
  /**
   * @remarks
   * The time when the plan expires.
   * 
   * @example
   * YYYY-MM-DDThh:mm:ssZ
   */
  expireTime?: string;
  /**
   * @remarks
   * The plan ID.
   * 
   * @example
   * sp-xcdn-96wblslz****
   */
  instanceId?: string;
  layer4Traffic?: string;
  layer4TrafficIntl?: string;
  /**
   * @remarks
   * The plan name.
   * 
   * @example
   * basic
   */
  planName?: string;
  planTraffic?: string;
  /**
   * @remarks
   * The plan type. Valid values:
   * 
   * *   normal
   * *   enterprise
   * 
   * @example
   * normal
   */
  planType?: string;
  /**
   * @remarks
   * The maximum number of websites that can be associated with the plan.
   * 
   * @example
   * 1
   */
  siteQuota?: string;
  /**
   * @remarks
   * The websites that have been associated with the plan.
   */
  sites?: ListUserRatePlanInstancesResponseBodyInstanceInfoSites[];
  smartRoutingRequest?: string;
  staticRequest?: string;
  /**
   * @remarks
   * The plan status. Valid values:
   * 
   * *   online: The plan is in service.
   * *   offline: The plan has expired within an allowable period. In this state, the plan is unavailable.
   * *   disable: The plan is released.
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      billingMode: 'BillingMode',
      botInstanceLevel: 'BotInstanceLevel',
      coverages: 'Coverages',
      createTime: 'CreateTime',
      crossborderTraffic: 'CrossborderTraffic',
      ddosBurstableDomesticProtection: 'DdosBurstableDomesticProtection',
      ddosBurstableOverseasProtection: 'DdosBurstableOverseasProtection',
      ddosInstanceLevel: 'DdosInstanceLevel',
      duration: 'Duration',
      edgeRoutineRquest: 'EdgeRoutineRquest',
      edgeWafRequest: 'EdgeWafRequest',
      expireTime: 'ExpireTime',
      instanceId: 'InstanceId',
      layer4Traffic: 'Layer4Traffic',
      layer4TrafficIntl: 'Layer4TrafficIntl',
      planName: 'PlanName',
      planTraffic: 'PlanTraffic',
      planType: 'PlanType',
      siteQuota: 'SiteQuota',
      sites: 'Sites',
      smartRoutingRequest: 'SmartRoutingRequest',
      staticRequest: 'StaticRequest',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      billingMode: 'string',
      botInstanceLevel: 'string',
      coverages: 'string',
      createTime: 'string',
      crossborderTraffic: 'string',
      ddosBurstableDomesticProtection: 'string',
      ddosBurstableOverseasProtection: 'string',
      ddosInstanceLevel: 'string',
      duration: 'number',
      edgeRoutineRquest: 'string',
      edgeWafRequest: 'string',
      expireTime: 'string',
      instanceId: 'string',
      layer4Traffic: 'string',
      layer4TrafficIntl: 'string',
      planName: 'string',
      planTraffic: 'string',
      planType: 'string',
      siteQuota: 'string',
      sites: { 'type': 'array', 'itemType': ListUserRatePlanInstancesResponseBodyInstanceInfoSites },
      smartRoutingRequest: 'string',
      staticRequest: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafManagedRulesRequestQueryArgs extends $tea.Model {
  /**
   * @remarks
   * The action that you want WAF to perform on requests that match the rule.
   * 
   * @example
   * deny
   */
  action?: string;
  /**
   * @remarks
   * The rule ID or name for fuzzy search.
   * 
   * @example
   * example
   */
  idNameLike?: string;
  /**
   * @remarks
   * The protection levels of the rules.
   */
  protectionLevels?: number[];
  /**
   * @remarks
   * The status.
   * 
   * @example
   * on
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      idNameLike: 'IdNameLike',
      protectionLevels: 'ProtectionLevels',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      idNameLike: 'string',
      protectionLevels: { 'type': 'array', 'itemType': 'number' },
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafManagedRulesResponseBodyRules extends $tea.Model {
  /**
   * @remarks
   * The action that WAF performs on requests that match the managed rule.
   * 
   * @example
   * deny
   */
  action?: string;
  /**
   * @remarks
   * The ID of the managed rule.
   * 
   * @example
   * 100001
   */
  id?: number;
  /**
   * @remarks
   * The name of the managed rule.
   */
  name?: string;
  /**
   * @remarks
   * The protection level of the managed rule.
   * 
   * @example
   * 1
   */
  protectionLevel?: number;
  /**
   * @remarks
   * The status of the protection rule.
   * 
   * @example
   * on
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      id: 'Id',
      name: 'Name',
      protectionLevel: 'ProtectionLevel',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      id: 'number',
      name: 'string',
      protectionLevel: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafPhasesResponseBodyPhasesRulesets extends $tea.Model {
  /**
   * @remarks
   * The ID of the WAF ruleset.[](~~2850233~~)
   * 
   * @example
   * 10000001
   */
  id?: number;
  /**
   * @remarks
   * The name of the WAF ruleset.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The rule configurations in the WAF ruleset.
   */
  rules?: WafRuleConfig[];
  /**
   * @remarks
   * The configurations shared by the rules in the WAF ruleset.
   */
  shared?: WafBatchRuleShared;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
      rules: 'Rules',
      shared: 'Shared',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
      rules: { 'type': 'array', 'itemType': WafRuleConfig },
      shared: WafBatchRuleShared,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafPhasesResponseBodyPhases extends $tea.Model {
  /**
   * @remarks
   * The name of the WAF rule category.
   * 
   * @example
   * http_custom
   */
  phase?: string;
  /**
   * @remarks
   * The WAF rulesets.
   */
  rulesets?: ListWafPhasesResponseBodyPhasesRulesets[];
  static names(): { [key: string]: string } {
    return {
      phase: 'Phase',
      rulesets: 'Rulesets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      phase: 'string',
      rulesets: { 'type': 'array', 'itemType': ListWafPhasesResponseBodyPhasesRulesets },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafRulesRequestQueryArgs extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to sort the returned data in descending order.
   * 
   * @example
   * true
   */
  desc?: boolean;
  /**
   * @remarks
   * The ID of a WAF rule for exact search.
   * 
   * @example
   * 20000001
   */
  id?: number;
  /**
   * @remarks
   * The ID or name of a WAF rule for fuzzy search.
   * 
   * @example
   * example
   */
  idNameLike?: string;
  /**
   * @remarks
   * The name of a WAF rule for fuzzy search.
   * 
   * @example
   * example
   */
  nameLike?: string;
  /**
   * @remarks
   * The column by which you want to sort the returned data.
   * 
   * @example
   * position
   */
  orderBy?: string;
  /**
   * @remarks
   * The ID of a WAF ruleset for exact search.
   * 
   * @example
   * 10000001
   */
  rulesetId?: number;
  /**
   * @remarks
   * The status of a WAF rule for exact search.
   * 
   * @example
   * on
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      id: 'Id',
      idNameLike: 'IdNameLike',
      nameLike: 'NameLike',
      orderBy: 'OrderBy',
      rulesetId: 'RulesetId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'boolean',
      id: 'number',
      idNameLike: 'string',
      nameLike: 'string',
      orderBy: 'string',
      rulesetId: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafRulesResponseBodyRules extends $tea.Model {
  /**
   * @remarks
   * The action triggered when requests match conditions defined in the rule.
   * 
   * @example
   * deny
   */
  action?: string;
  /**
   * @remarks
   * The fields in rate limiting rules.
   */
  characteristicsFields?: string[];
  /**
   * @remarks
   * The configuration of the rule.
   */
  config?: WafRuleConfig;
  /**
   * @remarks
   * The fields in the rule.
   */
  fields?: string[];
  /**
   * @remarks
   * The rule ID.
   * 
   * @example
   * 20000001
   */
  id?: number;
  /**
   * @remarks
   * The rule name.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The WAF rule category.
   * 
   * @example
   * http_custom
   */
  phase?: string;
  /**
   * @remarks
   * The position of the rule in the ruleset.
   * 
   * @example
   * 1
   */
  position?: number;
  /**
   * @remarks
   * The ruleset ID.
   * 
   * @example
   * 10000001
   */
  rulesetId?: number;
  /**
   * @remarks
   * The skip scope applied when requests match conditions defined in the whitelist rule.
   * 
   * @example
   * part
   */
  skip?: string;
  /**
   * @remarks
   * Indicates whether the rule is enabled.
   * 
   * @example
   * on
   */
  status?: string;
  /**
   * @remarks
   * The skipped WAF rule categories when requests match conditions defined in the whitelist rule.
   */
  tags?: string[];
  /**
   * @remarks
   * The time when the rule takes effect.
   */
  timer?: WafTimer;
  /**
   * @remarks
   * The WAF rule type.
   * 
   * @example
   * http_custom
   */
  type?: string;
  /**
   * @remarks
   * The time when the rule was modified.
   * 
   * @example
   * 2024-01-01T00:00:00Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      characteristicsFields: 'CharacteristicsFields',
      config: 'Config',
      fields: 'Fields',
      id: 'Id',
      name: 'Name',
      phase: 'Phase',
      position: 'Position',
      rulesetId: 'RulesetId',
      skip: 'Skip',
      status: 'Status',
      tags: 'Tags',
      timer: 'Timer',
      type: 'Type',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      characteristicsFields: { 'type': 'array', 'itemType': 'string' },
      config: WafRuleConfig,
      fields: { 'type': 'array', 'itemType': 'string' },
      id: 'number',
      name: 'string',
      phase: 'string',
      position: 'number',
      rulesetId: 'number',
      skip: 'string',
      status: 'string',
      tags: { 'type': 'array', 'itemType': 'string' },
      timer: WafTimer,
      type: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafRulesetsRequestQueryArgs extends $tea.Model {
  /**
   * @remarks
   * The ruleset ID, ruleset name, rule ID, or rule name for fuzzy search.
   * 
   * @example
   * example
   */
  anyLike?: string;
  /**
   * @remarks
   * Specifies whether to sort the returned data in descending order.
   */
  desc?: boolean;
  /**
   * @remarks
   * The ruleset name for fuzzy search.
   * 
   * @example
   * example
   */
  nameLike?: string;
  /**
   * @remarks
   * The column by which you want to sort the returned data.
   * 
   * @example
   * id
   */
  orderBy?: string;
  static names(): { [key: string]: string } {
    return {
      anyLike: 'AnyLike',
      desc: 'Desc',
      nameLike: 'NameLike',
      orderBy: 'OrderBy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      anyLike: 'string',
      desc: 'boolean',
      nameLike: 'string',
      orderBy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafRulesetsResponseBodyRulesets extends $tea.Model {
  /**
   * @remarks
   * The matched objects.
   */
  fields?: string[];
  /**
   * @remarks
   * The ID of the WAF ruleset.[](~~2850233~~)
   * 
   * @example
   * 10000001
   */
  id?: number;
  /**
   * @remarks
   * The ruleset name.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The WAF rule category.
   * 
   * @example
   * http_bot
   */
  phase?: string;
  /**
   * @remarks
   * The ruleset status.
   * 
   * @example
   * on
   */
  status?: string;
  /**
   * @remarks
   * The type of the protection target in the http_bot rule category.
   * 
   * @example
   * web
   */
  target?: string;
  /**
   * @remarks
   * The types of rules.
   */
  types?: string[];
  /**
   * @remarks
   * The time when the ruleset was last modified.
   * 
   * @example
   * 2024-01-01T00:00:00Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      fields: 'Fields',
      id: 'Id',
      name: 'Name',
      phase: 'Phase',
      status: 'Status',
      target: 'Target',
      types: 'Types',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fields: { 'type': 'array', 'itemType': 'string' },
      id: 'number',
      name: 'string',
      phase: 'string',
      status: 'string',
      target: 'string',
      types: { 'type': 'array', 'itemType': 'string' },
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafTemplateRulesRequestQueryArgs extends $tea.Model {
  /**
   * @remarks
   * The rule type.
   * 
   * @example
   * http_directory_traversal
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafTemplateRulesResponseBodyRules extends $tea.Model {
  /**
   * @remarks
   * The configuration of the rule.
   */
  config?: WafRuleConfig;
  /**
   * @remarks
   * The rule name.
   * 
   * @example
   * HTTP Directory Traversal Rule [Template]
   */
  name?: string;
  /**
   * @remarks
   * The WAF rule category.
   * 
   * @example
   * http_anti_scan
   */
  phase?: string;
  /**
   * @remarks
   * Indicates whether the rule is enabled.
   * 
   * @example
   * on
   */
  status?: string;
  /**
   * @remarks
   * The rule type.
   * 
   * @example
   * http_directory_traversal
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      name: 'Name',
      phase: 'Phase',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: WafRuleConfig,
      name: 'string',
      phase: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafUsageOfRulesResponseBodySites extends $tea.Model {
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  name?: string;
  /**
   * @remarks
   * The usage of WAF rules or WAF rulesets.
   * 
   * @example
   * 1
   */
  usage?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
      usage: 'Usage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
      usage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomEventsResponseBodyWaitingRoomEvents extends $tea.Model {
  /**
   * @remarks
   * The content of the custom waiting room page. This parameter is returned when the waiting room type is set to custom. The content is URL-encoded.
   * 
   * @example
   * html-yets-maqi1111
   */
  customPageHtml?: string;
  /**
   * @remarks
   * The event description.
   * 
   * @example
   * terraform-example
   */
  description?: string;
  /**
   * @remarks
   * Indicates whether session renewal is disabled. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * off
   */
  disableSessionRenewalEnable?: string;
  /**
   * @remarks
   * The event status. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * The end time of the event. This value is a UNIX timestamp.
   * 
   * @example
   * 1719814497
   */
  endTime?: string;
  /**
   * @remarks
   * Indicates whether JOSN response is enabled. If JSON response is enabled, a JSON body is returned for requests to the waiting room with the header Accept: application/json. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * off
   */
  jsonResponseEnable?: string;
  /**
   * @remarks
   * The language of the waiting room page. This parameter is returned when the waiting room type is set to default. Valid values:
   * 
   * *   enus: English.
   * *   zhcn: Simplified Chinese.
   * *   zhhk: Traditional Chinese.
   * 
   * @example
   * zhcn
   */
  language?: string;
  /**
   * @remarks
   * The custom event name.
   */
  name?: string;
  /**
   * @remarks
   * The maximum number of new users per minute.
   * 
   * @example
   * 11
   */
  newUsersPerMinute?: string;
  /**
   * @remarks
   * Indicates whether pre-queuing is enabled. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  preQueueEnable?: string;
  /**
   * @remarks
   * The start time for pre-queuing. This value is a UNIX timestamp. This parameter is valid only when pre-queuing is enabled.
   * 
   * @example
   * 1719814097
   */
  preQueueStartTime?: string;
  /**
   * @remarks
   * The queuing method. Valid values:
   * 
   * *   random: Users gain access to the origin randomly, regardless of the arrival time.
   * *   fifo: Users gain access to the origin in order of arrival.
   * *   passthrough: Users pass through the waiting room and go straight to the origin.
   * *   reject-all: Users are blocked from reaching the origin.
   * 
   * @example
   * fifo
   */
  queuingMethod?: string;
  /**
   * @remarks
   * The HTTP status code to return while a user is in the queue. Valid values:
   * 
   * *   200
   * *   202
   * *   429
   * 
   * @example
   * 200
   */
  queuingStatusCode?: string;
  /**
   * @remarks
   * Indicates whether random queuing is enabled. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  randomPreQueueEnable?: string;
  /**
   * @remarks
   * The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.
   * 
   * @example
   * 3
   */
  sessionDuration?: string;
  /**
   * @remarks
   * The start time of the event. This value is a UNIX timestamp.
   * 
   * @example
   * 1719814398
   */
  startTime?: string;
  /**
   * @remarks
   * The maximum number of active users.
   * 
   * @example
   * 22
   */
  totalActiveUsers?: string;
  /**
   * @remarks
   * The unique ID of the waiting room event.
   * 
   * @example
   * 89677721098****
   */
  waitingRoomEventId?: number;
  /**
   * @remarks
   * The ID of the waiting room associated with the event.
   * 
   * @example
   * 5c938a045c9ca46607163d34966****
   */
  waitingRoomId?: string;
  /**
   * @remarks
   * The type of the waiting room. Valid values:
   * 
   * *   default
   * *   custom
   * 
   * @example
   * custom
   */
  waitingRoomType?: string;
  static names(): { [key: string]: string } {
    return {
      customPageHtml: 'CustomPageHtml',
      description: 'Description',
      disableSessionRenewalEnable: 'DisableSessionRenewalEnable',
      enable: 'Enable',
      endTime: 'EndTime',
      jsonResponseEnable: 'JsonResponseEnable',
      language: 'Language',
      name: 'Name',
      newUsersPerMinute: 'NewUsersPerMinute',
      preQueueEnable: 'PreQueueEnable',
      preQueueStartTime: 'PreQueueStartTime',
      queuingMethod: 'QueuingMethod',
      queuingStatusCode: 'QueuingStatusCode',
      randomPreQueueEnable: 'RandomPreQueueEnable',
      sessionDuration: 'SessionDuration',
      startTime: 'StartTime',
      totalActiveUsers: 'TotalActiveUsers',
      waitingRoomEventId: 'WaitingRoomEventId',
      waitingRoomId: 'WaitingRoomId',
      waitingRoomType: 'WaitingRoomType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customPageHtml: 'string',
      description: 'string',
      disableSessionRenewalEnable: 'string',
      enable: 'string',
      endTime: 'string',
      jsonResponseEnable: 'string',
      language: 'string',
      name: 'string',
      newUsersPerMinute: 'string',
      preQueueEnable: 'string',
      preQueueStartTime: 'string',
      queuingMethod: 'string',
      queuingStatusCode: 'string',
      randomPreQueueEnable: 'string',
      sessionDuration: 'string',
      startTime: 'string',
      totalActiveUsers: 'string',
      waitingRoomEventId: 'number',
      waitingRoomId: 'string',
      waitingRoomType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomRulesResponseBodyWaitingRoomRules extends $tea.Model {
  /**
   * @remarks
   * The rule content, which is a policy or conditional expression.
   * 
   * @example
   * (http.request.uri.path.file_name eq \\"jpg\\")
   */
  rule?: string;
  /**
   * @remarks
   * Indicates whether the rule is enabled. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @remarks
   * The rule name.
   * 
   * @example
   * ip
   */
  ruleName?: string;
  /**
   * @remarks
   * The rule ID.
   * 
   * @example
   * 37286782688****
   */
  waitingRoomRuleId?: number;
  static names(): { [key: string]: string } {
    return {
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      waitingRoomRuleId: 'WaitingRoomRuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      waitingRoomRuleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomsResponseBodyWaitingRoomsHostNameAndPath extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domain?: string;
  /**
   * @remarks
   * The path.
   * 
   * @example
   * /test
   */
  path?: string;
  /**
   * @remarks
   * The subdomain.
   * 
   * @example
   * test.
   */
  subdomain?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      path: 'Path',
      subdomain: 'Subdomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      path: 'string',
      subdomain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomsResponseBodyWaitingRooms extends $tea.Model {
  /**
   * @remarks
   * The name of the custom cookie.
   * 
   * @example
   * __aliwaitingroom_example
   */
  cookieName?: string;
  /**
   * @remarks
   * The HTML content or identifier of the custom queuing page. This parameter is valid only when `WaitingRoomType` is set to `custom`. The content must be URL-encoded.
   */
  customPageHtml?: string;
  /**
   * @remarks
   * The description of the waiting room.
   */
  description?: string;
  /**
   * @remarks
   * Indicates whether session renewal is disabled. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  disableSessionRenewalEnable?: string;
  /**
   * @remarks
   * Indicates whether the waiting room is enabled. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * The hostname and path.
   */
  hostNameAndPath?: ListWaitingRoomsResponseBodyWaitingRoomsHostNameAndPath[];
  /**
   * @remarks
   * Indicates whether JSON response is enabled. If you set this parameter to on, a JSON body is returned for requests to the waiting room with the header Accept: application/json. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  jsonResponseEnable?: string;
  /**
   * @remarks
   * The language of the waiting room page. This parameter is returned when the waiting room type is set to default. Valid values:
   * 
   * *   enus: English.
   * *   zhcn: Simplified Chinese.
   * *   zhhk: Traditional Chinese.
   * 
   * @example
   * zhcn
   */
  language?: string;
  /**
   * @remarks
   * The name of the waiting room.
   */
  name?: string;
  /**
   * @remarks
   * The maximum number of new users per minute.
   * 
   * @example
   * 200
   */
  newUsersPerMinute?: string;
  /**
   * @remarks
   * Indicates whether all requests must be queued. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  queueAllEnable?: string;
  /**
   * @remarks
   * The queuing method. Valid values:
   * 
   * *   random: Users gain access to the origin randomly, regardless of the arrival time.
   * *   fifo: Users gain access to the origin in order of arrival.
   * *   passthrough: Users pass through the waiting room and go straight to the origin.
   * *   reject-all: Users are blocked from reaching the origin.
   * 
   * @example
   * random
   */
  queuingMethod?: string;
  /**
   * @remarks
   * The HTTP status code to return while a user is in the queue. Valid values:
   * 
   * *   200
   * *   202
   * *   429
   * 
   * @example
   * 200
   */
  queuingStatusCode?: string;
  /**
   * @remarks
   * The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.
   * 
   * @example
   * 3600
   */
  sessionDuration?: string;
  /**
   * @remarks
   * The maximum number of active users.
   * 
   * @example
   * 300
   */
  totalActiveUsers?: string;
  /**
   * @remarks
   * The unique ID of the waiting room.
   * 
   * @example
   * 6a51d5bc6460887abd1291dc7d4d****
   */
  waitingRoomId?: string;
  /**
   * @remarks
   * The type of the waiting room. Valid values:
   * 
   * *   default
   * *   custom
   * 
   * @example
   * default
   */
  waitingRoomType?: string;
  static names(): { [key: string]: string } {
    return {
      cookieName: 'CookieName',
      customPageHtml: 'CustomPageHtml',
      description: 'Description',
      disableSessionRenewalEnable: 'DisableSessionRenewalEnable',
      enable: 'Enable',
      hostNameAndPath: 'HostNameAndPath',
      jsonResponseEnable: 'JsonResponseEnable',
      language: 'Language',
      name: 'Name',
      newUsersPerMinute: 'NewUsersPerMinute',
      queueAllEnable: 'QueueAllEnable',
      queuingMethod: 'QueuingMethod',
      queuingStatusCode: 'QueuingStatusCode',
      sessionDuration: 'SessionDuration',
      totalActiveUsers: 'TotalActiveUsers',
      waitingRoomId: 'WaitingRoomId',
      waitingRoomType: 'WaitingRoomType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cookieName: 'string',
      customPageHtml: 'string',
      description: 'string',
      disableSessionRenewalEnable: 'string',
      enable: 'string',
      hostNameAndPath: { 'type': 'array', 'itemType': ListWaitingRoomsResponseBodyWaitingRoomsHostNameAndPath },
      jsonResponseEnable: 'string',
      language: 'string',
      name: 'string',
      newUsersPerMinute: 'string',
      queueAllEnable: 'string',
      queuingMethod: 'string',
      queuingStatusCode: 'string',
      sessionDuration: 'string',
      totalActiveUsers: 'string',
      waitingRoomId: 'string',
      waitingRoomType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurgeCachesRequestContent extends $tea.Model {
  /**
   * @remarks
   * The cache tags that are used to purge the cache. This parameter is required if Type is set to cachetag.
   */
  cacheTags?: string[];
  /**
   * @remarks
   * The directories that are used to purge the cache. This parameter is required if Type is set to directory.
   */
  directories?: string[];
  /**
   * @remarks
   * The files to purge. This parameter is required if Type is set to file.
   */
  files?: any[];
  /**
   * @remarks
   * The hostnames that are used to purge the cache. This parameter is required if Type is set to hostname.
   */
  hostnames?: string[];
  /**
   * @remarks
   * The file URLs with parameters ignored that are used to purge the cache. This parameter is required if Type is set to ignoreParams.
   */
  ignoreParams?: string[];
  /**
   * @remarks
   * Specifies whether to purge all cache of the website. Default value: false. The value is true when Type is set to purgeall.
   * 
   * @example
   * true
   */
  purgeAll?: boolean;
  static names(): { [key: string]: string } {
    return {
      cacheTags: 'CacheTags',
      directories: 'Directories',
      files: 'Files',
      hostnames: 'Hostnames',
      ignoreParams: 'IgnoreParams',
      purgeAll: 'PurgeAll',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheTags: { 'type': 'array', 'itemType': 'string' },
      directories: { 'type': 'array', 'itemType': 'string' },
      files: { 'type': 'array', 'itemType': 'any' },
      hostnames: { 'type': 'array', 'itemType': 'string' },
      ignoreParams: { 'type': 'array', 'itemType': 'string' },
      purgeAll: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRecordRequestAuthConf extends $tea.Model {
  /**
   * @remarks
   * The access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_same_account, or when the SourceType is S3 and AuthType is private.
   * 
   * @example
   * VIxuvJSA2S03f******kp208dy5w7
   */
  accessKey?: string;
  /**
   * @remarks
   * The authentication type of the origin server. Different origins support different authentication types. The type of origin refers to the SourceType parameter in this operation. If the type of origin is OSS or S3, you must specify the authentication type of the origin. Valid values:
   * 
   * *   **public**: public read. Select this value when the origin type is OSS or S3 and the origin access is public read.
   * *   **private**: private read. Select this value when the origin type is S3 and the origin access is private read.
   * *   **private_same_account**: private read under the same account. Select this value when the origin type is OSS, the origins belong to the same Alibaba Cloud account, and the origins have private read access.
   * 
   * @example
   * private
   */
  authType?: string;
  /**
   * @remarks
   * The version of the signature algorithm. This parameter is required when the origin type is S3 and AuthType is private. The following two types are supported:
   * 
   * *   **v2**
   * *   **v4**
   * 
   * If you leave this parameter empty, the default value v4 is used.
   * 
   * @example
   * v2
   */
  region?: string;
  /**
   * @remarks
   * The secret access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_same_account, or when the SourceType is S3 and AuthType is private.
   * 
   * @example
   * u0Nkg5gBK*******QF5wvKMM504JUHt
   */
  secretKey?: string;
  /**
   * @remarks
   * The region of the origin. If the origin type is S3, you must specify this value. You can get the region information from the official website of S3.
   * 
   * @example
   * us-east-1
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      authType: 'AuthType',
      region: 'Region',
      secretKey: 'SecretKey',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      authType: 'string',
      region: 'string',
      secretKey: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRecordRequestData extends $tea.Model {
  /**
   * @remarks
   * The encryption algorithm used for the record, specified within the range from 0 to 255. This parameter is required when you add CERT or SSHFP records.
   * 
   * @example
   * 0
   */
  algorithm?: number;
  /**
   * @remarks
   * The public key of the certificate. This parameter is required when you add CERT, SMIMEA, or TLSA records.
   * 
   * @example
   * dGVzdGFkYWxrcw==
   */
  certificate?: string;
  /**
   * @remarks
   * The public key fingerprint of the record. This parameter is required when you add a SSHFP record.
   * 
   * @example
   * abcdef1234567890
   */
  fingerprint?: string;
  /**
   * @remarks
   * The flag bit of the record. The Flag for a CAA record indicates its priority and how it is processed, specified within the range of 0 to 255. This parameter is required when you add a CAA record.
   * 
   * @example
   * 128
   */
  flag?: number;
  /**
   * @remarks
   * The public key identification for the record, specified within the range of 0 to 65,535. This parameter is required when you add a CAA record.
   * 
   * @example
   * 0
   */
  keyTag?: number;
  /**
   * @remarks
   * The algorithm policy used to match or validate the certificate, specified within the range 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
   * 
   * @example
   * 0
   */
  matchingType?: number;
  /**
   * @remarks
   * The port of the record, specified within the range of 0 to 65,535. This parameter is required when you add an SRV record.
   * 
   * @example
   * 0
   */
  port?: number;
  /**
   * @remarks
   * The priority of the record, specified within the range of 0 to 65,535. A smaller value indicates a higher priority. This parameter is required when you add MX, SRV, and URI records.
   * 
   * @example
   * 10
   */
  priority?: number;
  /**
   * @remarks
   * The type of certificate or public key, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
   * 
   * @example
   * 0
   */
  selector?: number;
  /**
   * @remarks
   * The label of the record. The Tag of a CAA record indicate its specific type and usage. This parameter is required when you add a CAA record.
   * 
   * @example
   * issue
   */
  tag?: string;
  /**
   * @remarks
   * The certificate type of the record (in CERT records), or the public key type (in SSHFP records). This parameter is required when you add CERT or SSHFP records.
   * 
   * @example
   * 0
   */
  type?: number;
  /**
   * @remarks
   * The usage identifier of the record, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
   * 
   * @example
   * 0
   */
  usage?: number;
  /**
   * @remarks
   * The record value or part of the record content. This parameter is required when you add A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI records. It has different meanings based on different types of records:
   * 
   * *   **A/AAAA**: the IP address(es). Separate multiple IPs with commas (,). You must have at least one IPv4 address.
   * *   **CNAME**: the target domain name.
   * *   **NS**: the name servers for the domain name.
   * *   **MX**: a valid domain name of the target mail server.
   * *   **TXT**: a valid text string.
   * *   **CAA**: a valid domain name of the certificate authority.
   * *   **SRV**: a valid domain name of the target host.
   * *   **URI**: a valid URI string.
   * 
   * @example
   * example.com
   */
  value?: string;
  /**
   * @remarks
   * The weight of the record, specified within the range of 0 to 65,535. This parameter is required when you add SRV or URI records.
   * 
   * @example
   * 0
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      algorithm: 'Algorithm',
      certificate: 'Certificate',
      fingerprint: 'Fingerprint',
      flag: 'Flag',
      keyTag: 'KeyTag',
      matchingType: 'MatchingType',
      port: 'Port',
      priority: 'Priority',
      selector: 'Selector',
      tag: 'Tag',
      type: 'Type',
      usage: 'Usage',
      value: 'Value',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      algorithm: 'number',
      certificate: 'string',
      fingerprint: 'string',
      flag: 'number',
      keyTag: 'number',
      matchingType: 'number',
      port: 'number',
      priority: 'number',
      selector: 'number',
      tag: 'string',
      type: 'number',
      usage: 'number',
      value: 'string',
      weight: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestCacheReserve extends $tea.Model {
  configId?: number;
  enable?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestCacheRules extends $tea.Model {
  additionalCacheablePorts?: string;
  browserCacheMode?: string;
  browserCacheTtl?: string;
  bypassCache?: string;
  cacheDeceptionArmor?: string;
  cacheReserveEligibility?: string;
  checkPresenceCookie?: string;
  checkPresenceHeader?: string;
  configId?: number;
  edgeCacheMode?: string;
  edgeCacheTtl?: string;
  edgeStatusCodeCacheTtl?: string;
  includeCookie?: string;
  includeHeader?: string;
  queryString?: string;
  queryStringMode?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  serveStale?: string;
  sortQueryStringForCache?: string;
  userDeviceType?: string;
  userGeo?: string;
  userLanguage?: string;
  static names(): { [key: string]: string } {
    return {
      additionalCacheablePorts: 'AdditionalCacheablePorts',
      browserCacheMode: 'BrowserCacheMode',
      browserCacheTtl: 'BrowserCacheTtl',
      bypassCache: 'BypassCache',
      cacheDeceptionArmor: 'CacheDeceptionArmor',
      cacheReserveEligibility: 'CacheReserveEligibility',
      checkPresenceCookie: 'CheckPresenceCookie',
      checkPresenceHeader: 'CheckPresenceHeader',
      configId: 'ConfigId',
      edgeCacheMode: 'EdgeCacheMode',
      edgeCacheTtl: 'EdgeCacheTtl',
      edgeStatusCodeCacheTtl: 'EdgeStatusCodeCacheTtl',
      includeCookie: 'IncludeCookie',
      includeHeader: 'IncludeHeader',
      queryString: 'QueryString',
      queryStringMode: 'QueryStringMode',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      serveStale: 'ServeStale',
      sortQueryStringForCache: 'SortQueryStringForCache',
      userDeviceType: 'UserDeviceType',
      userGeo: 'UserGeo',
      userLanguage: 'UserLanguage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      additionalCacheablePorts: 'string',
      browserCacheMode: 'string',
      browserCacheTtl: 'string',
      bypassCache: 'string',
      cacheDeceptionArmor: 'string',
      cacheReserveEligibility: 'string',
      checkPresenceCookie: 'string',
      checkPresenceHeader: 'string',
      configId: 'number',
      edgeCacheMode: 'string',
      edgeCacheTtl: 'string',
      edgeStatusCodeCacheTtl: 'string',
      includeCookie: 'string',
      includeHeader: 'string',
      queryString: 'string',
      queryStringMode: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      serveStale: 'string',
      sortQueryStringForCache: 'string',
      userDeviceType: 'string',
      userGeo: 'string',
      userLanguage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestCacheTags extends $tea.Model {
  caseInsensitive?: string;
  configId?: number;
  tagName?: string;
  static names(): { [key: string]: string } {
    return {
      caseInsensitive: 'CaseInsensitive',
      configId: 'ConfigId',
      tagName: 'TagName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      caseInsensitive: 'string',
      configId: 'number',
      tagName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestCnameFlattening extends $tea.Model {
  configId?: number;
  flattenMode?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      flattenMode: 'FlattenMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      flattenMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestCompressionRules extends $tea.Model {
  brotli?: string;
  configId?: number;
  gzip?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      brotli: 'Brotli',
      configId: 'ConfigId',
      gzip: 'Gzip',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      brotli: 'string',
      configId: 'number',
      gzip: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestCrossBorderOptimization extends $tea.Model {
  configId?: number;
  enable?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestDevelopmentMode extends $tea.Model {
  configId?: number;
  enable?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification extends $tea.Model {
  name?: string;
  operation?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      operation: 'Operation',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      operation: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestHttpRequestHeaderModificationRules extends $tea.Model {
  configId?: number;
  requestHeaderModification?: UpdateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification[];
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      requestHeaderModification: 'RequestHeaderModification',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      requestHeaderModification: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification },
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification extends $tea.Model {
  name?: string;
  operation?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      operation: 'Operation',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      operation: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestHttpResponseHeaderModificationRules extends $tea.Model {
  configId?: number;
  responseHeaderModification?: UpdateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification[];
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      responseHeaderModification: 'ResponseHeaderModification',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      responseHeaderModification: { 'type': 'array', 'itemType': UpdateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification },
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestHttpsApplicationConfiguration extends $tea.Model {
  altSvc?: string;
  altSvcClear?: string;
  altSvcMa?: string;
  altSvcPersist?: string;
  configId?: number;
  hsts?: string;
  hstsIncludeSubdomains?: string;
  hstsMaxAge?: string;
  hstsPreload?: string;
  httpsForce?: string;
  httpsForceCode?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      altSvc: 'AltSvc',
      altSvcClear: 'AltSvcClear',
      altSvcMa: 'AltSvcMa',
      altSvcPersist: 'AltSvcPersist',
      configId: 'ConfigId',
      hsts: 'Hsts',
      hstsIncludeSubdomains: 'HstsIncludeSubdomains',
      hstsMaxAge: 'HstsMaxAge',
      hstsPreload: 'HstsPreload',
      httpsForce: 'HttpsForce',
      httpsForceCode: 'HttpsForceCode',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      altSvc: 'string',
      altSvcClear: 'string',
      altSvcMa: 'string',
      altSvcPersist: 'string',
      configId: 'number',
      hsts: 'string',
      hstsIncludeSubdomains: 'string',
      hstsMaxAge: 'string',
      hstsPreload: 'string',
      httpsForce: 'string',
      httpsForceCode: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestHttpsBasicConfiguration extends $tea.Model {
  ciphersuite?: string;
  ciphersuiteGroup?: string;
  configId?: number;
  http2?: string;
  http3?: string;
  https?: string;
  ocspStapling?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  tls10?: string;
  tls11?: string;
  tls12?: string;
  tls13?: string;
  static names(): { [key: string]: string } {
    return {
      ciphersuite: 'Ciphersuite',
      ciphersuiteGroup: 'CiphersuiteGroup',
      configId: 'ConfigId',
      http2: 'Http2',
      http3: 'Http3',
      https: 'Https',
      ocspStapling: 'OcspStapling',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      tls10: 'Tls10',
      tls11: 'Tls11',
      tls12: 'Tls12',
      tls13: 'Tls13',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ciphersuite: 'string',
      ciphersuiteGroup: 'string',
      configId: 'number',
      http2: 'string',
      http3: 'string',
      https: 'string',
      ocspStapling: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      tls10: 'string',
      tls11: 'string',
      tls12: 'string',
      tls13: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestImageTransform extends $tea.Model {
  configId?: number;
  enable?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestIpv6 extends $tea.Model {
  configId?: number;
  enable?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestManagedTransforms extends $tea.Model {
  addClientGeolocationHeaders?: string;
  addRealClientIpHeader?: string;
  configId?: number;
  static names(): { [key: string]: string } {
    return {
      addClientGeolocationHeaders: 'AddClientGeolocationHeaders',
      addRealClientIpHeader: 'AddRealClientIpHeader',
      configId: 'ConfigId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addClientGeolocationHeaders: 'string',
      addRealClientIpHeader: 'string',
      configId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestNetworkOptimization extends $tea.Model {
  configId?: number;
  grpc?: string;
  http2Origin?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  smartRouting?: string;
  uploadMaxFilesize?: string;
  websocket?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      grpc: 'Grpc',
      http2Origin: 'Http2Origin',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      smartRouting: 'SmartRouting',
      uploadMaxFilesize: 'UploadMaxFilesize',
      websocket: 'Websocket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      grpc: 'string',
      http2Origin: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      smartRouting: 'string',
      uploadMaxFilesize: 'string',
      websocket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestOriginRules extends $tea.Model {
  configId?: number;
  dnsRecord?: string;
  originHost?: string;
  originHttpPort?: string;
  originHttpsPort?: string;
  originScheme?: string;
  originSni?: string;
  range?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      dnsRecord: 'DnsRecord',
      originHost: 'OriginHost',
      originHttpPort: 'OriginHttpPort',
      originHttpsPort: 'OriginHttpsPort',
      originScheme: 'OriginScheme',
      originSni: 'OriginSni',
      range: 'Range',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      dnsRecord: 'string',
      originHost: 'string',
      originHttpPort: 'string',
      originHttpsPort: 'string',
      originScheme: 'string',
      originSni: 'string',
      range: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestRedirectRules extends $tea.Model {
  configId?: number;
  reserveQueryString?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  statusCode?: string;
  targetUrl?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      reserveQueryString: 'ReserveQueryString',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      statusCode: 'StatusCode',
      targetUrl: 'TargetUrl',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      reserveQueryString: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      statusCode: 'string',
      targetUrl: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestRewriteUrlRules extends $tea.Model {
  configId?: number;
  queryString?: string;
  rewriteQueryStringType?: string;
  rewriteUriType?: string;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  uri?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      queryString: 'QueryString',
      rewriteQueryStringType: 'RewriteQueryStringType',
      rewriteUriType: 'RewriteUriType',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      uri: 'Uri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      queryString: 'string',
      rewriteQueryStringType: 'string',
      rewriteUriType: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      uri: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestSeoBypass extends $tea.Model {
  configId?: number;
  enable?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestSiteNameExclusive extends $tea.Model {
  configId?: number;
  enable?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestSitePause extends $tea.Model {
  configId?: number;
  paused?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      paused: 'Paused',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      paused: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteFunctionRequestTieredCache extends $tea.Model {
  cacheArchitectureMode?: string;
  configId?: number;
  static names(): { [key: string]: string } {
    return {
      cacheArchitectureMode: 'CacheArchitectureMode',
      configId: 'ConfigId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheArchitectureMode: 'string',
      configId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomRequestHostNameAndPath extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domain?: string;
  /**
   * @remarks
   * The probe path.
   * 
   * @example
   * /test
   */
  path?: string;
  /**
   * @remarks
   * The subdomain.
   * 
   * @example
   * test.
   */
  subdomain?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      path: 'Path',
      subdomain: 'Subdomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      path: 'string',
      subdomain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "";
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("esa", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  /**
   * Activates a client certificate.
   * 
   * @param request - ActivateClientCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ActivateClientCertificateResponse
   */
  async activateClientCertificateWithOptions(request: ActivateClientCertificateRequest, runtime: $Util.RuntimeOptions): Promise<ActivateClientCertificateResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ActivateClientCertificate",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ActivateClientCertificateResponse>(await this.callApi(params, req, runtime), new ActivateClientCertificateResponse({}));
  }

  /**
   * Activates a client certificate.
   * 
   * @param request - ActivateClientCertificateRequest
   * @returns ActivateClientCertificateResponse
   */
  async activateClientCertificate(request: ActivateClientCertificateRequest): Promise<ActivateClientCertificateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.activateClientCertificateWithOptions(request, runtime);
  }

  /**
   * Adds DNS records of different record types at a time..
   * 
   * @remarks
   * This operation allows you to create or update multiple DNS records at a time. It is suitable for managing a large number of DNS configurations. Supported record types include but are not limited to A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI. The operation allows you to configure the priority, flag, tag, and weight for DNS records. In addition, for specific types of records, such as CERT, SSHFP, SMIMEA, and TLSA, advanced settings such as certificate information and encryption algorithms are also supported.
   * Successful and failed records along with error messages are listed in the response.
   * 
   * @param tmpReq - BatchCreateRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchCreateRecordsResponse
   */
  async batchCreateRecordsWithOptions(tmpReq: BatchCreateRecordsRequest, runtime: $Util.RuntimeOptions): Promise<BatchCreateRecordsResponse> {
    Util.validateModel(tmpReq);
    let request = new BatchCreateRecordsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.recordList)) {
      request.recordListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.recordList, "RecordList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.recordListShrink)) {
      query["RecordList"] = request.recordListShrink;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchCreateRecords",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchCreateRecordsResponse>(await this.callApi(params, req, runtime), new BatchCreateRecordsResponse({}));
  }

  /**
   * Adds DNS records of different record types at a time..
   * 
   * @remarks
   * This operation allows you to create or update multiple DNS records at a time. It is suitable for managing a large number of DNS configurations. Supported record types include but are not limited to A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI. The operation allows you to configure the priority, flag, tag, and weight for DNS records. In addition, for specific types of records, such as CERT, SSHFP, SMIMEA, and TLSA, advanced settings such as certificate information and encryption algorithms are also supported.
   * Successful and failed records along with error messages are listed in the response.
   * 
   * @param request - BatchCreateRecordsRequest
   * @returns BatchCreateRecordsResponse
   */
  async batchCreateRecords(request: BatchCreateRecordsRequest): Promise<BatchCreateRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchCreateRecordsWithOptions(request, runtime);
  }

  /**
   * Creates multiple rules of a specific Web Application Firewall (WAF) rule category at a time. You can also configure shared settings for the rules.
   * 
   * @param tmpReq - BatchCreateWafRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchCreateWafRulesResponse
   */
  async batchCreateWafRulesWithOptions(tmpReq: BatchCreateWafRulesRequest, runtime: $Util.RuntimeOptions): Promise<BatchCreateWafRulesResponse> {
    Util.validateModel(tmpReq);
    let request = new BatchCreateWafRulesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.configs)) {
      request.configsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.configs, "Configs", "json");
    }

    if (!Util.isUnset(tmpReq.shared)) {
      request.sharedShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.shared, "Shared", "json");
    }

    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.configsShrink)) {
      body["Configs"] = request.configsShrink;
    }

    if (!Util.isUnset(request.phase)) {
      body["Phase"] = request.phase;
    }

    if (!Util.isUnset(request.sharedShrink)) {
      body["Shared"] = request.sharedShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchCreateWafRules",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchCreateWafRulesResponse>(await this.callApi(params, req, runtime), new BatchCreateWafRulesResponse({}));
  }

  /**
   * Creates multiple rules of a specific Web Application Firewall (WAF) rule category at a time. You can also configure shared settings for the rules.
   * 
   * @param request - BatchCreateWafRulesRequest
   * @returns BatchCreateWafRulesResponse
   */
  async batchCreateWafRules(request: BatchCreateWafRulesRequest): Promise<BatchCreateWafRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchCreateWafRulesWithOptions(request, runtime);
  }

  /**
   * Deletes key-value pairs from a namespace at a time based on keys.
   * 
   * @param tmpReq - BatchDeleteKvRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchDeleteKvResponse
   */
  async batchDeleteKvWithOptions(tmpReq: BatchDeleteKvRequest, runtime: $Util.RuntimeOptions): Promise<BatchDeleteKvResponse> {
    Util.validateModel(tmpReq);
    let request = new BatchDeleteKvShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.keys)) {
      request.keysShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.keys, "Keys", "json");
    }

    let query = { };
    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.keysShrink)) {
      body["Keys"] = request.keysShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchDeleteKv",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchDeleteKvResponse>(await this.callApi(params, req, runtime), new BatchDeleteKvResponse({}));
  }

  /**
   * Deletes key-value pairs from a namespace at a time based on keys.
   * 
   * @param request - BatchDeleteKvRequest
   * @returns BatchDeleteKvResponse
   */
  async batchDeleteKv(request: BatchDeleteKvRequest): Promise<BatchDeleteKvResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchDeleteKvWithOptions(request, runtime);
  }

  /**
   * Deletes multiple key-value pairs from a namespace at a time based on specified keys. The request body can be up to 100 MB.
   * 
   * @remarks
   * This operation allows you to upload a larger request body than by using [BatchDeleteKv](https://help.aliyun.com/document_detail/2850204.html). For small request bodies, we recommend that you use [BatchDeleteKv](https://help.aliyun.com/document_detail/2850204.html) to minimize the server processing time. This operation must be called by using SDKs. The following sample code uses the Golang SDK and BatchDeleteKvWithHighCapacityAdvance to call the operation.
   *     func TestBatchDeleteWithHighCapacity() error {
   *     	// Initialize the configurations.
   *     	cfg := new(openapi.Config)
   *     	cfg.SetAccessKeyId("xxxxxxxxx")
   *     	cfg.SetAccessKeySecret("xxxxxxxxxx")
   *     	cli, err := NewClient(cfg)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	runtime := &util.RuntimeOptions{}
   *     	// Construct a request for deleting key-value pairs at a time.
   *     	namespace := "test_batch_put"
   *     	rawReq := BatchDeleteKvRequest{
   *     		Namespace: &namespace,
   *     	}
   *     	for i := 0; i < 10000; i++ {
   *     		key := fmt.Sprintf("test_key_%d", i)
   *     		rawReq.Keys = append(rawReq.Keys, &key)
   *     	}
   *     	payload, err := json.Marshal(rawReq)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	// If the payload is greater than 2 MB, call the BatchDeleteKvWithHighCapacity operation for deletion.
   *     	reqHighCapacity := BatchDeleteKvWithHighCapacityAdvanceRequest{
   *     		Namespace: &namespace,
   *     		UrlObject: bytes.NewReader(payload),
   *     	}
   *     	resp, err := cli.BatchDeleteKvWithHighCapacityAdvance(&reqHighCapacity, runtime)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	return nil
   *     }
   * 
   * @param request - BatchDeleteKvWithHighCapacityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchDeleteKvWithHighCapacityResponse
   */
  async batchDeleteKvWithHighCapacityWithOptions(request: BatchDeleteKvWithHighCapacityRequest, runtime: $Util.RuntimeOptions): Promise<BatchDeleteKvWithHighCapacityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.url)) {
      query["Url"] = request.url;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchDeleteKvWithHighCapacity",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchDeleteKvWithHighCapacityResponse>(await this.callApi(params, req, runtime), new BatchDeleteKvWithHighCapacityResponse({}));
  }

  /**
   * Deletes multiple key-value pairs from a namespace at a time based on specified keys. The request body can be up to 100 MB.
   * 
   * @remarks
   * This operation allows you to upload a larger request body than by using [BatchDeleteKv](https://help.aliyun.com/document_detail/2850204.html). For small request bodies, we recommend that you use [BatchDeleteKv](https://help.aliyun.com/document_detail/2850204.html) to minimize the server processing time. This operation must be called by using SDKs. The following sample code uses the Golang SDK and BatchDeleteKvWithHighCapacityAdvance to call the operation.
   *     func TestBatchDeleteWithHighCapacity() error {
   *     	// Initialize the configurations.
   *     	cfg := new(openapi.Config)
   *     	cfg.SetAccessKeyId("xxxxxxxxx")
   *     	cfg.SetAccessKeySecret("xxxxxxxxxx")
   *     	cli, err := NewClient(cfg)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	runtime := &util.RuntimeOptions{}
   *     	// Construct a request for deleting key-value pairs at a time.
   *     	namespace := "test_batch_put"
   *     	rawReq := BatchDeleteKvRequest{
   *     		Namespace: &namespace,
   *     	}
   *     	for i := 0; i < 10000; i++ {
   *     		key := fmt.Sprintf("test_key_%d", i)
   *     		rawReq.Keys = append(rawReq.Keys, &key)
   *     	}
   *     	payload, err := json.Marshal(rawReq)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	// If the payload is greater than 2 MB, call the BatchDeleteKvWithHighCapacity operation for deletion.
   *     	reqHighCapacity := BatchDeleteKvWithHighCapacityAdvanceRequest{
   *     		Namespace: &namespace,
   *     		UrlObject: bytes.NewReader(payload),
   *     	}
   *     	resp, err := cli.BatchDeleteKvWithHighCapacityAdvance(&reqHighCapacity, runtime)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	return nil
   *     }
   * 
   * @param request - BatchDeleteKvWithHighCapacityRequest
   * @returns BatchDeleteKvWithHighCapacityResponse
   */
  async batchDeleteKvWithHighCapacity(request: BatchDeleteKvWithHighCapacityRequest): Promise<BatchDeleteKvWithHighCapacityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchDeleteKvWithHighCapacityWithOptions(request, runtime);
  }

  async batchDeleteKvWithHighCapacityAdvance(request: BatchDeleteKvWithHighCapacityAdvanceRequest, runtime: $Util.RuntimeOptions): Promise<BatchDeleteKvWithHighCapacityResponse> {
    // Step 0: init client
    let accessKeyId = await this._credential.getAccessKeyId();
    let accessKeySecret = await this._credential.getAccessKeySecret();
    let securityToken = await this._credential.getSecurityToken();
    let credentialType = this._credential.getType();
    let openPlatformEndpoint = this._openPlatformEndpoint;
    if (Util.empty(openPlatformEndpoint)) {
      openPlatformEndpoint = "openplatform.aliyuncs.com";
    }

    if (Util.isUnset(credentialType)) {
      credentialType = "access_key";
    }

    let authConfig = new $OpenApi.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      securityToken: securityToken,
      type: credentialType,
      endpoint: openPlatformEndpoint,
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let authClient = new OpenPlatform(authConfig);
    let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
      product: "ESA",
      regionId: this._regionId,
    });
    let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({ });
    let ossConfig = new $OSS.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      type: "access_key",
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let ossClient : OSS = new OSS(ossConfig);
    let fileObj = new $FileForm.FileField({ });
    let ossHeader = new $OSS.PostObjectRequestHeader({ });
    let uploadRequest = new $OSS.PostObjectRequest({ });
    let ossRuntime = new $OSSUtil.RuntimeOptions({ });
    OpenApiUtil.convert(runtime, ossRuntime);
    let batchDeleteKvWithHighCapacityReq = new BatchDeleteKvWithHighCapacityRequest({ });
    OpenApiUtil.convert(request, batchDeleteKvWithHighCapacityReq);
    if (!Util.isUnset(request.urlObject)) {
      authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
      ossConfig.accessKeyId = authResponse.body.accessKeyId;
      ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
      ossClient = new OSS(ossConfig);
      fileObj = new $FileForm.FileField({
        filename: authResponse.body.objectKey,
        content: request.urlObject,
        contentType: "",
      });
      ossHeader = new $OSS.PostObjectRequestHeader({
        accessKeyId: authResponse.body.accessKeyId,
        policy: authResponse.body.encodedPolicy,
        signature: authResponse.body.signature,
        key: authResponse.body.objectKey,
        file: fileObj,
        successActionStatus: "201",
      });
      uploadRequest = new $OSS.PostObjectRequest({
        bucketName: authResponse.body.bucket,
        header: ossHeader,
      });
      await ossClient.postObject(uploadRequest, ossRuntime);
      batchDeleteKvWithHighCapacityReq.url = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
    }

    let batchDeleteKvWithHighCapacityResp = await this.batchDeleteKvWithHighCapacityWithOptions(batchDeleteKvWithHighCapacityReq, runtime);
    return batchDeleteKvWithHighCapacityResp;
  }

  /**
   * Batch queries the objects that match specific expressions.
   * 
   * @param tmpReq - BatchGetExpressionFieldsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchGetExpressionFieldsResponse
   */
  async batchGetExpressionFieldsWithOptions(tmpReq: BatchGetExpressionFieldsRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetExpressionFieldsResponse> {
    Util.validateModel(tmpReq);
    let request = new BatchGetExpressionFieldsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.expressions)) {
      request.expressionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.expressions, "Expressions", "json");
    }

    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.expressionsShrink)) {
      body["Expressions"] = request.expressionsShrink;
    }

    if (!Util.isUnset(request.phase)) {
      body["Phase"] = request.phase;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchGetExpressionFields",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchGetExpressionFieldsResponse>(await this.callApi(params, req, runtime), new BatchGetExpressionFieldsResponse({}));
  }

  /**
   * Batch queries the objects that match specific expressions.
   * 
   * @param request - BatchGetExpressionFieldsRequest
   * @returns BatchGetExpressionFieldsResponse
   */
  async batchGetExpressionFields(request: BatchGetExpressionFieldsRequest): Promise<BatchGetExpressionFieldsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetExpressionFieldsWithOptions(request, runtime);
  }

  /**
   * Configures key-value pairs for a namespace at a time based on specified keys.
   * 
   * @param tmpReq - BatchPutKvRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchPutKvResponse
   */
  async batchPutKvWithOptions(tmpReq: BatchPutKvRequest, runtime: $Util.RuntimeOptions): Promise<BatchPutKvResponse> {
    Util.validateModel(tmpReq);
    let request = new BatchPutKvShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.kvList)) {
      request.kvListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.kvList, "KvList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.kvListShrink)) {
      body["KvList"] = request.kvListShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchPutKv",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchPutKvResponse>(await this.callApi(params, req, runtime), new BatchPutKvResponse({}));
  }

  /**
   * Configures key-value pairs for a namespace at a time based on specified keys.
   * 
   * @param request - BatchPutKvRequest
   * @returns BatchPutKvResponse
   */
  async batchPutKv(request: BatchPutKvRequest): Promise<BatchPutKvResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchPutKvWithOptions(request, runtime);
  }

  /**
   * Configures key-value pairs for a namespace at a time based on specified keys. The request body can be up to 100 MB.
   * 
   * @remarks
   * This operation allows you to upload a larger request body than by using [BatchPutKv](https://help.aliyun.com/document_detail/2850203.html). For small request bodies, we recommend that you use [BatchPutKv](https://help.aliyun.com/document_detail/2850203.html) to minimize the server processing time. This operation must be called by using SDKs. The following sample code uses the Golang SDK and BatchPutKvWithHighCapacityAdvance to call the operation.
   *     func TestBatchPutKvWithHighCapacity() error {
   *     	// Initialize the configurations.
   *     	cfg := new(openapi.Config)
   *     	cfg.SetAccessKeyId("xxxxxxxxx")
   *     	cfg.SetAccessKeySecret("xxxxxxxxxx")
   *     	cli, err := NewClient(cfg)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	runtime := &util.RuntimeOptions{}
   *     	// Construct a request for uploading key-value pairs at a time.
   *     	namespace := "test_batch_put"
   *     	numKv := 10000
   *     	kvList := make([]*BatchPutKvRequestKvList, numKv)
   *     	test_value := strings.Repeat("a", 10*1024)
   *     	for i := 0; i < numKv; i++ {
   *     		key := fmt.Sprintf("test_key_%d", i)
   *     		value := test_value
   *     		kvList[i] = &BatchPutKvRequestKvList{
   *     			Key:   &key,
   *     			Value: &value,
   *     		}
   *     	}
   *     	rawReq := BatchPutKvRequest{
   *     		Namespace: &namespace,
   *     		KvList:    kvList,
   *     	}
   *     	payload, err := json.Marshal(rawReq)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	// If the payload is greater than 2 MB, call the BatchPutKvWithHighCapacity operation for upload.
   *     	reqHighCapacity := BatchPutKvWithHighCapacityAdvanceRequest{
   *     		Namespace: &namespace,
   *     		UrlObject: bytes.NewReader(payload),
   *     	}
   *     	resp, err := cli.BatchPutKvWithHighCapacityAdvance(&reqHighCapacity, runtime)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	return nil
   *     }
   * 
   * @param request - BatchPutKvWithHighCapacityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchPutKvWithHighCapacityResponse
   */
  async batchPutKvWithHighCapacityWithOptions(request: BatchPutKvWithHighCapacityRequest, runtime: $Util.RuntimeOptions): Promise<BatchPutKvWithHighCapacityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.url)) {
      query["Url"] = request.url;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchPutKvWithHighCapacity",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchPutKvWithHighCapacityResponse>(await this.callApi(params, req, runtime), new BatchPutKvWithHighCapacityResponse({}));
  }

  /**
   * Configures key-value pairs for a namespace at a time based on specified keys. The request body can be up to 100 MB.
   * 
   * @remarks
   * This operation allows you to upload a larger request body than by using [BatchPutKv](https://help.aliyun.com/document_detail/2850203.html). For small request bodies, we recommend that you use [BatchPutKv](https://help.aliyun.com/document_detail/2850203.html) to minimize the server processing time. This operation must be called by using SDKs. The following sample code uses the Golang SDK and BatchPutKvWithHighCapacityAdvance to call the operation.
   *     func TestBatchPutKvWithHighCapacity() error {
   *     	// Initialize the configurations.
   *     	cfg := new(openapi.Config)
   *     	cfg.SetAccessKeyId("xxxxxxxxx")
   *     	cfg.SetAccessKeySecret("xxxxxxxxxx")
   *     	cli, err := NewClient(cfg)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	runtime := &util.RuntimeOptions{}
   *     	// Construct a request for uploading key-value pairs at a time.
   *     	namespace := "test_batch_put"
   *     	numKv := 10000
   *     	kvList := make([]*BatchPutKvRequestKvList, numKv)
   *     	test_value := strings.Repeat("a", 10*1024)
   *     	for i := 0; i < numKv; i++ {
   *     		key := fmt.Sprintf("test_key_%d", i)
   *     		value := test_value
   *     		kvList[i] = &BatchPutKvRequestKvList{
   *     			Key:   &key,
   *     			Value: &value,
   *     		}
   *     	}
   *     	rawReq := BatchPutKvRequest{
   *     		Namespace: &namespace,
   *     		KvList:    kvList,
   *     	}
   *     	payload, err := json.Marshal(rawReq)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	// If the payload is greater than 2 MB, call the BatchPutKvWithHighCapacity operation for upload.
   *     	reqHighCapacity := BatchPutKvWithHighCapacityAdvanceRequest{
   *     		Namespace: &namespace,
   *     		UrlObject: bytes.NewReader(payload),
   *     	}
   *     	resp, err := cli.BatchPutKvWithHighCapacityAdvance(&reqHighCapacity, runtime)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	return nil
   *     }
   * 
   * @param request - BatchPutKvWithHighCapacityRequest
   * @returns BatchPutKvWithHighCapacityResponse
   */
  async batchPutKvWithHighCapacity(request: BatchPutKvWithHighCapacityRequest): Promise<BatchPutKvWithHighCapacityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchPutKvWithHighCapacityWithOptions(request, runtime);
  }

  async batchPutKvWithHighCapacityAdvance(request: BatchPutKvWithHighCapacityAdvanceRequest, runtime: $Util.RuntimeOptions): Promise<BatchPutKvWithHighCapacityResponse> {
    // Step 0: init client
    let accessKeyId = await this._credential.getAccessKeyId();
    let accessKeySecret = await this._credential.getAccessKeySecret();
    let securityToken = await this._credential.getSecurityToken();
    let credentialType = this._credential.getType();
    let openPlatformEndpoint = this._openPlatformEndpoint;
    if (Util.empty(openPlatformEndpoint)) {
      openPlatformEndpoint = "openplatform.aliyuncs.com";
    }

    if (Util.isUnset(credentialType)) {
      credentialType = "access_key";
    }

    let authConfig = new $OpenApi.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      securityToken: securityToken,
      type: credentialType,
      endpoint: openPlatformEndpoint,
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let authClient = new OpenPlatform(authConfig);
    let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
      product: "ESA",
      regionId: this._regionId,
    });
    let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({ });
    let ossConfig = new $OSS.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      type: "access_key",
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let ossClient : OSS = new OSS(ossConfig);
    let fileObj = new $FileForm.FileField({ });
    let ossHeader = new $OSS.PostObjectRequestHeader({ });
    let uploadRequest = new $OSS.PostObjectRequest({ });
    let ossRuntime = new $OSSUtil.RuntimeOptions({ });
    OpenApiUtil.convert(runtime, ossRuntime);
    let batchPutKvWithHighCapacityReq = new BatchPutKvWithHighCapacityRequest({ });
    OpenApiUtil.convert(request, batchPutKvWithHighCapacityReq);
    if (!Util.isUnset(request.urlObject)) {
      authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
      ossConfig.accessKeyId = authResponse.body.accessKeyId;
      ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
      ossClient = new OSS(ossConfig);
      fileObj = new $FileForm.FileField({
        filename: authResponse.body.objectKey,
        content: request.urlObject,
        contentType: "",
      });
      ossHeader = new $OSS.PostObjectRequestHeader({
        accessKeyId: authResponse.body.accessKeyId,
        policy: authResponse.body.encodedPolicy,
        signature: authResponse.body.signature,
        key: authResponse.body.objectKey,
        file: fileObj,
        successActionStatus: "201",
      });
      uploadRequest = new $OSS.PostObjectRequest({
        bucketName: authResponse.body.bucket,
        header: ossHeader,
      });
      await ossClient.postObject(uploadRequest, ossRuntime);
      batchPutKvWithHighCapacityReq.url = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
    }

    let batchPutKvWithHighCapacityResp = await this.batchPutKvWithHighCapacityWithOptions(batchPutKvWithHighCapacityReq, runtime);
    return batchPutKvWithHighCapacityResp;
  }

  /**
   * Modifies multiple rules in a specific Web Application Firewall (WAF) ruleset at a time.
   * 
   * @param tmpReq - BatchUpdateWafRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchUpdateWafRulesResponse
   */
  async batchUpdateWafRulesWithOptions(tmpReq: BatchUpdateWafRulesRequest, runtime: $Util.RuntimeOptions): Promise<BatchUpdateWafRulesResponse> {
    Util.validateModel(tmpReq);
    let request = new BatchUpdateWafRulesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.configs)) {
      request.configsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.configs, "Configs", "json");
    }

    if (!Util.isUnset(tmpReq.shared)) {
      request.sharedShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.shared, "Shared", "json");
    }

    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.configsShrink)) {
      body["Configs"] = request.configsShrink;
    }

    if (!Util.isUnset(request.phase)) {
      body["Phase"] = request.phase;
    }

    if (!Util.isUnset(request.rulesetId)) {
      body["RulesetId"] = request.rulesetId;
    }

    if (!Util.isUnset(request.sharedShrink)) {
      body["Shared"] = request.sharedShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchUpdateWafRules",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchUpdateWafRulesResponse>(await this.callApi(params, req, runtime), new BatchUpdateWafRulesResponse({}));
  }

  /**
   * Modifies multiple rules in a specific Web Application Firewall (WAF) ruleset at a time.
   * 
   * @param request - BatchUpdateWafRulesRequest
   * @returns BatchUpdateWafRulesResponse
   */
  async batchUpdateWafRules(request: BatchUpdateWafRulesRequest): Promise<BatchUpdateWafRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchUpdateWafRulesWithOptions(request, runtime);
  }

  /**
   * Blocks URLs.
   * 
   * @param tmpReq - BlockObjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BlockObjectResponse
   */
  async blockObjectWithOptions(tmpReq: BlockObjectRequest, runtime: $Util.RuntimeOptions): Promise<BlockObjectResponse> {
    Util.validateModel(tmpReq);
    let request = new BlockObjectShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.content)) {
      request.contentShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.content, "Content", "json");
    }

    let query = { };
    if (!Util.isUnset(request.contentShrink)) {
      query["Content"] = request.contentShrink;
    }

    if (!Util.isUnset(request.extension)) {
      query["Extension"] = request.extension;
    }

    if (!Util.isUnset(request.maxage)) {
      query["Maxage"] = request.maxage;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BlockObject",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BlockObjectResponse>(await this.callApi(params, req, runtime), new BlockObjectResponse({}));
  }

  /**
   * Blocks URLs.
   * 
   * @param request - BlockObjectRequest
   * @returns BlockObjectResponse
   */
  async blockObject(request: BlockObjectRequest): Promise<BlockObjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.blockObjectWithOptions(request, runtime);
  }

  /**
   * Moves a website from one resource group to another.
   * 
   * @param request - ChangeResourceGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ChangeResourceGroupResponse
   */
  async changeResourceGroupWithOptions(request: ChangeResourceGroupRequest, runtime: $Util.RuntimeOptions): Promise<ChangeResourceGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ChangeResourceGroup",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ChangeResourceGroupResponse>(await this.callApi(params, req, runtime), new ChangeResourceGroupResponse({}));
  }

  /**
   * Moves a website from one resource group to another.
   * 
   * @param request - ChangeResourceGroupRequest
   * @returns ChangeResourceGroupResponse
   */
  async changeResourceGroup(request: ChangeResourceGroupRequest): Promise<ChangeResourceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.changeResourceGroupWithOptions(request, runtime);
  }

  /**
   * Checks whether a specified website name is available.
   * 
   * @param request - CheckSiteNameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CheckSiteNameResponse
   */
  async checkSiteNameWithOptions(request: CheckSiteNameRequest, runtime: $Util.RuntimeOptions): Promise<CheckSiteNameResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.siteName)) {
      query["SiteName"] = request.siteName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CheckSiteName",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CheckSiteNameResponse>(await this.callApi(params, req, runtime), new CheckSiteNameResponse({}));
  }

  /**
   * Checks whether a specified website name is available.
   * 
   * @param request - CheckSiteNameRequest
   * @returns CheckSiteNameResponse
   */
  async checkSiteName(request: CheckSiteNameRequest): Promise<CheckSiteNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.checkSiteNameWithOptions(request, runtime);
  }

  /**
   * Checks the name of a real-time log delivery task.
   * 
   * @param request - CheckSiteProjectNameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CheckSiteProjectNameResponse
   */
  async checkSiteProjectNameWithOptions(request: CheckSiteProjectNameRequest, runtime: $Util.RuntimeOptions): Promise<CheckSiteProjectNameResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CheckSiteProjectName",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CheckSiteProjectNameResponse>(await this.callApi(params, req, runtime), new CheckSiteProjectNameResponse({}));
  }

  /**
   * Checks the name of a real-time log delivery task.
   * 
   * @param request - CheckSiteProjectNameRequest
   * @returns CheckSiteProjectNameResponse
   */
  async checkSiteProjectName(request: CheckSiteProjectNameRequest): Promise<CheckSiteProjectNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.checkSiteProjectNameWithOptions(request, runtime);
  }

  /**
   * Checks the name of a real-time log delivery task by account.
   * 
   * @param request - CheckUserProjectNameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CheckUserProjectNameResponse
   */
  async checkUserProjectNameWithOptions(request: CheckUserProjectNameRequest, runtime: $Util.RuntimeOptions): Promise<CheckUserProjectNameResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CheckUserProjectName",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CheckUserProjectNameResponse>(await this.callApi(params, req, runtime), new CheckUserProjectNameResponse({}));
  }

  /**
   * Checks the name of a real-time log delivery task by account.
   * 
   * @param request - CheckUserProjectNameRequest
   * @returns CheckUserProjectNameResponse
   */
  async checkUserProjectName(request: CheckUserProjectNameRequest): Promise<CheckUserProjectNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.checkUserProjectNameWithOptions(request, runtime);
  }

  /**
   * Commits the unstable code in the staging environment to generate an official code version.
   * 
   * @param request - CommitRoutineStagingCodeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CommitRoutineStagingCodeResponse
   */
  async commitRoutineStagingCodeWithOptions(request: CommitRoutineStagingCodeRequest, runtime: $Util.RuntimeOptions): Promise<CommitRoutineStagingCodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.codeDescription)) {
      body["CodeDescription"] = request.codeDescription;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CommitRoutineStagingCode",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CommitRoutineStagingCodeResponse>(await this.callApi(params, req, runtime), new CommitRoutineStagingCodeResponse({}));
  }

  /**
   * Commits the unstable code in the staging environment to generate an official code version.
   * 
   * @param request - CommitRoutineStagingCodeRequest
   * @returns CommitRoutineStagingCodeResponse
   */
  async commitRoutineStagingCode(request: CommitRoutineStagingCodeRequest): Promise<CommitRoutineStagingCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.commitRoutineStagingCodeWithOptions(request, runtime);
  }

  /**
   * Creates an account-level custom scenario policy. You can execute a policy after you associate the policy with a website.
   * 
   * @param request - CreateCustomScenePolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateCustomScenePolicyResponse
   */
  async createCustomScenePolicyWithOptions(request: CreateCustomScenePolicyRequest, runtime: $Util.RuntimeOptions): Promise<CreateCustomScenePolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.objects)) {
      query["Objects"] = request.objects;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.template)) {
      query["Template"] = request.template;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateCustomScenePolicy",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateCustomScenePolicyResponse>(await this.callApi(params, req, runtime), new CreateCustomScenePolicyResponse({}));
  }

  /**
   * Creates an account-level custom scenario policy. You can execute a policy after you associate the policy with a website.
   * 
   * @param request - CreateCustomScenePolicyRequest
   * @returns CreateCustomScenePolicyResponse
   */
  async createCustomScenePolicy(request: CreateCustomScenePolicyRequest): Promise<CreateCustomScenePolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createCustomScenePolicyWithOptions(request, runtime);
  }

  /**
   * Creates a containerized application. You can deploy and release a version of the application across points of presence (POPs).
   * 
   * @param request - CreateEdgeContainerAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateEdgeContainerAppResponse
   */
  async createEdgeContainerAppWithOptions(request: CreateEdgeContainerAppRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeContainerAppResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.healthCheckFailTimes)) {
      body["HealthCheckFailTimes"] = request.healthCheckFailTimes;
    }

    if (!Util.isUnset(request.healthCheckHost)) {
      body["HealthCheckHost"] = request.healthCheckHost;
    }

    if (!Util.isUnset(request.healthCheckHttpCode)) {
      body["HealthCheckHttpCode"] = request.healthCheckHttpCode;
    }

    if (!Util.isUnset(request.healthCheckInterval)) {
      body["HealthCheckInterval"] = request.healthCheckInterval;
    }

    if (!Util.isUnset(request.healthCheckMethod)) {
      body["HealthCheckMethod"] = request.healthCheckMethod;
    }

    if (!Util.isUnset(request.healthCheckPort)) {
      body["HealthCheckPort"] = request.healthCheckPort;
    }

    if (!Util.isUnset(request.healthCheckSuccTimes)) {
      body["HealthCheckSuccTimes"] = request.healthCheckSuccTimes;
    }

    if (!Util.isUnset(request.healthCheckTimeout)) {
      body["HealthCheckTimeout"] = request.healthCheckTimeout;
    }

    if (!Util.isUnset(request.healthCheckType)) {
      body["HealthCheckType"] = request.healthCheckType;
    }

    if (!Util.isUnset(request.healthCheckURI)) {
      body["HealthCheckURI"] = request.healthCheckURI;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.remarks)) {
      body["Remarks"] = request.remarks;
    }

    if (!Util.isUnset(request.servicePort)) {
      body["ServicePort"] = request.servicePort;
    }

    if (!Util.isUnset(request.targetPort)) {
      body["TargetPort"] = request.targetPort;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateEdgeContainerApp",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEdgeContainerAppResponse>(await this.callApi(params, req, runtime), new CreateEdgeContainerAppResponse({}));
  }

  /**
   * Creates a containerized application. You can deploy and release a version of the application across points of presence (POPs).
   * 
   * @param request - CreateEdgeContainerAppRequest
   * @returns CreateEdgeContainerAppResponse
   */
  async createEdgeContainerApp(request: CreateEdgeContainerAppRequest): Promise<CreateEdgeContainerAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeContainerAppWithOptions(request, runtime);
  }

  /**
   * Associates a domain name with a containerized application. This way, requests destined for the associated domain name are forwarded to the application.
   * 
   * @param request - CreateEdgeContainerAppRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateEdgeContainerAppRecordResponse
   */
  async createEdgeContainerAppRecordWithOptions(request: CreateEdgeContainerAppRecordRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeContainerAppRecordResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.recordName)) {
      body["RecordName"] = request.recordName;
    }

    if (!Util.isUnset(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateEdgeContainerAppRecord",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEdgeContainerAppRecordResponse>(await this.callApi(params, req, runtime), new CreateEdgeContainerAppRecordResponse({}));
  }

  /**
   * Associates a domain name with a containerized application. This way, requests destined for the associated domain name are forwarded to the application.
   * 
   * @param request - CreateEdgeContainerAppRecordRequest
   * @returns CreateEdgeContainerAppRecordResponse
   */
  async createEdgeContainerAppRecord(request: CreateEdgeContainerAppRecordRequest): Promise<CreateEdgeContainerAppRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeContainerAppRecordWithOptions(request, runtime);
  }

  /**
   * Creates a version for a containerized application. You can iterate the application based on the version.
   * 
   * @param tmpReq - CreateEdgeContainerAppVersionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateEdgeContainerAppVersionResponse
   */
  async createEdgeContainerAppVersionWithOptions(tmpReq: CreateEdgeContainerAppVersionRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeContainerAppVersionResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateEdgeContainerAppVersionShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.containers)) {
      request.containersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.containers, "Containers", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.containersShrink)) {
      body["Containers"] = request.containersShrink;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.remarks)) {
      body["Remarks"] = request.remarks;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateEdgeContainerAppVersion",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEdgeContainerAppVersionResponse>(await this.callApi(params, req, runtime), new CreateEdgeContainerAppVersionResponse({}));
  }

  /**
   * Creates a version for a containerized application. You can iterate the application based on the version.
   * 
   * @param request - CreateEdgeContainerAppVersionRequest
   * @returns CreateEdgeContainerAppVersionResponse
   */
  async createEdgeContainerAppVersion(request: CreateEdgeContainerAppVersionRequest): Promise<CreateEdgeContainerAppVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeContainerAppVersionWithOptions(request, runtime);
  }

  /**
   * Create a namespace in your Alibaba Cloud account.
   * 
   * @param request - CreateKvNamespaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateKvNamespaceResponse
   */
  async createKvNamespaceWithOptions(request: CreateKvNamespaceRequest, runtime: $Util.RuntimeOptions): Promise<CreateKvNamespaceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.namespace)) {
      body["Namespace"] = request.namespace;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateKvNamespace",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateKvNamespaceResponse>(await this.callApi(params, req, runtime), new CreateKvNamespaceResponse({}));
  }

  /**
   * Create a namespace in your Alibaba Cloud account.
   * 
   * @param request - CreateKvNamespaceRequest
   * @returns CreateKvNamespaceResponse
   */
  async createKvNamespace(request: CreateKvNamespaceRequest): Promise<CreateKvNamespaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createKvNamespaceWithOptions(request, runtime);
  }

  /**
   * Creates a list. Lists are used for the referencing of values in the rules engine to implement complex logic and control in security policies.
   * 
   * @param tmpReq - CreateListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateListResponse
   */
  async createListWithOptions(tmpReq: CreateListRequest, runtime: $Util.RuntimeOptions): Promise<CreateListResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateListShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.items)) {
      request.itemsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.items, "Items", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.itemsShrink)) {
      body["Items"] = request.itemsShrink;
    }

    if (!Util.isUnset(request.kind)) {
      body["Kind"] = request.kind;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateList",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateListResponse>(await this.callApi(params, req, runtime), new CreateListResponse({}));
  }

  /**
   * Creates a list. Lists are used for the referencing of values in the rules engine to implement complex logic and control in security policies.
   * 
   * @param request - CreateListRequest
   * @returns CreateListResponse
   */
  async createList(request: CreateListRequest): Promise<CreateListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createListWithOptions(request, runtime);
  }

  /**
   * 开启源站防护
   * 
   * @param request - CreateOriginProtectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateOriginProtectionResponse
   */
  async createOriginProtectionWithOptions(request: CreateOriginProtectionRequest, runtime: $Util.RuntimeOptions): Promise<CreateOriginProtectionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateOriginProtection",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOriginProtectionResponse>(await this.callApi(params, req, runtime), new CreateOriginProtectionResponse({}));
  }

  /**
   * 开启源站防护
   * 
   * @param request - CreateOriginProtectionRequest
   * @returns CreateOriginProtectionResponse
   */
  async createOriginProtection(request: CreateOriginProtectionRequest): Promise<CreateOriginProtectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOriginProtectionWithOptions(request, runtime);
  }

  /**
   * Creates a custom error page, which is displayed when a request is blocked by Web Application Firewall (WAF). You can configure the HTML content, page type, and description, and submit the Base64-encoded page content.
   * 
   * @param request - CreatePageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreatePageResponse
   */
  async createPageWithOptions(request: CreatePageRequest, runtime: $Util.RuntimeOptions): Promise<CreatePageResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.content)) {
      body["Content"] = request.content;
    }

    if (!Util.isUnset(request.contentType)) {
      body["ContentType"] = request.contentType;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreatePage",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreatePageResponse>(await this.callApi(params, req, runtime), new CreatePageResponse({}));
  }

  /**
   * Creates a custom error page, which is displayed when a request is blocked by Web Application Firewall (WAF). You can configure the HTML content, page type, and description, and submit the Base64-encoded page content.
   * 
   * @param request - CreatePageRequest
   * @returns CreatePageResponse
   */
  async createPage(request: CreatePageRequest): Promise<CreatePageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createPageWithOptions(request, runtime);
  }

  /**
   * Creates a DNS record for a specific website.
   * 
   * @param tmpReq - CreateRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRecordResponse
   */
  async createRecordWithOptions(tmpReq: CreateRecordRequest, runtime: $Util.RuntimeOptions): Promise<CreateRecordResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateRecordShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.authConf)) {
      request.authConfShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.authConf, "AuthConf", "json");
    }

    if (!Util.isUnset(tmpReq.data)) {
      request.dataShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.data, "Data", "json");
    }

    let query = { };
    if (!Util.isUnset(request.authConfShrink)) {
      query["AuthConf"] = request.authConfShrink;
    }

    if (!Util.isUnset(request.bizName)) {
      query["BizName"] = request.bizName;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.dataShrink)) {
      query["Data"] = request.dataShrink;
    }

    if (!Util.isUnset(request.hostPolicy)) {
      query["HostPolicy"] = request.hostPolicy;
    }

    if (!Util.isUnset(request.proxied)) {
      query["Proxied"] = request.proxied;
    }

    if (!Util.isUnset(request.recordName)) {
      query["RecordName"] = request.recordName;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.sourceType)) {
      query["SourceType"] = request.sourceType;
    }

    if (!Util.isUnset(request.ttl)) {
      query["Ttl"] = request.ttl;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateRecord",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateRecordResponse>(await this.callApi(params, req, runtime), new CreateRecordResponse({}));
  }

  /**
   * Creates a DNS record for a specific website.
   * 
   * @param request - CreateRecordRequest
   * @returns CreateRecordResponse
   */
  async createRecord(request: CreateRecordRequest): Promise<CreateRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createRecordWithOptions(request, runtime);
  }

  /**
   * Creates a routine.
   * 
   * @param request - CreateRoutineRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRoutineResponse
   */
  async createRoutineWithOptions(request: CreateRoutineRequest, runtime: $Util.RuntimeOptions): Promise<CreateRoutineResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.specName)) {
      body["SpecName"] = request.specName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateRoutine",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateRoutineResponse>(await this.callApi(params, req, runtime), new CreateRoutineResponse({}));
  }

  /**
   * Creates a routine.
   * 
   * @param request - CreateRoutineRequest
   * @returns CreateRoutineResponse
   */
  async createRoutine(request: CreateRoutineRequest): Promise<CreateRoutineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createRoutineWithOptions(request, runtime);
  }

  /**
   * Adds a record to map a domain that is associated with a routine. This record is used to trigger the associated routine code.
   * 
   * @param request - CreateRoutineRelatedRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRoutineRelatedRecordResponse
   */
  async createRoutineRelatedRecordWithOptions(request: CreateRoutineRelatedRecordRequest, runtime: $Util.RuntimeOptions): Promise<CreateRoutineRelatedRecordResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.recordName)) {
      body["RecordName"] = request.recordName;
    }

    if (!Util.isUnset(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateRoutineRelatedRecord",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateRoutineRelatedRecordResponse>(await this.callApi(params, req, runtime), new CreateRoutineRelatedRecordResponse({}));
  }

  /**
   * Adds a record to map a domain that is associated with a routine. This record is used to trigger the associated routine code.
   * 
   * @param request - CreateRoutineRelatedRecordRequest
   * @returns CreateRoutineRelatedRecordResponse
   */
  async createRoutineRelatedRecord(request: CreateRoutineRelatedRecordRequest): Promise<CreateRoutineRelatedRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createRoutineRelatedRecordWithOptions(request, runtime);
  }

  /**
   * Adds a route to map a URL to a routine so that the routine can be triggered to respond to requests destined for the URL.
   * 
   * @param request - CreateRoutineRelatedRouteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRoutineRelatedRouteResponse
   */
  async createRoutineRelatedRouteWithOptions(request: CreateRoutineRelatedRouteRequest, runtime: $Util.RuntimeOptions): Promise<CreateRoutineRelatedRouteResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.route)) {
      body["Route"] = request.route;
    }

    if (!Util.isUnset(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateRoutineRelatedRoute",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateRoutineRelatedRouteResponse>(await this.callApi(params, req, runtime), new CreateRoutineRelatedRouteResponse({}));
  }

  /**
   * Adds a route to map a URL to a routine so that the routine can be triggered to respond to requests destined for the URL.
   * 
   * @param request - CreateRoutineRelatedRouteRequest
   * @returns CreateRoutineRelatedRouteResponse
   */
  async createRoutineRelatedRoute(request: CreateRoutineRelatedRouteRequest): Promise<CreateRoutineRelatedRouteResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createRoutineRelatedRouteWithOptions(request, runtime);
  }

  /**
   * Creates scheduled prefetch plans.
   * 
   * @param tmpReq - CreateScheduledPreloadExecutionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateScheduledPreloadExecutionsResponse
   */
  async createScheduledPreloadExecutionsWithOptions(tmpReq: CreateScheduledPreloadExecutionsRequest, runtime: $Util.RuntimeOptions): Promise<CreateScheduledPreloadExecutionsResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateScheduledPreloadExecutionsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.executions)) {
      request.executionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.executions, "Executions", "json");
    }

    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.executionsShrink)) {
      body["Executions"] = request.executionsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateScheduledPreloadExecutions",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateScheduledPreloadExecutionsResponse>(await this.callApi(params, req, runtime), new CreateScheduledPreloadExecutionsResponse({}));
  }

  /**
   * Creates scheduled prefetch plans.
   * 
   * @param request - CreateScheduledPreloadExecutionsRequest
   * @returns CreateScheduledPreloadExecutionsResponse
   */
  async createScheduledPreloadExecutions(request: CreateScheduledPreloadExecutionsRequest): Promise<CreateScheduledPreloadExecutionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createScheduledPreloadExecutionsWithOptions(request, runtime);
  }

  /**
   * Adds a scheduled prefetch task.
   * 
   * @param request - CreateScheduledPreloadJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateScheduledPreloadJobResponse
   */
  async createScheduledPreloadJobWithOptions(request: CreateScheduledPreloadJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateScheduledPreloadJobResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.insertWay)) {
      body["InsertWay"] = request.insertWay;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.ossUrl)) {
      body["OssUrl"] = request.ossUrl;
    }

    if (!Util.isUnset(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.urlList)) {
      body["UrlList"] = request.urlList;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateScheduledPreloadJob",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateScheduledPreloadJobResponse>(await this.callApi(params, req, runtime), new CreateScheduledPreloadJobResponse({}));
  }

  /**
   * Adds a scheduled prefetch task.
   * 
   * @param request - CreateScheduledPreloadJobRequest
   * @returns CreateScheduledPreloadJobResponse
   */
  async createScheduledPreloadJob(request: CreateScheduledPreloadJobRequest): Promise<CreateScheduledPreloadJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createScheduledPreloadJobWithOptions(request, runtime);
  }

  /**
   * Adds a website.
   * 
   * @remarks
   *   Make sure that you have an available plan before you add a website.
   * *   Make sure that your website domain name has an ICP filing if the location you want to specify covers the Chinese mainland.
   * 
   * @param request - CreateSiteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSiteResponse
   */
  async createSiteWithOptions(request: CreateSiteRequest, runtime: $Util.RuntimeOptions): Promise<CreateSiteResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.accessType)) {
      query["AccessType"] = request.accessType;
    }

    if (!Util.isUnset(request.coverage)) {
      query["Coverage"] = request.coverage;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.siteName)) {
      query["SiteName"] = request.siteName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateSite",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSiteResponse>(await this.callApi(params, req, runtime), new CreateSiteResponse({}));
  }

  /**
   * Adds a website.
   * 
   * @remarks
   *   Make sure that you have an available plan before you add a website.
   * *   Make sure that your website domain name has an ICP filing if the location you want to specify covers the Chinese mainland.
   * 
   * @param request - CreateSiteRequest
   * @returns CreateSiteResponse
   */
  async createSite(request: CreateSiteRequest): Promise<CreateSiteResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSiteWithOptions(request, runtime);
  }

  /**
   * Adds the configuration of custom request header, response header, and cookie fields that are used to capture logs of a website.
   * 
   * @remarks
   *   **Custom field limits**: The key name of a custom field can contain only letters, digits, underscores (_), and spaces. The key name cannot contain other characters. Otherwise, errors may occur.
   * *   **Parameter passing**: Submit `SiteId`, `RequestHeaders`, `ResponseHeaders`, and `Cookies` by using `formData`. Each array element matches a custom field name.
   * *   **(Required) SiteId**: Although `SiteId` is not marked as required in the Required column, you must specify a website ID by using this parameter when you can call this API operation.
   * 
   * @param tmpReq - CreateSiteCustomLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSiteCustomLogResponse
   */
  async createSiteCustomLogWithOptions(tmpReq: CreateSiteCustomLogRequest, runtime: $Util.RuntimeOptions): Promise<CreateSiteCustomLogResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateSiteCustomLogShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.cookies)) {
      request.cookiesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.cookies, "Cookies", "json");
    }

    if (!Util.isUnset(tmpReq.requestHeaders)) {
      request.requestHeadersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.requestHeaders, "RequestHeaders", "json");
    }

    if (!Util.isUnset(tmpReq.responseHeaders)) {
      request.responseHeadersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.responseHeaders, "ResponseHeaders", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.cookiesShrink)) {
      body["Cookies"] = request.cookiesShrink;
    }

    if (!Util.isUnset(request.requestHeadersShrink)) {
      body["RequestHeaders"] = request.requestHeadersShrink;
    }

    if (!Util.isUnset(request.responseHeadersShrink)) {
      body["ResponseHeaders"] = request.responseHeadersShrink;
    }

    if (!Util.isUnset(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateSiteCustomLog",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSiteCustomLogResponse>(await this.callApi(params, req, runtime), new CreateSiteCustomLogResponse({}));
  }

  /**
   * Adds the configuration of custom request header, response header, and cookie fields that are used to capture logs of a website.
   * 
   * @remarks
   *   **Custom field limits**: The key name of a custom field can contain only letters, digits, underscores (_), and spaces. The key name cannot contain other characters. Otherwise, errors may occur.
   * *   **Parameter passing**: Submit `SiteId`, `RequestHeaders`, `ResponseHeaders`, and `Cookies` by using `formData`. Each array element matches a custom field name.
   * *   **(Required) SiteId**: Although `SiteId` is not marked as required in the Required column, you must specify a website ID by using this parameter when you can call this API operation.
   * 
   * @param request - CreateSiteCustomLogRequest
   * @returns CreateSiteCustomLogResponse
   */
  async createSiteCustomLog(request: CreateSiteCustomLogRequest): Promise<CreateSiteCustomLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSiteCustomLogWithOptions(request, runtime);
  }

  /**
   * Creates a real-time log delivery task.
   * 
   * @param tmpReq - CreateSiteDeliveryTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSiteDeliveryTaskResponse
   */
  async createSiteDeliveryTaskWithOptions(tmpReq: CreateSiteDeliveryTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreateSiteDeliveryTaskResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateSiteDeliveryTaskShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.httpDelivery)) {
      request.httpDeliveryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.httpDelivery, "HttpDelivery", "json");
    }

    if (!Util.isUnset(tmpReq.kafkaDelivery)) {
      request.kafkaDeliveryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.kafkaDelivery, "KafkaDelivery", "json");
    }

    if (!Util.isUnset(tmpReq.ossDelivery)) {
      request.ossDeliveryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ossDelivery, "OssDelivery", "json");
    }

    if (!Util.isUnset(tmpReq.s3Delivery)) {
      request.s3DeliveryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.s3Delivery, "S3Delivery", "json");
    }

    if (!Util.isUnset(tmpReq.slsDelivery)) {
      request.slsDeliveryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.slsDelivery, "SlsDelivery", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.businessType)) {
      body["BusinessType"] = request.businessType;
    }

    if (!Util.isUnset(request.dataCenter)) {
      body["DataCenter"] = request.dataCenter;
    }

    if (!Util.isUnset(request.deliveryType)) {
      body["DeliveryType"] = request.deliveryType;
    }

    if (!Util.isUnset(request.discardRate)) {
      body["DiscardRate"] = request.discardRate;
    }

    if (!Util.isUnset(request.fieldName)) {
      body["FieldName"] = request.fieldName;
    }

    if (!Util.isUnset(request.httpDeliveryShrink)) {
      body["HttpDelivery"] = request.httpDeliveryShrink;
    }

    if (!Util.isUnset(request.kafkaDeliveryShrink)) {
      body["KafkaDelivery"] = request.kafkaDeliveryShrink;
    }

    if (!Util.isUnset(request.ossDeliveryShrink)) {
      body["OssDelivery"] = request.ossDeliveryShrink;
    }

    if (!Util.isUnset(request.s3DeliveryShrink)) {
      body["S3Delivery"] = request.s3DeliveryShrink;
    }

    if (!Util.isUnset(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.slsDeliveryShrink)) {
      body["SlsDelivery"] = request.slsDeliveryShrink;
    }

    if (!Util.isUnset(request.taskName)) {
      body["TaskName"] = request.taskName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateSiteDeliveryTask",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSiteDeliveryTaskResponse>(await this.callApi(params, req, runtime), new CreateSiteDeliveryTaskResponse({}));
  }

  /**
   * Creates a real-time log delivery task.
   * 
   * @param request - CreateSiteDeliveryTaskRequest
   * @returns CreateSiteDeliveryTaskResponse
   */
  async createSiteDeliveryTask(request: CreateSiteDeliveryTaskRequest): Promise<CreateSiteDeliveryTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSiteDeliveryTaskWithOptions(request, runtime);
  }

  /**
   * 新增站点功能配置
   * 
   * @param tmpReq - CreateSiteFunctionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSiteFunctionResponse
   */
  async createSiteFunctionWithOptions(tmpReq: CreateSiteFunctionRequest, runtime: $Util.RuntimeOptions): Promise<CreateSiteFunctionResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateSiteFunctionShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.cacheReserve)) {
      request.cacheReserveShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.cacheReserve, "CacheReserve", "json");
    }

    if (!Util.isUnset(tmpReq.cacheRules)) {
      request.cacheRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.cacheRules, "CacheRules", "json");
    }

    if (!Util.isUnset(tmpReq.cacheTags)) {
      request.cacheTagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.cacheTags, "CacheTags", "json");
    }

    if (!Util.isUnset(tmpReq.cnameFlattening)) {
      request.cnameFlatteningShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.cnameFlattening, "CnameFlattening", "json");
    }

    if (!Util.isUnset(tmpReq.compressionRules)) {
      request.compressionRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.compressionRules, "CompressionRules", "json");
    }

    if (!Util.isUnset(tmpReq.crossBorderOptimization)) {
      request.crossBorderOptimizationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.crossBorderOptimization, "CrossBorderOptimization", "json");
    }

    if (!Util.isUnset(tmpReq.developmentMode)) {
      request.developmentModeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.developmentMode, "DevelopmentMode", "json");
    }

    if (!Util.isUnset(tmpReq.httpRequestHeaderModificationRules)) {
      request.httpRequestHeaderModificationRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.httpRequestHeaderModificationRules, "HttpRequestHeaderModificationRules", "json");
    }

    if (!Util.isUnset(tmpReq.httpResponseHeaderModificationRules)) {
      request.httpResponseHeaderModificationRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.httpResponseHeaderModificationRules, "HttpResponseHeaderModificationRules", "json");
    }

    if (!Util.isUnset(tmpReq.httpsApplicationConfiguration)) {
      request.httpsApplicationConfigurationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.httpsApplicationConfiguration, "HttpsApplicationConfiguration", "json");
    }

    if (!Util.isUnset(tmpReq.httpsBasicConfiguration)) {
      request.httpsBasicConfigurationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.httpsBasicConfiguration, "HttpsBasicConfiguration", "json");
    }

    if (!Util.isUnset(tmpReq.imageTransform)) {
      request.imageTransformShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.imageTransform, "ImageTransform", "json");
    }

    if (!Util.isUnset(tmpReq.ipv6)) {
      request.ipv6Shrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ipv6, "Ipv6", "json");
    }

    if (!Util.isUnset(tmpReq.managedTransforms)) {
      request.managedTransformsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.managedTransforms, "ManagedTransforms", "json");
    }

    if (!Util.isUnset(tmpReq.networkOptimization)) {
      request.networkOptimizationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.networkOptimization, "NetworkOptimization", "json");
    }

    if (!Util.isUnset(tmpReq.originProtection)) {
      request.originProtectionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.originProtection, "OriginProtection", "json");
    }

    if (!Util.isUnset(tmpReq.originRules)) {
      request.originRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.originRules, "OriginRules", "json");
    }

    if (!Util.isUnset(tmpReq.redirectRules)) {
      request.redirectRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.redirectRules, "RedirectRules", "json");
    }

    if (!Util.isUnset(tmpReq.rewriteUrlRules)) {
      request.rewriteUrlRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.rewriteUrlRules, "RewriteUrlRules", "json");
    }

    if (!Util.isUnset(tmpReq.seoBypass)) {
      request.seoBypassShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.seoBypass, "SeoBypass", "json");
    }

    if (!Util.isUnset(tmpReq.siteNameExclusive)) {
      request.siteNameExclusiveShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.siteNameExclusive, "SiteNameExclusive", "json");
    }

    if (!Util.isUnset(tmpReq.sitePause)) {
      request.sitePauseShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sitePause, "SitePause", "json");
    }

    if (!Util.isUnset(tmpReq.tieredCache)) {
      request.tieredCacheShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tieredCache, "TieredCache", "json");
    }

    let query = { };
    if (!Util.isUnset(request.cacheReserveShrink)) {
      query["CacheReserve"] = request.cacheReserveShrink;
    }

    if (!Util.isUnset(request.cacheRulesShrink)) {
      query["CacheRules"] = request.cacheRulesShrink;
    }

    if (!Util.isUnset(request.cacheTagsShrink)) {
      query["CacheTags"] = request.cacheTagsShrink;
    }

    if (!Util.isUnset(request.cnameFlatteningShrink)) {
      query["CnameFlattening"] = request.cnameFlatteningShrink;
    }

    if (!Util.isUnset(request.compressionRulesShrink)) {
      query["CompressionRules"] = request.compressionRulesShrink;
    }

    if (!Util.isUnset(request.crossBorderOptimizationShrink)) {
      query["CrossBorderOptimization"] = request.crossBorderOptimizationShrink;
    }

    if (!Util.isUnset(request.developmentModeShrink)) {
      query["DevelopmentMode"] = request.developmentModeShrink;
    }

    if (!Util.isUnset(request.httpRequestHeaderModificationRulesShrink)) {
      query["HttpRequestHeaderModificationRules"] = request.httpRequestHeaderModificationRulesShrink;
    }

    if (!Util.isUnset(request.httpResponseHeaderModificationRulesShrink)) {
      query["HttpResponseHeaderModificationRules"] = request.httpResponseHeaderModificationRulesShrink;
    }

    if (!Util.isUnset(request.httpsApplicationConfigurationShrink)) {
      query["HttpsApplicationConfiguration"] = request.httpsApplicationConfigurationShrink;
    }

    if (!Util.isUnset(request.httpsBasicConfigurationShrink)) {
      query["HttpsBasicConfiguration"] = request.httpsBasicConfigurationShrink;
    }

    if (!Util.isUnset(request.imageTransformShrink)) {
      query["ImageTransform"] = request.imageTransformShrink;
    }

    if (!Util.isUnset(request.ipv6Shrink)) {
      query["Ipv6"] = request.ipv6Shrink;
    }

    if (!Util.isUnset(request.managedTransformsShrink)) {
      query["ManagedTransforms"] = request.managedTransformsShrink;
    }

    if (!Util.isUnset(request.networkOptimizationShrink)) {
      query["NetworkOptimization"] = request.networkOptimizationShrink;
    }

    if (!Util.isUnset(request.originProtectionShrink)) {
      query["OriginProtection"] = request.originProtectionShrink;
    }

    if (!Util.isUnset(request.originRulesShrink)) {
      query["OriginRules"] = request.originRulesShrink;
    }

    if (!Util.isUnset(request.redirectRulesShrink)) {
      query["RedirectRules"] = request.redirectRulesShrink;
    }

    if (!Util.isUnset(request.rewriteUrlRulesShrink)) {
      query["RewriteUrlRules"] = request.rewriteUrlRulesShrink;
    }

    if (!Util.isUnset(request.seoBypassShrink)) {
      query["SeoBypass"] = request.seoBypassShrink;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.siteNameExclusiveShrink)) {
      query["SiteNameExclusive"] = request.siteNameExclusiveShrink;
    }

    if (!Util.isUnset(request.sitePauseShrink)) {
      query["SitePause"] = request.sitePauseShrink;
    }

    if (!Util.isUnset(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    if (!Util.isUnset(request.tieredCacheShrink)) {
      query["TieredCache"] = request.tieredCacheShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateSiteFunction",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSiteFunctionResponse>(await this.callApi(params, req, runtime), new CreateSiteFunctionResponse({}));
  }

  /**
   * 新增站点功能配置
   * 
   * @param request - CreateSiteFunctionRequest
   * @returns CreateSiteFunctionResponse
   */
  async createSiteFunction(request: CreateSiteFunctionRequest): Promise<CreateSiteFunctionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSiteFunctionWithOptions(request, runtime);
  }

  /**
   * Creates a log delivery task to ship logs to the specified destination.
   * 
   * @remarks
   * This API operation allows you to deliver logs to destinations such as Simple Log Service (SLS), HTTP servers, Object Storage Service (OSS), Amazon Simple Storage Service (S3), and Kafka. You can specify the task name, log fields to deliver, data center, discard rate, delivery type, and delivery details.
   * *   **Field filtering**: Use the `FieldName` parameter to specify log fields to deliver.
   * *   **Filtering rules**: Use the `FilterRules` parameter to pre-process and filter log data.
   * *   **Diverse delivery destinations**: Logs can be delivered to different destinations. Configuration parameters vary with delivery destinations.
   * ## [](#)Precautions
   * *   Make sure that you have sufficient permissions to perform delivery tasks.
   * *   If you enable encryption or authentication, properly configure corresponding parameters.
   * *   Verify the syntax of `FilterRules` to make sure that filtering logic works as expected.
   * *   Specify advanced settings such as the number of retries and timeout period based on your needs to have optimal delivery efficiency and stability.
   * 
   * @param tmpReq - CreateUserDeliveryTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateUserDeliveryTaskResponse
   */
  async createUserDeliveryTaskWithOptions(tmpReq: CreateUserDeliveryTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreateUserDeliveryTaskResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateUserDeliveryTaskShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.httpDelivery)) {
      request.httpDeliveryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.httpDelivery, "HttpDelivery", "json");
    }

    if (!Util.isUnset(tmpReq.kafkaDelivery)) {
      request.kafkaDeliveryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.kafkaDelivery, "KafkaDelivery", "json");
    }

    if (!Util.isUnset(tmpReq.ossDelivery)) {
      request.ossDeliveryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ossDelivery, "OssDelivery", "json");
    }

    if (!Util.isUnset(tmpReq.s3Delivery)) {
      request.s3DeliveryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.s3Delivery, "S3Delivery", "json");
    }

    if (!Util.isUnset(tmpReq.slsDelivery)) {
      request.slsDeliveryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.slsDelivery, "SlsDelivery", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.businessType)) {
      body["BusinessType"] = request.businessType;
    }

    if (!Util.isUnset(request.dataCenter)) {
      body["DataCenter"] = request.dataCenter;
    }

    if (!Util.isUnset(request.deliveryType)) {
      body["DeliveryType"] = request.deliveryType;
    }

    if (!Util.isUnset(request.discardRate)) {
      body["DiscardRate"] = request.discardRate;
    }

    if (!Util.isUnset(request.fieldName)) {
      body["FieldName"] = request.fieldName;
    }

    if (!Util.isUnset(request.httpDeliveryShrink)) {
      body["HttpDelivery"] = request.httpDeliveryShrink;
    }

    if (!Util.isUnset(request.kafkaDeliveryShrink)) {
      body["KafkaDelivery"] = request.kafkaDeliveryShrink;
    }

    if (!Util.isUnset(request.ossDeliveryShrink)) {
      body["OssDelivery"] = request.ossDeliveryShrink;
    }

    if (!Util.isUnset(request.s3DeliveryShrink)) {
      body["S3Delivery"] = request.s3DeliveryShrink;
    }

    if (!Util.isUnset(request.slsDeliveryShrink)) {
      body["SlsDelivery"] = request.slsDeliveryShrink;
    }

    if (!Util.isUnset(request.taskName)) {
      body["TaskName"] = request.taskName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateUserDeliveryTask",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateUserDeliveryTaskResponse>(await this.callApi(params, req, runtime), new CreateUserDeliveryTaskResponse({}));
  }

  /**
   * Creates a log delivery task to ship logs to the specified destination.
   * 
   * @remarks
   * This API operation allows you to deliver logs to destinations such as Simple Log Service (SLS), HTTP servers, Object Storage Service (OSS), Amazon Simple Storage Service (S3), and Kafka. You can specify the task name, log fields to deliver, data center, discard rate, delivery type, and delivery details.
   * *   **Field filtering**: Use the `FieldName` parameter to specify log fields to deliver.
   * *   **Filtering rules**: Use the `FilterRules` parameter to pre-process and filter log data.
   * *   **Diverse delivery destinations**: Logs can be delivered to different destinations. Configuration parameters vary with delivery destinations.
   * ## [](#)Precautions
   * *   Make sure that you have sufficient permissions to perform delivery tasks.
   * *   If you enable encryption or authentication, properly configure corresponding parameters.
   * *   Verify the syntax of `FilterRules` to make sure that filtering logic works as expected.
   * *   Specify advanced settings such as the number of retries and timeout period based on your needs to have optimal delivery efficiency and stability.
   * 
   * @param request - CreateUserDeliveryTaskRequest
   * @returns CreateUserDeliveryTaskResponse
   */
  async createUserDeliveryTask(request: CreateUserDeliveryTaskRequest): Promise<CreateUserDeliveryTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createUserDeliveryTaskWithOptions(request, runtime);
  }

  /**
   * Creates a Web Application Firewall (WAF) rule. This allows you to configure fine-grained WAF settings to improve the security of your website or application.
   * 
   * @param tmpReq - CreateWafRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateWafRuleResponse
   */
  async createWafRuleWithOptions(tmpReq: CreateWafRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateWafRuleResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateWafRuleShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.config)) {
      request.configShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.config, "Config", "json");
    }

    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.configShrink)) {
      body["Config"] = request.configShrink;
    }

    if (!Util.isUnset(request.phase)) {
      body["Phase"] = request.phase;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateWafRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateWafRuleResponse>(await this.callApi(params, req, runtime), new CreateWafRuleResponse({}));
  }

  /**
   * Creates a Web Application Firewall (WAF) rule. This allows you to configure fine-grained WAF settings to improve the security of your website or application.
   * 
   * @param request - CreateWafRuleRequest
   * @returns CreateWafRuleResponse
   */
  async createWafRule(request: CreateWafRuleRequest): Promise<CreateWafRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createWafRuleWithOptions(request, runtime);
  }

  /**
   * Creates a waiting room for a website.
   * 
   * @param tmpReq - CreateWaitingRoomRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateWaitingRoomResponse
   */
  async createWaitingRoomWithOptions(tmpReq: CreateWaitingRoomRequest, runtime: $Util.RuntimeOptions): Promise<CreateWaitingRoomResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateWaitingRoomShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.hostNameAndPath)) {
      request.hostNameAndPathShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.hostNameAndPath, "HostNameAndPath", "json");
    }

    let query = { };
    if (!Util.isUnset(request.cookieName)) {
      query["CookieName"] = request.cookieName;
    }

    if (!Util.isUnset(request.customPageHtml)) {
      query["CustomPageHtml"] = request.customPageHtml;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.disableSessionRenewalEnable)) {
      query["DisableSessionRenewalEnable"] = request.disableSessionRenewalEnable;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.hostNameAndPathShrink)) {
      query["HostNameAndPath"] = request.hostNameAndPathShrink;
    }

    if (!Util.isUnset(request.jsonResponseEnable)) {
      query["JsonResponseEnable"] = request.jsonResponseEnable;
    }

    if (!Util.isUnset(request.language)) {
      query["Language"] = request.language;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.newUsersPerMinute)) {
      query["NewUsersPerMinute"] = request.newUsersPerMinute;
    }

    if (!Util.isUnset(request.queueAllEnable)) {
      query["QueueAllEnable"] = request.queueAllEnable;
    }

    if (!Util.isUnset(request.queuingMethod)) {
      query["QueuingMethod"] = request.queuingMethod;
    }

    if (!Util.isUnset(request.queuingStatusCode)) {
      query["QueuingStatusCode"] = request.queuingStatusCode;
    }

    if (!Util.isUnset(request.sessionDuration)) {
      query["SessionDuration"] = request.sessionDuration;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.totalActiveUsers)) {
      query["TotalActiveUsers"] = request.totalActiveUsers;
    }

    if (!Util.isUnset(request.waitingRoomType)) {
      query["WaitingRoomType"] = request.waitingRoomType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateWaitingRoom",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateWaitingRoomResponse>(await this.callApi(params, req, runtime), new CreateWaitingRoomResponse({}));
  }

  /**
   * Creates a waiting room for a website.
   * 
   * @param request - CreateWaitingRoomRequest
   * @returns CreateWaitingRoomResponse
   */
  async createWaitingRoom(request: CreateWaitingRoomRequest): Promise<CreateWaitingRoomResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createWaitingRoomWithOptions(request, runtime);
  }

  /**
   * Creates a waiting room event.
   * 
   * @param request - CreateWaitingRoomEventRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateWaitingRoomEventResponse
   */
  async createWaitingRoomEventWithOptions(request: CreateWaitingRoomEventRequest, runtime: $Util.RuntimeOptions): Promise<CreateWaitingRoomEventResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.customPageHtml)) {
      query["CustomPageHtml"] = request.customPageHtml;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.disableSessionRenewalEnable)) {
      query["DisableSessionRenewalEnable"] = request.disableSessionRenewalEnable;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.jsonResponseEnable)) {
      query["JsonResponseEnable"] = request.jsonResponseEnable;
    }

    if (!Util.isUnset(request.language)) {
      query["Language"] = request.language;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.newUsersPerMinute)) {
      query["NewUsersPerMinute"] = request.newUsersPerMinute;
    }

    if (!Util.isUnset(request.preQueueEnable)) {
      query["PreQueueEnable"] = request.preQueueEnable;
    }

    if (!Util.isUnset(request.preQueueStartTime)) {
      query["PreQueueStartTime"] = request.preQueueStartTime;
    }

    if (!Util.isUnset(request.queuingMethod)) {
      query["QueuingMethod"] = request.queuingMethod;
    }

    if (!Util.isUnset(request.queuingStatusCode)) {
      query["QueuingStatusCode"] = request.queuingStatusCode;
    }

    if (!Util.isUnset(request.randomPreQueueEnable)) {
      query["RandomPreQueueEnable"] = request.randomPreQueueEnable;
    }

    if (!Util.isUnset(request.sessionDuration)) {
      query["SessionDuration"] = request.sessionDuration;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.totalActiveUsers)) {
      query["TotalActiveUsers"] = request.totalActiveUsers;
    }

    if (!Util.isUnset(request.waitingRoomId)) {
      query["WaitingRoomId"] = request.waitingRoomId;
    }

    if (!Util.isUnset(request.waitingRoomType)) {
      query["WaitingRoomType"] = request.waitingRoomType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateWaitingRoomEvent",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateWaitingRoomEventResponse>(await this.callApi(params, req, runtime), new CreateWaitingRoomEventResponse({}));
  }

  /**
   * Creates a waiting room event.
   * 
   * @param request - CreateWaitingRoomEventRequest
   * @returns CreateWaitingRoomEventResponse
   */
  async createWaitingRoomEvent(request: CreateWaitingRoomEventRequest): Promise<CreateWaitingRoomEventResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createWaitingRoomEventWithOptions(request, runtime);
  }

  /**
   * Creates a waiting room bypass rule.
   * 
   * @param request - CreateWaitingRoomRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateWaitingRoomRuleResponse
   */
  async createWaitingRoomRuleWithOptions(request: CreateWaitingRoomRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateWaitingRoomRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!Util.isUnset(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.waitingRoomId)) {
      query["WaitingRoomId"] = request.waitingRoomId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateWaitingRoomRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateWaitingRoomRuleResponse>(await this.callApi(params, req, runtime), new CreateWaitingRoomRuleResponse({}));
  }

  /**
   * Creates a waiting room bypass rule.
   * 
   * @param request - CreateWaitingRoomRuleRequest
   * @returns CreateWaitingRoomRuleResponse
   */
  async createWaitingRoomRule(request: CreateWaitingRoomRuleRequest): Promise<CreateWaitingRoomRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createWaitingRoomRuleWithOptions(request, runtime);
  }

  /**
   * Deletes a scenario-specific custom policy.
   * 
   * @param request - DeleteCustomScenePolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteCustomScenePolicyResponse
   */
  async deleteCustomScenePolicyWithOptions(request: DeleteCustomScenePolicyRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCustomScenePolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCustomScenePolicy",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteCustomScenePolicyResponse>(await this.callApi(params, req, runtime), new DeleteCustomScenePolicyResponse({}));
  }

  /**
   * Deletes a scenario-specific custom policy.
   * 
   * @param request - DeleteCustomScenePolicyRequest
   * @returns DeleteCustomScenePolicyResponse
   */
  async deleteCustomScenePolicy(request: DeleteCustomScenePolicyRequest): Promise<DeleteCustomScenePolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCustomScenePolicyWithOptions(request, runtime);
  }

  /**
   * Deletes a containerized application.
   * 
   * @param request - DeleteEdgeContainerAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteEdgeContainerAppResponse
   */
  async deleteEdgeContainerAppWithOptions(request: DeleteEdgeContainerAppRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEdgeContainerAppResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEdgeContainerApp",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteEdgeContainerAppResponse>(await this.callApi(params, req, runtime), new DeleteEdgeContainerAppResponse({}));
  }

  /**
   * Deletes a containerized application.
   * 
   * @param request - DeleteEdgeContainerAppRequest
   * @returns DeleteEdgeContainerAppResponse
   */
  async deleteEdgeContainerApp(request: DeleteEdgeContainerAppRequest): Promise<DeleteEdgeContainerAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEdgeContainerAppWithOptions(request, runtime);
  }

  /**
   * Disassociates a domain name from a containerized application. After the dissociation, you can no longer use the domain name to access the containerized application.
   * 
   * @param request - DeleteEdgeContainerAppRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteEdgeContainerAppRecordResponse
   */
  async deleteEdgeContainerAppRecordWithOptions(request: DeleteEdgeContainerAppRecordRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEdgeContainerAppRecordResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.recordName)) {
      body["RecordName"] = request.recordName;
    }

    if (!Util.isUnset(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEdgeContainerAppRecord",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteEdgeContainerAppRecordResponse>(await this.callApi(params, req, runtime), new DeleteEdgeContainerAppRecordResponse({}));
  }

  /**
   * Disassociates a domain name from a containerized application. After the dissociation, you can no longer use the domain name to access the containerized application.
   * 
   * @param request - DeleteEdgeContainerAppRecordRequest
   * @returns DeleteEdgeContainerAppRecordResponse
   */
  async deleteEdgeContainerAppRecord(request: DeleteEdgeContainerAppRecordRequest): Promise<DeleteEdgeContainerAppRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEdgeContainerAppRecordWithOptions(request, runtime);
  }

  /**
   * Deletes a version of a containerized application.
   * 
   * @param request - DeleteEdgeContainerAppVersionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteEdgeContainerAppVersionResponse
   */
  async deleteEdgeContainerAppVersionWithOptions(request: DeleteEdgeContainerAppVersionRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEdgeContainerAppVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.versionId)) {
      query["VersionId"] = request.versionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEdgeContainerAppVersion",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteEdgeContainerAppVersionResponse>(await this.callApi(params, req, runtime), new DeleteEdgeContainerAppVersionResponse({}));
  }

  /**
   * Deletes a version of a containerized application.
   * 
   * @param request - DeleteEdgeContainerAppVersionRequest
   * @returns DeleteEdgeContainerAppVersionResponse
   */
  async deleteEdgeContainerAppVersion(request: DeleteEdgeContainerAppVersionRequest): Promise<DeleteEdgeContainerAppVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEdgeContainerAppVersionWithOptions(request, runtime);
  }

  /**
   * Deletes a key-value pair from a namespace.
   * 
   * @param request - DeleteKvRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteKvResponse
   */
  async deleteKvWithOptions(request: DeleteKvRequest, runtime: $Util.RuntimeOptions): Promise<DeleteKvResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteKv",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteKvResponse>(await this.callApi(params, req, runtime), new DeleteKvResponse({}));
  }

  /**
   * Deletes a key-value pair from a namespace.
   * 
   * @param request - DeleteKvRequest
   * @returns DeleteKvResponse
   */
  async deleteKv(request: DeleteKvRequest): Promise<DeleteKvResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteKvWithOptions(request, runtime);
  }

  /**
   * Deletes a namespace from an Alibaba Cloud account.
   * 
   * @param request - DeleteKvNamespaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteKvNamespaceResponse
   */
  async deleteKvNamespaceWithOptions(request: DeleteKvNamespaceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteKvNamespaceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteKvNamespace",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteKvNamespaceResponse>(await this.callApi(params, req, runtime), new DeleteKvNamespaceResponse({}));
  }

  /**
   * Deletes a namespace from an Alibaba Cloud account.
   * 
   * @param request - DeleteKvNamespaceRequest
   * @returns DeleteKvNamespaceResponse
   */
  async deleteKvNamespace(request: DeleteKvNamespaceRequest): Promise<DeleteKvNamespaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteKvNamespaceWithOptions(request, runtime);
  }

  /**
   * Deletes a custom list that is no longer needed.
   * 
   * @param request - DeleteListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteListResponse
   */
  async deleteListWithOptions(request: DeleteListRequest, runtime: $Util.RuntimeOptions): Promise<DeleteListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteList",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteListResponse>(await this.callApi(params, req, runtime), new DeleteListResponse({}));
  }

  /**
   * Deletes a custom list that is no longer needed.
   * 
   * @param request - DeleteListRequest
   * @returns DeleteListResponse
   */
  async deleteList(request: DeleteListRequest): Promise<DeleteListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteListWithOptions(request, runtime);
  }

  /**
   * 关闭源站防护功能
   * 
   * @param request - DeleteOriginProtectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteOriginProtectionResponse
   */
  async deleteOriginProtectionWithOptions(request: DeleteOriginProtectionRequest, runtime: $Util.RuntimeOptions): Promise<DeleteOriginProtectionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteOriginProtection",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteOriginProtectionResponse>(await this.callApi(params, req, runtime), new DeleteOriginProtectionResponse({}));
  }

  /**
   * 关闭源站防护功能
   * 
   * @param request - DeleteOriginProtectionRequest
   * @returns DeleteOriginProtectionResponse
   */
  async deleteOriginProtection(request: DeleteOriginProtectionRequest): Promise<DeleteOriginProtectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteOriginProtectionWithOptions(request, runtime);
  }

  /**
   * Deletes a custom error page that is no longer needed.
   * 
   * @param request - DeletePageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeletePageResponse
   */
  async deletePageWithOptions(request: DeletePageRequest, runtime: $Util.RuntimeOptions): Promise<DeletePageResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeletePage",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeletePageResponse>(await this.callApi(params, req, runtime), new DeletePageResponse({}));
  }

  /**
   * Deletes a custom error page that is no longer needed.
   * 
   * @param request - DeletePageRequest
   * @returns DeletePageResponse
   */
  async deletePage(request: DeletePageRequest): Promise<DeletePageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deletePageWithOptions(request, runtime);
  }

  /**
   * Deletes a DNS record of a website based on the specified RecordId.
   * 
   * @param request - DeleteRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRecordResponse
   */
  async deleteRecordWithOptions(request: DeleteRecordRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRecordResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.recordId)) {
      query["RecordId"] = request.recordId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRecord",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteRecordResponse>(await this.callApi(params, req, runtime), new DeleteRecordResponse({}));
  }

  /**
   * Deletes a DNS record of a website based on the specified RecordId.
   * 
   * @param request - DeleteRecordRequest
   * @returns DeleteRecordResponse
   */
  async deleteRecord(request: DeleteRecordRequest): Promise<DeleteRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRecordWithOptions(request, runtime);
  }

  /**
   * Deletes a routine in Edge Routine.
   * 
   * @param request - DeleteRoutineRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRoutineResponse
   */
  async deleteRoutineWithOptions(request: DeleteRoutineRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRoutineResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRoutine",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteRoutineResponse>(await this.callApi(params, req, runtime), new DeleteRoutineResponse({}));
  }

  /**
   * Deletes a routine in Edge Routine.
   * 
   * @param request - DeleteRoutineRequest
   * @returns DeleteRoutineResponse
   */
  async deleteRoutine(request: DeleteRoutineRequest): Promise<DeleteRoutineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRoutineWithOptions(request, runtime);
  }

  /**
   * Deletes a code version of a routine.
   * 
   * @param request - DeleteRoutineCodeVersionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRoutineCodeVersionResponse
   */
  async deleteRoutineCodeVersionWithOptions(request: DeleteRoutineCodeVersionRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRoutineCodeVersionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.codeVersion)) {
      body["CodeVersion"] = request.codeVersion;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRoutineCodeVersion",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteRoutineCodeVersionResponse>(await this.callApi(params, req, runtime), new DeleteRoutineCodeVersionResponse({}));
  }

  /**
   * Deletes a code version of a routine.
   * 
   * @param request - DeleteRoutineCodeVersionRequest
   * @returns DeleteRoutineCodeVersionResponse
   */
  async deleteRoutineCodeVersion(request: DeleteRoutineCodeVersionRequest): Promise<DeleteRoutineCodeVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRoutineCodeVersionWithOptions(request, runtime);
  }

  /**
   * Deletes a record that is associated with a routine.
   * 
   * @param request - DeleteRoutineRelatedRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRoutineRelatedRecordResponse
   */
  async deleteRoutineRelatedRecordWithOptions(request: DeleteRoutineRelatedRecordRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRoutineRelatedRecordResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.recordId)) {
      body["RecordId"] = request.recordId;
    }

    if (!Util.isUnset(request.recordName)) {
      body["RecordName"] = request.recordName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRoutineRelatedRecord",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteRoutineRelatedRecordResponse>(await this.callApi(params, req, runtime), new DeleteRoutineRelatedRecordResponse({}));
  }

  /**
   * Deletes a record that is associated with a routine.
   * 
   * @param request - DeleteRoutineRelatedRecordRequest
   * @returns DeleteRoutineRelatedRecordResponse
   */
  async deleteRoutineRelatedRecord(request: DeleteRoutineRelatedRecordRequest): Promise<DeleteRoutineRelatedRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRoutineRelatedRecordWithOptions(request, runtime);
  }

  /**
   * Deletes a route that is associated with a routine.
   * 
   * @param request - DeleteRoutineRelatedRouteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRoutineRelatedRouteResponse
   */
  async deleteRoutineRelatedRouteWithOptions(request: DeleteRoutineRelatedRouteRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRoutineRelatedRouteResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.route)) {
      body["Route"] = request.route;
    }

    if (!Util.isUnset(request.routeId)) {
      body["RouteId"] = request.routeId;
    }

    if (!Util.isUnset(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRoutineRelatedRoute",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteRoutineRelatedRouteResponse>(await this.callApi(params, req, runtime), new DeleteRoutineRelatedRouteResponse({}));
  }

  /**
   * Deletes a route that is associated with a routine.
   * 
   * @param request - DeleteRoutineRelatedRouteRequest
   * @returns DeleteRoutineRelatedRouteResponse
   */
  async deleteRoutineRelatedRoute(request: DeleteRoutineRelatedRouteRequest): Promise<DeleteRoutineRelatedRouteResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRoutineRelatedRouteWithOptions(request, runtime);
  }

  /**
   * Deletes a scheduled prefetch plan based on the plan ID.
   * 
   * @param request - DeleteScheduledPreloadExecutionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteScheduledPreloadExecutionResponse
   */
  async deleteScheduledPreloadExecutionWithOptions(request: DeleteScheduledPreloadExecutionRequest, runtime: $Util.RuntimeOptions): Promise<DeleteScheduledPreloadExecutionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteScheduledPreloadExecution",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteScheduledPreloadExecutionResponse>(await this.callApi(params, req, runtime), new DeleteScheduledPreloadExecutionResponse({}));
  }

  /**
   * Deletes a scheduled prefetch plan based on the plan ID.
   * 
   * @param request - DeleteScheduledPreloadExecutionRequest
   * @returns DeleteScheduledPreloadExecutionResponse
   */
  async deleteScheduledPreloadExecution(request: DeleteScheduledPreloadExecutionRequest): Promise<DeleteScheduledPreloadExecutionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteScheduledPreloadExecutionWithOptions(request, runtime);
  }

  /**
   * Deletes a specified scheduled prefetch task based on the task ID.
   * 
   * @param request - DeleteScheduledPreloadJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteScheduledPreloadJobResponse
   */
  async deleteScheduledPreloadJobWithOptions(request: DeleteScheduledPreloadJobRequest, runtime: $Util.RuntimeOptions): Promise<DeleteScheduledPreloadJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteScheduledPreloadJob",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteScheduledPreloadJobResponse>(await this.callApi(params, req, runtime), new DeleteScheduledPreloadJobResponse({}));
  }

  /**
   * Deletes a specified scheduled prefetch task based on the task ID.
   * 
   * @param request - DeleteScheduledPreloadJobRequest
   * @returns DeleteScheduledPreloadJobResponse
   */
  async deleteScheduledPreloadJob(request: DeleteScheduledPreloadJobRequest): Promise<DeleteScheduledPreloadJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteScheduledPreloadJobWithOptions(request, runtime);
  }

  /**
   * Deletes a website based on the specified website ID.
   * 
   * @param request - DeleteSiteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteSiteResponse
   */
  async deleteSiteWithOptions(request: DeleteSiteRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSiteResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSite",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSiteResponse>(await this.callApi(params, req, runtime), new DeleteSiteResponse({}));
  }

  /**
   * Deletes a website based on the specified website ID.
   * 
   * @param request - DeleteSiteRequest
   * @returns DeleteSiteResponse
   */
  async deleteSite(request: DeleteSiteRequest): Promise<DeleteSiteResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSiteWithOptions(request, runtime);
  }

  /**
   * Deletes a real-time log delivery task.
   * 
   * @param request - DeleteSiteDeliveryTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteSiteDeliveryTaskResponse
   */
  async deleteSiteDeliveryTaskWithOptions(request: DeleteSiteDeliveryTaskRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSiteDeliveryTaskResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.taskName)) {
      body["TaskName"] = request.taskName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSiteDeliveryTask",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSiteDeliveryTaskResponse>(await this.callApi(params, req, runtime), new DeleteSiteDeliveryTaskResponse({}));
  }

  /**
   * Deletes a real-time log delivery task.
   * 
   * @param request - DeleteSiteDeliveryTaskRequest
   * @returns DeleteSiteDeliveryTaskResponse
   */
  async deleteSiteDeliveryTask(request: DeleteSiteDeliveryTaskRequest): Promise<DeleteSiteDeliveryTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSiteDeliveryTaskWithOptions(request, runtime);
  }

  /**
   * 删除站点配置
   * 
   * @param request - DeleteSiteFunctionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteSiteFunctionResponse
   */
  async deleteSiteFunctionWithOptions(request: DeleteSiteFunctionRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSiteFunctionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.configIds)) {
      query["ConfigIds"] = request.configIds;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSiteFunction",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSiteFunctionResponse>(await this.callApi(params, req, runtime), new DeleteSiteFunctionResponse({}));
  }

  /**
   * 删除站点配置
   * 
   * @param request - DeleteSiteFunctionRequest
   * @returns DeleteSiteFunctionResponse
   */
  async deleteSiteFunction(request: DeleteSiteFunctionRequest): Promise<DeleteSiteFunctionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSiteFunctionWithOptions(request, runtime);
  }

  /**
   * Deletes a log delivery task from your Alibaba Cloud account.
   * 
   * @remarks
   * *****> 
   * *   Deleted tasks cannot be restored. Proceed with caution.
   * *   To call this operation, you must have an account that has the required permissions.
   * *   The returned `RequestId` value can be used to track the request processing progress and troubleshoot issues.
   * 
   * @param request - DeleteUserDeliveryTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteUserDeliveryTaskResponse
   */
  async deleteUserDeliveryTaskWithOptions(request: DeleteUserDeliveryTaskRequest, runtime: $Util.RuntimeOptions): Promise<DeleteUserDeliveryTaskResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.taskName)) {
      body["TaskName"] = request.taskName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteUserDeliveryTask",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteUserDeliveryTaskResponse>(await this.callApi(params, req, runtime), new DeleteUserDeliveryTaskResponse({}));
  }

  /**
   * Deletes a log delivery task from your Alibaba Cloud account.
   * 
   * @remarks
   * *****> 
   * *   Deleted tasks cannot be restored. Proceed with caution.
   * *   To call this operation, you must have an account that has the required permissions.
   * *   The returned `RequestId` value can be used to track the request processing progress and troubleshoot issues.
   * 
   * @param request - DeleteUserDeliveryTaskRequest
   * @returns DeleteUserDeliveryTaskResponse
   */
  async deleteUserDeliveryTask(request: DeleteUserDeliveryTaskRequest): Promise<DeleteUserDeliveryTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteUserDeliveryTaskWithOptions(request, runtime);
  }

  /**
   * Deletes a Web Application Firewall (WAF) rule, including its configurations and match conditions.
   * 
   * @param request - DeleteWafRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteWafRuleResponse
   */
  async deleteWafRuleWithOptions(request: DeleteWafRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteWafRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteWafRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteWafRuleResponse>(await this.callApi(params, req, runtime), new DeleteWafRuleResponse({}));
  }

  /**
   * Deletes a Web Application Firewall (WAF) rule, including its configurations and match conditions.
   * 
   * @param request - DeleteWafRuleRequest
   * @returns DeleteWafRuleResponse
   */
  async deleteWafRule(request: DeleteWafRuleRequest): Promise<DeleteWafRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteWafRuleWithOptions(request, runtime);
  }

  /**
   * Deletes a Web Application Firewall (WAF) ruleset that is no longer needed.
   * 
   * @param request - DeleteWafRulesetRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteWafRulesetResponse
   */
  async deleteWafRulesetWithOptions(request: DeleteWafRulesetRequest, runtime: $Util.RuntimeOptions): Promise<DeleteWafRulesetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteWafRuleset",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteWafRulesetResponse>(await this.callApi(params, req, runtime), new DeleteWafRulesetResponse({}));
  }

  /**
   * Deletes a Web Application Firewall (WAF) ruleset that is no longer needed.
   * 
   * @param request - DeleteWafRulesetRequest
   * @returns DeleteWafRulesetResponse
   */
  async deleteWafRuleset(request: DeleteWafRulesetRequest): Promise<DeleteWafRulesetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteWafRulesetWithOptions(request, runtime);
  }

  /**
   * Deletes a waiting room.
   * 
   * @param request - DeleteWaitingRoomRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteWaitingRoomResponse
   */
  async deleteWaitingRoomWithOptions(request: DeleteWaitingRoomRequest, runtime: $Util.RuntimeOptions): Promise<DeleteWaitingRoomResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.waitingRoomId)) {
      query["WaitingRoomId"] = request.waitingRoomId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteWaitingRoom",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteWaitingRoomResponse>(await this.callApi(params, req, runtime), new DeleteWaitingRoomResponse({}));
  }

  /**
   * Deletes a waiting room.
   * 
   * @param request - DeleteWaitingRoomRequest
   * @returns DeleteWaitingRoomResponse
   */
  async deleteWaitingRoom(request: DeleteWaitingRoomRequest): Promise<DeleteWaitingRoomResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteWaitingRoomWithOptions(request, runtime);
  }

  /**
   * Deletes a waiting room event.
   * 
   * @param request - DeleteWaitingRoomEventRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteWaitingRoomEventResponse
   */
  async deleteWaitingRoomEventWithOptions(request: DeleteWaitingRoomEventRequest, runtime: $Util.RuntimeOptions): Promise<DeleteWaitingRoomEventResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.waitingRoomEventId)) {
      query["WaitingRoomEventId"] = request.waitingRoomEventId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteWaitingRoomEvent",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteWaitingRoomEventResponse>(await this.callApi(params, req, runtime), new DeleteWaitingRoomEventResponse({}));
  }

  /**
   * Deletes a waiting room event.
   * 
   * @param request - DeleteWaitingRoomEventRequest
   * @returns DeleteWaitingRoomEventResponse
   */
  async deleteWaitingRoomEvent(request: DeleteWaitingRoomEventRequest): Promise<DeleteWaitingRoomEventResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteWaitingRoomEventWithOptions(request, runtime);
  }

  /**
   * Deletes a waiting room bypass rule.
   * 
   * @param request - DeleteWaitingRoomRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteWaitingRoomRuleResponse
   */
  async deleteWaitingRoomRuleWithOptions(request: DeleteWaitingRoomRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteWaitingRoomRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.waitingRoomRuleId)) {
      query["WaitingRoomRuleId"] = request.waitingRoomRuleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteWaitingRoomRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteWaitingRoomRuleResponse>(await this.callApi(params, req, runtime), new DeleteWaitingRoomRuleResponse({}));
  }

  /**
   * Deletes a waiting room bypass rule.
   * 
   * @param request - DeleteWaitingRoomRuleRequest
   * @returns DeleteWaitingRoomRuleResponse
   */
  async deleteWaitingRoomRule(request: DeleteWaitingRoomRuleRequest): Promise<DeleteWaitingRoomRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteWaitingRoomRuleWithOptions(request, runtime);
  }

  /**
   * Queries the configurations of a scenario-specific policy.
   * 
   * @param request - DescribeCustomScenePoliciesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCustomScenePoliciesResponse
   */
  async describeCustomScenePoliciesWithOptions(request: DescribeCustomScenePoliciesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCustomScenePoliciesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCustomScenePolicies",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCustomScenePoliciesResponse>(await this.callApi(params, req, runtime), new DescribeCustomScenePoliciesResponse({}));
  }

  /**
   * Queries the configurations of a scenario-specific policy.
   * 
   * @param request - DescribeCustomScenePoliciesRequest
   * @returns DescribeCustomScenePoliciesResponse
   */
  async describeCustomScenePolicies(request: DescribeCustomScenePoliciesRequest): Promise<DescribeCustomScenePoliciesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCustomScenePoliciesWithOptions(request, runtime);
  }

  /**
   * Queries DDoS attack events.
   * 
   * @param request - DescribeDDoSAllEventListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDDoSAllEventListResponse
   */
  async describeDDoSAllEventListWithOptions(request: DescribeDDoSAllEventListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDDoSAllEventListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDDoSAllEventList",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDDoSAllEventListResponse>(await this.callApi(params, req, runtime), new DescribeDDoSAllEventListResponse({}));
  }

  /**
   * Queries DDoS attack events.
   * 
   * @param request - DescribeDDoSAllEventListRequest
   * @returns DescribeDDoSAllEventListResponse
   */
  async describeDDoSAllEventList(request: DescribeDDoSAllEventListRequest): Promise<DescribeDDoSAllEventListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDDoSAllEventListWithOptions(request, runtime);
  }

  /**
   * Queries the configuration of smart HTTP DDoS protection for a website.
   * 
   * @param request - DescribeHttpDDoSAttackIntelligentProtectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeHttpDDoSAttackIntelligentProtectionResponse
   */
  async describeHttpDDoSAttackIntelligentProtectionWithOptions(request: DescribeHttpDDoSAttackIntelligentProtectionRequest, runtime: $Util.RuntimeOptions): Promise<DescribeHttpDDoSAttackIntelligentProtectionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeHttpDDoSAttackIntelligentProtection",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeHttpDDoSAttackIntelligentProtectionResponse>(await this.callApi(params, req, runtime), new DescribeHttpDDoSAttackIntelligentProtectionResponse({}));
  }

  /**
   * Queries the configuration of smart HTTP DDoS protection for a website.
   * 
   * @param request - DescribeHttpDDoSAttackIntelligentProtectionRequest
   * @returns DescribeHttpDDoSAttackIntelligentProtectionResponse
   */
  async describeHttpDDoSAttackIntelligentProtection(request: DescribeHttpDDoSAttackIntelligentProtectionRequest): Promise<DescribeHttpDDoSAttackIntelligentProtectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeHttpDDoSAttackIntelligentProtectionWithOptions(request, runtime);
  }

  /**
   * Queries the configurations of HTTP DDoS attack protection.
   * 
   * @param request - DescribeHttpDDoSAttackProtectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeHttpDDoSAttackProtectionResponse
   */
  async describeHttpDDoSAttackProtectionWithOptions(request: DescribeHttpDDoSAttackProtectionRequest, runtime: $Util.RuntimeOptions): Promise<DescribeHttpDDoSAttackProtectionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeHttpDDoSAttackProtection",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeHttpDDoSAttackProtectionResponse>(await this.callApi(params, req, runtime), new DescribeHttpDDoSAttackProtectionResponse({}));
  }

  /**
   * Queries the configurations of HTTP DDoS attack protection.
   * 
   * @param request - DescribeHttpDDoSAttackProtectionRequest
   * @returns DescribeHttpDDoSAttackProtectionResponse
   */
  async describeHttpDDoSAttackProtection(request: DescribeHttpDDoSAttackProtectionRequest): Promise<DescribeHttpDDoSAttackProtectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeHttpDDoSAttackProtectionWithOptions(request, runtime);
  }

  /**
   * Queries whether Edge KV is activated in your Alibaba Cloud account.
   * 
   * @param request - DescribeKvAccountStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeKvAccountStatusResponse
   */
  async describeKvAccountStatusWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeKvAccountStatusResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeKvAccountStatus",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeKvAccountStatusResponse>(await this.callApi(params, req, runtime), new DescribeKvAccountStatusResponse({}));
  }

  /**
   * Queries whether Edge KV is activated in your Alibaba Cloud account.
   * @returns DescribeKvAccountStatusResponse
   */
  async describeKvAccountStatus(): Promise<DescribeKvAccountStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeKvAccountStatusWithOptions(runtime);
  }

  /**
   * Queries the details of prefetch tasks by time, task status, or prefetch URL.
   * 
   * @param request - DescribePreloadTasksRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePreloadTasksResponse
   */
  async describePreloadTasksWithOptions(request: DescribePreloadTasksRequest, runtime: $Util.RuntimeOptions): Promise<DescribePreloadTasksResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePreloadTasks",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePreloadTasksResponse>(await this.callApi(params, req, runtime), new DescribePreloadTasksResponse({}));
  }

  /**
   * Queries the details of prefetch tasks by time, task status, or prefetch URL.
   * 
   * @param request - DescribePreloadTasksRequest
   * @returns DescribePreloadTasksResponse
   */
  async describePreloadTasks(request: DescribePreloadTasksRequest): Promise<DescribePreloadTasksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePreloadTasksWithOptions(request, runtime);
  }

  /**
   * Queries the details of purge tasks.
   * 
   * @param request - DescribePurgeTasksRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePurgeTasksResponse
   */
  async describePurgeTasksWithOptions(request: DescribePurgeTasksRequest, runtime: $Util.RuntimeOptions): Promise<DescribePurgeTasksResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePurgeTasks",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePurgeTasksResponse>(await this.callApi(params, req, runtime), new DescribePurgeTasksResponse({}));
  }

  /**
   * Queries the details of purge tasks.
   * 
   * @param request - DescribePurgeTasksRequest
   * @returns DescribePurgeTasksResponse
   */
  async describePurgeTasks(request: DescribePurgeTasksRequest): Promise<DescribePurgeTasksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePurgeTasksWithOptions(request, runtime);
  }

  /**
   * Disables a scenario-specific policy.
   * 
   * @param request - DisableCustomScenePolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DisableCustomScenePolicyResponse
   */
  async disableCustomScenePolicyWithOptions(request: DisableCustomScenePolicyRequest, runtime: $Util.RuntimeOptions): Promise<DisableCustomScenePolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableCustomScenePolicy",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableCustomScenePolicyResponse>(await this.callApi(params, req, runtime), new DisableCustomScenePolicyResponse({}));
  }

  /**
   * Disables a scenario-specific policy.
   * 
   * @param request - DisableCustomScenePolicyRequest
   * @returns DisableCustomScenePolicyResponse
   */
  async disableCustomScenePolicy(request: DisableCustomScenePolicyRequest): Promise<DisableCustomScenePolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableCustomScenePolicyWithOptions(request, runtime);
  }

  /**
   * Modifies the Web Application Firewall (WAF) configuration of a website, such as the client IP address that is identified by WAF.
   * 
   * @param tmpReq - EditSiteWafSettingsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EditSiteWafSettingsResponse
   */
  async editSiteWafSettingsWithOptions(tmpReq: EditSiteWafSettingsRequest, runtime: $Util.RuntimeOptions): Promise<EditSiteWafSettingsResponse> {
    Util.validateModel(tmpReq);
    let request = new EditSiteWafSettingsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.settings)) {
      request.settingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.settings, "Settings", "json");
    }

    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.settingsShrink)) {
      body["Settings"] = request.settingsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "EditSiteWafSettings",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EditSiteWafSettingsResponse>(await this.callApi(params, req, runtime), new EditSiteWafSettingsResponse({}));
  }

  /**
   * Modifies the Web Application Firewall (WAF) configuration of a website, such as the client IP address that is identified by WAF.
   * 
   * @param request - EditSiteWafSettingsRequest
   * @returns EditSiteWafSettingsResponse
   */
  async editSiteWafSettings(request: EditSiteWafSettingsRequest): Promise<EditSiteWafSettingsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.editSiteWafSettingsWithOptions(request, runtime);
  }

  /**
   * Enables a scenario-specific policy.
   * 
   * @param request - EnableCustomScenePolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnableCustomScenePolicyResponse
   */
  async enableCustomScenePolicyWithOptions(request: EnableCustomScenePolicyRequest, runtime: $Util.RuntimeOptions): Promise<EnableCustomScenePolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableCustomScenePolicy",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableCustomScenePolicyResponse>(await this.callApi(params, req, runtime), new EnableCustomScenePolicyResponse({}));
  }

  /**
   * Enables a scenario-specific policy.
   * 
   * @param request - EnableCustomScenePolicyRequest
   * @returns EnableCustomScenePolicyResponse
   */
  async enableCustomScenePolicy(request: EnableCustomScenePolicyRequest): Promise<EnableCustomScenePolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableCustomScenePolicyWithOptions(request, runtime);
  }

  /**
   * Exports all DNS records of a website domain as a TXT file.
   * 
   * @param request - ExportRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExportRecordsResponse
   */
  async exportRecordsWithOptions(request: ExportRecordsRequest, runtime: $Util.RuntimeOptions): Promise<ExportRecordsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ExportRecords",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExportRecordsResponse>(await this.callApi(params, req, runtime), new ExportRecordsResponse({}));
  }

  /**
   * Exports all DNS records of a website domain as a TXT file.
   * 
   * @param request - ExportRecordsRequest
   * @returns ExportRecordsResponse
   */
  async exportRecords(request: ExportRecordsRequest): Promise<ExportRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.exportRecordsWithOptions(request, runtime);
  }

  /**
   * Queries the available specifications of cache reserve instances.
   * 
   * @param request - GetCacheReserveSpecificationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetCacheReserveSpecificationResponse
   */
  async getCacheReserveSpecificationWithOptions(runtime: $Util.RuntimeOptions): Promise<GetCacheReserveSpecificationResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetCacheReserveSpecification",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetCacheReserveSpecificationResponse>(await this.callApi(params, req, runtime), new GetCacheReserveSpecificationResponse({}));
  }

  /**
   * Queries the available specifications of cache reserve instances.
   * @returns GetCacheReserveSpecificationResponse
   */
  async getCacheReserveSpecification(): Promise<GetCacheReserveSpecificationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getCacheReserveSpecificationWithOptions(runtime);
  }

  /**
   * Queries the information about a containerized application, including basic application configurations and health check configurations.
   * 
   * @param request - GetEdgeContainerAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetEdgeContainerAppResponse
   */
  async getEdgeContainerAppWithOptions(request: GetEdgeContainerAppRequest, runtime: $Util.RuntimeOptions): Promise<GetEdgeContainerAppResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetEdgeContainerApp",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetEdgeContainerAppResponse>(await this.callApi(params, req, runtime), new GetEdgeContainerAppResponse({}));
  }

  /**
   * Queries the information about a containerized application, including basic application configurations and health check configurations.
   * 
   * @param request - GetEdgeContainerAppRequest
   * @returns GetEdgeContainerAppResponse
   */
  async getEdgeContainerApp(request: GetEdgeContainerAppRequest): Promise<GetEdgeContainerAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getEdgeContainerAppWithOptions(request, runtime);
  }

  /**
   * Queries the status information about a containerized application, including the deployment, release, and rollback of the application.
   * 
   * @param request - GetEdgeContainerAppStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetEdgeContainerAppStatusResponse
   */
  async getEdgeContainerAppStatusWithOptions(request: GetEdgeContainerAppStatusRequest, runtime: $Util.RuntimeOptions): Promise<GetEdgeContainerAppStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.publishEnv)) {
      query["PublishEnv"] = request.publishEnv;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetEdgeContainerAppStatus",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetEdgeContainerAppStatusResponse>(await this.callApi(params, req, runtime), new GetEdgeContainerAppStatusResponse({}));
  }

  /**
   * Queries the status information about a containerized application, including the deployment, release, and rollback of the application.
   * 
   * @param request - GetEdgeContainerAppStatusRequest
   * @returns GetEdgeContainerAppStatusResponse
   */
  async getEdgeContainerAppStatus(request: GetEdgeContainerAppStatusRequest): Promise<GetEdgeContainerAppStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getEdgeContainerAppStatusWithOptions(request, runtime);
  }

  /**
   * Queries the information about a version of a containerized application. You can select an application version to release based on the version information.
   * 
   * @param request - GetEdgeContainerAppVersionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetEdgeContainerAppVersionResponse
   */
  async getEdgeContainerAppVersionWithOptions(request: GetEdgeContainerAppVersionRequest, runtime: $Util.RuntimeOptions): Promise<GetEdgeContainerAppVersionResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetEdgeContainerAppVersion",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetEdgeContainerAppVersionResponse>(await this.callApi(params, req, runtime), new GetEdgeContainerAppVersionResponse({}));
  }

  /**
   * Queries the information about a version of a containerized application. You can select an application version to release based on the version information.
   * 
   * @param request - GetEdgeContainerAppVersionRequest
   * @returns GetEdgeContainerAppVersionResponse
   */
  async getEdgeContainerAppVersion(request: GetEdgeContainerAppVersionRequest): Promise<GetEdgeContainerAppVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getEdgeContainerAppVersionWithOptions(request, runtime);
  }

  /**
   * Queries regions where a containerized application is deployed based on the application ID.
   * 
   * @param request - GetEdgeContainerDeployRegionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetEdgeContainerDeployRegionsResponse
   */
  async getEdgeContainerDeployRegionsWithOptions(request: GetEdgeContainerDeployRegionsRequest, runtime: $Util.RuntimeOptions): Promise<GetEdgeContainerDeployRegionsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetEdgeContainerDeployRegions",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetEdgeContainerDeployRegionsResponse>(await this.callApi(params, req, runtime), new GetEdgeContainerDeployRegionsResponse({}));
  }

  /**
   * Queries regions where a containerized application is deployed based on the application ID.
   * 
   * @param request - GetEdgeContainerDeployRegionsRequest
   * @returns GetEdgeContainerDeployRegionsResponse
   */
  async getEdgeContainerDeployRegions(request: GetEdgeContainerDeployRegionsRequest): Promise<GetEdgeContainerDeployRegionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getEdgeContainerDeployRegionsWithOptions(request, runtime);
  }

  /**
   * Queries Edge Container logs.
   * 
   * @param request - GetEdgeContainerLogsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetEdgeContainerLogsResponse
   */
  async getEdgeContainerLogsWithOptions(request: GetEdgeContainerLogsRequest, runtime: $Util.RuntimeOptions): Promise<GetEdgeContainerLogsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetEdgeContainerLogs",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetEdgeContainerLogsResponse>(await this.callApi(params, req, runtime), new GetEdgeContainerLogsResponse({}));
  }

  /**
   * Queries Edge Container logs.
   * 
   * @param request - GetEdgeContainerLogsRequest
   * @returns GetEdgeContainerLogsResponse
   */
  async getEdgeContainerLogs(request: GetEdgeContainerLogsRequest): Promise<GetEdgeContainerLogsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getEdgeContainerLogsWithOptions(request, runtime);
  }

  /**
   * Queries the deployment status of an application in the staging environment by using the application ID.
   * 
   * @param request - GetEdgeContainerStagingDeployStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetEdgeContainerStagingDeployStatusResponse
   */
  async getEdgeContainerStagingDeployStatusWithOptions(request: GetEdgeContainerStagingDeployStatusRequest, runtime: $Util.RuntimeOptions): Promise<GetEdgeContainerStagingDeployStatusResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetEdgeContainerStagingDeployStatus",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetEdgeContainerStagingDeployStatusResponse>(await this.callApi(params, req, runtime), new GetEdgeContainerStagingDeployStatusResponse({}));
  }

  /**
   * Queries the deployment status of an application in the staging environment by using the application ID.
   * 
   * @param request - GetEdgeContainerStagingDeployStatusRequest
   * @returns GetEdgeContainerStagingDeployStatusResponse
   */
  async getEdgeContainerStagingDeployStatus(request: GetEdgeContainerStagingDeployStatusRequest): Promise<GetEdgeContainerStagingDeployStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getEdgeContainerStagingDeployStatusWithOptions(request, runtime);
  }

  /**
   * Queries the terminal information of a containerized application.
   * 
   * @param request - GetEdgeContainerTerminalRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetEdgeContainerTerminalResponse
   */
  async getEdgeContainerTerminalWithOptions(request: GetEdgeContainerTerminalRequest, runtime: $Util.RuntimeOptions): Promise<GetEdgeContainerTerminalResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetEdgeContainerTerminal",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetEdgeContainerTerminalResponse>(await this.callApi(params, req, runtime), new GetEdgeContainerTerminalResponse({}));
  }

  /**
   * Queries the terminal information of a containerized application.
   * 
   * @param request - GetEdgeContainerTerminalRequest
   * @returns GetEdgeContainerTerminalResponse
   */
  async getEdgeContainerTerminal(request: GetEdgeContainerTerminalRequest): Promise<GetEdgeContainerTerminalResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getEdgeContainerTerminalWithOptions(request, runtime);
  }

  /**
   * Checks the status of Edge Routine.
   * 
   * @param request - GetErServiceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetErServiceResponse
   */
  async getErServiceWithOptions(request: GetErServiceRequest, runtime: $Util.RuntimeOptions): Promise<GetErServiceResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetErService",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetErServiceResponse>(await this.callApi(params, req, runtime), new GetErServiceResponse({}));
  }

  /**
   * Checks the status of Edge Routine.
   * 
   * @param request - GetErServiceRequest
   * @returns GetErServiceResponse
   */
  async getErService(request: GetErServiceRequest): Promise<GetErServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getErServiceWithOptions(request, runtime);
  }

  /**
   * Queries the value of a key in a key-value pair.
   * 
   * @param request - GetKvRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetKvResponse
   */
  async getKvWithOptions(request: GetKvRequest, runtime: $Util.RuntimeOptions): Promise<GetKvResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetKv",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetKvResponse>(await this.callApi(params, req, runtime), new GetKvResponse({}));
  }

  /**
   * Queries the value of a key in a key-value pair.
   * 
   * @param request - GetKvRequest
   * @returns GetKvResponse
   */
  async getKv(request: GetKvRequest): Promise<GetKvResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getKvWithOptions(request, runtime);
  }

  /**
   * Queries the Edge KV usage in your Alibaba Cloud account, including the information about all namespaces.
   * 
   * @param request - GetKvAccountRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetKvAccountResponse
   */
  async getKvAccountWithOptions(runtime: $Util.RuntimeOptions): Promise<GetKvAccountResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetKvAccount",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetKvAccountResponse>(await this.callApi(params, req, runtime), new GetKvAccountResponse({}));
  }

  /**
   * Queries the Edge KV usage in your Alibaba Cloud account, including the information about all namespaces.
   * @returns GetKvAccountResponse
   */
  async getKvAccount(): Promise<GetKvAccountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getKvAccountWithOptions(runtime);
  }

  /**
   * Queries the information about a namespace in your Alibaba Cloud account.
   * 
   * @param request - GetKvNamespaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetKvNamespaceResponse
   */
  async getKvNamespaceWithOptions(request: GetKvNamespaceRequest, runtime: $Util.RuntimeOptions): Promise<GetKvNamespaceResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetKvNamespace",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetKvNamespaceResponse>(await this.callApi(params, req, runtime), new GetKvNamespaceResponse({}));
  }

  /**
   * Queries the information about a namespace in your Alibaba Cloud account.
   * 
   * @param request - GetKvNamespaceRequest
   * @returns GetKvNamespaceResponse
   */
  async getKvNamespace(request: GetKvNamespaceRequest): Promise<GetKvNamespaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getKvNamespaceWithOptions(request, runtime);
  }

  /**
   * Queries the details of a custom list, such as the name, description, type, and content.
   * 
   * @param request - GetListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetListResponse
   */
  async getListWithOptions(request: GetListRequest, runtime: $Util.RuntimeOptions): Promise<GetListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetList",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetListResponse>(await this.callApi(params, req, runtime), new GetListResponse({}));
  }

  /**
   * Queries the details of a custom list, such as the name, description, type, and content.
   * 
   * @param request - GetListRequest
   * @returns GetListResponse
   */
  async getList(request: GetListRequest): Promise<GetListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getListWithOptions(request, runtime);
  }

  /**
   * 查询站点源站防护相关配置，查看回源IP白名单信息
   * 
   * @param request - GetOriginProtectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetOriginProtectionResponse
   */
  async getOriginProtectionWithOptions(request: GetOriginProtectionRequest, runtime: $Util.RuntimeOptions): Promise<GetOriginProtectionResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOriginProtection",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOriginProtectionResponse>(await this.callApi(params, req, runtime), new GetOriginProtectionResponse({}));
  }

  /**
   * 查询站点源站防护相关配置，查看回源IP白名单信息
   * 
   * @param request - GetOriginProtectionRequest
   * @returns GetOriginProtectionResponse
   */
  async getOriginProtection(request: GetOriginProtectionRequest): Promise<GetOriginProtectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOriginProtectionWithOptions(request, runtime);
  }

  /**
   * Queries the details of a custom error page based on the error page ID.
   * 
   * @param request - GetPageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPageResponse
   */
  async getPageWithOptions(request: GetPageRequest, runtime: $Util.RuntimeOptions): Promise<GetPageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPage",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetPageResponse>(await this.callApi(params, req, runtime), new GetPageResponse({}));
  }

  /**
   * Queries the details of a custom error page based on the error page ID.
   * 
   * @param request - GetPageRequest
   * @returns GetPageResponse
   */
  async getPage(request: GetPageRequest): Promise<GetPageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getPageWithOptions(request, runtime);
  }

  /**
   * Queries the quotas and quota usage for different cache purge options.
   * 
   * @param request - GetPurgeQuotaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPurgeQuotaResponse
   */
  async getPurgeQuotaWithOptions(request: GetPurgeQuotaRequest, runtime: $Util.RuntimeOptions): Promise<GetPurgeQuotaResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPurgeQuota",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetPurgeQuotaResponse>(await this.callApi(params, req, runtime), new GetPurgeQuotaResponse({}));
  }

  /**
   * Queries the quotas and quota usage for different cache purge options.
   * 
   * @param request - GetPurgeQuotaRequest
   * @returns GetPurgeQuotaResponse
   */
  async getPurgeQuota(request: GetPurgeQuotaRequest): Promise<GetPurgeQuotaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getPurgeQuotaWithOptions(request, runtime);
  }

  /**
   * Queries the fields in real-time logs based on the log category.
   * 
   * @param request - GetRealtimeDeliveryFieldRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRealtimeDeliveryFieldResponse
   */
  async getRealtimeDeliveryFieldWithOptions(request: GetRealtimeDeliveryFieldRequest, runtime: $Util.RuntimeOptions): Promise<GetRealtimeDeliveryFieldResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRealtimeDeliveryField",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetRealtimeDeliveryFieldResponse>(await this.callApi(params, req, runtime), new GetRealtimeDeliveryFieldResponse({}));
  }

  /**
   * Queries the fields in real-time logs based on the log category.
   * 
   * @param request - GetRealtimeDeliveryFieldRequest
   * @returns GetRealtimeDeliveryFieldResponse
   */
  async getRealtimeDeliveryField(request: GetRealtimeDeliveryFieldRequest): Promise<GetRealtimeDeliveryFieldResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRealtimeDeliveryFieldWithOptions(request, runtime);
  }

  /**
   * 查询单个记录信息
   * 
   * @param request - GetRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRecordResponse
   */
  async getRecordWithOptions(request: GetRecordRequest, runtime: $Util.RuntimeOptions): Promise<GetRecordResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRecord",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetRecordResponse>(await this.callApi(params, req, runtime), new GetRecordResponse({}));
  }

  /**
   * 查询单个记录信息
   * 
   * @param request - GetRecordRequest
   * @returns GetRecordResponse
   */
  async getRecord(request: GetRecordRequest): Promise<GetRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRecordWithOptions(request, runtime);
  }

  /**
   * Queries the configurations of a routine, including the code versions and the configurations of the environments, associated domain names, and associated routes.
   * 
   * @param request - GetRoutineRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRoutineResponse
   */
  async getRoutineWithOptions(request: GetRoutineRequest, runtime: $Util.RuntimeOptions): Promise<GetRoutineResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetRoutine",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetRoutineResponse>(await this.callApi(params, req, runtime), new GetRoutineResponse({}));
  }

  /**
   * Queries the configurations of a routine, including the code versions and the configurations of the environments, associated domain names, and associated routes.
   * 
   * @param request - GetRoutineRequest
   * @returns GetRoutineResponse
   */
  async getRoutine(request: GetRoutineRequest): Promise<GetRoutineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRoutineWithOptions(request, runtime);
  }

  /**
   * Obtains the release information about the routine code that is released to the staging environment. This information can be used to upload the test code to Object Storage Service (OSS).
   * 
   * @remarks
   *   Every time the code of a routine is released to the staging environment, a version number is generated. Such code is for tests only.
   * *   A routine can retain a maximum of 10 code versions. If the number of versions reaches the limit, you must call the DeleteRoutineCodeRevision operation to delete unwanted versions.
   * 
   * @param request - GetRoutineStagingCodeUploadInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRoutineStagingCodeUploadInfoResponse
   */
  async getRoutineStagingCodeUploadInfoWithOptions(request: GetRoutineStagingCodeUploadInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetRoutineStagingCodeUploadInfoResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.codeDescription)) {
      body["CodeDescription"] = request.codeDescription;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetRoutineStagingCodeUploadInfo",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetRoutineStagingCodeUploadInfoResponse>(await this.callApi(params, req, runtime), new GetRoutineStagingCodeUploadInfoResponse({}));
  }

  /**
   * Obtains the release information about the routine code that is released to the staging environment. This information can be used to upload the test code to Object Storage Service (OSS).
   * 
   * @remarks
   *   Every time the code of a routine is released to the staging environment, a version number is generated. Such code is for tests only.
   * *   A routine can retain a maximum of 10 code versions. If the number of versions reaches the limit, you must call the DeleteRoutineCodeRevision operation to delete unwanted versions.
   * 
   * @param request - GetRoutineStagingCodeUploadInfoRequest
   * @returns GetRoutineStagingCodeUploadInfoResponse
   */
  async getRoutineStagingCodeUploadInfo(request: GetRoutineStagingCodeUploadInfoRequest): Promise<GetRoutineStagingCodeUploadInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRoutineStagingCodeUploadInfoWithOptions(request, runtime);
  }

  /**
   * Queries the IP addresses of staging environments for Edge Routine.
   * 
   * @param request - GetRoutineStagingEnvIpRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRoutineStagingEnvIpResponse
   */
  async getRoutineStagingEnvIpWithOptions(runtime: $Util.RuntimeOptions): Promise<GetRoutineStagingEnvIpResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetRoutineStagingEnvIp",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetRoutineStagingEnvIpResponse>(await this.callApi(params, req, runtime), new GetRoutineStagingEnvIpResponse({}));
  }

  /**
   * Queries the IP addresses of staging environments for Edge Routine.
   * @returns GetRoutineStagingEnvIpResponse
   */
  async getRoutineStagingEnvIp(): Promise<GetRoutineStagingEnvIpResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRoutineStagingEnvIpWithOptions(runtime);
  }

  /**
   * Queries the Edge Routine information in your Alibaba Cloud account, including the associated subdomain and created routines.
   * 
   * @param request - GetRoutineUserInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRoutineUserInfoResponse
   */
  async getRoutineUserInfoWithOptions(runtime: $Util.RuntimeOptions): Promise<GetRoutineUserInfoResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetRoutineUserInfo",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetRoutineUserInfoResponse>(await this.callApi(params, req, runtime), new GetRoutineUserInfoResponse({}));
  }

  /**
   * Queries the Edge Routine information in your Alibaba Cloud account, including the associated subdomain and created routines.
   * @returns GetRoutineUserInfoResponse
   */
  async getRoutineUserInfo(): Promise<GetRoutineUserInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRoutineUserInfoWithOptions(runtime);
  }

  /**
   * Queries a specified scheduled prefetch task based on the task ID.
   * 
   * @param request - GetScheduledPreloadJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetScheduledPreloadJobResponse
   */
  async getScheduledPreloadJobWithOptions(request: GetScheduledPreloadJobRequest, runtime: $Util.RuntimeOptions): Promise<GetScheduledPreloadJobResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetScheduledPreloadJob",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetScheduledPreloadJobResponse>(await this.callApi(params, req, runtime), new GetScheduledPreloadJobResponse({}));
  }

  /**
   * Queries a specified scheduled prefetch task based on the task ID.
   * 
   * @param request - GetScheduledPreloadJobRequest
   * @returns GetScheduledPreloadJobResponse
   */
  async getScheduledPreloadJob(request: GetScheduledPreloadJobRequest): Promise<GetScheduledPreloadJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getScheduledPreloadJobWithOptions(request, runtime);
  }

  /**
   * Queries information about a website based on the website ID.
   * 
   * @param request - GetSiteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSiteResponse
   */
  async getSiteWithOptions(request: GetSiteRequest, runtime: $Util.RuntimeOptions): Promise<GetSiteResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSite",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSiteResponse>(await this.callApi(params, req, runtime), new GetSiteResponse({}));
  }

  /**
   * Queries information about a website based on the website ID.
   * 
   * @param request - GetSiteRequest
   * @returns GetSiteResponse
   */
  async getSite(request: GetSiteRequest): Promise<GetSiteResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSiteWithOptions(request, runtime);
  }

  /**
   * Queries the nameservers configured for a website.
   * 
   * @param request - GetSiteCurrentNSRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSiteCurrentNSResponse
   */
  async getSiteCurrentNSWithOptions(request: GetSiteCurrentNSRequest, runtime: $Util.RuntimeOptions): Promise<GetSiteCurrentNSResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSiteCurrentNS",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSiteCurrentNSResponse>(await this.callApi(params, req, runtime), new GetSiteCurrentNSResponse({}));
  }

  /**
   * Queries the nameservers configured for a website.
   * 
   * @param request - GetSiteCurrentNSRequest
   * @returns GetSiteCurrentNSResponse
   */
  async getSiteCurrentNS(request: GetSiteCurrentNSRequest): Promise<GetSiteCurrentNSResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSiteCurrentNSWithOptions(request, runtime);
  }

  /**
   * Queries the configuration of custom log fields for a website.
   * 
   * @remarks
   *   **Description**: You can call this operation to query the configuration of custom log fields for a website, including custom fields in request headers, response headers, and cookies.
   * *   **Scenarios**: You can call this operation in scenarios where you need to obtain specific HTTP headers or cookie information for log analysis.
   * *   ****
   * 
   * @param request - GetSiteCustomLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSiteCustomLogResponse
   */
  async getSiteCustomLogWithOptions(request: GetSiteCustomLogRequest, runtime: $Util.RuntimeOptions): Promise<GetSiteCustomLogResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSiteCustomLog",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSiteCustomLogResponse>(await this.callApi(params, req, runtime), new GetSiteCustomLogResponse({}));
  }

  /**
   * Queries the configuration of custom log fields for a website.
   * 
   * @remarks
   *   **Description**: You can call this operation to query the configuration of custom log fields for a website, including custom fields in request headers, response headers, and cookies.
   * *   **Scenarios**: You can call this operation in scenarios where you need to obtain specific HTTP headers or cookie information for log analysis.
   * *   ****
   * 
   * @param request - GetSiteCustomLogRequest
   * @returns GetSiteCustomLogResponse
   */
  async getSiteCustomLog(request: GetSiteCustomLogRequest): Promise<GetSiteCustomLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSiteCustomLogWithOptions(request, runtime);
  }

  /**
   * Queries a real-time log delivery task.
   * 
   * @param request - GetSiteDeliveryTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSiteDeliveryTaskResponse
   */
  async getSiteDeliveryTaskWithOptions(request: GetSiteDeliveryTaskRequest, runtime: $Util.RuntimeOptions): Promise<GetSiteDeliveryTaskResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSiteDeliveryTask",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSiteDeliveryTaskResponse>(await this.callApi(params, req, runtime), new GetSiteDeliveryTaskResponse({}));
  }

  /**
   * Queries a real-time log delivery task.
   * 
   * @param request - GetSiteDeliveryTaskRequest
   * @returns GetSiteDeliveryTaskResponse
   */
  async getSiteDeliveryTask(request: GetSiteDeliveryTaskRequest): Promise<GetSiteDeliveryTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSiteDeliveryTaskWithOptions(request, runtime);
  }

  /**
   * Queries the remaining quota for delivering a specific category of real-time logs in a website.
   * 
   * @remarks
   * You can call this operation to query the remaining quota for delivering a specific category of real-time logs in a website within an Alibaba Cloud account. This is essential for monitoring and managing your log delivery capacity to ensure that logs can be delivered to the destination and prevent data loss or latency caused by insufficient quota.
   * **Take note of the following parameters:**
   * *   ``
   * *   `BusinessType` is required. You must specify a log category to obtain the corresponding quota information.
   * *   `SiteId` specifies the ID of a website, which must be a valid integer that corresponds to a website that you configured on Alibaba Cloud.
   * **Response:**
   * *   If a request is successful, the system returns the remaining log delivery quota (`FreeQuota`), request ID (`RequestId`), website ID (`SiteId`), and log category (`BusinessType`). You can confirm and record the returned data.
   * 
   * @param request - GetSiteLogDeliveryQuotaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSiteLogDeliveryQuotaResponse
   */
  async getSiteLogDeliveryQuotaWithOptions(request: GetSiteLogDeliveryQuotaRequest, runtime: $Util.RuntimeOptions): Promise<GetSiteLogDeliveryQuotaResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSiteLogDeliveryQuota",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSiteLogDeliveryQuotaResponse>(await this.callApi(params, req, runtime), new GetSiteLogDeliveryQuotaResponse({}));
  }

  /**
   * Queries the remaining quota for delivering a specific category of real-time logs in a website.
   * 
   * @remarks
   * You can call this operation to query the remaining quota for delivering a specific category of real-time logs in a website within an Alibaba Cloud account. This is essential for monitoring and managing your log delivery capacity to ensure that logs can be delivered to the destination and prevent data loss or latency caused by insufficient quota.
   * **Take note of the following parameters:**
   * *   ``
   * *   `BusinessType` is required. You must specify a log category to obtain the corresponding quota information.
   * *   `SiteId` specifies the ID of a website, which must be a valid integer that corresponds to a website that you configured on Alibaba Cloud.
   * **Response:**
   * *   If a request is successful, the system returns the remaining log delivery quota (`FreeQuota`), request ID (`RequestId`), website ID (`SiteId`), and log category (`BusinessType`). You can confirm and record the returned data.
   * 
   * @param request - GetSiteLogDeliveryQuotaRequest
   * @returns GetSiteLogDeliveryQuotaResponse
   */
  async getSiteLogDeliveryQuota(request: GetSiteLogDeliveryQuotaRequest): Promise<GetSiteLogDeliveryQuotaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSiteLogDeliveryQuotaWithOptions(request, runtime);
  }

  /**
   * Queries the Web Application Firewall (WAF) configurations of a website.
   * 
   * @param request - GetSiteWafSettingsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSiteWafSettingsResponse
   */
  async getSiteWafSettingsWithOptions(request: GetSiteWafSettingsRequest, runtime: $Util.RuntimeOptions): Promise<GetSiteWafSettingsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSiteWafSettings",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSiteWafSettingsResponse>(await this.callApi(params, req, runtime), new GetSiteWafSettingsResponse({}));
  }

  /**
   * Queries the Web Application Firewall (WAF) configurations of a website.
   * 
   * @param request - GetSiteWafSettingsRequest
   * @returns GetSiteWafSettingsResponse
   */
  async getSiteWafSettings(request: GetSiteWafSettingsRequest): Promise<GetSiteWafSettingsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSiteWafSettingsWithOptions(request, runtime);
  }

  /**
   * Queries the execution status and running information of a file upload task based on the task ID.
   * 
   * @param request - GetUploadTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetUploadTaskResponse
   */
  async getUploadTaskWithOptions(request: GetUploadTaskRequest, runtime: $Util.RuntimeOptions): Promise<GetUploadTaskResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetUploadTask",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetUploadTaskResponse>(await this.callApi(params, req, runtime), new GetUploadTaskResponse({}));
  }

  /**
   * Queries the execution status and running information of a file upload task based on the task ID.
   * 
   * @param request - GetUploadTaskRequest
   * @returns GetUploadTaskResponse
   */
  async getUploadTask(request: GetUploadTaskRequest): Promise<GetUploadTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getUploadTaskWithOptions(request, runtime);
  }

  /**
   * Queries the information about a log delivery task by account.
   * 
   * @remarks
   *   This API operation queries the details of a delivery task, including the task name, discard rate, region, log category, status, delivery destination, configuration, and filtering rules.****
   * *   You can call this operation to query detailed information about a log delivery task to analyze log processing efficiency or troubleshoot delivery problems.****
   * *   ****````
   * 
   * @param request - GetUserDeliveryTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetUserDeliveryTaskResponse
   */
  async getUserDeliveryTaskWithOptions(request: GetUserDeliveryTaskRequest, runtime: $Util.RuntimeOptions): Promise<GetUserDeliveryTaskResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetUserDeliveryTask",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetUserDeliveryTaskResponse>(await this.callApi(params, req, runtime), new GetUserDeliveryTaskResponse({}));
  }

  /**
   * Queries the information about a log delivery task by account.
   * 
   * @remarks
   *   This API operation queries the details of a delivery task, including the task name, discard rate, region, log category, status, delivery destination, configuration, and filtering rules.****
   * *   You can call this operation to query detailed information about a log delivery task to analyze log processing efficiency or troubleshoot delivery problems.****
   * *   ****````
   * 
   * @param request - GetUserDeliveryTaskRequest
   * @returns GetUserDeliveryTaskResponse
   */
  async getUserDeliveryTask(request: GetUserDeliveryTaskRequest): Promise<GetUserDeliveryTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getUserDeliveryTaskWithOptions(request, runtime);
  }

  /**
   * Queries the remaining log delivery quota of each log category in your account.
   * 
   * @remarks
   * This operation allows you to query the remaining real-time log delivery quota of each log category in your Alibaba Cloud account. You must provide your Alibaba Cloud account ID (aliUid) and log category (BusinessType). The system then returns the remaining quota of the log category to help you track the usage.
   * 
   * @param request - GetUserLogDeliveryQuotaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetUserLogDeliveryQuotaResponse
   */
  async getUserLogDeliveryQuotaWithOptions(request: GetUserLogDeliveryQuotaRequest, runtime: $Util.RuntimeOptions): Promise<GetUserLogDeliveryQuotaResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetUserLogDeliveryQuota",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetUserLogDeliveryQuotaResponse>(await this.callApi(params, req, runtime), new GetUserLogDeliveryQuotaResponse({}));
  }

  /**
   * Queries the remaining log delivery quota of each log category in your account.
   * 
   * @remarks
   * This operation allows you to query the remaining real-time log delivery quota of each log category in your Alibaba Cloud account. You must provide your Alibaba Cloud account ID (aliUid) and log category (BusinessType). The system then returns the remaining quota of the log category to help you track the usage.
   * 
   * @param request - GetUserLogDeliveryQuotaRequest
   * @returns GetUserLogDeliveryQuotaResponse
   */
  async getUserLogDeliveryQuota(request: GetUserLogDeliveryQuotaRequest): Promise<GetUserLogDeliveryQuotaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getUserLogDeliveryQuotaWithOptions(request, runtime);
  }

  /**
   * Queries the application key (AppKey) that is used for authentication and data exchange in bot behavior detection in Web Application Firewall (WAF).
   * 
   * @param request - GetWafBotAppKeyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetWafBotAppKeyResponse
   */
  async getWafBotAppKeyWithOptions(runtime: $Util.RuntimeOptions): Promise<GetWafBotAppKeyResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetWafBotAppKey",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetWafBotAppKeyResponse>(await this.callApi(params, req, runtime), new GetWafBotAppKeyResponse({}));
  }

  /**
   * Queries the application key (AppKey) that is used for authentication and data exchange in bot behavior detection in Web Application Firewall (WAF).
   * @returns GetWafBotAppKeyResponse
   */
  async getWafBotAppKey(): Promise<GetWafBotAppKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getWafBotAppKeyWithOptions(runtime);
  }

  /**
   * Queries the conditions for matching incoming requests that are configured in a WAF rule category for a website. These conditions define how WAF detects and processes different types of requests.
   * 
   * @param request - GetWafFilterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetWafFilterResponse
   */
  async getWafFilterWithOptions(request: GetWafFilterRequest, runtime: $Util.RuntimeOptions): Promise<GetWafFilterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.phase)) {
      query["Phase"] = request.phase;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.target)) {
      query["Target"] = request.target;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetWafFilter",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetWafFilterResponse>(await this.callApi(params, req, runtime), new GetWafFilterResponse({}));
  }

  /**
   * Queries the conditions for matching incoming requests that are configured in a WAF rule category for a website. These conditions define how WAF detects and processes different types of requests.
   * 
   * @param request - GetWafFilterRequest
   * @returns GetWafFilterResponse
   */
  async getWafFilter(request: GetWafFilterRequest): Promise<GetWafFilterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getWafFilterWithOptions(request, runtime);
  }

  /**
   * Queries the quotas of Web Application Firewall (WAF) resources, such as managed rule groups, custom lists, custom error pages, and scenario-specific policies.
   * 
   * @param request - GetWafQuotaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetWafQuotaResponse
   */
  async getWafQuotaWithOptions(request: GetWafQuotaRequest, runtime: $Util.RuntimeOptions): Promise<GetWafQuotaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.paths)) {
      query["Paths"] = request.paths;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetWafQuota",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetWafQuotaResponse>(await this.callApi(params, req, runtime), new GetWafQuotaResponse({}));
  }

  /**
   * Queries the quotas of Web Application Firewall (WAF) resources, such as managed rule groups, custom lists, custom error pages, and scenario-specific policies.
   * 
   * @param request - GetWafQuotaRequest
   * @returns GetWafQuotaResponse
   */
  async getWafQuota(request: GetWafQuotaRequest): Promise<GetWafQuotaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getWafQuotaWithOptions(request, runtime);
  }

  /**
   * Queries the details of a Web Application Firewall (WAF) rule, such as its configuration and status.
   * 
   * @param request - GetWafRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetWafRuleResponse
   */
  async getWafRuleWithOptions(request: GetWafRuleRequest, runtime: $Util.RuntimeOptions): Promise<GetWafRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetWafRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetWafRuleResponse>(await this.callApi(params, req, runtime), new GetWafRuleResponse({}));
  }

  /**
   * Queries the details of a Web Application Firewall (WAF) rule, such as its configuration and status.
   * 
   * @param request - GetWafRuleRequest
   * @returns GetWafRuleResponse
   */
  async getWafRule(request: GetWafRuleRequest): Promise<GetWafRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getWafRuleWithOptions(request, runtime);
  }

  /**
   * Queries the details of a Web Application Firewall (WAF) ruleset, such as the configuration and status.
   * 
   * @param request - GetWafRulesetRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetWafRulesetResponse
   */
  async getWafRulesetWithOptions(request: GetWafRulesetRequest, runtime: $Util.RuntimeOptions): Promise<GetWafRulesetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.phase)) {
      query["Phase"] = request.phase;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetWafRuleset",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetWafRulesetResponse>(await this.callApi(params, req, runtime), new GetWafRulesetResponse({}));
  }

  /**
   * Queries the details of a Web Application Firewall (WAF) ruleset, such as the configuration and status.
   * 
   * @param request - GetWafRulesetRequest
   * @returns GetWafRulesetResponse
   */
  async getWafRuleset(request: GetWafRulesetRequest): Promise<GetWafRulesetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getWafRulesetWithOptions(request, runtime);
  }

  /**
   * Queries the cache reserve instances in your Alibaba Cloud account.
   * 
   * @param request - ListCacheReserveInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListCacheReserveInstancesResponse
   */
  async listCacheReserveInstancesWithOptions(request: ListCacheReserveInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ListCacheReserveInstancesResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCacheReserveInstances",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListCacheReserveInstancesResponse>(await this.callApi(params, req, runtime), new ListCacheReserveInstancesResponse({}));
  }

  /**
   * Queries the cache reserve instances in your Alibaba Cloud account.
   * 
   * @param request - ListCacheReserveInstancesRequest
   * @returns ListCacheReserveInstancesResponse
   */
  async listCacheReserveInstances(request: ListCacheReserveInstancesRequest): Promise<ListCacheReserveInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCacheReserveInstancesWithOptions(request, runtime);
  }

  /**
   * Queries client certificates configured for a website.
   * 
   * @param request - ListClientCertificatesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListClientCertificatesResponse
   */
  async listClientCertificatesWithOptions(request: ListClientCertificatesRequest, runtime: $Util.RuntimeOptions): Promise<ListClientCertificatesResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListClientCertificates",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListClientCertificatesResponse>(await this.callApi(params, req, runtime), new ListClientCertificatesResponse({}));
  }

  /**
   * Queries client certificates configured for a website.
   * 
   * @param request - ListClientCertificatesRequest
   * @returns ListClientCertificatesResponse
   */
  async listClientCertificates(request: ListClientCertificatesRequest): Promise<ListClientCertificatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClientCertificatesWithOptions(request, runtime);
  }

  /**
   * Lists domain names that are associated with a containerized application.
   * 
   * @param request - ListEdgeContainerAppRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEdgeContainerAppRecordsResponse
   */
  async listEdgeContainerAppRecordsWithOptions(request: ListEdgeContainerAppRecordsRequest, runtime: $Util.RuntimeOptions): Promise<ListEdgeContainerAppRecordsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListEdgeContainerAppRecords",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListEdgeContainerAppRecordsResponse>(await this.callApi(params, req, runtime), new ListEdgeContainerAppRecordsResponse({}));
  }

  /**
   * Lists domain names that are associated with a containerized application.
   * 
   * @param request - ListEdgeContainerAppRecordsRequest
   * @returns ListEdgeContainerAppRecordsResponse
   */
  async listEdgeContainerAppRecords(request: ListEdgeContainerAppRecordsRequest): Promise<ListEdgeContainerAppRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEdgeContainerAppRecordsWithOptions(request, runtime);
  }

  /**
   * Lists versions of all containerized applications.
   * 
   * @param request - ListEdgeContainerAppVersionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEdgeContainerAppVersionsResponse
   */
  async listEdgeContainerAppVersionsWithOptions(request: ListEdgeContainerAppVersionsRequest, runtime: $Util.RuntimeOptions): Promise<ListEdgeContainerAppVersionsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListEdgeContainerAppVersions",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListEdgeContainerAppVersionsResponse>(await this.callApi(params, req, runtime), new ListEdgeContainerAppVersionsResponse({}));
  }

  /**
   * Lists versions of all containerized applications.
   * 
   * @param request - ListEdgeContainerAppVersionsRequest
   * @returns ListEdgeContainerAppVersionsResponse
   */
  async listEdgeContainerAppVersions(request: ListEdgeContainerAppVersionsRequest): Promise<ListEdgeContainerAppVersionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEdgeContainerAppVersionsWithOptions(request, runtime);
  }

  /**
   * Queries all containerized applications in your Alibaba Cloud account.
   * 
   * @param request - ListEdgeContainerAppsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEdgeContainerAppsResponse
   */
  async listEdgeContainerAppsWithOptions(request: ListEdgeContainerAppsRequest, runtime: $Util.RuntimeOptions): Promise<ListEdgeContainerAppsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderKey)) {
      query["OrderKey"] = request.orderKey;
    }

    if (!Util.isUnset(request.orderType)) {
      query["OrderType"] = request.orderType;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchKey)) {
      query["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.searchType)) {
      query["SearchType"] = request.searchType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListEdgeContainerApps",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListEdgeContainerAppsResponse>(await this.callApi(params, req, runtime), new ListEdgeContainerAppsResponse({}));
  }

  /**
   * Queries all containerized applications in your Alibaba Cloud account.
   * 
   * @param request - ListEdgeContainerAppsRequest
   * @returns ListEdgeContainerAppsResponse
   */
  async listEdgeContainerApps(request: ListEdgeContainerAppsRequest): Promise<ListEdgeContainerAppsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEdgeContainerAppsWithOptions(request, runtime);
  }

  /**
   * Queries the records that are associated with Edge Container for a website.
   * 
   * @param request - ListEdgeContainerRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEdgeContainerRecordsResponse
   */
  async listEdgeContainerRecordsWithOptions(request: ListEdgeContainerRecordsRequest, runtime: $Util.RuntimeOptions): Promise<ListEdgeContainerRecordsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListEdgeContainerRecords",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListEdgeContainerRecordsResponse>(await this.callApi(params, req, runtime), new ListEdgeContainerRecordsResponse({}));
  }

  /**
   * Queries the records that are associated with Edge Container for a website.
   * 
   * @param request - ListEdgeContainerRecordsRequest
   * @returns ListEdgeContainerRecordsResponse
   */
  async listEdgeContainerRecords(request: ListEdgeContainerRecordsRequest): Promise<ListEdgeContainerRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEdgeContainerRecordsWithOptions(request, runtime);
  }

  /**
   * Queries Edge Routine plans.
   * 
   * @param request - ListEdgeRoutinePlansRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEdgeRoutinePlansResponse
   */
  async listEdgeRoutinePlansWithOptions(runtime: $Util.RuntimeOptions): Promise<ListEdgeRoutinePlansResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "ListEdgeRoutinePlans",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListEdgeRoutinePlansResponse>(await this.callApi(params, req, runtime), new ListEdgeRoutinePlansResponse({}));
  }

  /**
   * Queries Edge Routine plans.
   * @returns ListEdgeRoutinePlansResponse
   */
  async listEdgeRoutinePlans(): Promise<ListEdgeRoutinePlansResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEdgeRoutinePlansWithOptions(runtime);
  }

  /**
   * Queries the records that are associated with Edge Routine routes for a website.
   * 
   * @remarks
   * >  You can call this operation 100 times per second.
   * 
   * @param request - ListEdgeRoutineRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEdgeRoutineRecordsResponse
   */
  async listEdgeRoutineRecordsWithOptions(request: ListEdgeRoutineRecordsRequest, runtime: $Util.RuntimeOptions): Promise<ListEdgeRoutineRecordsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListEdgeRoutineRecords",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListEdgeRoutineRecordsResponse>(await this.callApi(params, req, runtime), new ListEdgeRoutineRecordsResponse({}));
  }

  /**
   * Queries the records that are associated with Edge Routine routes for a website.
   * 
   * @remarks
   * >  You can call this operation 100 times per second.
   * 
   * @param request - ListEdgeRoutineRecordsRequest
   * @returns ListEdgeRoutineRecordsResponse
   */
  async listEdgeRoutineRecords(request: ListEdgeRoutineRecordsRequest): Promise<ListEdgeRoutineRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEdgeRoutineRecordsWithOptions(request, runtime);
  }

  /**
   * Queries the quota details in a subscription plan.
   * 
   * @param request - ListInstanceQuotasRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListInstanceQuotasResponse
   */
  async listInstanceQuotasWithOptions(request: ListInstanceQuotasRequest, runtime: $Util.RuntimeOptions): Promise<ListInstanceQuotasResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListInstanceQuotas",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListInstanceQuotasResponse>(await this.callApi(params, req, runtime), new ListInstanceQuotasResponse({}));
  }

  /**
   * Queries the quota details in a subscription plan.
   * 
   * @param request - ListInstanceQuotasRequest
   * @returns ListInstanceQuotasResponse
   */
  async listInstanceQuotas(request: ListInstanceQuotasRequest): Promise<ListInstanceQuotasResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listInstanceQuotasWithOptions(request, runtime);
  }

  /**
   * Queries quotas and the actual usage in a plan based on the website or plan ID.
   * 
   * @param request - ListInstanceQuotasWithUsageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListInstanceQuotasWithUsageResponse
   */
  async listInstanceQuotasWithUsageWithOptions(request: ListInstanceQuotasWithUsageRequest, runtime: $Util.RuntimeOptions): Promise<ListInstanceQuotasWithUsageResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListInstanceQuotasWithUsage",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListInstanceQuotasWithUsageResponse>(await this.callApi(params, req, runtime), new ListInstanceQuotasWithUsageResponse({}));
  }

  /**
   * Queries quotas and the actual usage in a plan based on the website or plan ID.
   * 
   * @param request - ListInstanceQuotasWithUsageRequest
   * @returns ListInstanceQuotasWithUsageResponse
   */
  async listInstanceQuotasWithUsage(request: ListInstanceQuotasWithUsageRequest): Promise<ListInstanceQuotasWithUsageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listInstanceQuotasWithUsageWithOptions(request, runtime);
  }

  /**
   * Lists all key-value pairs in a namespace in your Alibaba Cloud account.
   * 
   * @param request - ListKvsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListKvsResponse
   */
  async listKvsWithOptions(request: ListKvsRequest, runtime: $Util.RuntimeOptions): Promise<ListKvsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListKvs",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListKvsResponse>(await this.callApi(params, req, runtime), new ListKvsResponse({}));
  }

  /**
   * Lists all key-value pairs in a namespace in your Alibaba Cloud account.
   * 
   * @param request - ListKvsRequest
   * @returns ListKvsResponse
   */
  async listKvs(request: ListKvsRequest): Promise<ListKvsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listKvsWithOptions(request, runtime);
  }

  /**
   * Queries all custom lists and their details in an Alibaba Cloud account. You can specify query arguments to filter the results and display the returned lists by page.
   * 
   * @param tmpReq - ListListsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListListsResponse
   */
  async listListsWithOptions(tmpReq: ListListsRequest, runtime: $Util.RuntimeOptions): Promise<ListListsResponse> {
    Util.validateModel(tmpReq);
    let request = new ListListsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.queryArgs)) {
      request.queryArgsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queryArgs, "QueryArgs", "json");
    }

    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.queryArgsShrink)) {
      query["QueryArgs"] = request.queryArgsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListLists",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListListsResponse>(await this.callApi(params, req, runtime), new ListListsResponse({}));
  }

  /**
   * Queries all custom lists and their details in an Alibaba Cloud account. You can specify query arguments to filter the results and display the returned lists by page.
   * 
   * @param request - ListListsRequest
   * @returns ListListsResponse
   */
  async listLists(request: ListListsRequest): Promise<ListListsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listListsWithOptions(request, runtime);
  }

  /**
   * Queries the information that can be used to configure a traffic steering policy based on the originating country or region for a load balancer, such as the code and code descriptions of the regions and subregions of the load balancer.
   * 
   * @remarks
   * When you call an operation to create a traffic steering policy based on the originating country or region for a load balancer, you can use the code of a region or subregion to specify traffic that is sent from the region or subregion.
   * 
   * @param request - ListLoadBalancerRegionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListLoadBalancerRegionsResponse
   */
  async listLoadBalancerRegionsWithOptions(request: ListLoadBalancerRegionsRequest, runtime: $Util.RuntimeOptions): Promise<ListLoadBalancerRegionsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListLoadBalancerRegions",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListLoadBalancerRegionsResponse>(await this.callApi(params, req, runtime), new ListLoadBalancerRegionsResponse({}));
  }

  /**
   * Queries the information that can be used to configure a traffic steering policy based on the originating country or region for a load balancer, such as the code and code descriptions of the regions and subregions of the load balancer.
   * 
   * @remarks
   * When you call an operation to create a traffic steering policy based on the originating country or region for a load balancer, you can use the code of a region or subregion to specify traffic that is sent from the region or subregion.
   * 
   * @param request - ListLoadBalancerRegionsRequest
   * @returns ListLoadBalancerRegionsResponse
   */
  async listLoadBalancerRegions(request: ListLoadBalancerRegionsRequest): Promise<ListLoadBalancerRegionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listLoadBalancerRegionsWithOptions(request, runtime);
  }

  /**
   * Queries all WAF managed rule groups in your Alibaba Cloud account.
   * 
   * @param request - ListManagedRulesGroupsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListManagedRulesGroupsResponse
   */
  async listManagedRulesGroupsWithOptions(request: ListManagedRulesGroupsRequest, runtime: $Util.RuntimeOptions): Promise<ListManagedRulesGroupsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListManagedRulesGroups",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListManagedRulesGroupsResponse>(await this.callApi(params, req, runtime), new ListManagedRulesGroupsResponse({}));
  }

  /**
   * Queries all WAF managed rule groups in your Alibaba Cloud account.
   * 
   * @param request - ListManagedRulesGroupsRequest
   * @returns ListManagedRulesGroupsResponse
   */
  async listManagedRulesGroups(request: ListManagedRulesGroupsRequest): Promise<ListManagedRulesGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listManagedRulesGroupsWithOptions(request, runtime);
  }

  /**
   * Lists all custom error pages that you created. You can define the page number and the number of entries per page to display the response.
   * 
   * @param request - ListPagesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPagesResponse
   */
  async listPagesWithOptions(request: ListPagesRequest, runtime: $Util.RuntimeOptions): Promise<ListPagesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPages",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListPagesResponse>(await this.callApi(params, req, runtime), new ListPagesResponse({}));
  }

  /**
   * Lists all custom error pages that you created. You can define the page number and the number of entries per page to display the response.
   * 
   * @param request - ListPagesRequest
   * @returns ListPagesResponse
   */
  async listPages(request: ListPagesRequest): Promise<ListPagesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listPagesWithOptions(request, runtime);
  }

  /**
   * Queries a list of Domain Name System (DNS) records of a website, including the record value, priority, and authentication configurations. Supports filtering by specifying parameters such as RecordName and RecordMatchType.
   * 
   * @remarks
   * The DNS records related to Edge Container, Edge Routine, and TCP/UDP proxy are not returned in this operation.
   * 
   * @param request - ListRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListRecordsResponse
   */
  async listRecordsWithOptions(request: ListRecordsRequest, runtime: $Util.RuntimeOptions): Promise<ListRecordsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRecords",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListRecordsResponse>(await this.callApi(params, req, runtime), new ListRecordsResponse({}));
  }

  /**
   * Queries a list of Domain Name System (DNS) records of a website, including the record value, priority, and authentication configurations. Supports filtering by specifying parameters such as RecordName and RecordMatchType.
   * 
   * @remarks
   * The DNS records related to Edge Container, Edge Routine, and TCP/UDP proxy are not returned in this operation.
   * 
   * @param request - ListRecordsRequest
   * @returns ListRecordsResponse
   */
  async listRecords(request: ListRecordsRequest): Promise<ListRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listRecordsWithOptions(request, runtime);
  }

  /**
   * Lists the regions to which Edge Routine code can be released for canary deployment.
   * 
   * @param request - ListRoutineCanaryAreasRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListRoutineCanaryAreasResponse
   */
  async listRoutineCanaryAreasWithOptions(runtime: $Util.RuntimeOptions): Promise<ListRoutineCanaryAreasResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "ListRoutineCanaryAreas",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListRoutineCanaryAreasResponse>(await this.callApi(params, req, runtime), new ListRoutineCanaryAreasResponse({}));
  }

  /**
   * Lists the regions to which Edge Routine code can be released for canary deployment.
   * @returns ListRoutineCanaryAreasResponse
   */
  async listRoutineCanaryAreas(): Promise<ListRoutineCanaryAreasResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listRoutineCanaryAreasWithOptions(runtime);
  }

  /**
   * Queries the specifications that you can select for a routine based on the plan type. The response contains all specifications that you can select for a routine. The IsAvailable parameter indicates whether a specification is available.
   * 
   * @remarks
   * You can call this operation to query the specifications that you can select for a routine.
   * 
   * @param request - ListRoutineOptionalSpecsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListRoutineOptionalSpecsResponse
   */
  async listRoutineOptionalSpecsWithOptions(runtime: $Util.RuntimeOptions): Promise<ListRoutineOptionalSpecsResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "ListRoutineOptionalSpecs",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListRoutineOptionalSpecsResponse>(await this.callApi(params, req, runtime), new ListRoutineOptionalSpecsResponse({}));
  }

  /**
   * Queries the specifications that you can select for a routine based on the plan type. The response contains all specifications that you can select for a routine. The IsAvailable parameter indicates whether a specification is available.
   * 
   * @remarks
   * You can call this operation to query the specifications that you can select for a routine.
   * @returns ListRoutineOptionalSpecsResponse
   */
  async listRoutineOptionalSpecs(): Promise<ListRoutineOptionalSpecsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listRoutineOptionalSpecsWithOptions(runtime);
  }

  /**
   * Lists the plans in a scheduled prefetch task by task ID.
   * 
   * @param request - ListScheduledPreloadExecutionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListScheduledPreloadExecutionsResponse
   */
  async listScheduledPreloadExecutionsWithOptions(request: ListScheduledPreloadExecutionsRequest, runtime: $Util.RuntimeOptions): Promise<ListScheduledPreloadExecutionsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListScheduledPreloadExecutions",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListScheduledPreloadExecutionsResponse>(await this.callApi(params, req, runtime), new ListScheduledPreloadExecutionsResponse({}));
  }

  /**
   * Lists the plans in a scheduled prefetch task by task ID.
   * 
   * @param request - ListScheduledPreloadExecutionsRequest
   * @returns ListScheduledPreloadExecutionsResponse
   */
  async listScheduledPreloadExecutions(request: ListScheduledPreloadExecutionsRequest): Promise<ListScheduledPreloadExecutionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listScheduledPreloadExecutionsWithOptions(request, runtime);
  }

  /**
   * Queries the scheduled prefetch tasks for a website.
   * 
   * @param request - ListScheduledPreloadJobsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListScheduledPreloadJobsResponse
   */
  async listScheduledPreloadJobsWithOptions(request: ListScheduledPreloadJobsRequest, runtime: $Util.RuntimeOptions): Promise<ListScheduledPreloadJobsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListScheduledPreloadJobs",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListScheduledPreloadJobsResponse>(await this.callApi(params, req, runtime), new ListScheduledPreloadJobsResponse({}));
  }

  /**
   * Queries the scheduled prefetch tasks for a website.
   * 
   * @param request - ListScheduledPreloadJobsRequest
   * @returns ListScheduledPreloadJobsResponse
   */
  async listScheduledPreloadJobs(request: ListScheduledPreloadJobsRequest): Promise<ListScheduledPreloadJobsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listScheduledPreloadJobsWithOptions(request, runtime);
  }

  /**
   * Lists all log delivery tasks that are in progress.
   * 
   * @param request - ListSiteDeliveryTasksRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSiteDeliveryTasksResponse
   */
  async listSiteDeliveryTasksWithOptions(request: ListSiteDeliveryTasksRequest, runtime: $Util.RuntimeOptions): Promise<ListSiteDeliveryTasksResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSiteDeliveryTasks",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSiteDeliveryTasksResponse>(await this.callApi(params, req, runtime), new ListSiteDeliveryTasksResponse({}));
  }

  /**
   * Lists all log delivery tasks that are in progress.
   * 
   * @param request - ListSiteDeliveryTasksRequest
   * @returns ListSiteDeliveryTasksResponse
   */
  async listSiteDeliveryTasks(request: ListSiteDeliveryTasksRequest): Promise<ListSiteDeliveryTasksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSiteDeliveryTasksWithOptions(request, runtime);
  }

  /**
   * 查询站点配置
   * 
   * @param request - ListSiteFunctionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSiteFunctionsResponse
   */
  async listSiteFunctionsWithOptions(request: ListSiteFunctionsRequest, runtime: $Util.RuntimeOptions): Promise<ListSiteFunctionsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSiteFunctions",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSiteFunctionsResponse>(await this.callApi(params, req, runtime), new ListSiteFunctionsResponse({}));
  }

  /**
   * 查询站点配置
   * 
   * @param request - ListSiteFunctionsRequest
   * @returns ListSiteFunctionsResponse
   */
  async listSiteFunctions(request: ListSiteFunctionsRequest): Promise<ListSiteFunctionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSiteFunctionsWithOptions(request, runtime);
  }

  /**
   * Queries the information about websites in your account, such as the name, status, and configuration of each website.
   * 
   * @param tmpReq - ListSitesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSitesResponse
   */
  async listSitesWithOptions(tmpReq: ListSitesRequest, runtime: $Util.RuntimeOptions): Promise<ListSitesResponse> {
    Util.validateModel(tmpReq);
    let request = new ListSitesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.tagFilter)) {
      request.tagFilterShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tagFilter, "TagFilter", "json");
    }

    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSites",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSitesResponse>(await this.callApi(params, req, runtime), new ListSitesResponse({}));
  }

  /**
   * Queries the information about websites in your account, such as the name, status, and configuration of each website.
   * 
   * @param request - ListSitesRequest
   * @returns ListSitesResponse
   */
  async listSites(request: ListSitesRequest): Promise<ListSitesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSitesWithOptions(request, runtime);
  }

  /**
   * Queries tags based on the region ID and resource type.
   * 
   * @param request - ListTagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTagResourcesResponse
   */
  async listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<ListTagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.maxItem)) {
      query["MaxItem"] = request.maxItem;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTagResources",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTagResourcesResponse>(await this.callApi(params, req, runtime), new ListTagResourcesResponse({}));
  }

  /**
   * Queries tags based on the region ID and resource type.
   * 
   * @param request - ListTagResourcesRequest
   * @returns ListTagResourcesResponse
   */
  async listTagResources(request: ListTagResourcesRequest): Promise<ListTagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTagResourcesWithOptions(request, runtime);
  }

  /**
   * Queries the execution status and running information of file upload tasks based on the task time and type.
   * 
   * @param request - ListUploadTasksRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListUploadTasksResponse
   */
  async listUploadTasksWithOptions(request: ListUploadTasksRequest, runtime: $Util.RuntimeOptions): Promise<ListUploadTasksResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListUploadTasks",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListUploadTasksResponse>(await this.callApi(params, req, runtime), new ListUploadTasksResponse({}));
  }

  /**
   * Queries the execution status and running information of file upload tasks based on the task time and type.
   * 
   * @param request - ListUploadTasksRequest
   * @returns ListUploadTasksResponse
   */
  async listUploadTasks(request: ListUploadTasksRequest): Promise<ListUploadTasksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listUploadTasksWithOptions(request, runtime);
  }

  /**
   * Queries all delivery tasks in your Alibaba Cloud account by page. You can filter the delivery tasks by the category of the delivered real-time logs.
   * 
   * @param request - ListUserDeliveryTasksRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListUserDeliveryTasksResponse
   */
  async listUserDeliveryTasksWithOptions(request: ListUserDeliveryTasksRequest, runtime: $Util.RuntimeOptions): Promise<ListUserDeliveryTasksResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListUserDeliveryTasks",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListUserDeliveryTasksResponse>(await this.callApi(params, req, runtime), new ListUserDeliveryTasksResponse({}));
  }

  /**
   * Queries all delivery tasks in your Alibaba Cloud account by page. You can filter the delivery tasks by the category of the delivered real-time logs.
   * 
   * @param request - ListUserDeliveryTasksRequest
   * @returns ListUserDeliveryTasksResponse
   */
  async listUserDeliveryTasks(request: ListUserDeliveryTasksRequest): Promise<ListUserDeliveryTasksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listUserDeliveryTasksWithOptions(request, runtime);
  }

  /**
   * Queries the plans that you purchased and the details of the plans.
   * 
   * @param request - ListUserRatePlanInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListUserRatePlanInstancesResponse
   */
  async listUserRatePlanInstancesWithOptions(request: ListUserRatePlanInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ListUserRatePlanInstancesResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListUserRatePlanInstances",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListUserRatePlanInstancesResponse>(await this.callApi(params, req, runtime), new ListUserRatePlanInstancesResponse({}));
  }

  /**
   * Queries the plans that you purchased and the details of the plans.
   * 
   * @param request - ListUserRatePlanInstancesRequest
   * @returns ListUserRatePlanInstancesResponse
   */
  async listUserRatePlanInstances(request: ListUserRatePlanInstancesRequest): Promise<ListUserRatePlanInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listUserRatePlanInstancesWithOptions(request, runtime);
  }

  /**
   * Lists all Web Application Firewall (WAF) managed rules or some of them based on specific conditions. You can call this operation to query the details of WAF rules by page.
   * 
   * @param tmpReq - ListWafManagedRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWafManagedRulesResponse
   */
  async listWafManagedRulesWithOptions(tmpReq: ListWafManagedRulesRequest, runtime: $Util.RuntimeOptions): Promise<ListWafManagedRulesResponse> {
    Util.validateModel(tmpReq);
    let request = new ListWafManagedRulesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.queryArgs)) {
      request.queryArgsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queryArgs, "QueryArgs", "json");
    }

    let query = { };
    if (!Util.isUnset(request.attackType)) {
      query["AttackType"] = request.attackType;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.language)) {
      query["Language"] = request.language;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.protectionLevel)) {
      query["ProtectionLevel"] = request.protectionLevel;
    }

    if (!Util.isUnset(request.queryArgsShrink)) {
      query["QueryArgs"] = request.queryArgsShrink;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListWafManagedRules",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListWafManagedRulesResponse>(await this.callApi(params, req, runtime), new ListWafManagedRulesResponse({}));
  }

  /**
   * Lists all Web Application Firewall (WAF) managed rules or some of them based on specific conditions. You can call this operation to query the details of WAF rules by page.
   * 
   * @param request - ListWafManagedRulesRequest
   * @returns ListWafManagedRulesResponse
   */
  async listWafManagedRules(request: ListWafManagedRulesRequest): Promise<ListWafManagedRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listWafManagedRulesWithOptions(request, runtime);
  }

  /**
   * Queries the WAF rule categories that are applied to a website and related rulesets.
   * 
   * @param request - ListWafPhasesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWafPhasesResponse
   */
  async listWafPhasesWithOptions(request: ListWafPhasesRequest, runtime: $Util.RuntimeOptions): Promise<ListWafPhasesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListWafPhases",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListWafPhasesResponse>(await this.callApi(params, req, runtime), new ListWafPhasesResponse({}));
  }

  /**
   * Queries the WAF rule categories that are applied to a website and related rulesets.
   * 
   * @param request - ListWafPhasesRequest
   * @returns ListWafPhasesResponse
   */
  async listWafPhases(request: ListWafPhasesRequest): Promise<ListWafPhasesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listWafPhasesWithOptions(request, runtime);
  }

  /**
   * Lists all Web Application Firewall (WAF) rules or some of them based on specific conditions. You can call this operation to query the details of WAF rules by page.
   * 
   * @param tmpReq - ListWafRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWafRulesResponse
   */
  async listWafRulesWithOptions(tmpReq: ListWafRulesRequest, runtime: $Util.RuntimeOptions): Promise<ListWafRulesResponse> {
    Util.validateModel(tmpReq);
    let request = new ListWafRulesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.queryArgs)) {
      request.queryArgsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queryArgs, "QueryArgs", "json");
    }

    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.phase)) {
      query["Phase"] = request.phase;
    }

    if (!Util.isUnset(request.queryArgsShrink)) {
      query["QueryArgs"] = request.queryArgsShrink;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListWafRules",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListWafRulesResponse>(await this.callApi(params, req, runtime), new ListWafRulesResponse({}));
  }

  /**
   * Lists all Web Application Firewall (WAF) rules or some of them based on specific conditions. You can call this operation to query the details of WAF rules by page.
   * 
   * @param request - ListWafRulesRequest
   * @returns ListWafRulesResponse
   */
  async listWafRules(request: ListWafRulesRequest): Promise<ListWafRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listWafRulesWithOptions(request, runtime);
  }

  /**
   * Lists the rulesets in a Web Application Firewall (WAF) rule category. You can call this operation to query the basic information about and status of rulesets by page.
   * 
   * @param tmpReq - ListWafRulesetsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWafRulesetsResponse
   */
  async listWafRulesetsWithOptions(tmpReq: ListWafRulesetsRequest, runtime: $Util.RuntimeOptions): Promise<ListWafRulesetsResponse> {
    Util.validateModel(tmpReq);
    let request = new ListWafRulesetsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.queryArgs)) {
      request.queryArgsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queryArgs, "QueryArgs", "json");
    }

    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.phase)) {
      query["Phase"] = request.phase;
    }

    if (!Util.isUnset(request.queryArgsShrink)) {
      query["QueryArgs"] = request.queryArgsShrink;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListWafRulesets",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListWafRulesetsResponse>(await this.callApi(params, req, runtime), new ListWafRulesetsResponse({}));
  }

  /**
   * Lists the rulesets in a Web Application Firewall (WAF) rule category. You can call this operation to query the basic information about and status of rulesets by page.
   * 
   * @param request - ListWafRulesetsRequest
   * @returns ListWafRulesetsResponse
   */
  async listWafRulesets(request: ListWafRulesetsRequest): Promise<ListWafRulesetsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listWafRulesetsWithOptions(request, runtime);
  }

  /**
   * Queries template rules in Web Application Firewall (WAF). In most cases, these rules are pre-defined rulesets that are used to quickly enable protection against common types of attacks.
   * 
   * @param tmpReq - ListWafTemplateRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWafTemplateRulesResponse
   */
  async listWafTemplateRulesWithOptions(tmpReq: ListWafTemplateRulesRequest, runtime: $Util.RuntimeOptions): Promise<ListWafTemplateRulesResponse> {
    Util.validateModel(tmpReq);
    let request = new ListWafTemplateRulesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.queryArgs)) {
      request.queryArgsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queryArgs, "QueryArgs", "json");
    }

    let query = { };
    if (!Util.isUnset(request.phase)) {
      query["Phase"] = request.phase;
    }

    if (!Util.isUnset(request.queryArgsShrink)) {
      query["QueryArgs"] = request.queryArgsShrink;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListWafTemplateRules",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListWafTemplateRulesResponse>(await this.callApi(params, req, runtime), new ListWafTemplateRulesResponse({}));
  }

  /**
   * Queries template rules in Web Application Firewall (WAF). In most cases, these rules are pre-defined rulesets that are used to quickly enable protection against common types of attacks.
   * 
   * @param request - ListWafTemplateRulesRequest
   * @returns ListWafTemplateRulesResponse
   */
  async listWafTemplateRules(request: ListWafTemplateRulesRequest): Promise<ListWafTemplateRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listWafTemplateRulesWithOptions(request, runtime);
  }

  /**
   * Queries the usage details of WAF rules.
   * 
   * @param request - ListWafUsageOfRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWafUsageOfRulesResponse
   */
  async listWafUsageOfRulesWithOptions(request: ListWafUsageOfRulesRequest, runtime: $Util.RuntimeOptions): Promise<ListWafUsageOfRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.phase)) {
      query["Phase"] = request.phase;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListWafUsageOfRules",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListWafUsageOfRulesResponse>(await this.callApi(params, req, runtime), new ListWafUsageOfRulesResponse({}));
  }

  /**
   * Queries the usage details of WAF rules.
   * 
   * @param request - ListWafUsageOfRulesRequest
   * @returns ListWafUsageOfRulesResponse
   */
  async listWafUsageOfRules(request: ListWafUsageOfRulesRequest): Promise<ListWafUsageOfRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listWafUsageOfRulesWithOptions(request, runtime);
  }

  /**
   * Queries the information about waiting room events for a waiting room.
   * 
   * @remarks
   * You can call this operation to query details of all waiting room events related to a waiting room in a website.
   * 
   * @param request - ListWaitingRoomEventsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWaitingRoomEventsResponse
   */
  async listWaitingRoomEventsWithOptions(request: ListWaitingRoomEventsRequest, runtime: $Util.RuntimeOptions): Promise<ListWaitingRoomEventsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListWaitingRoomEvents",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListWaitingRoomEventsResponse>(await this.callApi(params, req, runtime), new ListWaitingRoomEventsResponse({}));
  }

  /**
   * Queries the information about waiting room events for a waiting room.
   * 
   * @remarks
   * You can call this operation to query details of all waiting room events related to a waiting room in a website.
   * 
   * @param request - ListWaitingRoomEventsRequest
   * @returns ListWaitingRoomEventsResponse
   */
  async listWaitingRoomEvents(request: ListWaitingRoomEventsRequest): Promise<ListWaitingRoomEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listWaitingRoomEventsWithOptions(request, runtime);
  }

  /**
   * Queries the waiting room bypass rules configured for a waiting room.
   * 
   * @remarks
   * You can call this operation to query the waiting room bypass rules that are associated with a website.
   * 
   * @param request - ListWaitingRoomRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWaitingRoomRulesResponse
   */
  async listWaitingRoomRulesWithOptions(request: ListWaitingRoomRulesRequest, runtime: $Util.RuntimeOptions): Promise<ListWaitingRoomRulesResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListWaitingRoomRules",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListWaitingRoomRulesResponse>(await this.callApi(params, req, runtime), new ListWaitingRoomRulesResponse({}));
  }

  /**
   * Queries the waiting room bypass rules configured for a waiting room.
   * 
   * @remarks
   * You can call this operation to query the waiting room bypass rules that are associated with a website.
   * 
   * @param request - ListWaitingRoomRulesRequest
   * @returns ListWaitingRoomRulesResponse
   */
  async listWaitingRoomRules(request: ListWaitingRoomRulesRequest): Promise<ListWaitingRoomRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listWaitingRoomRulesWithOptions(request, runtime);
  }

  /**
   * Queries the information about all waiting rooms in a website.
   * 
   * @remarks
   * You can call this operation to query detailed configurations about all waiting rooms in a website, including the status, name, and queuing rules of each waiting room.
   * 
   * @param request - ListWaitingRoomsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWaitingRoomsResponse
   */
  async listWaitingRoomsWithOptions(request: ListWaitingRoomsRequest, runtime: $Util.RuntimeOptions): Promise<ListWaitingRoomsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListWaitingRooms",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListWaitingRoomsResponse>(await this.callApi(params, req, runtime), new ListWaitingRoomsResponse({}));
  }

  /**
   * Queries the information about all waiting rooms in a website.
   * 
   * @remarks
   * You can call this operation to query detailed configurations about all waiting rooms in a website, including the status, name, and queuing rules of each waiting room.
   * 
   * @param request - ListWaitingRoomsRequest
   * @returns ListWaitingRoomsResponse
   */
  async listWaitingRooms(request: ListWaitingRoomsRequest): Promise<ListWaitingRoomsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listWaitingRoomsWithOptions(request, runtime);
  }

  /**
   * Prefetches cache.
   * 
   * @param tmpReq - PreloadCachesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PreloadCachesResponse
   */
  async preloadCachesWithOptions(tmpReq: PreloadCachesRequest, runtime: $Util.RuntimeOptions): Promise<PreloadCachesResponse> {
    Util.validateModel(tmpReq);
    let request = new PreloadCachesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.content)) {
      request.contentShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.content, "Content", "json");
    }

    if (!Util.isUnset(tmpReq.headers)) {
      request.headersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.headers, "Headers", "json");
    }

    let query = { };
    if (!Util.isUnset(request.contentShrink)) {
      query["Content"] = request.contentShrink;
    }

    if (!Util.isUnset(request.headersShrink)) {
      query["Headers"] = request.headersShrink;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PreloadCaches",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PreloadCachesResponse>(await this.callApi(params, req, runtime), new PreloadCachesResponse({}));
  }

  /**
   * Prefetches cache.
   * 
   * @param request - PreloadCachesRequest
   * @returns PreloadCachesResponse
   */
  async preloadCaches(request: PreloadCachesRequest): Promise<PreloadCachesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.preloadCachesWithOptions(request, runtime);
  }

  /**
   * Releases a specific version of a containerized application. You can call this operation to iterate an application.
   * 
   * @param tmpReq - PublishEdgeContainerAppVersionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PublishEdgeContainerAppVersionResponse
   */
  async publishEdgeContainerAppVersionWithOptions(tmpReq: PublishEdgeContainerAppVersionRequest, runtime: $Util.RuntimeOptions): Promise<PublishEdgeContainerAppVersionResponse> {
    Util.validateModel(tmpReq);
    let request = new PublishEdgeContainerAppVersionShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.regions)) {
      request.regionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.regions, "Regions", "json");
    }

    let query = { };
    if (!Util.isUnset(request.fullRelease)) {
      query["FullRelease"] = request.fullRelease;
    }

    if (!Util.isUnset(request.publishType)) {
      query["PublishType"] = request.publishType;
    }

    if (!Util.isUnset(request.regionsShrink)) {
      query["Regions"] = request.regionsShrink;
    }

    if (!Util.isUnset(request.versionId)) {
      query["VersionId"] = request.versionId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.percentage)) {
      body["Percentage"] = request.percentage;
    }

    if (!Util.isUnset(request.publishEnv)) {
      body["PublishEnv"] = request.publishEnv;
    }

    if (!Util.isUnset(request.remarks)) {
      body["Remarks"] = request.remarks;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "PublishEdgeContainerAppVersion",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PublishEdgeContainerAppVersionResponse>(await this.callApi(params, req, runtime), new PublishEdgeContainerAppVersionResponse({}));
  }

  /**
   * Releases a specific version of a containerized application. You can call this operation to iterate an application.
   * 
   * @param request - PublishEdgeContainerAppVersionRequest
   * @returns PublishEdgeContainerAppVersionResponse
   */
  async publishEdgeContainerAppVersion(request: PublishEdgeContainerAppVersionRequest): Promise<PublishEdgeContainerAppVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.publishEdgeContainerAppVersionWithOptions(request, runtime);
  }

  /**
   * Releases a code version of a routine to the staging, canary, or production environment. You can specify the regions where the canary environment is deployed to release your code.
   * 
   * @param tmpReq - PublishRoutineCodeVersionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PublishRoutineCodeVersionResponse
   */
  async publishRoutineCodeVersionWithOptions(tmpReq: PublishRoutineCodeVersionRequest, runtime: $Util.RuntimeOptions): Promise<PublishRoutineCodeVersionResponse> {
    Util.validateModel(tmpReq);
    let request = new PublishRoutineCodeVersionShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.canaryAreaList)) {
      request.canaryAreaListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.canaryAreaList, "CanaryAreaList", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.canaryAreaListShrink)) {
      body["CanaryAreaList"] = request.canaryAreaListShrink;
    }

    if (!Util.isUnset(request.canaryCodeVersion)) {
      body["CanaryCodeVersion"] = request.canaryCodeVersion;
    }

    if (!Util.isUnset(request.codeVersion)) {
      body["CodeVersion"] = request.codeVersion;
    }

    if (!Util.isUnset(request.env)) {
      body["Env"] = request.env;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "PublishRoutineCodeVersion",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PublishRoutineCodeVersionResponse>(await this.callApi(params, req, runtime), new PublishRoutineCodeVersionResponse({}));
  }

  /**
   * Releases a code version of a routine to the staging, canary, or production environment. You can specify the regions where the canary environment is deployed to release your code.
   * 
   * @param request - PublishRoutineCodeVersionRequest
   * @returns PublishRoutineCodeVersionResponse
   */
  async publishRoutineCodeVersion(request: PublishRoutineCodeVersionRequest): Promise<PublishRoutineCodeVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.publishRoutineCodeVersionWithOptions(request, runtime);
  }

  /**
   * Purges resources cached on points of presence (POPs). You can purge the cache by file URL, directory, cache tag, hostname, or URL with specified parameters ignored, or purge all the cache.
   * 
   * @param tmpReq - PurgeCachesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PurgeCachesResponse
   */
  async purgeCachesWithOptions(tmpReq: PurgeCachesRequest, runtime: $Util.RuntimeOptions): Promise<PurgeCachesResponse> {
    Util.validateModel(tmpReq);
    let request = new PurgeCachesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.content)) {
      request.contentShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.content, "Content", "json");
    }

    let query = { };
    if (!Util.isUnset(request.contentShrink)) {
      query["Content"] = request.contentShrink;
    }

    if (!Util.isUnset(request.edgeComputePurge)) {
      query["EdgeComputePurge"] = request.edgeComputePurge;
    }

    if (!Util.isUnset(request.force)) {
      query["Force"] = request.force;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PurgeCaches",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PurgeCachesResponse>(await this.callApi(params, req, runtime), new PurgeCachesResponse({}));
  }

  /**
   * Purges resources cached on points of presence (POPs). You can purge the cache by file URL, directory, cache tag, hostname, or URL with specified parameters ignored, or purge all the cache.
   * 
   * @param request - PurgeCachesRequest
   * @returns PurgeCachesResponse
   */
  async purgeCaches(request: PurgeCachesRequest): Promise<PurgeCachesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.purgeCachesWithOptions(request, runtime);
  }

  /**
   * Configures a key-value pair for a namespace. The request body can be up to 2 MB.
   * 
   * @param request - PutKvRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutKvResponse
   */
  async putKvWithOptions(request: PutKvRequest, runtime: $Util.RuntimeOptions): Promise<PutKvResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.base64)) {
      query["Base64"] = request.base64;
    }

    if (!Util.isUnset(request.expiration)) {
      query["Expiration"] = request.expiration;
    }

    if (!Util.isUnset(request.expirationTtl)) {
      query["ExpirationTtl"] = request.expirationTtl;
    }

    if (!Util.isUnset(request.key)) {
      query["Key"] = request.key;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.value)) {
      body["Value"] = request.value;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "PutKv",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutKvResponse>(await this.callApi(params, req, runtime), new PutKvResponse({}));
  }

  /**
   * Configures a key-value pair for a namespace. The request body can be up to 2 MB.
   * 
   * @param request - PutKvRequest
   * @returns PutKvResponse
   */
  async putKv(request: PutKvRequest): Promise<PutKvResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putKvWithOptions(request, runtime);
  }

  /**
   * Configures a large key-value pair for a namespace. The request body can be up to 25 MB.
   * 
   * @remarks
   * This operation allows you to upload a larger request body than by using [PutKv](~~PutKv~~). For small request bodies, we recommend that you use [PutKv](~~PutKv~~) to minimize the server processing time. This operation must be called by using SDKs. The following sample code uses the Golang SDK and PutKvWithHighCapacityAdvance to call the operation.
   *     func TestPutKvWithHighCapacity() {
   *     	// Initialize the configurations.
   *     	cfg := new(openapi.Config)
   *     	cfg.SetAccessKeyId("xxxxxxxxx")
   *     	cfg.SetAccessKeySecret("xxxxxxxxxx")
   *     	cli, err := NewClient(cfg)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	runtime := &util.RuntimeOptions{}
   *     	// Construct a request for uploading key-value pairs.
   *     	namespace := "test-put-kv"
   *     	key := "test_PutKvWithHighCapacity_0"
   *     	value := strings.Repeat("t", 10*1024*1024)
   *     	rawReq := &PutKvRequest{
   *     		Namespace: &namespace,
   *     		Key:       &key,
   *     		Value:     &value,
   *     	}
   *     	payload, err := json.Marshal(rawReq)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	// If the payload is greater than 2 MB, call the PutKvWithHighCapacity operation for upload.
   *     	reqHighCapacity := &PutKvWithHighCapacityAdvanceRequest{
   *     		Namespace: &namespace,
   *     		Key:       &key,
   *     		UrlObject: bytes.NewReader([]byte(payload)),
   *     	}
   *     	resp, err := cli.PutKvWithHighCapacityAdvance(reqHighCapacity, runtime)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	return nil
   *     }
   * 
   * @param request - PutKvWithHighCapacityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutKvWithHighCapacityResponse
   */
  async putKvWithHighCapacityWithOptions(request: PutKvWithHighCapacityRequest, runtime: $Util.RuntimeOptions): Promise<PutKvWithHighCapacityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.key)) {
      query["Key"] = request.key;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.url)) {
      query["Url"] = request.url;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutKvWithHighCapacity",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutKvWithHighCapacityResponse>(await this.callApi(params, req, runtime), new PutKvWithHighCapacityResponse({}));
  }

  /**
   * Configures a large key-value pair for a namespace. The request body can be up to 25 MB.
   * 
   * @remarks
   * This operation allows you to upload a larger request body than by using [PutKv](~~PutKv~~). For small request bodies, we recommend that you use [PutKv](~~PutKv~~) to minimize the server processing time. This operation must be called by using SDKs. The following sample code uses the Golang SDK and PutKvWithHighCapacityAdvance to call the operation.
   *     func TestPutKvWithHighCapacity() {
   *     	// Initialize the configurations.
   *     	cfg := new(openapi.Config)
   *     	cfg.SetAccessKeyId("xxxxxxxxx")
   *     	cfg.SetAccessKeySecret("xxxxxxxxxx")
   *     	cli, err := NewClient(cfg)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	runtime := &util.RuntimeOptions{}
   *     	// Construct a request for uploading key-value pairs.
   *     	namespace := "test-put-kv"
   *     	key := "test_PutKvWithHighCapacity_0"
   *     	value := strings.Repeat("t", 10*1024*1024)
   *     	rawReq := &PutKvRequest{
   *     		Namespace: &namespace,
   *     		Key:       &key,
   *     		Value:     &value,
   *     	}
   *     	payload, err := json.Marshal(rawReq)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	// If the payload is greater than 2 MB, call the PutKvWithHighCapacity operation for upload.
   *     	reqHighCapacity := &PutKvWithHighCapacityAdvanceRequest{
   *     		Namespace: &namespace,
   *     		Key:       &key,
   *     		UrlObject: bytes.NewReader([]byte(payload)),
   *     	}
   *     	resp, err := cli.PutKvWithHighCapacityAdvance(reqHighCapacity, runtime)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	return nil
   *     }
   * 
   * @param request - PutKvWithHighCapacityRequest
   * @returns PutKvWithHighCapacityResponse
   */
  async putKvWithHighCapacity(request: PutKvWithHighCapacityRequest): Promise<PutKvWithHighCapacityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putKvWithHighCapacityWithOptions(request, runtime);
  }

  async putKvWithHighCapacityAdvance(request: PutKvWithHighCapacityAdvanceRequest, runtime: $Util.RuntimeOptions): Promise<PutKvWithHighCapacityResponse> {
    // Step 0: init client
    let accessKeyId = await this._credential.getAccessKeyId();
    let accessKeySecret = await this._credential.getAccessKeySecret();
    let securityToken = await this._credential.getSecurityToken();
    let credentialType = this._credential.getType();
    let openPlatformEndpoint = this._openPlatformEndpoint;
    if (Util.empty(openPlatformEndpoint)) {
      openPlatformEndpoint = "openplatform.aliyuncs.com";
    }

    if (Util.isUnset(credentialType)) {
      credentialType = "access_key";
    }

    let authConfig = new $OpenApi.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      securityToken: securityToken,
      type: credentialType,
      endpoint: openPlatformEndpoint,
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let authClient = new OpenPlatform(authConfig);
    let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
      product: "ESA",
      regionId: this._regionId,
    });
    let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({ });
    let ossConfig = new $OSS.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      type: "access_key",
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let ossClient : OSS = new OSS(ossConfig);
    let fileObj = new $FileForm.FileField({ });
    let ossHeader = new $OSS.PostObjectRequestHeader({ });
    let uploadRequest = new $OSS.PostObjectRequest({ });
    let ossRuntime = new $OSSUtil.RuntimeOptions({ });
    OpenApiUtil.convert(runtime, ossRuntime);
    let putKvWithHighCapacityReq = new PutKvWithHighCapacityRequest({ });
    OpenApiUtil.convert(request, putKvWithHighCapacityReq);
    if (!Util.isUnset(request.urlObject)) {
      authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
      ossConfig.accessKeyId = authResponse.body.accessKeyId;
      ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
      ossClient = new OSS(ossConfig);
      fileObj = new $FileForm.FileField({
        filename: authResponse.body.objectKey,
        content: request.urlObject,
        contentType: "",
      });
      ossHeader = new $OSS.PostObjectRequestHeader({
        accessKeyId: authResponse.body.accessKeyId,
        policy: authResponse.body.encodedPolicy,
        signature: authResponse.body.signature,
        key: authResponse.body.objectKey,
        file: fileObj,
        successActionStatus: "201",
      });
      uploadRequest = new $OSS.PostObjectRequest({
        bucketName: authResponse.body.bucket,
        header: ossHeader,
      });
      await ossClient.postObject(uploadRequest, ossRuntime);
      putKvWithHighCapacityReq.url = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
    }

    let putKvWithHighCapacityResp = await this.putKvWithHighCapacityWithOptions(putKvWithHighCapacityReq, runtime);
    return putKvWithHighCapacityResp;
  }

  /**
   * Rebuilds the staging environment for containerized applications.
   * 
   * @param request - RebuildEdgeContainerAppStagingEnvRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RebuildEdgeContainerAppStagingEnvResponse
   */
  async rebuildEdgeContainerAppStagingEnvWithOptions(request: RebuildEdgeContainerAppStagingEnvRequest, runtime: $Util.RuntimeOptions): Promise<RebuildEdgeContainerAppStagingEnvResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RebuildEdgeContainerAppStagingEnv",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RebuildEdgeContainerAppStagingEnvResponse>(await this.callApi(params, req, runtime), new RebuildEdgeContainerAppStagingEnvResponse({}));
  }

  /**
   * Rebuilds the staging environment for containerized applications.
   * 
   * @param request - RebuildEdgeContainerAppStagingEnvRequest
   * @returns RebuildEdgeContainerAppStagingEnvResponse
   */
  async rebuildEdgeContainerAppStagingEnv(request: RebuildEdgeContainerAppStagingEnvRequest): Promise<RebuildEdgeContainerAppStagingEnvResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.rebuildEdgeContainerAppStagingEnvWithOptions(request, runtime);
  }

  /**
   * Resets the progress of a scheduled prefetch task and starts the prefetch from the beginning.
   * 
   * @param request - ResetScheduledPreloadJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ResetScheduledPreloadJobResponse
   */
  async resetScheduledPreloadJobWithOptions(request: ResetScheduledPreloadJobRequest, runtime: $Util.RuntimeOptions): Promise<ResetScheduledPreloadJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ResetScheduledPreloadJob",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ResetScheduledPreloadJobResponse>(await this.callApi(params, req, runtime), new ResetScheduledPreloadJobResponse({}));
  }

  /**
   * Resets the progress of a scheduled prefetch task and starts the prefetch from the beginning.
   * 
   * @param request - ResetScheduledPreloadJobRequest
   * @returns ResetScheduledPreloadJobResponse
   */
  async resetScheduledPreloadJob(request: ResetScheduledPreloadJobRequest): Promise<ResetScheduledPreloadJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resetScheduledPreloadJobWithOptions(request, runtime);
  }

  /**
   * Rolls back a version of a containerized application.
   * 
   * @param request - RollbackEdgeContainerAppVersionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RollbackEdgeContainerAppVersionResponse
   */
  async rollbackEdgeContainerAppVersionWithOptions(request: RollbackEdgeContainerAppVersionRequest, runtime: $Util.RuntimeOptions): Promise<RollbackEdgeContainerAppVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.versionId)) {
      query["VersionId"] = request.versionId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.remarks)) {
      body["Remarks"] = request.remarks;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "RollbackEdgeContainerAppVersion",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RollbackEdgeContainerAppVersionResponse>(await this.callApi(params, req, runtime), new RollbackEdgeContainerAppVersionResponse({}));
  }

  /**
   * Rolls back a version of a containerized application.
   * 
   * @param request - RollbackEdgeContainerAppVersionRequest
   * @returns RollbackEdgeContainerAppVersionResponse
   */
  async rollbackEdgeContainerAppVersion(request: RollbackEdgeContainerAppVersionRequest): Promise<RollbackEdgeContainerAppVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.rollbackEdgeContainerAppVersionWithOptions(request, runtime);
  }

  /**
   * Configures whether to enable certificates and update certificate information for a website.
   * 
   * @param request - SetCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetCertificateResponse
   */
  async setCertificateWithOptions(request: SetCertificateRequest, runtime: $Util.RuntimeOptions): Promise<SetCertificateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.casId)) {
      body["CasId"] = request.casId;
    }

    if (!Util.isUnset(request.certificate)) {
      body["Certificate"] = request.certificate;
    }

    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.privateKey)) {
      body["PrivateKey"] = request.privateKey;
    }

    if (!Util.isUnset(request.region)) {
      body["Region"] = request.region;
    }

    if (!Util.isUnset(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.type)) {
      body["Type"] = request.type;
    }

    if (!Util.isUnset(request.update)) {
      body["Update"] = request.update;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SetCertificate",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetCertificateResponse>(await this.callApi(params, req, runtime), new SetCertificateResponse({}));
  }

  /**
   * Configures whether to enable certificates and update certificate information for a website.
   * 
   * @param request - SetCertificateRequest
   * @returns SetCertificateResponse
   */
  async setCertificate(request: SetCertificateRequest): Promise<SetCertificateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setCertificateWithOptions(request, runtime);
  }

  /**
   * Configures smart HTTP DDoS protection.
   * 
   * @param request - SetHttpDDoSAttackIntelligentProtectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetHttpDDoSAttackIntelligentProtectionResponse
   */
  async setHttpDDoSAttackIntelligentProtectionWithOptions(request: SetHttpDDoSAttackIntelligentProtectionRequest, runtime: $Util.RuntimeOptions): Promise<SetHttpDDoSAttackIntelligentProtectionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aiMode)) {
      query["AiMode"] = request.aiMode;
    }

    if (!Util.isUnset(request.aiTemplate)) {
      query["AiTemplate"] = request.aiTemplate;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetHttpDDoSAttackIntelligentProtection",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetHttpDDoSAttackIntelligentProtectionResponse>(await this.callApi(params, req, runtime), new SetHttpDDoSAttackIntelligentProtectionResponse({}));
  }

  /**
   * Configures smart HTTP DDoS protection.
   * 
   * @param request - SetHttpDDoSAttackIntelligentProtectionRequest
   * @returns SetHttpDDoSAttackIntelligentProtectionResponse
   */
  async setHttpDDoSAttackIntelligentProtection(request: SetHttpDDoSAttackIntelligentProtectionRequest): Promise<SetHttpDDoSAttackIntelligentProtectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setHttpDDoSAttackIntelligentProtectionWithOptions(request, runtime);
  }

  /**
   * Configures HTTP DDoS attack protection for a website.
   * 
   * @param request - SetHttpDDoSAttackProtectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetHttpDDoSAttackProtectionResponse
   */
  async setHttpDDoSAttackProtectionWithOptions(request: SetHttpDDoSAttackProtectionRequest, runtime: $Util.RuntimeOptions): Promise<SetHttpDDoSAttackProtectionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.globalMode)) {
      query["GlobalMode"] = request.globalMode;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetHttpDDoSAttackProtection",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetHttpDDoSAttackProtectionResponse>(await this.callApi(params, req, runtime), new SetHttpDDoSAttackProtectionResponse({}));
  }

  /**
   * Configures HTTP DDoS attack protection for a website.
   * 
   * @param request - SetHttpDDoSAttackProtectionRequest
   * @returns SetHttpDDoSAttackProtectionResponse
   */
  async setHttpDDoSAttackProtection(request: SetHttpDDoSAttackProtectionRequest): Promise<SetHttpDDoSAttackProtectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setHttpDDoSAttackProtectionWithOptions(request, runtime);
  }

  /**
   * Starts a scheduled prefetch plan based on the plan ID.
   * 
   * @param request - StartScheduledPreloadExecutionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StartScheduledPreloadExecutionResponse
   */
  async startScheduledPreloadExecutionWithOptions(request: StartScheduledPreloadExecutionRequest, runtime: $Util.RuntimeOptions): Promise<StartScheduledPreloadExecutionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StartScheduledPreloadExecution",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartScheduledPreloadExecutionResponse>(await this.callApi(params, req, runtime), new StartScheduledPreloadExecutionResponse({}));
  }

  /**
   * Starts a scheduled prefetch plan based on the plan ID.
   * 
   * @param request - StartScheduledPreloadExecutionRequest
   * @returns StartScheduledPreloadExecutionResponse
   */
  async startScheduledPreloadExecution(request: StartScheduledPreloadExecutionRequest): Promise<StartScheduledPreloadExecutionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startScheduledPreloadExecutionWithOptions(request, runtime);
  }

  /**
   * Stops a scheduled prefetch plan based on the plan ID.
   * 
   * @param request - StopScheduledPreloadExecutionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StopScheduledPreloadExecutionResponse
   */
  async stopScheduledPreloadExecutionWithOptions(request: StopScheduledPreloadExecutionRequest, runtime: $Util.RuntimeOptions): Promise<StopScheduledPreloadExecutionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StopScheduledPreloadExecution",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StopScheduledPreloadExecutionResponse>(await this.callApi(params, req, runtime), new StopScheduledPreloadExecutionResponse({}));
  }

  /**
   * Stops a scheduled prefetch plan based on the plan ID.
   * 
   * @param request - StopScheduledPreloadExecutionRequest
   * @returns StopScheduledPreloadExecutionResponse
   */
  async stopScheduledPreloadExecution(request: StopScheduledPreloadExecutionRequest): Promise<StopScheduledPreloadExecutionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopScheduledPreloadExecutionWithOptions(request, runtime);
  }

  /**
   * Deletes a resource tag based on a specified resource ID.
   * 
   * @param request - UntagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UntagResourcesResponse
   */
  async untagResourcesWithOptions(request: UntagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<UntagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.all)) {
      query["All"] = request.all;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tagKey)) {
      query["TagKey"] = request.tagKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UntagResources",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UntagResourcesResponse>(await this.callApi(params, req, runtime), new UntagResourcesResponse({}));
  }

  /**
   * Deletes a resource tag based on a specified resource ID.
   * 
   * @param request - UntagResourcesRequest
   * @returns UntagResourcesResponse
   */
  async untagResources(request: UntagResourcesRequest): Promise<UntagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.untagResourcesWithOptions(request, runtime);
  }

  /**
   * Modifies the configurations of a custom scenario-specific policy.
   * 
   * @param request - UpdateCustomScenePolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCustomScenePolicyResponse
   */
  async updateCustomScenePolicyWithOptions(request: UpdateCustomScenePolicyRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCustomScenePolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.objects)) {
      query["Objects"] = request.objects;
    }

    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.template)) {
      query["Template"] = request.template;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCustomScenePolicy",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCustomScenePolicyResponse>(await this.callApi(params, req, runtime), new UpdateCustomScenePolicyResponse({}));
  }

  /**
   * Modifies the configurations of a custom scenario-specific policy.
   * 
   * @param request - UpdateCustomScenePolicyRequest
   * @returns UpdateCustomScenePolicyResponse
   */
  async updateCustomScenePolicy(request: UpdateCustomScenePolicyRequest): Promise<UpdateCustomScenePolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCustomScenePolicyWithOptions(request, runtime);
  }

  /**
   * Updates the name of a namespace in Edge KV.
   * 
   * @param request - UpdateKvNamespaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateKvNamespaceResponse
   */
  async updateKvNamespaceWithOptions(request: UpdateKvNamespaceRequest, runtime: $Util.RuntimeOptions): Promise<UpdateKvNamespaceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.title)) {
      query["Title"] = request.title;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateKvNamespace",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateKvNamespaceResponse>(await this.callApi(params, req, runtime), new UpdateKvNamespaceResponse({}));
  }

  /**
   * Updates the name of a namespace in Edge KV.
   * 
   * @param request - UpdateKvNamespaceRequest
   * @returns UpdateKvNamespaceResponse
   */
  async updateKvNamespace(request: UpdateKvNamespaceRequest): Promise<UpdateKvNamespaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateKvNamespaceWithOptions(request, runtime);
  }

  /**
   * Updates a custom list.
   * 
   * @param tmpReq - UpdateListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateListResponse
   */
  async updateListWithOptions(tmpReq: UpdateListRequest, runtime: $Util.RuntimeOptions): Promise<UpdateListResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateListShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.items)) {
      request.itemsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.items, "Items", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    if (!Util.isUnset(request.itemsShrink)) {
      body["Items"] = request.itemsShrink;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateList",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateListResponse>(await this.callApi(params, req, runtime), new UpdateListResponse({}));
  }

  /**
   * Updates a custom list.
   * 
   * @param request - UpdateListRequest
   * @returns UpdateListResponse
   */
  async updateList(request: UpdateListRequest): Promise<UpdateListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateListWithOptions(request, runtime);
  }

  /**
   * 修改源站防护
   * 
   * @param request - UpdateOriginProtectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateOriginProtectionResponse
   */
  async updateOriginProtectionWithOptions(request: UpdateOriginProtectionRequest, runtime: $Util.RuntimeOptions): Promise<UpdateOriginProtectionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.originConverge)) {
      query["OriginConverge"] = request.originConverge;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateOriginProtection",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateOriginProtectionResponse>(await this.callApi(params, req, runtime), new UpdateOriginProtectionResponse({}));
  }

  /**
   * 修改源站防护
   * 
   * @param request - UpdateOriginProtectionRequest
   * @returns UpdateOriginProtectionResponse
   */
  async updateOriginProtection(request: UpdateOriginProtectionRequest): Promise<UpdateOriginProtectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateOriginProtectionWithOptions(request, runtime);
  }

  /**
   * 确认更新站点回源IP白名单到最新版本
   * 
   * @param request - UpdateOriginProtectionIpWhiteListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateOriginProtectionIpWhiteListResponse
   */
  async updateOriginProtectionIpWhiteListWithOptions(request: UpdateOriginProtectionIpWhiteListRequest, runtime: $Util.RuntimeOptions): Promise<UpdateOriginProtectionIpWhiteListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateOriginProtectionIpWhiteList",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateOriginProtectionIpWhiteListResponse>(await this.callApi(params, req, runtime), new UpdateOriginProtectionIpWhiteListResponse({}));
  }

  /**
   * 确认更新站点回源IP白名单到最新版本
   * 
   * @param request - UpdateOriginProtectionIpWhiteListRequest
   * @returns UpdateOriginProtectionIpWhiteListResponse
   */
  async updateOriginProtectionIpWhiteList(request: UpdateOriginProtectionIpWhiteListRequest): Promise<UpdateOriginProtectionIpWhiteListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateOriginProtectionIpWhiteListWithOptions(request, runtime);
  }

  /**
   * Modifies the configurations of a custom error page, such as the name, description, content type, and content of the page.
   * 
   * @param request - UpdatePageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdatePageResponse
   */
  async updatePageWithOptions(request: UpdatePageRequest, runtime: $Util.RuntimeOptions): Promise<UpdatePageResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.content)) {
      body["Content"] = request.content;
    }

    if (!Util.isUnset(request.contentType)) {
      body["ContentType"] = request.contentType;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdatePage",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdatePageResponse>(await this.callApi(params, req, runtime), new UpdatePageResponse({}));
  }

  /**
   * Modifies the configurations of a custom error page, such as the name, description, content type, and content of the page.
   * 
   * @param request - UpdatePageRequest
   * @returns UpdatePageResponse
   */
  async updatePage(request: UpdatePageRequest): Promise<UpdatePageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updatePageWithOptions(request, runtime);
  }

  /**
   * Updates multiple types of DNS records and origin authentication configurations.
   * 
   * @remarks
   * This operation allows you to update multiple types of DNS records, including but not limited to A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI. You can modify the record content by providing the necessary fields such as Value, Priority, and Flag. For origins added in CNAME records such as OSS and S3, the API enables you to configure authentication details to ensure secure access.
   * ### [](#)Usage notes
   * *   The record value (Value) must match the record type. For example, the CNAME record should correspond to the target domain name.
   * *   You must specify a priority (Priority) for some record types, such as MX and SRV.
   * *   You must specify specific fields such as Flag and Tag for CAA records.
   * *   When you update security records such as CERT and SSHFP, you must accurately set fields such as Type and Algorithm.
   * *   If your origin type is OSS or S3, configure the authentication details in AuthConf based on the permissions.
   * 
   * @param tmpReq - UpdateRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateRecordResponse
   */
  async updateRecordWithOptions(tmpReq: UpdateRecordRequest, runtime: $Util.RuntimeOptions): Promise<UpdateRecordResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateRecordShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.authConf)) {
      request.authConfShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.authConf, "AuthConf", "json");
    }

    if (!Util.isUnset(tmpReq.data)) {
      request.dataShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.data, "Data", "json");
    }

    let query = { };
    if (!Util.isUnset(request.authConfShrink)) {
      query["AuthConf"] = request.authConfShrink;
    }

    if (!Util.isUnset(request.bizName)) {
      query["BizName"] = request.bizName;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.dataShrink)) {
      query["Data"] = request.dataShrink;
    }

    if (!Util.isUnset(request.hostPolicy)) {
      query["HostPolicy"] = request.hostPolicy;
    }

    if (!Util.isUnset(request.proxied)) {
      query["Proxied"] = request.proxied;
    }

    if (!Util.isUnset(request.recordId)) {
      query["RecordId"] = request.recordId;
    }

    if (!Util.isUnset(request.sourceType)) {
      query["SourceType"] = request.sourceType;
    }

    if (!Util.isUnset(request.ttl)) {
      query["Ttl"] = request.ttl;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateRecord",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateRecordResponse>(await this.callApi(params, req, runtime), new UpdateRecordResponse({}));
  }

  /**
   * Updates multiple types of DNS records and origin authentication configurations.
   * 
   * @remarks
   * This operation allows you to update multiple types of DNS records, including but not limited to A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI. You can modify the record content by providing the necessary fields such as Value, Priority, and Flag. For origins added in CNAME records such as OSS and S3, the API enables you to configure authentication details to ensure secure access.
   * ### [](#)Usage notes
   * *   The record value (Value) must match the record type. For example, the CNAME record should correspond to the target domain name.
   * *   You must specify a priority (Priority) for some record types, such as MX and SRV.
   * *   You must specify specific fields such as Flag and Tag for CAA records.
   * *   When you update security records such as CERT and SSHFP, you must accurately set fields such as Type and Algorithm.
   * *   If your origin type is OSS or S3, configure the authentication details in AuthConf based on the permissions.
   * 
   * @param request - UpdateRecordRequest
   * @returns UpdateRecordResponse
   */
  async updateRecord(request: UpdateRecordRequest): Promise<UpdateRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateRecordWithOptions(request, runtime);
  }

  /**
   * Updates a scheduled prefetch plan based on the plan ID.
   * 
   * @param request - UpdateScheduledPreloadExecutionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateScheduledPreloadExecutionResponse
   */
  async updateScheduledPreloadExecutionWithOptions(request: UpdateScheduledPreloadExecutionRequest, runtime: $Util.RuntimeOptions): Promise<UpdateScheduledPreloadExecutionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      body["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.sliceLen)) {
      body["SliceLen"] = request.sliceLen;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateScheduledPreloadExecution",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateScheduledPreloadExecutionResponse>(await this.callApi(params, req, runtime), new UpdateScheduledPreloadExecutionResponse({}));
  }

  /**
   * Updates a scheduled prefetch plan based on the plan ID.
   * 
   * @param request - UpdateScheduledPreloadExecutionRequest
   * @returns UpdateScheduledPreloadExecutionResponse
   */
  async updateScheduledPreloadExecution(request: UpdateScheduledPreloadExecutionRequest): Promise<UpdateScheduledPreloadExecutionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateScheduledPreloadExecutionWithOptions(request, runtime);
  }

  /**
   * Converts the DNS setup option of a website.
   * 
   * @remarks
   * When you change the DNS setup of a website from NS to CNAME, take note of the following items:
   * *   Make sure that the website has only proxied A/AAAA and CNAME records.
   * *   Make sure that ESA proxy is not disabled for the website and custom nameservers are not configured.
   * 
   * @param request - UpdateSiteAccessTypeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateSiteAccessTypeResponse
   */
  async updateSiteAccessTypeWithOptions(request: UpdateSiteAccessTypeRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSiteAccessTypeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.accessType)) {
      query["AccessType"] = request.accessType;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSiteAccessType",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSiteAccessTypeResponse>(await this.callApi(params, req, runtime), new UpdateSiteAccessTypeResponse({}));
  }

  /**
   * Converts the DNS setup option of a website.
   * 
   * @remarks
   * When you change the DNS setup of a website from NS to CNAME, take note of the following items:
   * *   Make sure that the website has only proxied A/AAAA and CNAME records.
   * *   Make sure that ESA proxy is not disabled for the website and custom nameservers are not configured.
   * 
   * @param request - UpdateSiteAccessTypeRequest
   * @returns UpdateSiteAccessTypeResponse
   */
  async updateSiteAccessType(request: UpdateSiteAccessTypeRequest): Promise<UpdateSiteAccessTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSiteAccessTypeWithOptions(request, runtime);
  }

  /**
   * Modifies the service location for a single website. This updates the acceleration configuration of the website to adapt to changes in traffic distribution, and improve user experience in specific regions.
   * 
   * @param request - UpdateSiteCoverageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateSiteCoverageResponse
   */
  async updateSiteCoverageWithOptions(request: UpdateSiteCoverageRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSiteCoverageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.coverage)) {
      query["Coverage"] = request.coverage;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSiteCoverage",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSiteCoverageResponse>(await this.callApi(params, req, runtime), new UpdateSiteCoverageResponse({}));
  }

  /**
   * Modifies the service location for a single website. This updates the acceleration configuration of the website to adapt to changes in traffic distribution, and improve user experience in specific regions.
   * 
   * @param request - UpdateSiteCoverageRequest
   * @returns UpdateSiteCoverageResponse
   */
  async updateSiteCoverage(request: UpdateSiteCoverageRequest): Promise<UpdateSiteCoverageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSiteCoverageWithOptions(request, runtime);
  }

  /**
   * Modifies the configuration of custom request header, response header, and cookie fields that are used to capture logs of a website.
   * 
   * @param tmpReq - UpdateSiteCustomLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateSiteCustomLogResponse
   */
  async updateSiteCustomLogWithOptions(tmpReq: UpdateSiteCustomLogRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSiteCustomLogResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateSiteCustomLogShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.cookies)) {
      request.cookiesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.cookies, "Cookies", "json");
    }

    if (!Util.isUnset(tmpReq.requestHeaders)) {
      request.requestHeadersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.requestHeaders, "RequestHeaders", "json");
    }

    if (!Util.isUnset(tmpReq.responseHeaders)) {
      request.responseHeadersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.responseHeaders, "ResponseHeaders", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.cookiesShrink)) {
      body["Cookies"] = request.cookiesShrink;
    }

    if (!Util.isUnset(request.requestHeadersShrink)) {
      body["RequestHeaders"] = request.requestHeadersShrink;
    }

    if (!Util.isUnset(request.responseHeadersShrink)) {
      body["ResponseHeaders"] = request.responseHeadersShrink;
    }

    if (!Util.isUnset(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSiteCustomLog",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSiteCustomLogResponse>(await this.callApi(params, req, runtime), new UpdateSiteCustomLogResponse({}));
  }

  /**
   * Modifies the configuration of custom request header, response header, and cookie fields that are used to capture logs of a website.
   * 
   * @param request - UpdateSiteCustomLogRequest
   * @returns UpdateSiteCustomLogResponse
   */
  async updateSiteCustomLog(request: UpdateSiteCustomLogRequest): Promise<UpdateSiteCustomLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSiteCustomLogWithOptions(request, runtime);
  }

  /**
   * Modifies a real-time log delivery task.
   * 
   * @param request - UpdateSiteDeliveryTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateSiteDeliveryTaskResponse
   */
  async updateSiteDeliveryTaskWithOptions(request: UpdateSiteDeliveryTaskRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSiteDeliveryTaskResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.businessType)) {
      body["BusinessType"] = request.businessType;
    }

    if (!Util.isUnset(request.discardRate)) {
      body["DiscardRate"] = request.discardRate;
    }

    if (!Util.isUnset(request.fieldName)) {
      body["FieldName"] = request.fieldName;
    }

    if (!Util.isUnset(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.taskName)) {
      body["TaskName"] = request.taskName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSiteDeliveryTask",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSiteDeliveryTaskResponse>(await this.callApi(params, req, runtime), new UpdateSiteDeliveryTaskResponse({}));
  }

  /**
   * Modifies a real-time log delivery task.
   * 
   * @param request - UpdateSiteDeliveryTaskRequest
   * @returns UpdateSiteDeliveryTaskResponse
   */
  async updateSiteDeliveryTask(request: UpdateSiteDeliveryTaskRequest): Promise<UpdateSiteDeliveryTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSiteDeliveryTaskWithOptions(request, runtime);
  }

  /**
   * Changes the status of a real-time log delivery task.
   * 
   * @param request - UpdateSiteDeliveryTaskStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateSiteDeliveryTaskStatusResponse
   */
  async updateSiteDeliveryTaskStatusWithOptions(request: UpdateSiteDeliveryTaskStatusRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSiteDeliveryTaskStatusResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSiteDeliveryTaskStatus",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSiteDeliveryTaskStatusResponse>(await this.callApi(params, req, runtime), new UpdateSiteDeliveryTaskStatusResponse({}));
  }

  /**
   * Changes the status of a real-time log delivery task.
   * 
   * @param request - UpdateSiteDeliveryTaskStatusRequest
   * @returns UpdateSiteDeliveryTaskStatusResponse
   */
  async updateSiteDeliveryTaskStatus(request: UpdateSiteDeliveryTaskStatusRequest): Promise<UpdateSiteDeliveryTaskStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSiteDeliveryTaskStatusWithOptions(request, runtime);
  }

  /**
   * 修改站点配置
   * 
   * @param tmpReq - UpdateSiteFunctionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateSiteFunctionResponse
   */
  async updateSiteFunctionWithOptions(tmpReq: UpdateSiteFunctionRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSiteFunctionResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateSiteFunctionShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.cacheReserve)) {
      request.cacheReserveShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.cacheReserve, "CacheReserve", "json");
    }

    if (!Util.isUnset(tmpReq.cacheRules)) {
      request.cacheRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.cacheRules, "CacheRules", "json");
    }

    if (!Util.isUnset(tmpReq.cacheTags)) {
      request.cacheTagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.cacheTags, "CacheTags", "json");
    }

    if (!Util.isUnset(tmpReq.cnameFlattening)) {
      request.cnameFlatteningShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.cnameFlattening, "CnameFlattening", "json");
    }

    if (!Util.isUnset(tmpReq.compressionRules)) {
      request.compressionRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.compressionRules, "CompressionRules", "json");
    }

    if (!Util.isUnset(tmpReq.crossBorderOptimization)) {
      request.crossBorderOptimizationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.crossBorderOptimization, "CrossBorderOptimization", "json");
    }

    if (!Util.isUnset(tmpReq.developmentMode)) {
      request.developmentModeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.developmentMode, "DevelopmentMode", "json");
    }

    if (!Util.isUnset(tmpReq.httpRequestHeaderModificationRules)) {
      request.httpRequestHeaderModificationRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.httpRequestHeaderModificationRules, "HttpRequestHeaderModificationRules", "json");
    }

    if (!Util.isUnset(tmpReq.httpResponseHeaderModificationRules)) {
      request.httpResponseHeaderModificationRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.httpResponseHeaderModificationRules, "HttpResponseHeaderModificationRules", "json");
    }

    if (!Util.isUnset(tmpReq.httpsApplicationConfiguration)) {
      request.httpsApplicationConfigurationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.httpsApplicationConfiguration, "HttpsApplicationConfiguration", "json");
    }

    if (!Util.isUnset(tmpReq.httpsBasicConfiguration)) {
      request.httpsBasicConfigurationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.httpsBasicConfiguration, "HttpsBasicConfiguration", "json");
    }

    if (!Util.isUnset(tmpReq.imageTransform)) {
      request.imageTransformShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.imageTransform, "ImageTransform", "json");
    }

    if (!Util.isUnset(tmpReq.ipv6)) {
      request.ipv6Shrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ipv6, "Ipv6", "json");
    }

    if (!Util.isUnset(tmpReq.managedTransforms)) {
      request.managedTransformsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.managedTransforms, "ManagedTransforms", "json");
    }

    if (!Util.isUnset(tmpReq.networkOptimization)) {
      request.networkOptimizationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.networkOptimization, "NetworkOptimization", "json");
    }

    if (!Util.isUnset(tmpReq.originRules)) {
      request.originRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.originRules, "OriginRules", "json");
    }

    if (!Util.isUnset(tmpReq.redirectRules)) {
      request.redirectRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.redirectRules, "RedirectRules", "json");
    }

    if (!Util.isUnset(tmpReq.rewriteUrlRules)) {
      request.rewriteUrlRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.rewriteUrlRules, "RewriteUrlRules", "json");
    }

    if (!Util.isUnset(tmpReq.seoBypass)) {
      request.seoBypassShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.seoBypass, "SeoBypass", "json");
    }

    if (!Util.isUnset(tmpReq.siteNameExclusive)) {
      request.siteNameExclusiveShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.siteNameExclusive, "SiteNameExclusive", "json");
    }

    if (!Util.isUnset(tmpReq.sitePause)) {
      request.sitePauseShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sitePause, "SitePause", "json");
    }

    if (!Util.isUnset(tmpReq.tieredCache)) {
      request.tieredCacheShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tieredCache, "TieredCache", "json");
    }

    let query = { };
    if (!Util.isUnset(request.cacheReserveShrink)) {
      query["CacheReserve"] = request.cacheReserveShrink;
    }

    if (!Util.isUnset(request.cacheRulesShrink)) {
      query["CacheRules"] = request.cacheRulesShrink;
    }

    if (!Util.isUnset(request.cacheTagsShrink)) {
      query["CacheTags"] = request.cacheTagsShrink;
    }

    if (!Util.isUnset(request.cnameFlatteningShrink)) {
      query["CnameFlattening"] = request.cnameFlatteningShrink;
    }

    if (!Util.isUnset(request.compressionRulesShrink)) {
      query["CompressionRules"] = request.compressionRulesShrink;
    }

    if (!Util.isUnset(request.crossBorderOptimizationShrink)) {
      query["CrossBorderOptimization"] = request.crossBorderOptimizationShrink;
    }

    if (!Util.isUnset(request.developmentModeShrink)) {
      query["DevelopmentMode"] = request.developmentModeShrink;
    }

    if (!Util.isUnset(request.httpRequestHeaderModificationRulesShrink)) {
      query["HttpRequestHeaderModificationRules"] = request.httpRequestHeaderModificationRulesShrink;
    }

    if (!Util.isUnset(request.httpResponseHeaderModificationRulesShrink)) {
      query["HttpResponseHeaderModificationRules"] = request.httpResponseHeaderModificationRulesShrink;
    }

    if (!Util.isUnset(request.httpsApplicationConfigurationShrink)) {
      query["HttpsApplicationConfiguration"] = request.httpsApplicationConfigurationShrink;
    }

    if (!Util.isUnset(request.httpsBasicConfigurationShrink)) {
      query["HttpsBasicConfiguration"] = request.httpsBasicConfigurationShrink;
    }

    if (!Util.isUnset(request.imageTransformShrink)) {
      query["ImageTransform"] = request.imageTransformShrink;
    }

    if (!Util.isUnset(request.ipv6Shrink)) {
      query["Ipv6"] = request.ipv6Shrink;
    }

    if (!Util.isUnset(request.managedTransformsShrink)) {
      query["ManagedTransforms"] = request.managedTransformsShrink;
    }

    if (!Util.isUnset(request.networkOptimizationShrink)) {
      query["NetworkOptimization"] = request.networkOptimizationShrink;
    }

    if (!Util.isUnset(request.originRulesShrink)) {
      query["OriginRules"] = request.originRulesShrink;
    }

    if (!Util.isUnset(request.redirectRulesShrink)) {
      query["RedirectRules"] = request.redirectRulesShrink;
    }

    if (!Util.isUnset(request.rewriteUrlRulesShrink)) {
      query["RewriteUrlRules"] = request.rewriteUrlRulesShrink;
    }

    if (!Util.isUnset(request.seoBypassShrink)) {
      query["SeoBypass"] = request.seoBypassShrink;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.siteNameExclusiveShrink)) {
      query["SiteNameExclusive"] = request.siteNameExclusiveShrink;
    }

    if (!Util.isUnset(request.sitePauseShrink)) {
      query["SitePause"] = request.sitePauseShrink;
    }

    if (!Util.isUnset(request.tieredCacheShrink)) {
      query["TieredCache"] = request.tieredCacheShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSiteFunction",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSiteFunctionResponse>(await this.callApi(params, req, runtime), new UpdateSiteFunctionResponse({}));
  }

  /**
   * 修改站点配置
   * 
   * @param request - UpdateSiteFunctionRequest
   * @returns UpdateSiteFunctionResponse
   */
  async updateSiteFunction(request: UpdateSiteFunctionRequest): Promise<UpdateSiteFunctionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSiteFunctionWithOptions(request, runtime);
  }

  /**
   * Updates the custom nameserver names for a single website.
   * 
   * @param request - UpdateSiteVanityNSRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateSiteVanityNSResponse
   */
  async updateSiteVanityNSWithOptions(request: UpdateSiteVanityNSRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSiteVanityNSResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.vanityNSList)) {
      query["VanityNSList"] = request.vanityNSList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSiteVanityNS",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSiteVanityNSResponse>(await this.callApi(params, req, runtime), new UpdateSiteVanityNSResponse({}));
  }

  /**
   * Updates the custom nameserver names for a single website.
   * 
   * @param request - UpdateSiteVanityNSRequest
   * @returns UpdateSiteVanityNSResponse
   */
  async updateSiteVanityNS(request: UpdateSiteVanityNSRequest): Promise<UpdateSiteVanityNSResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSiteVanityNSWithOptions(request, runtime);
  }

  /**
   * Modifies the configurations of a delivery task, including the task name, log field, log category, and discard rate.
   * 
   * @param request - UpdateUserDeliveryTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateUserDeliveryTaskResponse
   */
  async updateUserDeliveryTaskWithOptions(request: UpdateUserDeliveryTaskRequest, runtime: $Util.RuntimeOptions): Promise<UpdateUserDeliveryTaskResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.businessType)) {
      body["BusinessType"] = request.businessType;
    }

    if (!Util.isUnset(request.discardRate)) {
      body["DiscardRate"] = request.discardRate;
    }

    if (!Util.isUnset(request.fieldName)) {
      body["FieldName"] = request.fieldName;
    }

    if (!Util.isUnset(request.taskName)) {
      body["TaskName"] = request.taskName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateUserDeliveryTask",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateUserDeliveryTaskResponse>(await this.callApi(params, req, runtime), new UpdateUserDeliveryTaskResponse({}));
  }

  /**
   * Modifies the configurations of a delivery task, including the task name, log field, log category, and discard rate.
   * 
   * @param request - UpdateUserDeliveryTaskRequest
   * @returns UpdateUserDeliveryTaskResponse
   */
  async updateUserDeliveryTask(request: UpdateUserDeliveryTaskRequest): Promise<UpdateUserDeliveryTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateUserDeliveryTaskWithOptions(request, runtime);
  }

  /**
   * Changes the status of a delivery task in your Alibaba Cloud account.
   * 
   * @remarks
   * ## [](#)
   * You can call this operation to enable or disable a delivery task by using TaskName and Method. The response includes the most recent status and operation result details of the task.
   * 
   * @param request - UpdateUserDeliveryTaskStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateUserDeliveryTaskStatusResponse
   */
  async updateUserDeliveryTaskStatusWithOptions(request: UpdateUserDeliveryTaskStatusRequest, runtime: $Util.RuntimeOptions): Promise<UpdateUserDeliveryTaskStatusResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateUserDeliveryTaskStatus",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateUserDeliveryTaskStatusResponse>(await this.callApi(params, req, runtime), new UpdateUserDeliveryTaskStatusResponse({}));
  }

  /**
   * Changes the status of a delivery task in your Alibaba Cloud account.
   * 
   * @remarks
   * ## [](#)
   * You can call this operation to enable or disable a delivery task by using TaskName and Method. The response includes the most recent status and operation result details of the task.
   * 
   * @param request - UpdateUserDeliveryTaskStatusRequest
   * @returns UpdateUserDeliveryTaskStatusResponse
   */
  async updateUserDeliveryTaskStatus(request: UpdateUserDeliveryTaskStatusRequest): Promise<UpdateUserDeliveryTaskStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateUserDeliveryTaskStatusWithOptions(request, runtime);
  }

  /**
   * Modifies the configuration or status of a Web Application Firewall (WAF) rule.
   * 
   * @param tmpReq - UpdateWafRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateWafRuleResponse
   */
  async updateWafRuleWithOptions(tmpReq: UpdateWafRuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateWafRuleResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateWafRuleShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.config)) {
      request.configShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.config, "Config", "json");
    }

    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.configShrink)) {
      body["Config"] = request.configShrink;
    }

    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    if (!Util.isUnset(request.position)) {
      body["Position"] = request.position;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateWafRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateWafRuleResponse>(await this.callApi(params, req, runtime), new UpdateWafRuleResponse({}));
  }

  /**
   * Modifies the configuration or status of a Web Application Firewall (WAF) rule.
   * 
   * @param request - UpdateWafRuleRequest
   * @returns UpdateWafRuleResponse
   */
  async updateWafRule(request: UpdateWafRuleRequest): Promise<UpdateWafRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateWafRuleWithOptions(request, runtime);
  }

  /**
   * Updates a WAF ruleset based on its ID.
   * 
   * @param request - UpdateWafRulesetRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateWafRulesetResponse
   */
  async updateWafRulesetWithOptions(request: UpdateWafRulesetRequest, runtime: $Util.RuntimeOptions): Promise<UpdateWafRulesetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateWafRuleset",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateWafRulesetResponse>(await this.callApi(params, req, runtime), new UpdateWafRulesetResponse({}));
  }

  /**
   * Updates a WAF ruleset based on its ID.
   * 
   * @param request - UpdateWafRulesetRequest
   * @returns UpdateWafRulesetResponse
   */
  async updateWafRuleset(request: UpdateWafRulesetRequest): Promise<UpdateWafRulesetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateWafRulesetWithOptions(request, runtime);
  }

  /**
   * Modifies the configurations of a waiting room.
   * 
   * @param tmpReq - UpdateWaitingRoomRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateWaitingRoomResponse
   */
  async updateWaitingRoomWithOptions(tmpReq: UpdateWaitingRoomRequest, runtime: $Util.RuntimeOptions): Promise<UpdateWaitingRoomResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateWaitingRoomShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.hostNameAndPath)) {
      request.hostNameAndPathShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.hostNameAndPath, "HostNameAndPath", "json");
    }

    let query = { };
    if (!Util.isUnset(request.cookieName)) {
      query["CookieName"] = request.cookieName;
    }

    if (!Util.isUnset(request.customPageHtml)) {
      query["CustomPageHtml"] = request.customPageHtml;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.disableSessionRenewalEnable)) {
      query["DisableSessionRenewalEnable"] = request.disableSessionRenewalEnable;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.hostNameAndPathShrink)) {
      query["HostNameAndPath"] = request.hostNameAndPathShrink;
    }

    if (!Util.isUnset(request.jsonResponseEnable)) {
      query["JsonResponseEnable"] = request.jsonResponseEnable;
    }

    if (!Util.isUnset(request.language)) {
      query["Language"] = request.language;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.newUsersPerMinute)) {
      query["NewUsersPerMinute"] = request.newUsersPerMinute;
    }

    if (!Util.isUnset(request.queueAllEnable)) {
      query["QueueAllEnable"] = request.queueAllEnable;
    }

    if (!Util.isUnset(request.queuingMethod)) {
      query["QueuingMethod"] = request.queuingMethod;
    }

    if (!Util.isUnset(request.queuingStatusCode)) {
      query["QueuingStatusCode"] = request.queuingStatusCode;
    }

    if (!Util.isUnset(request.sessionDuration)) {
      query["SessionDuration"] = request.sessionDuration;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.totalActiveUsers)) {
      query["TotalActiveUsers"] = request.totalActiveUsers;
    }

    if (!Util.isUnset(request.waitingRoomId)) {
      query["WaitingRoomId"] = request.waitingRoomId;
    }

    if (!Util.isUnset(request.waitingRoomType)) {
      query["WaitingRoomType"] = request.waitingRoomType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateWaitingRoom",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateWaitingRoomResponse>(await this.callApi(params, req, runtime), new UpdateWaitingRoomResponse({}));
  }

  /**
   * Modifies the configurations of a waiting room.
   * 
   * @param request - UpdateWaitingRoomRequest
   * @returns UpdateWaitingRoomResponse
   */
  async updateWaitingRoom(request: UpdateWaitingRoomRequest): Promise<UpdateWaitingRoomResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateWaitingRoomWithOptions(request, runtime);
  }

  /**
   * Modifies the configurations of a waiting room event.
   * 
   * @param request - UpdateWaitingRoomEventRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateWaitingRoomEventResponse
   */
  async updateWaitingRoomEventWithOptions(request: UpdateWaitingRoomEventRequest, runtime: $Util.RuntimeOptions): Promise<UpdateWaitingRoomEventResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.customPageHtml)) {
      query["CustomPageHtml"] = request.customPageHtml;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.disableSessionRenewalEnable)) {
      query["DisableSessionRenewalEnable"] = request.disableSessionRenewalEnable;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.jsonResponseEnable)) {
      query["JsonResponseEnable"] = request.jsonResponseEnable;
    }

    if (!Util.isUnset(request.language)) {
      query["Language"] = request.language;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.newUsersPerMinute)) {
      query["NewUsersPerMinute"] = request.newUsersPerMinute;
    }

    if (!Util.isUnset(request.preQueueEnable)) {
      query["PreQueueEnable"] = request.preQueueEnable;
    }

    if (!Util.isUnset(request.preQueueStartTime)) {
      query["PreQueueStartTime"] = request.preQueueStartTime;
    }

    if (!Util.isUnset(request.queuingMethod)) {
      query["QueuingMethod"] = request.queuingMethod;
    }

    if (!Util.isUnset(request.queuingStatusCode)) {
      query["QueuingStatusCode"] = request.queuingStatusCode;
    }

    if (!Util.isUnset(request.randomPreQueueEnable)) {
      query["RandomPreQueueEnable"] = request.randomPreQueueEnable;
    }

    if (!Util.isUnset(request.sessionDuration)) {
      query["SessionDuration"] = request.sessionDuration;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.totalActiveUsers)) {
      query["TotalActiveUsers"] = request.totalActiveUsers;
    }

    if (!Util.isUnset(request.waitingRoomEventId)) {
      query["WaitingRoomEventId"] = request.waitingRoomEventId;
    }

    if (!Util.isUnset(request.waitingRoomType)) {
      query["WaitingRoomType"] = request.waitingRoomType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateWaitingRoomEvent",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateWaitingRoomEventResponse>(await this.callApi(params, req, runtime), new UpdateWaitingRoomEventResponse({}));
  }

  /**
   * Modifies the configurations of a waiting room event.
   * 
   * @param request - UpdateWaitingRoomEventRequest
   * @returns UpdateWaitingRoomEventResponse
   */
  async updateWaitingRoomEvent(request: UpdateWaitingRoomEventRequest): Promise<UpdateWaitingRoomEventResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateWaitingRoomEventWithOptions(request, runtime);
  }

  /**
   * Updates the configurations of a waiting room bypass rule for a website.
   * 
   * @remarks
   * You can call this API operation to modify the configurations of a waiting room bypass rule for your website, including the rule name, status, and rule content.
   * 
   * @param request - UpdateWaitingRoomRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateWaitingRoomRuleResponse
   */
  async updateWaitingRoomRuleWithOptions(request: UpdateWaitingRoomRuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateWaitingRoomRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!Util.isUnset(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.waitingRoomRuleId)) {
      query["WaitingRoomRuleId"] = request.waitingRoomRuleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateWaitingRoomRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateWaitingRoomRuleResponse>(await this.callApi(params, req, runtime), new UpdateWaitingRoomRuleResponse({}));
  }

  /**
   * Updates the configurations of a waiting room bypass rule for a website.
   * 
   * @remarks
   * You can call this API operation to modify the configurations of a waiting room bypass rule for your website, including the rule name, status, and rule content.
   * 
   * @param request - UpdateWaitingRoomRuleRequest
   * @returns UpdateWaitingRoomRuleResponse
   */
  async updateWaitingRoomRule(request: UpdateWaitingRoomRuleRequest): Promise<UpdateWaitingRoomRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateWaitingRoomRuleWithOptions(request, runtime);
  }

  /**
   * Uploads the file that contains resources to be purged or prefetched.
   * 
   * @remarks
   * > 
   * *   The file can be up to 10 MB in size.
   * *   After the file is uploaded, you can call [SubmitUploadTask](~~SubmitUploadTask~~) to submit the purge or prefetch task.
   * 
   * @param request - UploadFileRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UploadFileResponse
   */
  async uploadFileWithOptions(request: UploadFileRequest, runtime: $Util.RuntimeOptions): Promise<UploadFileResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.uploadTaskName)) {
      query["UploadTaskName"] = request.uploadTaskName;
    }

    if (!Util.isUnset(request.url)) {
      query["Url"] = request.url;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UploadFile",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UploadFileResponse>(await this.callApi(params, req, runtime), new UploadFileResponse({}));
  }

  /**
   * Uploads the file that contains resources to be purged or prefetched.
   * 
   * @remarks
   * > 
   * *   The file can be up to 10 MB in size.
   * *   After the file is uploaded, you can call [SubmitUploadTask](~~SubmitUploadTask~~) to submit the purge or prefetch task.
   * 
   * @param request - UploadFileRequest
   * @returns UploadFileResponse
   */
  async uploadFile(request: UploadFileRequest): Promise<UploadFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.uploadFileWithOptions(request, runtime);
  }

  async uploadFileAdvance(request: UploadFileAdvanceRequest, runtime: $Util.RuntimeOptions): Promise<UploadFileResponse> {
    // Step 0: init client
    let accessKeyId = await this._credential.getAccessKeyId();
    let accessKeySecret = await this._credential.getAccessKeySecret();
    let securityToken = await this._credential.getSecurityToken();
    let credentialType = this._credential.getType();
    let openPlatformEndpoint = this._openPlatformEndpoint;
    if (Util.empty(openPlatformEndpoint)) {
      openPlatformEndpoint = "openplatform.aliyuncs.com";
    }

    if (Util.isUnset(credentialType)) {
      credentialType = "access_key";
    }

    let authConfig = new $OpenApi.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      securityToken: securityToken,
      type: credentialType,
      endpoint: openPlatformEndpoint,
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let authClient = new OpenPlatform(authConfig);
    let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
      product: "ESA",
      regionId: this._regionId,
    });
    let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({ });
    let ossConfig = new $OSS.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      type: "access_key",
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let ossClient : OSS = new OSS(ossConfig);
    let fileObj = new $FileForm.FileField({ });
    let ossHeader = new $OSS.PostObjectRequestHeader({ });
    let uploadRequest = new $OSS.PostObjectRequest({ });
    let ossRuntime = new $OSSUtil.RuntimeOptions({ });
    OpenApiUtil.convert(runtime, ossRuntime);
    let uploadFileReq = new UploadFileRequest({ });
    OpenApiUtil.convert(request, uploadFileReq);
    if (!Util.isUnset(request.urlObject)) {
      authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
      ossConfig.accessKeyId = authResponse.body.accessKeyId;
      ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
      ossClient = new OSS(ossConfig);
      fileObj = new $FileForm.FileField({
        filename: authResponse.body.objectKey,
        content: request.urlObject,
        contentType: "",
      });
      ossHeader = new $OSS.PostObjectRequestHeader({
        accessKeyId: authResponse.body.accessKeyId,
        policy: authResponse.body.encodedPolicy,
        signature: authResponse.body.signature,
        key: authResponse.body.objectKey,
        file: fileObj,
        successActionStatus: "201",
      });
      uploadRequest = new $OSS.PostObjectRequest({
        bucketName: authResponse.body.bucket,
        header: ossHeader,
      });
      await ossClient.postObject(uploadRequest, ossRuntime);
      uploadFileReq.url = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
    }

    let uploadFileResp = await this.uploadFileWithOptions(uploadFileReq, runtime);
    return uploadFileResp;
  }

  /**
   * Verifies the ownership of a website domain. Websites that pass the verification are automatically activated.
   * 
   * @remarks
   * 1.  For a website connected by using NS setup, this operation verifies whether the nameservers of the website are the nameservers assigned by Alibaba Cloud.
   * 2.  For a website connected by using CNAME setup, this operation verifies whether the website has a TXT record whose hostname is  _esaauth.[websiteDomainName] and record value is the value of VerifyCode to the DNS records of your domain. You can see the VerifyCode field in the site information.
   * 
   * @param request - VerifySiteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns VerifySiteResponse
   */
  async verifySiteWithOptions(request: VerifySiteRequest, runtime: $Util.RuntimeOptions): Promise<VerifySiteResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "VerifySite",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<VerifySiteResponse>(await this.callApi(params, req, runtime), new VerifySiteResponse({}));
  }

  /**
   * Verifies the ownership of a website domain. Websites that pass the verification are automatically activated.
   * 
   * @remarks
   * 1.  For a website connected by using NS setup, this operation verifies whether the nameservers of the website are the nameservers assigned by Alibaba Cloud.
   * 2.  For a website connected by using CNAME setup, this operation verifies whether the website has a TXT record whose hostname is  _esaauth.[websiteDomainName] and record value is the value of VerifyCode to the DNS records of your domain. You can see the VerifyCode field in the site information.
   * 
   * @param request - VerifySiteRequest
   * @returns VerifySiteResponse
   */
  async verifySite(request: VerifySiteRequest): Promise<VerifySiteResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.verifySiteWithOptions(request, runtime);
  }

}
