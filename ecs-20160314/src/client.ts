// This file is auto-generated, don't edit it
/**
 *
 */
import Util, * as $Util from '@alicloud/tea-util';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class AddMigratableInstancesRequest extends $tea.Model {
  businessMigrationType?: number;
  instanceId?: string[];
  networkMigrationType?: number;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      businessMigrationType: 'BusinessMigrationType',
      instanceId: 'InstanceId',
      networkMigrationType: 'NetworkMigrationType',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessMigrationType: 'number',
      instanceId: { 'type': 'array', 'itemType': 'string' },
      networkMigrationType: 'number',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMigratableInstancesResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMigratableInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddMigratableInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddMigratableInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AllocateDedicatedHostsRequest extends $tea.Model {
  networkAttributes?: AllocateDedicatedHostsRequestNetworkAttributes;
  schedulerOptions?: AllocateDedicatedHostsRequestSchedulerOptions;
  actionOnMaintenance?: string;
  autoPlacement?: string;
  autoReleaseTime?: string;
  autoRenew?: boolean;
  autoRenewPeriod?: number;
  businessInfo?: string;
  chargeType?: string;
  clientToken?: string;
  cpuOverCommitRatio?: number;
  dedicatedHostClusterId?: string;
  dedicatedHostName?: string;
  dedicatedHostType?: string;
  description?: string;
  fromApp?: string;
  minQuantity?: number;
  ownerAccount?: string;
  ownerId?: number;
  period?: number;
  periodUnit?: string;
  quantity?: number;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  tag?: AllocateDedicatedHostsRequestTag[];
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      networkAttributes: 'NetworkAttributes',
      schedulerOptions: 'SchedulerOptions',
      actionOnMaintenance: 'ActionOnMaintenance',
      autoPlacement: 'AutoPlacement',
      autoReleaseTime: 'AutoReleaseTime',
      autoRenew: 'AutoRenew',
      autoRenewPeriod: 'AutoRenewPeriod',
      businessInfo: 'BusinessInfo',
      chargeType: 'ChargeType',
      clientToken: 'ClientToken',
      cpuOverCommitRatio: 'CpuOverCommitRatio',
      dedicatedHostClusterId: 'DedicatedHostClusterId',
      dedicatedHostName: 'DedicatedHostName',
      dedicatedHostType: 'DedicatedHostType',
      description: 'Description',
      fromApp: 'FromApp',
      minQuantity: 'MinQuantity',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      quantity: 'Quantity',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      tag: 'Tag',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkAttributes: AllocateDedicatedHostsRequestNetworkAttributes,
      schedulerOptions: AllocateDedicatedHostsRequestSchedulerOptions,
      actionOnMaintenance: 'string',
      autoPlacement: 'string',
      autoReleaseTime: 'string',
      autoRenew: 'boolean',
      autoRenewPeriod: 'number',
      businessInfo: 'string',
      chargeType: 'string',
      clientToken: 'string',
      cpuOverCommitRatio: 'number',
      dedicatedHostClusterId: 'string',
      dedicatedHostName: 'string',
      dedicatedHostType: 'string',
      description: 'string',
      fromApp: 'string',
      minQuantity: 'number',
      ownerAccount: 'string',
      ownerId: 'number',
      period: 'number',
      periodUnit: 'string',
      quantity: 'number',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      tag: { 'type': 'array', 'itemType': AllocateDedicatedHostsRequestTag },
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AllocateDedicatedHostsResponseBody extends $tea.Model {
  dedicatedHostIdSets?: AllocateDedicatedHostsResponseBodyDedicatedHostIdSets;
  orderId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      dedicatedHostIdSets: 'DedicatedHostIdSets',
      orderId: 'OrderId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedHostIdSets: AllocateDedicatedHostsResponseBodyDedicatedHostIdSets,
      orderId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AllocateDedicatedHostsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AllocateDedicatedHostsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AllocateDedicatedHostsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelMigrationInstancesRequest extends $tea.Model {
  instanceId?: string[];
  networkMigrationType?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      networkMigrationType: 'NetworkMigrationType',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: { 'type': 'array', 'itemType': 'string' },
      networkMigrationType: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelMigrationInstancesResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelMigrationInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CancelMigrationInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CancelMigrationInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelMigrationPlanRequest extends $tea.Model {
  migrationPlanId?: string;
  onlyCancelPlan?: boolean;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      migrationPlanId: 'MigrationPlanId',
      onlyCancelPlan: 'OnlyCancelPlan',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      migrationPlanId: 'string',
      onlyCancelPlan: 'boolean',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelMigrationPlanResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelMigrationPlanResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CancelMigrationPlanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CancelMigrationPlanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigureSecurityGroupPermissionsRequest extends $tea.Model {
  authorizePermission?: ConfigureSecurityGroupPermissionsRequestAuthorizePermission[];
  clientToken?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  revokePermission?: ConfigureSecurityGroupPermissionsRequestRevokePermission[];
  securityGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      authorizePermission: 'AuthorizePermission',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      revokePermission: 'RevokePermission',
      securityGroupId: 'SecurityGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorizePermission: { 'type': 'array', 'itemType': ConfigureSecurityGroupPermissionsRequestAuthorizePermission },
      clientToken: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      revokePermission: { 'type': 'array', 'itemType': ConfigureSecurityGroupPermissionsRequestRevokePermission },
      securityGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigureSecurityGroupPermissionsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigureSecurityGroupPermissionsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ConfigureSecurityGroupPermissionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ConfigureSecurityGroupPermissionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfirmReservationDemandRequest extends $tea.Model {
  demandId?: string;
  regionId?: string;
  resourceGroupId?: string;
  tag?: ConfirmReservationDemandRequestTag[];
  static names(): { [key: string]: string } {
    return {
      demandId: 'DemandId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      demandId: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      tag: { 'type': 'array', 'itemType': ConfirmReservationDemandRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfirmReservationDemandResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfirmReservationDemandResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ConfirmReservationDemandResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ConfirmReservationDemandResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCapacityReservationRequest extends $tea.Model {
  capacityReservationName?: string;
  description?: string;
  endDateType?: string;
  instanceCount?: string;
  instanceMatchCriteria?: string;
  instancePlatform?: string;
  instanceType?: string;
  networkType?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  tag?: CreateCapacityReservationRequestTag[];
  timeSlot?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      capacityReservationName: 'CapacityReservationName',
      description: 'Description',
      endDateType: 'EndDateType',
      instanceCount: 'InstanceCount',
      instanceMatchCriteria: 'InstanceMatchCriteria',
      instancePlatform: 'InstancePlatform',
      instanceType: 'InstanceType',
      networkType: 'NetworkType',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      tag: 'Tag',
      timeSlot: 'TimeSlot',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityReservationName: 'string',
      description: 'string',
      endDateType: 'string',
      instanceCount: 'string',
      instanceMatchCriteria: 'string',
      instancePlatform: 'string',
      instanceType: 'string',
      networkType: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      tag: { 'type': 'array', 'itemType': CreateCapacityReservationRequestTag },
      timeSlot: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCapacityReservationResponseBody extends $tea.Model {
  capacityReservationId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      capacityReservationId: 'CapacityReservationId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityReservationId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCapacityReservationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateCapacityReservationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCapacityReservationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDedicatedBlockStorageClusterRequest extends $tea.Model {
  capacity?: number;
  category?: string;
  clientToken?: string;
  dedicatedBlockStorageClusterName?: string;
  description?: string;
  fromApp?: string;
  ownerAccount?: string;
  ownerId?: number;
  period?: number;
  periodUnit?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  type?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      capacity: 'Capacity',
      category: 'Category',
      clientToken: 'ClientToken',
      dedicatedBlockStorageClusterName: 'DedicatedBlockStorageClusterName',
      description: 'Description',
      fromApp: 'FromApp',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      type: 'Type',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacity: 'number',
      category: 'string',
      clientToken: 'string',
      dedicatedBlockStorageClusterName: 'string',
      description: 'string',
      fromApp: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      period: 'number',
      periodUnit: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      type: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDedicatedBlockStorageClusterResponseBody extends $tea.Model {
  dedicatedBlockStorageClusterId?: string;
  dedicatedBlockStorageClusterOrderId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      dedicatedBlockStorageClusterId: 'DedicatedBlockStorageClusterId',
      dedicatedBlockStorageClusterOrderId: 'DedicatedBlockStorageClusterOrderId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedBlockStorageClusterId: 'string',
      dedicatedBlockStorageClusterOrderId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDedicatedBlockStorageClusterResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateDedicatedBlockStorageClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDedicatedBlockStorageClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDedicatedHostClusterRequest extends $tea.Model {
  schedulerOptions?: CreateDedicatedHostClusterRequestSchedulerOptions;
  dedicatedHostClusterName?: string;
  description?: string;
  dryRun?: boolean;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  tag?: CreateDedicatedHostClusterRequestTag[];
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      schedulerOptions: 'SchedulerOptions',
      dedicatedHostClusterName: 'DedicatedHostClusterName',
      description: 'Description',
      dryRun: 'DryRun',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      tag: 'Tag',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      schedulerOptions: CreateDedicatedHostClusterRequestSchedulerOptions,
      dedicatedHostClusterName: 'string',
      description: 'string',
      dryRun: 'boolean',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      tag: { 'type': 'array', 'itemType': CreateDedicatedHostClusterRequestTag },
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDedicatedHostClusterResponseBody extends $tea.Model {
  dedicatedHostClusterId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      dedicatedHostClusterId: 'DedicatedHostClusterId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedHostClusterId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDedicatedHostClusterResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateDedicatedHostClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDedicatedHostClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDefaultAutoSnapshotPolicyRequest extends $tea.Model {
  clientToken?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDefaultAutoSnapshotPolicyResponseBody extends $tea.Model {
  autoSnapshotPolicyId?: string;
  autoSnapshotPolicyName?: string;
  repeatWeekdays?: string;
  requestId?: string;
  retentionDays?: number;
  timePoints?: string;
  static names(): { [key: string]: string } {
    return {
      autoSnapshotPolicyId: 'AutoSnapshotPolicyId',
      autoSnapshotPolicyName: 'AutoSnapshotPolicyName',
      repeatWeekdays: 'RepeatWeekdays',
      requestId: 'RequestId',
      retentionDays: 'RetentionDays',
      timePoints: 'TimePoints',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoSnapshotPolicyId: 'string',
      autoSnapshotPolicyName: 'string',
      repeatWeekdays: 'string',
      requestId: 'string',
      retentionDays: 'number',
      timePoints: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDefaultAutoSnapshotPolicyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateDefaultAutoSnapshotPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDefaultAutoSnapshotPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDiagnoseRequest extends $tea.Model {
  amount?: number;
  diagnoseAction?: string;
  diagnoseErrorCode?: string;
  diagnoseProduct?: string;
  diagnoseRequestId?: string;
  diagnoseRequestParams?: string;
  diagnoseResponse?: string;
  diskCategory?: string;
  expireTime?: string;
  instanceChargeType?: string;
  instanceTypeName?: string;
  izNo?: string;
  mark?: string;
  networkType?: string;
  ownerAccount?: string;
  ownerId?: number;
  period?: number;
  periodUnit?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  tag?: CreateDiagnoseRequestTag[];
  type?: number;
  static names(): { [key: string]: string } {
    return {
      amount: 'Amount',
      diagnoseAction: 'DiagnoseAction',
      diagnoseErrorCode: 'DiagnoseErrorCode',
      diagnoseProduct: 'DiagnoseProduct',
      diagnoseRequestId: 'DiagnoseRequestId',
      diagnoseRequestParams: 'DiagnoseRequestParams',
      diagnoseResponse: 'DiagnoseResponse',
      diskCategory: 'DiskCategory',
      expireTime: 'ExpireTime',
      instanceChargeType: 'InstanceChargeType',
      instanceTypeName: 'InstanceTypeName',
      izNo: 'IzNo',
      mark: 'Mark',
      networkType: 'NetworkType',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      tag: 'Tag',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      amount: 'number',
      diagnoseAction: 'string',
      diagnoseErrorCode: 'string',
      diagnoseProduct: 'string',
      diagnoseRequestId: 'string',
      diagnoseRequestParams: 'string',
      diagnoseResponse: 'string',
      diskCategory: 'string',
      expireTime: 'string',
      instanceChargeType: 'string',
      instanceTypeName: 'string',
      izNo: 'string',
      mark: 'string',
      networkType: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      period: 'number',
      periodUnit: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      tag: { 'type': 'array', 'itemType': CreateDiagnoseRequestTag },
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDiagnoseResponseBody extends $tea.Model {
  diagnoseId?: string;
  requestId?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      diagnoseId: 'DiagnoseId',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diagnoseId: 'string',
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDiagnoseResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateDiagnoseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDiagnoseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDiagnosisOperateRecordsRequest extends $tea.Model {
  errorCode?: string;
  instanceType?: string;
  newInstanceType?: string;
  newZoneId?: string;
  operateRecordType?: string;
  ownerId?: number;
  payType?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      instanceType: 'InstanceType',
      newInstanceType: 'NewInstanceType',
      newZoneId: 'NewZoneId',
      operateRecordType: 'OperateRecordType',
      ownerId: 'OwnerId',
      payType: 'PayType',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      instanceType: 'string',
      newInstanceType: 'string',
      newZoneId: 'string',
      operateRecordType: 'string',
      ownerId: 'number',
      payType: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDiagnosisOperateRecordsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDiagnosisOperateRecordsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateDiagnosisOperateRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDiagnosisOperateRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDiagnosticReportRequest extends $tea.Model {
  clientToken?: string;
  commandName?: string[];
  commandType?: string;
  diagnosticCategory?: string;
  endTime?: string;
  ownerAccount?: string;
  ownerId?: number;
  pluginVersion?: string;
  regionId?: string;
  resourceId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  resourceType?: string;
  sourceSystem?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      commandName: 'CommandName',
      commandType: 'CommandType',
      diagnosticCategory: 'DiagnosticCategory',
      endTime: 'EndTime',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      pluginVersion: 'PluginVersion',
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      resourceType: 'ResourceType',
      sourceSystem: 'SourceSystem',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      commandName: { 'type': 'array', 'itemType': 'string' },
      commandType: 'string',
      diagnosticCategory: 'string',
      endTime: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      pluginVersion: 'string',
      regionId: 'string',
      resourceId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      resourceType: 'string',
      sourceSystem: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDiagnosticReportResponseBody extends $tea.Model {
  commandInvokeResults?: CreateDiagnosticReportResponseBodyCommandInvokeResults;
  createTime?: string;
  reportId?: string;
  requestId?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      commandInvokeResults: 'CommandInvokeResults',
      createTime: 'CreateTime',
      reportId: 'ReportId',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commandInvokeResults: CreateDiagnosticReportResponseBodyCommandInvokeResults,
      createTime: 'string',
      reportId: 'string',
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDiagnosticReportResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateDiagnosticReportResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDiagnosticReportResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDisksRequest extends $tea.Model {
  amount?: number;
  autoSnapshotPolicyId?: string;
  burstingEnabled?: boolean;
  category?: string;
  clientToken?: string;
  description?: string;
  diskName?: string;
  encryptAlgorithm?: string;
  encrypted?: boolean;
  KMSKeyId?: string;
  multiAttach?: string;
  ownerAccount?: string;
  ownerId?: number;
  performanceLevel?: string;
  provisionedIops?: number;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  size?: number;
  snapshotId?: string;
  storageClusterId?: string;
  storageSetId?: string;
  storageSetPartitionNumber?: number;
  tag?: CreateDisksRequestTag[];
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      amount: 'Amount',
      autoSnapshotPolicyId: 'AutoSnapshotPolicyId',
      burstingEnabled: 'BurstingEnabled',
      category: 'Category',
      clientToken: 'ClientToken',
      description: 'Description',
      diskName: 'DiskName',
      encryptAlgorithm: 'EncryptAlgorithm',
      encrypted: 'Encrypted',
      KMSKeyId: 'KMSKeyId',
      multiAttach: 'MultiAttach',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      performanceLevel: 'PerformanceLevel',
      provisionedIops: 'ProvisionedIops',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      size: 'Size',
      snapshotId: 'SnapshotId',
      storageClusterId: 'StorageClusterId',
      storageSetId: 'StorageSetId',
      storageSetPartitionNumber: 'StorageSetPartitionNumber',
      tag: 'Tag',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      amount: 'number',
      autoSnapshotPolicyId: 'string',
      burstingEnabled: 'boolean',
      category: 'string',
      clientToken: 'string',
      description: 'string',
      diskName: 'string',
      encryptAlgorithm: 'string',
      encrypted: 'boolean',
      KMSKeyId: 'string',
      multiAttach: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      performanceLevel: 'string',
      provisionedIops: 'number',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      size: 'number',
      snapshotId: 'string',
      storageClusterId: 'string',
      storageSetId: 'string',
      storageSetPartitionNumber: 'number',
      tag: { 'type': 'array', 'itemType': CreateDisksRequestTag },
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDisksResponseBody extends $tea.Model {
  diskId?: CreateDisksResponseBodyDiskId;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      diskId: 'DiskId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskId: CreateDisksResponseBodyDiskId,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDisksResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateDisksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDisksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateElasticityAssuranceRequest extends $tea.Model {
  privatePoolOptions?: CreateElasticityAssuranceRequestPrivatePoolOptions;
  assuranceTimes?: string;
  clientToken?: string;
  description?: string;
  instanceAmount?: number;
  instanceCpuCoreCount?: number;
  instanceType?: string[];
  ownerAccount?: string;
  ownerId?: number;
  period?: number;
  periodUnit?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  startTime?: string;
  tag?: CreateElasticityAssuranceRequestTag[];
  zoneId?: string[];
  static names(): { [key: string]: string } {
    return {
      privatePoolOptions: 'PrivatePoolOptions',
      assuranceTimes: 'AssuranceTimes',
      clientToken: 'ClientToken',
      description: 'Description',
      instanceAmount: 'InstanceAmount',
      instanceCpuCoreCount: 'InstanceCpuCoreCount',
      instanceType: 'InstanceType',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      startTime: 'StartTime',
      tag: 'Tag',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      privatePoolOptions: CreateElasticityAssuranceRequestPrivatePoolOptions,
      assuranceTimes: 'string',
      clientToken: 'string',
      description: 'string',
      instanceAmount: 'number',
      instanceCpuCoreCount: 'number',
      instanceType: { 'type': 'array', 'itemType': 'string' },
      ownerAccount: 'string',
      ownerId: 'number',
      period: 'number',
      periodUnit: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      startTime: 'string',
      tag: { 'type': 'array', 'itemType': CreateElasticityAssuranceRequestTag },
      zoneId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateElasticityAssuranceResponseBody extends $tea.Model {
  orderId?: string;
  privatePoolOptionsId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      privatePoolOptionsId: 'PrivatePoolOptionsId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'string',
      privatePoolOptionsId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateElasticityAssuranceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateElasticityAssuranceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateElasticityAssuranceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEniQosGroupRequest extends $tea.Model {
  instanceId?: string;
  ownerId?: number;
  qosGroupName?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  rx?: number;
  rxPps?: number;
  tx?: number;
  txPps?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      ownerId: 'OwnerId',
      qosGroupName: 'QosGroupName',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      rx: 'Rx',
      rxPps: 'RxPps',
      tx: 'Tx',
      txPps: 'TxPps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      ownerId: 'number',
      qosGroupName: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      rx: 'number',
      rxPps: 'number',
      tx: 'number',
      txPps: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEniQosGroupResponseBody extends $tea.Model {
  qosGroupName?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      qosGroupName: 'QosGroupName',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qosGroupName: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEniQosGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateEniQosGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEniQosGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFunctionFeedbackRequest extends $tea.Model {
  category?: string;
  feedback?: string;
  functionName?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  suggestion?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      feedback: 'Feedback',
      functionName: 'FunctionName',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      suggestion: 'Suggestion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      feedback: 'string',
      functionName: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      suggestion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFunctionFeedbackResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFunctionFeedbackResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateFunctionFeedbackResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateFunctionFeedbackResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateImageCacheRequest extends $tea.Model {
  clientToken?: string;
  imageId?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      imageId: 'ImageId',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      imageId: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateImageCacheResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateImageCacheResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateImageCacheResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateImageCacheResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateIssueCategoryReportRelationRequest extends $tea.Model {
  regionId?: string;
  relationModelList?: CreateIssueCategoryReportRelationRequestRelationModelList[];
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      relationModelList: 'RelationModelList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      relationModelList: { 'type': 'array', 'itemType': CreateIssueCategoryReportRelationRequestRelationModelList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateIssueCategoryReportRelationResponseBody extends $tea.Model {
  requestId?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateIssueCategoryReportRelationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateIssueCategoryReportRelationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateIssueCategoryReportRelationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMigrationPlanRequest extends $tea.Model {
  customMigrationTimes?: CreateMigrationPlanRequestCustomMigrationTimes[];
  dryRun?: boolean;
  enableAutoCreateVSwitch?: boolean;
  ensureNetworkConnectivity?: boolean;
  globalMigrationTime?: string;
  instanceIds?: string[];
  name?: string;
  ownerId?: number;
  regionId?: string;
  remainPrivateIp?: boolean;
  remainPublicMacAsPriority?: boolean;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  targetSecurityGroupIds?: string[];
  targetVSwitchId?: string;
  targetVpcId?: string;
  targetZoneId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      customMigrationTimes: 'CustomMigrationTimes',
      dryRun: 'DryRun',
      enableAutoCreateVSwitch: 'EnableAutoCreateVSwitch',
      ensureNetworkConnectivity: 'EnsureNetworkConnectivity',
      globalMigrationTime: 'GlobalMigrationTime',
      instanceIds: 'InstanceIds',
      name: 'Name',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      remainPrivateIp: 'RemainPrivateIp',
      remainPublicMacAsPriority: 'RemainPublicMacAsPriority',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      targetSecurityGroupIds: 'TargetSecurityGroupIds',
      targetVSwitchId: 'TargetVSwitchId',
      targetVpcId: 'TargetVpcId',
      targetZoneId: 'TargetZoneId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customMigrationTimes: { 'type': 'array', 'itemType': CreateMigrationPlanRequestCustomMigrationTimes },
      dryRun: 'boolean',
      enableAutoCreateVSwitch: 'boolean',
      ensureNetworkConnectivity: 'boolean',
      globalMigrationTime: 'string',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      name: 'string',
      ownerId: 'number',
      regionId: 'string',
      remainPrivateIp: 'boolean',
      remainPublicMacAsPriority: 'boolean',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      targetSecurityGroupIds: { 'type': 'array', 'itemType': 'string' },
      targetVSwitchId: 'string',
      targetVpcId: 'string',
      targetZoneId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMigrationPlanResponseBody extends $tea.Model {
  instancesFailModels?: CreateMigrationPlanResponseBodyInstancesFailModels;
  migrationPlanId?: string;
  planFailModels?: CreateMigrationPlanResponseBodyPlanFailModels;
  requestId?: string;
  sgFailModels?: CreateMigrationPlanResponseBodySgFailModels;
  static names(): { [key: string]: string } {
    return {
      instancesFailModels: 'InstancesFailModels',
      migrationPlanId: 'MigrationPlanId',
      planFailModels: 'PlanFailModels',
      requestId: 'RequestId',
      sgFailModels: 'SgFailModels',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instancesFailModels: CreateMigrationPlanResponseBodyInstancesFailModels,
      migrationPlanId: 'string',
      planFailModels: CreateMigrationPlanResponseBodyPlanFailModels,
      requestId: 'string',
      sgFailModels: CreateMigrationPlanResponseBodySgFailModels,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMigrationPlanResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateMigrationPlanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMigrationPlanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNetworkInsightsPathRequest extends $tea.Model {
  clientToken?: string;
  destination?: string;
  destinationPort?: string;
  destinationType?: string;
  dryRun?: boolean;
  needDiagnoseGuest?: boolean;
  networkInsightsPathName?: string;
  protocol?: string;
  regionId?: string;
  resourceOwnerId?: number;
  source?: string;
  sourceType?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      destination: 'Destination',
      destinationPort: 'DestinationPort',
      destinationType: 'DestinationType',
      dryRun: 'DryRun',
      needDiagnoseGuest: 'NeedDiagnoseGuest',
      networkInsightsPathName: 'NetworkInsightsPathName',
      protocol: 'Protocol',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      source: 'Source',
      sourceType: 'SourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      destination: 'string',
      destinationPort: 'string',
      destinationType: 'string',
      dryRun: 'boolean',
      needDiagnoseGuest: 'boolean',
      networkInsightsPathName: 'string',
      protocol: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      source: 'string',
      sourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNetworkInsightsPathResponseBody extends $tea.Model {
  networkInsightsPathId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      networkInsightsPathId: 'NetworkInsightsPathId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkInsightsPathId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNetworkInsightsPathResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateNetworkInsightsPathResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateNetworkInsightsPathResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrderRequest extends $tea.Model {
  affinity?: string;
  asyncPattern?: boolean;
  businessInfo?: string;
  chargeType?: string;
  clientToken?: string;
  commodity?: string;
  dedicatedHostClusterId?: string;
  dedicatedHostId?: string;
  fromApp?: string;
  orderType?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  tenancy?: string;
  static names(): { [key: string]: string } {
    return {
      affinity: 'Affinity',
      asyncPattern: 'AsyncPattern',
      businessInfo: 'BusinessInfo',
      chargeType: 'ChargeType',
      clientToken: 'ClientToken',
      commodity: 'Commodity',
      dedicatedHostClusterId: 'DedicatedHostClusterId',
      dedicatedHostId: 'DedicatedHostId',
      fromApp: 'FromApp',
      orderType: 'OrderType',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      tenancy: 'Tenancy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affinity: 'string',
      asyncPattern: 'boolean',
      businessInfo: 'string',
      chargeType: 'string',
      clientToken: 'string',
      commodity: 'string',
      dedicatedHostClusterId: 'string',
      dedicatedHostId: 'string',
      fromApp: 'string',
      orderType: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      tenancy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrderResponseBody extends $tea.Model {
  orderId?: string;
  orderParams?: CreateOrderResponseBodyOrderParams;
  relatedOrderItemSets?: CreateOrderResponseBodyRelatedOrderItemSets;
  requestId?: string;
  taskId?: string;
  tradePrice?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      orderParams: 'OrderParams',
      relatedOrderItemSets: 'RelatedOrderItemSets',
      requestId: 'RequestId',
      taskId: 'TaskId',
      tradePrice: 'TradePrice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'string',
      orderParams: CreateOrderResponseBodyOrderParams,
      relatedOrderItemSets: CreateOrderResponseBodyRelatedOrderItemSets,
      requestId: 'string',
      taskId: 'string',
      tradePrice: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrderResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateReservationDemandRequest extends $tea.Model {
  clientToken?: string;
  confirmType?: string;
  couponAuto?: boolean;
  couponType?: string;
  description?: string;
  endTime?: string;
  instanceAmount?: number;
  instanceChargeType?: string;
  instanceCpuCoreCount?: number;
  instanceTypeFamily?: string;
  instanceTypes?: string;
  matchCriteria?: string;
  name?: string;
  period?: number;
  periodUnit?: string;
  phoneNumber?: string;
  platform?: string;
  privatePoolOptions?: CreateReservationDemandRequestPrivatePoolOptions[];
  productType?: string;
  regionId?: string;
  reservedInstanceDescription?: string;
  reservedInstanceName?: string;
  reservedInstanceOfferingType?: string;
  reservedInstanceScope?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  resourceSupplyType?: string;
  savingPlanDescription?: string;
  savingPlanHourFee?: number;
  savingPlanId?: string;
  savingPlanInstanceTypeFamilyGroup?: string;
  savingPlanName?: string;
  savingPlanPayMode?: string;
  savingPlanSavingType?: string;
  startTime?: string;
  tag?: CreateReservationDemandRequestTag[];
  zoneIds?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      confirmType: 'ConfirmType',
      couponAuto: 'CouponAuto',
      couponType: 'CouponType',
      description: 'Description',
      endTime: 'EndTime',
      instanceAmount: 'InstanceAmount',
      instanceChargeType: 'InstanceChargeType',
      instanceCpuCoreCount: 'InstanceCpuCoreCount',
      instanceTypeFamily: 'InstanceTypeFamily',
      instanceTypes: 'InstanceTypes',
      matchCriteria: 'MatchCriteria',
      name: 'Name',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      phoneNumber: 'PhoneNumber',
      platform: 'Platform',
      privatePoolOptions: 'PrivatePoolOptions',
      productType: 'ProductType',
      regionId: 'RegionId',
      reservedInstanceDescription: 'ReservedInstanceDescription',
      reservedInstanceName: 'ReservedInstanceName',
      reservedInstanceOfferingType: 'ReservedInstanceOfferingType',
      reservedInstanceScope: 'ReservedInstanceScope',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      resourceSupplyType: 'ResourceSupplyType',
      savingPlanDescription: 'SavingPlanDescription',
      savingPlanHourFee: 'SavingPlanHourFee',
      savingPlanId: 'SavingPlanId',
      savingPlanInstanceTypeFamilyGroup: 'SavingPlanInstanceTypeFamilyGroup',
      savingPlanName: 'SavingPlanName',
      savingPlanPayMode: 'SavingPlanPayMode',
      savingPlanSavingType: 'SavingPlanSavingType',
      startTime: 'StartTime',
      tag: 'Tag',
      zoneIds: 'ZoneIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      confirmType: 'string',
      couponAuto: 'boolean',
      couponType: 'string',
      description: 'string',
      endTime: 'string',
      instanceAmount: 'number',
      instanceChargeType: 'string',
      instanceCpuCoreCount: 'number',
      instanceTypeFamily: 'string',
      instanceTypes: 'string',
      matchCriteria: 'string',
      name: 'string',
      period: 'number',
      periodUnit: 'string',
      phoneNumber: 'string',
      platform: 'string',
      privatePoolOptions: { 'type': 'array', 'itemType': CreateReservationDemandRequestPrivatePoolOptions },
      productType: 'string',
      regionId: 'string',
      reservedInstanceDescription: 'string',
      reservedInstanceName: 'string',
      reservedInstanceOfferingType: 'string',
      reservedInstanceScope: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      resourceSupplyType: 'string',
      savingPlanDescription: 'string',
      savingPlanHourFee: 'number',
      savingPlanId: 'string',
      savingPlanInstanceTypeFamilyGroup: 'string',
      savingPlanName: 'string',
      savingPlanPayMode: 'string',
      savingPlanSavingType: 'string',
      startTime: 'string',
      tag: { 'type': 'array', 'itemType': CreateReservationDemandRequestTag },
      zoneIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateReservationDemandResponseBody extends $tea.Model {
  demandId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      demandId: 'DemandId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      demandId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateReservationDemandResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateReservationDemandResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateReservationDemandResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStorageSetRequest extends $tea.Model {
  clientToken?: string;
  description?: string;
  maxPartitionNumber?: number;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  storageSetName?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      description: 'Description',
      maxPartitionNumber: 'MaxPartitionNumber',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      storageSetName: 'StorageSetName',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      description: 'string',
      maxPartitionNumber: 'number',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      storageSetName: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStorageSetResponseBody extends $tea.Model {
  requestId?: string;
  storageSetId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      storageSetId: 'StorageSetId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      storageSetId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStorageSetResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateStorageSetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateStorageSetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserQuotaApplicationRequest extends $tea.Model {
  chargeType?: string;
  clientToken?: string;
  description?: string;
  instanceType?: string;
  ownerAccount?: string;
  ownerId?: number;
  quotaType?: string;
  quotaValue?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      chargeType: 'ChargeType',
      clientToken: 'ClientToken',
      description: 'Description',
      instanceType: 'InstanceType',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      quotaType: 'QuotaType',
      quotaValue: 'QuotaValue',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chargeType: 'string',
      clientToken: 'string',
      description: 'string',
      instanceType: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      quotaType: 'string',
      quotaValue: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserQuotaApplicationResponseBody extends $tea.Model {
  applicationId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      applicationId: 'ApplicationId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserQuotaApplicationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateUserQuotaApplicationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateUserQuotaApplicationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVolumesRequest extends $tea.Model {
  amount?: number;
  clientToken?: string;
  description?: string;
  KMSKeyId?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  size?: number;
  snapshotId?: string;
  storageSetId?: string;
  storageSetPartitionNumber?: number;
  tag?: CreateVolumesRequestTag[];
  volumeCategory?: string;
  volumeEncrypted?: boolean;
  volumeName?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      amount: 'Amount',
      clientToken: 'ClientToken',
      description: 'Description',
      KMSKeyId: 'KMSKeyId',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      size: 'Size',
      snapshotId: 'SnapshotId',
      storageSetId: 'StorageSetId',
      storageSetPartitionNumber: 'StorageSetPartitionNumber',
      tag: 'Tag',
      volumeCategory: 'VolumeCategory',
      volumeEncrypted: 'VolumeEncrypted',
      volumeName: 'VolumeName',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      amount: 'number',
      clientToken: 'string',
      description: 'string',
      KMSKeyId: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      size: 'number',
      snapshotId: 'string',
      storageSetId: 'string',
      storageSetPartitionNumber: 'number',
      tag: { 'type': 'array', 'itemType': CreateVolumesRequestTag },
      volumeCategory: 'string',
      volumeEncrypted: 'boolean',
      volumeName: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVolumesResponseBody extends $tea.Model {
  requestId?: string;
  volumeIds?: CreateVolumesResponseBodyVolumeIds;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      volumeIds: 'VolumeIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      volumeIds: CreateVolumesResponseBodyVolumeIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVolumesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateVolumesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateVolumesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingOrderRequest extends $tea.Model {
  cpuOptions?: CreateWaitingOrderRequestCpuOptions;
  hibernationOptions?: CreateWaitingOrderRequestHibernationOptions;
  privatePoolOptions?: CreateWaitingOrderRequestPrivatePoolOptions;
  schedulerOptions?: CreateWaitingOrderRequestSchedulerOptions;
  securityOptions?: CreateWaitingOrderRequestSecurityOptions;
  systemDisk?: CreateWaitingOrderRequestSystemDisk;
  affinity?: string;
  arn?: CreateWaitingOrderRequestArn[];
  autoReleaseTime?: string;
  autoRenew?: boolean;
  autoRenewPeriod?: number;
  clientToken?: string;
  creditSpecification?: string;
  dataDisk?: CreateWaitingOrderRequestDataDisk[];
  dedicatedHostId?: string;
  deletionProtection?: boolean;
  deploymentSetGroupNo?: number;
  deploymentSetId?: string;
  description?: string;
  dryRun?: boolean;
  expiredTime?: string;
  hostName?: string;
  hostNames?: string[];
  hpcClusterId?: string;
  httpEndpoint?: string;
  httpPutResponseHopLimit?: number;
  httpTokens?: string;
  imageFamily?: string;
  imageId?: string;
  instanceChargeType?: string;
  instanceName?: string;
  instanceType?: string;
  internetChargeType?: string;
  internetMaxBandwidthIn?: number;
  internetMaxBandwidthOut?: number;
  ioOptimized?: string;
  ipv6Address?: string[];
  ipv6AddressCount?: number;
  isp?: string;
  keyPairName?: string;
  launchTemplateId?: string;
  launchTemplateName?: string;
  launchTemplateVersion?: number;
  maxAmount?: number;
  minAmount?: number;
  networkInterface?: CreateWaitingOrderRequestNetworkInterface[];
  networkInterfaceQueueNumber?: number;
  ownerAccount?: string;
  ownerId?: number;
  password?: string;
  passwordInherit?: boolean;
  period?: number;
  periodUnit?: string;
  privateIpAddress?: string;
  ramRoleName?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  securityEnhancementStrategy?: string;
  securityGroupId?: string;
  securityGroupIds?: string[];
  spotDuration?: number;
  spotInterruptionBehavior?: string;
  spotPriceLimit?: number;
  spotStrategy?: string;
  storageSetId?: string;
  storageSetPartitionNumber?: number;
  tag?: CreateWaitingOrderRequestTag[];
  tenancy?: string;
  uniqueSuffix?: boolean;
  userData?: string;
  vSwitchId?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      cpuOptions: 'CpuOptions',
      hibernationOptions: 'HibernationOptions',
      privatePoolOptions: 'PrivatePoolOptions',
      schedulerOptions: 'SchedulerOptions',
      securityOptions: 'SecurityOptions',
      systemDisk: 'SystemDisk',
      affinity: 'Affinity',
      arn: 'Arn',
      autoReleaseTime: 'AutoReleaseTime',
      autoRenew: 'AutoRenew',
      autoRenewPeriod: 'AutoRenewPeriod',
      clientToken: 'ClientToken',
      creditSpecification: 'CreditSpecification',
      dataDisk: 'DataDisk',
      dedicatedHostId: 'DedicatedHostId',
      deletionProtection: 'DeletionProtection',
      deploymentSetGroupNo: 'DeploymentSetGroupNo',
      deploymentSetId: 'DeploymentSetId',
      description: 'Description',
      dryRun: 'DryRun',
      expiredTime: 'ExpiredTime',
      hostName: 'HostName',
      hostNames: 'HostNames',
      hpcClusterId: 'HpcClusterId',
      httpEndpoint: 'HttpEndpoint',
      httpPutResponseHopLimit: 'HttpPutResponseHopLimit',
      httpTokens: 'HttpTokens',
      imageFamily: 'ImageFamily',
      imageId: 'ImageId',
      instanceChargeType: 'InstanceChargeType',
      instanceName: 'InstanceName',
      instanceType: 'InstanceType',
      internetChargeType: 'InternetChargeType',
      internetMaxBandwidthIn: 'InternetMaxBandwidthIn',
      internetMaxBandwidthOut: 'InternetMaxBandwidthOut',
      ioOptimized: 'IoOptimized',
      ipv6Address: 'Ipv6Address',
      ipv6AddressCount: 'Ipv6AddressCount',
      isp: 'Isp',
      keyPairName: 'KeyPairName',
      launchTemplateId: 'LaunchTemplateId',
      launchTemplateName: 'LaunchTemplateName',
      launchTemplateVersion: 'LaunchTemplateVersion',
      maxAmount: 'MaxAmount',
      minAmount: 'MinAmount',
      networkInterface: 'NetworkInterface',
      networkInterfaceQueueNumber: 'NetworkInterfaceQueueNumber',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      password: 'Password',
      passwordInherit: 'PasswordInherit',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      privateIpAddress: 'PrivateIpAddress',
      ramRoleName: 'RamRoleName',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      securityEnhancementStrategy: 'SecurityEnhancementStrategy',
      securityGroupId: 'SecurityGroupId',
      securityGroupIds: 'SecurityGroupIds',
      spotDuration: 'SpotDuration',
      spotInterruptionBehavior: 'SpotInterruptionBehavior',
      spotPriceLimit: 'SpotPriceLimit',
      spotStrategy: 'SpotStrategy',
      storageSetId: 'StorageSetId',
      storageSetPartitionNumber: 'StorageSetPartitionNumber',
      tag: 'Tag',
      tenancy: 'Tenancy',
      uniqueSuffix: 'UniqueSuffix',
      userData: 'UserData',
      vSwitchId: 'VSwitchId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpuOptions: CreateWaitingOrderRequestCpuOptions,
      hibernationOptions: CreateWaitingOrderRequestHibernationOptions,
      privatePoolOptions: CreateWaitingOrderRequestPrivatePoolOptions,
      schedulerOptions: CreateWaitingOrderRequestSchedulerOptions,
      securityOptions: CreateWaitingOrderRequestSecurityOptions,
      systemDisk: CreateWaitingOrderRequestSystemDisk,
      affinity: 'string',
      arn: { 'type': 'array', 'itemType': CreateWaitingOrderRequestArn },
      autoReleaseTime: 'string',
      autoRenew: 'boolean',
      autoRenewPeriod: 'number',
      clientToken: 'string',
      creditSpecification: 'string',
      dataDisk: { 'type': 'array', 'itemType': CreateWaitingOrderRequestDataDisk },
      dedicatedHostId: 'string',
      deletionProtection: 'boolean',
      deploymentSetGroupNo: 'number',
      deploymentSetId: 'string',
      description: 'string',
      dryRun: 'boolean',
      expiredTime: 'string',
      hostName: 'string',
      hostNames: { 'type': 'array', 'itemType': 'string' },
      hpcClusterId: 'string',
      httpEndpoint: 'string',
      httpPutResponseHopLimit: 'number',
      httpTokens: 'string',
      imageFamily: 'string',
      imageId: 'string',
      instanceChargeType: 'string',
      instanceName: 'string',
      instanceType: 'string',
      internetChargeType: 'string',
      internetMaxBandwidthIn: 'number',
      internetMaxBandwidthOut: 'number',
      ioOptimized: 'string',
      ipv6Address: { 'type': 'array', 'itemType': 'string' },
      ipv6AddressCount: 'number',
      isp: 'string',
      keyPairName: 'string',
      launchTemplateId: 'string',
      launchTemplateName: 'string',
      launchTemplateVersion: 'number',
      maxAmount: 'number',
      minAmount: 'number',
      networkInterface: { 'type': 'array', 'itemType': CreateWaitingOrderRequestNetworkInterface },
      networkInterfaceQueueNumber: 'number',
      ownerAccount: 'string',
      ownerId: 'number',
      password: 'string',
      passwordInherit: 'boolean',
      period: 'number',
      periodUnit: 'string',
      privateIpAddress: 'string',
      ramRoleName: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      securityEnhancementStrategy: 'string',
      securityGroupId: 'string',
      securityGroupIds: { 'type': 'array', 'itemType': 'string' },
      spotDuration: 'number',
      spotInterruptionBehavior: 'string',
      spotPriceLimit: 'number',
      spotStrategy: 'string',
      storageSetId: 'string',
      storageSetPartitionNumber: 'number',
      tag: { 'type': 'array', 'itemType': CreateWaitingOrderRequestTag },
      tenancy: 'string',
      uniqueSuffix: 'boolean',
      userData: 'string',
      vSwitchId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingOrderResponseBody extends $tea.Model {
  dryRunResult?: string;
  requestId?: string;
  waitTimeCycle?: string;
  waitTimeValue?: number;
  waitingOrderId?: string;
  static names(): { [key: string]: string } {
    return {
      dryRunResult: 'DryRunResult',
      requestId: 'RequestId',
      waitTimeCycle: 'WaitTimeCycle',
      waitTimeValue: 'WaitTimeValue',
      waitingOrderId: 'WaitingOrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dryRunResult: 'string',
      requestId: 'string',
      waitTimeCycle: 'string',
      waitTimeValue: 'number',
      waitingOrderId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingOrderResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateWaitingOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWaitingOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDedicatedHostClusterRequest extends $tea.Model {
  dedicatedHostClusterId?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      dedicatedHostClusterId: 'DedicatedHostClusterId',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedHostClusterId: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDedicatedHostClusterResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDedicatedHostClusterResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteDedicatedHostClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDedicatedHostClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEniQosGroupRequest extends $tea.Model {
  ownerId?: number;
  qosGroupName?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      qosGroupName: 'QosGroupName',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      qosGroupName: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEniQosGroupResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEniQosGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteEniQosGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteEniQosGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteImageCacheRequest extends $tea.Model {
  clientToken?: string;
  imageId?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      imageId: 'ImageId',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      imageId: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteImageCacheResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteImageCacheResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteImageCacheResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteImageCacheResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMigratableInstancesRequest extends $tea.Model {
  instanceId?: string[];
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: { 'type': 'array', 'itemType': 'string' },
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMigratableInstancesResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMigratableInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteMigratableInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMigratableInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNetworkInsightsAnalysisRequest extends $tea.Model {
  dryRun?: boolean;
  networkInsightsAnalysisId?: string[];
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      dryRun: 'DryRun',
      networkInsightsAnalysisId: 'NetworkInsightsAnalysisId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dryRun: 'boolean',
      networkInsightsAnalysisId: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNetworkInsightsAnalysisResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNetworkInsightsAnalysisResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteNetworkInsightsAnalysisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteNetworkInsightsAnalysisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNetworkInsightsPathRequest extends $tea.Model {
  dryRun?: boolean;
  networkInsightsPathId?: string[];
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      dryRun: 'DryRun',
      networkInsightsPathId: 'NetworkInsightsPathId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dryRun: 'boolean',
      networkInsightsPathId: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNetworkInsightsPathResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNetworkInsightsPathResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteNetworkInsightsPathResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteNetworkInsightsPathResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteReservationDemandRequest extends $tea.Model {
  demandId?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  tag?: DeleteReservationDemandRequestTag[];
  static names(): { [key: string]: string } {
    return {
      demandId: 'DemandId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      demandId: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      tag: { 'type': 'array', 'itemType': DeleteReservationDemandRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteReservationDemandResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteReservationDemandResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteReservationDemandResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteReservationDemandResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStorageSetRequest extends $tea.Model {
  clientToken?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  storageSetId?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      storageSetId: 'StorageSetId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      storageSetId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStorageSetResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStorageSetResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteStorageSetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteStorageSetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserQuotaApplicationRequest extends $tea.Model {
  applicationId?: string;
  clientToken?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      applicationId: 'ApplicationId',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationId: 'string',
      clientToken: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserQuotaApplicationResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserQuotaApplicationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteUserQuotaApplicationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteUserQuotaApplicationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaitingOrdersRequest extends $tea.Model {
  clientToken?: string;
  ownerAccount?: string;
  regionId?: string;
  resourceGroupId?: number;
  waitingOrderId?: string[];
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      waitingOrderId: 'WaitingOrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      ownerAccount: 'string',
      regionId: 'string',
      resourceGroupId: 'number',
      waitingOrderId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaitingOrdersResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaitingOrdersResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteWaitingOrdersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWaitingOrdersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountAttributesRequest extends $tea.Model {
  attributeName?: string[];
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      attributeName: 'AttributeName',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attributeName: { 'type': 'array', 'itemType': 'string' },
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountAttributesResponseBody extends $tea.Model {
  accountAttributeItems?: DescribeAccountAttributesResponseBodyAccountAttributeItems;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      accountAttributeItems: 'AccountAttributeItems',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountAttributeItems: DescribeAccountAttributesResponseBodyAccountAttributeItems,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountAttributesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAccountAttributesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAccountAttributesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountLimitsRequest extends $tea.Model {
  filter?: DescribeAccountLimitsRequestFilter[];
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      filter: 'Filter',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filter: { 'type': 'array', 'itemType': DescribeAccountLimitsRequestFilter },
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountLimitsResponseBody extends $tea.Model {
  accountLimitTypeSet?: DescribeAccountLimitsResponseBodyAccountLimitTypeSet;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      accountLimitTypeSet: 'AccountLimitTypeSet',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountLimitTypeSet: DescribeAccountLimitsResponseBodyAccountLimitTypeSet,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountLimitsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAccountLimitsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAccountLimitsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountQuotaAttributesRequest extends $tea.Model {
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountQuotaAttributesResponseBody extends $tea.Model {
  quotaAttributes?: DescribeAccountQuotaAttributesResponseBodyQuotaAttributes;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      quotaAttributes: 'QuotaAttributes',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quotaAttributes: DescribeAccountQuotaAttributesResponseBodyQuotaAttributes,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountQuotaAttributesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAccountQuotaAttributesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAccountQuotaAttributesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupCapacitiesRequest extends $tea.Model {
  autoProvisioningGroupId?: string[];
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      autoProvisioningGroupId: 'AutoProvisioningGroupId',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoProvisioningGroupId: { 'type': 'array', 'itemType': 'string' },
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupCapacitiesResponseBody extends $tea.Model {
  capacities?: DescribeAutoProvisioningGroupCapacitiesResponseBodyCapacities;
  code?: string;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      capacities: 'Capacities',
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacities: DescribeAutoProvisioningGroupCapacitiesResponseBodyCapacities,
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupCapacitiesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAutoProvisioningGroupCapacitiesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAutoProvisioningGroupCapacitiesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBandwidthPriceRequest extends $tea.Model {
  ownerAccount?: string;
  ownerId?: number;
  priceUnit?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  verbose?: boolean;
  static names(): { [key: string]: string } {
    return {
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      priceUnit: 'PriceUnit',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      verbose: 'Verbose',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerAccount: 'string',
      ownerId: 'number',
      priceUnit: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      verbose: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBandwidthPriceResponseBody extends $tea.Model {
  priceInfo?: DescribeBandwidthPriceResponseBodyPriceInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      priceInfo: 'PriceInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      priceInfo: DescribeBandwidthPriceResponseBodyPriceInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBandwidthPriceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeBandwidthPriceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBandwidthPriceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCapacityReservationsRequest extends $tea.Model {
  capacityReservationIds?: string;
  capacityReservationName?: string;
  ownerAccount?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  status?: string;
  tag?: DescribeCapacityReservationsRequestTag[];
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      capacityReservationIds: 'CapacityReservationIds',
      capacityReservationName: 'CapacityReservationName',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      status: 'Status',
      tag: 'Tag',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityReservationIds: 'string',
      capacityReservationName: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      status: 'string',
      tag: { 'type': 'array', 'itemType': DescribeCapacityReservationsRequestTag },
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCapacityReservationsResponseBody extends $tea.Model {
  capacityReservations?: DescribeCapacityReservationsResponseBodyCapacityReservations;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      capacityReservations: 'CapacityReservations',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityReservations: DescribeCapacityReservationsResponseBodyCapacityReservations,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCapacityReservationsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCapacityReservationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCapacityReservationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomerIssueCategoryRequest extends $tea.Model {
  layer?: number;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      layer: 'Layer',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      layer: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomerIssueCategoryResponseBody extends $tea.Model {
  issueCategoryModelList?: DescribeCustomerIssueCategoryResponseBodyIssueCategoryModelList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      issueCategoryModelList: 'IssueCategoryModelList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      issueCategoryModelList: { 'type': 'array', 'itemType': DescribeCustomerIssueCategoryResponseBodyIssueCategoryModelList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomerIssueCategoryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCustomerIssueCategoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCustomerIssueCategoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostAutoRenewRequest extends $tea.Model {
  instanceIds?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      instanceIds: 'InstanceIds',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      resourceType: 'ResourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceIds: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostAutoRenewResponseBody extends $tea.Model {
  instanceRenewAttributes?: DescribeDedicatedHostAutoRenewResponseBodyInstanceRenewAttributes;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceRenewAttributes: 'InstanceRenewAttributes',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceRenewAttributes: DescribeDedicatedHostAutoRenewResponseBodyInstanceRenewAttributes,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostAutoRenewResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeDedicatedHostAutoRenewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDedicatedHostAutoRenewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersRequest extends $tea.Model {
  schedulerOptions?: DescribeDedicatedHostClustersRequestSchedulerOptions;
  dedicatedHostClusterIds?: string;
  dedicatedHostClusterName?: string;
  lockReason?: string;
  ownerAccount?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  status?: string;
  tag?: DescribeDedicatedHostClustersRequestTag[];
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      schedulerOptions: 'SchedulerOptions',
      dedicatedHostClusterIds: 'DedicatedHostClusterIds',
      dedicatedHostClusterName: 'DedicatedHostClusterName',
      lockReason: 'LockReason',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      status: 'Status',
      tag: 'Tag',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      schedulerOptions: DescribeDedicatedHostClustersRequestSchedulerOptions,
      dedicatedHostClusterIds: 'string',
      dedicatedHostClusterName: 'string',
      lockReason: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      status: 'string',
      tag: { 'type': 'array', 'itemType': DescribeDedicatedHostClustersRequestTag },
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersResponseBody extends $tea.Model {
  dedicatedHostClusters?: DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dedicatedHostClusters: 'DedicatedHostClusters',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedHostClusters: DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeDedicatedHostClustersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDedicatedHostClustersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostTypesRequest extends $tea.Model {
  dedicatedHostType?: string;
  generation?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  supportInstanceTypeFamily?: string;
  static names(): { [key: string]: string } {
    return {
      dedicatedHostType: 'DedicatedHostType',
      generation: 'Generation',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      supportInstanceTypeFamily: 'SupportInstanceTypeFamily',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedHostType: 'string',
      generation: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      supportInstanceTypeFamily: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostTypesResponseBody extends $tea.Model {
  dedicatedHostTypes?: DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      dedicatedHostTypes: 'DedicatedHostTypes',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedHostTypes: DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostTypesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeDedicatedHostTypesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDedicatedHostTypesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsRequest extends $tea.Model {
  schedulerOptions?: DescribeDedicatedHostsRequestSchedulerOptions;
  dedicatedHostClusterId?: string;
  dedicatedHostIds?: string;
  dedicatedHostName?: string;
  dedicatedHostType?: string;
  lockReason?: string;
  ownerAccount?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  status?: string;
  tag?: DescribeDedicatedHostsRequestTag[];
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      schedulerOptions: 'SchedulerOptions',
      dedicatedHostClusterId: 'DedicatedHostClusterId',
      dedicatedHostIds: 'DedicatedHostIds',
      dedicatedHostName: 'DedicatedHostName',
      dedicatedHostType: 'DedicatedHostType',
      lockReason: 'LockReason',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      status: 'Status',
      tag: 'Tag',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      schedulerOptions: DescribeDedicatedHostsRequestSchedulerOptions,
      dedicatedHostClusterId: 'string',
      dedicatedHostIds: 'string',
      dedicatedHostName: 'string',
      dedicatedHostType: 'string',
      lockReason: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      status: 'string',
      tag: { 'type': 'array', 'itemType': DescribeDedicatedHostsRequestTag },
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBody extends $tea.Model {
  dedicatedHosts?: DescribeDedicatedHostsResponseBodyDedicatedHosts;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dedicatedHosts: 'DedicatedHosts',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedHosts: DescribeDedicatedHostsResponseBodyDedicatedHosts,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeDedicatedHostsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDedicatedHostsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnoseRequest extends $tea.Model {
  diagnoseAction?: string;
  diagnoseId?: string;
  ownerAccount?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  status?: number;
  tag?: DescribeDiagnoseRequestTag[];
  type?: number;
  static names(): { [key: string]: string } {
    return {
      diagnoseAction: 'DiagnoseAction',
      diagnoseId: 'DiagnoseId',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      status: 'Status',
      tag: 'Tag',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diagnoseAction: 'string',
      diagnoseId: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      status: 'number',
      tag: { 'type': 'array', 'itemType': DescribeDiagnoseRequestTag },
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnoseResponseBody extends $tea.Model {
  diagnoseInstances?: DescribeDiagnoseResponseBodyDiagnoseInstances;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      diagnoseInstances: 'DiagnoseInstances',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diagnoseInstances: DescribeDiagnoseResponseBodyDiagnoseInstances,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnoseResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeDiagnoseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDiagnoseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnosisOperateRecordsRequest extends $tea.Model {
  errorCode?: string;
  instanceType?: string;
  operateRecordType?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  payType?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      instanceType: 'InstanceType',
      operateRecordType: 'OperateRecordType',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      payType: 'PayType',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      instanceType: 'string',
      operateRecordType: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      payType: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnosisOperateRecordsResponseBody extends $tea.Model {
  diagnosisOperateRecordModels?: DescribeDiagnosisOperateRecordsResponseBodyDiagnosisOperateRecordModels[];
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      diagnosisOperateRecordModels: 'DiagnosisOperateRecordModels',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diagnosisOperateRecordModels: { 'type': 'array', 'itemType': DescribeDiagnosisOperateRecordsResponseBodyDiagnosisOperateRecordModels },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnosisOperateRecordsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeDiagnosisOperateRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDiagnosisOperateRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnosticReportsRequest extends $tea.Model {
  maxResults?: number;
  nextToken?: string;
  ownerId?: number;
  regionId?: string;
  reportId?: string[];
  resourceId?: string[];
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  resourceType?: string;
  severity?: string;
  sourceSystem?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      reportId: 'ReportId',
      resourceId: 'ResourceId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      resourceType: 'ResourceType',
      severity: 'Severity',
      sourceSystem: 'SourceSystem',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      ownerId: 'number',
      regionId: 'string',
      reportId: { 'type': 'array', 'itemType': 'string' },
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      resourceType: 'string',
      severity: 'string',
      sourceSystem: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnosticReportsResponseBody extends $tea.Model {
  maxResults?: number;
  nextToken?: string;
  reports?: DescribeDiagnosticReportsResponseBodyReports;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      reports: 'Reports',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      reports: DescribeDiagnosticReportsResponseBodyReports,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnosticReportsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeDiagnosticReportsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDiagnosticReportsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiskReplicaPairsRequest extends $tea.Model {
  maxResults?: number;
  nextToken?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiskReplicaPairsResponseBody extends $tea.Model {
  diskReplicaPairs?: DescribeDiskReplicaPairsResponseBodyDiskReplicaPairs;
  nextToken?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      diskReplicaPairs: 'DiskReplicaPairs',
      nextToken: 'NextToken',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskReplicaPairs: DescribeDiskReplicaPairsResponseBodyDiskReplicaPairs,
      nextToken: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiskReplicaPairsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeDiskReplicaPairsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDiskReplicaPairsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEcsScenarioFacadeRequest extends $tea.Model {
  extMap?: { [key: string]: string };
  extParam?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerId?: number;
  scenarioList?: DescribeEcsScenarioFacadeRequestScenarioList[];
  static names(): { [key: string]: string } {
    return {
      extMap: 'ExtMap',
      extParam: 'ExtParam',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      scenarioList: 'ScenarioList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      extParam: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
      scenarioList: { 'type': 'array', 'itemType': DescribeEcsScenarioFacadeRequestScenarioList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEcsScenarioFacadeResponseBody extends $tea.Model {
  requestId?: string;
  scenarios?: DescribeEcsScenarioFacadeResponseBodyScenarios[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      scenarios: 'Scenarios',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      scenarios: { 'type': 'array', 'itemType': DescribeEcsScenarioFacadeResponseBodyScenarios },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEcsScenarioFacadeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeEcsScenarioFacadeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEcsScenarioFacadeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEniQosGroupInfoRequest extends $tea.Model {
  ownerId?: number;
  qosGroupName?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      qosGroupName: 'QosGroupName',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      qosGroupName: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEniQosGroupInfoResponseBody extends $tea.Model {
  qosGroupInfo?: DescribeEniQosGroupInfoResponseBodyQosGroupInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      qosGroupInfo: 'QosGroupInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qosGroupInfo: DescribeEniQosGroupInfoResponseBodyQosGroupInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEniQosGroupInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeEniQosGroupInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEniQosGroupInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFunctionFeedbackRequest extends $tea.Model {
  category?: string;
  feedback?: string;
  functionName?: string[];
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      feedback: 'Feedback',
      functionName: 'FunctionName',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      feedback: 'string',
      functionName: { 'type': 'array', 'itemType': 'string' },
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFunctionFeedbackResponseBody extends $tea.Model {
  data?: DescribeFunctionFeedbackResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeFunctionFeedbackResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFunctionFeedbackResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeFunctionFeedbackResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeFunctionFeedbackResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHavsInstanceTypesRequest extends $tea.Model {
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHavsInstanceTypesResponseBody extends $tea.Model {
  describeHavsInstanceTypesResponse?: DescribeHavsInstanceTypesResponseBodyDescribeHavsInstanceTypesResponse;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      describeHavsInstanceTypesResponse: 'DescribeHavsInstanceTypesResponse',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      describeHavsInstanceTypesResponse: DescribeHavsInstanceTypesResponseBodyDescribeHavsInstanceTypesResponse,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHavsInstanceTypesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeHavsInstanceTypesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeHavsInstanceTypesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageAgreementRequest extends $tea.Model {
  agreementType?: string;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      agreementType: 'AgreementType',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      agreementType: 'string',
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageAgreementResponseBody extends $tea.Model {
  requestId?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageAgreementResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageAgreementResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageAgreementResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageCachesRequest extends $tea.Model {
  clientToken?: string;
  imageId?: string;
  maxResults?: number;
  nextToken?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      imageId: 'ImageId',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      imageId: 'string',
      maxResults: 'number',
      nextToken: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageCachesResponseBody extends $tea.Model {
  imageCaches?: DescribeImageCachesResponseBodyImageCaches;
  nextToken?: string;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      imageCaches: 'ImageCaches',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageCaches: DescribeImageCachesResponseBodyImageCaches,
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageCachesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageCachesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageCachesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageFamiliesRequest extends $tea.Model {
  ownerAccount?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerAccount: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageFamiliesResponseBody extends $tea.Model {
  imageFamilies?: DescribeImageFamiliesResponseBodyImageFamilies;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      imageFamilies: 'ImageFamilies',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageFamilies: DescribeImageFamiliesResponseBodyImageFamilies,
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageFamiliesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageFamiliesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageFamiliesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAutoRebootTimeRequest extends $tea.Model {
  autoRebootTimeFrom?: string;
  autoRebootTimeTo?: string;
  instanceIds?: string[];
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      autoRebootTimeFrom: 'AutoRebootTimeFrom',
      autoRebootTimeTo: 'AutoRebootTimeTo',
      instanceIds: 'InstanceIds',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRebootTimeFrom: 'string',
      autoRebootTimeTo: 'string',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAutoRebootTimeResponseBody extends $tea.Model {
  autoRebootInfos?: DescribeInstanceAutoRebootTimeResponseBodyAutoRebootInfos;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      autoRebootInfos: 'AutoRebootInfos',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRebootInfos: DescribeInstanceAutoRebootTimeResponseBodyAutoRebootInfos,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAutoRebootTimeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeInstanceAutoRebootTimeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceAutoRebootTimeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceHealthStatusRequest extends $tea.Model {
  instanceId?: string[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceHealthStatusResponseBody extends $tea.Model {
  healthStatusModel?: DescribeInstanceHealthStatusResponseBodyHealthStatusModel[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      healthStatusModel: 'HealthStatusModel',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      healthStatusModel: { 'type': 'array', 'itemType': DescribeInstanceHealthStatusResponseBodyHealthStatusModel },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceHealthStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeInstanceHealthStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceHealthStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceMaintenanceAttributesRequest extends $tea.Model {
  instanceId?: string[];
  ownerAccount?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: { 'type': 'array', 'itemType': 'string' },
      ownerAccount: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceMaintenanceAttributesResponseBody extends $tea.Model {
  maintenanceAttributes?: DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      maintenanceAttributes: 'MaintenanceAttributes',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maintenanceAttributes: DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceMaintenanceAttributesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeInstanceMaintenanceAttributesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceMaintenanceAttributesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceModificationPriceRequest extends $tea.Model {
  systemDisk?: DescribeInstanceModificationPriceRequestSystemDisk;
  dataDisk?: DescribeInstanceModificationPriceRequestDataDisk[];
  instanceId?: string;
  instanceType?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      systemDisk: 'SystemDisk',
      dataDisk: 'DataDisk',
      instanceId: 'InstanceId',
      instanceType: 'InstanceType',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      systemDisk: DescribeInstanceModificationPriceRequestSystemDisk,
      dataDisk: { 'type': 'array', 'itemType': DescribeInstanceModificationPriceRequestDataDisk },
      instanceId: 'string',
      instanceType: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceModificationPriceResponseBody extends $tea.Model {
  priceInfo?: DescribeInstanceModificationPriceResponseBodyPriceInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      priceInfo: 'PriceInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      priceInfo: DescribeInstanceModificationPriceResponseBodyPriceInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceModificationPriceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeInstanceModificationPriceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceModificationPriceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceNeedRebootRequest extends $tea.Model {
  instanceIds?: string[];
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      instanceIds: 'InstanceIds',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceNeedRebootResponseBody extends $tea.Model {
  instanceInfo?: DescribeInstanceNeedRebootResponseBodyInstanceInfo;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      instanceInfo: 'InstanceInfo',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceInfo: DescribeInstanceNeedRebootResponseBodyInstanceInfo,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceNeedRebootResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeInstanceNeedRebootResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceNeedRebootResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancePerformanceRestrictHistoryRequest extends $tea.Model {
  instanceId?: string[];
  ownerAccount?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: { 'type': 'array', 'itemType': 'string' },
      ownerAccount: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancePerformanceRestrictHistoryResponseBody extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  performanceRestrictHistories?: DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistories;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      performanceRestrictHistories: 'PerformanceRestrictHistories',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      performanceRestrictHistories: DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistories,
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancePerformanceRestrictHistoryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeInstancePerformanceRestrictHistoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstancePerformanceRestrictHistoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTypeResourceRequest extends $tea.Model {
  cores?: number;
  instanceTypeFamilies?: string[];
  instanceTypeMatchMode?: string;
  instanceTypes?: string[];
  memories?: number[];
  ownerAccount?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  searchTypes?: string[];
  zoneIds?: string[];
  static names(): { [key: string]: string } {
    return {
      cores: 'Cores',
      instanceTypeFamilies: 'InstanceTypeFamilies',
      instanceTypeMatchMode: 'InstanceTypeMatchMode',
      instanceTypes: 'InstanceTypes',
      memories: 'Memories',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      searchTypes: 'SearchTypes',
      zoneIds: 'ZoneIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cores: 'number',
      instanceTypeFamilies: { 'type': 'array', 'itemType': 'string' },
      instanceTypeMatchMode: 'string',
      instanceTypes: { 'type': 'array', 'itemType': 'string' },
      memories: { 'type': 'array', 'itemType': 'number' },
      ownerAccount: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      searchTypes: { 'type': 'array', 'itemType': 'string' },
      zoneIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTypeResourceResponseBody extends $tea.Model {
  instanceTypeResources?: DescribeInstanceTypeResourceResponseBodyInstanceTypeResources;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      instanceTypeResources: 'InstanceTypeResources',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceTypeResources: DescribeInstanceTypeResourceResponseBodyInstanceTypeResources,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTypeResourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeInstanceTypeResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceTypeResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeKMSKeyAttributeRequest extends $tea.Model {
  KMSKeyId?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  appKey?: string;
  channel?: string;
  operator?: string;
  proxyId?: string;
  token?: string;
  static names(): { [key: string]: string } {
    return {
      KMSKeyId: 'KMSKeyId',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      appKey: 'appKey',
      channel: 'channel',
      operator: 'operator',
      proxyId: 'proxyId',
      token: 'token',
    };
  }

  static types(): { [key: string]: any } {
    return {
      KMSKeyId: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      appKey: 'string',
      channel: 'string',
      operator: 'string',
      proxyId: 'string',
      token: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeKMSKeyAttributeResponseBody extends $tea.Model {
  alias?: string;
  creator?: string;
  ecsTagged?: boolean;
  KMSKeyId?: string;
  requestId?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      creator: 'Creator',
      ecsTagged: 'EcsTagged',
      KMSKeyId: 'KMSKeyId',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      creator: 'string',
      ecsTagged: 'boolean',
      KMSKeyId: 'string',
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeKMSKeyAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeKMSKeyAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeKMSKeyAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeKMSKeysRequest extends $tea.Model {
  ownerAccount?: string;
  ownerId?: number;
  pageNumber?: string;
  pageSize?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  appKey?: string;
  channel?: string;
  operator?: string;
  proxyId?: string;
  token?: string;
  static names(): { [key: string]: string } {
    return {
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      appKey: 'appKey',
      channel: 'channel',
      operator: 'operator',
      proxyId: 'proxyId',
      token: 'token',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerAccount: 'string',
      ownerId: 'number',
      pageNumber: 'string',
      pageSize: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      appKey: 'string',
      channel: 'string',
      operator: 'string',
      proxyId: 'string',
      token: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeKMSKeysResponseBody extends $tea.Model {
  KMSKeyIds?: DescribeKMSKeysResponseBodyKMSKeyIds;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      KMSKeyIds: 'KMSKeyIds',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      KMSKeyIds: DescribeKMSKeysResponseBodyKMSKeyIds,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeKMSKeysResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeKMSKeysResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeKMSKeysResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLinkedKMSKeysRequest extends $tea.Model {
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  appKey?: string;
  channel?: string;
  operator?: string;
  proxyId?: string;
  token?: string;
  static names(): { [key: string]: string } {
    return {
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      appKey: 'appKey',
      channel: 'channel',
      operator: 'operator',
      proxyId: 'proxyId',
      token: 'token',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      appKey: 'string',
      channel: 'string',
      operator: 'string',
      proxyId: 'string',
      token: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLinkedKMSKeysResponseBody extends $tea.Model {
  KMSKeys?: DescribeLinkedKMSKeysResponseBodyKMSKeys;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      KMSKeys: 'KMSKeys',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      KMSKeys: DescribeLinkedKMSKeysResponseBodyKMSKeys,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLinkedKMSKeysResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLinkedKMSKeysResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLinkedKMSKeysResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLocalDiskRepairActivitiesRequest extends $tea.Model {
  diskId?: string[];
  includeHistory?: boolean;
  instanceId?: string[];
  ownerAccount?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      diskId: 'DiskId',
      includeHistory: 'IncludeHistory',
      instanceId: 'InstanceId',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskId: { 'type': 'array', 'itemType': 'string' },
      includeHistory: 'boolean',
      instanceId: { 'type': 'array', 'itemType': 'string' },
      ownerAccount: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLocalDiskRepairActivitiesResponseBody extends $tea.Model {
  localDiskRepairActivities?: DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivities;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      localDiskRepairActivities: 'LocalDiskRepairActivities',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      localDiskRepairActivities: DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivities,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLocalDiskRepairActivitiesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLocalDiskRepairActivitiesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLocalDiskRepairActivitiesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMigrationInstancesRequest extends $tea.Model {
  businessMigrationType?: string;
  hostname?: string;
  instanceId?: string[];
  migrationPlanId?: string;
  migrationStatus?: string;
  networkMigrationType?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  tag?: DescribeMigrationInstancesRequestTag[];
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      businessMigrationType: 'BusinessMigrationType',
      hostname: 'Hostname',
      instanceId: 'InstanceId',
      migrationPlanId: 'MigrationPlanId',
      migrationStatus: 'MigrationStatus',
      networkMigrationType: 'NetworkMigrationType',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      tag: 'Tag',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessMigrationType: 'string',
      hostname: 'string',
      instanceId: { 'type': 'array', 'itemType': 'string' },
      migrationPlanId: 'string',
      migrationStatus: 'string',
      networkMigrationType: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      tag: { 'type': 'array', 'itemType': DescribeMigrationInstancesRequestTag },
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMigrationInstancesResponseBody extends $tea.Model {
  migrationInstanceSet?: DescribeMigrationInstancesResponseBodyMigrationInstanceSet;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      migrationInstanceSet: 'MigrationInstanceSet',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      migrationInstanceSet: DescribeMigrationInstancesResponseBodyMigrationInstanceSet,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMigrationInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeMigrationInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMigrationInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMigrationPlansRequest extends $tea.Model {
  migrationPlanId?: string;
  name?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  status?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      migrationPlanId: 'MigrationPlanId',
      name: 'Name',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      migrationPlanId: 'string',
      name: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMigrationPlansResponseBody extends $tea.Model {
  migrationPlanSet?: DescribeMigrationPlansResponseBodyMigrationPlanSet;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      migrationPlanSet: 'MigrationPlanSet',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      migrationPlanSet: DescribeMigrationPlansResponseBodyMigrationPlanSet,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMigrationPlansResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeMigrationPlansResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMigrationPlansResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMigrationPreferencesRequest extends $tea.Model {
  migrationNetworkType?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      migrationNetworkType: 'MigrationNetworkType',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      migrationNetworkType: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMigrationPreferencesResponseBody extends $tea.Model {
  migrationNetworkType?: string;
  regionId?: string;
  requestId?: string;
  targetZoneIdSet?: DescribeMigrationPreferencesResponseBodyTargetZoneIdSet;
  static names(): { [key: string]: string } {
    return {
      migrationNetworkType: 'MigrationNetworkType',
      regionId: 'RegionId',
      requestId: 'RequestId',
      targetZoneIdSet: 'TargetZoneIdSet',
    };
  }

  static types(): { [key: string]: any } {
    return {
      migrationNetworkType: 'string',
      regionId: 'string',
      requestId: 'string',
      targetZoneIdSet: DescribeMigrationPreferencesResponseBodyTargetZoneIdSet,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMigrationPreferencesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeMigrationPreferencesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMigrationPreferencesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisResultRequest extends $tea.Model {
  dryRun?: boolean;
  networkInsightsAnalysisId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      dryRun: 'DryRun',
      networkInsightsAnalysisId: 'NetworkInsightsAnalysisId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dryRun: 'boolean',
      networkInsightsAnalysisId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisResultResponseBody extends $tea.Model {
  creationTime?: string;
  destination?: string;
  destinationIp?: string;
  destinationPort?: string;
  destinationType?: string;
  networkInsightsAnalysisComponents?: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponents;
  networkInsightsAnalysisId?: string;
  networkInsightsPathId?: string;
  networkPathFound?: string;
  protocol?: string;
  requestId?: string;
  source?: string;
  sourceIp?: string;
  sourceType?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      destination: 'Destination',
      destinationIp: 'DestinationIp',
      destinationPort: 'DestinationPort',
      destinationType: 'DestinationType',
      networkInsightsAnalysisComponents: 'NetworkInsightsAnalysisComponents',
      networkInsightsAnalysisId: 'NetworkInsightsAnalysisId',
      networkInsightsPathId: 'NetworkInsightsPathId',
      networkPathFound: 'NetworkPathFound',
      protocol: 'Protocol',
      requestId: 'RequestId',
      source: 'Source',
      sourceIp: 'SourceIp',
      sourceType: 'SourceType',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      destination: 'string',
      destinationIp: 'string',
      destinationPort: 'string',
      destinationType: 'string',
      networkInsightsAnalysisComponents: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponents,
      networkInsightsAnalysisId: 'string',
      networkInsightsPathId: 'string',
      networkPathFound: 'string',
      protocol: 'string',
      requestId: 'string',
      source: 'string',
      sourceIp: 'string',
      sourceType: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeNetworkInsightsAnalysisResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeNetworkInsightsAnalysisResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisesRequest extends $tea.Model {
  dryRun?: boolean;
  maxResults?: number;
  networkInsightsAnalysisId?: string[];
  networkInsightsPathId?: string;
  networkPathFound?: string;
  nextToken?: string;
  regionId?: string;
  resourceOwnerId?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      dryRun: 'DryRun',
      maxResults: 'MaxResults',
      networkInsightsAnalysisId: 'NetworkInsightsAnalysisId',
      networkInsightsPathId: 'NetworkInsightsPathId',
      networkPathFound: 'NetworkPathFound',
      nextToken: 'NextToken',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dryRun: 'boolean',
      maxResults: 'number',
      networkInsightsAnalysisId: { 'type': 'array', 'itemType': 'string' },
      networkInsightsPathId: 'string',
      networkPathFound: 'string',
      nextToken: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisesResponseBody extends $tea.Model {
  maxResults?: number;
  networkInsightsAnalysisSets?: DescribeNetworkInsightsAnalysisesResponseBodyNetworkInsightsAnalysisSets;
  nextToken?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      networkInsightsAnalysisSets: 'NetworkInsightsAnalysisSets',
      nextToken: 'NextToken',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      networkInsightsAnalysisSets: DescribeNetworkInsightsAnalysisesResponseBodyNetworkInsightsAnalysisSets,
      nextToken: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeNetworkInsightsAnalysisesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeNetworkInsightsAnalysisesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsPathsRequest extends $tea.Model {
  dryRun?: boolean;
  maxResults?: number;
  networkInsightsPathId?: string[];
  networkPathFound?: string;
  nextToken?: string;
  regionId?: string;
  resourceOwnerId?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      dryRun: 'DryRun',
      maxResults: 'MaxResults',
      networkInsightsPathId: 'NetworkInsightsPathId',
      networkPathFound: 'NetworkPathFound',
      nextToken: 'NextToken',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dryRun: 'boolean',
      maxResults: 'number',
      networkInsightsPathId: { 'type': 'array', 'itemType': 'string' },
      networkPathFound: 'string',
      nextToken: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsPathsResponseBody extends $tea.Model {
  maxResults?: number;
  networkInsightsPathSets?: DescribeNetworkInsightsPathsResponseBodyNetworkInsightsPathSets;
  nextToken?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      networkInsightsPathSets: 'NetworkInsightsPathSets',
      nextToken: 'NextToken',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      networkInsightsPathSets: DescribeNetworkInsightsPathsResponseBodyNetworkInsightsPathSets,
      nextToken: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsPathsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeNetworkInsightsPathsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeNetworkInsightsPathsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrderAutoRebootTimeRequest extends $tea.Model {
  orderId?: number;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrderAutoRebootTimeResponseBody extends $tea.Model {
  describeOrderAutoRebootTimeInfo?: DescribeOrderAutoRebootTimeResponseBodyDescribeOrderAutoRebootTimeInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      describeOrderAutoRebootTimeInfo: 'DescribeOrderAutoRebootTimeInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      describeOrderAutoRebootTimeInfo: DescribeOrderAutoRebootTimeResponseBodyDescribeOrderAutoRebootTimeInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrderAutoRebootTimeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeOrderAutoRebootTimeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOrderAutoRebootTimeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePrePaidResourceRefundPriceRequest extends $tea.Model {
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      resourceType: 'ResourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePrePaidResourceRefundPriceResponseBody extends $tea.Model {
  currency?: string;
  refunds?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      currency: 'Currency',
      refunds: 'Refunds',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currency: 'string',
      refunds: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePrePaidResourceRefundPriceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribePrePaidResourceRefundPriceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePrePaidResourceRefundPriceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceRequest extends $tea.Model {
  businessInfo?: string;
  commodity?: string;
  defaultVpc?: string;
  fromApp?: string;
  needSpotPrice?: boolean;
  networkType?: string;
  orderType?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  verbose?: boolean;
  static names(): { [key: string]: string } {
    return {
      businessInfo: 'BusinessInfo',
      commodity: 'Commodity',
      defaultVpc: 'DefaultVpc',
      fromApp: 'FromApp',
      needSpotPrice: 'NeedSpotPrice',
      networkType: 'NetworkType',
      orderType: 'OrderType',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      verbose: 'Verbose',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessInfo: 'string',
      commodity: 'string',
      defaultVpc: 'string',
      fromApp: 'string',
      needSpotPrice: 'boolean',
      networkType: 'string',
      orderType: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      verbose: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBody extends $tea.Model {
  priceInfo?: DescribePriceResponseBodyPriceInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      priceInfo: 'PriceInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      priceInfo: DescribePriceResponseBodyPriceInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribePriceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePriceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePrivatePoolsRequest extends $tea.Model {
  privatePoolOptions?: DescribePrivatePoolsRequestPrivatePoolOptions;
  instanceChargeType?: string;
  instanceType?: string;
  maxResults?: number;
  nextToken?: string;
  ownerAccount?: string;
  ownerId?: number;
  platform?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  startTimeType?: string;
  status?: string;
  tag?: DescribePrivatePoolsRequestTag[];
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      privatePoolOptions: 'PrivatePoolOptions',
      instanceChargeType: 'InstanceChargeType',
      instanceType: 'InstanceType',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      platform: 'Platform',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      startTimeType: 'StartTimeType',
      status: 'Status',
      tag: 'Tag',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      privatePoolOptions: DescribePrivatePoolsRequestPrivatePoolOptions,
      instanceChargeType: 'string',
      instanceType: 'string',
      maxResults: 'number',
      nextToken: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      platform: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      startTimeType: 'string',
      status: 'string',
      tag: { 'type': 'array', 'itemType': DescribePrivatePoolsRequestTag },
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePrivatePoolsResponseBody extends $tea.Model {
  maxResults?: number;
  nextToken?: string;
  privatePoolSet?: DescribePrivatePoolsResponseBodyPrivatePoolSet;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      privatePoolSet: 'PrivatePoolSet',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      privatePoolSet: DescribePrivatePoolsResponseBodyPrivatePoolSet,
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePrivatePoolsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribePrivatePoolsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePrivatePoolsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendProductRequest extends $tea.Model {
  amount?: number;
  cores?: number;
  instanceChargeType?: string;
  instanceFamilyLevel?: string;
  instanceType?: string;
  instanceTypeFamily?: string[];
  instanceTypeSupportIPv6?: boolean;
  ioOptimized?: string;
  maxPrice?: number;
  memory?: number;
  networkType?: string;
  ownerAccount?: string;
  ownerId?: number;
  priorityStrategy?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  spotStrategy?: string;
  systemDiskCategory?: string;
  zoneId?: string;
  zoneMatchMode?: string;
  static names(): { [key: string]: string } {
    return {
      amount: 'Amount',
      cores: 'Cores',
      instanceChargeType: 'InstanceChargeType',
      instanceFamilyLevel: 'InstanceFamilyLevel',
      instanceType: 'InstanceType',
      instanceTypeFamily: 'InstanceTypeFamily',
      instanceTypeSupportIPv6: 'InstanceTypeSupportIPv6',
      ioOptimized: 'IoOptimized',
      maxPrice: 'MaxPrice',
      memory: 'Memory',
      networkType: 'NetworkType',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      priorityStrategy: 'PriorityStrategy',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      spotStrategy: 'SpotStrategy',
      systemDiskCategory: 'SystemDiskCategory',
      zoneId: 'ZoneId',
      zoneMatchMode: 'ZoneMatchMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      amount: 'number',
      cores: 'number',
      instanceChargeType: 'string',
      instanceFamilyLevel: 'string',
      instanceType: 'string',
      instanceTypeFamily: { 'type': 'array', 'itemType': 'string' },
      instanceTypeSupportIPv6: 'boolean',
      ioOptimized: 'string',
      maxPrice: 'number',
      memory: 'number',
      networkType: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      priorityStrategy: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      spotStrategy: 'string',
      systemDiskCategory: 'string',
      zoneId: 'string',
      zoneMatchMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendProductResponseBody extends $tea.Model {
  recommendProducts?: DescribeRecommendProductResponseBodyRecommendProducts;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recommendProducts: 'RecommendProducts',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recommendProducts: DescribeRecommendProductResponseBodyRecommendProducts,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendProductResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeRecommendProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRecommendProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservationDemandCommittedAmountRequest extends $tea.Model {
  demandPlan?: DescribeReservationDemandCommittedAmountRequestDemandPlan[];
  instanceFamily?: string;
  instanceFamilySet?: string;
  offeringType?: string;
  ownerAccount?: string;
  ownerId?: number;
  period?: number;
  periodUnit?: string;
  planType?: string;
  platform?: string;
  purchaseMethod?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      demandPlan: 'DemandPlan',
      instanceFamily: 'InstanceFamily',
      instanceFamilySet: 'InstanceFamilySet',
      offeringType: 'OfferingType',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      planType: 'PlanType',
      platform: 'Platform',
      purchaseMethod: 'PurchaseMethod',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      demandPlan: { 'type': 'array', 'itemType': DescribeReservationDemandCommittedAmountRequestDemandPlan },
      instanceFamily: 'string',
      instanceFamilySet: 'string',
      offeringType: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      period: 'number',
      periodUnit: 'string',
      planType: 'string',
      platform: 'string',
      purchaseMethod: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservationDemandCommittedAmountResponseBody extends $tea.Model {
  committedAmountInfo?: DescribeReservationDemandCommittedAmountResponseBodyCommittedAmountInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      committedAmountInfo: 'CommittedAmountInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      committedAmountInfo: DescribeReservationDemandCommittedAmountResponseBodyCommittedAmountInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservationDemandCommittedAmountResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeReservationDemandCommittedAmountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeReservationDemandCommittedAmountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservationDemandsRequest extends $tea.Model {
  demandId?: string[];
  maxResults?: number;
  nextToken?: string;
  ownerAccount?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  status?: string;
  tag?: DescribeReservationDemandsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      demandId: 'DemandId',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      status: 'Status',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      demandId: { 'type': 'array', 'itemType': 'string' },
      maxResults: 'number',
      nextToken: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      status: 'string',
      tag: { 'type': 'array', 'itemType': DescribeReservationDemandsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservationDemandsResponseBody extends $tea.Model {
  data?: DescribeReservationDemandsResponseBodyData;
  nextToken?: string;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeReservationDemandsResponseBodyData,
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservationDemandsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeReservationDemandsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeReservationDemandsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstanceAllocationsRequest extends $tea.Model {
  ownerAccount?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  reservedInstanceId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  tag?: DescribeReservedInstanceAllocationsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      reservedInstanceId: 'ReservedInstanceId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerAccount: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      reservedInstanceId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      tag: { 'type': 'array', 'itemType': DescribeReservedInstanceAllocationsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstanceAllocationsResponseBody extends $tea.Model {
  allocations?: DescribeReservedInstanceAllocationsResponseBodyAllocations;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      allocations: 'Allocations',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allocations: DescribeReservedInstanceAllocationsResponseBodyAllocations,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstanceAllocationsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeReservedInstanceAllocationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeReservedInstanceAllocationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstanceCategoriesRequest extends $tea.Model {
  ownerAccount?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  scope?: string;
  tag?: DescribeReservedInstanceCategoriesRequestTag[];
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      scope: 'Scope',
      tag: 'Tag',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerAccount: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      scope: 'string',
      tag: { 'type': 'array', 'itemType': DescribeReservedInstanceCategoriesRequestTag },
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstanceCategoriesResponseBody extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  reservedInstanceCategories?: DescribeReservedInstanceCategoriesResponseBodyReservedInstanceCategories;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      reservedInstanceCategories: 'ReservedInstanceCategories',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      reservedInstanceCategories: DescribeReservedInstanceCategoriesResponseBodyReservedInstanceCategories,
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstanceCategoriesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeReservedInstanceCategoriesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeReservedInstanceCategoriesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancePriceRequest extends $tea.Model {
  ownerAccount?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  reservedInstanceId?: string[];
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  tag?: DescribeReservedInstancePriceRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      reservedInstanceId: 'ReservedInstanceId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerAccount: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      reservedInstanceId: { 'type': 'array', 'itemType': 'string' },
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      tag: { 'type': 'array', 'itemType': DescribeReservedInstancePriceRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancePriceResponseBody extends $tea.Model {
  priceInfo?: DescribeReservedInstancePriceResponseBodyPriceInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      priceInfo: 'PriceInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      priceInfo: DescribeReservedInstancePriceResponseBodyPriceInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancePriceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeReservedInstancePriceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeReservedInstancePriceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancesRequest extends $tea.Model {
  allocationType?: string;
  expiredTime?: string;
  instanceType?: string;
  instanceTypeFamily?: string;
  lockReason?: string;
  offeringType?: string;
  ownerAccount?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  reservedInstanceId?: string[];
  reservedInstanceName?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  scope?: string;
  status?: string[];
  tag?: DescribeReservedInstancesRequestTag[];
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      allocationType: 'AllocationType',
      expiredTime: 'ExpiredTime',
      instanceType: 'InstanceType',
      instanceTypeFamily: 'InstanceTypeFamily',
      lockReason: 'LockReason',
      offeringType: 'OfferingType',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      reservedInstanceId: 'ReservedInstanceId',
      reservedInstanceName: 'ReservedInstanceName',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      scope: 'Scope',
      status: 'Status',
      tag: 'Tag',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allocationType: 'string',
      expiredTime: 'string',
      instanceType: 'string',
      instanceTypeFamily: 'string',
      lockReason: 'string',
      offeringType: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      reservedInstanceId: { 'type': 'array', 'itemType': 'string' },
      reservedInstanceName: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      scope: 'string',
      status: { 'type': 'array', 'itemType': 'string' },
      tag: { 'type': 'array', 'itemType': DescribeReservedInstancesRequestTag },
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancesResponseBody extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  reservedInstances?: DescribeReservedInstancesResponseBodyReservedInstances;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      reservedInstances: 'ReservedInstances',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      reservedInstances: DescribeReservedInstancesResponseBodyReservedInstances,
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeReservedInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeReservedInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceAggregationsRequest extends $tea.Model {
  aggregators?: string[];
  filter?: DescribeResourceAggregationsRequestFilter[];
  global?: string;
  keyword?: string;
  marker?: string;
  maxItems?: number;
  ownerAccount?: string;
  ownerId?: number;
  product?: string;
  regionId?: string;
  regionNo?: string;
  resourceGroupId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  resourceType?: string;
  tagFilter?: DescribeResourceAggregationsRequestTagFilter[];
  static names(): { [key: string]: string } {
    return {
      aggregators: 'Aggregators',
      filter: 'Filter',
      global: 'Global',
      keyword: 'Keyword',
      marker: 'Marker',
      maxItems: 'MaxItems',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      product: 'Product',
      regionId: 'RegionId',
      regionNo: 'RegionNo',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      resourceType: 'ResourceType',
      tagFilter: 'TagFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aggregators: { 'type': 'array', 'itemType': 'string' },
      filter: { 'type': 'array', 'itemType': DescribeResourceAggregationsRequestFilter },
      global: 'string',
      keyword: 'string',
      marker: 'string',
      maxItems: 'number',
      ownerAccount: 'string',
      ownerId: 'number',
      product: 'string',
      regionId: 'string',
      regionNo: 'string',
      resourceGroupId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      resourceType: 'string',
      tagFilter: { 'type': 'array', 'itemType': DescribeResourceAggregationsRequestTagFilter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceAggregationsResponseBody extends $tea.Model {
  aggregations?: DescribeResourceAggregationsResponseBodyAggregations;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      aggregations: 'Aggregations',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aggregations: DescribeResourceAggregationsResponseBodyAggregations,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceAggregationsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeResourceAggregationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeResourceAggregationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceAllocationRequest extends $tea.Model {
  cores?: number;
  dataDiskCategory?: string[];
  defaultTargetCapacityType?: string;
  instanceFamilyLevel?: string;
  instanceTypeModel?: DescribeResourceAllocationRequestInstanceTypeModel[];
  instanceTypeSupportIPv6?: boolean;
  ioOptimized?: string;
  maxPrice?: number;
  memory?: number;
  networkType?: string;
  ownerAccount?: string;
  ownerId?: number;
  postPaidBaseCapacity?: number;
  priorityStrategy?: string;
  regionId?: string;
  resourceAmountType?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  spotBaseCapacity?: number;
  spotInstancePools?: number;
  spotStrategy?: string;
  strictSatisfiedTargetCapacity?: boolean;
  systemDiskCategory?: string;
  targetCapacity?: number;
  zoneId?: string[];
  static names(): { [key: string]: string } {
    return {
      cores: 'Cores',
      dataDiskCategory: 'DataDiskCategory',
      defaultTargetCapacityType: 'DefaultTargetCapacityType',
      instanceFamilyLevel: 'InstanceFamilyLevel',
      instanceTypeModel: 'InstanceTypeModel',
      instanceTypeSupportIPv6: 'InstanceTypeSupportIPv6',
      ioOptimized: 'IoOptimized',
      maxPrice: 'MaxPrice',
      memory: 'Memory',
      networkType: 'NetworkType',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      postPaidBaseCapacity: 'PostPaidBaseCapacity',
      priorityStrategy: 'PriorityStrategy',
      regionId: 'RegionId',
      resourceAmountType: 'ResourceAmountType',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      spotBaseCapacity: 'SpotBaseCapacity',
      spotInstancePools: 'SpotInstancePools',
      spotStrategy: 'SpotStrategy',
      strictSatisfiedTargetCapacity: 'StrictSatisfiedTargetCapacity',
      systemDiskCategory: 'SystemDiskCategory',
      targetCapacity: 'TargetCapacity',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cores: 'number',
      dataDiskCategory: { 'type': 'array', 'itemType': 'string' },
      defaultTargetCapacityType: 'string',
      instanceFamilyLevel: 'string',
      instanceTypeModel: { 'type': 'array', 'itemType': DescribeResourceAllocationRequestInstanceTypeModel },
      instanceTypeSupportIPv6: 'boolean',
      ioOptimized: 'string',
      maxPrice: 'number',
      memory: 'number',
      networkType: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      postPaidBaseCapacity: 'number',
      priorityStrategy: 'string',
      regionId: 'string',
      resourceAmountType: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      spotBaseCapacity: 'number',
      spotInstancePools: 'number',
      spotStrategy: 'string',
      strictSatisfiedTargetCapacity: 'boolean',
      systemDiskCategory: 'string',
      targetCapacity: 'number',
      zoneId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceAllocationResponseBody extends $tea.Model {
  requestId?: string;
  resourcePlanningResponse?: DescribeResourceAllocationResponseBodyResourcePlanningResponse;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      resourcePlanningResponse: 'ResourcePlanningResponse',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      resourcePlanningResponse: DescribeResourceAllocationResponseBodyResourcePlanningResponse,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceAllocationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeResourceAllocationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeResourceAllocationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayRequest extends $tea.Model {
  chargeType?: string;
  firstBizLevel?: string;
  instanceCategoryType?: string[];
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  secondBizLevel?: string;
  spotStrategy?: string;
  templateTag?: DescribeResourceDisplayRequestTemplateTag[];
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      chargeType: 'ChargeType',
      firstBizLevel: 'FirstBizLevel',
      instanceCategoryType: 'InstanceCategoryType',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      secondBizLevel: 'SecondBizLevel',
      spotStrategy: 'SpotStrategy',
      templateTag: 'TemplateTag',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chargeType: 'string',
      firstBizLevel: 'string',
      instanceCategoryType: { 'type': 'array', 'itemType': 'string' },
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      secondBizLevel: 'string',
      spotStrategy: 'string',
      templateTag: { 'type': 'array', 'itemType': DescribeResourceDisplayRequestTemplateTag },
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBody extends $tea.Model {
  requestId?: string;
  resourceDisplay?: DescribeResourceDisplayResponseBodyResourceDisplay;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      resourceDisplay: 'ResourceDisplay',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      resourceDisplay: DescribeResourceDisplayResponseBodyResourceDisplay,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeResourceDisplayResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeResourceDisplayResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceFilterAttributesRequest extends $tea.Model {
  ownerAccount?: string;
  ownerId?: number;
  product?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  resourceType?: string;
  templateTag?: DescribeResourceFilterAttributesRequestTemplateTag[];
  static names(): { [key: string]: string } {
    return {
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      product: 'Product',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      resourceType: 'ResourceType',
      templateTag: 'TemplateTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerAccount: 'string',
      ownerId: 'number',
      product: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      resourceType: 'string',
      templateTag: { 'type': 'array', 'itemType': DescribeResourceFilterAttributesRequestTemplateTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceFilterAttributesResponseBody extends $tea.Model {
  filterAttributes?: DescribeResourceFilterAttributesResponseBodyFilterAttributes;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      filterAttributes: 'FilterAttributes',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filterAttributes: DescribeResourceFilterAttributesResponseBodyFilterAttributes,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceFilterAttributesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeResourceFilterAttributesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeResourceFilterAttributesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceRecommendFiltersRequest extends $tea.Model {
  attributeName?: string;
  attributeValue?: string;
  global?: string;
  maxItems?: number;
  ownerAccount?: string;
  ownerId?: number;
  product?: string;
  regionId?: string;
  regionNo?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  resourceType?: string;
  templateTag?: DescribeResourceRecommendFiltersRequestTemplateTag[];
  static names(): { [key: string]: string } {
    return {
      attributeName: 'AttributeName',
      attributeValue: 'AttributeValue',
      global: 'Global',
      maxItems: 'MaxItems',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      product: 'Product',
      regionId: 'RegionId',
      regionNo: 'RegionNo',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      resourceType: 'ResourceType',
      templateTag: 'TemplateTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attributeName: 'string',
      attributeValue: 'string',
      global: 'string',
      maxItems: 'number',
      ownerAccount: 'string',
      ownerId: 'number',
      product: 'string',
      regionId: 'string',
      regionNo: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      resourceType: 'string',
      templateTag: { 'type': 'array', 'itemType': DescribeResourceRecommendFiltersRequestTemplateTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceRecommendFiltersResponseBody extends $tea.Model {
  recommendFilters?: DescribeResourceRecommendFiltersResponseBodyRecommendFilters;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recommendFilters: 'RecommendFilters',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recommendFilters: DescribeResourceRecommendFiltersResponseBodyRecommendFilters,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceRecommendFiltersResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeResourceRecommendFiltersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeResourceRecommendFiltersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceSolutionsRequest extends $tea.Model {
  cores?: number;
  instanceChargeType?: string;
  instanceFamilyLevel?: string;
  instanceTypeModel?: DescribeResourceSolutionsRequestInstanceTypeModel[];
  instanceTypeSupportIPv6?: boolean;
  matchOpenInstances?: boolean;
  maxPrice?: number;
  memory?: number;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceAmountType?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  spotStrategy?: string;
  systemDiskCategory?: string;
  targetCapacity?: number;
  zoneId?: string[];
  static names(): { [key: string]: string } {
    return {
      cores: 'Cores',
      instanceChargeType: 'InstanceChargeType',
      instanceFamilyLevel: 'InstanceFamilyLevel',
      instanceTypeModel: 'InstanceTypeModel',
      instanceTypeSupportIPv6: 'InstanceTypeSupportIPv6',
      matchOpenInstances: 'MatchOpenInstances',
      maxPrice: 'MaxPrice',
      memory: 'Memory',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceAmountType: 'ResourceAmountType',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      spotStrategy: 'SpotStrategy',
      systemDiskCategory: 'SystemDiskCategory',
      targetCapacity: 'TargetCapacity',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cores: 'number',
      instanceChargeType: 'string',
      instanceFamilyLevel: 'string',
      instanceTypeModel: { 'type': 'array', 'itemType': DescribeResourceSolutionsRequestInstanceTypeModel },
      instanceTypeSupportIPv6: 'boolean',
      matchOpenInstances: 'boolean',
      maxPrice: 'number',
      memory: 'number',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceAmountType: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      spotStrategy: 'string',
      systemDiskCategory: 'string',
      targetCapacity: 'number',
      zoneId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceSolutionsResponseBody extends $tea.Model {
  requestId?: string;
  resourcePlanningResponses?: DescribeResourceSolutionsResponseBodyResourcePlanningResponses;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      resourcePlanningResponses: 'ResourcePlanningResponses',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      resourcePlanningResponses: DescribeResourceSolutionsResponseBodyResourcePlanningResponses,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceSolutionsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeResourceSolutionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeResourceSolutionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourcesRequest extends $tea.Model {
  filter?: DescribeResourcesRequestFilter[];
  global?: string;
  keyword?: string;
  marker?: string;
  maxItems?: number;
  ownerAccount?: string;
  ownerId?: number;
  product?: string;
  regionId?: string;
  regionNo?: string;
  resourceGroupId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  resourceType?: string;
  tagFilter?: DescribeResourcesRequestTagFilter[];
  templateTag?: DescribeResourcesRequestTemplateTag[];
  static names(): { [key: string]: string } {
    return {
      filter: 'Filter',
      global: 'Global',
      keyword: 'Keyword',
      marker: 'Marker',
      maxItems: 'MaxItems',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      product: 'Product',
      regionId: 'RegionId',
      regionNo: 'RegionNo',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      resourceType: 'ResourceType',
      tagFilter: 'TagFilter',
      templateTag: 'TemplateTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filter: { 'type': 'array', 'itemType': DescribeResourcesRequestFilter },
      global: 'string',
      keyword: 'string',
      marker: 'string',
      maxItems: 'number',
      ownerAccount: 'string',
      ownerId: 'number',
      product: 'string',
      regionId: 'string',
      regionNo: 'string',
      resourceGroupId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      resourceType: 'string',
      tagFilter: { 'type': 'array', 'itemType': DescribeResourcesRequestTagFilter },
      templateTag: { 'type': 'array', 'itemType': DescribeResourcesRequestTemplateTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourcesResponseBody extends $tea.Model {
  estimatedTotal?: number;
  marker?: string;
  requestId?: string;
  resources?: DescribeResourcesResponseBodyResources;
  truncated?: boolean;
  static names(): { [key: string]: string } {
    return {
      estimatedTotal: 'EstimatedTotal',
      marker: 'Marker',
      requestId: 'RequestId',
      resources: 'Resources',
      truncated: 'Truncated',
    };
  }

  static types(): { [key: string]: any } {
    return {
      estimatedTotal: 'number',
      marker: 'string',
      requestId: 'string',
      resources: DescribeResourcesResponseBodyResources,
      truncated: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourcesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiUtilizationRequest extends $tea.Model {
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  reservedInstanceId?: string[];
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  tag?: DescribeRiUtilizationRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      reservedInstanceId: 'ReservedInstanceId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      reservedInstanceId: { 'type': 'array', 'itemType': 'string' },
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      tag: { 'type': 'array', 'itemType': DescribeRiUtilizationRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiUtilizationResponseBody extends $tea.Model {
  requestId?: string;
  utilizations?: DescribeRiUtilizationResponseBodyUtilizations;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      utilizations: 'Utilizations',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      utilizations: DescribeRiUtilizationResponseBodyUtilizations,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiUtilizationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeRiUtilizationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRiUtilizationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScenePurchaseRecommendRequest extends $tea.Model {
  privatePoolOptions?: DescribeScenePurchaseRecommendRequestPrivatePoolOptions;
  schedulerOptions?: DescribeScenePurchaseRecommendRequestSchedulerOptions;
  amount?: number;
  dataDisk?: DescribeScenePurchaseRecommendRequestDataDisk[];
  dedicatedHostId?: string;
  imageId?: string;
  instanceChargeType?: string;
  instanceType?: string;
  internetChargeType?: string;
  internetMaxBandwidthOut?: number;
  ioOptimized?: string;
  networkType?: string;
  ownerAccount?: string;
  ownerId?: number;
  period?: number;
  periodUnit?: string;
  productId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  sceneId?: number;
  spotStrategy?: string;
  systemDisk?: DescribeScenePurchaseRecommendRequestSystemDisk;
  tenancy?: string;
  vSwitchId?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      privatePoolOptions: 'PrivatePoolOptions',
      schedulerOptions: 'SchedulerOptions',
      amount: 'Amount',
      dataDisk: 'DataDisk',
      dedicatedHostId: 'DedicatedHostId',
      imageId: 'ImageId',
      instanceChargeType: 'InstanceChargeType',
      instanceType: 'InstanceType',
      internetChargeType: 'InternetChargeType',
      internetMaxBandwidthOut: 'InternetMaxBandwidthOut',
      ioOptimized: 'IoOptimized',
      networkType: 'NetworkType',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      productId: 'ProductId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      sceneId: 'SceneId',
      spotStrategy: 'SpotStrategy',
      systemDisk: 'SystemDisk',
      tenancy: 'Tenancy',
      vSwitchId: 'VSwitchId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      privatePoolOptions: DescribeScenePurchaseRecommendRequestPrivatePoolOptions,
      schedulerOptions: DescribeScenePurchaseRecommendRequestSchedulerOptions,
      amount: 'number',
      dataDisk: { 'type': 'array', 'itemType': DescribeScenePurchaseRecommendRequestDataDisk },
      dedicatedHostId: 'string',
      imageId: 'string',
      instanceChargeType: 'string',
      instanceType: 'string',
      internetChargeType: 'string',
      internetMaxBandwidthOut: 'number',
      ioOptimized: 'string',
      networkType: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      period: 'number',
      periodUnit: 'string',
      productId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      sceneId: 'number',
      spotStrategy: 'string',
      systemDisk: DescribeScenePurchaseRecommendRequestSystemDisk,
      tenancy: 'string',
      vSwitchId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScenePurchaseRecommendResponseBody extends $tea.Model {
  recommendProducts?: DescribeScenePurchaseRecommendResponseBodyRecommendProducts;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recommendProducts: 'RecommendProducts',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recommendProducts: DescribeScenePurchaseRecommendResponseBodyRecommendProducts,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScenePurchaseRecommendResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeScenePurchaseRecommendResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeScenePurchaseRecommendResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSceneResourceRecommendRequest extends $tea.Model {
  ownerAccount?: string;
  ownerId?: number;
  productId?: number;
  regionId?: string;
  resourceId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  sceneId?: number;
  static names(): { [key: string]: string } {
    return {
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      productId: 'ProductId',
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      sceneId: 'SceneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerAccount: 'string',
      ownerId: 'number',
      productId: 'number',
      regionId: 'string',
      resourceId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      sceneId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSceneResourceRecommendResponseBody extends $tea.Model {
  recommendProducts?: DescribeSceneResourceRecommendResponseBodyRecommendProducts;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recommendProducts: 'RecommendProducts',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recommendProducts: DescribeSceneResourceRecommendResponseBodyRecommendProducts,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSceneResourceRecommendResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSceneResourceRecommendResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSceneResourceRecommendResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSpotInstanceAdviceRequest extends $tea.Model {
  cores?: number;
  ioOptimized?: string;
  memory?: number;
  minCores?: number;
  minMemory?: number;
  networkType?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      cores: 'Cores',
      ioOptimized: 'IoOptimized',
      memory: 'Memory',
      minCores: 'MinCores',
      minMemory: 'MinMemory',
      networkType: 'NetworkType',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cores: 'number',
      ioOptimized: 'string',
      memory: 'number',
      minCores: 'number',
      minMemory: 'number',
      networkType: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSpotInstanceAdviceResponseBody extends $tea.Model {
  availableSpotZones?: DescribeSpotInstanceAdviceResponseBodyAvailableSpotZones;
  regionId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      availableSpotZones: 'AvailableSpotZones',
      regionId: 'RegionId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableSpotZones: DescribeSpotInstanceAdviceResponseBodyAvailableSpotZones,
      regionId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSpotInstanceAdviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSpotInstanceAdviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSpotInstanceAdviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageCapacityUnitAllocationsRequest extends $tea.Model {
  ownerAccount?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  storageCapacityUnitId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      storageCapacityUnitId: 'StorageCapacityUnitId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerAccount: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      storageCapacityUnitId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageCapacityUnitAllocationsResponseBody extends $tea.Model {
  allocations?: DescribeStorageCapacityUnitAllocationsResponseBodyAllocations;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      allocations: 'Allocations',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allocations: DescribeStorageCapacityUnitAllocationsResponseBodyAllocations,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageCapacityUnitAllocationsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeStorageCapacityUnitAllocationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeStorageCapacityUnitAllocationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageCapacityUnitDeductFactorRequest extends $tea.Model {
  deductField?: string;
  ownerAccount?: string;
  ownerId?: number;
  performanceLevel?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  storageType?: string;
  tag?: DescribeStorageCapacityUnitDeductFactorRequestTag[];
  static names(): { [key: string]: string } {
    return {
      deductField: 'DeductField',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      performanceLevel: 'PerformanceLevel',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      storageType: 'StorageType',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deductField: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      performanceLevel: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      storageType: 'string',
      tag: { 'type': 'array', 'itemType': DescribeStorageCapacityUnitDeductFactorRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageCapacityUnitDeductFactorResponseBody extends $tea.Model {
  deductFactor?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      deductFactor: 'DeductFactor',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deductFactor: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageCapacityUnitDeductFactorResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeStorageCapacityUnitDeductFactorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeStorageCapacityUnitDeductFactorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageSetDetailsRequest extends $tea.Model {
  clientToken?: string;
  diskIds?: string;
  ownerAccount?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  storageSetId?: string;
  storageSetPartitionNumber?: number;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      diskIds: 'DiskIds',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      storageSetId: 'StorageSetId',
      storageSetPartitionNumber: 'StorageSetPartitionNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      diskIds: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      storageSetId: 'string',
      storageSetPartitionNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageSetDetailsResponseBody extends $tea.Model {
  disks?: DescribeStorageSetDetailsResponseBodyDisks;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      disks: 'Disks',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      disks: DescribeStorageSetDetailsResponseBodyDisks,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageSetDetailsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeStorageSetDetailsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeStorageSetDetailsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageSetsRequest extends $tea.Model {
  clientToken?: string;
  ownerAccount?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  storageSetIds?: string;
  storageSetName?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      storageSetIds: 'StorageSetIds',
      storageSetName: 'StorageSetName',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      storageSetIds: 'string',
      storageSetName: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageSetsResponseBody extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  storageSets?: DescribeStorageSetsResponseBodyStorageSets;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      storageSets: 'StorageSets',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      storageSets: DescribeStorageSetsResponseBodyStorageSets,
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageSetsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeStorageSetsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeStorageSetsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransitionVSwitchesRequest extends $tea.Model {
  instanceId?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  resourceType?: string;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      resourceType: 'ResourceType',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      resourceType: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransitionVSwitchesResponseBody extends $tea.Model {
  code?: string;
  requestId?: string;
  success?: boolean;
  vSwitchModels?: DescribeTransitionVSwitchesResponseBodyVSwitchModels;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      requestId: 'RequestId',
      success: 'Success',
      vSwitchModels: 'VSwitchModels',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      requestId: 'string',
      success: 'boolean',
      vSwitchModels: DescribeTransitionVSwitchesResponseBodyVSwitchModels,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransitionVSwitchesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeTransitionVSwitchesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTransitionVSwitchesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransitionVpcAndVSwitchRequest extends $tea.Model {
  instanceIds?: string[];
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      instanceIds: 'InstanceIds',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      resourceType: 'ResourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransitionVpcAndVSwitchResponseBody extends $tea.Model {
  requestId?: string;
  vmTransitionModels?: DescribeTransitionVpcAndVSwitchResponseBodyVmTransitionModels;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      vmTransitionModels: 'VmTransitionModels',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vmTransitionModels: DescribeTransitionVpcAndVSwitchResponseBodyVmTransitionModels,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransitionVpcAndVSwitchResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeTransitionVpcAndVSwitchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTransitionVpcAndVSwitchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransitionVpcsRequest extends $tea.Model {
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      resourceType: 'ResourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransitionVpcsResponseBody extends $tea.Model {
  code?: string;
  requestId?: string;
  success?: boolean;
  vpcModels?: DescribeTransitionVpcsResponseBodyVpcModels;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      requestId: 'RequestId',
      success: 'Success',
      vpcModels: 'VpcModels',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      requestId: 'string',
      success: 'boolean',
      vpcModels: DescribeTransitionVpcsResponseBodyVpcModels,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransitionVpcsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeTransitionVpcsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTransitionVpcsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserAvailableIpServiceProvidersRequest extends $tea.Model {
  aliUid?: number;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'number',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserAvailableIpServiceProvidersResponseBody extends $tea.Model {
  ipServiceProviders?: DescribeUserAvailableIpServiceProvidersResponseBodyIpServiceProviders;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      ipServiceProviders: 'IpServiceProviders',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipServiceProviders: DescribeUserAvailableIpServiceProvidersResponseBodyIpServiceProviders,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserAvailableIpServiceProvidersResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeUserAvailableIpServiceProvidersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUserAvailableIpServiceProvidersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserQuotaApplicationsRequest extends $tea.Model {
  applicationId?: string;
  chargeType?: string;
  clientToken?: string;
  instanceType?: string;
  nextToken?: string;
  ownerAccount?: string;
  ownerId?: number;
  pageNumber?: number;
  quotaType?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  status?: string;
  zoneId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      applicationId: 'ApplicationId',
      chargeType: 'ChargeType',
      clientToken: 'ClientToken',
      instanceType: 'InstanceType',
      nextToken: 'NextToken',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      quotaType: 'QuotaType',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      status: 'Status',
      zoneId: 'ZoneId',
      pageSize: 'pageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationId: 'string',
      chargeType: 'string',
      clientToken: 'string',
      instanceType: 'string',
      nextToken: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      quotaType: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      status: 'string',
      zoneId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserQuotaApplicationsResponseBody extends $tea.Model {
  nextToken?: string;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  userQuotaApplications?: DescribeUserQuotaApplicationsResponseBodyUserQuotaApplications;
  static names(): { [key: string]: string } {
    return {
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      userQuotaApplications: 'UserQuotaApplications',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      userQuotaApplications: DescribeUserQuotaApplicationsResponseBodyUserQuotaApplications,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserQuotaApplicationsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeUserQuotaApplicationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUserQuotaApplicationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcHavsInstancesRequest extends $tea.Model {
  maxResultSize?: number;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  vpcIdList?: string[];
  static names(): { [key: string]: string } {
    return {
      maxResultSize: 'MaxResultSize',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      vpcIdList: 'VpcIdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResultSize: 'number',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      vpcIdList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcHavsInstancesResponseBody extends $tea.Model {
  requestId?: string;
  vpcHavsInstances?: DescribeVpcHavsInstancesResponseBodyVpcHavsInstances;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      vpcHavsInstances: 'VpcHavsInstances',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vpcHavsInstances: DescribeVpcHavsInstancesResponseBodyVpcHavsInstances,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcHavsInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeVpcHavsInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeVpcHavsInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWaitingOrdersRequest extends $tea.Model {
  clientToken?: string;
  maxResults?: number;
  nextToken?: string;
  ownerAccount?: string;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  status?: string;
  tag?: DescribeWaitingOrdersRequestTag[];
  waitingOrderId?: string[];
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      ownerAccount: 'OwnerAccount',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      status: 'Status',
      tag: 'Tag',
      waitingOrderId: 'WaitingOrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      maxResults: 'number',
      nextToken: 'string',
      ownerAccount: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      status: 'string',
      tag: { 'type': 'array', 'itemType': DescribeWaitingOrdersRequestTag },
      waitingOrderId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWaitingOrdersResponseBody extends $tea.Model {
  data?: DescribeWaitingOrdersResponseBodyData[];
  nextToken?: string;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeWaitingOrdersResponseBodyData },
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWaitingOrdersResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeWaitingOrdersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWaitingOrdersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FeedbackDiagnoseRequest extends $tea.Model {
  diagnoseId?: string;
  mark?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  star?: number;
  static names(): { [key: string]: string } {
    return {
      diagnoseId: 'DiagnoseId',
      mark: 'Mark',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      star: 'Star',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diagnoseId: 'string',
      mark: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      star: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FeedbackDiagnoseResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FeedbackDiagnoseResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: FeedbackDiagnoseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: FeedbackDiagnoseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLaunchTemplateDataRequest extends $tea.Model {
  instanceId?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLaunchTemplateDataResponseBody extends $tea.Model {
  launchTemplateData?: GetLaunchTemplateDataResponseBodyLaunchTemplateData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      launchTemplateData: 'LaunchTemplateData',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      launchTemplateData: GetLaunchTemplateDataResponseBodyLaunchTemplateData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLaunchTemplateDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetLaunchTemplateDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetLaunchTemplateDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InnerDescribeNetworkInterfaceInGroupRequest extends $tea.Model {
  maxResults?: number;
  nextToken?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  securityGroupId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      securityGroupId: 'SecurityGroupId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      securityGroupId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InnerDescribeNetworkInterfaceInGroupResponseBody extends $tea.Model {
  networkInterfaceSets?: InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSets;
  nextToken?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      networkInterfaceSets: 'NetworkInterfaceSets',
      nextToken: 'NextToken',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkInterfaceSets: InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSets,
      nextToken: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InnerDescribeNetworkInterfaceInGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: InnerDescribeNetworkInterfaceInGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InnerDescribeNetworkInterfaceInGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinEniQosGroupRequest extends $tea.Model {
  networkInterfaceId?: string;
  ownerId?: number;
  qosGroupName?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      networkInterfaceId: 'NetworkInterfaceId',
      ownerId: 'OwnerId',
      qosGroupName: 'QosGroupName',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkInterfaceId: 'string',
      ownerId: 'number',
      qosGroupName: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinEniQosGroupResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinEniQosGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: JoinEniQosGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: JoinEniQosGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LeaveEniQosGroupRequest extends $tea.Model {
  networkInterfaceId?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      networkInterfaceId: 'NetworkInterfaceId',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkInterfaceId: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LeaveEniQosGroupResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LeaveEniQosGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: LeaveEniQosGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: LeaveEniQosGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAccountEcsQuotasRequest extends $tea.Model {
  chargeType?: string;
  networkType?: string;
  nextToken?: string;
  ownerAccount?: string;
  ownerId?: number;
  pageSize?: number;
  quotaResourceName?: string;
  quotaResourceType?: string;
  quotaUnit?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  sortField?: string;
  sortOrder?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      chargeType: 'ChargeType',
      networkType: 'NetworkType',
      nextToken: 'NextToken',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      pageSize: 'PageSize',
      quotaResourceName: 'QuotaResourceName',
      quotaResourceType: 'QuotaResourceType',
      quotaUnit: 'QuotaUnit',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      sortField: 'SortField',
      sortOrder: 'SortOrder',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chargeType: 'string',
      networkType: 'string',
      nextToken: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      pageSize: 'number',
      quotaResourceName: 'string',
      quotaResourceType: 'string',
      quotaUnit: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      sortField: 'string',
      sortOrder: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAccountEcsQuotasResponseBody extends $tea.Model {
  ecsQuotas?: ListAccountEcsQuotasResponseBodyEcsQuotas;
  nextToken?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      ecsQuotas: 'EcsQuotas',
      nextToken: 'NextToken',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ecsQuotas: ListAccountEcsQuotasResponseBodyEcsQuotas,
      nextToken: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAccountEcsQuotasResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListAccountEcsQuotasResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAccountEcsQuotasResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceSettingsRequest extends $tea.Model {
  cloudAssistantDeliverySettings?: boolean;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      cloudAssistantDeliverySettings: 'CloudAssistantDeliverySettings',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cloudAssistantDeliverySettings: 'boolean',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceSettingsResponseBody extends $tea.Model {
  cloudAssistantDeliverySettings?: ListServiceSettingsResponseBodyCloudAssistantDeliverySettings;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      cloudAssistantDeliverySettings: 'CloudAssistantDeliverySettings',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cloudAssistantDeliverySettings: ListServiceSettingsResponseBodyCloudAssistantDeliverySettings,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceSettingsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListServiceSettingsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListServiceSettingsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCapacityReservationRequest extends $tea.Model {
  capacityReservationId?: string;
  instanceCount?: number;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  token?: string;
  static names(): { [key: string]: string } {
    return {
      capacityReservationId: 'CapacityReservationId',
      instanceCount: 'InstanceCount',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      token: 'Token',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityReservationId: 'string',
      instanceCount: 'number',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      token: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCapacityReservationResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCapacityReservationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyCapacityReservationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyCapacityReservationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostAttributeRequest extends $tea.Model {
  networkAttributes?: ModifyDedicatedHostAttributeRequestNetworkAttributes;
  actionOnMaintenance?: string;
  autoPlacement?: string;
  cpuOverCommitRatio?: number;
  dedicatedHostClusterId?: string;
  dedicatedHostId?: string;
  dedicatedHostName?: string;
  description?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      networkAttributes: 'NetworkAttributes',
      actionOnMaintenance: 'ActionOnMaintenance',
      autoPlacement: 'AutoPlacement',
      cpuOverCommitRatio: 'CpuOverCommitRatio',
      dedicatedHostClusterId: 'DedicatedHostClusterId',
      dedicatedHostId: 'DedicatedHostId',
      dedicatedHostName: 'DedicatedHostName',
      description: 'Description',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkAttributes: ModifyDedicatedHostAttributeRequestNetworkAttributes,
      actionOnMaintenance: 'string',
      autoPlacement: 'string',
      cpuOverCommitRatio: 'number',
      dedicatedHostClusterId: 'string',
      dedicatedHostId: 'string',
      dedicatedHostName: 'string',
      description: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyDedicatedHostAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDedicatedHostAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostAutoReleaseTimeRequest extends $tea.Model {
  autoReleaseTime?: string;
  instanceId?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      autoReleaseTime: 'AutoReleaseTime',
      instanceId: 'InstanceId',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoReleaseTime: 'string',
      instanceId: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostAutoReleaseTimeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostAutoReleaseTimeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyDedicatedHostAutoReleaseTimeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDedicatedHostAutoReleaseTimeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostAutoRenewAttributeRequest extends $tea.Model {
  autoRenew?: boolean;
  duration?: number;
  instanceIds?: string;
  ownerAccount?: string;
  ownerId?: number;
  periodUnit?: string;
  regionId?: string;
  renewalStatus?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      autoRenew: 'AutoRenew',
      duration: 'Duration',
      instanceIds: 'InstanceIds',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      periodUnit: 'PeriodUnit',
      regionId: 'RegionId',
      renewalStatus: 'RenewalStatus',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      resourceType: 'ResourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRenew: 'boolean',
      duration: 'number',
      instanceIds: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      periodUnit: 'string',
      regionId: 'string',
      renewalStatus: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostAutoRenewAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostAutoRenewAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyDedicatedHostAutoRenewAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDedicatedHostAutoRenewAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostClusterAttributeRequest extends $tea.Model {
  dedicatedHostClusterId?: string;
  dedicatedHostClusterName?: string;
  description?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      dedicatedHostClusterId: 'DedicatedHostClusterId',
      dedicatedHostClusterName: 'DedicatedHostClusterName',
      description: 'Description',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedHostClusterId: 'string',
      dedicatedHostClusterName: 'string',
      description: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostClusterAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostClusterAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyDedicatedHostClusterAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDedicatedHostClusterAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDiagnoseRequest extends $tea.Model {
  diagnoseId?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      diagnoseId: 'DiagnoseId',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diagnoseId: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDiagnoseResponseBody extends $tea.Model {
  requestId?: string;
  data?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      data: 'data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      data: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDiagnoseResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyDiagnoseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDiagnoseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDiskSpecRequest extends $tea.Model {
  autoPay?: boolean;
  diskCategory?: string;
  diskId?: string;
  ownerAccount?: string;
  ownerId?: number;
  performanceLevel?: string;
  provisionedIops?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      autoPay: 'AutoPay',
      diskCategory: 'DiskCategory',
      diskId: 'DiskId',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      performanceLevel: 'PerformanceLevel',
      provisionedIops: 'ProvisionedIops',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoPay: 'boolean',
      diskCategory: 'string',
      diskId: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      performanceLevel: 'string',
      provisionedIops: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDiskSpecResponseBody extends $tea.Model {
  orderId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDiskSpecResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyDiskSpecResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDiskSpecResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyEniQosGroupRequest extends $tea.Model {
  ownerId?: number;
  qosGroupName?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  rx?: number;
  rxPps?: number;
  tx?: number;
  txPps?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      qosGroupName: 'QosGroupName',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      rx: 'Rx',
      rxPps: 'RxPps',
      tx: 'Tx',
      txPps: 'TxPps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      qosGroupName: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      rx: 'number',
      rxPps: 'number',
      tx: 'number',
      txPps: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyEniQosGroupResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyEniQosGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyEniQosGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyEniQosGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyImageAdvancedAttributeRequest extends $tea.Model {
  flag?: ModifyImageAdvancedAttributeRequestFlag[];
  imageId?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  supportIoOptimized?: string;
  static names(): { [key: string]: string } {
    return {
      flag: 'Flag',
      imageId: 'ImageId',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      supportIoOptimized: 'SupportIoOptimized',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flag: { 'type': 'array', 'itemType': ModifyImageAdvancedAttributeRequestFlag },
      imageId: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      supportIoOptimized: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyImageAdvancedAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyImageAdvancedAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyImageAdvancedAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyImageAdvancedAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAutoRebootTimeRequest extends $tea.Model {
  autoRebootTime?: string;
  instanceIds?: string[];
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      autoRebootTime: 'AutoRebootTime',
      instanceIds: 'InstanceIds',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRebootTime: 'string',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAutoRebootTimeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAutoRebootTimeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyInstanceAutoRebootTimeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceAutoRebootTimeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceCapacityReservationAttributesRequest extends $tea.Model {
  capacityReservationId?: string;
  capacityReservationPreference?: string;
  instanceId?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      capacityReservationId: 'CapacityReservationId',
      capacityReservationPreference: 'CapacityReservationPreference',
      instanceId: 'InstanceId',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityReservationId: 'string',
      capacityReservationPreference: 'string',
      instanceId: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceCapacityReservationAttributesResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceCapacityReservationAttributesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyInstanceCapacityReservationAttributesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceCapacityReservationAttributesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceChargeTypeRequest extends $tea.Model {
  autoPay?: boolean;
  clientToken?: string;
  couponNo?: string;
  dryRun?: boolean;
  includeDataDisks?: boolean;
  instanceChargeType?: string;
  instanceIds?: string;
  isDetailFee?: boolean;
  ownerAccount?: string;
  ownerId?: number;
  period?: number;
  periodUnit?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      autoPay: 'AutoPay',
      clientToken: 'ClientToken',
      couponNo: 'CouponNo',
      dryRun: 'DryRun',
      includeDataDisks: 'IncludeDataDisks',
      instanceChargeType: 'InstanceChargeType',
      instanceIds: 'InstanceIds',
      isDetailFee: 'IsDetailFee',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoPay: 'boolean',
      clientToken: 'string',
      couponNo: 'string',
      dryRun: 'boolean',
      includeDataDisks: 'boolean',
      instanceChargeType: 'string',
      instanceIds: 'string',
      isDetailFee: 'boolean',
      ownerAccount: 'string',
      ownerId: 'number',
      period: 'number',
      periodUnit: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceChargeTypeResponseBody extends $tea.Model {
  feeOfInstances?: ModifyInstanceChargeTypeResponseBodyFeeOfInstances;
  orderId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      feeOfInstances: 'FeeOfInstances',
      orderId: 'OrderId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      feeOfInstances: ModifyInstanceChargeTypeResponseBodyFeeOfInstances,
      orderId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceChargeTypeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyInstanceChargeTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceChargeTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceDeploymentRequest extends $tea.Model {
  affinity?: string;
  dedicatedHostClusterId?: string;
  dedicatedHostId?: string;
  instanceId?: string;
  migrationType?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  tenancy?: string;
  static names(): { [key: string]: string } {
    return {
      affinity: 'Affinity',
      dedicatedHostClusterId: 'DedicatedHostClusterId',
      dedicatedHostId: 'DedicatedHostId',
      instanceId: 'InstanceId',
      migrationType: 'MigrationType',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      tenancy: 'Tenancy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affinity: 'string',
      dedicatedHostClusterId: 'string',
      dedicatedHostId: 'string',
      instanceId: 'string',
      migrationType: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      tenancy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceDeploymentResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceDeploymentResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyInstanceDeploymentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceDeploymentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceMaintenanceAttributesRequest extends $tea.Model {
  actionOnMaintenance?: string;
  instanceId?: string[];
  liveMigration?: boolean;
  maintenanceWindow?: ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow[];
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      actionOnMaintenance: 'ActionOnMaintenance',
      instanceId: 'InstanceId',
      liveMigration: 'LiveMigration',
      maintenanceWindow: 'MaintenanceWindow',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionOnMaintenance: 'string',
      instanceId: { 'type': 'array', 'itemType': 'string' },
      liveMigration: 'boolean',
      maintenanceWindow: { 'type': 'array', 'itemType': ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow },
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceMaintenanceAttributesResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceMaintenanceAttributesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyInstanceMaintenanceAttributesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceMaintenanceAttributesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMigratableInstancesRequest extends $tea.Model {
  businessMigrationType?: number;
  instanceId?: string[];
  networkMigrationType?: number;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      businessMigrationType: 'BusinessMigrationType',
      instanceId: 'InstanceId',
      networkMigrationType: 'NetworkMigrationType',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessMigrationType: 'number',
      instanceId: { 'type': 'array', 'itemType': 'string' },
      networkMigrationType: 'number',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMigratableInstancesResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMigratableInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyMigratableInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyMigratableInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMigrationInstancesRequest extends $tea.Model {
  globalMigrationTime?: string;
  instanceId?: string[];
  networkMigrationType?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      globalMigrationTime: 'GlobalMigrationTime',
      instanceId: 'InstanceId',
      networkMigrationType: 'NetworkMigrationType',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      globalMigrationTime: 'string',
      instanceId: { 'type': 'array', 'itemType': 'string' },
      networkMigrationType: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMigrationInstancesResponseBody extends $tea.Model {
  instancesFailModels?: ModifyMigrationInstancesResponseBodyInstancesFailModels;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instancesFailModels: 'InstancesFailModels',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instancesFailModels: ModifyMigrationInstancesResponseBodyInstancesFailModels,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMigrationInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyMigrationInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyMigrationInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMigrationPlanRequest extends $tea.Model {
  migrationPlanId?: string;
  name?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      migrationPlanId: 'MigrationPlanId',
      name: 'Name',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      migrationPlanId: 'string',
      name: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMigrationPlanResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMigrationPlanResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyMigrationPlanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyMigrationPlanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyOrderAutoRebootTimeRequest extends $tea.Model {
  autoRebootTime?: string;
  orderId?: number;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      autoRebootTime: 'AutoRebootTime',
      orderId: 'OrderId',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRebootTime: 'string',
      orderId: 'number',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyOrderAutoRebootTimeResponseBody extends $tea.Model {
  modifyOrderAutoRebootTimeInfo?: ModifyOrderAutoRebootTimeResponseBodyModifyOrderAutoRebootTimeInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      modifyOrderAutoRebootTimeInfo: 'ModifyOrderAutoRebootTimeInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      modifyOrderAutoRebootTimeInfo: ModifyOrderAutoRebootTimeResponseBodyModifyOrderAutoRebootTimeInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyOrderAutoRebootTimeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyOrderAutoRebootTimeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyOrderAutoRebootTimeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPrivatePoolRequest extends $tea.Model {
  privatePoolOptions?: ModifyPrivatePoolRequestPrivatePoolOptions;
  description?: string;
  endTime?: string;
  endTimeType?: string;
  instanceAmount?: number;
  ownerAccount?: string;
  ownerId?: number;
  platform?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      privatePoolOptions: 'PrivatePoolOptions',
      description: 'Description',
      endTime: 'EndTime',
      endTimeType: 'EndTimeType',
      instanceAmount: 'InstanceAmount',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      platform: 'Platform',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      privatePoolOptions: ModifyPrivatePoolRequestPrivatePoolOptions,
      description: 'string',
      endTime: 'string',
      endTimeType: 'string',
      instanceAmount: 'number',
      ownerAccount: 'string',
      ownerId: 'number',
      platform: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPrivatePoolResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPrivatePoolResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyPrivatePoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyPrivatePoolResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyReservationDemandRequest extends $tea.Model {
  clientToken?: string;
  confirmType?: string;
  couponAuto?: boolean;
  couponType?: string;
  demandId?: string;
  description?: string;
  instanceAmount?: number;
  instanceChargeType?: string;
  instanceCpuCoreCount?: number;
  instanceTypeFamily?: string;
  instanceTypes?: string;
  matchCriteria?: string;
  name?: string;
  period?: number;
  periodUnit?: string;
  phoneNumber?: string;
  platform?: string;
  privatePoolOptions?: ModifyReservationDemandRequestPrivatePoolOptions[];
  productType?: string;
  regionId?: string;
  reservedInstanceDescription?: string;
  reservedInstanceGroupId?: string;
  reservedInstanceName?: string;
  reservedInstanceOfferingType?: string;
  reservedInstanceScope?: string;
  resourceOwnerId?: number;
  resourceSupplyType?: string;
  savingPlanDescription?: string;
  savingPlanHourFee?: number;
  savingPlanId?: string;
  savingPlanInstanceTypeFamilyGroup?: string;
  savingPlanName?: string;
  savingPlanPayMode?: string;
  savingPlanSavingType?: string;
  startTime?: string;
  tag?: ModifyReservationDemandRequestTag[];
  zoneIds?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      confirmType: 'ConfirmType',
      couponAuto: 'CouponAuto',
      couponType: 'CouponType',
      demandId: 'DemandId',
      description: 'Description',
      instanceAmount: 'InstanceAmount',
      instanceChargeType: 'InstanceChargeType',
      instanceCpuCoreCount: 'InstanceCpuCoreCount',
      instanceTypeFamily: 'InstanceTypeFamily',
      instanceTypes: 'InstanceTypes',
      matchCriteria: 'MatchCriteria',
      name: 'Name',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      phoneNumber: 'PhoneNumber',
      platform: 'Platform',
      privatePoolOptions: 'PrivatePoolOptions',
      productType: 'ProductType',
      regionId: 'RegionId',
      reservedInstanceDescription: 'ReservedInstanceDescription',
      reservedInstanceGroupId: 'ReservedInstanceGroupId',
      reservedInstanceName: 'ReservedInstanceName',
      reservedInstanceOfferingType: 'ReservedInstanceOfferingType',
      reservedInstanceScope: 'ReservedInstanceScope',
      resourceOwnerId: 'ResourceOwnerId',
      resourceSupplyType: 'ResourceSupplyType',
      savingPlanDescription: 'SavingPlanDescription',
      savingPlanHourFee: 'SavingPlanHourFee',
      savingPlanId: 'SavingPlanId',
      savingPlanInstanceTypeFamilyGroup: 'SavingPlanInstanceTypeFamilyGroup',
      savingPlanName: 'SavingPlanName',
      savingPlanPayMode: 'SavingPlanPayMode',
      savingPlanSavingType: 'SavingPlanSavingType',
      startTime: 'StartTime',
      tag: 'Tag',
      zoneIds: 'ZoneIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      confirmType: 'string',
      couponAuto: 'boolean',
      couponType: 'string',
      demandId: 'string',
      description: 'string',
      instanceAmount: 'number',
      instanceChargeType: 'string',
      instanceCpuCoreCount: 'number',
      instanceTypeFamily: 'string',
      instanceTypes: 'string',
      matchCriteria: 'string',
      name: 'string',
      period: 'number',
      periodUnit: 'string',
      phoneNumber: 'string',
      platform: 'string',
      privatePoolOptions: { 'type': 'array', 'itemType': ModifyReservationDemandRequestPrivatePoolOptions },
      productType: 'string',
      regionId: 'string',
      reservedInstanceDescription: 'string',
      reservedInstanceGroupId: 'string',
      reservedInstanceName: 'string',
      reservedInstanceOfferingType: 'string',
      reservedInstanceScope: 'string',
      resourceOwnerId: 'number',
      resourceSupplyType: 'string',
      savingPlanDescription: 'string',
      savingPlanHourFee: 'number',
      savingPlanId: 'string',
      savingPlanInstanceTypeFamilyGroup: 'string',
      savingPlanName: 'string',
      savingPlanPayMode: 'string',
      savingPlanSavingType: 'string',
      startTime: 'string',
      tag: { 'type': 'array', 'itemType': ModifyReservationDemandRequestTag },
      zoneIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyReservationDemandResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyReservationDemandResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyReservationDemandResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyReservationDemandResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyReservedInstanceAttributeRequest extends $tea.Model {
  description?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  reservedInstanceId?: string;
  reservedInstanceName?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      reservedInstanceId: 'ReservedInstanceId',
      reservedInstanceName: 'ReservedInstanceName',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      reservedInstanceId: 'string',
      reservedInstanceName: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyReservedInstanceAttributeResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyReservedInstanceAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyReservedInstanceAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyReservedInstanceAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyReservedInstancesRequest extends $tea.Model {
  configuration?: ModifyReservedInstancesRequestConfiguration[];
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  reservedInstanceId?: string[];
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  tag?: ModifyReservedInstancesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      reservedInstanceId: 'ReservedInstanceId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: { 'type': 'array', 'itemType': ModifyReservedInstancesRequestConfiguration },
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      reservedInstanceId: { 'type': 'array', 'itemType': 'string' },
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      tag: { 'type': 'array', 'itemType': ModifyReservedInstancesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyReservedInstancesResponseBody extends $tea.Model {
  orderId?: string;
  requestId?: string;
  reservedInstanceIdSets?: ModifyReservedInstancesResponseBodyReservedInstanceIdSets;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      requestId: 'RequestId',
      reservedInstanceIdSets: 'ReservedInstanceIdSets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'string',
      requestId: 'string',
      reservedInstanceIdSets: ModifyReservedInstancesResponseBodyReservedInstanceIdSets,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyReservedInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyReservedInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyReservedInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyResourceDiagnosisStatusRequest extends $tea.Model {
  diagnosisStatus?: string;
  errorCode?: string;
  instanceType?: string;
  ownerId?: number;
  payType?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      diagnosisStatus: 'DiagnosisStatus',
      errorCode: 'ErrorCode',
      instanceType: 'InstanceType',
      ownerId: 'OwnerId',
      payType: 'PayType',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diagnosisStatus: 'string',
      errorCode: 'string',
      instanceType: 'string',
      ownerId: 'number',
      payType: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyResourceDiagnosisStatusResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyResourceDiagnosisStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyResourceDiagnosisStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyResourceDiagnosisStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyResourceMetaRequest extends $tea.Model {
  meta?: ModifyResourceMetaRequestMeta[];
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      meta: 'Meta',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      resourceType: 'ResourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      meta: { 'type': 'array', 'itemType': ModifyResourceMetaRequestMeta },
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyResourceMetaResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyResourceMetaResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyResourceMetaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyResourceMetaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStorageSetAttributeRequest extends $tea.Model {
  clientToken?: string;
  description?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  storageSetId?: string;
  storageSetName?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      description: 'Description',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      storageSetId: 'StorageSetId',
      storageSetName: 'StorageSetName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      description: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      storageSetId: 'string',
      storageSetName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStorageSetAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStorageSetAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyStorageSetAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyStorageSetAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWaitingOrderRequest extends $tea.Model {
  clientToken?: string;
  instanceAmount?: number;
  ownerAccount?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  tag?: ModifyWaitingOrderRequestTag[];
  waitingOrderId?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      instanceAmount: 'InstanceAmount',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      tag: 'Tag',
      waitingOrderId: 'WaitingOrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      instanceAmount: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      tag: { 'type': 'array', 'itemType': ModifyWaitingOrderRequestTag },
      waitingOrderId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWaitingOrderResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWaitingOrderResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyWaitingOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWaitingOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseReservedInstancesOfferingRequest extends $tea.Model {
  autoPay?: boolean;
  businessInfo?: string;
  chargeType?: string;
  clientToken?: string;
  description?: string;
  fromApp?: string;
  instanceAmount?: number;
  instanceType?: string;
  offeringType?: string;
  ownerAccount?: string;
  ownerId?: number;
  period?: number;
  periodUnit?: string;
  platform?: string;
  regionId?: string;
  reservedInstanceName?: string;
  resourceGroupId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  scope?: string;
  startTime?: string;
  tag?: PurchaseReservedInstancesOfferingRequestTag[];
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      autoPay: 'AutoPay',
      businessInfo: 'BusinessInfo',
      chargeType: 'ChargeType',
      clientToken: 'ClientToken',
      description: 'Description',
      fromApp: 'FromApp',
      instanceAmount: 'InstanceAmount',
      instanceType: 'InstanceType',
      offeringType: 'OfferingType',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      platform: 'Platform',
      regionId: 'RegionId',
      reservedInstanceName: 'ReservedInstanceName',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      scope: 'Scope',
      startTime: 'StartTime',
      tag: 'Tag',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoPay: 'boolean',
      businessInfo: 'string',
      chargeType: 'string',
      clientToken: 'string',
      description: 'string',
      fromApp: 'string',
      instanceAmount: 'number',
      instanceType: 'string',
      offeringType: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      period: 'number',
      periodUnit: 'string',
      platform: 'string',
      regionId: 'string',
      reservedInstanceName: 'string',
      resourceGroupId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      scope: 'string',
      startTime: 'string',
      tag: { 'type': 'array', 'itemType': PurchaseReservedInstancesOfferingRequestTag },
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseReservedInstancesOfferingResponseBody extends $tea.Model {
  orderId?: string;
  requestId?: string;
  reservedInstanceIdSets?: PurchaseReservedInstancesOfferingResponseBodyReservedInstanceIdSets;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      requestId: 'RequestId',
      reservedInstanceIdSets: 'ReservedInstanceIdSets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'string',
      requestId: 'string',
      reservedInstanceIdSets: PurchaseReservedInstancesOfferingResponseBodyReservedInstanceIdSets,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseReservedInstancesOfferingResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: PurchaseReservedInstancesOfferingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PurchaseReservedInstancesOfferingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseSavingPlanOfferingRequest extends $tea.Model {
  chargeType?: string;
  clientToken?: string;
  committedAmount?: string;
  description?: string;
  instanceFamily?: string;
  instanceFamilySet?: string;
  name?: string;
  offeringType?: string;
  ownerAccount?: string;
  ownerId?: number;
  period?: number;
  periodUnit?: string;
  planType?: string;
  purchaseMethod?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      chargeType: 'ChargeType',
      clientToken: 'ClientToken',
      committedAmount: 'CommittedAmount',
      description: 'Description',
      instanceFamily: 'InstanceFamily',
      instanceFamilySet: 'InstanceFamilySet',
      name: 'Name',
      offeringType: 'OfferingType',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      planType: 'PlanType',
      purchaseMethod: 'PurchaseMethod',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chargeType: 'string',
      clientToken: 'string',
      committedAmount: 'string',
      description: 'string',
      instanceFamily: 'string',
      instanceFamilySet: 'string',
      name: 'string',
      offeringType: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      period: 'number',
      periodUnit: 'string',
      planType: 'string',
      purchaseMethod: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseSavingPlanOfferingResponseBody extends $tea.Model {
  orderId?: string;
  requestId?: string;
  savingPlanIdSets?: string[];
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      requestId: 'RequestId',
      savingPlanIdSets: 'SavingPlanIdSets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'string',
      requestId: 'string',
      savingPlanIdSets: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseSavingPlanOfferingResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: PurchaseSavingPlanOfferingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PurchaseSavingPlanOfferingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseStorageCapacityUnitRequest extends $tea.Model {
  amount?: number;
  capacity?: number;
  clientToken?: string;
  description?: string;
  extendParams?: string;
  fromApp?: string;
  name?: string;
  ownerAccount?: string;
  ownerId?: number;
  period?: number;
  periodUnit?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  startTime?: string;
  tag?: PurchaseStorageCapacityUnitRequestTag[];
  static names(): { [key: string]: string } {
    return {
      amount: 'Amount',
      capacity: 'Capacity',
      clientToken: 'ClientToken',
      description: 'Description',
      extendParams: 'ExtendParams',
      fromApp: 'FromApp',
      name: 'Name',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      startTime: 'StartTime',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      amount: 'number',
      capacity: 'number',
      clientToken: 'string',
      description: 'string',
      extendParams: 'string',
      fromApp: 'string',
      name: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      period: 'number',
      periodUnit: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      startTime: 'string',
      tag: { 'type': 'array', 'itemType': PurchaseStorageCapacityUnitRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseStorageCapacityUnitResponseBody extends $tea.Model {
  orderId?: string;
  requestId?: string;
  storageCapacityUnitIds?: PurchaseStorageCapacityUnitResponseBodyStorageCapacityUnitIds;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      requestId: 'RequestId',
      storageCapacityUnitIds: 'StorageCapacityUnitIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'string',
      requestId: 'string',
      storageCapacityUnitIds: PurchaseStorageCapacityUnitResponseBodyStorageCapacityUnitIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseStorageCapacityUnitResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: PurchaseStorageCapacityUnitResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PurchaseStorageCapacityUnitResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEniQosGroupByEniRequest extends $tea.Model {
  networkInterfaceId?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      networkInterfaceId: 'NetworkInterfaceId',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkInterfaceId: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEniQosGroupByEniResponseBody extends $tea.Model {
  qosGroupName?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      qosGroupName: 'QosGroupName',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qosGroupName: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEniQosGroupByEniResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryEniQosGroupByEniResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryEniQosGroupByEniResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEniQosGroupByInstanceRequest extends $tea.Model {
  instanceId?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEniQosGroupByInstanceResponseBody extends $tea.Model {
  data?: QueryEniQosGroupByInstanceResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: QueryEniQosGroupByInstanceResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEniQosGroupByInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryEniQosGroupByInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryEniQosGroupByInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReAddMigrationTaskInPlanRequest extends $tea.Model {
  instanceId?: string;
  migrationPlanId?: string;
  migrationTime?: string;
  networkMigrationType?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      migrationPlanId: 'MigrationPlanId',
      migrationTime: 'MigrationTime',
      networkMigrationType: 'NetworkMigrationType',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      migrationPlanId: 'string',
      migrationTime: 'string',
      networkMigrationType: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReAddMigrationTaskInPlanResponseBody extends $tea.Model {
  failModels?: ReAddMigrationTaskInPlanResponseBodyFailModels;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      failModels: 'FailModels',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failModels: ReAddMigrationTaskInPlanResponseBodyFailModels,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReAddMigrationTaskInPlanResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ReAddMigrationTaskInPlanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReAddMigrationTaskInPlanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseCapacityReservationRequest extends $tea.Model {
  capacityReservationId?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  token?: string;
  static names(): { [key: string]: string } {
    return {
      capacityReservationId: 'CapacityReservationId',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      token: 'Token',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityReservationId: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      token: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseCapacityReservationResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseCapacityReservationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ReleaseCapacityReservationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReleaseCapacityReservationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseDedicatedHostRequest extends $tea.Model {
  dedicatedHostId?: string;
  force?: boolean;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  token?: string;
  static names(): { [key: string]: string } {
    return {
      dedicatedHostId: 'DedicatedHostId',
      force: 'Force',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      token: 'Token',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedHostId: 'string',
      force: 'boolean',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      token: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseDedicatedHostResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseDedicatedHostResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ReleaseDedicatedHostResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReleaseDedicatedHostResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RenewDedicatedHostsRequest extends $tea.Model {
  businessInfo?: string;
  clientToken?: string;
  dedicatedHostIds?: string;
  fromApp?: string;
  ownerAccount?: string;
  ownerId?: number;
  period?: number;
  periodUnit?: string;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      businessInfo: 'BusinessInfo',
      clientToken: 'ClientToken',
      dedicatedHostIds: 'DedicatedHostIds',
      fromApp: 'FromApp',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessInfo: 'string',
      clientToken: 'string',
      dedicatedHostIds: 'string',
      fromApp: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      period: 'number',
      periodUnit: 'string',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RenewDedicatedHostsResponseBody extends $tea.Model {
  dedicatedHostIdSets?: RenewDedicatedHostsResponseBodyDedicatedHostIdSets;
  orderId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      dedicatedHostIdSets: 'DedicatedHostIdSets',
      orderId: 'OrderId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedHostIdSets: RenewDedicatedHostsResponseBodyDedicatedHostIdSets,
      orderId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RenewDedicatedHostsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RenewDedicatedHostsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RenewDedicatedHostsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReviewDiagnosticReportRequest extends $tea.Model {
  category?: string;
  clientToken?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  sourceSystem?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      sourceSystem: 'SourceSystem',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      clientToken: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      sourceSystem: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReviewDiagnosticReportResponseBody extends $tea.Model {
  requestId?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReviewDiagnosticReportResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ReviewDiagnosticReportResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReviewDiagnosticReportResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunInstancesRequest extends $tea.Model {
  hibernationOptions?: RunInstancesRequestHibernationOptions;
  privatePoolOptions?: RunInstancesRequestPrivatePoolOptions;
  schedulerOptions?: RunInstancesRequestSchedulerOptions;
  securityOptions?: RunInstancesRequestSecurityOptions;
  systemDisk?: RunInstancesRequestSystemDisk;
  affinity?: string;
  autoReleaseTime?: string;
  businessInfo?: string;
  clientToken?: string;
  clusterId?: string;
  creditSpecification?: string;
  dataDisk?: RunInstancesRequestDataDisk[];
  dedicatedHostClusterId?: string;
  dedicatedHostId?: string;
  defaultVpc?: string;
  deletionProtection?: boolean;
  deploymentSetGroupNo?: string;
  deploymentSetId?: string;
  description?: string;
  dryRun?: boolean;
  fromApp?: string;
  hostName?: string;
  hostNames?: string[];
  hpcClusterId?: string;
  httpEndpoint?: string;
  httpPutResponseHopLimit?: number;
  httpTokens?: string;
  imageFamily?: string;
  imageId?: string;
  imageOptions?: RunInstancesRequestImageOptions;
  instance?: RunInstancesRequestInstance[];
  instanceName?: string;
  instanceType?: string;
  internetChargeType?: string;
  internetMaxBandwidthIn?: number;
  internetMaxBandwidthOut?: number;
  ioOptimized?: string;
  ipv6Address?: string[];
  ipv6AddressCount?: number;
  isp?: string;
  keyPairName?: string;
  maxAmount?: number;
  minAmount?: number;
  networkInterface?: RunInstancesRequestNetworkInterface[];
  networkType?: string;
  nodeControllerId?: string;
  ownerAccount?: string;
  ownerId?: number;
  password?: string;
  passwordInherit?: boolean;
  privateIpAddress?: string;
  ramRoleName?: string;
  recycleBinResourceId?: string;
  regionId?: string;
  relationOrderId?: string;
  resourceGroupId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  securityEnhancementStrategy?: string;
  securityGroupId?: string;
  securityGroupIds?: string[];
  securityGroupRule?: RunInstancesRequestSecurityGroupRule[];
  spotDuration?: number;
  spotInterruptionBehavior?: string;
  spotPriceLimit?: number;
  spotStrategy?: string;
  storageSetId?: string;
  storageSetPartitionNumber?: number;
  tag?: RunInstancesRequestTag[];
  tenancy?: string;
  uniqueSuffix?: boolean;
  userData?: string;
  vSwitchId?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      hibernationOptions: 'HibernationOptions',
      privatePoolOptions: 'PrivatePoolOptions',
      schedulerOptions: 'SchedulerOptions',
      securityOptions: 'SecurityOptions',
      systemDisk: 'SystemDisk',
      affinity: 'Affinity',
      autoReleaseTime: 'AutoReleaseTime',
      businessInfo: 'BusinessInfo',
      clientToken: 'ClientToken',
      clusterId: 'ClusterId',
      creditSpecification: 'CreditSpecification',
      dataDisk: 'DataDisk',
      dedicatedHostClusterId: 'DedicatedHostClusterId',
      dedicatedHostId: 'DedicatedHostId',
      defaultVpc: 'DefaultVpc',
      deletionProtection: 'DeletionProtection',
      deploymentSetGroupNo: 'DeploymentSetGroupNo',
      deploymentSetId: 'DeploymentSetId',
      description: 'Description',
      dryRun: 'DryRun',
      fromApp: 'FromApp',
      hostName: 'HostName',
      hostNames: 'HostNames',
      hpcClusterId: 'HpcClusterId',
      httpEndpoint: 'HttpEndpoint',
      httpPutResponseHopLimit: 'HttpPutResponseHopLimit',
      httpTokens: 'HttpTokens',
      imageFamily: 'ImageFamily',
      imageId: 'ImageId',
      imageOptions: 'ImageOptions',
      instance: 'Instance',
      instanceName: 'InstanceName',
      instanceType: 'InstanceType',
      internetChargeType: 'InternetChargeType',
      internetMaxBandwidthIn: 'InternetMaxBandwidthIn',
      internetMaxBandwidthOut: 'InternetMaxBandwidthOut',
      ioOptimized: 'IoOptimized',
      ipv6Address: 'Ipv6Address',
      ipv6AddressCount: 'Ipv6AddressCount',
      isp: 'Isp',
      keyPairName: 'KeyPairName',
      maxAmount: 'MaxAmount',
      minAmount: 'MinAmount',
      networkInterface: 'NetworkInterface',
      networkType: 'NetworkType',
      nodeControllerId: 'NodeControllerId',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      password: 'Password',
      passwordInherit: 'PasswordInherit',
      privateIpAddress: 'PrivateIpAddress',
      ramRoleName: 'RamRoleName',
      recycleBinResourceId: 'RecycleBinResourceId',
      regionId: 'RegionId',
      relationOrderId: 'RelationOrderId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      securityEnhancementStrategy: 'SecurityEnhancementStrategy',
      securityGroupId: 'SecurityGroupId',
      securityGroupIds: 'SecurityGroupIds',
      securityGroupRule: 'SecurityGroupRule',
      spotDuration: 'SpotDuration',
      spotInterruptionBehavior: 'SpotInterruptionBehavior',
      spotPriceLimit: 'SpotPriceLimit',
      spotStrategy: 'SpotStrategy',
      storageSetId: 'StorageSetId',
      storageSetPartitionNumber: 'StorageSetPartitionNumber',
      tag: 'Tag',
      tenancy: 'Tenancy',
      uniqueSuffix: 'UniqueSuffix',
      userData: 'UserData',
      vSwitchId: 'VSwitchId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hibernationOptions: RunInstancesRequestHibernationOptions,
      privatePoolOptions: RunInstancesRequestPrivatePoolOptions,
      schedulerOptions: RunInstancesRequestSchedulerOptions,
      securityOptions: RunInstancesRequestSecurityOptions,
      systemDisk: RunInstancesRequestSystemDisk,
      affinity: 'string',
      autoReleaseTime: 'string',
      businessInfo: 'string',
      clientToken: 'string',
      clusterId: 'string',
      creditSpecification: 'string',
      dataDisk: { 'type': 'array', 'itemType': RunInstancesRequestDataDisk },
      dedicatedHostClusterId: 'string',
      dedicatedHostId: 'string',
      defaultVpc: 'string',
      deletionProtection: 'boolean',
      deploymentSetGroupNo: 'string',
      deploymentSetId: 'string',
      description: 'string',
      dryRun: 'boolean',
      fromApp: 'string',
      hostName: 'string',
      hostNames: { 'type': 'array', 'itemType': 'string' },
      hpcClusterId: 'string',
      httpEndpoint: 'string',
      httpPutResponseHopLimit: 'number',
      httpTokens: 'string',
      imageFamily: 'string',
      imageId: 'string',
      imageOptions: RunInstancesRequestImageOptions,
      instance: { 'type': 'array', 'itemType': RunInstancesRequestInstance },
      instanceName: 'string',
      instanceType: 'string',
      internetChargeType: 'string',
      internetMaxBandwidthIn: 'number',
      internetMaxBandwidthOut: 'number',
      ioOptimized: 'string',
      ipv6Address: { 'type': 'array', 'itemType': 'string' },
      ipv6AddressCount: 'number',
      isp: 'string',
      keyPairName: 'string',
      maxAmount: 'number',
      minAmount: 'number',
      networkInterface: { 'type': 'array', 'itemType': RunInstancesRequestNetworkInterface },
      networkType: 'string',
      nodeControllerId: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      password: 'string',
      passwordInherit: 'boolean',
      privateIpAddress: 'string',
      ramRoleName: 'string',
      recycleBinResourceId: 'string',
      regionId: 'string',
      relationOrderId: 'string',
      resourceGroupId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      securityEnhancementStrategy: 'string',
      securityGroupId: 'string',
      securityGroupIds: { 'type': 'array', 'itemType': 'string' },
      securityGroupRule: { 'type': 'array', 'itemType': RunInstancesRequestSecurityGroupRule },
      spotDuration: 'number',
      spotInterruptionBehavior: 'string',
      spotPriceLimit: 'number',
      spotStrategy: 'string',
      storageSetId: 'string',
      storageSetPartitionNumber: 'number',
      tag: { 'type': 'array', 'itemType': RunInstancesRequestTag },
      tenancy: 'string',
      uniqueSuffix: 'boolean',
      userData: 'string',
      vSwitchId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunInstancesResponseBody extends $tea.Model {
  instanceIdSets?: RunInstancesResponseBodyInstanceIdSets;
  requestId?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceIdSets: 'InstanceIdSets',
      requestId: 'RequestId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceIdSets: RunInstancesResponseBodyInstanceIdSets,
      requestId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RunInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RunInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetInstanceAutoReleaseTimeRequest extends $tea.Model {
  autoReleaseTime?: string;
  instanceId?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      autoReleaseTime: 'AutoReleaseTime',
      instanceId: 'InstanceId',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoReleaseTime: 'string',
      instanceId: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetInstanceAutoReleaseTimeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetInstanceAutoReleaseTimeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetInstanceAutoReleaseTimeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetInstanceAutoReleaseTimeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartNetworkInsightsAnalysisRequest extends $tea.Model {
  dryRun?: boolean;
  networkInsightsPathId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      dryRun: 'DryRun',
      networkInsightsPathId: 'NetworkInsightsPathId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dryRun: 'boolean',
      networkInsightsPathId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartNetworkInsightsAnalysisResponseBody extends $tea.Model {
  networkInsightsAnalysisId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      networkInsightsAnalysisId: 'NetworkInsightsAnalysisId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkInsightsAnalysisId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartNetworkInsightsAnalysisResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: StartNetworkInsightsAnalysisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartNetworkInsightsAnalysisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateServiceSettingsRequest extends $tea.Model {
  cloudAssistantDeliverySettings?: UpdateServiceSettingsRequestCloudAssistantDeliverySettings;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      cloudAssistantDeliverySettings: 'CloudAssistantDeliverySettings',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cloudAssistantDeliverySettings: UpdateServiceSettingsRequestCloudAssistantDeliverySettings,
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateServiceSettingsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateServiceSettingsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateServiceSettingsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateServiceSettingsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnmountPEDiskRequest extends $tea.Model {
  category?: string;
  clientToken?: string;
  ownerAccount?: string;
  ownerId?: number;
  regionId?: string;
  resourceId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  sourceSystem?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      sourceSystem: 'SourceSystem',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      clientToken: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      sourceSystem: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnmountPEDiskResponseBody extends $tea.Model {
  requestId?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnmountPEDiskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UnmountPEDiskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UnmountPEDiskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AllocateDedicatedHostsRequestNetworkAttributes extends $tea.Model {
  slbUdpTimeout?: number;
  udpTimeout?: number;
  static names(): { [key: string]: string } {
    return {
      slbUdpTimeout: 'SlbUdpTimeout',
      udpTimeout: 'UdpTimeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      slbUdpTimeout: 'number',
      udpTimeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AllocateDedicatedHostsRequestSchedulerOptions extends $tea.Model {
  managedPrivateSpaceId?: string;
  static names(): { [key: string]: string } {
    return {
      managedPrivateSpaceId: 'ManagedPrivateSpaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      managedPrivateSpaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AllocateDedicatedHostsRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AllocateDedicatedHostsResponseBodyDedicatedHostIdSets extends $tea.Model {
  dedicatedHostId?: string[];
  static names(): { [key: string]: string } {
    return {
      dedicatedHostId: 'DedicatedHostId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedHostId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigureSecurityGroupPermissionsRequestAuthorizePermission extends $tea.Model {
  description?: string;
  destCidrIp?: string;
  destGroupId?: string;
  destPrefixListId?: string;
  direction?: string;
  gressFlow?: string;
  groupOwnerAccount?: string;
  groupOwnerId?: number;
  ipProtocol?: string;
  ipv6DestCidrIp?: string;
  ipv6SourceCidrIp?: string;
  nicType?: string;
  policy?: string;
  portRange?: string;
  priority?: string;
  sourceCidrIp?: string;
  sourceGroupId?: string;
  sourcePortRange?: string;
  sourcePrefixListId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      destCidrIp: 'DestCidrIp',
      destGroupId: 'DestGroupId',
      destPrefixListId: 'DestPrefixListId',
      direction: 'Direction',
      gressFlow: 'GressFlow',
      groupOwnerAccount: 'GroupOwnerAccount',
      groupOwnerId: 'GroupOwnerId',
      ipProtocol: 'IpProtocol',
      ipv6DestCidrIp: 'Ipv6DestCidrIp',
      ipv6SourceCidrIp: 'Ipv6SourceCidrIp',
      nicType: 'NicType',
      policy: 'Policy',
      portRange: 'PortRange',
      priority: 'Priority',
      sourceCidrIp: 'SourceCidrIp',
      sourceGroupId: 'SourceGroupId',
      sourcePortRange: 'SourcePortRange',
      sourcePrefixListId: 'SourcePrefixListId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      destCidrIp: 'string',
      destGroupId: 'string',
      destPrefixListId: 'string',
      direction: 'string',
      gressFlow: 'string',
      groupOwnerAccount: 'string',
      groupOwnerId: 'number',
      ipProtocol: 'string',
      ipv6DestCidrIp: 'string',
      ipv6SourceCidrIp: 'string',
      nicType: 'string',
      policy: 'string',
      portRange: 'string',
      priority: 'string',
      sourceCidrIp: 'string',
      sourceGroupId: 'string',
      sourcePortRange: 'string',
      sourcePrefixListId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigureSecurityGroupPermissionsRequestRevokePermission extends $tea.Model {
  description?: string;
  destCidrIp?: string;
  destGroupId?: string;
  destPrefixListId?: string;
  direction?: string;
  gressFlow?: string;
  groupOwnerAccount?: string;
  groupOwnerId?: number;
  ipProtocol?: string;
  ipv6DestCidrIp?: string;
  ipv6SourceCidrIp?: string;
  nicType?: string;
  policy?: string;
  portRange?: string;
  priority?: string;
  sourceCidrIp?: string;
  sourceGroupId?: string;
  sourcePortRange?: string;
  sourcePrefixListId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      destCidrIp: 'DestCidrIp',
      destGroupId: 'DestGroupId',
      destPrefixListId: 'DestPrefixListId',
      direction: 'Direction',
      gressFlow: 'GressFlow',
      groupOwnerAccount: 'GroupOwnerAccount',
      groupOwnerId: 'GroupOwnerId',
      ipProtocol: 'IpProtocol',
      ipv6DestCidrIp: 'Ipv6DestCidrIp',
      ipv6SourceCidrIp: 'Ipv6SourceCidrIp',
      nicType: 'NicType',
      policy: 'Policy',
      portRange: 'PortRange',
      priority: 'Priority',
      sourceCidrIp: 'SourceCidrIp',
      sourceGroupId: 'SourceGroupId',
      sourcePortRange: 'SourcePortRange',
      sourcePrefixListId: 'SourcePrefixListId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      destCidrIp: 'string',
      destGroupId: 'string',
      destPrefixListId: 'string',
      direction: 'string',
      gressFlow: 'string',
      groupOwnerAccount: 'string',
      groupOwnerId: 'number',
      ipProtocol: 'string',
      ipv6DestCidrIp: 'string',
      ipv6SourceCidrIp: 'string',
      nicType: 'string',
      policy: 'string',
      portRange: 'string',
      priority: 'string',
      sourceCidrIp: 'string',
      sourceGroupId: 'string',
      sourcePortRange: 'string',
      sourcePrefixListId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfirmReservationDemandRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCapacityReservationRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDedicatedHostClusterRequestSchedulerOptions extends $tea.Model {
  managedPrivateSpaceId?: string;
  static names(): { [key: string]: string } {
    return {
      managedPrivateSpaceId: 'ManagedPrivateSpaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      managedPrivateSpaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDedicatedHostClusterRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDiagnoseRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDiagnosticReportResponseBodyCommandInvokeResultsInvokeResult extends $tea.Model {
  commandName?: string;
  dataFileDir?: string;
  invokeResult?: string;
  static names(): { [key: string]: string } {
    return {
      commandName: 'CommandName',
      dataFileDir: 'DataFileDir',
      invokeResult: 'InvokeResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commandName: 'string',
      dataFileDir: 'string',
      invokeResult: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDiagnosticReportResponseBodyCommandInvokeResults extends $tea.Model {
  invokeResult?: CreateDiagnosticReportResponseBodyCommandInvokeResultsInvokeResult[];
  static names(): { [key: string]: string } {
    return {
      invokeResult: 'InvokeResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invokeResult: { 'type': 'array', 'itemType': CreateDiagnosticReportResponseBodyCommandInvokeResultsInvokeResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDisksRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDisksResponseBodyDiskId extends $tea.Model {
  diskIds?: string[];
  static names(): { [key: string]: string } {
    return {
      diskIds: 'DiskIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateElasticityAssuranceRequestPrivatePoolOptions extends $tea.Model {
  matchCriteria?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      matchCriteria: 'MatchCriteria',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchCriteria: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateElasticityAssuranceRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateIssueCategoryReportRelationRequestRelationModelList extends $tea.Model {
  customerInputContent?: string;
  issueCategoryId?: number;
  issueCategoryName?: string;
  mappingTools?: string;
  reportId?: string;
  static names(): { [key: string]: string } {
    return {
      customerInputContent: 'CustomerInputContent',
      issueCategoryId: 'IssueCategoryId',
      issueCategoryName: 'IssueCategoryName',
      mappingTools: 'MappingTools',
      reportId: 'ReportId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customerInputContent: 'string',
      issueCategoryId: 'number',
      issueCategoryName: 'string',
      mappingTools: 'string',
      reportId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMigrationPlanRequestCustomMigrationTimes extends $tea.Model {
  instanceId?: string;
  migrationTime?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      migrationTime: 'MigrationTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      migrationTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModelFailModels extends $tea.Model {
  failModel?: CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel[];
  static names(): { [key: string]: string } {
    return {
      failModel: 'FailModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failModel: { 'type': 'array', 'itemType': CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModel extends $tea.Model {
  failModels?: CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModelFailModels;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      failModels: 'FailModels',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failModels: CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModelFailModels,
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMigrationPlanResponseBodyInstancesFailModels extends $tea.Model {
  instancesFailModel?: CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModel[];
  static names(): { [key: string]: string } {
    return {
      instancesFailModel: 'InstancesFailModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instancesFailModel: { 'type': 'array', 'itemType': CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMigrationPlanResponseBodyPlanFailModelsPlanFailModel extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMigrationPlanResponseBodyPlanFailModels extends $tea.Model {
  planFailModel?: CreateMigrationPlanResponseBodyPlanFailModelsPlanFailModel[];
  static names(): { [key: string]: string } {
    return {
      planFailModel: 'PlanFailModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      planFailModel: { 'type': 'array', 'itemType': CreateMigrationPlanResponseBodyPlanFailModelsPlanFailModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMigrationPlanResponseBodySgFailModelsSgFailModelFailModelsFailModel extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMigrationPlanResponseBodySgFailModelsSgFailModelFailModels extends $tea.Model {
  failModel?: CreateMigrationPlanResponseBodySgFailModelsSgFailModelFailModelsFailModel[];
  static names(): { [key: string]: string } {
    return {
      failModel: 'FailModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failModel: { 'type': 'array', 'itemType': CreateMigrationPlanResponseBodySgFailModelsSgFailModelFailModelsFailModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMigrationPlanResponseBodySgFailModelsSgFailModel extends $tea.Model {
  failModels?: CreateMigrationPlanResponseBodySgFailModelsSgFailModelFailModels;
  groupNo?: string;
  static names(): { [key: string]: string } {
    return {
      failModels: 'FailModels',
      groupNo: 'GroupNo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failModels: CreateMigrationPlanResponseBodySgFailModelsSgFailModelFailModels,
      groupNo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMigrationPlanResponseBodySgFailModels extends $tea.Model {
  sgFailModel?: CreateMigrationPlanResponseBodySgFailModelsSgFailModel[];
  static names(): { [key: string]: string } {
    return {
      sgFailModel: 'SgFailModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sgFailModel: { 'type': 'array', 'itemType': CreateMigrationPlanResponseBodySgFailModelsSgFailModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrderResponseBodyOrderParams extends $tea.Model {
  orderParam?: string[];
  static names(): { [key: string]: string } {
    return {
      orderParam: 'OrderParam',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderParam: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSetInstanceIdSet extends $tea.Model {
  instanceIds?: string[];
  static names(): { [key: string]: string } {
    return {
      instanceIds: 'InstanceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSetRelatedOrderIds extends $tea.Model {
  relatedOrderId?: string[];
  static names(): { [key: string]: string } {
    return {
      relatedOrderId: 'RelatedOrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      relatedOrderId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSet extends $tea.Model {
  instanceIdSet?: CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSetInstanceIdSet;
  relatedOrderIds?: CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSetRelatedOrderIds;
  static names(): { [key: string]: string } {
    return {
      instanceIdSet: 'InstanceIdSet',
      relatedOrderIds: 'RelatedOrderIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceIdSet: CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSetInstanceIdSet,
      relatedOrderIds: CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSetRelatedOrderIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrderResponseBodyRelatedOrderItemSets extends $tea.Model {
  relatedOrderItemSet?: CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSet[];
  static names(): { [key: string]: string } {
    return {
      relatedOrderItemSet: 'RelatedOrderItemSet',
    };
  }

  static types(): { [key: string]: any } {
    return {
      relatedOrderItemSet: { 'type': 'array', 'itemType': CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSet },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateReservationDemandRequestPrivatePoolOptions extends $tea.Model {
  instanceAmount?: number;
  instanceType?: string;
  matchCriteria?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceAmount: 'InstanceAmount',
      instanceType: 'InstanceType',
      matchCriteria: 'MatchCriteria',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceAmount: 'number',
      instanceType: 'string',
      matchCriteria: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateReservationDemandRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVolumesRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVolumesResponseBodyVolumeIds extends $tea.Model {
  volumeId?: string[];
  static names(): { [key: string]: string } {
    return {
      volumeId: 'VolumeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      volumeId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingOrderRequestCpuOptions extends $tea.Model {
  core?: number;
  numa?: string;
  threadsPerCore?: number;
  static names(): { [key: string]: string } {
    return {
      core: 'Core',
      numa: 'Numa',
      threadsPerCore: 'ThreadsPerCore',
    };
  }

  static types(): { [key: string]: any } {
    return {
      core: 'number',
      numa: 'string',
      threadsPerCore: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingOrderRequestHibernationOptions extends $tea.Model {
  configured?: boolean;
  static names(): { [key: string]: string } {
    return {
      configured: 'Configured',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configured: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingOrderRequestPrivatePoolOptions extends $tea.Model {
  id?: string;
  matchCriteria?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      matchCriteria: 'MatchCriteria',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      matchCriteria: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingOrderRequestSchedulerOptions extends $tea.Model {
  dedicatedHostClusterId?: string;
  static names(): { [key: string]: string } {
    return {
      dedicatedHostClusterId: 'DedicatedHostClusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedHostClusterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingOrderRequestSecurityOptions extends $tea.Model {
  confidentialComputingMode?: string;
  trustedSystemMode?: string;
  static names(): { [key: string]: string } {
    return {
      confidentialComputingMode: 'ConfidentialComputingMode',
      trustedSystemMode: 'TrustedSystemMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      confidentialComputingMode: 'string',
      trustedSystemMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingOrderRequestSystemDisk extends $tea.Model {
  autoSnapshotPolicyId?: string;
  category?: string;
  description?: string;
  diskName?: string;
  performanceLevel?: string;
  size?: string;
  storageClusterId?: string;
  static names(): { [key: string]: string } {
    return {
      autoSnapshotPolicyId: 'AutoSnapshotPolicyId',
      category: 'Category',
      description: 'Description',
      diskName: 'DiskName',
      performanceLevel: 'PerformanceLevel',
      size: 'Size',
      storageClusterId: 'StorageClusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoSnapshotPolicyId: 'string',
      category: 'string',
      description: 'string',
      diskName: 'string',
      performanceLevel: 'string',
      size: 'string',
      storageClusterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingOrderRequestArn extends $tea.Model {
  assumeRoleFor?: number;
  roleType?: string;
  rolearn?: string;
  static names(): { [key: string]: string } {
    return {
      assumeRoleFor: 'AssumeRoleFor',
      roleType: 'RoleType',
      rolearn: 'Rolearn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assumeRoleFor: 'number',
      roleType: 'string',
      rolearn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingOrderRequestDataDisk extends $tea.Model {
  autoSnapshotPolicyId?: string;
  category?: string;
  deleteWithInstance?: boolean;
  description?: string;
  device?: string;
  diskName?: string;
  encryptAlgorithm?: string;
  encrypted?: string;
  KMSKeyId?: string;
  performanceLevel?: string;
  size?: number;
  snapshotId?: string;
  storageClusterId?: string;
  static names(): { [key: string]: string } {
    return {
      autoSnapshotPolicyId: 'AutoSnapshotPolicyId',
      category: 'Category',
      deleteWithInstance: 'DeleteWithInstance',
      description: 'Description',
      device: 'Device',
      diskName: 'DiskName',
      encryptAlgorithm: 'EncryptAlgorithm',
      encrypted: 'Encrypted',
      KMSKeyId: 'KMSKeyId',
      performanceLevel: 'PerformanceLevel',
      size: 'Size',
      snapshotId: 'SnapshotId',
      storageClusterId: 'StorageClusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoSnapshotPolicyId: 'string',
      category: 'string',
      deleteWithInstance: 'boolean',
      description: 'string',
      device: 'string',
      diskName: 'string',
      encryptAlgorithm: 'string',
      encrypted: 'string',
      KMSKeyId: 'string',
      performanceLevel: 'string',
      size: 'number',
      snapshotId: 'string',
      storageClusterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingOrderRequestNetworkInterface extends $tea.Model {
  description?: string;
  networkInterfaceName?: string;
  primaryIpAddress?: string;
  queueNumber?: number;
  securityGroupId?: string;
  securityGroupIds?: string[];
  vSwitchId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      networkInterfaceName: 'NetworkInterfaceName',
      primaryIpAddress: 'PrimaryIpAddress',
      queueNumber: 'QueueNumber',
      securityGroupId: 'SecurityGroupId',
      securityGroupIds: 'SecurityGroupIds',
      vSwitchId: 'VSwitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      networkInterfaceName: 'string',
      primaryIpAddress: 'string',
      queueNumber: 'number',
      securityGroupId: 'string',
      securityGroupIds: { 'type': 'array', 'itemType': 'string' },
      vSwitchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingOrderRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteReservationDemandRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem extends $tea.Model {
  count?: number;
  diskCategory?: string;
  expiredTime?: string;
  instanceChargeType?: string;
  instanceType?: string;
  value?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      diskCategory: 'DiskCategory',
      expiredTime: 'ExpiredTime',
      instanceChargeType: 'InstanceChargeType',
      instanceType: 'InstanceType',
      value: 'Value',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      diskCategory: 'string',
      expiredTime: 'string',
      instanceChargeType: 'string',
      instanceType: 'string',
      value: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValues extends $tea.Model {
  valueItem?: DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem[];
  static names(): { [key: string]: string } {
    return {
      valueItem: 'ValueItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      valueItem: { 'type': 'array', 'itemType': DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem extends $tea.Model {
  attributeName?: string;
  attributeValues?: DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValues;
  static names(): { [key: string]: string } {
    return {
      attributeName: 'AttributeName',
      attributeValues: 'AttributeValues',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attributeName: 'string',
      attributeValues: DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValues,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountAttributesResponseBodyAccountAttributeItems extends $tea.Model {
  accountAttributeItem?: DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem[];
  static names(): { [key: string]: string } {
    return {
      accountAttributeItem: 'AccountAttributeItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountAttributeItem: { 'type': 'array', 'itemType': DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountLimitsRequestFilter extends $tea.Model {
  key?: string;
  value?: string[];
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountLimitsResponseBodyAccountLimitTypeSetAccountLimitLimitValueSet extends $tea.Model {
  limitValue?: string[];
  static names(): { [key: string]: string } {
    return {
      limitValue: 'LimitValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      limitValue: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountLimitsResponseBodyAccountLimitTypeSetAccountLimit extends $tea.Model {
  limitName?: string;
  limitValueSet?: DescribeAccountLimitsResponseBodyAccountLimitTypeSetAccountLimitLimitValueSet;
  static names(): { [key: string]: string } {
    return {
      limitName: 'LimitName',
      limitValueSet: 'LimitValueSet',
    };
  }

  static types(): { [key: string]: any } {
    return {
      limitName: 'string',
      limitValueSet: DescribeAccountLimitsResponseBodyAccountLimitTypeSetAccountLimitLimitValueSet,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountLimitsResponseBodyAccountLimitTypeSet extends $tea.Model {
  accountLimit?: DescribeAccountLimitsResponseBodyAccountLimitTypeSetAccountLimit[];
  static names(): { [key: string]: string } {
    return {
      accountLimit: 'AccountLimit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountLimit: { 'type': 'array', 'itemType': DescribeAccountLimitsResponseBodyAccountLimitTypeSetAccountLimit },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountQuotaAttributesResponseBodyQuotaAttributes extends $tea.Model {
  ecsElasticQuotaEnable?: boolean;
  static names(): { [key: string]: string } {
    return {
      ecsElasticQuotaEnable: 'EcsElasticQuotaEnable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ecsElasticQuotaEnable: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupCapacitiesResponseBodyCapacitiesCapacity extends $tea.Model {
  autoProvisioningGroupId?: string;
  payAsYouGoCapacity?: string;
  spotCapacity?: string;
  totalCapacity?: string;
  static names(): { [key: string]: string } {
    return {
      autoProvisioningGroupId: 'AutoProvisioningGroupId',
      payAsYouGoCapacity: 'PayAsYouGoCapacity',
      spotCapacity: 'SpotCapacity',
      totalCapacity: 'TotalCapacity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoProvisioningGroupId: 'string',
      payAsYouGoCapacity: 'string',
      spotCapacity: 'string',
      totalCapacity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupCapacitiesResponseBodyCapacities extends $tea.Model {
  capacity?: DescribeAutoProvisioningGroupCapacitiesResponseBodyCapacitiesCapacity[];
  static names(): { [key: string]: string } {
    return {
      capacity: 'Capacity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacity: { 'type': 'array', 'itemType': DescribeAutoProvisioningGroupCapacitiesResponseBodyCapacitiesCapacity },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBandwidthPriceResponseBodyPriceInfoOrderRuleIdSet extends $tea.Model {
  ruleId?: string[];
  static names(): { [key: string]: string } {
    return {
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBandwidthPriceResponseBodyPriceInfoOrder extends $tea.Model {
  currency?: string;
  discountPrice?: number;
  originalPrice?: number;
  ruleIdSet?: DescribeBandwidthPriceResponseBodyPriceInfoOrderRuleIdSet;
  tradePrice?: number;
  static names(): { [key: string]: string } {
    return {
      currency: 'Currency',
      discountPrice: 'DiscountPrice',
      originalPrice: 'OriginalPrice',
      ruleIdSet: 'RuleIdSet',
      tradePrice: 'TradePrice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currency: 'string',
      discountPrice: 'number',
      originalPrice: 'number',
      ruleIdSet: DescribeBandwidthPriceResponseBodyPriceInfoOrderRuleIdSet,
      tradePrice: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBandwidthPriceResponseBodyPriceInfoRulesRule extends $tea.Model {
  name?: string;
  ruleId?: number;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      ruleId: 'RuleId',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      ruleId: 'number',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBandwidthPriceResponseBodyPriceInfoRules extends $tea.Model {
  rule?: DescribeBandwidthPriceResponseBodyPriceInfoRulesRule[];
  static names(): { [key: string]: string } {
    return {
      rule: 'Rule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rule: { 'type': 'array', 'itemType': DescribeBandwidthPriceResponseBodyPriceInfoRulesRule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBandwidthPriceResponseBodyPriceInfo extends $tea.Model {
  order?: DescribeBandwidthPriceResponseBodyPriceInfoOrder;
  rules?: DescribeBandwidthPriceResponseBodyPriceInfoRules;
  static names(): { [key: string]: string } {
    return {
      order: 'Order',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      order: DescribeBandwidthPriceResponseBodyPriceInfoOrder,
      rules: DescribeBandwidthPriceResponseBodyPriceInfoRules,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCapacityReservationsRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCapacityReservationsResponseBodyCapacityReservationsCapacityReservation extends $tea.Model {
  availableInstanceCount?: number;
  capacityReservationId?: string;
  capacityReservationName?: string;
  description?: string;
  endDateType?: string;
  instanceMatchCriteria?: string;
  instancePlatform?: string;
  instanceType?: string;
  networkType?: string;
  regionId?: string;
  status?: string;
  timeSlot?: string;
  totalInstanceCount?: number;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      availableInstanceCount: 'AvailableInstanceCount',
      capacityReservationId: 'CapacityReservationId',
      capacityReservationName: 'CapacityReservationName',
      description: 'Description',
      endDateType: 'EndDateType',
      instanceMatchCriteria: 'InstanceMatchCriteria',
      instancePlatform: 'InstancePlatform',
      instanceType: 'InstanceType',
      networkType: 'NetworkType',
      regionId: 'RegionId',
      status: 'Status',
      timeSlot: 'TimeSlot',
      totalInstanceCount: 'TotalInstanceCount',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableInstanceCount: 'number',
      capacityReservationId: 'string',
      capacityReservationName: 'string',
      description: 'string',
      endDateType: 'string',
      instanceMatchCriteria: 'string',
      instancePlatform: 'string',
      instanceType: 'string',
      networkType: 'string',
      regionId: 'string',
      status: 'string',
      timeSlot: 'string',
      totalInstanceCount: 'number',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCapacityReservationsResponseBodyCapacityReservations extends $tea.Model {
  capacityReservation?: DescribeCapacityReservationsResponseBodyCapacityReservationsCapacityReservation[];
  static names(): { [key: string]: string } {
    return {
      capacityReservation: 'CapacityReservation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityReservation: { 'type': 'array', 'itemType': DescribeCapacityReservationsResponseBodyCapacityReservationsCapacityReservation },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomerIssueCategoryResponseBodyIssueCategoryModelList extends $tea.Model {
  issueCategoryId?: number;
  issueCategoryName?: string;
  issueCategoryParentId?: number;
  layer?: number;
  mappingTools?: string;
  metricSetId?: string;
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      issueCategoryId: 'IssueCategoryId',
      issueCategoryName: 'IssueCategoryName',
      issueCategoryParentId: 'IssueCategoryParentId',
      layer: 'Layer',
      mappingTools: 'MappingTools',
      metricSetId: 'MetricSetId',
      resourceType: 'ResourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      issueCategoryId: 'number',
      issueCategoryName: 'string',
      issueCategoryParentId: 'number',
      layer: 'number',
      mappingTools: 'string',
      metricSetId: 'string',
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostAutoRenewResponseBodyInstanceRenewAttributesInstanceRenewAttribute extends $tea.Model {
  autoRenewEnabled?: boolean;
  duration?: number;
  instanceId?: string;
  periodUnit?: string;
  renewalStatus?: string;
  static names(): { [key: string]: string } {
    return {
      autoRenewEnabled: 'AutoRenewEnabled',
      duration: 'Duration',
      instanceId: 'InstanceId',
      periodUnit: 'PeriodUnit',
      renewalStatus: 'RenewalStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRenewEnabled: 'boolean',
      duration: 'number',
      instanceId: 'string',
      periodUnit: 'string',
      renewalStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostAutoRenewResponseBodyInstanceRenewAttributes extends $tea.Model {
  instanceRenewAttribute?: DescribeDedicatedHostAutoRenewResponseBodyInstanceRenewAttributesInstanceRenewAttribute[];
  static names(): { [key: string]: string } {
    return {
      instanceRenewAttribute: 'InstanceRenewAttribute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceRenewAttribute: { 'type': 'array', 'itemType': DescribeDedicatedHostAutoRenewResponseBodyInstanceRenewAttributesInstanceRenewAttribute },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersRequestSchedulerOptions extends $tea.Model {
  managedPrivateSpaceId?: string;
  static names(): { [key: string]: string } {
    return {
      managedPrivateSpaceId: 'ManagedPrivateSpaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      managedPrivateSpaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterSchedulerOptions extends $tea.Model {
  managedPrivateSpaceId?: string;
  static names(): { [key: string]: string } {
    return {
      managedPrivateSpaceId: 'ManagedPrivateSpaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      managedPrivateSpaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType extends $tea.Model {
  availableInstanceCapacity?: number;
  instanceType?: string;
  static names(): { [key: string]: string } {
    return {
      availableInstanceCapacity: 'AvailableInstanceCapacity',
      instanceType: 'InstanceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableInstanceCapacity: 'number',
      instanceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypes extends $tea.Model {
  availableInstanceType?: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType[];
  static names(): { [key: string]: string } {
    return {
      availableInstanceType: 'AvailableInstanceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableInstanceType: { 'type': 'array', 'itemType': DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity extends $tea.Model {
  availableDisk?: number;
  dataDiskCategory?: string;
  totalDisk?: number;
  static names(): { [key: string]: string } {
    return {
      availableDisk: 'AvailableDisk',
      dataDiskCategory: 'DataDiskCategory',
      totalDisk: 'TotalDisk',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableDisk: 'number',
      dataDiskCategory: 'string',
      totalDisk: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacities extends $tea.Model {
  localStorageCapacity?: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity[];
  static names(): { [key: string]: string } {
    return {
      localStorageCapacity: 'LocalStorageCapacity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      localStorageCapacity: { 'type': 'array', 'itemType': DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacity extends $tea.Model {
  availableInstanceTypes?: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypes;
  availableMemory?: number;
  availableVcpus?: number;
  localStorageCapacities?: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacities;
  totalMemory?: number;
  totalVcpus?: number;
  static names(): { [key: string]: string } {
    return {
      availableInstanceTypes: 'AvailableInstanceTypes',
      availableMemory: 'AvailableMemory',
      availableVcpus: 'AvailableVcpus',
      localStorageCapacities: 'LocalStorageCapacities',
      totalMemory: 'TotalMemory',
      totalVcpus: 'TotalVcpus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableInstanceTypes: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypes,
      availableMemory: 'number',
      availableVcpus: 'number',
      localStorageCapacities: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacities,
      totalMemory: 'number',
      totalVcpus: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostIds extends $tea.Model {
  dedicatedHostId?: string[];
  static names(): { [key: string]: string } {
    return {
      dedicatedHostId: 'DedicatedHostId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedHostId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTags extends $tea.Model {
  tag?: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster extends $tea.Model {
  schedulerOptions: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterSchedulerOptions;
  dedicatedHostClusterCapacity?: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacity;
  dedicatedHostClusterId?: string;
  dedicatedHostClusterName?: string;
  dedicatedHostIds?: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostIds;
  description?: string;
  regionId?: string;
  resourceGroupId?: string;
  tags?: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTags;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      schedulerOptions: 'SchedulerOptions',
      dedicatedHostClusterCapacity: 'DedicatedHostClusterCapacity',
      dedicatedHostClusterId: 'DedicatedHostClusterId',
      dedicatedHostClusterName: 'DedicatedHostClusterName',
      dedicatedHostIds: 'DedicatedHostIds',
      description: 'Description',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tags: 'Tags',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      schedulerOptions: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterSchedulerOptions,
      dedicatedHostClusterCapacity: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacity,
      dedicatedHostClusterId: 'string',
      dedicatedHostClusterName: 'string',
      dedicatedHostIds: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostIds,
      description: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      tags: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTags,
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters extends $tea.Model {
  dedicatedHostCluster?: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster[];
  static names(): { [key: string]: string } {
    return {
      dedicatedHostCluster: 'DedicatedHostCluster',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedHostCluster: { 'type': 'array', 'itemType': DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportInstanceTypeFamilies extends $tea.Model {
  supportInstanceTypeFamily?: string[];
  static names(): { [key: string]: string } {
    return {
      supportInstanceTypeFamily: 'SupportInstanceTypeFamily',
    };
  }

  static types(): { [key: string]: any } {
    return {
      supportInstanceTypeFamily: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportInstanceTypesList extends $tea.Model {
  supportInstanceTypesList?: string[];
  static names(): { [key: string]: string } {
    return {
      supportInstanceTypesList: 'SupportInstanceTypesList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      supportInstanceTypesList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType extends $tea.Model {
  cpuOverCommitRatioRange?: string;
  dedicatedHostType?: string;
  GPUSpec?: string;
  generation?: string;
  localStorageAmount?: number;
  localStorageCapacity?: number;
  localStorageCategory?: string;
  memorySize?: number;
  physicalGpus?: number;
  supportCpuOverCommitRatio?: boolean;
  supportInstanceTypeFamilies?: DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportInstanceTypeFamilies;
  supportInstanceTypesList?: DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportInstanceTypesList;
  totalPhysicalCores?: number;
  totalSockets?: number;
  totalVcpus?: number;
  totalVgpus?: number;
  static names(): { [key: string]: string } {
    return {
      cpuOverCommitRatioRange: 'CpuOverCommitRatioRange',
      dedicatedHostType: 'DedicatedHostType',
      GPUSpec: 'GPUSpec',
      generation: 'Generation',
      localStorageAmount: 'LocalStorageAmount',
      localStorageCapacity: 'LocalStorageCapacity',
      localStorageCategory: 'LocalStorageCategory',
      memorySize: 'MemorySize',
      physicalGpus: 'PhysicalGpus',
      supportCpuOverCommitRatio: 'SupportCpuOverCommitRatio',
      supportInstanceTypeFamilies: 'SupportInstanceTypeFamilies',
      supportInstanceTypesList: 'SupportInstanceTypesList',
      totalPhysicalCores: 'TotalPhysicalCores',
      totalSockets: 'TotalSockets',
      totalVcpus: 'TotalVcpus',
      totalVgpus: 'TotalVgpus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpuOverCommitRatioRange: 'string',
      dedicatedHostType: 'string',
      GPUSpec: 'string',
      generation: 'string',
      localStorageAmount: 'number',
      localStorageCapacity: 'number',
      localStorageCategory: 'string',
      memorySize: 'number',
      physicalGpus: 'number',
      supportCpuOverCommitRatio: 'boolean',
      supportInstanceTypeFamilies: DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportInstanceTypeFamilies,
      supportInstanceTypesList: DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportInstanceTypesList,
      totalPhysicalCores: 'number',
      totalSockets: 'number',
      totalVcpus: 'number',
      totalVgpus: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes extends $tea.Model {
  dedicatedHostType?: DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType[];
  static names(): { [key: string]: string } {
    return {
      dedicatedHostType: 'DedicatedHostType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedHostType: { 'type': 'array', 'itemType': DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsRequestSchedulerOptions extends $tea.Model {
  managedPrivateSpaceId?: string;
  static names(): { [key: string]: string } {
    return {
      managedPrivateSpaceId: 'ManagedPrivateSpaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      managedPrivateSpaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSchedulerOptions extends $tea.Model {
  managedPrivateSpaceId?: string;
  static names(): { [key: string]: string } {
    return {
      managedPrivateSpaceId: 'ManagedPrivateSpaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      managedPrivateSpaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostCapacity extends $tea.Model {
  availableLocalStorage?: number;
  availableMemory?: number;
  availableVcpus?: number;
  availableVgpus?: number;
  localStorageCategory?: string;
  totalLocalStorage?: number;
  totalMemory?: number;
  totalVcpus?: number;
  totalVgpus?: number;
  static names(): { [key: string]: string } {
    return {
      availableLocalStorage: 'AvailableLocalStorage',
      availableMemory: 'AvailableMemory',
      availableVcpus: 'AvailableVcpus',
      availableVgpus: 'AvailableVgpus',
      localStorageCategory: 'LocalStorageCategory',
      totalLocalStorage: 'TotalLocalStorage',
      totalMemory: 'TotalMemory',
      totalVcpus: 'TotalVcpus',
      totalVgpus: 'TotalVgpus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableLocalStorage: 'number',
      availableMemory: 'number',
      availableVcpus: 'number',
      availableVgpus: 'number',
      localStorageCategory: 'string',
      totalLocalStorage: 'number',
      totalMemory: 'number',
      totalVcpus: 'number',
      totalVgpus: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostHostDetailInfo extends $tea.Model {
  serialNumber?: string;
  static names(): { [key: string]: string } {
    return {
      serialNumber: 'SerialNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serialNumber: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance extends $tea.Model {
  instanceId?: string;
  instanceType?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      instanceType: 'InstanceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      instanceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstances extends $tea.Model {
  instance?: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance[];
  static names(): { [key: string]: string } {
    return {
      instance: 'Instance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instance: { 'type': 'array', 'itemType': DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostNetworkAttributes extends $tea.Model {
  slbUdpTimeout?: number;
  udpTimeout?: number;
  static names(): { [key: string]: string } {
    return {
      slbUdpTimeout: 'SlbUdpTimeout',
      udpTimeout: 'UdpTimeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      slbUdpTimeout: 'number',
      udpTimeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock extends $tea.Model {
  lockReason?: string;
  static names(): { [key: string]: string } {
    return {
      lockReason: 'LockReason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lockReason: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocks extends $tea.Model {
  operationLock?: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock[];
  static names(): { [key: string]: string } {
    return {
      operationLock: 'OperationLock',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operationLock: { 'type': 'array', 'itemType': DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportInstanceTypeFamilies extends $tea.Model {
  supportInstanceTypeFamily?: string[];
  static names(): { [key: string]: string } {
    return {
      supportInstanceTypeFamily: 'SupportInstanceTypeFamily',
    };
  }

  static types(): { [key: string]: any } {
    return {
      supportInstanceTypeFamily: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportInstanceTypesList extends $tea.Model {
  supportInstanceTypesList?: string[];
  static names(): { [key: string]: string } {
    return {
      supportInstanceTypesList: 'SupportInstanceTypesList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      supportInstanceTypesList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedCustomInstanceTypeFamilies extends $tea.Model {
  supportedCustomInstanceTypeFamily?: string[];
  static names(): { [key: string]: string } {
    return {
      supportedCustomInstanceTypeFamily: 'SupportedCustomInstanceTypeFamily',
    };
  }

  static types(): { [key: string]: any } {
    return {
      supportedCustomInstanceTypeFamily: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTags extends $tea.Model {
  tag?: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost extends $tea.Model {
  schedulerOptions: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSchedulerOptions;
  actionOnMaintenance?: string;
  autoPlacement?: string;
  autoReleaseTime?: string;
  capacity?: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostCapacity;
  chargeType?: string;
  cpuOverCommitRatio?: number;
  creationTime?: string;
  dedicatedHostClusterId?: string;
  dedicatedHostId?: string;
  dedicatedHostName?: string;
  dedicatedHostType?: string;
  description?: string;
  expiredTime?: string;
  GPUSpec?: string;
  hostDetailInfo?: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostHostDetailInfo;
  instances?: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstances;
  machineId?: string;
  networkAttributes?: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostNetworkAttributes;
  operationLocks?: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocks;
  physicalGpus?: number;
  regionId?: string;
  resourceGroupId?: string;
  saleCycle?: string;
  status?: string;
  supportInstanceTypeFamilies?: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportInstanceTypeFamilies;
  supportInstanceTypesList?: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportInstanceTypesList;
  supportedCustomInstanceTypeFamilies?: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedCustomInstanceTypeFamilies;
  tags?: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTags;
  totalPhysicalCores?: number;
  totalSockets?: number;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      schedulerOptions: 'SchedulerOptions',
      actionOnMaintenance: 'ActionOnMaintenance',
      autoPlacement: 'AutoPlacement',
      autoReleaseTime: 'AutoReleaseTime',
      capacity: 'Capacity',
      chargeType: 'ChargeType',
      cpuOverCommitRatio: 'CpuOverCommitRatio',
      creationTime: 'CreationTime',
      dedicatedHostClusterId: 'DedicatedHostClusterId',
      dedicatedHostId: 'DedicatedHostId',
      dedicatedHostName: 'DedicatedHostName',
      dedicatedHostType: 'DedicatedHostType',
      description: 'Description',
      expiredTime: 'ExpiredTime',
      GPUSpec: 'GPUSpec',
      hostDetailInfo: 'HostDetailInfo',
      instances: 'Instances',
      machineId: 'MachineId',
      networkAttributes: 'NetworkAttributes',
      operationLocks: 'OperationLocks',
      physicalGpus: 'PhysicalGpus',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      saleCycle: 'SaleCycle',
      status: 'Status',
      supportInstanceTypeFamilies: 'SupportInstanceTypeFamilies',
      supportInstanceTypesList: 'SupportInstanceTypesList',
      supportedCustomInstanceTypeFamilies: 'SupportedCustomInstanceTypeFamilies',
      tags: 'Tags',
      totalPhysicalCores: 'TotalPhysicalCores',
      totalSockets: 'TotalSockets',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      schedulerOptions: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSchedulerOptions,
      actionOnMaintenance: 'string',
      autoPlacement: 'string',
      autoReleaseTime: 'string',
      capacity: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostCapacity,
      chargeType: 'string',
      cpuOverCommitRatio: 'number',
      creationTime: 'string',
      dedicatedHostClusterId: 'string',
      dedicatedHostId: 'string',
      dedicatedHostName: 'string',
      dedicatedHostType: 'string',
      description: 'string',
      expiredTime: 'string',
      GPUSpec: 'string',
      hostDetailInfo: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostHostDetailInfo,
      instances: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstances,
      machineId: 'string',
      networkAttributes: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostNetworkAttributes,
      operationLocks: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocks,
      physicalGpus: 'number',
      regionId: 'string',
      resourceGroupId: 'string',
      saleCycle: 'string',
      status: 'string',
      supportInstanceTypeFamilies: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportInstanceTypeFamilies,
      supportInstanceTypesList: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportInstanceTypesList,
      supportedCustomInstanceTypeFamilies: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedCustomInstanceTypeFamilies,
      tags: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTags,
      totalPhysicalCores: 'number',
      totalSockets: 'number',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBodyDedicatedHosts extends $tea.Model {
  dedicatedHost?: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost[];
  static names(): { [key: string]: string } {
    return {
      dedicatedHost: 'DedicatedHost',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedHost: { 'type': 'array', 'itemType': DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnoseRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnoseResponseBodyDiagnoseInstancesDiagnoseInstance extends $tea.Model {
  amount?: number;
  creationTime?: string;
  diagnoseAction?: string;
  diagnoseId?: string;
  diagnoseRequestId?: string;
  diskCategory?: string;
  errorCode?: string;
  expireTime?: string;
  instanceChargeType?: string;
  instanceTypeName?: string;
  izNo?: string;
  mark?: string;
  modificationTime?: string;
  networkType?: string;
  period?: number;
  periodUnit?: string;
  product?: string;
  regionId?: string;
  solutions?: string;
  star?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      amount: 'Amount',
      creationTime: 'CreationTime',
      diagnoseAction: 'DiagnoseAction',
      diagnoseId: 'DiagnoseId',
      diagnoseRequestId: 'DiagnoseRequestId',
      diskCategory: 'DiskCategory',
      errorCode: 'ErrorCode',
      expireTime: 'ExpireTime',
      instanceChargeType: 'InstanceChargeType',
      instanceTypeName: 'InstanceTypeName',
      izNo: 'IzNo',
      mark: 'Mark',
      modificationTime: 'ModificationTime',
      networkType: 'NetworkType',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      product: 'Product',
      regionId: 'RegionId',
      solutions: 'Solutions',
      star: 'Star',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      amount: 'number',
      creationTime: 'string',
      diagnoseAction: 'string',
      diagnoseId: 'string',
      diagnoseRequestId: 'string',
      diskCategory: 'string',
      errorCode: 'string',
      expireTime: 'string',
      instanceChargeType: 'string',
      instanceTypeName: 'string',
      izNo: 'string',
      mark: 'string',
      modificationTime: 'string',
      networkType: 'string',
      period: 'number',
      periodUnit: 'string',
      product: 'string',
      regionId: 'string',
      solutions: 'string',
      star: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnoseResponseBodyDiagnoseInstances extends $tea.Model {
  diagnoseInstance?: DescribeDiagnoseResponseBodyDiagnoseInstancesDiagnoseInstance[];
  static names(): { [key: string]: string } {
    return {
      diagnoseInstance: 'DiagnoseInstance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diagnoseInstance: { 'type': 'array', 'itemType': DescribeDiagnoseResponseBodyDiagnoseInstancesDiagnoseInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnosisOperateRecordsResponseBodyDiagnosisOperateRecordModels extends $tea.Model {
  instanceType?: string;
  newInstanceType?: string;
  newZoneId?: string;
  operateDate?: string;
  operateRecordType?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceType: 'InstanceType',
      newInstanceType: 'NewInstanceType',
      newZoneId: 'NewZoneId',
      operateDate: 'OperateDate',
      operateRecordType: 'OperateRecordType',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceType: 'string',
      newInstanceType: 'string',
      newZoneId: 'string',
      operateDate: 'string',
      operateRecordType: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedActionParametersParameter extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedActionParameters extends $tea.Model {
  parameter?: DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedActionParametersParameter[];
  static names(): { [key: string]: string } {
    return {
      parameter: 'Parameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      parameter: { 'type': 'array', 'itemType': DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedActionParametersParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedAction extends $tea.Model {
  actionCode?: string;
  parameters?: DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedActionParameters;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      actionCode: 'ActionCode',
      parameters: 'Parameters',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionCode: 'string',
      parameters: DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedActionParameters,
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActions extends $tea.Model {
  recommendedAction?: DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedAction[];
  static names(): { [key: string]: string } {
    return {
      recommendedAction: 'RecommendedAction',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recommendedAction: { 'type': 'array', 'itemType': DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedAction },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssue extends $tea.Model {
  issueCategory?: string;
  issueCode?: string;
  message?: string;
  occurrenceTime?: string;
  recommendedActions?: DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActions;
  severity?: string;
  static names(): { [key: string]: string } {
    return {
      issueCategory: 'IssueCategory',
      issueCode: 'IssueCode',
      message: 'Message',
      occurrenceTime: 'OccurrenceTime',
      recommendedActions: 'RecommendedActions',
      severity: 'Severity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      issueCategory: 'string',
      issueCode: 'string',
      message: 'string',
      occurrenceTime: 'string',
      recommendedActions: DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActions,
      severity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnosticReportsResponseBodyReportsReportIssues extends $tea.Model {
  issue?: DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssue[];
  static names(): { [key: string]: string } {
    return {
      issue: 'Issue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      issue: { 'type': 'array', 'itemType': DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssue },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnosticReportsResponseBodyReportsReportItemsItemItemDatasItemData extends $tea.Model {
  name?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnosticReportsResponseBodyReportsReportItemsItemItemDatas extends $tea.Model {
  itemData?: DescribeDiagnosticReportsResponseBodyReportsReportItemsItemItemDatasItemData[];
  static names(): { [key: string]: string } {
    return {
      itemData: 'ItemData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemData: { 'type': 'array', 'itemType': DescribeDiagnosticReportsResponseBodyReportsReportItemsItemItemDatasItemData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnosticReportsResponseBodyReportsReportItemsItem extends $tea.Model {
  itemCategory?: string;
  itemCode?: string;
  itemDatas?: DescribeDiagnosticReportsResponseBodyReportsReportItemsItemItemDatas;
  occurrenceTime?: string;
  severity?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      itemCategory: 'ItemCategory',
      itemCode: 'ItemCode',
      itemDatas: 'ItemDatas',
      occurrenceTime: 'OccurrenceTime',
      severity: 'Severity',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemCategory: 'string',
      itemCode: 'string',
      itemDatas: DescribeDiagnosticReportsResponseBodyReportsReportItemsItemItemDatas,
      occurrenceTime: 'string',
      severity: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnosticReportsResponseBodyReportsReportItems extends $tea.Model {
  item?: DescribeDiagnosticReportsResponseBodyReportsReportItemsItem[];
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: { 'type': 'array', 'itemType': DescribeDiagnosticReportsResponseBodyReportsReportItemsItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnosticReportsResponseBodyReportsReportRecentEventsRecentEvent extends $tea.Model {
  eventID?: string;
  eventName?: string;
  publishTime?: string;
  static names(): { [key: string]: string } {
    return {
      eventID: 'EventID',
      eventName: 'EventName',
      publishTime: 'PublishTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventID: 'string',
      eventName: 'string',
      publishTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnosticReportsResponseBodyReportsReportRecentEvents extends $tea.Model {
  recentEvent?: DescribeDiagnosticReportsResponseBodyReportsReportRecentEventsRecentEvent[];
  static names(): { [key: string]: string } {
    return {
      recentEvent: 'RecentEvent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recentEvent: { 'type': 'array', 'itemType': DescribeDiagnosticReportsResponseBodyReportsReportRecentEventsRecentEvent },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnosticReportsResponseBodyReportsReport extends $tea.Model {
  creationTime?: string;
  diagnosticCategory?: string;
  endTime?: string;
  finishedTime?: string;
  invokeSystem?: string;
  issueCategoryId?: string;
  issues?: DescribeDiagnosticReportsResponseBodyReportsReportIssues;
  items?: DescribeDiagnosticReportsResponseBodyReportsReportItems;
  offlineDiagReportStatus?: string;
  pePassword?: string;
  recentEvents?: DescribeDiagnosticReportsResponseBodyReportsReportRecentEvents;
  reportId?: string;
  resourceId?: string;
  resourceType?: string;
  severity?: string;
  startTime?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      diagnosticCategory: 'DiagnosticCategory',
      endTime: 'EndTime',
      finishedTime: 'FinishedTime',
      invokeSystem: 'InvokeSystem',
      issueCategoryId: 'IssueCategoryId',
      issues: 'Issues',
      items: 'Items',
      offlineDiagReportStatus: 'OfflineDiagReportStatus',
      pePassword: 'PePassword',
      recentEvents: 'RecentEvents',
      reportId: 'ReportId',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      severity: 'Severity',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      diagnosticCategory: 'string',
      endTime: 'string',
      finishedTime: 'string',
      invokeSystem: 'string',
      issueCategoryId: 'string',
      issues: DescribeDiagnosticReportsResponseBodyReportsReportIssues,
      items: DescribeDiagnosticReportsResponseBodyReportsReportItems,
      offlineDiagReportStatus: 'string',
      pePassword: 'string',
      recentEvents: DescribeDiagnosticReportsResponseBodyReportsReportRecentEvents,
      reportId: 'string',
      resourceId: 'string',
      resourceType: 'string',
      severity: 'string',
      startTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiagnosticReportsResponseBodyReports extends $tea.Model {
  report?: DescribeDiagnosticReportsResponseBodyReportsReport[];
  static names(): { [key: string]: string } {
    return {
      report: 'Report',
    };
  }

  static types(): { [key: string]: any } {
    return {
      report: { 'type': 'array', 'itemType': DescribeDiagnosticReportsResponseBodyReportsReport },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiskReplicaPairsResponseBodyDiskReplicaPairsDiskReplicaPair extends $tea.Model {
  asyncCycle?: number;
  bandwidth?: number;
  description?: string;
  destinationDiskId?: string;
  destinationRegion?: string;
  healthStatus?: string;
  pairName?: string;
  replicaPairId?: string;
  rpoTime?: string;
  sourceDiskId?: string;
  sourceRegion?: string;
  status?: string;
  totalCopiedSize?: number;
  static names(): { [key: string]: string } {
    return {
      asyncCycle: 'AsyncCycle',
      bandwidth: 'Bandwidth',
      description: 'Description',
      destinationDiskId: 'DestinationDiskId',
      destinationRegion: 'DestinationRegion',
      healthStatus: 'HealthStatus',
      pairName: 'PairName',
      replicaPairId: 'ReplicaPairId',
      rpoTime: 'RpoTime',
      sourceDiskId: 'SourceDiskId',
      sourceRegion: 'SourceRegion',
      status: 'Status',
      totalCopiedSize: 'TotalCopiedSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asyncCycle: 'number',
      bandwidth: 'number',
      description: 'string',
      destinationDiskId: 'string',
      destinationRegion: 'string',
      healthStatus: 'string',
      pairName: 'string',
      replicaPairId: 'string',
      rpoTime: 'string',
      sourceDiskId: 'string',
      sourceRegion: 'string',
      status: 'string',
      totalCopiedSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiskReplicaPairsResponseBodyDiskReplicaPairs extends $tea.Model {
  diskReplicaPair?: DescribeDiskReplicaPairsResponseBodyDiskReplicaPairsDiskReplicaPair[];
  static names(): { [key: string]: string } {
    return {
      diskReplicaPair: 'DiskReplicaPair',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskReplicaPair: { 'type': 'array', 'itemType': DescribeDiskReplicaPairsResponseBodyDiskReplicaPairsDiskReplicaPair },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEcsScenarioFacadeRequestScenarioListScenarioResources extends $tea.Model {
  type?: string;
  values?: string[];
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      values: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEcsScenarioFacadeRequestScenarioList extends $tea.Model {
  scenario?: string;
  scenarioResources?: DescribeEcsScenarioFacadeRequestScenarioListScenarioResources[];
  static names(): { [key: string]: string } {
    return {
      scenario: 'Scenario',
      scenarioResources: 'ScenarioResources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scenario: 'string',
      scenarioResources: { 'type': 'array', 'itemType': DescribeEcsScenarioFacadeRequestScenarioListScenarioResources },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEcsScenarioFacadeResponseBodyScenariosContentsEcsScenarioContentData extends $tea.Model {
  type?: string;
  values?: string[];
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      values: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEcsScenarioFacadeResponseBodyScenariosContents extends $tea.Model {
  action?: { [key: string]: string };
  attributes?: { [key: string]: string };
  colorLevel?: string;
  description?: string;
  ecsScenarioContentData?: DescribeEcsScenarioFacadeResponseBodyScenariosContentsEcsScenarioContentData[];
  icon?: string;
  supportCancel?: string;
  tips?: string;
  title?: string;
  track?: { [key: string]: string };
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      attributes: 'Attributes',
      colorLevel: 'ColorLevel',
      description: 'Description',
      ecsScenarioContentData: 'EcsScenarioContentData',
      icon: 'Icon',
      supportCancel: 'SupportCancel',
      tips: 'Tips',
      title: 'Title',
      track: 'Track',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      attributes: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      colorLevel: 'string',
      description: 'string',
      ecsScenarioContentData: { 'type': 'array', 'itemType': DescribeEcsScenarioFacadeResponseBodyScenariosContentsEcsScenarioContentData },
      icon: 'string',
      supportCancel: 'string',
      tips: 'string',
      title: 'string',
      track: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEcsScenarioFacadeResponseBodyScenarios extends $tea.Model {
  contents?: DescribeEcsScenarioFacadeResponseBodyScenariosContents[];
  scenario?: string;
  static names(): { [key: string]: string } {
    return {
      contents: 'Contents',
      scenario: 'Scenario',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contents: { 'type': 'array', 'itemType': DescribeEcsScenarioFacadeResponseBodyScenariosContents },
      scenario: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEniQosGroupInfoResponseBodyQosGroupInfoNetworkInterfaceIds extends $tea.Model {
  networkInterfaceId?: string[];
  static names(): { [key: string]: string } {
    return {
      networkInterfaceId: 'NetworkInterfaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkInterfaceId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEniQosGroupInfoResponseBodyQosGroupInfoQosGroup extends $tea.Model {
  gmtCreate?: string;
  gmtModify?: string;
  qosGroupName?: string;
  rx?: string;
  rxPps?: string;
  tx?: string;
  txPps?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      gmtModify: 'GmtModify',
      qosGroupName: 'QosGroupName',
      rx: 'Rx',
      rxPps: 'RxPps',
      tx: 'Tx',
      txPps: 'TxPps',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'string',
      gmtModify: 'string',
      qosGroupName: 'string',
      rx: 'string',
      rxPps: 'string',
      tx: 'string',
      txPps: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEniQosGroupInfoResponseBodyQosGroupInfo extends $tea.Model {
  instanceId?: string;
  networkInterfaceIds?: DescribeEniQosGroupInfoResponseBodyQosGroupInfoNetworkInterfaceIds;
  qosGroup?: DescribeEniQosGroupInfoResponseBodyQosGroupInfoQosGroup;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      networkInterfaceIds: 'NetworkInterfaceIds',
      qosGroup: 'QosGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      networkInterfaceIds: DescribeEniQosGroupInfoResponseBodyQosGroupInfoNetworkInterfaceIds,
      qosGroup: DescribeEniQosGroupInfoResponseBodyQosGroupInfoQosGroup,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFunctionFeedbackResponseBodyDataFeedback extends $tea.Model {
  category?: string;
  creationTime?: string;
  feedback?: string;
  finishedTime?: string;
  functionName?: string;
  suggestion?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      creationTime: 'CreationTime',
      feedback: 'Feedback',
      finishedTime: 'FinishedTime',
      functionName: 'FunctionName',
      suggestion: 'Suggestion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      creationTime: 'string',
      feedback: 'string',
      finishedTime: 'string',
      functionName: 'string',
      suggestion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFunctionFeedbackResponseBodyData extends $tea.Model {
  feedback?: DescribeFunctionFeedbackResponseBodyDataFeedback[];
  static names(): { [key: string]: string } {
    return {
      feedback: 'feedback',
    };
  }

  static types(): { [key: string]: any } {
    return {
      feedback: { 'type': 'array', 'itemType': DescribeFunctionFeedbackResponseBodyDataFeedback },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHavsInstanceTypesResponseBodyDescribeHavsInstanceTypesResponseHavsInstanceTypes extends $tea.Model {
  havsInstanceTypes?: string[];
  static names(): { [key: string]: string } {
    return {
      havsInstanceTypes: 'HavsInstanceTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      havsInstanceTypes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHavsInstanceTypesResponseBodyDescribeHavsInstanceTypesResponse extends $tea.Model {
  havsInstanceTypes?: DescribeHavsInstanceTypesResponseBodyDescribeHavsInstanceTypesResponseHavsInstanceTypes;
  static names(): { [key: string]: string } {
    return {
      havsInstanceTypes: 'HavsInstanceTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      havsInstanceTypes: DescribeHavsInstanceTypesResponseBodyDescribeHavsInstanceTypesResponseHavsInstanceTypes,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageCachesResponseBodyImageCachesImageCache extends $tea.Model {
  creationTime?: string;
  imageId?: string;
  progress?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      imageId: 'ImageId',
      progress: 'Progress',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      imageId: 'string',
      progress: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageCachesResponseBodyImageCaches extends $tea.Model {
  imageCache?: DescribeImageCachesResponseBodyImageCachesImageCache[];
  static names(): { [key: string]: string } {
    return {
      imageCache: 'ImageCache',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageCache: { 'type': 'array', 'itemType': DescribeImageCachesResponseBodyImageCachesImageCache },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageFamiliesResponseBodyImageFamilies extends $tea.Model {
  imageFamily?: string[];
  static names(): { [key: string]: string } {
    return {
      imageFamily: 'ImageFamily',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageFamily: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAutoRebootTimeResponseBodyAutoRebootInfosAutoRebootInfo extends $tea.Model {
  instanceId?: string;
  limitRebootTime?: string;
  orderType?: string;
  rebootTime?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      limitRebootTime: 'LimitRebootTime',
      orderType: 'OrderType',
      rebootTime: 'RebootTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      limitRebootTime: 'string',
      orderType: 'string',
      rebootTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAutoRebootTimeResponseBodyAutoRebootInfos extends $tea.Model {
  autoRebootInfo?: DescribeInstanceAutoRebootTimeResponseBodyAutoRebootInfosAutoRebootInfo[];
  static names(): { [key: string]: string } {
    return {
      autoRebootInfo: 'AutoRebootInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRebootInfo: { 'type': 'array', 'itemType': DescribeInstanceAutoRebootTimeResponseBodyAutoRebootInfosAutoRebootInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceHealthStatusResponseBodyHealthStatusModelHealthStatus extends $tea.Model {
  code?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceHealthStatusResponseBodyHealthStatusModel extends $tea.Model {
  healthStatus?: DescribeInstanceHealthStatusResponseBodyHealthStatusModelHealthStatus;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      healthStatus: 'HealthStatus',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      healthStatus: DescribeInstanceHealthStatusResponseBodyHealthStatusModelHealthStatus,
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenanceSupportedValues extends $tea.Model {
  supportedValue?: string[];
  static names(): { [key: string]: string } {
    return {
      supportedValue: 'SupportedValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      supportedValue: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenance extends $tea.Model {
  defaultValue?: string;
  supportedValues?: DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenanceSupportedValues;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      defaultValue: 'DefaultValue',
      supportedValues: 'SupportedValues',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultValue: 'string',
      supportedValues: DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenanceSupportedValues,
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow extends $tea.Model {
  endTime?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindows extends $tea.Model {
  maintenanceWindow?: DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow[];
  static names(): { [key: string]: string } {
    return {
      maintenanceWindow: 'MaintenanceWindow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maintenanceWindow: { 'type': 'array', 'itemType': DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute extends $tea.Model {
  actionOnMaintenance?: DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenance;
  instanceId?: string;
  liveMigration?: boolean;
  maintenanceWindows?: DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindows;
  static names(): { [key: string]: string } {
    return {
      actionOnMaintenance: 'ActionOnMaintenance',
      instanceId: 'InstanceId',
      liveMigration: 'LiveMigration',
      maintenanceWindows: 'MaintenanceWindows',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionOnMaintenance: DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenance,
      instanceId: 'string',
      liveMigration: 'boolean',
      maintenanceWindows: DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindows,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes extends $tea.Model {
  maintenanceAttribute?: DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute[];
  static names(): { [key: string]: string } {
    return {
      maintenanceAttribute: 'MaintenanceAttribute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maintenanceAttribute: { 'type': 'array', 'itemType': DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceModificationPriceRequestSystemDisk extends $tea.Model {
  category?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceModificationPriceRequestDataDisk extends $tea.Model {
  category?: string;
  performanceLevel?: string;
  size?: number;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      performanceLevel: 'PerformanceLevel',
      size: 'Size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      performanceLevel: 'string',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceModificationPriceResponseBodyPriceInfoPrice extends $tea.Model {
  currency?: string;
  discountPrice?: number;
  originalPrice?: number;
  tradePrice?: number;
  static names(): { [key: string]: string } {
    return {
      currency: 'Currency',
      discountPrice: 'DiscountPrice',
      originalPrice: 'OriginalPrice',
      tradePrice: 'TradePrice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currency: 'string',
      discountPrice: 'number',
      originalPrice: 'number',
      tradePrice: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule extends $tea.Model {
  description?: string;
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceModificationPriceResponseBodyPriceInfoRules extends $tea.Model {
  rule?: DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule[];
  static names(): { [key: string]: string } {
    return {
      rule: 'Rule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rule: { 'type': 'array', 'itemType': DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceModificationPriceResponseBodyPriceInfo extends $tea.Model {
  price?: DescribeInstanceModificationPriceResponseBodyPriceInfoPrice;
  rules?: DescribeInstanceModificationPriceResponseBodyPriceInfoRules;
  static names(): { [key: string]: string } {
    return {
      price: 'Price',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      price: DescribeInstanceModificationPriceResponseBodyPriceInfoPrice,
      rules: DescribeInstanceModificationPriceResponseBodyPriceInfoRules,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceNeedRebootResponseBodyInstanceInfo extends $tea.Model {
  instanceInfo?: string[];
  static names(): { [key: string]: string } {
    return {
      instanceInfo: 'InstanceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceInfo: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistoriesPerformanceRestrictHistoryIntervals extends $tea.Model {
  interval?: string[];
  static names(): { [key: string]: string } {
    return {
      interval: 'Interval',
    };
  }

  static types(): { [key: string]: any } {
    return {
      interval: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistoriesPerformanceRestrictHistory extends $tea.Model {
  instanceId?: string;
  intervals?: DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistoriesPerformanceRestrictHistoryIntervals;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      intervals: 'Intervals',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      intervals: DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistoriesPerformanceRestrictHistoryIntervals,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistories extends $tea.Model {
  performanceRestrictHistory?: DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistoriesPerformanceRestrictHistory[];
  static names(): { [key: string]: string } {
    return {
      performanceRestrictHistory: 'PerformanceRestrictHistory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      performanceRestrictHistory: { 'type': 'array', 'itemType': DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistoriesPerformanceRestrictHistory },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTypeResourceResponseBodyInstanceTypeResourcesInstanceTypeResourceStockHealth extends $tea.Model {
  adequacyScore?: number;
  healthScore?: number;
  hotScore?: number;
  supplyScore?: number;
  static names(): { [key: string]: string } {
    return {
      adequacyScore: 'AdequacyScore',
      healthScore: 'HealthScore',
      hotScore: 'HotScore',
      supplyScore: 'SupplyScore',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adequacyScore: 'number',
      healthScore: 'number',
      hotScore: 'number',
      supplyScore: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTypeResourceResponseBodyInstanceTypeResourcesInstanceTypeResource extends $tea.Model {
  instanceType?: string;
  instanceTypeFamily?: string;
  regionId?: string;
  searchType?: string;
  stockHealth?: DescribeInstanceTypeResourceResponseBodyInstanceTypeResourcesInstanceTypeResourceStockHealth;
  totalQuota?: number;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceType: 'InstanceType',
      instanceTypeFamily: 'InstanceTypeFamily',
      regionId: 'RegionId',
      searchType: 'SearchType',
      stockHealth: 'StockHealth',
      totalQuota: 'TotalQuota',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceType: 'string',
      instanceTypeFamily: 'string',
      regionId: 'string',
      searchType: 'string',
      stockHealth: DescribeInstanceTypeResourceResponseBodyInstanceTypeResourcesInstanceTypeResourceStockHealth,
      totalQuota: 'number',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTypeResourceResponseBodyInstanceTypeResources extends $tea.Model {
  instanceTypeResource?: DescribeInstanceTypeResourceResponseBodyInstanceTypeResourcesInstanceTypeResource[];
  static names(): { [key: string]: string } {
    return {
      instanceTypeResource: 'InstanceTypeResource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceTypeResource: { 'type': 'array', 'itemType': DescribeInstanceTypeResourceResponseBodyInstanceTypeResourcesInstanceTypeResource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeKMSKeysResponseBodyKMSKeyIds extends $tea.Model {
  kmsKeyId?: string[];
  static names(): { [key: string]: string } {
    return {
      kmsKeyId: 'kmsKeyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      kmsKeyId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLinkedKMSKeysResponseBodyKMSKeysKMSKey extends $tea.Model {
  alias?: string;
  KMSKeyId?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      KMSKeyId: 'KMSKeyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      KMSKeyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLinkedKMSKeysResponseBodyKMSKeys extends $tea.Model {
  KMSKey?: DescribeLinkedKMSKeysResponseBodyKMSKeysKMSKey[];
  static names(): { [key: string]: string } {
    return {
      KMSKey: 'KMSKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      KMSKey: { 'type': 'array', 'itemType': DescribeLinkedKMSKeysResponseBodyKMSKeysKMSKey },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityDiskEventEventType extends $tea.Model {
  code?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityDiskEvent extends $tea.Model {
  eventEndTime?: string;
  eventId?: string;
  eventTime?: string;
  eventType?: DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityDiskEventEventType;
  static names(): { [key: string]: string } {
    return {
      eventEndTime: 'EventEndTime',
      eventId: 'EventId',
      eventTime: 'EventTime',
      eventType: 'EventType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventEndTime: 'string',
      eventId: 'string',
      eventTime: 'string',
      eventType: DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityDiskEventEventType,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventEventCycleStatus extends $tea.Model {
  code?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventEventType extends $tea.Model {
  code?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventExtendedAttribute extends $tea.Model {
  device?: string;
  diskId?: string;
  onlineRepairPolicy?: string;
  static names(): { [key: string]: string } {
    return {
      device: 'Device',
      diskId: 'DiskId',
      onlineRepairPolicy: 'OnlineRepairPolicy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      device: 'string',
      diskId: 'string',
      onlineRepairPolicy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEvent extends $tea.Model {
  eventCycleStatus?: DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventEventCycleStatus;
  eventFinishTime?: string;
  eventId?: string;
  eventPublishTime?: string;
  eventType?: DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventEventType;
  extendedAttribute?: DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventExtendedAttribute;
  instanceId?: string;
  reason?: string;
  static names(): { [key: string]: string } {
    return {
      eventCycleStatus: 'EventCycleStatus',
      eventFinishTime: 'EventFinishTime',
      eventId: 'EventId',
      eventPublishTime: 'EventPublishTime',
      eventType: 'EventType',
      extendedAttribute: 'ExtendedAttribute',
      instanceId: 'InstanceId',
      reason: 'Reason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventCycleStatus: DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventEventCycleStatus,
      eventFinishTime: 'string',
      eventId: 'string',
      eventPublishTime: 'string',
      eventType: DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventEventType,
      extendedAttribute: DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventExtendedAttribute,
      instanceId: 'string',
      reason: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEvents extends $tea.Model {
  instanceEvent?: DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEvent[];
  static names(): { [key: string]: string } {
    return {
      instanceEvent: 'InstanceEvent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceEvent: { 'type': 'array', 'itemType': DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEvent },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivity extends $tea.Model {
  diskEvent?: DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityDiskEvent;
  diskId?: string;
  instanceEvents?: DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEvents;
  instanceId?: string;
  progress?: string;
  static names(): { [key: string]: string } {
    return {
      diskEvent: 'DiskEvent',
      diskId: 'DiskId',
      instanceEvents: 'InstanceEvents',
      instanceId: 'InstanceId',
      progress: 'Progress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskEvent: DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityDiskEvent,
      diskId: 'string',
      instanceEvents: DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEvents,
      instanceId: 'string',
      progress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivities extends $tea.Model {
  localDiskRepairActivity?: DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivity[];
  static names(): { [key: string]: string } {
    return {
      localDiskRepairActivity: 'LocalDiskRepairActivity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      localDiskRepairActivity: { 'type': 'array', 'itemType': DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivity },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMigrationInstancesRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceSecurityGroupIdSets extends $tea.Model {
  securityGroupId?: string[];
  static names(): { [key: string]: string } {
    return {
      securityGroupId: 'SecurityGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityGroupId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceSecurityGroupIdSetsAfterTransition extends $tea.Model {
  securityGroupId?: string[];
  static names(): { [key: string]: string } {
    return {
      securityGroupId: 'SecurityGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityGroupId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceTagsTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceTags extends $tea.Model {
  tag?: DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceTagsTag[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceTagsTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstance extends $tea.Model {
  businessMigrationType?: string;
  businessStatus?: string;
  changePublicIp?: boolean;
  finishTime?: string;
  hasLocalDisk?: boolean;
  instanceChargeType?: string;
  instanceId?: string;
  instanceType?: string;
  internetIp?: string;
  internetIpAfterTransition?: string;
  intranetIp?: string;
  intranetIpAfterTransition?: string;
  loadProgress?: string;
  macAddressAfterTransition?: string;
  mergeProgress?: string;
  migrationPlanId?: string;
  migrationStatus?: string;
  name?: string;
  networkConnectivityStatus?: boolean;
  networkMigrationType?: number;
  nonStandardInstanceType?: boolean;
  privateMacAddress?: string;
  publicMacAddress?: string;
  regionId?: string;
  resourceGroupId?: string;
  securityGroupIdSets?: DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceSecurityGroupIdSets;
  securityGroupIdSetsAfterTransition?: DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceSecurityGroupIdSetsAfterTransition;
  status?: string;
  tags?: DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceTags;
  targetVSwitchId?: string;
  targetVpcId?: string;
  targetZoneId?: string;
  transitionTime?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      businessMigrationType: 'BusinessMigrationType',
      businessStatus: 'BusinessStatus',
      changePublicIp: 'ChangePublicIp',
      finishTime: 'FinishTime',
      hasLocalDisk: 'HasLocalDisk',
      instanceChargeType: 'InstanceChargeType',
      instanceId: 'InstanceId',
      instanceType: 'InstanceType',
      internetIp: 'InternetIp',
      internetIpAfterTransition: 'InternetIpAfterTransition',
      intranetIp: 'IntranetIp',
      intranetIpAfterTransition: 'IntranetIpAfterTransition',
      loadProgress: 'LoadProgress',
      macAddressAfterTransition: 'MacAddressAfterTransition',
      mergeProgress: 'MergeProgress',
      migrationPlanId: 'MigrationPlanId',
      migrationStatus: 'MigrationStatus',
      name: 'Name',
      networkConnectivityStatus: 'NetworkConnectivityStatus',
      networkMigrationType: 'NetworkMigrationType',
      nonStandardInstanceType: 'NonStandardInstanceType',
      privateMacAddress: 'PrivateMacAddress',
      publicMacAddress: 'PublicMacAddress',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      securityGroupIdSets: 'SecurityGroupIdSets',
      securityGroupIdSetsAfterTransition: 'SecurityGroupIdSetsAfterTransition',
      status: 'Status',
      tags: 'Tags',
      targetVSwitchId: 'TargetVSwitchId',
      targetVpcId: 'TargetVpcId',
      targetZoneId: 'TargetZoneId',
      transitionTime: 'TransitionTime',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessMigrationType: 'string',
      businessStatus: 'string',
      changePublicIp: 'boolean',
      finishTime: 'string',
      hasLocalDisk: 'boolean',
      instanceChargeType: 'string',
      instanceId: 'string',
      instanceType: 'string',
      internetIp: 'string',
      internetIpAfterTransition: 'string',
      intranetIp: 'string',
      intranetIpAfterTransition: 'string',
      loadProgress: 'string',
      macAddressAfterTransition: 'string',
      mergeProgress: 'string',
      migrationPlanId: 'string',
      migrationStatus: 'string',
      name: 'string',
      networkConnectivityStatus: 'boolean',
      networkMigrationType: 'number',
      nonStandardInstanceType: 'boolean',
      privateMacAddress: 'string',
      publicMacAddress: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      securityGroupIdSets: DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceSecurityGroupIdSets,
      securityGroupIdSetsAfterTransition: DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceSecurityGroupIdSetsAfterTransition,
      status: 'string',
      tags: DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceTags,
      targetVSwitchId: 'string',
      targetVpcId: 'string',
      targetZoneId: 'string',
      transitionTime: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMigrationInstancesResponseBodyMigrationInstanceSet extends $tea.Model {
  migrationInstance?: DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstance[];
  static names(): { [key: string]: string } {
    return {
      migrationInstance: 'MigrationInstance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      migrationInstance: { 'type': 'array', 'itemType': DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMigrationPlansResponseBodyMigrationPlanSetMigrationPlanSecurityGroupNos extends $tea.Model {
  securityGroupNo?: string[];
  static names(): { [key: string]: string } {
    return {
      securityGroupNo: 'SecurityGroupNo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityGroupNo: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMigrationPlansResponseBodyMigrationPlanSetMigrationPlan extends $tea.Model {
  createTime?: string;
  enableAutoCreateVSwitch?: boolean;
  enableNetworkConnectivity?: boolean;
  finishInstanceCount?: number;
  migrationPlanId?: string;
  name?: string;
  remainPrivateIp?: boolean;
  remainPublicMacAsPriority?: boolean;
  securityGroupNos?: DescribeMigrationPlansResponseBodyMigrationPlanSetMigrationPlanSecurityGroupNos;
  status?: string;
  targetVSwitchId?: string;
  targetVpcId?: string;
  targetZoneId?: string;
  totalInstanceCount?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      enableAutoCreateVSwitch: 'EnableAutoCreateVSwitch',
      enableNetworkConnectivity: 'EnableNetworkConnectivity',
      finishInstanceCount: 'FinishInstanceCount',
      migrationPlanId: 'MigrationPlanId',
      name: 'Name',
      remainPrivateIp: 'RemainPrivateIp',
      remainPublicMacAsPriority: 'RemainPublicMacAsPriority',
      securityGroupNos: 'SecurityGroupNos',
      status: 'Status',
      targetVSwitchId: 'TargetVSwitchId',
      targetVpcId: 'TargetVpcId',
      targetZoneId: 'TargetZoneId',
      totalInstanceCount: 'TotalInstanceCount',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      enableAutoCreateVSwitch: 'boolean',
      enableNetworkConnectivity: 'boolean',
      finishInstanceCount: 'number',
      migrationPlanId: 'string',
      name: 'string',
      remainPrivateIp: 'boolean',
      remainPublicMacAsPriority: 'boolean',
      securityGroupNos: DescribeMigrationPlansResponseBodyMigrationPlanSetMigrationPlanSecurityGroupNos,
      status: 'string',
      targetVSwitchId: 'string',
      targetVpcId: 'string',
      targetZoneId: 'string',
      totalInstanceCount: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMigrationPlansResponseBodyMigrationPlanSet extends $tea.Model {
  migrationPlan?: DescribeMigrationPlansResponseBodyMigrationPlanSetMigrationPlan[];
  static names(): { [key: string]: string } {
    return {
      migrationPlan: 'MigrationPlan',
    };
  }

  static types(): { [key: string]: any } {
    return {
      migrationPlan: { 'type': 'array', 'itemType': DescribeMigrationPlansResponseBodyMigrationPlanSetMigrationPlan },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMigrationPreferencesResponseBodyTargetZoneIdSet extends $tea.Model {
  targetZoneId?: string[];
  static names(): { [key: string]: string } {
    return {
      targetZoneId: 'TargetZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetZoneId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsNetworkAclEntry extends $tea.Model {
  direction?: string;
  networkAclEntryId?: string;
  networkAclId?: string;
  networkAclName?: string;
  policy?: string;
  port?: string;
  protocol?: string;
  sourceCidrIp?: string;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      direction: 'Direction',
      networkAclEntryId: 'NetworkAclEntryId',
      networkAclId: 'NetworkAclId',
      networkAclName: 'NetworkAclName',
      policy: 'Policy',
      port: 'Port',
      protocol: 'Protocol',
      sourceCidrIp: 'SourceCidrIp',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      direction: 'string',
      networkAclEntryId: 'string',
      networkAclId: 'string',
      networkAclName: 'string',
      policy: 'string',
      port: 'string',
      protocol: 'string',
      sourceCidrIp: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsRelativeGroupIds extends $tea.Model {
  relativeGroupId?: string[];
  static names(): { [key: string]: string } {
    return {
      relativeGroupId: 'RelativeGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      relativeGroupId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsSecurityGroupAcl extends $tea.Model {
  createTime?: string;
  description?: string;
  destCidrIp?: string;
  destGroupId?: string;
  destPortRange?: string;
  innerAccessPolicy?: string;
  nicType?: string;
  policy?: string;
  sourceCidrIp?: string;
  sourcePortRange?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      destCidrIp: 'DestCidrIp',
      destGroupId: 'DestGroupId',
      destPortRange: 'DestPortRange',
      innerAccessPolicy: 'InnerAccessPolicy',
      nicType: 'NicType',
      policy: 'Policy',
      sourceCidrIp: 'SourceCidrIp',
      sourcePortRange: 'SourcePortRange',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      description: 'string',
      destCidrIp: 'string',
      destGroupId: 'string',
      destPortRange: 'string',
      innerAccessPolicy: 'string',
      nicType: 'string',
      policy: 'string',
      sourceCidrIp: 'string',
      sourcePortRange: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsTopProcesses extends $tea.Model {
  topProcess?: string[];
  static names(): { [key: string]: string } {
    return {
      topProcess: 'TopProcess',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topProcess: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanations extends $tea.Model {
  actualIP?: string;
  actualPort?: number;
  expectIP?: string;
  expectPort?: number;
  expireDate?: string;
  groupId?: string;
  header?: string;
  ip?: string;
  missingFiles?: string;
  netmask?: string;
  networkAclEntry?: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsNetworkAclEntry;
  networkInterfaceName?: string;
  port?: number;
  processName?: string;
  relativeGroupIds?: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsRelativeGroupIds;
  rule?: string;
  securityGroupAcl?: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsSecurityGroupAcl;
  topProcesses?: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsTopProcesses;
  usePercent?: string;
  static names(): { [key: string]: string } {
    return {
      actualIP: 'ActualIP',
      actualPort: 'ActualPort',
      expectIP: 'ExpectIP',
      expectPort: 'ExpectPort',
      expireDate: 'ExpireDate',
      groupId: 'GroupId',
      header: 'Header',
      ip: 'Ip',
      missingFiles: 'MissingFiles',
      netmask: 'Netmask',
      networkAclEntry: 'NetworkAclEntry',
      networkInterfaceName: 'NetworkInterfaceName',
      port: 'Port',
      processName: 'ProcessName',
      relativeGroupIds: 'RelativeGroupIds',
      rule: 'Rule',
      securityGroupAcl: 'SecurityGroupAcl',
      topProcesses: 'TopProcesses',
      usePercent: 'UsePercent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualIP: 'string',
      actualPort: 'number',
      expectIP: 'string',
      expectPort: 'number',
      expireDate: 'string',
      groupId: 'string',
      header: 'string',
      ip: 'string',
      missingFiles: 'string',
      netmask: 'string',
      networkAclEntry: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsNetworkAclEntry,
      networkInterfaceName: 'string',
      port: 'number',
      processName: 'string',
      relativeGroupIds: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsRelativeGroupIds,
      rule: 'string',
      securityGroupAcl: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsSecurityGroupAcl,
      topProcesses: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsTopProcesses,
      usePercent: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItem extends $tea.Model {
  code?: string;
  explanations?: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanations;
  itemName?: string;
  reachable?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      explanations: 'Explanations',
      itemName: 'ItemName',
      reachable: 'Reachable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      explanations: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanations,
      itemName: 'string',
      reachable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItems extends $tea.Model {
  categoryItem?: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItem[];
  static names(): { [key: string]: string } {
    return {
      categoryItem: 'CategoryItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryItem: { 'type': 'array', 'itemType': DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategory extends $tea.Model {
  categoryItems?: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItems;
  categoryName?: string;
  reachable?: string;
  static names(): { [key: string]: string } {
    return {
      categoryItems: 'CategoryItems',
      categoryName: 'CategoryName',
      reachable: 'Reachable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryItems: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItems,
      categoryName: 'string',
      reachable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategories extends $tea.Model {
  diagnoseCategory?: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategory[];
  static names(): { [key: string]: string } {
    return {
      diagnoseCategory: 'DiagnoseCategory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diagnoseCategory: { 'type': 'array', 'itemType': DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategory },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentNetworkAclEntry extends $tea.Model {
  creationTime?: string;
  destinationCidrIp?: string;
  direction?: string;
  networkAclEntryId?: string;
  networkAclEntryName?: string;
  networkAclId?: string;
  networkAclName?: string;
  policy?: string;
  port?: string;
  protocol?: string;
  sourceCidrIp?: string;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      destinationCidrIp: 'DestinationCidrIp',
      direction: 'Direction',
      networkAclEntryId: 'NetworkAclEntryId',
      networkAclEntryName: 'NetworkAclEntryName',
      networkAclId: 'NetworkAclId',
      networkAclName: 'NetworkAclName',
      policy: 'Policy',
      port: 'Port',
      protocol: 'Protocol',
      sourceCidrIp: 'SourceCidrIp',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      destinationCidrIp: 'string',
      direction: 'string',
      networkAclEntryId: 'string',
      networkAclEntryName: 'string',
      networkAclId: 'string',
      networkAclName: 'string',
      policy: 'string',
      port: 'string',
      protocol: 'string',
      sourceCidrIp: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentRelativeGroupIds extends $tea.Model {
  relativeGroupId?: string[];
  static names(): { [key: string]: string } {
    return {
      relativeGroupId: 'RelativeGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      relativeGroupId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentSecurityGroupAcl extends $tea.Model {
  createTime?: string;
  description?: string;
  destCidrIp?: string;
  destGroupId?: string;
  destGroupName?: string;
  destPortRange?: string;
  direction?: string;
  innerAccessPolicy?: string;
  ipProtocol?: string;
  ipv6DestCidrIp?: string;
  ipv6SourceCidrIp?: string;
  nicType?: string;
  permissionDescription?: string;
  policy?: string;
  priority?: string;
  securityGroupId?: string;
  sourceCidrIp?: string;
  sourceGroupId?: string;
  sourceGroupName?: string;
  sourcePortRange?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      destCidrIp: 'DestCidrIp',
      destGroupId: 'DestGroupId',
      destGroupName: 'DestGroupName',
      destPortRange: 'DestPortRange',
      direction: 'Direction',
      innerAccessPolicy: 'InnerAccessPolicy',
      ipProtocol: 'IpProtocol',
      ipv6DestCidrIp: 'Ipv6DestCidrIp',
      ipv6SourceCidrIp: 'Ipv6SourceCidrIp',
      nicType: 'NicType',
      permissionDescription: 'PermissionDescription',
      policy: 'Policy',
      priority: 'Priority',
      securityGroupId: 'SecurityGroupId',
      sourceCidrIp: 'SourceCidrIp',
      sourceGroupId: 'SourceGroupId',
      sourceGroupName: 'SourceGroupName',
      sourcePortRange: 'SourcePortRange',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      description: 'string',
      destCidrIp: 'string',
      destGroupId: 'string',
      destGroupName: 'string',
      destPortRange: 'string',
      direction: 'string',
      innerAccessPolicy: 'string',
      ipProtocol: 'string',
      ipv6DestCidrIp: 'string',
      ipv6SourceCidrIp: 'string',
      nicType: 'string',
      permissionDescription: 'string',
      policy: 'string',
      priority: 'string',
      securityGroupId: 'string',
      sourceCidrIp: 'string',
      sourceGroupId: 'string',
      sourceGroupName: 'string',
      sourcePortRange: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponent extends $tea.Model {
  code?: string;
  diagnoseCategories?: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategories;
  message?: string;
  networkAclEntry?: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentNetworkAclEntry;
  reachable?: string;
  relativeGroupIds?: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentRelativeGroupIds;
  resourceId?: string;
  resourceType?: string;
  securityGroupAcl?: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentSecurityGroupAcl;
  sequence?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      diagnoseCategories: 'DiagnoseCategories',
      message: 'Message',
      networkAclEntry: 'NetworkAclEntry',
      reachable: 'Reachable',
      relativeGroupIds: 'RelativeGroupIds',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      securityGroupAcl: 'SecurityGroupAcl',
      sequence: 'Sequence',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      diagnoseCategories: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategories,
      message: 'string',
      networkAclEntry: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentNetworkAclEntry,
      reachable: 'string',
      relativeGroupIds: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentRelativeGroupIds,
      resourceId: 'string',
      resourceType: 'string',
      securityGroupAcl: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentSecurityGroupAcl,
      sequence: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponents extends $tea.Model {
  networkInsightsAnalysisComponent?: DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponent[];
  static names(): { [key: string]: string } {
    return {
      networkInsightsAnalysisComponent: 'NetworkInsightsAnalysisComponent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkInsightsAnalysisComponent: { 'type': 'array', 'itemType': DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponent },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisesResponseBodyNetworkInsightsAnalysisSetsNetworkInsightsAnalysisSet extends $tea.Model {
  creationTime?: string;
  networkInsightsAnalysisId?: string;
  networkInsightsPathId?: string;
  networkPathFound?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      networkInsightsAnalysisId: 'NetworkInsightsAnalysisId',
      networkInsightsPathId: 'NetworkInsightsPathId',
      networkPathFound: 'NetworkPathFound',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      networkInsightsAnalysisId: 'string',
      networkInsightsPathId: 'string',
      networkPathFound: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsAnalysisesResponseBodyNetworkInsightsAnalysisSets extends $tea.Model {
  networkInsightsAnalysisSet?: DescribeNetworkInsightsAnalysisesResponseBodyNetworkInsightsAnalysisSetsNetworkInsightsAnalysisSet[];
  static names(): { [key: string]: string } {
    return {
      networkInsightsAnalysisSet: 'NetworkInsightsAnalysisSet',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkInsightsAnalysisSet: { 'type': 'array', 'itemType': DescribeNetworkInsightsAnalysisesResponseBodyNetworkInsightsAnalysisSetsNetworkInsightsAnalysisSet },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsPathsResponseBodyNetworkInsightsPathSetsNetworkInsightsPathSet extends $tea.Model {
  creationTime?: string;
  destination?: string;
  destinationPort?: string;
  destinationType?: string;
  networkInsightsPathId?: string;
  networkInsightsPathName?: string;
  networkPathFound?: string;
  protocol?: string;
  source?: string;
  sourceType?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      destination: 'Destination',
      destinationPort: 'DestinationPort',
      destinationType: 'DestinationType',
      networkInsightsPathId: 'NetworkInsightsPathId',
      networkInsightsPathName: 'NetworkInsightsPathName',
      networkPathFound: 'NetworkPathFound',
      protocol: 'Protocol',
      source: 'Source',
      sourceType: 'SourceType',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      destination: 'string',
      destinationPort: 'string',
      destinationType: 'string',
      networkInsightsPathId: 'string',
      networkInsightsPathName: 'string',
      networkPathFound: 'string',
      protocol: 'string',
      source: 'string',
      sourceType: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInsightsPathsResponseBodyNetworkInsightsPathSets extends $tea.Model {
  networkInsightsPathSet?: DescribeNetworkInsightsPathsResponseBodyNetworkInsightsPathSetsNetworkInsightsPathSet[];
  static names(): { [key: string]: string } {
    return {
      networkInsightsPathSet: 'NetworkInsightsPathSet',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkInsightsPathSet: { 'type': 'array', 'itemType': DescribeNetworkInsightsPathsResponseBodyNetworkInsightsPathSetsNetworkInsightsPathSet },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrderAutoRebootTimeResponseBodyDescribeOrderAutoRebootTimeInfo extends $tea.Model {
  autoRebootTime?: string;
  instanceId?: string;
  orderId?: number;
  static names(): { [key: string]: string } {
    return {
      autoRebootTime: 'AutoRebootTime',
      instanceId: 'InstanceId',
      orderId: 'OrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRebootTime: 'string',
      instanceId: 'string',
      orderId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBodyPriceInfoOrderCouponsCoupon extends $tea.Model {
  couponNo?: string;
  description?: string;
  discountOff?: number;
  isSelected?: boolean;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      couponNo: 'CouponNo',
      description: 'Description',
      discountOff: 'DiscountOff',
      isSelected: 'IsSelected',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      couponNo: 'string',
      description: 'string',
      discountOff: 'number',
      isSelected: 'boolean',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBodyPriceInfoOrderCoupons extends $tea.Model {
  coupon?: DescribePriceResponseBodyPriceInfoOrderCouponsCoupon[];
  static names(): { [key: string]: string } {
    return {
      coupon: 'Coupon',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coupon: { 'type': 'array', 'itemType': DescribePriceResponseBodyPriceInfoOrderCouponsCoupon },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModelSubRulesRule extends $tea.Model {
  name?: string;
  ruleId?: number;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      ruleId: 'RuleId',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      ruleId: 'number',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModelSubRules extends $tea.Model {
  rule?: DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModelSubRulesRule[];
  static names(): { [key: string]: string } {
    return {
      rule: 'Rule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rule: { 'type': 'array', 'itemType': DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModelSubRulesRule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModel extends $tea.Model {
  discountPrice?: number;
  originalPrice?: number;
  resource?: string;
  subRules?: DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModelSubRules;
  tradePrice?: number;
  static names(): { [key: string]: string } {
    return {
      discountPrice: 'DiscountPrice',
      originalPrice: 'OriginalPrice',
      resource: 'Resource',
      subRules: 'SubRules',
      tradePrice: 'TradePrice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      discountPrice: 'number',
      originalPrice: 'number',
      resource: 'string',
      subRules: DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModelSubRules,
      tradePrice: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBodyPriceInfoOrderDetailInfos extends $tea.Model {
  resourcePriceModel?: DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModel[];
  static names(): { [key: string]: string } {
    return {
      resourcePriceModel: 'ResourcePriceModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourcePriceModel: { 'type': 'array', 'itemType': DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBodyPriceInfoOrderRuleIdSet extends $tea.Model {
  ruleId?: string[];
  static names(): { [key: string]: string } {
    return {
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBodyPriceInfoOrderSubOrdersSubOrderRuleIdSet extends $tea.Model {
  ruleId?: string[];
  static names(): { [key: string]: string } {
    return {
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBodyPriceInfoOrderSubOrdersSubOrder extends $tea.Model {
  discountPrice?: number;
  instanceId?: string;
  originalPrice?: number;
  ruleIdSet?: DescribePriceResponseBodyPriceInfoOrderSubOrdersSubOrderRuleIdSet;
  tradePrice?: number;
  static names(): { [key: string]: string } {
    return {
      discountPrice: 'DiscountPrice',
      instanceId: 'InstanceId',
      originalPrice: 'OriginalPrice',
      ruleIdSet: 'RuleIdSet',
      tradePrice: 'TradePrice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      discountPrice: 'number',
      instanceId: 'string',
      originalPrice: 'number',
      ruleIdSet: DescribePriceResponseBodyPriceInfoOrderSubOrdersSubOrderRuleIdSet,
      tradePrice: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBodyPriceInfoOrderSubOrders extends $tea.Model {
  subOrder?: DescribePriceResponseBodyPriceInfoOrderSubOrdersSubOrder[];
  static names(): { [key: string]: string } {
    return {
      subOrder: 'SubOrder',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subOrder: { 'type': 'array', 'itemType': DescribePriceResponseBodyPriceInfoOrderSubOrdersSubOrder },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBodyPriceInfoOrder extends $tea.Model {
  coupons?: DescribePriceResponseBodyPriceInfoOrderCoupons;
  currency?: string;
  detailInfos?: DescribePriceResponseBodyPriceInfoOrderDetailInfos;
  discountPrice?: number;
  originalPrice?: number;
  ruleIdSet?: DescribePriceResponseBodyPriceInfoOrderRuleIdSet;
  spotInstanceTypeOriginalPrice?: number;
  spotInstanceTypePrice?: number;
  subOrders?: DescribePriceResponseBodyPriceInfoOrderSubOrders;
  tradePrice?: number;
  static names(): { [key: string]: string } {
    return {
      coupons: 'Coupons',
      currency: 'Currency',
      detailInfos: 'DetailInfos',
      discountPrice: 'DiscountPrice',
      originalPrice: 'OriginalPrice',
      ruleIdSet: 'RuleIdSet',
      spotInstanceTypeOriginalPrice: 'SpotInstanceTypeOriginalPrice',
      spotInstanceTypePrice: 'SpotInstanceTypePrice',
      subOrders: 'SubOrders',
      tradePrice: 'TradePrice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coupons: DescribePriceResponseBodyPriceInfoOrderCoupons,
      currency: 'string',
      detailInfos: DescribePriceResponseBodyPriceInfoOrderDetailInfos,
      discountPrice: 'number',
      originalPrice: 'number',
      ruleIdSet: DescribePriceResponseBodyPriceInfoOrderRuleIdSet,
      spotInstanceTypeOriginalPrice: 'number',
      spotInstanceTypePrice: 'number',
      subOrders: DescribePriceResponseBodyPriceInfoOrderSubOrders,
      tradePrice: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBodyPriceInfoOrderParams extends $tea.Model {
  orderParam?: string[];
  static names(): { [key: string]: string } {
    return {
      orderParam: 'OrderParam',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderParam: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBodyPriceInfoPriceWarning extends $tea.Model {
  code?: string;
  msg?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      msg: 'Msg',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      msg: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBodyPriceInfoRulesRule extends $tea.Model {
  name?: string;
  ruleId?: number;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      ruleId: 'RuleId',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      ruleId: 'number',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBodyPriceInfoRules extends $tea.Model {
  rule?: DescribePriceResponseBodyPriceInfoRulesRule[];
  static names(): { [key: string]: string } {
    return {
      rule: 'Rule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rule: { 'type': 'array', 'itemType': DescribePriceResponseBodyPriceInfoRulesRule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBodyPriceInfo extends $tea.Model {
  order?: DescribePriceResponseBodyPriceInfoOrder;
  orderParams?: DescribePriceResponseBodyPriceInfoOrderParams;
  priceWarning?: DescribePriceResponseBodyPriceInfoPriceWarning;
  rules?: DescribePriceResponseBodyPriceInfoRules;
  static names(): { [key: string]: string } {
    return {
      order: 'Order',
      orderParams: 'OrderParams',
      priceWarning: 'PriceWarning',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      order: DescribePriceResponseBodyPriceInfoOrder,
      orderParams: DescribePriceResponseBodyPriceInfoOrderParams,
      priceWarning: DescribePriceResponseBodyPriceInfoPriceWarning,
      rules: DescribePriceResponseBodyPriceInfoRules,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePrivatePoolsRequestPrivatePoolOptions extends $tea.Model {
  ids?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      ids: 'Ids',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ids: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePrivatePoolsRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemAllocatedResourcesAllocatedResource extends $tea.Model {
  instanceType?: string;
  totalAmount?: number;
  usedAmount?: number;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceType: 'InstanceType',
      totalAmount: 'TotalAmount',
      usedAmount: 'UsedAmount',
      zoneId: 'zoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceType: 'string',
      totalAmount: 'number',
      usedAmount: 'number',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemAllocatedResources extends $tea.Model {
  allocatedResource?: DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemAllocatedResourcesAllocatedResource[];
  static names(): { [key: string]: string } {
    return {
      allocatedResource: 'AllocatedResource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allocatedResource: { 'type': 'array', 'itemType': DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemAllocatedResourcesAllocatedResource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemTagsTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemTags extends $tea.Model {
  tag?: DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemTagsTag[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemTagsTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItem extends $tea.Model {
  allocatedResources?: DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemAllocatedResources;
  description?: string;
  endTime?: string;
  endTimeType?: string;
  instanceChargeType?: string;
  latestStartTime?: string;
  platform?: string;
  privatePoolOptionsId?: string;
  privatePoolOptionsMatchCriteria?: string;
  privatePoolOptionsName?: string;
  privatePoolOptionsType?: string;
  regionId?: string;
  resourceGroupId?: string;
  startTime?: string;
  startTimeType?: string;
  status?: string;
  tags?: DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemTags;
  totalAssuranceTimes?: string;
  usedAssuranceTimes?: number;
  static names(): { [key: string]: string } {
    return {
      allocatedResources: 'AllocatedResources',
      description: 'Description',
      endTime: 'EndTime',
      endTimeType: 'EndTimeType',
      instanceChargeType: 'InstanceChargeType',
      latestStartTime: 'LatestStartTime',
      platform: 'Platform',
      privatePoolOptionsId: 'PrivatePoolOptionsId',
      privatePoolOptionsMatchCriteria: 'PrivatePoolOptionsMatchCriteria',
      privatePoolOptionsName: 'PrivatePoolOptionsName',
      privatePoolOptionsType: 'PrivatePoolOptionsType',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
      startTimeType: 'StartTimeType',
      status: 'Status',
      tags: 'Tags',
      totalAssuranceTimes: 'TotalAssuranceTimes',
      usedAssuranceTimes: 'UsedAssuranceTimes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allocatedResources: DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemAllocatedResources,
      description: 'string',
      endTime: 'string',
      endTimeType: 'string',
      instanceChargeType: 'string',
      latestStartTime: 'string',
      platform: 'string',
      privatePoolOptionsId: 'string',
      privatePoolOptionsMatchCriteria: 'string',
      privatePoolOptionsName: 'string',
      privatePoolOptionsType: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      startTime: 'string',
      startTimeType: 'string',
      status: 'string',
      tags: DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemTags,
      totalAssuranceTimes: 'string',
      usedAssuranceTimes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePrivatePoolsResponseBodyPrivatePoolSet extends $tea.Model {
  privatePoolItem?: DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItem[];
  static names(): { [key: string]: string } {
    return {
      privatePoolItem: 'PrivatePoolItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      privatePoolItem: { 'type': 'array', 'itemType': DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypesRecommendInstanceTypeInstanceType extends $tea.Model {
  cores?: number;
  generation?: string;
  instanceFamilyLevel?: string;
  instanceType?: string;
  instanceTypeFamily?: string;
  memory?: number;
  supportIoOptimized?: string;
  static names(): { [key: string]: string } {
    return {
      cores: 'Cores',
      generation: 'Generation',
      instanceFamilyLevel: 'InstanceFamilyLevel',
      instanceType: 'InstanceType',
      instanceTypeFamily: 'InstanceTypeFamily',
      memory: 'Memory',
      supportIoOptimized: 'SupportIoOptimized',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cores: 'number',
      generation: 'string',
      instanceFamilyLevel: 'string',
      instanceType: 'string',
      instanceTypeFamily: 'string',
      memory: 'number',
      supportIoOptimized: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypesRecommendInstanceType extends $tea.Model {
  capacitySpecification?: string;
  instanceChargeType?: string;
  instanceType?: DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypesRecommendInstanceTypeInstanceType;
  networkType?: string;
  price?: number;
  priority?: number;
  spotStrategy?: string;
  static names(): { [key: string]: string } {
    return {
      capacitySpecification: 'CapacitySpecification',
      instanceChargeType: 'InstanceChargeType',
      instanceType: 'InstanceType',
      networkType: 'NetworkType',
      price: 'Price',
      priority: 'Priority',
      spotStrategy: 'SpotStrategy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacitySpecification: 'string',
      instanceChargeType: 'string',
      instanceType: DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypesRecommendInstanceTypeInstanceType,
      networkType: 'string',
      price: 'number',
      priority: 'number',
      spotStrategy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypes extends $tea.Model {
  recommendInstanceType?: DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypesRecommendInstanceType[];
  static names(): { [key: string]: string } {
    return {
      recommendInstanceType: 'RecommendInstanceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recommendInstanceType: { 'type': 'array', 'itemType': DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypesRecommendInstanceType },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendProductResponseBodyRecommendProductsRecommendProduct extends $tea.Model {
  recommendInstanceTypes?: DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypes;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      recommendInstanceTypes: 'RecommendInstanceTypes',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recommendInstanceTypes: DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypes,
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendProductResponseBodyRecommendProducts extends $tea.Model {
  recommendProduct?: DescribeRecommendProductResponseBodyRecommendProductsRecommendProduct[];
  static names(): { [key: string]: string } {
    return {
      recommendProduct: 'RecommendProduct',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recommendProduct: { 'type': 'array', 'itemType': DescribeRecommendProductResponseBodyRecommendProductsRecommendProduct },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservationDemandCommittedAmountRequestDemandPlan extends $tea.Model {
  amount?: number;
  instanceType?: string;
  static names(): { [key: string]: string } {
    return {
      amount: 'Amount',
      instanceType: 'InstanceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      amount: 'number',
      instanceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservationDemandCommittedAmountResponseBodyCommittedAmountInfo extends $tea.Model {
  committedAmount?: number;
  currency?: string;
  static names(): { [key: string]: string } {
    return {
      committedAmount: 'CommittedAmount',
      currency: 'Currency',
    };
  }

  static types(): { [key: string]: any } {
    return {
      committedAmount: 'number',
      currency: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservationDemandsRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservationDemandsResponseBodyDataDemandOrdersRecommendResourceCapacityReservations extends $tea.Model {
  instanceAmount?: number;
  instanceType?: string;
  matchCriteria?: string;
  planId?: string;
  privatePoolOptionsId?: string;
  startTime?: string;
  status?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceAmount: 'InstanceAmount',
      instanceType: 'InstanceType',
      matchCriteria: 'MatchCriteria',
      planId: 'PlanId',
      privatePoolOptionsId: 'PrivatePoolOptionsId',
      startTime: 'StartTime',
      status: 'Status',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceAmount: 'number',
      instanceType: 'string',
      matchCriteria: 'string',
      planId: 'string',
      privatePoolOptionsId: 'string',
      startTime: 'string',
      status: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservationDemandsResponseBodyDataDemandOrdersRecommendResource extends $tea.Model {
  capacityReservations?: DescribeReservationDemandsResponseBodyDataDemandOrdersRecommendResourceCapacityReservations[];
  static names(): { [key: string]: string } {
    return {
      capacityReservations: 'CapacityReservations',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityReservations: { 'type': 'array', 'itemType': DescribeReservationDemandsResponseBodyDataDemandOrdersRecommendResourceCapacityReservations },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservationDemandsResponseBodyDataDemandOrdersReservationResourceCapacityReservations extends $tea.Model {
  approveCode?: string;
  approveNotes?: string;
  instanceAmount?: number;
  instanceType?: string;
  matchCriteria?: string;
  planId?: string;
  privatePoolOptionsId?: string;
  startTime?: string;
  status?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      approveCode: 'ApproveCode',
      approveNotes: 'ApproveNotes',
      instanceAmount: 'InstanceAmount',
      instanceType: 'InstanceType',
      matchCriteria: 'MatchCriteria',
      planId: 'PlanId',
      privatePoolOptionsId: 'PrivatePoolOptionsId',
      startTime: 'StartTime',
      status: 'Status',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      approveCode: 'string',
      approveNotes: 'string',
      instanceAmount: 'number',
      instanceType: 'string',
      matchCriteria: 'string',
      planId: 'string',
      privatePoolOptionsId: 'string',
      startTime: 'string',
      status: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservationDemandsResponseBodyDataDemandOrdersReservationResource extends $tea.Model {
  capacityReservations?: DescribeReservationDemandsResponseBodyDataDemandOrdersReservationResourceCapacityReservations[];
  static names(): { [key: string]: string } {
    return {
      capacityReservations: 'CapacityReservations',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityReservations: { 'type': 'array', 'itemType': DescribeReservationDemandsResponseBodyDataDemandOrdersReservationResourceCapacityReservations },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservationDemandsResponseBodyDataDemandOrders extends $tea.Model {
  confirmType?: string;
  couponAuto?: string;
  couponType?: string;
  demandId?: string;
  description?: string;
  instanceChargeType?: string;
  instanceCpuCoreCount?: number;
  instanceTypes?: string;
  matchCriteria?: string;
  name?: string;
  period?: number;
  periodUnit?: string;
  phoneNumber?: string;
  platform?: string;
  productType?: string;
  recommendResource?: DescribeReservationDemandsResponseBodyDataDemandOrdersRecommendResource;
  regionId?: string;
  reservationResource?: DescribeReservationDemandsResponseBodyDataDemandOrdersReservationResource;
  reservedInstanceDescription?: string;
  reservedInstanceId?: string;
  reservedInstanceName?: string;
  reservedInstanceOfferingType?: string;
  resourceSupplyType?: string;
  savingPlanDescription?: string;
  savingPlanHourFee?: number;
  savingPlanId?: string;
  savingPlanInstanceTypeFamilyGroup?: string;
  savingPlanName?: string;
  savingPlanPayMode?: string;
  savingPlanSavingType?: string;
  savingPlanSpecType?: string;
  startTime?: string;
  status?: string;
  zoneIds?: string;
  static names(): { [key: string]: string } {
    return {
      confirmType: 'ConfirmType',
      couponAuto: 'CouponAuto',
      couponType: 'CouponType',
      demandId: 'DemandId',
      description: 'Description',
      instanceChargeType: 'InstanceChargeType',
      instanceCpuCoreCount: 'InstanceCpuCoreCount',
      instanceTypes: 'InstanceTypes',
      matchCriteria: 'MatchCriteria',
      name: 'Name',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      phoneNumber: 'PhoneNumber',
      platform: 'Platform',
      productType: 'ProductType',
      recommendResource: 'RecommendResource',
      regionId: 'RegionId',
      reservationResource: 'ReservationResource',
      reservedInstanceDescription: 'ReservedInstanceDescription',
      reservedInstanceId: 'ReservedInstanceId',
      reservedInstanceName: 'ReservedInstanceName',
      reservedInstanceOfferingType: 'ReservedInstanceOfferingType',
      resourceSupplyType: 'ResourceSupplyType',
      savingPlanDescription: 'SavingPlanDescription',
      savingPlanHourFee: 'SavingPlanHourFee',
      savingPlanId: 'SavingPlanId',
      savingPlanInstanceTypeFamilyGroup: 'SavingPlanInstanceTypeFamilyGroup',
      savingPlanName: 'SavingPlanName',
      savingPlanPayMode: 'SavingPlanPayMode',
      savingPlanSavingType: 'SavingPlanSavingType',
      savingPlanSpecType: 'SavingPlanSpecType',
      startTime: 'StartTime',
      status: 'Status',
      zoneIds: 'ZoneIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      confirmType: 'string',
      couponAuto: 'string',
      couponType: 'string',
      demandId: 'string',
      description: 'string',
      instanceChargeType: 'string',
      instanceCpuCoreCount: 'number',
      instanceTypes: 'string',
      matchCriteria: 'string',
      name: 'string',
      period: 'number',
      periodUnit: 'string',
      phoneNumber: 'string',
      platform: 'string',
      productType: 'string',
      recommendResource: DescribeReservationDemandsResponseBodyDataDemandOrdersRecommendResource,
      regionId: 'string',
      reservationResource: DescribeReservationDemandsResponseBodyDataDemandOrdersReservationResource,
      reservedInstanceDescription: 'string',
      reservedInstanceId: 'string',
      reservedInstanceName: 'string',
      reservedInstanceOfferingType: 'string',
      resourceSupplyType: 'string',
      savingPlanDescription: 'string',
      savingPlanHourFee: 'number',
      savingPlanId: 'string',
      savingPlanInstanceTypeFamilyGroup: 'string',
      savingPlanName: 'string',
      savingPlanPayMode: 'string',
      savingPlanSavingType: 'string',
      savingPlanSpecType: 'string',
      startTime: 'string',
      status: 'string',
      zoneIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservationDemandsResponseBodyData extends $tea.Model {
  demandOrders?: DescribeReservationDemandsResponseBodyDataDemandOrders[];
  static names(): { [key: string]: string } {
    return {
      demandOrders: 'DemandOrders',
    };
  }

  static types(): { [key: string]: any } {
    return {
      demandOrders: { 'type': 'array', 'itemType': DescribeReservationDemandsResponseBodyDataDemandOrders },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstanceAllocationsRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstanceAllocationsResponseBodyAllocationsAllocation extends $tea.Model {
  beAllocatedAccountId?: string;
  reservedInstanceId?: string;
  resourceOwnerId?: string;
  static names(): { [key: string]: string } {
    return {
      beAllocatedAccountId: 'BeAllocatedAccountId',
      reservedInstanceId: 'ReservedInstanceId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      beAllocatedAccountId: 'string',
      reservedInstanceId: 'string',
      resourceOwnerId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstanceAllocationsResponseBodyAllocations extends $tea.Model {
  allocation?: DescribeReservedInstanceAllocationsResponseBodyAllocationsAllocation[];
  static names(): { [key: string]: string } {
    return {
      allocation: 'Allocation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allocation: { 'type': 'array', 'itemType': DescribeReservedInstanceAllocationsResponseBodyAllocationsAllocation },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstanceCategoriesRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstanceCategoriesResponseBodyReservedInstanceCategoriesReservedInstanceCategory extends $tea.Model {
  amount?: number;
  instanceAmount?: number;
  instanceType?: string;
  platform?: string;
  regionId?: string;
  scope?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      amount: 'Amount',
      instanceAmount: 'InstanceAmount',
      instanceType: 'InstanceType',
      platform: 'Platform',
      regionId: 'RegionId',
      scope: 'Scope',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      amount: 'number',
      instanceAmount: 'number',
      instanceType: 'string',
      platform: 'string',
      regionId: 'string',
      scope: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstanceCategoriesResponseBodyReservedInstanceCategories extends $tea.Model {
  reservedInstanceCategory?: DescribeReservedInstanceCategoriesResponseBodyReservedInstanceCategoriesReservedInstanceCategory[];
  static names(): { [key: string]: string } {
    return {
      reservedInstanceCategory: 'ReservedInstanceCategory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reservedInstanceCategory: { 'type': 'array', 'itemType': DescribeReservedInstanceCategoriesResponseBodyReservedInstanceCategoriesReservedInstanceCategory },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancePriceRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancePriceResponseBodyPriceInfoOrder extends $tea.Model {
  currency?: string;
  reservedInstanceHourPrice?: number;
  tradePrice?: number;
  static names(): { [key: string]: string } {
    return {
      currency: 'Currency',
      reservedInstanceHourPrice: 'ReservedInstanceHourPrice',
      tradePrice: 'TradePrice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currency: 'string',
      reservedInstanceHourPrice: 'number',
      tradePrice: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancePriceResponseBodyPriceInfo extends $tea.Model {
  order?: DescribeReservedInstancePriceResponseBodyPriceInfoOrder;
  static names(): { [key: string]: string } {
    return {
      order: 'Order',
    };
  }

  static types(): { [key: string]: any } {
    return {
      order: DescribeReservedInstancePriceResponseBodyPriceInfoOrder,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancesRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock extends $tea.Model {
  lockReason?: string;
  static names(): { [key: string]: string } {
    return {
      lockReason: 'LockReason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lockReason: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocks extends $tea.Model {
  operationLock?: DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock[];
  static names(): { [key: string]: string } {
    return {
      operationLock: 'OperationLock',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operationLock: { 'type': 'array', 'itemType': DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTags extends $tea.Model {
  tag?: DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance extends $tea.Model {
  allocationStatus?: string;
  creationTime?: string;
  description?: string;
  expiredTime?: string;
  instanceAmount?: number;
  instanceType?: string;
  offeringType?: string;
  operationLocks?: DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocks;
  platform?: string;
  regionId?: string;
  reservedInstanceId?: string;
  reservedInstanceName?: string;
  resourceGroupId?: string;
  scope?: string;
  startTime?: string;
  status?: string;
  tags?: DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTags;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      allocationStatus: 'AllocationStatus',
      creationTime: 'CreationTime',
      description: 'Description',
      expiredTime: 'ExpiredTime',
      instanceAmount: 'InstanceAmount',
      instanceType: 'InstanceType',
      offeringType: 'OfferingType',
      operationLocks: 'OperationLocks',
      platform: 'Platform',
      regionId: 'RegionId',
      reservedInstanceId: 'ReservedInstanceId',
      reservedInstanceName: 'ReservedInstanceName',
      resourceGroupId: 'ResourceGroupId',
      scope: 'Scope',
      startTime: 'StartTime',
      status: 'Status',
      tags: 'Tags',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allocationStatus: 'string',
      creationTime: 'string',
      description: 'string',
      expiredTime: 'string',
      instanceAmount: 'number',
      instanceType: 'string',
      offeringType: 'string',
      operationLocks: DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocks,
      platform: 'string',
      regionId: 'string',
      reservedInstanceId: 'string',
      reservedInstanceName: 'string',
      resourceGroupId: 'string',
      scope: 'string',
      startTime: 'string',
      status: 'string',
      tags: DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTags,
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancesResponseBodyReservedInstances extends $tea.Model {
  reservedInstance?: DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance[];
  static names(): { [key: string]: string } {
    return {
      reservedInstance: 'ReservedInstance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reservedInstance: { 'type': 'array', 'itemType': DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceAggregationsRequestFilter extends $tea.Model {
  attributeName?: string;
  attributeValue?: string;
  operation?: string;
  static names(): { [key: string]: string } {
    return {
      attributeName: 'AttributeName',
      attributeValue: 'AttributeValue',
      operation: 'Operation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attributeName: 'string',
      attributeValue: 'string',
      operation: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceAggregationsRequestTagFilter extends $tea.Model {
  operation?: string;
  tagKey?: string;
  tagValues?: string[];
  static names(): { [key: string]: string } {
    return {
      operation: 'Operation',
      tagKey: 'TagKey',
      tagValues: 'TagValues',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operation: 'string',
      tagKey: 'string',
      tagValues: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceAggregationsResponseBodyAggregationsAggregation extends $tea.Model {
  count?: string;
  keys?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      keys: 'Keys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'string',
      keys: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceAggregationsResponseBodyAggregations extends $tea.Model {
  aggregation?: DescribeResourceAggregationsResponseBodyAggregationsAggregation[];
  static names(): { [key: string]: string } {
    return {
      aggregation: 'Aggregation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aggregation: { 'type': 'array', 'itemType': DescribeResourceAggregationsResponseBodyAggregationsAggregation },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceAllocationRequestInstanceTypeModel extends $tea.Model {
  instanceType?: string;
  maxPrice?: number;
  spotStrategy?: string;
  weightedCapacity?: number;
  static names(): { [key: string]: string } {
    return {
      instanceType: 'InstanceType',
      maxPrice: 'MaxPrice',
      spotStrategy: 'SpotStrategy',
      weightedCapacity: 'WeightedCapacity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceType: 'string',
      maxPrice: 'number',
      spotStrategy: 'string',
      weightedCapacity: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceAllocationResponseBodyResourcePlanningResponseResourceModelsResourceModel extends $tea.Model {
  amount?: number;
  instanceChargeType?: string;
  instanceType?: string;
  ioOptimized?: string;
  networkType?: string;
  price?: number;
  regionId?: string;
  spotStrategy?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      amount: 'Amount',
      instanceChargeType: 'InstanceChargeType',
      instanceType: 'InstanceType',
      ioOptimized: 'IoOptimized',
      networkType: 'NetworkType',
      price: 'Price',
      regionId: 'RegionId',
      spotStrategy: 'SpotStrategy',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      amount: 'number',
      instanceChargeType: 'string',
      instanceType: 'string',
      ioOptimized: 'string',
      networkType: 'string',
      price: 'number',
      regionId: 'string',
      spotStrategy: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceAllocationResponseBodyResourcePlanningResponseResourceModels extends $tea.Model {
  resourceModel?: DescribeResourceAllocationResponseBodyResourcePlanningResponseResourceModelsResourceModel[];
  static names(): { [key: string]: string } {
    return {
      resourceModel: 'ResourceModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceModel: { 'type': 'array', 'itemType': DescribeResourceAllocationResponseBodyResourcePlanningResponseResourceModelsResourceModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceAllocationResponseBodyResourcePlanningResponse extends $tea.Model {
  resourceModels?: DescribeResourceAllocationResponseBodyResourcePlanningResponseResourceModels;
  satisfiedAmount?: number;
  static names(): { [key: string]: string } {
    return {
      resourceModels: 'ResourceModels',
      satisfiedAmount: 'SatisfiedAmount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceModels: DescribeResourceAllocationResponseBodyResourcePlanningResponseResourceModels,
      satisfiedAmount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayRequestTemplateTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamiliesInstanceTypeFamilyTags extends $tea.Model {
  tag?: string[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamiliesInstanceTypeFamily extends $tea.Model {
  instanceTypeFamilyId?: string;
  tags?: DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamiliesInstanceTypeFamilyTags;
  static names(): { [key: string]: string } {
    return {
      instanceTypeFamilyId: 'InstanceTypeFamilyId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceTypeFamilyId: 'string',
      tags: DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamiliesInstanceTypeFamilyTags,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamilies extends $tea.Model {
  instanceTypeFamily?: DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamiliesInstanceTypeFamily[];
  static names(): { [key: string]: string } {
    return {
      instanceTypeFamily: 'InstanceTypeFamily',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceTypeFamily: { 'type': 'array', 'itemType': DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamiliesInstanceTypeFamily },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategory extends $tea.Model {
  instanceTypeFamilies?: DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamilies;
  secondCategoryLevel?: string;
  static names(): { [key: string]: string } {
    return {
      instanceTypeFamilies: 'InstanceTypeFamilies',
      secondCategoryLevel: 'SecondCategoryLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceTypeFamilies: DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamilies,
      secondCategoryLevel: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategories extends $tea.Model {
  instanceSecondCategory?: DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategory[];
  static names(): { [key: string]: string } {
    return {
      instanceSecondCategory: 'InstanceSecondCategory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceSecondCategory: { 'type': 'array', 'itemType': DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategory },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategory extends $tea.Model {
  instanceSecondCategories?: DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategories;
  topCategoryLevel?: string;
  static names(): { [key: string]: string } {
    return {
      instanceSecondCategories: 'InstanceSecondCategories',
      topCategoryLevel: 'TopCategoryLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceSecondCategories: DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategories,
      topCategoryLevel: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategories extends $tea.Model {
  instanceTopCategory?: DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategory[];
  static names(): { [key: string]: string } {
    return {
      instanceTopCategory: 'InstanceTopCategory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceTopCategory: { 'type': 'array', 'itemType': DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategory },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryZoneIds extends $tea.Model {
  zoneId?: string[];
  static names(): { [key: string]: string } {
    return {
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      zoneId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategory extends $tea.Model {
  categoryType?: string;
  instanceTopCategories?: DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategories;
  zoneIds?: DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryZoneIds;
  static names(): { [key: string]: string } {
    return {
      categoryType: 'CategoryType',
      instanceTopCategories: 'InstanceTopCategories',
      zoneIds: 'ZoneIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryType: 'string',
      instanceTopCategories: DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategories,
      zoneIds: DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryZoneIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategories extends $tea.Model {
  instanceCategory?: DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategory[];
  static names(): { [key: string]: string } {
    return {
      instanceCategory: 'InstanceCategory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceCategory: { 'type': 'array', 'itemType': DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategory },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypesInstanceChargeTypeTags extends $tea.Model {
  tag?: string[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypesInstanceChargeType extends $tea.Model {
  chargeType?: string;
  spotStrategy?: string;
  tags?: DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypesInstanceChargeTypeTags;
  static names(): { [key: string]: string } {
    return {
      chargeType: 'ChargeType',
      spotStrategy: 'SpotStrategy',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chargeType: 'string',
      spotStrategy: 'string',
      tags: DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypesInstanceChargeTypeTags,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypes extends $tea.Model {
  instanceChargeType?: DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypesInstanceChargeType[];
  static names(): { [key: string]: string } {
    return {
      instanceChargeType: 'InstanceChargeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceChargeType: { 'type': 'array', 'itemType': DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypesInstanceChargeType },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamiliesInstanceTypeFamilyTags extends $tea.Model {
  tag?: string[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamiliesInstanceTypeFamily extends $tea.Model {
  instanceTypeFamilyId?: string;
  tags?: DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamiliesInstanceTypeFamilyTags;
  static names(): { [key: string]: string } {
    return {
      instanceTypeFamilyId: 'InstanceTypeFamilyId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceTypeFamilyId: 'string',
      tags: DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamiliesInstanceTypeFamilyTags,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamilies extends $tea.Model {
  instanceTypeFamily?: DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamiliesInstanceTypeFamily[];
  static names(): { [key: string]: string } {
    return {
      instanceTypeFamily: 'InstanceTypeFamily',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceTypeFamily: { 'type': 'array', 'itemType': DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamiliesInstanceTypeFamily },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroup extends $tea.Model {
  instanceFamilyGroupName?: string;
  instanceTypeFamilies?: DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamilies;
  static names(): { [key: string]: string } {
    return {
      instanceFamilyGroupName: 'InstanceFamilyGroupName',
      instanceTypeFamilies: 'InstanceTypeFamilies',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceFamilyGroupName: 'string',
      instanceTypeFamilies: DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamilies,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroups extends $tea.Model {
  instanceFamilyGroup?: DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroup[];
  static names(): { [key: string]: string } {
    return {
      instanceFamilyGroup: 'InstanceFamilyGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceFamilyGroup: { 'type': 'array', 'itemType': DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroup },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategory extends $tea.Model {
  instanceFamilyGroups?: DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroups;
  productName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceFamilyGroups: 'InstanceFamilyGroups',
      productName: 'ProductName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceFamilyGroups: DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroups,
      productName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayProductCategories extends $tea.Model {
  productCategory?: DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategory[];
  static names(): { [key: string]: string } {
    return {
      productCategory: 'ProductCategory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productCategory: { 'type': 'array', 'itemType': DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategory },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayZonesZoneTags extends $tea.Model {
  tag?: string[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayZonesZone extends $tea.Model {
  tags?: DescribeResourceDisplayResponseBodyResourceDisplayZonesZoneTags;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      tags: 'Tags',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tags: DescribeResourceDisplayResponseBodyResourceDisplayZonesZoneTags,
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplayZones extends $tea.Model {
  zone?: DescribeResourceDisplayResponseBodyResourceDisplayZonesZone[];
  static names(): { [key: string]: string } {
    return {
      zone: 'Zone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      zone: { 'type': 'array', 'itemType': DescribeResourceDisplayResponseBodyResourceDisplayZonesZone },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceDisplayResponseBodyResourceDisplay extends $tea.Model {
  instanceCategories?: DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategories;
  instanceChargeTypes?: DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypes;
  productCategories?: DescribeResourceDisplayResponseBodyResourceDisplayProductCategories;
  zones?: DescribeResourceDisplayResponseBodyResourceDisplayZones;
  static names(): { [key: string]: string } {
    return {
      instanceCategories: 'InstanceCategories',
      instanceChargeTypes: 'InstanceChargeTypes',
      productCategories: 'ProductCategories',
      zones: 'Zones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceCategories: DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategories,
      instanceChargeTypes: DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypes,
      productCategories: DescribeResourceDisplayResponseBodyResourceDisplayProductCategories,
      zones: DescribeResourceDisplayResponseBodyResourceDisplayZones,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceFilterAttributesRequestTemplateTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttributeSupportOperations extends $tea.Model {
  supportOperation?: string[];
  static names(): { [key: string]: string } {
    return {
      supportOperation: 'SupportOperation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      supportOperation: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttributeValues extends $tea.Model {
  value?: string[];
  static names(): { [key: string]: string } {
    return {
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      value: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttribute extends $tea.Model {
  name?: string;
  supportOperations?: DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttributeSupportOperations;
  type?: string;
  values?: DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttributeValues;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      supportOperations: 'SupportOperations',
      type: 'Type',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      supportOperations: DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttributeSupportOperations,
      type: 'string',
      values: DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttributeValues,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceFilterAttributesResponseBodyFilterAttributes extends $tea.Model {
  filterAttribute?: DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttribute[];
  static names(): { [key: string]: string } {
    return {
      filterAttribute: 'FilterAttribute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filterAttribute: { 'type': 'array', 'itemType': DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttribute },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceRecommendFiltersRequestTemplateTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceRecommendFiltersResponseBodyRecommendFiltersRecommendFilter extends $tea.Model {
  attributeName?: string;
  attributeValue?: string;
  product?: string;
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      attributeName: 'AttributeName',
      attributeValue: 'AttributeValue',
      product: 'Product',
      resourceType: 'ResourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attributeName: 'string',
      attributeValue: 'string',
      product: 'string',
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceRecommendFiltersResponseBodyRecommendFilters extends $tea.Model {
  recommendFilter?: DescribeResourceRecommendFiltersResponseBodyRecommendFiltersRecommendFilter[];
  static names(): { [key: string]: string } {
    return {
      recommendFilter: 'RecommendFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recommendFilter: { 'type': 'array', 'itemType': DescribeResourceRecommendFiltersResponseBodyRecommendFiltersRecommendFilter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceSolutionsRequestInstanceTypeModel extends $tea.Model {
  instanceType?: string;
  weightedCapacity?: number;
  static names(): { [key: string]: string } {
    return {
      instanceType: 'InstanceType',
      weightedCapacity: 'WeightedCapacity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceType: 'string',
      weightedCapacity: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseRecommendReasons extends $tea.Model {
  recommendReason?: string[];
  static names(): { [key: string]: string } {
    return {
      recommendReason: 'RecommendReason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recommendReason: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseResourceModelsResourceModel extends $tea.Model {
  amount?: number;
  deliveryTime?: string;
  instanceType?: string;
  regionId?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      amount: 'Amount',
      deliveryTime: 'DeliveryTime',
      instanceType: 'InstanceType',
      regionId: 'RegionId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      amount: 'number',
      deliveryTime: 'string',
      instanceType: 'string',
      regionId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseResourceModels extends $tea.Model {
  resourceModel?: DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseResourceModelsResourceModel[];
  static names(): { [key: string]: string } {
    return {
      resourceModel: 'ResourceModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceModel: { 'type': 'array', 'itemType': DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseResourceModelsResourceModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponse extends $tea.Model {
  recommendReasons?: DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseRecommendReasons;
  resourceModels?: DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseResourceModels;
  satisfiedAmount?: number;
  static names(): { [key: string]: string } {
    return {
      recommendReasons: 'RecommendReasons',
      resourceModels: 'ResourceModels',
      satisfiedAmount: 'SatisfiedAmount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recommendReasons: DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseRecommendReasons,
      resourceModels: DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseResourceModels,
      satisfiedAmount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceSolutionsResponseBodyResourcePlanningResponses extends $tea.Model {
  resourcePlanningResponse?: DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponse[];
  static names(): { [key: string]: string } {
    return {
      resourcePlanningResponse: 'ResourcePlanningResponse',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourcePlanningResponse: { 'type': 'array', 'itemType': DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponse },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourcesRequestFilter extends $tea.Model {
  attributeName?: string;
  attributeValue?: string;
  operation?: string;
  static names(): { [key: string]: string } {
    return {
      attributeName: 'AttributeName',
      attributeValue: 'AttributeValue',
      operation: 'Operation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attributeName: 'string',
      attributeValue: 'string',
      operation: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourcesRequestTagFilter extends $tea.Model {
  operation?: string;
  tagKey?: string;
  tagValues?: string[];
  static names(): { [key: string]: string } {
    return {
      operation: 'Operation',
      tagKey: 'TagKey',
      tagValues: 'TagValues',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operation: 'string',
      tagKey: 'string',
      tagValues: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourcesRequestTemplateTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourcesResponseBodyResourcesResource extends $tea.Model {
  arn?: string;
  createTime?: string;
  matchedAttributes?: string;
  product?: string;
  regionId?: string;
  resourceId?: string;
  resourceName?: string;
  resourceType?: string;
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      arn: 'Arn',
      createTime: 'CreateTime',
      matchedAttributes: 'MatchedAttributes',
      product: 'Product',
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      resourceName: 'ResourceName',
      resourceType: 'ResourceType',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arn: 'string',
      createTime: 'string',
      matchedAttributes: 'string',
      product: 'string',
      regionId: 'string',
      resourceId: 'string',
      resourceName: 'string',
      resourceType: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourcesResponseBodyResources extends $tea.Model {
  resource?: DescribeResourcesResponseBodyResourcesResource[];
  static names(): { [key: string]: string } {
    return {
      resource: 'Resource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resource: { 'type': 'array', 'itemType': DescribeResourcesResponseBodyResourcesResource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiUtilizationRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiUtilizationResponseBodyUtilizationsUtilization extends $tea.Model {
  reservedInstanceId?: string;
  utilization?: string;
  static names(): { [key: string]: string } {
    return {
      reservedInstanceId: 'ReservedInstanceId',
      utilization: 'Utilization',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reservedInstanceId: 'string',
      utilization: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiUtilizationResponseBodyUtilizations extends $tea.Model {
  utilization?: DescribeRiUtilizationResponseBodyUtilizationsUtilization[];
  static names(): { [key: string]: string } {
    return {
      utilization: 'Utilization',
    };
  }

  static types(): { [key: string]: any } {
    return {
      utilization: { 'type': 'array', 'itemType': DescribeRiUtilizationResponseBodyUtilizationsUtilization },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScenePurchaseRecommendRequestPrivatePoolOptions extends $tea.Model {
  id?: string;
  matchCriteria?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      matchCriteria: 'MatchCriteria',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      matchCriteria: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScenePurchaseRecommendRequestSchedulerOptions extends $tea.Model {
  dedicatedHostClusterId?: string;
  static names(): { [key: string]: string } {
    return {
      dedicatedHostClusterId: 'DedicatedHostClusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedHostClusterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScenePurchaseRecommendRequestDataDisk extends $tea.Model {
  category?: string;
  performanceLevel?: string;
  size?: number;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      performanceLevel: 'PerformanceLevel',
      size: 'Size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      performanceLevel: 'string',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScenePurchaseRecommendRequestSystemDisk extends $tea.Model {
  storageClusterId?: string;
  static names(): { [key: string]: string } {
    return {
      storageClusterId: 'StorageClusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      storageClusterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProductRecommendSpSpecsRecommendSpSpec extends $tea.Model {
  duration?: number;
  effectiveDate?: string;
  payMode?: string;
  pricingCycle?: string;
  recommendReason?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
      effectiveDate: 'EffectiveDate',
      payMode: 'PayMode',
      pricingCycle: 'PricingCycle',
      recommendReason: 'RecommendReason',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'number',
      effectiveDate: 'string',
      payMode: 'string',
      pricingCycle: 'string',
      recommendReason: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProductRecommendSpSpecs extends $tea.Model {
  recommendSpSpec?: DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProductRecommendSpSpecsRecommendSpSpec[];
  static names(): { [key: string]: string } {
    return {
      recommendSpSpec: 'RecommendSpSpec',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recommendSpSpec: { 'type': 'array', 'itemType': DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProductRecommendSpSpecsRecommendSpSpec },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProduct extends $tea.Model {
  recommendSpSpecs?: DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProductRecommendSpSpecs;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      recommendSpSpecs: 'RecommendSpSpecs',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recommendSpSpecs: DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProductRecommendSpSpecs,
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScenePurchaseRecommendResponseBodyRecommendProducts extends $tea.Model {
  recommendProduct?: DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProduct[];
  static names(): { [key: string]: string } {
    return {
      recommendProduct: 'RecommendProduct',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recommendProduct: { 'type': 'array', 'itemType': DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProduct },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpecInstanceTypesInstanceType extends $tea.Model {
  instanceTypeFamily?: string;
  instanceTypeName?: string;
  priority?: number;
  static names(): { [key: string]: string } {
    return {
      instanceTypeFamily: 'InstanceTypeFamily',
      instanceTypeName: 'InstanceTypeName',
      priority: 'Priority',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceTypeFamily: 'string',
      instanceTypeName: 'string',
      priority: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpecInstanceTypes extends $tea.Model {
  instanceType?: DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpecInstanceTypesInstanceType[];
  static names(): { [key: string]: string } {
    return {
      instanceType: 'InstanceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceType: { 'type': 'array', 'itemType': DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpecInstanceTypesInstanceType },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpec extends $tea.Model {
  cores?: number;
  instanceTypes?: DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpecInstanceTypes;
  memory?: number;
  static names(): { [key: string]: string } {
    return {
      cores: 'Cores',
      instanceTypes: 'InstanceTypes',
      memory: 'Memory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cores: 'number',
      instanceTypes: DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpecInstanceTypes,
      memory: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecs extends $tea.Model {
  recommendInstanceSpec?: DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpec[];
  static names(): { [key: string]: string } {
    return {
      recommendInstanceSpec: 'RecommendInstanceSpec',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recommendInstanceSpec: { 'type': 'array', 'itemType': DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpec },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProduct extends $tea.Model {
  recommendInstanceSpecs?: DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecs;
  recommendReason?: string;
  regionId?: string;
  resourceId?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      recommendInstanceSpecs: 'RecommendInstanceSpecs',
      recommendReason: 'RecommendReason',
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recommendInstanceSpecs: DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecs,
      recommendReason: 'string',
      regionId: 'string',
      resourceId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSceneResourceRecommendResponseBodyRecommendProducts extends $tea.Model {
  recommendProduct?: DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProduct[];
  static names(): { [key: string]: string } {
    return {
      recommendProduct: 'RecommendProduct',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recommendProduct: { 'type': 'array', 'itemType': DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProduct },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSpotInstanceAdviceResponseBodyAvailableSpotZones extends $tea.Model {
  availableSpotZone?: string[];
  static names(): { [key: string]: string } {
    return {
      availableSpotZone: 'AvailableSpotZone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableSpotZone: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageCapacityUnitAllocationsResponseBodyAllocationsAllocation extends $tea.Model {
  beAllocatedAccountId?: string;
  resourceOwnerId?: string;
  storageCapacityUnitId?: string;
  static names(): { [key: string]: string } {
    return {
      beAllocatedAccountId: 'BeAllocatedAccountId',
      resourceOwnerId: 'ResourceOwnerId',
      storageCapacityUnitId: 'StorageCapacityUnitId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      beAllocatedAccountId: 'string',
      resourceOwnerId: 'string',
      storageCapacityUnitId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageCapacityUnitAllocationsResponseBodyAllocations extends $tea.Model {
  allocation?: DescribeStorageCapacityUnitAllocationsResponseBodyAllocationsAllocation[];
  static names(): { [key: string]: string } {
    return {
      allocation: 'Allocation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allocation: { 'type': 'array', 'itemType': DescribeStorageCapacityUnitAllocationsResponseBodyAllocationsAllocation },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageCapacityUnitDeductFactorRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageSetDetailsResponseBodyDisksDisk extends $tea.Model {
  category?: string;
  creationTime?: string;
  diskId?: string;
  diskName?: string;
  regionId?: string;
  storageSetId?: string;
  storageSetPartitionNumber?: number;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      creationTime: 'CreationTime',
      diskId: 'DiskId',
      diskName: 'DiskName',
      regionId: 'RegionId',
      storageSetId: 'StorageSetId',
      storageSetPartitionNumber: 'StorageSetPartitionNumber',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      creationTime: 'string',
      diskId: 'string',
      diskName: 'string',
      regionId: 'string',
      storageSetId: 'string',
      storageSetPartitionNumber: 'number',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageSetDetailsResponseBodyDisks extends $tea.Model {
  disk?: DescribeStorageSetDetailsResponseBodyDisksDisk[];
  static names(): { [key: string]: string } {
    return {
      disk: 'Disk',
    };
  }

  static types(): { [key: string]: any } {
    return {
      disk: { 'type': 'array', 'itemType': DescribeStorageSetDetailsResponseBodyDisksDisk },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageSetsResponseBodyStorageSetsStorageSet extends $tea.Model {
  creationTime?: string;
  description?: string;
  regionId?: string;
  storageSetId?: string;
  storageSetName?: string;
  storageSetPartitionNumber?: number;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      description: 'Description',
      regionId: 'RegionId',
      storageSetId: 'StorageSetId',
      storageSetName: 'StorageSetName',
      storageSetPartitionNumber: 'StorageSetPartitionNumber',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      description: 'string',
      regionId: 'string',
      storageSetId: 'string',
      storageSetName: 'string',
      storageSetPartitionNumber: 'number',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageSetsResponseBodyStorageSets extends $tea.Model {
  storageSet?: DescribeStorageSetsResponseBodyStorageSetsStorageSet[];
  static names(): { [key: string]: string } {
    return {
      storageSet: 'StorageSet',
    };
  }

  static types(): { [key: string]: any } {
    return {
      storageSet: { 'type': 'array', 'itemType': DescribeStorageSetsResponseBodyStorageSetsStorageSet },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransitionVSwitchesResponseBodyVSwitchModelsModel extends $tea.Model {
  CIDR?: string;
  description?: string;
  izNo?: string;
  name?: string;
  vSwitchId?: string;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      CIDR: 'CIDR',
      description: 'Description',
      izNo: 'IzNo',
      name: 'Name',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      CIDR: 'string',
      description: 'string',
      izNo: 'string',
      name: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransitionVSwitchesResponseBodyVSwitchModels extends $tea.Model {
  model?: DescribeTransitionVSwitchesResponseBodyVSwitchModelsModel[];
  static names(): { [key: string]: string } {
    return {
      model: 'Model',
    };
  }

  static types(): { [key: string]: any } {
    return {
      model: { 'type': 'array', 'itemType': DescribeTransitionVSwitchesResponseBodyVSwitchModelsModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransitionVpcAndVSwitchResponseBodyVmTransitionModelsModel extends $tea.Model {
  code?: string;
  instanceId?: string;
  message?: string;
  vSwitchId?: string;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      instanceId: 'InstanceId',
      message: 'Message',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      instanceId: 'string',
      message: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransitionVpcAndVSwitchResponseBodyVmTransitionModels extends $tea.Model {
  model?: DescribeTransitionVpcAndVSwitchResponseBodyVmTransitionModelsModel[];
  static names(): { [key: string]: string } {
    return {
      model: 'Model',
    };
  }

  static types(): { [key: string]: any } {
    return {
      model: { 'type': 'array', 'itemType': DescribeTransitionVpcAndVSwitchResponseBodyVmTransitionModelsModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransitionVpcsResponseBodyVpcModelsModel extends $tea.Model {
  config?: string;
  regionId?: string;
  status?: number;
  type?: number;
  vpcId?: string;
  vpcName?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      regionId: 'RegionId',
      status: 'Status',
      type: 'Type',
      vpcId: 'VpcId',
      vpcName: 'VpcName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      regionId: 'string',
      status: 'number',
      type: 'number',
      vpcId: 'string',
      vpcName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransitionVpcsResponseBodyVpcModels extends $tea.Model {
  model?: DescribeTransitionVpcsResponseBodyVpcModelsModel[];
  static names(): { [key: string]: string } {
    return {
      model: 'Model',
    };
  }

  static types(): { [key: string]: any } {
    return {
      model: { 'type': 'array', 'itemType': DescribeTransitionVpcsResponseBodyVpcModelsModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserAvailableIpServiceProvidersResponseBodyIpServiceProvidersIpServiceProvider extends $tea.Model {
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserAvailableIpServiceProvidersResponseBodyIpServiceProviders extends $tea.Model {
  ipServiceProvider?: DescribeUserAvailableIpServiceProvidersResponseBodyIpServiceProvidersIpServiceProvider[];
  static names(): { [key: string]: string } {
    return {
      ipServiceProvider: 'IpServiceProvider',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipServiceProvider: { 'type': 'array', 'itemType': DescribeUserAvailableIpServiceProvidersResponseBodyIpServiceProvidersIpServiceProvider },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserQuotaApplicationsResponseBodyUserQuotaApplicationsUserQuotaApplication extends $tea.Model {
  applicationId?: string;
  chargeType?: string;
  comment?: string;
  creationTime?: string;
  description?: string;
  expireTime?: string;
  instanceType?: string;
  quotaType?: string;
  quotaValue?: number;
  resultCode?: string;
  startTime?: string;
  status?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      applicationId: 'ApplicationId',
      chargeType: 'ChargeType',
      comment: 'Comment',
      creationTime: 'CreationTime',
      description: 'Description',
      expireTime: 'ExpireTime',
      instanceType: 'InstanceType',
      quotaType: 'QuotaType',
      quotaValue: 'QuotaValue',
      resultCode: 'ResultCode',
      startTime: 'StartTime',
      status: 'Status',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationId: 'string',
      chargeType: 'string',
      comment: 'string',
      creationTime: 'string',
      description: 'string',
      expireTime: 'string',
      instanceType: 'string',
      quotaType: 'string',
      quotaValue: 'number',
      resultCode: 'string',
      startTime: 'string',
      status: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserQuotaApplicationsResponseBodyUserQuotaApplications extends $tea.Model {
  userQuotaApplication?: DescribeUserQuotaApplicationsResponseBodyUserQuotaApplicationsUserQuotaApplication[];
  static names(): { [key: string]: string } {
    return {
      userQuotaApplication: 'UserQuotaApplication',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userQuotaApplication: { 'type': 'array', 'itemType': DescribeUserQuotaApplicationsResponseBodyUserQuotaApplicationsUserQuotaApplication },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstanceHavsInstancesHavsInstance extends $tea.Model {
  ecsInstanceId?: string;
  reason?: string;
  static names(): { [key: string]: string } {
    return {
      ecsInstanceId: 'EcsInstanceId',
      reason: 'Reason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ecsInstanceId: 'string',
      reason: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstanceHavsInstances extends $tea.Model {
  havsInstance?: DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstanceHavsInstancesHavsInstance[];
  static names(): { [key: string]: string } {
    return {
      havsInstance: 'HavsInstance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      havsInstance: { 'type': 'array', 'itemType': DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstanceHavsInstancesHavsInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstance extends $tea.Model {
  havsInstances?: DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstanceHavsInstances;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      havsInstances: 'HavsInstances',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      havsInstances: DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstanceHavsInstances,
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcHavsInstancesResponseBodyVpcHavsInstances extends $tea.Model {
  vpcHavsInstance?: DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstance[];
  static names(): { [key: string]: string } {
    return {
      vpcHavsInstance: 'VpcHavsInstance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      vpcHavsInstance: { 'type': 'array', 'itemType': DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWaitingOrdersRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWaitingOrdersResponseBodyDataInstanceInfos extends $tea.Model {
  instanceId?: string;
  resultCode?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      resultCode: 'ResultCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      resultCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWaitingOrdersResponseBodyData extends $tea.Model {
  chargeType?: string;
  createTime?: string;
  expireTime?: string;
  failedMessage?: string;
  instanceAmount?: number;
  instanceInfos?: DescribeWaitingOrdersResponseBodyDataInstanceInfos[];
  instanceType?: string;
  lxCreateParam?: string;
  regionId?: string;
  status?: string;
  successAmount?: number;
  waitingOrderId?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      chargeType: 'ChargeType',
      createTime: 'CreateTime',
      expireTime: 'ExpireTime',
      failedMessage: 'FailedMessage',
      instanceAmount: 'InstanceAmount',
      instanceInfos: 'InstanceInfos',
      instanceType: 'InstanceType',
      lxCreateParam: 'LxCreateParam',
      regionId: 'RegionId',
      status: 'Status',
      successAmount: 'SuccessAmount',
      waitingOrderId: 'WaitingOrderId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chargeType: 'string',
      createTime: 'string',
      expireTime: 'string',
      failedMessage: 'string',
      instanceAmount: 'number',
      instanceInfos: { 'type': 'array', 'itemType': DescribeWaitingOrdersResponseBodyDataInstanceInfos },
      instanceType: 'string',
      lxCreateParam: 'string',
      regionId: 'string',
      status: 'string',
      successAmount: 'number',
      waitingOrderId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLaunchTemplateDataResponseBodyLaunchTemplateDataSystemDisk extends $tea.Model {
  category?: string;
  description?: string;
  diskName?: string;
  iops?: number;
  size?: number;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      description: 'Description',
      diskName: 'DiskName',
      iops: 'Iops',
      size: 'Size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      description: 'string',
      diskName: 'string',
      iops: 'number',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLaunchTemplateDataResponseBodyLaunchTemplateDataDataDisksDataDisk extends $tea.Model {
  category?: string;
  deleteWithInstance?: boolean;
  description?: string;
  device?: string;
  diskName?: string;
  encrypted?: string;
  size?: number;
  snapshotId?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      deleteWithInstance: 'DeleteWithInstance',
      description: 'Description',
      device: 'Device',
      diskName: 'DiskName',
      encrypted: 'Encrypted',
      size: 'Size',
      snapshotId: 'SnapshotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      deleteWithInstance: 'boolean',
      description: 'string',
      device: 'string',
      diskName: 'string',
      encrypted: 'string',
      size: 'number',
      snapshotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLaunchTemplateDataResponseBodyLaunchTemplateDataDataDisks extends $tea.Model {
  dataDisk?: GetLaunchTemplateDataResponseBodyLaunchTemplateDataDataDisksDataDisk[];
  static names(): { [key: string]: string } {
    return {
      dataDisk: 'DataDisk',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataDisk: { 'type': 'array', 'itemType': GetLaunchTemplateDataResponseBodyLaunchTemplateDataDataDisksDataDisk },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLaunchTemplateDataResponseBodyLaunchTemplateDataNetworkInterfacesNetworkInterface extends $tea.Model {
  description?: string;
  networkInterfaceName?: string;
  primaryIpAddress?: string;
  securityGroupId?: string;
  vSwitchId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      networkInterfaceName: 'NetworkInterfaceName',
      primaryIpAddress: 'PrimaryIpAddress',
      securityGroupId: 'SecurityGroupId',
      vSwitchId: 'VSwitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      networkInterfaceName: 'string',
      primaryIpAddress: 'string',
      securityGroupId: 'string',
      vSwitchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLaunchTemplateDataResponseBodyLaunchTemplateDataNetworkInterfaces extends $tea.Model {
  networkInterface?: GetLaunchTemplateDataResponseBodyLaunchTemplateDataNetworkInterfacesNetworkInterface[];
  static names(): { [key: string]: string } {
    return {
      networkInterface: 'NetworkInterface',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkInterface: { 'type': 'array', 'itemType': GetLaunchTemplateDataResponseBodyLaunchTemplateDataNetworkInterfacesNetworkInterface },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLaunchTemplateDataResponseBodyLaunchTemplateDataTagsInstanceTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLaunchTemplateDataResponseBodyLaunchTemplateDataTags extends $tea.Model {
  instanceTag?: GetLaunchTemplateDataResponseBodyLaunchTemplateDataTagsInstanceTag[];
  static names(): { [key: string]: string } {
    return {
      instanceTag: 'InstanceTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceTag: { 'type': 'array', 'itemType': GetLaunchTemplateDataResponseBodyLaunchTemplateDataTagsInstanceTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLaunchTemplateDataResponseBodyLaunchTemplateData extends $tea.Model {
  systemDisk: GetLaunchTemplateDataResponseBodyLaunchTemplateDataSystemDisk;
  autoReleaseTime?: string;
  dataDisks?: GetLaunchTemplateDataResponseBodyLaunchTemplateDataDataDisks;
  description?: string;
  enableVmOsConfig?: boolean;
  hostName?: string;
  imageId?: string;
  imageOwnerAlias?: string;
  instanceChargeType?: string;
  instanceName?: string;
  instanceType?: string;
  internetChargeType?: string;
  internetMaxBandwidthIn?: number;
  internetMaxBandwidthOut?: number;
  ioOptimized?: string;
  keyPairName?: string;
  networkInterfaces?: GetLaunchTemplateDataResponseBodyLaunchTemplateDataNetworkInterfaces;
  networkType?: string;
  passwordInherit?: boolean;
  period?: number;
  ramRoleName?: string;
  resourceGroupId?: string;
  securityEnhancementStrategy?: boolean;
  securityGroupId?: string;
  spotDuration?: number;
  spotPriceLimit?: number;
  spotStrategy?: string;
  tags?: GetLaunchTemplateDataResponseBodyLaunchTemplateDataTags;
  userData?: string;
  vSwitchId?: string;
  vpcId?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      systemDisk: 'SystemDisk',
      autoReleaseTime: 'AutoReleaseTime',
      dataDisks: 'DataDisks',
      description: 'Description',
      enableVmOsConfig: 'EnableVmOsConfig',
      hostName: 'HostName',
      imageId: 'ImageId',
      imageOwnerAlias: 'ImageOwnerAlias',
      instanceChargeType: 'InstanceChargeType',
      instanceName: 'InstanceName',
      instanceType: 'InstanceType',
      internetChargeType: 'InternetChargeType',
      internetMaxBandwidthIn: 'InternetMaxBandwidthIn',
      internetMaxBandwidthOut: 'InternetMaxBandwidthOut',
      ioOptimized: 'IoOptimized',
      keyPairName: 'KeyPairName',
      networkInterfaces: 'NetworkInterfaces',
      networkType: 'NetworkType',
      passwordInherit: 'PasswordInherit',
      period: 'Period',
      ramRoleName: 'RamRoleName',
      resourceGroupId: 'ResourceGroupId',
      securityEnhancementStrategy: 'SecurityEnhancementStrategy',
      securityGroupId: 'SecurityGroupId',
      spotDuration: 'SpotDuration',
      spotPriceLimit: 'SpotPriceLimit',
      spotStrategy: 'SpotStrategy',
      tags: 'Tags',
      userData: 'UserData',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      systemDisk: GetLaunchTemplateDataResponseBodyLaunchTemplateDataSystemDisk,
      autoReleaseTime: 'string',
      dataDisks: GetLaunchTemplateDataResponseBodyLaunchTemplateDataDataDisks,
      description: 'string',
      enableVmOsConfig: 'boolean',
      hostName: 'string',
      imageId: 'string',
      imageOwnerAlias: 'string',
      instanceChargeType: 'string',
      instanceName: 'string',
      instanceType: 'string',
      internetChargeType: 'string',
      internetMaxBandwidthIn: 'number',
      internetMaxBandwidthOut: 'number',
      ioOptimized: 'string',
      keyPairName: 'string',
      networkInterfaces: GetLaunchTemplateDataResponseBodyLaunchTemplateDataNetworkInterfaces,
      networkType: 'string',
      passwordInherit: 'boolean',
      period: 'number',
      ramRoleName: 'string',
      resourceGroupId: 'string',
      securityEnhancementStrategy: 'boolean',
      securityGroupId: 'string',
      spotDuration: 'number',
      spotPriceLimit: 'number',
      spotStrategy: 'string',
      tags: GetLaunchTemplateDataResponseBodyLaunchTemplateDataTags,
      userData: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAssociatedPublicIp extends $tea.Model {
  allocationId?: string;
  publicIpAddress?: string;
  static names(): { [key: string]: string } {
    return {
      allocationId: 'AllocationId',
      publicIpAddress: 'PublicIpAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allocationId: 'string',
      publicIpAddress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAttachment extends $tea.Model {
  deviceIndex?: number;
  instanceId?: string;
  trunkNetworkInterfaceId?: string;
  static names(): { [key: string]: string } {
    return {
      deviceIndex: 'DeviceIndex',
      instanceId: 'InstanceId',
      trunkNetworkInterfaceId: 'TrunkNetworkInterfaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceIndex: 'number',
      instanceId: 'string',
      trunkNetworkInterfaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set extends $tea.Model {
  ipv6Address?: string;
  static names(): { [key: string]: string } {
    return {
      ipv6Address: 'Ipv6Address',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipv6Address: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets extends $tea.Model {
  ipv6Set?: InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set[];
  static names(): { [key: string]: string } {
    return {
      ipv6Set: 'Ipv6Set',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipv6Set: { 'type': 'array', 'itemType': InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSetAssociatedPublicIp extends $tea.Model {
  allocationId?: string;
  publicIpAddress?: string;
  static names(): { [key: string]: string } {
    return {
      allocationId: 'AllocationId',
      publicIpAddress: 'PublicIpAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allocationId: 'string',
      publicIpAddress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet extends $tea.Model {
  associatedPublicIp?: InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSetAssociatedPublicIp;
  primary?: boolean;
  privateIpAddress?: string;
  static names(): { [key: string]: string } {
    return {
      associatedPublicIp: 'AssociatedPublicIp',
      primary: 'Primary',
      privateIpAddress: 'PrivateIpAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      associatedPublicIp: InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSetAssociatedPublicIp,
      primary: 'boolean',
      privateIpAddress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets extends $tea.Model {
  privateIpSet?: InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet[];
  static names(): { [key: string]: string } {
    return {
      privateIpSet: 'PrivateIpSet',
    };
  }

  static types(): { [key: string]: any } {
    return {
      privateIpSet: { 'type': 'array', 'itemType': InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds extends $tea.Model {
  securityGroupId?: string[];
  static names(): { [key: string]: string } {
    return {
      securityGroupId: 'SecurityGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityGroupId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTags extends $tea.Model {
  tag?: InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSet extends $tea.Model {
  associatedPublicIp?: InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAssociatedPublicIp;
  attachment?: InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAttachment;
  creationTime?: string;
  description?: string;
  instanceId?: string;
  ipv6Sets?: InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets;
  macAddress?: string;
  networkInterfaceId?: string;
  networkInterfaceName?: string;
  networkInterfaceTrafficMode?: string;
  ownerId?: string;
  privateIpAddress?: string;
  privateIpSets?: InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets;
  queueNumber?: number;
  queuePairNumber?: number;
  resourceGroupId?: string;
  securityGroupIds?: InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds;
  serviceID?: number;
  serviceManaged?: boolean;
  status?: string;
  tags?: InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTags;
  type?: string;
  vSwitchId?: string;
  vpcId?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      associatedPublicIp: 'AssociatedPublicIp',
      attachment: 'Attachment',
      creationTime: 'CreationTime',
      description: 'Description',
      instanceId: 'InstanceId',
      ipv6Sets: 'Ipv6Sets',
      macAddress: 'MacAddress',
      networkInterfaceId: 'NetworkInterfaceId',
      networkInterfaceName: 'NetworkInterfaceName',
      networkInterfaceTrafficMode: 'NetworkInterfaceTrafficMode',
      ownerId: 'OwnerId',
      privateIpAddress: 'PrivateIpAddress',
      privateIpSets: 'PrivateIpSets',
      queueNumber: 'QueueNumber',
      queuePairNumber: 'QueuePairNumber',
      resourceGroupId: 'ResourceGroupId',
      securityGroupIds: 'SecurityGroupIds',
      serviceID: 'ServiceID',
      serviceManaged: 'ServiceManaged',
      status: 'Status',
      tags: 'Tags',
      type: 'Type',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      associatedPublicIp: InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAssociatedPublicIp,
      attachment: InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAttachment,
      creationTime: 'string',
      description: 'string',
      instanceId: 'string',
      ipv6Sets: InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets,
      macAddress: 'string',
      networkInterfaceId: 'string',
      networkInterfaceName: 'string',
      networkInterfaceTrafficMode: 'string',
      ownerId: 'string',
      privateIpAddress: 'string',
      privateIpSets: InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets,
      queueNumber: 'number',
      queuePairNumber: 'number',
      resourceGroupId: 'string',
      securityGroupIds: InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds,
      serviceID: 'number',
      serviceManaged: 'boolean',
      status: 'string',
      tags: InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTags,
      type: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSets extends $tea.Model {
  networkInterfaceSet?: InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSet[];
  static names(): { [key: string]: string } {
    return {
      networkInterfaceSet: 'NetworkInterfaceSet',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkInterfaceSet: { 'type': 'array', 'itemType': InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSet },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAccountEcsQuotasResponseBodyEcsQuotasEcsQuota extends $tea.Model {
  applicationStatus?: string;
  baseQuota?: number;
  baseQuotaUsage?: number;
  chargeType?: string;
  networkType?: string;
  quotaResourceName?: string;
  quotaResourceType?: string;
  quotaUnit?: string;
  regionId?: string;
  reservedQuota?: number;
  reservedQuotaUsage?: number;
  totalQuota?: number;
  totalQuotaUsage?: number;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      applicationStatus: 'ApplicationStatus',
      baseQuota: 'BaseQuota',
      baseQuotaUsage: 'BaseQuotaUsage',
      chargeType: 'ChargeType',
      networkType: 'NetworkType',
      quotaResourceName: 'QuotaResourceName',
      quotaResourceType: 'QuotaResourceType',
      quotaUnit: 'QuotaUnit',
      regionId: 'RegionId',
      reservedQuota: 'ReservedQuota',
      reservedQuotaUsage: 'ReservedQuotaUsage',
      totalQuota: 'TotalQuota',
      totalQuotaUsage: 'TotalQuotaUsage',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationStatus: 'string',
      baseQuota: 'number',
      baseQuotaUsage: 'number',
      chargeType: 'string',
      networkType: 'string',
      quotaResourceName: 'string',
      quotaResourceType: 'string',
      quotaUnit: 'string',
      regionId: 'string',
      reservedQuota: 'number',
      reservedQuotaUsage: 'number',
      totalQuota: 'number',
      totalQuotaUsage: 'number',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAccountEcsQuotasResponseBodyEcsQuotas extends $tea.Model {
  ecsQuota?: ListAccountEcsQuotasResponseBodyEcsQuotasEcsQuota[];
  static names(): { [key: string]: string } {
    return {
      ecsQuota: 'EcsQuota',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ecsQuota: { 'type': 'array', 'itemType': ListAccountEcsQuotasResponseBodyEcsQuotasEcsQuota },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceSettingsResponseBodyCloudAssistantDeliverySettings extends $tea.Model {
  ossBucketName?: string;
  ossEnabled?: boolean;
  ossKeyPrefix?: string;
  slsEnabled?: boolean;
  slsLogstoreName?: string;
  slsProjectName?: string;
  static names(): { [key: string]: string } {
    return {
      ossBucketName: 'OssBucketName',
      ossEnabled: 'OssEnabled',
      ossKeyPrefix: 'OssKeyPrefix',
      slsEnabled: 'SlsEnabled',
      slsLogstoreName: 'SlsLogstoreName',
      slsProjectName: 'SlsProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ossBucketName: 'string',
      ossEnabled: 'boolean',
      ossKeyPrefix: 'string',
      slsEnabled: 'boolean',
      slsLogstoreName: 'string',
      slsProjectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostAttributeRequestNetworkAttributes extends $tea.Model {
  slbUdpTimeout?: number;
  udpTimeout?: number;
  static names(): { [key: string]: string } {
    return {
      slbUdpTimeout: 'SlbUdpTimeout',
      udpTimeout: 'UdpTimeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      slbUdpTimeout: 'number',
      udpTimeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyImageAdvancedAttributeRequestFlag extends $tea.Model {
  name?: string;
  value?: boolean;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance extends $tea.Model {
  currency?: string;
  fee?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      currency: 'Currency',
      fee: 'Fee',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currency: 'string',
      fee: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceChargeTypeResponseBodyFeeOfInstances extends $tea.Model {
  feeOfInstance?: ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance[];
  static names(): { [key: string]: string } {
    return {
      feeOfInstance: 'FeeOfInstance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      feeOfInstance: { 'type': 'array', 'itemType': ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow extends $tea.Model {
  endTime?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModelFailModels extends $tea.Model {
  failModel?: ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel[];
  static names(): { [key: string]: string } {
    return {
      failModel: 'FailModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failModel: { 'type': 'array', 'itemType': ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModel extends $tea.Model {
  failModels?: ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModelFailModels;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      failModels: 'FailModels',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failModels: ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModelFailModels,
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMigrationInstancesResponseBodyInstancesFailModels extends $tea.Model {
  instancesFailModel?: ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModel[];
  static names(): { [key: string]: string } {
    return {
      instancesFailModel: 'InstancesFailModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instancesFailModel: { 'type': 'array', 'itemType': ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyOrderAutoRebootTimeResponseBodyModifyOrderAutoRebootTimeInfo extends $tea.Model {
  autoRebootTime?: string;
  orderId?: number;
  static names(): { [key: string]: string } {
    return {
      autoRebootTime: 'AutoRebootTime',
      orderId: 'OrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRebootTime: 'string',
      orderId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPrivatePoolRequestPrivatePoolOptions extends $tea.Model {
  id?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyReservationDemandRequestPrivatePoolOptions extends $tea.Model {
  instanceAmount?: number;
  instanceType?: string;
  matchCriteria?: string;
  planId?: string;
  startTime?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceAmount: 'InstanceAmount',
      instanceType: 'InstanceType',
      matchCriteria: 'MatchCriteria',
      planId: 'PlanId',
      startTime: 'StartTime',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceAmount: 'number',
      instanceType: 'string',
      matchCriteria: 'string',
      planId: 'string',
      startTime: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyReservationDemandRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyReservedInstancesRequestConfiguration extends $tea.Model {
  instanceAmount?: number;
  instanceType?: string;
  reservedInstanceName?: string;
  scope?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceAmount: 'InstanceAmount',
      instanceType: 'InstanceType',
      reservedInstanceName: 'ReservedInstanceName',
      scope: 'Scope',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceAmount: 'number',
      instanceType: 'string',
      reservedInstanceName: 'string',
      scope: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyReservedInstancesRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyReservedInstancesResponseBodyReservedInstanceIdSets extends $tea.Model {
  reservedInstanceId?: string[];
  static names(): { [key: string]: string } {
    return {
      reservedInstanceId: 'ReservedInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reservedInstanceId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyResourceMetaRequestMeta extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'key',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWaitingOrderRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseReservedInstancesOfferingRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseReservedInstancesOfferingResponseBodyReservedInstanceIdSets extends $tea.Model {
  reservedInstanceId?: string[];
  static names(): { [key: string]: string } {
    return {
      reservedInstanceId: 'ReservedInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reservedInstanceId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseStorageCapacityUnitRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseStorageCapacityUnitResponseBodyStorageCapacityUnitIds extends $tea.Model {
  storageCapacityUnitId?: string[];
  static names(): { [key: string]: string } {
    return {
      storageCapacityUnitId: 'StorageCapacityUnitId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      storageCapacityUnitId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEniQosGroupByInstanceResponseBodyData extends $tea.Model {
  eniQosGroups?: string[];
  static names(): { [key: string]: string } {
    return {
      eniQosGroups: 'EniQosGroups',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eniQosGroups: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReAddMigrationTaskInPlanResponseBodyFailModelsFailModels extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReAddMigrationTaskInPlanResponseBodyFailModels extends $tea.Model {
  failModels?: ReAddMigrationTaskInPlanResponseBodyFailModelsFailModels[];
  static names(): { [key: string]: string } {
    return {
      failModels: 'FailModels',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failModels: { 'type': 'array', 'itemType': ReAddMigrationTaskInPlanResponseBodyFailModelsFailModels },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RenewDedicatedHostsResponseBodyDedicatedHostIdSets extends $tea.Model {
  dedicatedHostId?: string[];
  static names(): { [key: string]: string } {
    return {
      dedicatedHostId: 'DedicatedHostId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedHostId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunInstancesRequestHibernationOptions extends $tea.Model {
  configured?: boolean;
  static names(): { [key: string]: string } {
    return {
      configured: 'Configured',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configured: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunInstancesRequestPrivatePoolOptions extends $tea.Model {
  id?: string;
  matchCriteria?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      matchCriteria: 'MatchCriteria',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      matchCriteria: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunInstancesRequestSchedulerOptions extends $tea.Model {
  managedPrivateSpaceId?: string;
  static names(): { [key: string]: string } {
    return {
      managedPrivateSpaceId: 'ManagedPrivateSpaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      managedPrivateSpaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunInstancesRequestSecurityOptions extends $tea.Model {
  confidentialComputingMode?: string;
  trustedSystemMode?: string;
  static names(): { [key: string]: string } {
    return {
      confidentialComputingMode: 'ConfidentialComputingMode',
      trustedSystemMode: 'TrustedSystemMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      confidentialComputingMode: 'string',
      trustedSystemMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunInstancesRequestSystemDisk extends $tea.Model {
  autoSnapshotPolicyId?: string;
  category?: string;
  deleteWithInstance?: boolean;
  description?: string;
  diskName?: string;
  performanceLevel?: string;
  size?: string;
  burstingEnabled?: boolean;
  encryptAlgorithm?: string;
  encrypted?: boolean;
  KMSKeyId?: string;
  provisionedIops?: number;
  storageClusterId?: string;
  static names(): { [key: string]: string } {
    return {
      autoSnapshotPolicyId: 'AutoSnapshotPolicyId',
      category: 'Category',
      deleteWithInstance: 'DeleteWithInstance',
      description: 'Description',
      diskName: 'DiskName',
      performanceLevel: 'PerformanceLevel',
      size: 'Size',
      burstingEnabled: 'BurstingEnabled',
      encryptAlgorithm: 'EncryptAlgorithm',
      encrypted: 'Encrypted',
      KMSKeyId: 'KMSKeyId',
      provisionedIops: 'ProvisionedIops',
      storageClusterId: 'StorageClusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoSnapshotPolicyId: 'string',
      category: 'string',
      deleteWithInstance: 'boolean',
      description: 'string',
      diskName: 'string',
      performanceLevel: 'string',
      size: 'string',
      burstingEnabled: 'boolean',
      encryptAlgorithm: 'string',
      encrypted: 'boolean',
      KMSKeyId: 'string',
      provisionedIops: 'number',
      storageClusterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunInstancesRequestDataDisk extends $tea.Model {
  autoSnapshotPolicyId?: string;
  burstingEnabled?: boolean;
  category?: string;
  deleteWithInstance?: boolean;
  description?: string;
  device?: string;
  diskName?: string;
  encryptAlgorithm?: string;
  encrypted?: boolean;
  KMSKeyId?: string;
  performanceLevel?: string;
  provisionedIops?: number;
  size?: number;
  snapshotId?: string;
  storageClusterId?: string;
  static names(): { [key: string]: string } {
    return {
      autoSnapshotPolicyId: 'AutoSnapshotPolicyId',
      burstingEnabled: 'BurstingEnabled',
      category: 'Category',
      deleteWithInstance: 'DeleteWithInstance',
      description: 'Description',
      device: 'Device',
      diskName: 'DiskName',
      encryptAlgorithm: 'EncryptAlgorithm',
      encrypted: 'Encrypted',
      KMSKeyId: 'KMSKeyId',
      performanceLevel: 'PerformanceLevel',
      provisionedIops: 'ProvisionedIops',
      size: 'Size',
      snapshotId: 'SnapshotId',
      storageClusterId: 'StorageClusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoSnapshotPolicyId: 'string',
      burstingEnabled: 'boolean',
      category: 'string',
      deleteWithInstance: 'boolean',
      description: 'string',
      device: 'string',
      diskName: 'string',
      encryptAlgorithm: 'string',
      encrypted: 'boolean',
      KMSKeyId: 'string',
      performanceLevel: 'string',
      provisionedIops: 'number',
      size: 'number',
      snapshotId: 'string',
      storageClusterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunInstancesRequestImageOptions extends $tea.Model {
  loginAsNonRoot?: boolean;
  static names(): { [key: string]: string } {
    return {
      loginAsNonRoot: 'LoginAsNonRoot',
    };
  }

  static types(): { [key: string]: any } {
    return {
      loginAsNonRoot: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunInstancesRequestInstance extends $tea.Model {
  privateIpAddress?: string;
  static names(): { [key: string]: string } {
    return {
      privateIpAddress: 'PrivateIpAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      privateIpAddress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunInstancesRequestNetworkInterface extends $tea.Model {
  description?: string;
  instanceType?: string;
  ipv6Address?: string[];
  ipv6AddressCount?: number;
  networkInterfaceName?: string;
  networkInterfaceTrafficMode?: string;
  primaryIpAddress?: string;
  queuePairNumber?: number;
  securityGroupId?: string;
  securityGroupIds?: string[];
  vSwitchId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      instanceType: 'InstanceType',
      ipv6Address: 'Ipv6Address',
      ipv6AddressCount: 'Ipv6AddressCount',
      networkInterfaceName: 'NetworkInterfaceName',
      networkInterfaceTrafficMode: 'NetworkInterfaceTrafficMode',
      primaryIpAddress: 'PrimaryIpAddress',
      queuePairNumber: 'QueuePairNumber',
      securityGroupId: 'SecurityGroupId',
      securityGroupIds: 'SecurityGroupIds',
      vSwitchId: 'VSwitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      instanceType: 'string',
      ipv6Address: { 'type': 'array', 'itemType': 'string' },
      ipv6AddressCount: 'number',
      networkInterfaceName: 'string',
      networkInterfaceTrafficMode: 'string',
      primaryIpAddress: 'string',
      queuePairNumber: 'number',
      securityGroupId: 'string',
      securityGroupIds: { 'type': 'array', 'itemType': 'string' },
      vSwitchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunInstancesRequestSecurityGroupRule extends $tea.Model {
  ipProtocol?: string;
  nicType?: string;
  policy?: string;
  portRange?: string;
  priority?: string;
  static names(): { [key: string]: string } {
    return {
      ipProtocol: 'IpProtocol',
      nicType: 'NicType',
      policy: 'Policy',
      portRange: 'PortRange',
      priority: 'Priority',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipProtocol: 'string',
      nicType: 'string',
      policy: 'string',
      portRange: 'string',
      priority: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunInstancesRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunInstancesResponseBodyInstanceIdSets extends $tea.Model {
  instanceIdSet?: string[];
  static names(): { [key: string]: string } {
    return {
      instanceIdSet: 'InstanceIdSet',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceIdSet: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateServiceSettingsRequestCloudAssistantDeliverySettings extends $tea.Model {
  ossBucketName?: string;
  ossEnabled?: boolean;
  ossKeyPrefix?: string;
  slsEnabled?: boolean;
  slsLogstoreName?: string;
  slsProjectName?: string;
  static names(): { [key: string]: string } {
    return {
      ossBucketName: 'OssBucketName',
      ossEnabled: 'OssEnabled',
      ossKeyPrefix: 'OssKeyPrefix',
      slsEnabled: 'SlsEnabled',
      slsLogstoreName: 'SlsLogstoreName',
      slsProjectName: 'SlsProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ossBucketName: 'string',
      ossEnabled: 'boolean',
      ossKeyPrefix: 'string',
      slsEnabled: 'boolean',
      slsLogstoreName: 'string',
      slsProjectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "regional";
    this._endpointMap = {
      'cn-hangzhou': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-shanghai-finance-1': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-shenzhen-finance-1': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-north-2-gov-1': "ecs.aliyuncs.com",
      'ap-northeast-2-pop': "ecs.aliyuncs.com",
      'cn-beijing-finance-pop': "ecs.aliyuncs.com",
      'cn-beijing-gov-1': "ecs.aliyuncs.com",
      'cn-beijing-nu16-b01': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-edge-1': "ecs.cn-qingdao-nebula.aliyuncs.com",
      'cn-fujian': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-haidian-cm12-c01': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-hangzhou-bj-b01': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-hangzhou-finance': "ecs.aliyuncs.com",
      'cn-hangzhou-internal-prod-1': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-hangzhou-internal-test-1': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-hangzhou-internal-test-2': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-hangzhou-internal-test-3': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-hangzhou-test-306': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-hongkong-finance-pop': "ecs.aliyuncs.com",
      'cn-huhehaote-nebula-1': "ecs.cn-qingdao-nebula.aliyuncs.com",
      'cn-shanghai-et15-b01': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-shanghai-et2-b01': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-shanghai-inner': "ecs.aliyuncs.com",
      'cn-shanghai-internal-test-1': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-shenzhen-inner': "ecs.aliyuncs.com",
      'cn-shenzhen-st4-d01': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-shenzhen-su18-b01': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-wuhan': "ecs.aliyuncs.com",
      'cn-yushanfang': "ecs.aliyuncs.com",
      'cn-zhangbei': "ecs.aliyuncs.com",
      'cn-zhangbei-na61-b01': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-zhangjiakou-na62-a01': "ecs.cn-zhangjiakou.aliyuncs.com",
      'cn-zhengzhou-nebula-1': "ecs.cn-qingdao-nebula.aliyuncs.com",
      'eu-west-1-oxs': "ecs.cn-shenzhen-cloudstone.aliyuncs.com",
      'rus-west-1-pop': "ecs.aliyuncs.com",
    };
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("ecs", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  async addMigratableInstancesWithOptions(request: AddMigratableInstancesRequest, runtime: $Util.RuntimeOptions): Promise<AddMigratableInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.businessMigrationType)) {
      query["BusinessMigrationType"] = request.businessMigrationType;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.networkMigrationType)) {
      query["NetworkMigrationType"] = request.networkMigrationType;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddMigratableInstances",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddMigratableInstancesResponse>(await this.callApi(params, req, runtime), new AddMigratableInstancesResponse({}));
  }

  async addMigratableInstances(request: AddMigratableInstancesRequest): Promise<AddMigratableInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addMigratableInstancesWithOptions(request, runtime);
  }

  async allocateDedicatedHostsWithOptions(request: AllocateDedicatedHostsRequest, runtime: $Util.RuntimeOptions): Promise<AllocateDedicatedHostsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.actionOnMaintenance)) {
      query["ActionOnMaintenance"] = request.actionOnMaintenance;
    }

    if (!Util.isUnset(request.autoPlacement)) {
      query["AutoPlacement"] = request.autoPlacement;
    }

    if (!Util.isUnset(request.autoReleaseTime)) {
      query["AutoReleaseTime"] = request.autoReleaseTime;
    }

    if (!Util.isUnset(request.autoRenew)) {
      query["AutoRenew"] = request.autoRenew;
    }

    if (!Util.isUnset(request.autoRenewPeriod)) {
      query["AutoRenewPeriod"] = request.autoRenewPeriod;
    }

    if (!Util.isUnset(request.businessInfo)) {
      query["BusinessInfo"] = request.businessInfo;
    }

    if (!Util.isUnset(request.chargeType)) {
      query["ChargeType"] = request.chargeType;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.cpuOverCommitRatio)) {
      query["CpuOverCommitRatio"] = request.cpuOverCommitRatio;
    }

    if (!Util.isUnset(request.dedicatedHostClusterId)) {
      query["DedicatedHostClusterId"] = request.dedicatedHostClusterId;
    }

    if (!Util.isUnset(request.dedicatedHostName)) {
      query["DedicatedHostName"] = request.dedicatedHostName;
    }

    if (!Util.isUnset(request.dedicatedHostType)) {
      query["DedicatedHostType"] = request.dedicatedHostType;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.fromApp)) {
      query["FromApp"] = request.fromApp;
    }

    if (!Util.isUnset(request.minQuantity)) {
      query["MinQuantity"] = request.minQuantity;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.periodUnit)) {
      query["PeriodUnit"] = request.periodUnit;
    }

    if (!Util.isUnset(request.quantity)) {
      query["Quantity"] = request.quantity;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    if (!Util.isUnset($tea.toMap(request.networkAttributes))) {
      query["NetworkAttributes"] = request.networkAttributes;
    }

    if (!Util.isUnset($tea.toMap(request.schedulerOptions))) {
      query["SchedulerOptions"] = request.schedulerOptions;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AllocateDedicatedHosts",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AllocateDedicatedHostsResponse>(await this.callApi(params, req, runtime), new AllocateDedicatedHostsResponse({}));
  }

  async allocateDedicatedHosts(request: AllocateDedicatedHostsRequest): Promise<AllocateDedicatedHostsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.allocateDedicatedHostsWithOptions(request, runtime);
  }

  async cancelMigrationInstancesWithOptions(request: CancelMigrationInstancesRequest, runtime: $Util.RuntimeOptions): Promise<CancelMigrationInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.networkMigrationType)) {
      query["NetworkMigrationType"] = request.networkMigrationType;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CancelMigrationInstances",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CancelMigrationInstancesResponse>(await this.callApi(params, req, runtime), new CancelMigrationInstancesResponse({}));
  }

  async cancelMigrationInstances(request: CancelMigrationInstancesRequest): Promise<CancelMigrationInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelMigrationInstancesWithOptions(request, runtime);
  }

  async cancelMigrationPlanWithOptions(request: CancelMigrationPlanRequest, runtime: $Util.RuntimeOptions): Promise<CancelMigrationPlanResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.migrationPlanId)) {
      query["MigrationPlanId"] = request.migrationPlanId;
    }

    if (!Util.isUnset(request.onlyCancelPlan)) {
      query["OnlyCancelPlan"] = request.onlyCancelPlan;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CancelMigrationPlan",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CancelMigrationPlanResponse>(await this.callApi(params, req, runtime), new CancelMigrationPlanResponse({}));
  }

  async cancelMigrationPlan(request: CancelMigrationPlanRequest): Promise<CancelMigrationPlanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelMigrationPlanWithOptions(request, runtime);
  }

  async configureSecurityGroupPermissionsWithOptions(request: ConfigureSecurityGroupPermissionsRequest, runtime: $Util.RuntimeOptions): Promise<ConfigureSecurityGroupPermissionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.authorizePermission)) {
      query["AuthorizePermission"] = request.authorizePermission;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.revokePermission)) {
      query["RevokePermission"] = request.revokePermission;
    }

    if (!Util.isUnset(request.securityGroupId)) {
      query["SecurityGroupId"] = request.securityGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ConfigureSecurityGroupPermissions",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ConfigureSecurityGroupPermissionsResponse>(await this.callApi(params, req, runtime), new ConfigureSecurityGroupPermissionsResponse({}));
  }

  async configureSecurityGroupPermissions(request: ConfigureSecurityGroupPermissionsRequest): Promise<ConfigureSecurityGroupPermissionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.configureSecurityGroupPermissionsWithOptions(request, runtime);
  }

  async confirmReservationDemandWithOptions(request: ConfirmReservationDemandRequest, runtime: $Util.RuntimeOptions): Promise<ConfirmReservationDemandResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.demandId)) {
      query["DemandId"] = request.demandId;
    }

    if (!Util.isUnset(request.demandId)) {
      query["DemandId"] = request.demandId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ConfirmReservationDemand",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ConfirmReservationDemandResponse>(await this.callApi(params, req, runtime), new ConfirmReservationDemandResponse({}));
  }

  async confirmReservationDemand(request: ConfirmReservationDemandRequest): Promise<ConfirmReservationDemandResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.confirmReservationDemandWithOptions(request, runtime);
  }

  async createCapacityReservationWithOptions(request: CreateCapacityReservationRequest, runtime: $Util.RuntimeOptions): Promise<CreateCapacityReservationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.capacityReservationName)) {
      query["CapacityReservationName"] = request.capacityReservationName;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.endDateType)) {
      query["EndDateType"] = request.endDateType;
    }

    if (!Util.isUnset(request.instanceCount)) {
      query["InstanceCount"] = request.instanceCount;
    }

    if (!Util.isUnset(request.instanceMatchCriteria)) {
      query["InstanceMatchCriteria"] = request.instanceMatchCriteria;
    }

    if (!Util.isUnset(request.instancePlatform)) {
      query["InstancePlatform"] = request.instancePlatform;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.networkType)) {
      query["NetworkType"] = request.networkType;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.timeSlot)) {
      query["TimeSlot"] = request.timeSlot;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateCapacityReservation",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateCapacityReservationResponse>(await this.callApi(params, req, runtime), new CreateCapacityReservationResponse({}));
  }

  async createCapacityReservation(request: CreateCapacityReservationRequest): Promise<CreateCapacityReservationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createCapacityReservationWithOptions(request, runtime);
  }

  async createDedicatedBlockStorageClusterWithOptions(request: CreateDedicatedBlockStorageClusterRequest, runtime: $Util.RuntimeOptions): Promise<CreateDedicatedBlockStorageClusterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.capacity)) {
      query["Capacity"] = request.capacity;
    }

    if (!Util.isUnset(request.category)) {
      query["Category"] = request.category;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.dedicatedBlockStorageClusterName)) {
      query["DedicatedBlockStorageClusterName"] = request.dedicatedBlockStorageClusterName;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.fromApp)) {
      query["FromApp"] = request.fromApp;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.periodUnit)) {
      query["PeriodUnit"] = request.periodUnit;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDedicatedBlockStorageCluster",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDedicatedBlockStorageClusterResponse>(await this.callApi(params, req, runtime), new CreateDedicatedBlockStorageClusterResponse({}));
  }

  async createDedicatedBlockStorageCluster(request: CreateDedicatedBlockStorageClusterRequest): Promise<CreateDedicatedBlockStorageClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDedicatedBlockStorageClusterWithOptions(request, runtime);
  }

  async createDedicatedHostClusterWithOptions(request: CreateDedicatedHostClusterRequest, runtime: $Util.RuntimeOptions): Promise<CreateDedicatedHostClusterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dedicatedHostClusterName)) {
      query["DedicatedHostClusterName"] = request.dedicatedHostClusterName;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    if (!Util.isUnset($tea.toMap(request.schedulerOptions))) {
      query["SchedulerOptions"] = request.schedulerOptions;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDedicatedHostCluster",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDedicatedHostClusterResponse>(await this.callApi(params, req, runtime), new CreateDedicatedHostClusterResponse({}));
  }

  async createDedicatedHostCluster(request: CreateDedicatedHostClusterRequest): Promise<CreateDedicatedHostClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDedicatedHostClusterWithOptions(request, runtime);
  }

  async createDefaultAutoSnapshotPolicyWithOptions(request: CreateDefaultAutoSnapshotPolicyRequest, runtime: $Util.RuntimeOptions): Promise<CreateDefaultAutoSnapshotPolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDefaultAutoSnapshotPolicy",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDefaultAutoSnapshotPolicyResponse>(await this.callApi(params, req, runtime), new CreateDefaultAutoSnapshotPolicyResponse({}));
  }

  async createDefaultAutoSnapshotPolicy(request: CreateDefaultAutoSnapshotPolicyRequest): Promise<CreateDefaultAutoSnapshotPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDefaultAutoSnapshotPolicyWithOptions(request, runtime);
  }

  async createDiagnoseWithOptions(request: CreateDiagnoseRequest, runtime: $Util.RuntimeOptions): Promise<CreateDiagnoseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.amount)) {
      query["Amount"] = request.amount;
    }

    if (!Util.isUnset(request.diagnoseAction)) {
      query["DiagnoseAction"] = request.diagnoseAction;
    }

    if (!Util.isUnset(request.diagnoseErrorCode)) {
      query["DiagnoseErrorCode"] = request.diagnoseErrorCode;
    }

    if (!Util.isUnset(request.diagnoseProduct)) {
      query["DiagnoseProduct"] = request.diagnoseProduct;
    }

    if (!Util.isUnset(request.diagnoseRequestId)) {
      query["DiagnoseRequestId"] = request.diagnoseRequestId;
    }

    if (!Util.isUnset(request.diagnoseRequestParams)) {
      query["DiagnoseRequestParams"] = request.diagnoseRequestParams;
    }

    if (!Util.isUnset(request.diagnoseResponse)) {
      query["DiagnoseResponse"] = request.diagnoseResponse;
    }

    if (!Util.isUnset(request.diskCategory)) {
      query["DiskCategory"] = request.diskCategory;
    }

    if (!Util.isUnset(request.expireTime)) {
      query["ExpireTime"] = request.expireTime;
    }

    if (!Util.isUnset(request.instanceChargeType)) {
      query["InstanceChargeType"] = request.instanceChargeType;
    }

    if (!Util.isUnset(request.instanceTypeName)) {
      query["InstanceTypeName"] = request.instanceTypeName;
    }

    if (!Util.isUnset(request.izNo)) {
      query["IzNo"] = request.izNo;
    }

    if (!Util.isUnset(request.mark)) {
      query["Mark"] = request.mark;
    }

    if (!Util.isUnset(request.networkType)) {
      query["NetworkType"] = request.networkType;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.periodUnit)) {
      query["PeriodUnit"] = request.periodUnit;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDiagnose",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDiagnoseResponse>(await this.callApi(params, req, runtime), new CreateDiagnoseResponse({}));
  }

  async createDiagnose(request: CreateDiagnoseRequest): Promise<CreateDiagnoseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDiagnoseWithOptions(request, runtime);
  }

  async createDiagnosisOperateRecordsWithOptions(request: CreateDiagnosisOperateRecordsRequest, runtime: $Util.RuntimeOptions): Promise<CreateDiagnosisOperateRecordsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.errorCode)) {
      query["ErrorCode"] = request.errorCode;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.newInstanceType)) {
      query["NewInstanceType"] = request.newInstanceType;
    }

    if (!Util.isUnset(request.newZoneId)) {
      query["NewZoneId"] = request.newZoneId;
    }

    if (!Util.isUnset(request.operateRecordType)) {
      query["OperateRecordType"] = request.operateRecordType;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.payType)) {
      query["PayType"] = request.payType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDiagnosisOperateRecords",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDiagnosisOperateRecordsResponse>(await this.callApi(params, req, runtime), new CreateDiagnosisOperateRecordsResponse({}));
  }

  async createDiagnosisOperateRecords(request: CreateDiagnosisOperateRecordsRequest): Promise<CreateDiagnosisOperateRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDiagnosisOperateRecordsWithOptions(request, runtime);
  }

  async createDiagnosticReportWithOptions(request: CreateDiagnosticReportRequest, runtime: $Util.RuntimeOptions): Promise<CreateDiagnosticReportResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.commandName)) {
      query["CommandName"] = request.commandName;
    }

    if (!Util.isUnset(request.commandType)) {
      query["CommandType"] = request.commandType;
    }

    if (!Util.isUnset(request.diagnosticCategory)) {
      query["DiagnosticCategory"] = request.diagnosticCategory;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pluginVersion)) {
      query["PluginVersion"] = request.pluginVersion;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.sourceSystem)) {
      query["SourceSystem"] = request.sourceSystem;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.sourceSystem)) {
      query["sourceSystem"] = request.sourceSystem;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDiagnosticReport",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDiagnosticReportResponse>(await this.callApi(params, req, runtime), new CreateDiagnosticReportResponse({}));
  }

  async createDiagnosticReport(request: CreateDiagnosticReportRequest): Promise<CreateDiagnosticReportResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDiagnosticReportWithOptions(request, runtime);
  }

  async createDisksWithOptions(request: CreateDisksRequest, runtime: $Util.RuntimeOptions): Promise<CreateDisksResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.amount)) {
      query["Amount"] = request.amount;
    }

    if (!Util.isUnset(request.autoSnapshotPolicyId)) {
      query["AutoSnapshotPolicyId"] = request.autoSnapshotPolicyId;
    }

    if (!Util.isUnset(request.burstingEnabled)) {
      query["BurstingEnabled"] = request.burstingEnabled;
    }

    if (!Util.isUnset(request.category)) {
      query["Category"] = request.category;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.diskName)) {
      query["DiskName"] = request.diskName;
    }

    if (!Util.isUnset(request.encryptAlgorithm)) {
      query["EncryptAlgorithm"] = request.encryptAlgorithm;
    }

    if (!Util.isUnset(request.encrypted)) {
      query["Encrypted"] = request.encrypted;
    }

    if (!Util.isUnset(request.KMSKeyId)) {
      query["KMSKeyId"] = request.KMSKeyId;
    }

    if (!Util.isUnset(request.multiAttach)) {
      query["MultiAttach"] = request.multiAttach;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.performanceLevel)) {
      query["PerformanceLevel"] = request.performanceLevel;
    }

    if (!Util.isUnset(request.provisionedIops)) {
      query["ProvisionedIops"] = request.provisionedIops;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.size)) {
      query["Size"] = request.size;
    }

    if (!Util.isUnset(request.snapshotId)) {
      query["SnapshotId"] = request.snapshotId;
    }

    if (!Util.isUnset(request.storageClusterId)) {
      query["StorageClusterId"] = request.storageClusterId;
    }

    if (!Util.isUnset(request.storageSetId)) {
      query["StorageSetId"] = request.storageSetId;
    }

    if (!Util.isUnset(request.storageSetPartitionNumber)) {
      query["StorageSetPartitionNumber"] = request.storageSetPartitionNumber;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDisks",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDisksResponse>(await this.callApi(params, req, runtime), new CreateDisksResponse({}));
  }

  async createDisks(request: CreateDisksRequest): Promise<CreateDisksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDisksWithOptions(request, runtime);
  }

  async createElasticityAssuranceWithOptions(request: CreateElasticityAssuranceRequest, runtime: $Util.RuntimeOptions): Promise<CreateElasticityAssuranceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.assuranceTimes)) {
      query["AssuranceTimes"] = request.assuranceTimes;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.instanceAmount)) {
      query["InstanceAmount"] = request.instanceAmount;
    }

    if (!Util.isUnset(request.instanceCpuCoreCount)) {
      query["InstanceCpuCoreCount"] = request.instanceCpuCoreCount;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.periodUnit)) {
      query["PeriodUnit"] = request.periodUnit;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    if (!Util.isUnset($tea.toMap(request.privatePoolOptions))) {
      query["PrivatePoolOptions"] = request.privatePoolOptions;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateElasticityAssurance",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateElasticityAssuranceResponse>(await this.callApi(params, req, runtime), new CreateElasticityAssuranceResponse({}));
  }

  async createElasticityAssurance(request: CreateElasticityAssuranceRequest): Promise<CreateElasticityAssuranceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createElasticityAssuranceWithOptions(request, runtime);
  }

  async createEniQosGroupWithOptions(request: CreateEniQosGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateEniQosGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.qosGroupName)) {
      query["QosGroupName"] = request.qosGroupName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.rx)) {
      query["Rx"] = request.rx;
    }

    if (!Util.isUnset(request.rxPps)) {
      query["RxPps"] = request.rxPps;
    }

    if (!Util.isUnset(request.tx)) {
      query["Tx"] = request.tx;
    }

    if (!Util.isUnset(request.txPps)) {
      query["TxPps"] = request.txPps;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateEniQosGroup",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEniQosGroupResponse>(await this.callApi(params, req, runtime), new CreateEniQosGroupResponse({}));
  }

  async createEniQosGroup(request: CreateEniQosGroupRequest): Promise<CreateEniQosGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEniQosGroupWithOptions(request, runtime);
  }

  async createFunctionFeedbackWithOptions(request: CreateFunctionFeedbackRequest, runtime: $Util.RuntimeOptions): Promise<CreateFunctionFeedbackResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.category)) {
      query["Category"] = request.category;
    }

    if (!Util.isUnset(request.feedback)) {
      query["Feedback"] = request.feedback;
    }

    if (!Util.isUnset(request.functionName)) {
      query["FunctionName"] = request.functionName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.suggestion)) {
      query["Suggestion"] = request.suggestion;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateFunctionFeedback",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateFunctionFeedbackResponse>(await this.callApi(params, req, runtime), new CreateFunctionFeedbackResponse({}));
  }

  async createFunctionFeedback(request: CreateFunctionFeedbackRequest): Promise<CreateFunctionFeedbackResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createFunctionFeedbackWithOptions(request, runtime);
  }

  async createImageCacheWithOptions(request: CreateImageCacheRequest, runtime: $Util.RuntimeOptions): Promise<CreateImageCacheResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.imageId)) {
      query["ImageId"] = request.imageId;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateImageCache",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateImageCacheResponse>(await this.callApi(params, req, runtime), new CreateImageCacheResponse({}));
  }

  async createImageCache(request: CreateImageCacheRequest): Promise<CreateImageCacheResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createImageCacheWithOptions(request, runtime);
  }

  async createIssueCategoryReportRelationWithOptions(request: CreateIssueCategoryReportRelationRequest, runtime: $Util.RuntimeOptions): Promise<CreateIssueCategoryReportRelationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.relationModelList)) {
      query["RelationModelList"] = request.relationModelList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateIssueCategoryReportRelation",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateIssueCategoryReportRelationResponse>(await this.callApi(params, req, runtime), new CreateIssueCategoryReportRelationResponse({}));
  }

  async createIssueCategoryReportRelation(request: CreateIssueCategoryReportRelationRequest): Promise<CreateIssueCategoryReportRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createIssueCategoryReportRelationWithOptions(request, runtime);
  }

  async createMigrationPlanWithOptions(request: CreateMigrationPlanRequest, runtime: $Util.RuntimeOptions): Promise<CreateMigrationPlanResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.customMigrationTimes)) {
      query["CustomMigrationTimes"] = request.customMigrationTimes;
    }

    if (!Util.isUnset(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!Util.isUnset(request.enableAutoCreateVSwitch)) {
      query["EnableAutoCreateVSwitch"] = request.enableAutoCreateVSwitch;
    }

    if (!Util.isUnset(request.ensureNetworkConnectivity)) {
      query["EnsureNetworkConnectivity"] = request.ensureNetworkConnectivity;
    }

    if (!Util.isUnset(request.globalMigrationTime)) {
      query["GlobalMigrationTime"] = request.globalMigrationTime;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.remainPrivateIp)) {
      query["RemainPrivateIp"] = request.remainPrivateIp;
    }

    if (!Util.isUnset(request.remainPublicMacAsPriority)) {
      query["RemainPublicMacAsPriority"] = request.remainPublicMacAsPriority;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.targetSecurityGroupIds)) {
      query["TargetSecurityGroupIds"] = request.targetSecurityGroupIds;
    }

    if (!Util.isUnset(request.targetVSwitchId)) {
      query["TargetVSwitchId"] = request.targetVSwitchId;
    }

    if (!Util.isUnset(request.targetVpcId)) {
      query["TargetVpcId"] = request.targetVpcId;
    }

    if (!Util.isUnset(request.targetZoneId)) {
      query["TargetZoneId"] = request.targetZoneId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateMigrationPlan",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateMigrationPlanResponse>(await this.callApi(params, req, runtime), new CreateMigrationPlanResponse({}));
  }

  async createMigrationPlan(request: CreateMigrationPlanRequest): Promise<CreateMigrationPlanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createMigrationPlanWithOptions(request, runtime);
  }

  async createNetworkInsightsPathWithOptions(request: CreateNetworkInsightsPathRequest, runtime: $Util.RuntimeOptions): Promise<CreateNetworkInsightsPathResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.destination)) {
      query["Destination"] = request.destination;
    }

    if (!Util.isUnset(request.destinationPort)) {
      query["DestinationPort"] = request.destinationPort;
    }

    if (!Util.isUnset(request.destinationType)) {
      query["DestinationType"] = request.destinationType;
    }

    if (!Util.isUnset(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!Util.isUnset(request.needDiagnoseGuest)) {
      query["NeedDiagnoseGuest"] = request.needDiagnoseGuest;
    }

    if (!Util.isUnset(request.networkInsightsPathName)) {
      query["NetworkInsightsPathName"] = request.networkInsightsPathName;
    }

    if (!Util.isUnset(request.protocol)) {
      query["Protocol"] = request.protocol;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.sourceType)) {
      query["SourceType"] = request.sourceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateNetworkInsightsPath",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateNetworkInsightsPathResponse>(await this.callApi(params, req, runtime), new CreateNetworkInsightsPathResponse({}));
  }

  async createNetworkInsightsPath(request: CreateNetworkInsightsPathRequest): Promise<CreateNetworkInsightsPathResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createNetworkInsightsPathWithOptions(request, runtime);
  }

  async createOrderWithOptions(request: CreateOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateOrderResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.affinity)) {
      query["Affinity"] = request.affinity;
    }

    if (!Util.isUnset(request.asyncPattern)) {
      query["AsyncPattern"] = request.asyncPattern;
    }

    if (!Util.isUnset(request.businessInfo)) {
      query["BusinessInfo"] = request.businessInfo;
    }

    if (!Util.isUnset(request.chargeType)) {
      query["ChargeType"] = request.chargeType;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.commodity)) {
      query["Commodity"] = request.commodity;
    }

    if (!Util.isUnset(request.dedicatedHostClusterId)) {
      query["DedicatedHostClusterId"] = request.dedicatedHostClusterId;
    }

    if (!Util.isUnset(request.dedicatedHostId)) {
      query["DedicatedHostId"] = request.dedicatedHostId;
    }

    if (!Util.isUnset(request.fromApp)) {
      query["FromApp"] = request.fromApp;
    }

    if (!Util.isUnset(request.orderType)) {
      query["OrderType"] = request.orderType;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.tenancy)) {
      query["Tenancy"] = request.tenancy;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateOrder",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOrderResponse>(await this.callApi(params, req, runtime), new CreateOrderResponse({}));
  }

  async createOrder(request: CreateOrderRequest): Promise<CreateOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOrderWithOptions(request, runtime);
  }

  async createReservationDemandWithOptions(request: CreateReservationDemandRequest, runtime: $Util.RuntimeOptions): Promise<CreateReservationDemandResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.confirmType)) {
      query["ConfirmType"] = request.confirmType;
    }

    if (!Util.isUnset(request.couponAuto)) {
      query["CouponAuto"] = request.couponAuto;
    }

    if (!Util.isUnset(request.couponType)) {
      query["CouponType"] = request.couponType;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceAmount)) {
      query["InstanceAmount"] = request.instanceAmount;
    }

    if (!Util.isUnset(request.instanceChargeType)) {
      query["InstanceChargeType"] = request.instanceChargeType;
    }

    if (!Util.isUnset(request.instanceCpuCoreCount)) {
      query["InstanceCpuCoreCount"] = request.instanceCpuCoreCount;
    }

    if (!Util.isUnset(request.instanceTypeFamily)) {
      query["InstanceTypeFamily"] = request.instanceTypeFamily;
    }

    if (!Util.isUnset(request.instanceTypes)) {
      query["InstanceTypes"] = request.instanceTypes;
    }

    if (!Util.isUnset(request.matchCriteria)) {
      query["MatchCriteria"] = request.matchCriteria;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.periodUnit)) {
      query["PeriodUnit"] = request.periodUnit;
    }

    if (!Util.isUnset(request.phoneNumber)) {
      query["PhoneNumber"] = request.phoneNumber;
    }

    if (!Util.isUnset(request.platform)) {
      query["Platform"] = request.platform;
    }

    if (!Util.isUnset(request.privatePoolOptions)) {
      query["PrivatePoolOptions"] = request.privatePoolOptions;
    }

    if (!Util.isUnset(request.productType)) {
      query["ProductType"] = request.productType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.reservedInstanceDescription)) {
      query["ReservedInstanceDescription"] = request.reservedInstanceDescription;
    }

    if (!Util.isUnset(request.reservedInstanceName)) {
      query["ReservedInstanceName"] = request.reservedInstanceName;
    }

    if (!Util.isUnset(request.reservedInstanceOfferingType)) {
      query["ReservedInstanceOfferingType"] = request.reservedInstanceOfferingType;
    }

    if (!Util.isUnset(request.reservedInstanceScope)) {
      query["ReservedInstanceScope"] = request.reservedInstanceScope;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.resourceSupplyType)) {
      query["ResourceSupplyType"] = request.resourceSupplyType;
    }

    if (!Util.isUnset(request.savingPlanDescription)) {
      query["SavingPlanDescription"] = request.savingPlanDescription;
    }

    if (!Util.isUnset(request.savingPlanHourFee)) {
      query["SavingPlanHourFee"] = request.savingPlanHourFee;
    }

    if (!Util.isUnset(request.savingPlanId)) {
      query["SavingPlanId"] = request.savingPlanId;
    }

    if (!Util.isUnset(request.savingPlanInstanceTypeFamilyGroup)) {
      query["SavingPlanInstanceTypeFamilyGroup"] = request.savingPlanInstanceTypeFamilyGroup;
    }

    if (!Util.isUnset(request.savingPlanName)) {
      query["SavingPlanName"] = request.savingPlanName;
    }

    if (!Util.isUnset(request.savingPlanPayMode)) {
      query["SavingPlanPayMode"] = request.savingPlanPayMode;
    }

    if (!Util.isUnset(request.savingPlanSavingType)) {
      query["SavingPlanSavingType"] = request.savingPlanSavingType;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.zoneIds)) {
      query["ZoneIds"] = request.zoneIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateReservationDemand",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateReservationDemandResponse>(await this.callApi(params, req, runtime), new CreateReservationDemandResponse({}));
  }

  async createReservationDemand(request: CreateReservationDemandRequest): Promise<CreateReservationDemandResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createReservationDemandWithOptions(request, runtime);
  }

  async createStorageSetWithOptions(request: CreateStorageSetRequest, runtime: $Util.RuntimeOptions): Promise<CreateStorageSetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.maxPartitionNumber)) {
      query["MaxPartitionNumber"] = request.maxPartitionNumber;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.storageSetName)) {
      query["StorageSetName"] = request.storageSetName;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateStorageSet",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateStorageSetResponse>(await this.callApi(params, req, runtime), new CreateStorageSetResponse({}));
  }

  async createStorageSet(request: CreateStorageSetRequest): Promise<CreateStorageSetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createStorageSetWithOptions(request, runtime);
  }

  async createUserQuotaApplicationWithOptions(request: CreateUserQuotaApplicationRequest, runtime: $Util.RuntimeOptions): Promise<CreateUserQuotaApplicationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.chargeType)) {
      query["ChargeType"] = request.chargeType;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.quotaType)) {
      query["QuotaType"] = request.quotaType;
    }

    if (!Util.isUnset(request.quotaValue)) {
      query["QuotaValue"] = request.quotaValue;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateUserQuotaApplication",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateUserQuotaApplicationResponse>(await this.callApi(params, req, runtime), new CreateUserQuotaApplicationResponse({}));
  }

  async createUserQuotaApplication(request: CreateUserQuotaApplicationRequest): Promise<CreateUserQuotaApplicationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createUserQuotaApplicationWithOptions(request, runtime);
  }

  async createVolumesWithOptions(request: CreateVolumesRequest, runtime: $Util.RuntimeOptions): Promise<CreateVolumesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.amount)) {
      query["Amount"] = request.amount;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.KMSKeyId)) {
      query["KMSKeyId"] = request.KMSKeyId;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.size)) {
      query["Size"] = request.size;
    }

    if (!Util.isUnset(request.snapshotId)) {
      query["SnapshotId"] = request.snapshotId;
    }

    if (!Util.isUnset(request.storageSetId)) {
      query["StorageSetId"] = request.storageSetId;
    }

    if (!Util.isUnset(request.storageSetPartitionNumber)) {
      query["StorageSetPartitionNumber"] = request.storageSetPartitionNumber;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.volumeCategory)) {
      query["VolumeCategory"] = request.volumeCategory;
    }

    if (!Util.isUnset(request.volumeEncrypted)) {
      query["VolumeEncrypted"] = request.volumeEncrypted;
    }

    if (!Util.isUnset(request.volumeName)) {
      query["VolumeName"] = request.volumeName;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateVolumes",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateVolumesResponse>(await this.callApi(params, req, runtime), new CreateVolumesResponse({}));
  }

  async createVolumes(request: CreateVolumesRequest): Promise<CreateVolumesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createVolumesWithOptions(request, runtime);
  }

  async createWaitingOrderWithOptions(request: CreateWaitingOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateWaitingOrderResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.affinity)) {
      query["Affinity"] = request.affinity;
    }

    if (!Util.isUnset(request.arn)) {
      query["Arn"] = request.arn;
    }

    if (!Util.isUnset(request.autoReleaseTime)) {
      query["AutoReleaseTime"] = request.autoReleaseTime;
    }

    if (!Util.isUnset(request.autoRenew)) {
      query["AutoRenew"] = request.autoRenew;
    }

    if (!Util.isUnset(request.autoRenewPeriod)) {
      query["AutoRenewPeriod"] = request.autoRenewPeriod;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.creditSpecification)) {
      query["CreditSpecification"] = request.creditSpecification;
    }

    if (!Util.isUnset(request.dataDisk)) {
      query["DataDisk"] = request.dataDisk;
    }

    if (!Util.isUnset(request.dedicatedHostId)) {
      query["DedicatedHostId"] = request.dedicatedHostId;
    }

    if (!Util.isUnset(request.deletionProtection)) {
      query["DeletionProtection"] = request.deletionProtection;
    }

    if (!Util.isUnset(request.deploymentSetGroupNo)) {
      query["DeploymentSetGroupNo"] = request.deploymentSetGroupNo;
    }

    if (!Util.isUnset(request.deploymentSetId)) {
      query["DeploymentSetId"] = request.deploymentSetId;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!Util.isUnset(request.expiredTime)) {
      query["ExpiredTime"] = request.expiredTime;
    }

    if (!Util.isUnset(request.hostName)) {
      query["HostName"] = request.hostName;
    }

    if (!Util.isUnset(request.hostNames)) {
      query["HostNames"] = request.hostNames;
    }

    if (!Util.isUnset(request.hpcClusterId)) {
      query["HpcClusterId"] = request.hpcClusterId;
    }

    if (!Util.isUnset(request.httpEndpoint)) {
      query["HttpEndpoint"] = request.httpEndpoint;
    }

    if (!Util.isUnset(request.httpPutResponseHopLimit)) {
      query["HttpPutResponseHopLimit"] = request.httpPutResponseHopLimit;
    }

    if (!Util.isUnset(request.httpTokens)) {
      query["HttpTokens"] = request.httpTokens;
    }

    if (!Util.isUnset(request.imageFamily)) {
      query["ImageFamily"] = request.imageFamily;
    }

    if (!Util.isUnset(request.imageId)) {
      query["ImageId"] = request.imageId;
    }

    if (!Util.isUnset(request.instanceChargeType)) {
      query["InstanceChargeType"] = request.instanceChargeType;
    }

    if (!Util.isUnset(request.instanceName)) {
      query["InstanceName"] = request.instanceName;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.internetChargeType)) {
      query["InternetChargeType"] = request.internetChargeType;
    }

    if (!Util.isUnset(request.internetMaxBandwidthIn)) {
      query["InternetMaxBandwidthIn"] = request.internetMaxBandwidthIn;
    }

    if (!Util.isUnset(request.internetMaxBandwidthOut)) {
      query["InternetMaxBandwidthOut"] = request.internetMaxBandwidthOut;
    }

    if (!Util.isUnset(request.ioOptimized)) {
      query["IoOptimized"] = request.ioOptimized;
    }

    if (!Util.isUnset(request.ipv6Address)) {
      query["Ipv6Address"] = request.ipv6Address;
    }

    if (!Util.isUnset(request.ipv6AddressCount)) {
      query["Ipv6AddressCount"] = request.ipv6AddressCount;
    }

    if (!Util.isUnset(request.isp)) {
      query["Isp"] = request.isp;
    }

    if (!Util.isUnset(request.keyPairName)) {
      query["KeyPairName"] = request.keyPairName;
    }

    if (!Util.isUnset(request.launchTemplateId)) {
      query["LaunchTemplateId"] = request.launchTemplateId;
    }

    if (!Util.isUnset(request.launchTemplateName)) {
      query["LaunchTemplateName"] = request.launchTemplateName;
    }

    if (!Util.isUnset(request.launchTemplateVersion)) {
      query["LaunchTemplateVersion"] = request.launchTemplateVersion;
    }

    if (!Util.isUnset(request.maxAmount)) {
      query["MaxAmount"] = request.maxAmount;
    }

    if (!Util.isUnset(request.minAmount)) {
      query["MinAmount"] = request.minAmount;
    }

    if (!Util.isUnset(request.networkInterface)) {
      query["NetworkInterface"] = request.networkInterface;
    }

    if (!Util.isUnset(request.networkInterfaceQueueNumber)) {
      query["NetworkInterfaceQueueNumber"] = request.networkInterfaceQueueNumber;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.password)) {
      query["Password"] = request.password;
    }

    if (!Util.isUnset(request.passwordInherit)) {
      query["PasswordInherit"] = request.passwordInherit;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.periodUnit)) {
      query["PeriodUnit"] = request.periodUnit;
    }

    if (!Util.isUnset(request.privateIpAddress)) {
      query["PrivateIpAddress"] = request.privateIpAddress;
    }

    if (!Util.isUnset(request.ramRoleName)) {
      query["RamRoleName"] = request.ramRoleName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.securityEnhancementStrategy)) {
      query["SecurityEnhancementStrategy"] = request.securityEnhancementStrategy;
    }

    if (!Util.isUnset(request.securityGroupId)) {
      query["SecurityGroupId"] = request.securityGroupId;
    }

    if (!Util.isUnset(request.securityGroupIds)) {
      query["SecurityGroupIds"] = request.securityGroupIds;
    }

    if (!Util.isUnset(request.spotDuration)) {
      query["SpotDuration"] = request.spotDuration;
    }

    if (!Util.isUnset(request.spotInterruptionBehavior)) {
      query["SpotInterruptionBehavior"] = request.spotInterruptionBehavior;
    }

    if (!Util.isUnset(request.spotPriceLimit)) {
      query["SpotPriceLimit"] = request.spotPriceLimit;
    }

    if (!Util.isUnset(request.spotStrategy)) {
      query["SpotStrategy"] = request.spotStrategy;
    }

    if (!Util.isUnset(request.storageSetId)) {
      query["StorageSetId"] = request.storageSetId;
    }

    if (!Util.isUnset(request.storageSetPartitionNumber)) {
      query["StorageSetPartitionNumber"] = request.storageSetPartitionNumber;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.tenancy)) {
      query["Tenancy"] = request.tenancy;
    }

    if (!Util.isUnset(request.uniqueSuffix)) {
      query["UniqueSuffix"] = request.uniqueSuffix;
    }

    if (!Util.isUnset(request.userData)) {
      query["UserData"] = request.userData;
    }

    if (!Util.isUnset(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    if (!Util.isUnset($tea.toMap(request.cpuOptions))) {
      query["CpuOptions"] = request.cpuOptions;
    }

    if (!Util.isUnset($tea.toMap(request.hibernationOptions))) {
      query["HibernationOptions"] = request.hibernationOptions;
    }

    if (!Util.isUnset($tea.toMap(request.privatePoolOptions))) {
      query["PrivatePoolOptions"] = request.privatePoolOptions;
    }

    if (!Util.isUnset($tea.toMap(request.schedulerOptions))) {
      query["SchedulerOptions"] = request.schedulerOptions;
    }

    if (!Util.isUnset($tea.toMap(request.securityOptions))) {
      query["SecurityOptions"] = request.securityOptions;
    }

    if (!Util.isUnset($tea.toMap(request.systemDisk))) {
      query["SystemDisk"] = request.systemDisk;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateWaitingOrder",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateWaitingOrderResponse>(await this.callApi(params, req, runtime), new CreateWaitingOrderResponse({}));
  }

  async createWaitingOrder(request: CreateWaitingOrderRequest): Promise<CreateWaitingOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createWaitingOrderWithOptions(request, runtime);
  }

  async deleteDedicatedHostClusterWithOptions(request: DeleteDedicatedHostClusterRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDedicatedHostClusterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dedicatedHostClusterId)) {
      query["DedicatedHostClusterId"] = request.dedicatedHostClusterId;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDedicatedHostCluster",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDedicatedHostClusterResponse>(await this.callApi(params, req, runtime), new DeleteDedicatedHostClusterResponse({}));
  }

  async deleteDedicatedHostCluster(request: DeleteDedicatedHostClusterRequest): Promise<DeleteDedicatedHostClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDedicatedHostClusterWithOptions(request, runtime);
  }

  async deleteEniQosGroupWithOptions(request: DeleteEniQosGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEniQosGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.qosGroupName)) {
      query["QosGroupName"] = request.qosGroupName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEniQosGroup",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteEniQosGroupResponse>(await this.callApi(params, req, runtime), new DeleteEniQosGroupResponse({}));
  }

  async deleteEniQosGroup(request: DeleteEniQosGroupRequest): Promise<DeleteEniQosGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEniQosGroupWithOptions(request, runtime);
  }

  async deleteImageCacheWithOptions(request: DeleteImageCacheRequest, runtime: $Util.RuntimeOptions): Promise<DeleteImageCacheResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.imageId)) {
      query["ImageId"] = request.imageId;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteImageCache",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteImageCacheResponse>(await this.callApi(params, req, runtime), new DeleteImageCacheResponse({}));
  }

  async deleteImageCache(request: DeleteImageCacheRequest): Promise<DeleteImageCacheResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteImageCacheWithOptions(request, runtime);
  }

  async deleteMigratableInstancesWithOptions(request: DeleteMigratableInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMigratableInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMigratableInstances",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMigratableInstancesResponse>(await this.callApi(params, req, runtime), new DeleteMigratableInstancesResponse({}));
  }

  async deleteMigratableInstances(request: DeleteMigratableInstancesRequest): Promise<DeleteMigratableInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMigratableInstancesWithOptions(request, runtime);
  }

  async deleteNetworkInsightsAnalysisWithOptions(request: DeleteNetworkInsightsAnalysisRequest, runtime: $Util.RuntimeOptions): Promise<DeleteNetworkInsightsAnalysisResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!Util.isUnset(request.networkInsightsAnalysisId)) {
      query["NetworkInsightsAnalysisId"] = request.networkInsightsAnalysisId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteNetworkInsightsAnalysis",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteNetworkInsightsAnalysisResponse>(await this.callApi(params, req, runtime), new DeleteNetworkInsightsAnalysisResponse({}));
  }

  async deleteNetworkInsightsAnalysis(request: DeleteNetworkInsightsAnalysisRequest): Promise<DeleteNetworkInsightsAnalysisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteNetworkInsightsAnalysisWithOptions(request, runtime);
  }

  async deleteNetworkInsightsPathWithOptions(request: DeleteNetworkInsightsPathRequest, runtime: $Util.RuntimeOptions): Promise<DeleteNetworkInsightsPathResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!Util.isUnset(request.networkInsightsPathId)) {
      query["NetworkInsightsPathId"] = request.networkInsightsPathId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteNetworkInsightsPath",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteNetworkInsightsPathResponse>(await this.callApi(params, req, runtime), new DeleteNetworkInsightsPathResponse({}));
  }

  async deleteNetworkInsightsPath(request: DeleteNetworkInsightsPathRequest): Promise<DeleteNetworkInsightsPathResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteNetworkInsightsPathWithOptions(request, runtime);
  }

  async deleteReservationDemandWithOptions(request: DeleteReservationDemandRequest, runtime: $Util.RuntimeOptions): Promise<DeleteReservationDemandResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.demandId)) {
      query["DemandId"] = request.demandId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteReservationDemand",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteReservationDemandResponse>(await this.callApi(params, req, runtime), new DeleteReservationDemandResponse({}));
  }

  async deleteReservationDemand(request: DeleteReservationDemandRequest): Promise<DeleteReservationDemandResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteReservationDemandWithOptions(request, runtime);
  }

  async deleteStorageSetWithOptions(request: DeleteStorageSetRequest, runtime: $Util.RuntimeOptions): Promise<DeleteStorageSetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.storageSetId)) {
      query["StorageSetId"] = request.storageSetId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteStorageSet",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteStorageSetResponse>(await this.callApi(params, req, runtime), new DeleteStorageSetResponse({}));
  }

  async deleteStorageSet(request: DeleteStorageSetRequest): Promise<DeleteStorageSetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteStorageSetWithOptions(request, runtime);
  }

  async deleteUserQuotaApplicationWithOptions(request: DeleteUserQuotaApplicationRequest, runtime: $Util.RuntimeOptions): Promise<DeleteUserQuotaApplicationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applicationId)) {
      query["ApplicationId"] = request.applicationId;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteUserQuotaApplication",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteUserQuotaApplicationResponse>(await this.callApi(params, req, runtime), new DeleteUserQuotaApplicationResponse({}));
  }

  async deleteUserQuotaApplication(request: DeleteUserQuotaApplicationRequest): Promise<DeleteUserQuotaApplicationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteUserQuotaApplicationWithOptions(request, runtime);
  }

  async deleteWaitingOrdersWithOptions(request: DeleteWaitingOrdersRequest, runtime: $Util.RuntimeOptions): Promise<DeleteWaitingOrdersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.waitingOrderId)) {
      query["WaitingOrderId"] = request.waitingOrderId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteWaitingOrders",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteWaitingOrdersResponse>(await this.callApi(params, req, runtime), new DeleteWaitingOrdersResponse({}));
  }

  async deleteWaitingOrders(request: DeleteWaitingOrdersRequest): Promise<DeleteWaitingOrdersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteWaitingOrdersWithOptions(request, runtime);
  }

  async describeAccountAttributesWithOptions(request: DescribeAccountAttributesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAccountAttributesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.attributeName)) {
      query["AttributeName"] = request.attributeName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAccountAttributes",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAccountAttributesResponse>(await this.callApi(params, req, runtime), new DescribeAccountAttributesResponse({}));
  }

  async describeAccountAttributes(request: DescribeAccountAttributesRequest): Promise<DescribeAccountAttributesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAccountAttributesWithOptions(request, runtime);
  }

  async describeAccountLimitsWithOptions(request: DescribeAccountLimitsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAccountLimitsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.filter)) {
      query["Filter"] = request.filter;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAccountLimits",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAccountLimitsResponse>(await this.callApi(params, req, runtime), new DescribeAccountLimitsResponse({}));
  }

  async describeAccountLimits(request: DescribeAccountLimitsRequest): Promise<DescribeAccountLimitsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAccountLimitsWithOptions(request, runtime);
  }

  async describeAccountQuotaAttributesWithOptions(request: DescribeAccountQuotaAttributesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAccountQuotaAttributesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAccountQuotaAttributes",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAccountQuotaAttributesResponse>(await this.callApi(params, req, runtime), new DescribeAccountQuotaAttributesResponse({}));
  }

  async describeAccountQuotaAttributes(request: DescribeAccountQuotaAttributesRequest): Promise<DescribeAccountQuotaAttributesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAccountQuotaAttributesWithOptions(request, runtime);
  }

  async describeAutoProvisioningGroupCapacitiesWithOptions(request: DescribeAutoProvisioningGroupCapacitiesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAutoProvisioningGroupCapacitiesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.autoProvisioningGroupId)) {
      query["AutoProvisioningGroupId"] = request.autoProvisioningGroupId;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAutoProvisioningGroupCapacities",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAutoProvisioningGroupCapacitiesResponse>(await this.callApi(params, req, runtime), new DescribeAutoProvisioningGroupCapacitiesResponse({}));
  }

  async describeAutoProvisioningGroupCapacities(request: DescribeAutoProvisioningGroupCapacitiesRequest): Promise<DescribeAutoProvisioningGroupCapacitiesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAutoProvisioningGroupCapacitiesWithOptions(request, runtime);
  }

  async describeBandwidthPriceWithOptions(request: DescribeBandwidthPriceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBandwidthPriceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.priceUnit)) {
      query["PriceUnit"] = request.priceUnit;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.verbose)) {
      query["Verbose"] = request.verbose;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBandwidthPrice",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBandwidthPriceResponse>(await this.callApi(params, req, runtime), new DescribeBandwidthPriceResponse({}));
  }

  async describeBandwidthPrice(request: DescribeBandwidthPriceRequest): Promise<DescribeBandwidthPriceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBandwidthPriceWithOptions(request, runtime);
  }

  async describeCapacityReservationsWithOptions(request: DescribeCapacityReservationsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCapacityReservationsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.capacityReservationIds)) {
      query["CapacityReservationIds"] = request.capacityReservationIds;
    }

    if (!Util.isUnset(request.capacityReservationName)) {
      query["CapacityReservationName"] = request.capacityReservationName;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCapacityReservations",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCapacityReservationsResponse>(await this.callApi(params, req, runtime), new DescribeCapacityReservationsResponse({}));
  }

  async describeCapacityReservations(request: DescribeCapacityReservationsRequest): Promise<DescribeCapacityReservationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCapacityReservationsWithOptions(request, runtime);
  }

  async describeCustomerIssueCategoryWithOptions(request: DescribeCustomerIssueCategoryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCustomerIssueCategoryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.layer)) {
      query["Layer"] = request.layer;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCustomerIssueCategory",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCustomerIssueCategoryResponse>(await this.callApi(params, req, runtime), new DescribeCustomerIssueCategoryResponse({}));
  }

  async describeCustomerIssueCategory(request: DescribeCustomerIssueCategoryRequest): Promise<DescribeCustomerIssueCategoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCustomerIssueCategoryWithOptions(request, runtime);
  }

  async describeDedicatedHostAutoRenewWithOptions(request: DescribeDedicatedHostAutoRenewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDedicatedHostAutoRenewResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDedicatedHostAutoRenew",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDedicatedHostAutoRenewResponse>(await this.callApi(params, req, runtime), new DescribeDedicatedHostAutoRenewResponse({}));
  }

  async describeDedicatedHostAutoRenew(request: DescribeDedicatedHostAutoRenewRequest): Promise<DescribeDedicatedHostAutoRenewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDedicatedHostAutoRenewWithOptions(request, runtime);
  }

  async describeDedicatedHostClustersWithOptions(request: DescribeDedicatedHostClustersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDedicatedHostClustersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dedicatedHostClusterIds)) {
      query["DedicatedHostClusterIds"] = request.dedicatedHostClusterIds;
    }

    if (!Util.isUnset(request.dedicatedHostClusterName)) {
      query["DedicatedHostClusterName"] = request.dedicatedHostClusterName;
    }

    if (!Util.isUnset(request.lockReason)) {
      query["LockReason"] = request.lockReason;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    if (!Util.isUnset($tea.toMap(request.schedulerOptions))) {
      query["SchedulerOptions"] = request.schedulerOptions;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDedicatedHostClusters",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDedicatedHostClustersResponse>(await this.callApi(params, req, runtime), new DescribeDedicatedHostClustersResponse({}));
  }

  async describeDedicatedHostClusters(request: DescribeDedicatedHostClustersRequest): Promise<DescribeDedicatedHostClustersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDedicatedHostClustersWithOptions(request, runtime);
  }

  async describeDedicatedHostTypesWithOptions(request: DescribeDedicatedHostTypesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDedicatedHostTypesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dedicatedHostType)) {
      query["DedicatedHostType"] = request.dedicatedHostType;
    }

    if (!Util.isUnset(request.generation)) {
      query["Generation"] = request.generation;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.supportInstanceTypeFamily)) {
      query["SupportInstanceTypeFamily"] = request.supportInstanceTypeFamily;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDedicatedHostTypes",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDedicatedHostTypesResponse>(await this.callApi(params, req, runtime), new DescribeDedicatedHostTypesResponse({}));
  }

  async describeDedicatedHostTypes(request: DescribeDedicatedHostTypesRequest): Promise<DescribeDedicatedHostTypesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDedicatedHostTypesWithOptions(request, runtime);
  }

  async describeDedicatedHostsWithOptions(request: DescribeDedicatedHostsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDedicatedHostsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dedicatedHostClusterId)) {
      query["DedicatedHostClusterId"] = request.dedicatedHostClusterId;
    }

    if (!Util.isUnset(request.dedicatedHostIds)) {
      query["DedicatedHostIds"] = request.dedicatedHostIds;
    }

    if (!Util.isUnset(request.dedicatedHostName)) {
      query["DedicatedHostName"] = request.dedicatedHostName;
    }

    if (!Util.isUnset(request.dedicatedHostType)) {
      query["DedicatedHostType"] = request.dedicatedHostType;
    }

    if (!Util.isUnset(request.lockReason)) {
      query["LockReason"] = request.lockReason;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    if (!Util.isUnset($tea.toMap(request.schedulerOptions))) {
      query["SchedulerOptions"] = request.schedulerOptions;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDedicatedHosts",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDedicatedHostsResponse>(await this.callApi(params, req, runtime), new DescribeDedicatedHostsResponse({}));
  }

  async describeDedicatedHosts(request: DescribeDedicatedHostsRequest): Promise<DescribeDedicatedHostsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDedicatedHostsWithOptions(request, runtime);
  }

  async describeDiagnoseWithOptions(request: DescribeDiagnoseRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDiagnoseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.diagnoseAction)) {
      query["DiagnoseAction"] = request.diagnoseAction;
    }

    if (!Util.isUnset(request.diagnoseId)) {
      query["DiagnoseId"] = request.diagnoseId;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDiagnose",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDiagnoseResponse>(await this.callApi(params, req, runtime), new DescribeDiagnoseResponse({}));
  }

  async describeDiagnose(request: DescribeDiagnoseRequest): Promise<DescribeDiagnoseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDiagnoseWithOptions(request, runtime);
  }

  async describeDiagnosisOperateRecordsWithOptions(request: DescribeDiagnosisOperateRecordsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDiagnosisOperateRecordsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.errorCode)) {
      query["ErrorCode"] = request.errorCode;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.operateRecordType)) {
      query["OperateRecordType"] = request.operateRecordType;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.payType)) {
      query["PayType"] = request.payType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDiagnosisOperateRecords",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDiagnosisOperateRecordsResponse>(await this.callApi(params, req, runtime), new DescribeDiagnosisOperateRecordsResponse({}));
  }

  async describeDiagnosisOperateRecords(request: DescribeDiagnosisOperateRecordsRequest): Promise<DescribeDiagnosisOperateRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDiagnosisOperateRecordsWithOptions(request, runtime);
  }

  async describeDiagnosticReportsWithOptions(request: DescribeDiagnosticReportsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDiagnosticReportsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.reportId)) {
      query["ReportId"] = request.reportId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.severity)) {
      query["Severity"] = request.severity;
    }

    if (!Util.isUnset(request.sourceSystem)) {
      query["SourceSystem"] = request.sourceSystem;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDiagnosticReports",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDiagnosticReportsResponse>(await this.callApi(params, req, runtime), new DescribeDiagnosticReportsResponse({}));
  }

  async describeDiagnosticReports(request: DescribeDiagnosticReportsRequest): Promise<DescribeDiagnosticReportsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDiagnosticReportsWithOptions(request, runtime);
  }

  async describeDiskReplicaPairsWithOptions(request: DescribeDiskReplicaPairsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDiskReplicaPairsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDiskReplicaPairs",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDiskReplicaPairsResponse>(await this.callApi(params, req, runtime), new DescribeDiskReplicaPairsResponse({}));
  }

  async describeDiskReplicaPairs(request: DescribeDiskReplicaPairsRequest): Promise<DescribeDiskReplicaPairsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDiskReplicaPairsWithOptions(request, runtime);
  }

  async describeEcsScenarioFacadeWithOptions(request: DescribeEcsScenarioFacadeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEcsScenarioFacadeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.extMap)) {
      query["ExtMap"] = request.extMap;
    }

    if (!Util.isUnset(request.extParam)) {
      query["ExtParam"] = request.extParam;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.scenarioList)) {
      query["ScenarioList"] = request.scenarioList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEcsScenarioFacade",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEcsScenarioFacadeResponse>(await this.callApi(params, req, runtime), new DescribeEcsScenarioFacadeResponse({}));
  }

  async describeEcsScenarioFacade(request: DescribeEcsScenarioFacadeRequest): Promise<DescribeEcsScenarioFacadeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEcsScenarioFacadeWithOptions(request, runtime);
  }

  async describeEniQosGroupInfoWithOptions(request: DescribeEniQosGroupInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEniQosGroupInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.qosGroupName)) {
      query["QosGroupName"] = request.qosGroupName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEniQosGroupInfo",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEniQosGroupInfoResponse>(await this.callApi(params, req, runtime), new DescribeEniQosGroupInfoResponse({}));
  }

  async describeEniQosGroupInfo(request: DescribeEniQosGroupInfoRequest): Promise<DescribeEniQosGroupInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEniQosGroupInfoWithOptions(request, runtime);
  }

  async describeFunctionFeedbackWithOptions(request: DescribeFunctionFeedbackRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFunctionFeedbackResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.category)) {
      query["Category"] = request.category;
    }

    if (!Util.isUnset(request.feedback)) {
      query["Feedback"] = request.feedback;
    }

    if (!Util.isUnset(request.functionName)) {
      query["FunctionName"] = request.functionName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFunctionFeedback",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeFunctionFeedbackResponse>(await this.callApi(params, req, runtime), new DescribeFunctionFeedbackResponse({}));
  }

  async describeFunctionFeedback(request: DescribeFunctionFeedbackRequest): Promise<DescribeFunctionFeedbackResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFunctionFeedbackWithOptions(request, runtime);
  }

  async describeHavsInstanceTypesWithOptions(request: DescribeHavsInstanceTypesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeHavsInstanceTypesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeHavsInstanceTypes",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeHavsInstanceTypesResponse>(await this.callApi(params, req, runtime), new DescribeHavsInstanceTypesResponse({}));
  }

  async describeHavsInstanceTypes(request: DescribeHavsInstanceTypesRequest): Promise<DescribeHavsInstanceTypesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeHavsInstanceTypesWithOptions(request, runtime);
  }

  async describeImageAgreementWithOptions(request: DescribeImageAgreementRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageAgreementResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.agreementType)) {
      query["AgreementType"] = request.agreementType;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageAgreement",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageAgreementResponse>(await this.callApi(params, req, runtime), new DescribeImageAgreementResponse({}));
  }

  async describeImageAgreement(request: DescribeImageAgreementRequest): Promise<DescribeImageAgreementResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageAgreementWithOptions(request, runtime);
  }

  async describeImageCachesWithOptions(request: DescribeImageCachesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageCachesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.imageId)) {
      query["ImageId"] = request.imageId;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageCaches",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageCachesResponse>(await this.callApi(params, req, runtime), new DescribeImageCachesResponse({}));
  }

  async describeImageCaches(request: DescribeImageCachesRequest): Promise<DescribeImageCachesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageCachesWithOptions(request, runtime);
  }

  async describeImageFamiliesWithOptions(request: DescribeImageFamiliesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageFamiliesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageFamilies",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageFamiliesResponse>(await this.callApi(params, req, runtime), new DescribeImageFamiliesResponse({}));
  }

  async describeImageFamilies(request: DescribeImageFamiliesRequest): Promise<DescribeImageFamiliesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageFamiliesWithOptions(request, runtime);
  }

  async describeInstanceAutoRebootTimeWithOptions(request: DescribeInstanceAutoRebootTimeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceAutoRebootTimeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.autoRebootTimeFrom)) {
      query["AutoRebootTimeFrom"] = request.autoRebootTimeFrom;
    }

    if (!Util.isUnset(request.autoRebootTimeTo)) {
      query["AutoRebootTimeTo"] = request.autoRebootTimeTo;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceAutoRebootTime",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceAutoRebootTimeResponse>(await this.callApi(params, req, runtime), new DescribeInstanceAutoRebootTimeResponse({}));
  }

  async describeInstanceAutoRebootTime(request: DescribeInstanceAutoRebootTimeRequest): Promise<DescribeInstanceAutoRebootTimeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceAutoRebootTimeWithOptions(request, runtime);
  }

  async describeInstanceHealthStatusWithOptions(request: DescribeInstanceHealthStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceHealthStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceHealthStatus",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceHealthStatusResponse>(await this.callApi(params, req, runtime), new DescribeInstanceHealthStatusResponse({}));
  }

  async describeInstanceHealthStatus(request: DescribeInstanceHealthStatusRequest): Promise<DescribeInstanceHealthStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceHealthStatusWithOptions(request, runtime);
  }

  async describeInstanceMaintenanceAttributesWithOptions(request: DescribeInstanceMaintenanceAttributesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceMaintenanceAttributesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceMaintenanceAttributes",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceMaintenanceAttributesResponse>(await this.callApi(params, req, runtime), new DescribeInstanceMaintenanceAttributesResponse({}));
  }

  async describeInstanceMaintenanceAttributes(request: DescribeInstanceMaintenanceAttributesRequest): Promise<DescribeInstanceMaintenanceAttributesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceMaintenanceAttributesWithOptions(request, runtime);
  }

  async describeInstanceModificationPriceWithOptions(request: DescribeInstanceModificationPriceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceModificationPriceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataDisk)) {
      query["DataDisk"] = request.dataDisk;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset($tea.toMap(request.systemDisk))) {
      query["SystemDisk"] = request.systemDisk;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceModificationPrice",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceModificationPriceResponse>(await this.callApi(params, req, runtime), new DescribeInstanceModificationPriceResponse({}));
  }

  async describeInstanceModificationPrice(request: DescribeInstanceModificationPriceRequest): Promise<DescribeInstanceModificationPriceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceModificationPriceWithOptions(request, runtime);
  }

  async describeInstanceNeedRebootWithOptions(request: DescribeInstanceNeedRebootRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceNeedRebootResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceNeedReboot",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceNeedRebootResponse>(await this.callApi(params, req, runtime), new DescribeInstanceNeedRebootResponse({}));
  }

  async describeInstanceNeedReboot(request: DescribeInstanceNeedRebootRequest): Promise<DescribeInstanceNeedRebootResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceNeedRebootWithOptions(request, runtime);
  }

  async describeInstancePerformanceRestrictHistoryWithOptions(request: DescribeInstancePerformanceRestrictHistoryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstancePerformanceRestrictHistoryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstancePerformanceRestrictHistory",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstancePerformanceRestrictHistoryResponse>(await this.callApi(params, req, runtime), new DescribeInstancePerformanceRestrictHistoryResponse({}));
  }

  async describeInstancePerformanceRestrictHistory(request: DescribeInstancePerformanceRestrictHistoryRequest): Promise<DescribeInstancePerformanceRestrictHistoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstancePerformanceRestrictHistoryWithOptions(request, runtime);
  }

  async describeInstanceTypeResourceWithOptions(request: DescribeInstanceTypeResourceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceTypeResourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cores)) {
      query["Cores"] = request.cores;
    }

    if (!Util.isUnset(request.instanceTypeFamilies)) {
      query["InstanceTypeFamilies"] = request.instanceTypeFamilies;
    }

    if (!Util.isUnset(request.instanceTypeMatchMode)) {
      query["InstanceTypeMatchMode"] = request.instanceTypeMatchMode;
    }

    if (!Util.isUnset(request.instanceTypes)) {
      query["InstanceTypes"] = request.instanceTypes;
    }

    if (!Util.isUnset(request.memories)) {
      query["Memories"] = request.memories;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.searchTypes)) {
      query["SearchTypes"] = request.searchTypes;
    }

    if (!Util.isUnset(request.zoneIds)) {
      query["ZoneIds"] = request.zoneIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceTypeResource",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceTypeResourceResponse>(await this.callApi(params, req, runtime), new DescribeInstanceTypeResourceResponse({}));
  }

  async describeInstanceTypeResource(request: DescribeInstanceTypeResourceRequest): Promise<DescribeInstanceTypeResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceTypeResourceWithOptions(request, runtime);
  }

  async describeKMSKeyAttributeWithOptions(request: DescribeKMSKeyAttributeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeKMSKeyAttributeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.KMSKeyId)) {
      query["KMSKeyId"] = request.KMSKeyId;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.appKey)) {
      query["appKey"] = request.appKey;
    }

    if (!Util.isUnset(request.channel)) {
      query["channel"] = request.channel;
    }

    if (!Util.isUnset(request.operator)) {
      query["operator"] = request.operator;
    }

    if (!Util.isUnset(request.proxyId)) {
      query["proxyId"] = request.proxyId;
    }

    if (!Util.isUnset(request.token)) {
      query["token"] = request.token;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeKMSKeyAttribute",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeKMSKeyAttributeResponse>(await this.callApi(params, req, runtime), new DescribeKMSKeyAttributeResponse({}));
  }

  async describeKMSKeyAttribute(request: DescribeKMSKeyAttributeRequest): Promise<DescribeKMSKeyAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeKMSKeyAttributeWithOptions(request, runtime);
  }

  async describeKMSKeysWithOptions(request: DescribeKMSKeysRequest, runtime: $Util.RuntimeOptions): Promise<DescribeKMSKeysResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.appKey)) {
      query["appKey"] = request.appKey;
    }

    if (!Util.isUnset(request.channel)) {
      query["channel"] = request.channel;
    }

    if (!Util.isUnset(request.operator)) {
      query["operator"] = request.operator;
    }

    if (!Util.isUnset(request.proxyId)) {
      query["proxyId"] = request.proxyId;
    }

    if (!Util.isUnset(request.token)) {
      query["token"] = request.token;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeKMSKeys",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeKMSKeysResponse>(await this.callApi(params, req, runtime), new DescribeKMSKeysResponse({}));
  }

  async describeKMSKeys(request: DescribeKMSKeysRequest): Promise<DescribeKMSKeysResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeKMSKeysWithOptions(request, runtime);
  }

  async describeLinkedKMSKeysWithOptions(request: DescribeLinkedKMSKeysRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLinkedKMSKeysResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.appKey)) {
      query["appKey"] = request.appKey;
    }

    if (!Util.isUnset(request.channel)) {
      query["channel"] = request.channel;
    }

    if (!Util.isUnset(request.operator)) {
      query["operator"] = request.operator;
    }

    if (!Util.isUnset(request.proxyId)) {
      query["proxyId"] = request.proxyId;
    }

    if (!Util.isUnset(request.token)) {
      query["token"] = request.token;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLinkedKMSKeys",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLinkedKMSKeysResponse>(await this.callApi(params, req, runtime), new DescribeLinkedKMSKeysResponse({}));
  }

  async describeLinkedKMSKeys(request: DescribeLinkedKMSKeysRequest): Promise<DescribeLinkedKMSKeysResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLinkedKMSKeysWithOptions(request, runtime);
  }

  async describeLocalDiskRepairActivitiesWithOptions(request: DescribeLocalDiskRepairActivitiesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLocalDiskRepairActivitiesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.diskId)) {
      query["DiskId"] = request.diskId;
    }

    if (!Util.isUnset(request.includeHistory)) {
      query["IncludeHistory"] = request.includeHistory;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLocalDiskRepairActivities",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLocalDiskRepairActivitiesResponse>(await this.callApi(params, req, runtime), new DescribeLocalDiskRepairActivitiesResponse({}));
  }

  async describeLocalDiskRepairActivities(request: DescribeLocalDiskRepairActivitiesRequest): Promise<DescribeLocalDiskRepairActivitiesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLocalDiskRepairActivitiesWithOptions(request, runtime);
  }

  async describeMigrationInstancesWithOptions(request: DescribeMigrationInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMigrationInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.businessMigrationType)) {
      query["BusinessMigrationType"] = request.businessMigrationType;
    }

    if (!Util.isUnset(request.hostname)) {
      query["Hostname"] = request.hostname;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.migrationPlanId)) {
      query["MigrationPlanId"] = request.migrationPlanId;
    }

    if (!Util.isUnset(request.migrationStatus)) {
      query["MigrationStatus"] = request.migrationStatus;
    }

    if (!Util.isUnset(request.networkMigrationType)) {
      query["NetworkMigrationType"] = request.networkMigrationType;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMigrationInstances",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMigrationInstancesResponse>(await this.callApi(params, req, runtime), new DescribeMigrationInstancesResponse({}));
  }

  async describeMigrationInstances(request: DescribeMigrationInstancesRequest): Promise<DescribeMigrationInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMigrationInstancesWithOptions(request, runtime);
  }

  async describeMigrationPlansWithOptions(request: DescribeMigrationPlansRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMigrationPlansResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.migrationPlanId)) {
      query["MigrationPlanId"] = request.migrationPlanId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMigrationPlans",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMigrationPlansResponse>(await this.callApi(params, req, runtime), new DescribeMigrationPlansResponse({}));
  }

  async describeMigrationPlans(request: DescribeMigrationPlansRequest): Promise<DescribeMigrationPlansResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMigrationPlansWithOptions(request, runtime);
  }

  async describeMigrationPreferencesWithOptions(request: DescribeMigrationPreferencesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMigrationPreferencesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.migrationNetworkType)) {
      query["MigrationNetworkType"] = request.migrationNetworkType;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMigrationPreferences",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMigrationPreferencesResponse>(await this.callApi(params, req, runtime), new DescribeMigrationPreferencesResponse({}));
  }

  async describeMigrationPreferences(request: DescribeMigrationPreferencesRequest): Promise<DescribeMigrationPreferencesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMigrationPreferencesWithOptions(request, runtime);
  }

  async describeNetworkInsightsAnalysisResultWithOptions(request: DescribeNetworkInsightsAnalysisResultRequest, runtime: $Util.RuntimeOptions): Promise<DescribeNetworkInsightsAnalysisResultResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeNetworkInsightsAnalysisResult",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeNetworkInsightsAnalysisResultResponse>(await this.callApi(params, req, runtime), new DescribeNetworkInsightsAnalysisResultResponse({}));
  }

  async describeNetworkInsightsAnalysisResult(request: DescribeNetworkInsightsAnalysisResultRequest): Promise<DescribeNetworkInsightsAnalysisResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeNetworkInsightsAnalysisResultWithOptions(request, runtime);
  }

  async describeNetworkInsightsAnalysisesWithOptions(request: DescribeNetworkInsightsAnalysisesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeNetworkInsightsAnalysisesResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeNetworkInsightsAnalysises",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeNetworkInsightsAnalysisesResponse>(await this.callApi(params, req, runtime), new DescribeNetworkInsightsAnalysisesResponse({}));
  }

  async describeNetworkInsightsAnalysises(request: DescribeNetworkInsightsAnalysisesRequest): Promise<DescribeNetworkInsightsAnalysisesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeNetworkInsightsAnalysisesWithOptions(request, runtime);
  }

  async describeNetworkInsightsPathsWithOptions(request: DescribeNetworkInsightsPathsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeNetworkInsightsPathsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.networkInsightsPathId)) {
      query["NetworkInsightsPathId"] = request.networkInsightsPathId;
    }

    if (!Util.isUnset(request.networkPathFound)) {
      query["NetworkPathFound"] = request.networkPathFound;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeNetworkInsightsPaths",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeNetworkInsightsPathsResponse>(await this.callApi(params, req, runtime), new DescribeNetworkInsightsPathsResponse({}));
  }

  async describeNetworkInsightsPaths(request: DescribeNetworkInsightsPathsRequest): Promise<DescribeNetworkInsightsPathsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeNetworkInsightsPathsWithOptions(request, runtime);
  }

  async describeOrderAutoRebootTimeWithOptions(request: DescribeOrderAutoRebootTimeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOrderAutoRebootTimeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOrderAutoRebootTime",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOrderAutoRebootTimeResponse>(await this.callApi(params, req, runtime), new DescribeOrderAutoRebootTimeResponse({}));
  }

  async describeOrderAutoRebootTime(request: DescribeOrderAutoRebootTimeRequest): Promise<DescribeOrderAutoRebootTimeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOrderAutoRebootTimeWithOptions(request, runtime);
  }

  async describePrePaidResourceRefundPriceWithOptions(request: DescribePrePaidResourceRefundPriceRequest, runtime: $Util.RuntimeOptions): Promise<DescribePrePaidResourceRefundPriceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePrePaidResourceRefundPrice",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePrePaidResourceRefundPriceResponse>(await this.callApi(params, req, runtime), new DescribePrePaidResourceRefundPriceResponse({}));
  }

  async describePrePaidResourceRefundPrice(request: DescribePrePaidResourceRefundPriceRequest): Promise<DescribePrePaidResourceRefundPriceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePrePaidResourceRefundPriceWithOptions(request, runtime);
  }

  async describePriceWithOptions(request: DescribePriceRequest, runtime: $Util.RuntimeOptions): Promise<DescribePriceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.businessInfo)) {
      query["BusinessInfo"] = request.businessInfo;
    }

    if (!Util.isUnset(request.commodity)) {
      query["Commodity"] = request.commodity;
    }

    if (!Util.isUnset(request.defaultVpc)) {
      query["DefaultVpc"] = request.defaultVpc;
    }

    if (!Util.isUnset(request.fromApp)) {
      query["FromApp"] = request.fromApp;
    }

    if (!Util.isUnset(request.needSpotPrice)) {
      query["NeedSpotPrice"] = request.needSpotPrice;
    }

    if (!Util.isUnset(request.networkType)) {
      query["NetworkType"] = request.networkType;
    }

    if (!Util.isUnset(request.orderType)) {
      query["OrderType"] = request.orderType;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.verbose)) {
      query["Verbose"] = request.verbose;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePrice",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePriceResponse>(await this.callApi(params, req, runtime), new DescribePriceResponse({}));
  }

  async describePrice(request: DescribePriceRequest): Promise<DescribePriceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePriceWithOptions(request, runtime);
  }

  async describePrivatePoolsWithOptions(request: DescribePrivatePoolsRequest, runtime: $Util.RuntimeOptions): Promise<DescribePrivatePoolsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceChargeType)) {
      query["InstanceChargeType"] = request.instanceChargeType;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.platform)) {
      query["Platform"] = request.platform;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.startTimeType)) {
      query["StartTimeType"] = request.startTimeType;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    if (!Util.isUnset($tea.toMap(request.privatePoolOptions))) {
      query["PrivatePoolOptions"] = request.privatePoolOptions;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePrivatePools",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePrivatePoolsResponse>(await this.callApi(params, req, runtime), new DescribePrivatePoolsResponse({}));
  }

  async describePrivatePools(request: DescribePrivatePoolsRequest): Promise<DescribePrivatePoolsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePrivatePoolsWithOptions(request, runtime);
  }

  async describeRecommendProductWithOptions(request: DescribeRecommendProductRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRecommendProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.amount)) {
      query["Amount"] = request.amount;
    }

    if (!Util.isUnset(request.cores)) {
      query["Cores"] = request.cores;
    }

    if (!Util.isUnset(request.instanceChargeType)) {
      query["InstanceChargeType"] = request.instanceChargeType;
    }

    if (!Util.isUnset(request.instanceFamilyLevel)) {
      query["InstanceFamilyLevel"] = request.instanceFamilyLevel;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.instanceTypeFamily)) {
      query["InstanceTypeFamily"] = request.instanceTypeFamily;
    }

    if (!Util.isUnset(request.instanceTypeSupportIPv6)) {
      query["InstanceTypeSupportIPv6"] = request.instanceTypeSupportIPv6;
    }

    if (!Util.isUnset(request.ioOptimized)) {
      query["IoOptimized"] = request.ioOptimized;
    }

    if (!Util.isUnset(request.maxPrice)) {
      query["MaxPrice"] = request.maxPrice;
    }

    if (!Util.isUnset(request.memory)) {
      query["Memory"] = request.memory;
    }

    if (!Util.isUnset(request.networkType)) {
      query["NetworkType"] = request.networkType;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.priorityStrategy)) {
      query["PriorityStrategy"] = request.priorityStrategy;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.spotStrategy)) {
      query["SpotStrategy"] = request.spotStrategy;
    }

    if (!Util.isUnset(request.systemDiskCategory)) {
      query["SystemDiskCategory"] = request.systemDiskCategory;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    if (!Util.isUnset(request.zoneMatchMode)) {
      query["ZoneMatchMode"] = request.zoneMatchMode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRecommendProduct",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRecommendProductResponse>(await this.callApi(params, req, runtime), new DescribeRecommendProductResponse({}));
  }

  async describeRecommendProduct(request: DescribeRecommendProductRequest): Promise<DescribeRecommendProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRecommendProductWithOptions(request, runtime);
  }

  async describeReservationDemandCommittedAmountWithOptions(request: DescribeReservationDemandCommittedAmountRequest, runtime: $Util.RuntimeOptions): Promise<DescribeReservationDemandCommittedAmountResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.demandPlan)) {
      query["DemandPlan"] = request.demandPlan;
    }

    if (!Util.isUnset(request.instanceFamily)) {
      query["InstanceFamily"] = request.instanceFamily;
    }

    if (!Util.isUnset(request.instanceFamilySet)) {
      query["InstanceFamilySet"] = request.instanceFamilySet;
    }

    if (!Util.isUnset(request.offeringType)) {
      query["OfferingType"] = request.offeringType;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.periodUnit)) {
      query["PeriodUnit"] = request.periodUnit;
    }

    if (!Util.isUnset(request.planType)) {
      query["PlanType"] = request.planType;
    }

    if (!Util.isUnset(request.platform)) {
      query["Platform"] = request.platform;
    }

    if (!Util.isUnset(request.purchaseMethod)) {
      query["PurchaseMethod"] = request.purchaseMethod;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeReservationDemandCommittedAmount",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeReservationDemandCommittedAmountResponse>(await this.callApi(params, req, runtime), new DescribeReservationDemandCommittedAmountResponse({}));
  }

  async describeReservationDemandCommittedAmount(request: DescribeReservationDemandCommittedAmountRequest): Promise<DescribeReservationDemandCommittedAmountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeReservationDemandCommittedAmountWithOptions(request, runtime);
  }

  async describeReservationDemandsWithOptions(request: DescribeReservationDemandsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeReservationDemandsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.demandId)) {
      query["DemandId"] = request.demandId;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeReservationDemands",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeReservationDemandsResponse>(await this.callApi(params, req, runtime), new DescribeReservationDemandsResponse({}));
  }

  async describeReservationDemands(request: DescribeReservationDemandsRequest): Promise<DescribeReservationDemandsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeReservationDemandsWithOptions(request, runtime);
  }

  async describeReservedInstanceAllocationsWithOptions(request: DescribeReservedInstanceAllocationsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeReservedInstanceAllocationsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.reservedInstanceId)) {
      query["ReservedInstanceId"] = request.reservedInstanceId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeReservedInstanceAllocations",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeReservedInstanceAllocationsResponse>(await this.callApi(params, req, runtime), new DescribeReservedInstanceAllocationsResponse({}));
  }

  async describeReservedInstanceAllocations(request: DescribeReservedInstanceAllocationsRequest): Promise<DescribeReservedInstanceAllocationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeReservedInstanceAllocationsWithOptions(request, runtime);
  }

  async describeReservedInstanceCategoriesWithOptions(request: DescribeReservedInstanceCategoriesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeReservedInstanceCategoriesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.scope)) {
      query["Scope"] = request.scope;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeReservedInstanceCategories",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeReservedInstanceCategoriesResponse>(await this.callApi(params, req, runtime), new DescribeReservedInstanceCategoriesResponse({}));
  }

  async describeReservedInstanceCategories(request: DescribeReservedInstanceCategoriesRequest): Promise<DescribeReservedInstanceCategoriesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeReservedInstanceCategoriesWithOptions(request, runtime);
  }

  async describeReservedInstancePriceWithOptions(request: DescribeReservedInstancePriceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeReservedInstancePriceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.reservedInstanceId)) {
      query["ReservedInstanceId"] = request.reservedInstanceId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeReservedInstancePrice",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeReservedInstancePriceResponse>(await this.callApi(params, req, runtime), new DescribeReservedInstancePriceResponse({}));
  }

  async describeReservedInstancePrice(request: DescribeReservedInstancePriceRequest): Promise<DescribeReservedInstancePriceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeReservedInstancePriceWithOptions(request, runtime);
  }

  async describeReservedInstancesWithOptions(request: DescribeReservedInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeReservedInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.allocationType)) {
      query["AllocationType"] = request.allocationType;
    }

    if (!Util.isUnset(request.expiredTime)) {
      query["ExpiredTime"] = request.expiredTime;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.instanceTypeFamily)) {
      query["InstanceTypeFamily"] = request.instanceTypeFamily;
    }

    if (!Util.isUnset(request.lockReason)) {
      query["LockReason"] = request.lockReason;
    }

    if (!Util.isUnset(request.offeringType)) {
      query["OfferingType"] = request.offeringType;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.reservedInstanceId)) {
      query["ReservedInstanceId"] = request.reservedInstanceId;
    }

    if (!Util.isUnset(request.reservedInstanceName)) {
      query["ReservedInstanceName"] = request.reservedInstanceName;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.scope)) {
      query["Scope"] = request.scope;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeReservedInstances",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeReservedInstancesResponse>(await this.callApi(params, req, runtime), new DescribeReservedInstancesResponse({}));
  }

  async describeReservedInstances(request: DescribeReservedInstancesRequest): Promise<DescribeReservedInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeReservedInstancesWithOptions(request, runtime);
  }

  async describeResourceAggregationsWithOptions(request: DescribeResourceAggregationsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeResourceAggregationsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aggregators)) {
      query["Aggregators"] = request.aggregators;
    }

    if (!Util.isUnset(request.filter)) {
      query["Filter"] = request.filter;
    }

    if (!Util.isUnset(request.global)) {
      query["Global"] = request.global;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.marker)) {
      query["Marker"] = request.marker;
    }

    if (!Util.isUnset(request.maxItems)) {
      query["MaxItems"] = request.maxItems;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.product)) {
      query["Product"] = request.product;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionNo)) {
      query["RegionNo"] = request.regionNo;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tagFilter)) {
      query["TagFilter"] = request.tagFilter;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeResourceAggregations",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeResourceAggregationsResponse>(await this.callApi(params, req, runtime), new DescribeResourceAggregationsResponse({}));
  }

  async describeResourceAggregations(request: DescribeResourceAggregationsRequest): Promise<DescribeResourceAggregationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeResourceAggregationsWithOptions(request, runtime);
  }

  async describeResourceAllocationWithOptions(request: DescribeResourceAllocationRequest, runtime: $Util.RuntimeOptions): Promise<DescribeResourceAllocationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cores)) {
      query["Cores"] = request.cores;
    }

    if (!Util.isUnset(request.dataDiskCategory)) {
      query["DataDiskCategory"] = request.dataDiskCategory;
    }

    if (!Util.isUnset(request.defaultTargetCapacityType)) {
      query["DefaultTargetCapacityType"] = request.defaultTargetCapacityType;
    }

    if (!Util.isUnset(request.instanceFamilyLevel)) {
      query["InstanceFamilyLevel"] = request.instanceFamilyLevel;
    }

    if (!Util.isUnset(request.instanceTypeModel)) {
      query["InstanceTypeModel"] = request.instanceTypeModel;
    }

    if (!Util.isUnset(request.instanceTypeSupportIPv6)) {
      query["InstanceTypeSupportIPv6"] = request.instanceTypeSupportIPv6;
    }

    if (!Util.isUnset(request.ioOptimized)) {
      query["IoOptimized"] = request.ioOptimized;
    }

    if (!Util.isUnset(request.maxPrice)) {
      query["MaxPrice"] = request.maxPrice;
    }

    if (!Util.isUnset(request.memory)) {
      query["Memory"] = request.memory;
    }

    if (!Util.isUnset(request.networkType)) {
      query["NetworkType"] = request.networkType;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.postPaidBaseCapacity)) {
      query["PostPaidBaseCapacity"] = request.postPaidBaseCapacity;
    }

    if (!Util.isUnset(request.priorityStrategy)) {
      query["PriorityStrategy"] = request.priorityStrategy;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceAmountType)) {
      query["ResourceAmountType"] = request.resourceAmountType;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.spotBaseCapacity)) {
      query["SpotBaseCapacity"] = request.spotBaseCapacity;
    }

    if (!Util.isUnset(request.spotInstancePools)) {
      query["SpotInstancePools"] = request.spotInstancePools;
    }

    if (!Util.isUnset(request.spotStrategy)) {
      query["SpotStrategy"] = request.spotStrategy;
    }

    if (!Util.isUnset(request.strictSatisfiedTargetCapacity)) {
      query["StrictSatisfiedTargetCapacity"] = request.strictSatisfiedTargetCapacity;
    }

    if (!Util.isUnset(request.systemDiskCategory)) {
      query["SystemDiskCategory"] = request.systemDiskCategory;
    }

    if (!Util.isUnset(request.targetCapacity)) {
      query["TargetCapacity"] = request.targetCapacity;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeResourceAllocation",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeResourceAllocationResponse>(await this.callApi(params, req, runtime), new DescribeResourceAllocationResponse({}));
  }

  async describeResourceAllocation(request: DescribeResourceAllocationRequest): Promise<DescribeResourceAllocationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeResourceAllocationWithOptions(request, runtime);
  }

  async describeResourceDisplayWithOptions(request: DescribeResourceDisplayRequest, runtime: $Util.RuntimeOptions): Promise<DescribeResourceDisplayResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.chargeType)) {
      query["ChargeType"] = request.chargeType;
    }

    if (!Util.isUnset(request.firstBizLevel)) {
      query["FirstBizLevel"] = request.firstBizLevel;
    }

    if (!Util.isUnset(request.instanceCategoryType)) {
      query["InstanceCategoryType"] = request.instanceCategoryType;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.secondBizLevel)) {
      query["SecondBizLevel"] = request.secondBizLevel;
    }

    if (!Util.isUnset(request.spotStrategy)) {
      query["SpotStrategy"] = request.spotStrategy;
    }

    if (!Util.isUnset(request.templateTag)) {
      query["TemplateTag"] = request.templateTag;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeResourceDisplay",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeResourceDisplayResponse>(await this.callApi(params, req, runtime), new DescribeResourceDisplayResponse({}));
  }

  async describeResourceDisplay(request: DescribeResourceDisplayRequest): Promise<DescribeResourceDisplayResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeResourceDisplayWithOptions(request, runtime);
  }

  async describeResourceFilterAttributesWithOptions(request: DescribeResourceFilterAttributesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeResourceFilterAttributesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.product)) {
      query["Product"] = request.product;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.templateTag)) {
      query["TemplateTag"] = request.templateTag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeResourceFilterAttributes",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeResourceFilterAttributesResponse>(await this.callApi(params, req, runtime), new DescribeResourceFilterAttributesResponse({}));
  }

  async describeResourceFilterAttributes(request: DescribeResourceFilterAttributesRequest): Promise<DescribeResourceFilterAttributesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeResourceFilterAttributesWithOptions(request, runtime);
  }

  async describeResourceRecommendFiltersWithOptions(request: DescribeResourceRecommendFiltersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeResourceRecommendFiltersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.attributeName)) {
      query["AttributeName"] = request.attributeName;
    }

    if (!Util.isUnset(request.attributeValue)) {
      query["AttributeValue"] = request.attributeValue;
    }

    if (!Util.isUnset(request.global)) {
      query["Global"] = request.global;
    }

    if (!Util.isUnset(request.maxItems)) {
      query["MaxItems"] = request.maxItems;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.product)) {
      query["Product"] = request.product;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionNo)) {
      query["RegionNo"] = request.regionNo;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.templateTag)) {
      query["TemplateTag"] = request.templateTag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeResourceRecommendFilters",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeResourceRecommendFiltersResponse>(await this.callApi(params, req, runtime), new DescribeResourceRecommendFiltersResponse({}));
  }

  async describeResourceRecommendFilters(request: DescribeResourceRecommendFiltersRequest): Promise<DescribeResourceRecommendFiltersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeResourceRecommendFiltersWithOptions(request, runtime);
  }

  async describeResourceSolutionsWithOptions(request: DescribeResourceSolutionsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeResourceSolutionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cores)) {
      query["Cores"] = request.cores;
    }

    if (!Util.isUnset(request.instanceChargeType)) {
      query["InstanceChargeType"] = request.instanceChargeType;
    }

    if (!Util.isUnset(request.instanceFamilyLevel)) {
      query["InstanceFamilyLevel"] = request.instanceFamilyLevel;
    }

    if (!Util.isUnset(request.instanceTypeModel)) {
      query["InstanceTypeModel"] = request.instanceTypeModel;
    }

    if (!Util.isUnset(request.instanceTypeSupportIPv6)) {
      query["InstanceTypeSupportIPv6"] = request.instanceTypeSupportIPv6;
    }

    if (!Util.isUnset(request.matchOpenInstances)) {
      query["MatchOpenInstances"] = request.matchOpenInstances;
    }

    if (!Util.isUnset(request.maxPrice)) {
      query["MaxPrice"] = request.maxPrice;
    }

    if (!Util.isUnset(request.memory)) {
      query["Memory"] = request.memory;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceAmountType)) {
      query["ResourceAmountType"] = request.resourceAmountType;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.spotStrategy)) {
      query["SpotStrategy"] = request.spotStrategy;
    }

    if (!Util.isUnset(request.systemDiskCategory)) {
      query["SystemDiskCategory"] = request.systemDiskCategory;
    }

    if (!Util.isUnset(request.targetCapacity)) {
      query["TargetCapacity"] = request.targetCapacity;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeResourceSolutions",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeResourceSolutionsResponse>(await this.callApi(params, req, runtime), new DescribeResourceSolutionsResponse({}));
  }

  async describeResourceSolutions(request: DescribeResourceSolutionsRequest): Promise<DescribeResourceSolutionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeResourceSolutionsWithOptions(request, runtime);
  }

  async describeResourcesWithOptions(request: DescribeResourcesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.filter)) {
      query["Filter"] = request.filter;
    }

    if (!Util.isUnset(request.global)) {
      query["Global"] = request.global;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.marker)) {
      query["Marker"] = request.marker;
    }

    if (!Util.isUnset(request.maxItems)) {
      query["MaxItems"] = request.maxItems;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.product)) {
      query["Product"] = request.product;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionNo)) {
      query["RegionNo"] = request.regionNo;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tagFilter)) {
      query["TagFilter"] = request.tagFilter;
    }

    if (!Util.isUnset(request.templateTag)) {
      query["TemplateTag"] = request.templateTag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeResources",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeResourcesResponse>(await this.callApi(params, req, runtime), new DescribeResourcesResponse({}));
  }

  async describeResources(request: DescribeResourcesRequest): Promise<DescribeResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeResourcesWithOptions(request, runtime);
  }

  async describeRiUtilizationWithOptions(request: DescribeRiUtilizationRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRiUtilizationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.reservedInstanceId)) {
      query["ReservedInstanceId"] = request.reservedInstanceId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRiUtilization",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRiUtilizationResponse>(await this.callApi(params, req, runtime), new DescribeRiUtilizationResponse({}));
  }

  async describeRiUtilization(request: DescribeRiUtilizationRequest): Promise<DescribeRiUtilizationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRiUtilizationWithOptions(request, runtime);
  }

  async describeScenePurchaseRecommendWithOptions(request: DescribeScenePurchaseRecommendRequest, runtime: $Util.RuntimeOptions): Promise<DescribeScenePurchaseRecommendResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.amount)) {
      query["Amount"] = request.amount;
    }

    if (!Util.isUnset(request.dataDisk)) {
      query["DataDisk"] = request.dataDisk;
    }

    if (!Util.isUnset(request.dedicatedHostId)) {
      query["DedicatedHostId"] = request.dedicatedHostId;
    }

    if (!Util.isUnset(request.imageId)) {
      query["ImageId"] = request.imageId;
    }

    if (!Util.isUnset(request.instanceChargeType)) {
      query["InstanceChargeType"] = request.instanceChargeType;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.internetChargeType)) {
      query["InternetChargeType"] = request.internetChargeType;
    }

    if (!Util.isUnset(request.internetMaxBandwidthOut)) {
      query["InternetMaxBandwidthOut"] = request.internetMaxBandwidthOut;
    }

    if (!Util.isUnset(request.ioOptimized)) {
      query["IoOptimized"] = request.ioOptimized;
    }

    if (!Util.isUnset(request.networkType)) {
      query["NetworkType"] = request.networkType;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.periodUnit)) {
      query["PeriodUnit"] = request.periodUnit;
    }

    if (!Util.isUnset(request.productId)) {
      query["ProductId"] = request.productId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sceneId)) {
      query["SceneId"] = request.sceneId;
    }

    if (!Util.isUnset(request.spotStrategy)) {
      query["SpotStrategy"] = request.spotStrategy;
    }

    if (!Util.isUnset($tea.toMap(request.systemDisk))) {
      query["SystemDisk"] = request.systemDisk;
    }

    if (!Util.isUnset(request.tenancy)) {
      query["Tenancy"] = request.tenancy;
    }

    if (!Util.isUnset(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    if (!Util.isUnset($tea.toMap(request.privatePoolOptions))) {
      query["PrivatePoolOptions"] = request.privatePoolOptions;
    }

    if (!Util.isUnset($tea.toMap(request.schedulerOptions))) {
      query["SchedulerOptions"] = request.schedulerOptions;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeScenePurchaseRecommend",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeScenePurchaseRecommendResponse>(await this.callApi(params, req, runtime), new DescribeScenePurchaseRecommendResponse({}));
  }

  async describeScenePurchaseRecommend(request: DescribeScenePurchaseRecommendRequest): Promise<DescribeScenePurchaseRecommendResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeScenePurchaseRecommendWithOptions(request, runtime);
  }

  async describeSceneResourceRecommendWithOptions(request: DescribeSceneResourceRecommendRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSceneResourceRecommendResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.productId)) {
      query["ProductId"] = request.productId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sceneId)) {
      query["SceneId"] = request.sceneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSceneResourceRecommend",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSceneResourceRecommendResponse>(await this.callApi(params, req, runtime), new DescribeSceneResourceRecommendResponse({}));
  }

  async describeSceneResourceRecommend(request: DescribeSceneResourceRecommendRequest): Promise<DescribeSceneResourceRecommendResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSceneResourceRecommendWithOptions(request, runtime);
  }

  async describeSpotInstanceAdviceWithOptions(request: DescribeSpotInstanceAdviceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSpotInstanceAdviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cores)) {
      query["Cores"] = request.cores;
    }

    if (!Util.isUnset(request.ioOptimized)) {
      query["IoOptimized"] = request.ioOptimized;
    }

    if (!Util.isUnset(request.memory)) {
      query["Memory"] = request.memory;
    }

    if (!Util.isUnset(request.minCores)) {
      query["MinCores"] = request.minCores;
    }

    if (!Util.isUnset(request.minMemory)) {
      query["MinMemory"] = request.minMemory;
    }

    if (!Util.isUnset(request.networkType)) {
      query["NetworkType"] = request.networkType;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSpotInstanceAdvice",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSpotInstanceAdviceResponse>(await this.callApi(params, req, runtime), new DescribeSpotInstanceAdviceResponse({}));
  }

  async describeSpotInstanceAdvice(request: DescribeSpotInstanceAdviceRequest): Promise<DescribeSpotInstanceAdviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSpotInstanceAdviceWithOptions(request, runtime);
  }

  async describeStorageCapacityUnitAllocationsWithOptions(request: DescribeStorageCapacityUnitAllocationsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeStorageCapacityUnitAllocationsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.storageCapacityUnitId)) {
      query["StorageCapacityUnitId"] = request.storageCapacityUnitId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeStorageCapacityUnitAllocations",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeStorageCapacityUnitAllocationsResponse>(await this.callApi(params, req, runtime), new DescribeStorageCapacityUnitAllocationsResponse({}));
  }

  async describeStorageCapacityUnitAllocations(request: DescribeStorageCapacityUnitAllocationsRequest): Promise<DescribeStorageCapacityUnitAllocationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeStorageCapacityUnitAllocationsWithOptions(request, runtime);
  }

  async describeStorageCapacityUnitDeductFactorWithOptions(request: DescribeStorageCapacityUnitDeductFactorRequest, runtime: $Util.RuntimeOptions): Promise<DescribeStorageCapacityUnitDeductFactorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deductField)) {
      query["DeductField"] = request.deductField;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.performanceLevel)) {
      query["PerformanceLevel"] = request.performanceLevel;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.storageType)) {
      query["StorageType"] = request.storageType;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeStorageCapacityUnitDeductFactor",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeStorageCapacityUnitDeductFactorResponse>(await this.callApi(params, req, runtime), new DescribeStorageCapacityUnitDeductFactorResponse({}));
  }

  async describeStorageCapacityUnitDeductFactor(request: DescribeStorageCapacityUnitDeductFactorRequest): Promise<DescribeStorageCapacityUnitDeductFactorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeStorageCapacityUnitDeductFactorWithOptions(request, runtime);
  }

  async describeStorageSetDetailsWithOptions(request: DescribeStorageSetDetailsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeStorageSetDetailsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.diskIds)) {
      query["DiskIds"] = request.diskIds;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.storageSetId)) {
      query["StorageSetId"] = request.storageSetId;
    }

    if (!Util.isUnset(request.storageSetPartitionNumber)) {
      query["StorageSetPartitionNumber"] = request.storageSetPartitionNumber;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeStorageSetDetails",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeStorageSetDetailsResponse>(await this.callApi(params, req, runtime), new DescribeStorageSetDetailsResponse({}));
  }

  async describeStorageSetDetails(request: DescribeStorageSetDetailsRequest): Promise<DescribeStorageSetDetailsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeStorageSetDetailsWithOptions(request, runtime);
  }

  async describeStorageSetsWithOptions(request: DescribeStorageSetsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeStorageSetsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.storageSetIds)) {
      query["StorageSetIds"] = request.storageSetIds;
    }

    if (!Util.isUnset(request.storageSetName)) {
      query["StorageSetName"] = request.storageSetName;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeStorageSets",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeStorageSetsResponse>(await this.callApi(params, req, runtime), new DescribeStorageSetsResponse({}));
  }

  async describeStorageSets(request: DescribeStorageSetsRequest): Promise<DescribeStorageSetsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeStorageSetsWithOptions(request, runtime);
  }

  async describeTransitionVSwitchesWithOptions(request: DescribeTransitionVSwitchesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTransitionVSwitchesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTransitionVSwitches",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTransitionVSwitchesResponse>(await this.callApi(params, req, runtime), new DescribeTransitionVSwitchesResponse({}));
  }

  async describeTransitionVSwitches(request: DescribeTransitionVSwitchesRequest): Promise<DescribeTransitionVSwitchesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTransitionVSwitchesWithOptions(request, runtime);
  }

  async describeTransitionVpcAndVSwitchWithOptions(request: DescribeTransitionVpcAndVSwitchRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTransitionVpcAndVSwitchResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTransitionVpcAndVSwitch",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTransitionVpcAndVSwitchResponse>(await this.callApi(params, req, runtime), new DescribeTransitionVpcAndVSwitchResponse({}));
  }

  async describeTransitionVpcAndVSwitch(request: DescribeTransitionVpcAndVSwitchRequest): Promise<DescribeTransitionVpcAndVSwitchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTransitionVpcAndVSwitchWithOptions(request, runtime);
  }

  async describeTransitionVpcsWithOptions(request: DescribeTransitionVpcsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTransitionVpcsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTransitionVpcs",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTransitionVpcsResponse>(await this.callApi(params, req, runtime), new DescribeTransitionVpcsResponse({}));
  }

  async describeTransitionVpcs(request: DescribeTransitionVpcsRequest): Promise<DescribeTransitionVpcsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTransitionVpcsWithOptions(request, runtime);
  }

  async describeUserAvailableIpServiceProvidersWithOptions(request: DescribeUserAvailableIpServiceProvidersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUserAvailableIpServiceProvidersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliUid)) {
      query["AliUid"] = request.aliUid;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUserAvailableIpServiceProviders",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUserAvailableIpServiceProvidersResponse>(await this.callApi(params, req, runtime), new DescribeUserAvailableIpServiceProvidersResponse({}));
  }

  async describeUserAvailableIpServiceProviders(request: DescribeUserAvailableIpServiceProvidersRequest): Promise<DescribeUserAvailableIpServiceProvidersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUserAvailableIpServiceProvidersWithOptions(request, runtime);
  }

  async describeUserQuotaApplicationsWithOptions(request: DescribeUserQuotaApplicationsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUserQuotaApplicationsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applicationId)) {
      query["ApplicationId"] = request.applicationId;
    }

    if (!Util.isUnset(request.chargeType)) {
      query["ChargeType"] = request.chargeType;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.quotaType)) {
      query["QuotaType"] = request.quotaType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUserQuotaApplications",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUserQuotaApplicationsResponse>(await this.callApi(params, req, runtime), new DescribeUserQuotaApplicationsResponse({}));
  }

  async describeUserQuotaApplications(request: DescribeUserQuotaApplicationsRequest): Promise<DescribeUserQuotaApplicationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUserQuotaApplicationsWithOptions(request, runtime);
  }

  async describeVpcHavsInstancesWithOptions(request: DescribeVpcHavsInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeVpcHavsInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.maxResultSize)) {
      query["MaxResultSize"] = request.maxResultSize;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.vpcIdList)) {
      query["VpcIdList"] = request.vpcIdList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeVpcHavsInstances",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeVpcHavsInstancesResponse>(await this.callApi(params, req, runtime), new DescribeVpcHavsInstancesResponse({}));
  }

  async describeVpcHavsInstances(request: DescribeVpcHavsInstancesRequest): Promise<DescribeVpcHavsInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVpcHavsInstancesWithOptions(request, runtime);
  }

  async describeWaitingOrdersWithOptions(request: DescribeWaitingOrdersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWaitingOrdersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.waitingOrderId)) {
      query["WaitingOrderId"] = request.waitingOrderId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWaitingOrders",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWaitingOrdersResponse>(await this.callApi(params, req, runtime), new DescribeWaitingOrdersResponse({}));
  }

  async describeWaitingOrders(request: DescribeWaitingOrdersRequest): Promise<DescribeWaitingOrdersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWaitingOrdersWithOptions(request, runtime);
  }

  async feedbackDiagnoseWithOptions(request: FeedbackDiagnoseRequest, runtime: $Util.RuntimeOptions): Promise<FeedbackDiagnoseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.diagnoseId)) {
      query["DiagnoseId"] = request.diagnoseId;
    }

    if (!Util.isUnset(request.mark)) {
      query["Mark"] = request.mark;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.star)) {
      query["Star"] = request.star;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "FeedbackDiagnose",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<FeedbackDiagnoseResponse>(await this.callApi(params, req, runtime), new FeedbackDiagnoseResponse({}));
  }

  async feedbackDiagnose(request: FeedbackDiagnoseRequest): Promise<FeedbackDiagnoseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.feedbackDiagnoseWithOptions(request, runtime);
  }

  async getLaunchTemplateDataWithOptions(request: GetLaunchTemplateDataRequest, runtime: $Util.RuntimeOptions): Promise<GetLaunchTemplateDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetLaunchTemplateData",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetLaunchTemplateDataResponse>(await this.callApi(params, req, runtime), new GetLaunchTemplateDataResponse({}));
  }

  async getLaunchTemplateData(request: GetLaunchTemplateDataRequest): Promise<GetLaunchTemplateDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getLaunchTemplateDataWithOptions(request, runtime);
  }

  async innerDescribeNetworkInterfaceInGroupWithOptions(request: InnerDescribeNetworkInterfaceInGroupRequest, runtime: $Util.RuntimeOptions): Promise<InnerDescribeNetworkInterfaceInGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.securityGroupId)) {
      query["SecurityGroupId"] = request.securityGroupId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "InnerDescribeNetworkInterfaceInGroup",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InnerDescribeNetworkInterfaceInGroupResponse>(await this.callApi(params, req, runtime), new InnerDescribeNetworkInterfaceInGroupResponse({}));
  }

  async innerDescribeNetworkInterfaceInGroup(request: InnerDescribeNetworkInterfaceInGroupRequest): Promise<InnerDescribeNetworkInterfaceInGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.innerDescribeNetworkInterfaceInGroupWithOptions(request, runtime);
  }

  async joinEniQosGroupWithOptions(request: JoinEniQosGroupRequest, runtime: $Util.RuntimeOptions): Promise<JoinEniQosGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.networkInterfaceId)) {
      query["NetworkInterfaceId"] = request.networkInterfaceId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.qosGroupName)) {
      query["QosGroupName"] = request.qosGroupName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "JoinEniQosGroup",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<JoinEniQosGroupResponse>(await this.callApi(params, req, runtime), new JoinEniQosGroupResponse({}));
  }

  async joinEniQosGroup(request: JoinEniQosGroupRequest): Promise<JoinEniQosGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.joinEniQosGroupWithOptions(request, runtime);
  }

  async leaveEniQosGroupWithOptions(request: LeaveEniQosGroupRequest, runtime: $Util.RuntimeOptions): Promise<LeaveEniQosGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.networkInterfaceId)) {
      query["NetworkInterfaceId"] = request.networkInterfaceId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "LeaveEniQosGroup",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<LeaveEniQosGroupResponse>(await this.callApi(params, req, runtime), new LeaveEniQosGroupResponse({}));
  }

  async leaveEniQosGroup(request: LeaveEniQosGroupRequest): Promise<LeaveEniQosGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.leaveEniQosGroupWithOptions(request, runtime);
  }

  async listAccountEcsQuotasWithOptions(request: ListAccountEcsQuotasRequest, runtime: $Util.RuntimeOptions): Promise<ListAccountEcsQuotasResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.chargeType)) {
      query["ChargeType"] = request.chargeType;
    }

    if (!Util.isUnset(request.networkType)) {
      query["NetworkType"] = request.networkType;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.quotaResourceName)) {
      query["QuotaResourceName"] = request.quotaResourceName;
    }

    if (!Util.isUnset(request.quotaResourceType)) {
      query["QuotaResourceType"] = request.quotaResourceType;
    }

    if (!Util.isUnset(request.quotaUnit)) {
      query["QuotaUnit"] = request.quotaUnit;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sortField)) {
      query["SortField"] = request.sortField;
    }

    if (!Util.isUnset(request.sortOrder)) {
      query["SortOrder"] = request.sortOrder;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAccountEcsQuotas",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAccountEcsQuotasResponse>(await this.callApi(params, req, runtime), new ListAccountEcsQuotasResponse({}));
  }

  async listAccountEcsQuotas(request: ListAccountEcsQuotasRequest): Promise<ListAccountEcsQuotasResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAccountEcsQuotasWithOptions(request, runtime);
  }

  async listServiceSettingsWithOptions(request: ListServiceSettingsRequest, runtime: $Util.RuntimeOptions): Promise<ListServiceSettingsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cloudAssistantDeliverySettings)) {
      query["CloudAssistantDeliverySettings"] = request.cloudAssistantDeliverySettings;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListServiceSettings",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListServiceSettingsResponse>(await this.callApi(params, req, runtime), new ListServiceSettingsResponse({}));
  }

  async listServiceSettings(request: ListServiceSettingsRequest): Promise<ListServiceSettingsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listServiceSettingsWithOptions(request, runtime);
  }

  async modifyCapacityReservationWithOptions(request: ModifyCapacityReservationRequest, runtime: $Util.RuntimeOptions): Promise<ModifyCapacityReservationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.capacityReservationId)) {
      query["CapacityReservationId"] = request.capacityReservationId;
    }

    if (!Util.isUnset(request.instanceCount)) {
      query["InstanceCount"] = request.instanceCount;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.token)) {
      query["Token"] = request.token;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyCapacityReservation",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyCapacityReservationResponse>(await this.callApi(params, req, runtime), new ModifyCapacityReservationResponse({}));
  }

  async modifyCapacityReservation(request: ModifyCapacityReservationRequest): Promise<ModifyCapacityReservationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyCapacityReservationWithOptions(request, runtime);
  }

  async modifyDedicatedHostAttributeWithOptions(request: ModifyDedicatedHostAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDedicatedHostAttributeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.actionOnMaintenance)) {
      query["ActionOnMaintenance"] = request.actionOnMaintenance;
    }

    if (!Util.isUnset(request.autoPlacement)) {
      query["AutoPlacement"] = request.autoPlacement;
    }

    if (!Util.isUnset(request.cpuOverCommitRatio)) {
      query["CpuOverCommitRatio"] = request.cpuOverCommitRatio;
    }

    if (!Util.isUnset(request.dedicatedHostClusterId)) {
      query["DedicatedHostClusterId"] = request.dedicatedHostClusterId;
    }

    if (!Util.isUnset(request.dedicatedHostId)) {
      query["DedicatedHostId"] = request.dedicatedHostId;
    }

    if (!Util.isUnset(request.dedicatedHostName)) {
      query["DedicatedHostName"] = request.dedicatedHostName;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset($tea.toMap(request.networkAttributes))) {
      query["NetworkAttributes"] = request.networkAttributes;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyDedicatedHostAttribute",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyDedicatedHostAttributeResponse>(await this.callApi(params, req, runtime), new ModifyDedicatedHostAttributeResponse({}));
  }

  async modifyDedicatedHostAttribute(request: ModifyDedicatedHostAttributeRequest): Promise<ModifyDedicatedHostAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDedicatedHostAttributeWithOptions(request, runtime);
  }

  async modifyDedicatedHostAutoReleaseTimeWithOptions(request: ModifyDedicatedHostAutoReleaseTimeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDedicatedHostAutoReleaseTimeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.autoReleaseTime)) {
      query["AutoReleaseTime"] = request.autoReleaseTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyDedicatedHostAutoReleaseTime",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyDedicatedHostAutoReleaseTimeResponse>(await this.callApi(params, req, runtime), new ModifyDedicatedHostAutoReleaseTimeResponse({}));
  }

  async modifyDedicatedHostAutoReleaseTime(request: ModifyDedicatedHostAutoReleaseTimeRequest): Promise<ModifyDedicatedHostAutoReleaseTimeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDedicatedHostAutoReleaseTimeWithOptions(request, runtime);
  }

  async modifyDedicatedHostAutoRenewAttributeWithOptions(request: ModifyDedicatedHostAutoRenewAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDedicatedHostAutoRenewAttributeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.autoRenew)) {
      query["AutoRenew"] = request.autoRenew;
    }

    if (!Util.isUnset(request.duration)) {
      query["Duration"] = request.duration;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.periodUnit)) {
      query["PeriodUnit"] = request.periodUnit;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.renewalStatus)) {
      query["RenewalStatus"] = request.renewalStatus;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyDedicatedHostAutoRenewAttribute",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyDedicatedHostAutoRenewAttributeResponse>(await this.callApi(params, req, runtime), new ModifyDedicatedHostAutoRenewAttributeResponse({}));
  }

  async modifyDedicatedHostAutoRenewAttribute(request: ModifyDedicatedHostAutoRenewAttributeRequest): Promise<ModifyDedicatedHostAutoRenewAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDedicatedHostAutoRenewAttributeWithOptions(request, runtime);
  }

  async modifyDedicatedHostClusterAttributeWithOptions(request: ModifyDedicatedHostClusterAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDedicatedHostClusterAttributeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dedicatedHostClusterId)) {
      query["DedicatedHostClusterId"] = request.dedicatedHostClusterId;
    }

    if (!Util.isUnset(request.dedicatedHostClusterName)) {
      query["DedicatedHostClusterName"] = request.dedicatedHostClusterName;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyDedicatedHostClusterAttribute",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyDedicatedHostClusterAttributeResponse>(await this.callApi(params, req, runtime), new ModifyDedicatedHostClusterAttributeResponse({}));
  }

  async modifyDedicatedHostClusterAttribute(request: ModifyDedicatedHostClusterAttributeRequest): Promise<ModifyDedicatedHostClusterAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDedicatedHostClusterAttributeWithOptions(request, runtime);
  }

  async modifyDiagnoseWithOptions(request: ModifyDiagnoseRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDiagnoseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.diagnoseId)) {
      query["DiagnoseId"] = request.diagnoseId;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyDiagnose",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyDiagnoseResponse>(await this.callApi(params, req, runtime), new ModifyDiagnoseResponse({}));
  }

  async modifyDiagnose(request: ModifyDiagnoseRequest): Promise<ModifyDiagnoseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDiagnoseWithOptions(request, runtime);
  }

  async modifyDiskSpecWithOptions(request: ModifyDiskSpecRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDiskSpecResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.autoPay)) {
      query["AutoPay"] = request.autoPay;
    }

    if (!Util.isUnset(request.diskCategory)) {
      query["DiskCategory"] = request.diskCategory;
    }

    if (!Util.isUnset(request.diskId)) {
      query["DiskId"] = request.diskId;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.performanceLevel)) {
      query["PerformanceLevel"] = request.performanceLevel;
    }

    if (!Util.isUnset(request.provisionedIops)) {
      query["ProvisionedIops"] = request.provisionedIops;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyDiskSpec",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyDiskSpecResponse>(await this.callApi(params, req, runtime), new ModifyDiskSpecResponse({}));
  }

  async modifyDiskSpec(request: ModifyDiskSpecRequest): Promise<ModifyDiskSpecResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDiskSpecWithOptions(request, runtime);
  }

  async modifyEniQosGroupWithOptions(request: ModifyEniQosGroupRequest, runtime: $Util.RuntimeOptions): Promise<ModifyEniQosGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.qosGroupName)) {
      query["QosGroupName"] = request.qosGroupName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.rx)) {
      query["Rx"] = request.rx;
    }

    if (!Util.isUnset(request.rxPps)) {
      query["RxPps"] = request.rxPps;
    }

    if (!Util.isUnset(request.tx)) {
      query["Tx"] = request.tx;
    }

    if (!Util.isUnset(request.txPps)) {
      query["TxPps"] = request.txPps;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyEniQosGroup",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyEniQosGroupResponse>(await this.callApi(params, req, runtime), new ModifyEniQosGroupResponse({}));
  }

  async modifyEniQosGroup(request: ModifyEniQosGroupRequest): Promise<ModifyEniQosGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyEniQosGroupWithOptions(request, runtime);
  }

  async modifyImageAdvancedAttributeWithOptions(request: ModifyImageAdvancedAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyImageAdvancedAttributeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.flag)) {
      query["Flag"] = request.flag;
    }

    if (!Util.isUnset(request.imageId)) {
      query["ImageId"] = request.imageId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.supportIoOptimized)) {
      query["SupportIoOptimized"] = request.supportIoOptimized;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyImageAdvancedAttribute",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyImageAdvancedAttributeResponse>(await this.callApi(params, req, runtime), new ModifyImageAdvancedAttributeResponse({}));
  }

  async modifyImageAdvancedAttribute(request: ModifyImageAdvancedAttributeRequest): Promise<ModifyImageAdvancedAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyImageAdvancedAttributeWithOptions(request, runtime);
  }

  async modifyInstanceAutoRebootTimeWithOptions(request: ModifyInstanceAutoRebootTimeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceAutoRebootTimeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.autoRebootTime)) {
      query["AutoRebootTime"] = request.autoRebootTime;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyInstanceAutoRebootTime",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyInstanceAutoRebootTimeResponse>(await this.callApi(params, req, runtime), new ModifyInstanceAutoRebootTimeResponse({}));
  }

  async modifyInstanceAutoRebootTime(request: ModifyInstanceAutoRebootTimeRequest): Promise<ModifyInstanceAutoRebootTimeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceAutoRebootTimeWithOptions(request, runtime);
  }

  async modifyInstanceCapacityReservationAttributesWithOptions(request: ModifyInstanceCapacityReservationAttributesRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceCapacityReservationAttributesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.capacityReservationId)) {
      query["CapacityReservationId"] = request.capacityReservationId;
    }

    if (!Util.isUnset(request.capacityReservationPreference)) {
      query["CapacityReservationPreference"] = request.capacityReservationPreference;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyInstanceCapacityReservationAttributes",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyInstanceCapacityReservationAttributesResponse>(await this.callApi(params, req, runtime), new ModifyInstanceCapacityReservationAttributesResponse({}));
  }

  async modifyInstanceCapacityReservationAttributes(request: ModifyInstanceCapacityReservationAttributesRequest): Promise<ModifyInstanceCapacityReservationAttributesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceCapacityReservationAttributesWithOptions(request, runtime);
  }

  async modifyInstanceChargeTypeWithOptions(request: ModifyInstanceChargeTypeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceChargeTypeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.autoPay)) {
      query["AutoPay"] = request.autoPay;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.couponNo)) {
      query["CouponNo"] = request.couponNo;
    }

    if (!Util.isUnset(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!Util.isUnset(request.includeDataDisks)) {
      query["IncludeDataDisks"] = request.includeDataDisks;
    }

    if (!Util.isUnset(request.instanceChargeType)) {
      query["InstanceChargeType"] = request.instanceChargeType;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.isDetailFee)) {
      query["IsDetailFee"] = request.isDetailFee;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.periodUnit)) {
      query["PeriodUnit"] = request.periodUnit;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyInstanceChargeType",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyInstanceChargeTypeResponse>(await this.callApi(params, req, runtime), new ModifyInstanceChargeTypeResponse({}));
  }

  async modifyInstanceChargeType(request: ModifyInstanceChargeTypeRequest): Promise<ModifyInstanceChargeTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceChargeTypeWithOptions(request, runtime);
  }

  async modifyInstanceDeploymentWithOptions(request: ModifyInstanceDeploymentRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceDeploymentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.affinity)) {
      query["Affinity"] = request.affinity;
    }

    if (!Util.isUnset(request.dedicatedHostClusterId)) {
      query["DedicatedHostClusterId"] = request.dedicatedHostClusterId;
    }

    if (!Util.isUnset(request.dedicatedHostId)) {
      query["DedicatedHostId"] = request.dedicatedHostId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.migrationType)) {
      query["MigrationType"] = request.migrationType;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.tenancy)) {
      query["Tenancy"] = request.tenancy;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyInstanceDeployment",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyInstanceDeploymentResponse>(await this.callApi(params, req, runtime), new ModifyInstanceDeploymentResponse({}));
  }

  async modifyInstanceDeployment(request: ModifyInstanceDeploymentRequest): Promise<ModifyInstanceDeploymentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceDeploymentWithOptions(request, runtime);
  }

  async modifyInstanceMaintenanceAttributesWithOptions(request: ModifyInstanceMaintenanceAttributesRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceMaintenanceAttributesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.actionOnMaintenance)) {
      query["ActionOnMaintenance"] = request.actionOnMaintenance;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.liveMigration)) {
      query["LiveMigration"] = request.liveMigration;
    }

    if (!Util.isUnset(request.maintenanceWindow)) {
      query["MaintenanceWindow"] = request.maintenanceWindow;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyInstanceMaintenanceAttributes",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyInstanceMaintenanceAttributesResponse>(await this.callApi(params, req, runtime), new ModifyInstanceMaintenanceAttributesResponse({}));
  }

  async modifyInstanceMaintenanceAttributes(request: ModifyInstanceMaintenanceAttributesRequest): Promise<ModifyInstanceMaintenanceAttributesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceMaintenanceAttributesWithOptions(request, runtime);
  }

  async modifyMigratableInstancesWithOptions(request: ModifyMigratableInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ModifyMigratableInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.businessMigrationType)) {
      query["BusinessMigrationType"] = request.businessMigrationType;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.networkMigrationType)) {
      query["NetworkMigrationType"] = request.networkMigrationType;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyMigratableInstances",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyMigratableInstancesResponse>(await this.callApi(params, req, runtime), new ModifyMigratableInstancesResponse({}));
  }

  async modifyMigratableInstances(request: ModifyMigratableInstancesRequest): Promise<ModifyMigratableInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyMigratableInstancesWithOptions(request, runtime);
  }

  async modifyMigrationInstancesWithOptions(request: ModifyMigrationInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ModifyMigrationInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.globalMigrationTime)) {
      query["GlobalMigrationTime"] = request.globalMigrationTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.networkMigrationType)) {
      query["NetworkMigrationType"] = request.networkMigrationType;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyMigrationInstances",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyMigrationInstancesResponse>(await this.callApi(params, req, runtime), new ModifyMigrationInstancesResponse({}));
  }

  async modifyMigrationInstances(request: ModifyMigrationInstancesRequest): Promise<ModifyMigrationInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyMigrationInstancesWithOptions(request, runtime);
  }

  async modifyMigrationPlanWithOptions(request: ModifyMigrationPlanRequest, runtime: $Util.RuntimeOptions): Promise<ModifyMigrationPlanResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.migrationPlanId)) {
      query["MigrationPlanId"] = request.migrationPlanId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyMigrationPlan",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyMigrationPlanResponse>(await this.callApi(params, req, runtime), new ModifyMigrationPlanResponse({}));
  }

  async modifyMigrationPlan(request: ModifyMigrationPlanRequest): Promise<ModifyMigrationPlanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyMigrationPlanWithOptions(request, runtime);
  }

  async modifyOrderAutoRebootTimeWithOptions(request: ModifyOrderAutoRebootTimeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyOrderAutoRebootTimeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.autoRebootTime)) {
      query["AutoRebootTime"] = request.autoRebootTime;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyOrderAutoRebootTime",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyOrderAutoRebootTimeResponse>(await this.callApi(params, req, runtime), new ModifyOrderAutoRebootTimeResponse({}));
  }

  async modifyOrderAutoRebootTime(request: ModifyOrderAutoRebootTimeRequest): Promise<ModifyOrderAutoRebootTimeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyOrderAutoRebootTimeWithOptions(request, runtime);
  }

  async modifyPrivatePoolWithOptions(request: ModifyPrivatePoolRequest, runtime: $Util.RuntimeOptions): Promise<ModifyPrivatePoolResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.endTimeType)) {
      query["EndTimeType"] = request.endTimeType;
    }

    if (!Util.isUnset(request.instanceAmount)) {
      query["InstanceAmount"] = request.instanceAmount;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.platform)) {
      query["Platform"] = request.platform;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset($tea.toMap(request.privatePoolOptions))) {
      query["PrivatePoolOptions"] = request.privatePoolOptions;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyPrivatePool",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyPrivatePoolResponse>(await this.callApi(params, req, runtime), new ModifyPrivatePoolResponse({}));
  }

  async modifyPrivatePool(request: ModifyPrivatePoolRequest): Promise<ModifyPrivatePoolResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyPrivatePoolWithOptions(request, runtime);
  }

  async modifyReservationDemandWithOptions(request: ModifyReservationDemandRequest, runtime: $Util.RuntimeOptions): Promise<ModifyReservationDemandResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.confirmType)) {
      query["ConfirmType"] = request.confirmType;
    }

    if (!Util.isUnset(request.couponAuto)) {
      query["CouponAuto"] = request.couponAuto;
    }

    if (!Util.isUnset(request.couponType)) {
      query["CouponType"] = request.couponType;
    }

    if (!Util.isUnset(request.demandId)) {
      query["DemandId"] = request.demandId;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.instanceAmount)) {
      query["InstanceAmount"] = request.instanceAmount;
    }

    if (!Util.isUnset(request.instanceChargeType)) {
      query["InstanceChargeType"] = request.instanceChargeType;
    }

    if (!Util.isUnset(request.instanceCpuCoreCount)) {
      query["InstanceCpuCoreCount"] = request.instanceCpuCoreCount;
    }

    if (!Util.isUnset(request.instanceTypeFamily)) {
      query["InstanceTypeFamily"] = request.instanceTypeFamily;
    }

    if (!Util.isUnset(request.instanceTypes)) {
      query["InstanceTypes"] = request.instanceTypes;
    }

    if (!Util.isUnset(request.matchCriteria)) {
      query["MatchCriteria"] = request.matchCriteria;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.periodUnit)) {
      query["PeriodUnit"] = request.periodUnit;
    }

    if (!Util.isUnset(request.phoneNumber)) {
      query["PhoneNumber"] = request.phoneNumber;
    }

    if (!Util.isUnset(request.platform)) {
      query["Platform"] = request.platform;
    }

    if (!Util.isUnset(request.privatePoolOptions)) {
      query["PrivatePoolOptions"] = request.privatePoolOptions;
    }

    if (!Util.isUnset(request.productType)) {
      query["ProductType"] = request.productType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.reservedInstanceDescription)) {
      query["ReservedInstanceDescription"] = request.reservedInstanceDescription;
    }

    if (!Util.isUnset(request.reservedInstanceGroupId)) {
      query["ReservedInstanceGroupId"] = request.reservedInstanceGroupId;
    }

    if (!Util.isUnset(request.reservedInstanceName)) {
      query["ReservedInstanceName"] = request.reservedInstanceName;
    }

    if (!Util.isUnset(request.reservedInstanceOfferingType)) {
      query["ReservedInstanceOfferingType"] = request.reservedInstanceOfferingType;
    }

    if (!Util.isUnset(request.reservedInstanceScope)) {
      query["ReservedInstanceScope"] = request.reservedInstanceScope;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.resourceSupplyType)) {
      query["ResourceSupplyType"] = request.resourceSupplyType;
    }

    if (!Util.isUnset(request.savingPlanDescription)) {
      query["SavingPlanDescription"] = request.savingPlanDescription;
    }

    if (!Util.isUnset(request.savingPlanHourFee)) {
      query["SavingPlanHourFee"] = request.savingPlanHourFee;
    }

    if (!Util.isUnset(request.savingPlanId)) {
      query["SavingPlanId"] = request.savingPlanId;
    }

    if (!Util.isUnset(request.savingPlanInstanceTypeFamilyGroup)) {
      query["SavingPlanInstanceTypeFamilyGroup"] = request.savingPlanInstanceTypeFamilyGroup;
    }

    if (!Util.isUnset(request.savingPlanName)) {
      query["SavingPlanName"] = request.savingPlanName;
    }

    if (!Util.isUnset(request.savingPlanPayMode)) {
      query["SavingPlanPayMode"] = request.savingPlanPayMode;
    }

    if (!Util.isUnset(request.savingPlanSavingType)) {
      query["SavingPlanSavingType"] = request.savingPlanSavingType;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.zoneIds)) {
      query["ZoneIds"] = request.zoneIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyReservationDemand",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyReservationDemandResponse>(await this.callApi(params, req, runtime), new ModifyReservationDemandResponse({}));
  }

  async modifyReservationDemand(request: ModifyReservationDemandRequest): Promise<ModifyReservationDemandResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyReservationDemandWithOptions(request, runtime);
  }

  async modifyReservedInstanceAttributeWithOptions(request: ModifyReservedInstanceAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyReservedInstanceAttributeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.reservedInstanceId)) {
      query["ReservedInstanceId"] = request.reservedInstanceId;
    }

    if (!Util.isUnset(request.reservedInstanceName)) {
      query["ReservedInstanceName"] = request.reservedInstanceName;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyReservedInstanceAttribute",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyReservedInstanceAttributeResponse>(await this.callApi(params, req, runtime), new ModifyReservedInstanceAttributeResponse({}));
  }

  async modifyReservedInstanceAttribute(request: ModifyReservedInstanceAttributeRequest): Promise<ModifyReservedInstanceAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyReservedInstanceAttributeWithOptions(request, runtime);
  }

  async modifyReservedInstancesWithOptions(request: ModifyReservedInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ModifyReservedInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.configuration)) {
      query["Configuration"] = request.configuration;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.reservedInstanceId)) {
      query["ReservedInstanceId"] = request.reservedInstanceId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyReservedInstances",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyReservedInstancesResponse>(await this.callApi(params, req, runtime), new ModifyReservedInstancesResponse({}));
  }

  async modifyReservedInstances(request: ModifyReservedInstancesRequest): Promise<ModifyReservedInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyReservedInstancesWithOptions(request, runtime);
  }

  async modifyResourceDiagnosisStatusWithOptions(request: ModifyResourceDiagnosisStatusRequest, runtime: $Util.RuntimeOptions): Promise<ModifyResourceDiagnosisStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.diagnosisStatus)) {
      query["DiagnosisStatus"] = request.diagnosisStatus;
    }

    if (!Util.isUnset(request.errorCode)) {
      query["ErrorCode"] = request.errorCode;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.payType)) {
      query["PayType"] = request.payType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyResourceDiagnosisStatus",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyResourceDiagnosisStatusResponse>(await this.callApi(params, req, runtime), new ModifyResourceDiagnosisStatusResponse({}));
  }

  async modifyResourceDiagnosisStatus(request: ModifyResourceDiagnosisStatusRequest): Promise<ModifyResourceDiagnosisStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyResourceDiagnosisStatusWithOptions(request, runtime);
  }

  async modifyResourceMetaWithOptions(request: ModifyResourceMetaRequest, runtime: $Util.RuntimeOptions): Promise<ModifyResourceMetaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.meta)) {
      query["Meta"] = request.meta;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyResourceMeta",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyResourceMetaResponse>(await this.callApi(params, req, runtime), new ModifyResourceMetaResponse({}));
  }

  async modifyResourceMeta(request: ModifyResourceMetaRequest): Promise<ModifyResourceMetaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyResourceMetaWithOptions(request, runtime);
  }

  async modifyStorageSetAttributeWithOptions(request: ModifyStorageSetAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyStorageSetAttributeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.storageSetId)) {
      query["StorageSetId"] = request.storageSetId;
    }

    if (!Util.isUnset(request.storageSetName)) {
      query["StorageSetName"] = request.storageSetName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyStorageSetAttribute",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyStorageSetAttributeResponse>(await this.callApi(params, req, runtime), new ModifyStorageSetAttributeResponse({}));
  }

  async modifyStorageSetAttribute(request: ModifyStorageSetAttributeRequest): Promise<ModifyStorageSetAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyStorageSetAttributeWithOptions(request, runtime);
  }

  async modifyWaitingOrderWithOptions(request: ModifyWaitingOrderRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWaitingOrderResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.instanceAmount)) {
      query["InstanceAmount"] = request.instanceAmount;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.waitingOrderId)) {
      query["WaitingOrderId"] = request.waitingOrderId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWaitingOrder",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWaitingOrderResponse>(await this.callApi(params, req, runtime), new ModifyWaitingOrderResponse({}));
  }

  async modifyWaitingOrder(request: ModifyWaitingOrderRequest): Promise<ModifyWaitingOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWaitingOrderWithOptions(request, runtime);
  }

  async purchaseReservedInstancesOfferingWithOptions(request: PurchaseReservedInstancesOfferingRequest, runtime: $Util.RuntimeOptions): Promise<PurchaseReservedInstancesOfferingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.autoPay)) {
      query["AutoPay"] = request.autoPay;
    }

    if (!Util.isUnset(request.businessInfo)) {
      query["BusinessInfo"] = request.businessInfo;
    }

    if (!Util.isUnset(request.chargeType)) {
      query["ChargeType"] = request.chargeType;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.fromApp)) {
      query["FromApp"] = request.fromApp;
    }

    if (!Util.isUnset(request.instanceAmount)) {
      query["InstanceAmount"] = request.instanceAmount;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.offeringType)) {
      query["OfferingType"] = request.offeringType;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.periodUnit)) {
      query["PeriodUnit"] = request.periodUnit;
    }

    if (!Util.isUnset(request.platform)) {
      query["Platform"] = request.platform;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.reservedInstanceName)) {
      query["ReservedInstanceName"] = request.reservedInstanceName;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.scope)) {
      query["Scope"] = request.scope;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PurchaseReservedInstancesOffering",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PurchaseReservedInstancesOfferingResponse>(await this.callApi(params, req, runtime), new PurchaseReservedInstancesOfferingResponse({}));
  }

  async purchaseReservedInstancesOffering(request: PurchaseReservedInstancesOfferingRequest): Promise<PurchaseReservedInstancesOfferingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.purchaseReservedInstancesOfferingWithOptions(request, runtime);
  }

  async purchaseSavingPlanOfferingWithOptions(request: PurchaseSavingPlanOfferingRequest, runtime: $Util.RuntimeOptions): Promise<PurchaseSavingPlanOfferingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.chargeType)) {
      query["ChargeType"] = request.chargeType;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.committedAmount)) {
      query["CommittedAmount"] = request.committedAmount;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.instanceFamily)) {
      query["InstanceFamily"] = request.instanceFamily;
    }

    if (!Util.isUnset(request.instanceFamilySet)) {
      query["InstanceFamilySet"] = request.instanceFamilySet;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.offeringType)) {
      query["OfferingType"] = request.offeringType;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.periodUnit)) {
      query["PeriodUnit"] = request.periodUnit;
    }

    if (!Util.isUnset(request.planType)) {
      query["PlanType"] = request.planType;
    }

    if (!Util.isUnset(request.purchaseMethod)) {
      query["PurchaseMethod"] = request.purchaseMethod;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PurchaseSavingPlanOffering",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PurchaseSavingPlanOfferingResponse>(await this.callApi(params, req, runtime), new PurchaseSavingPlanOfferingResponse({}));
  }

  async purchaseSavingPlanOffering(request: PurchaseSavingPlanOfferingRequest): Promise<PurchaseSavingPlanOfferingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.purchaseSavingPlanOfferingWithOptions(request, runtime);
  }

  async purchaseStorageCapacityUnitWithOptions(request: PurchaseStorageCapacityUnitRequest, runtime: $Util.RuntimeOptions): Promise<PurchaseStorageCapacityUnitResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.amount)) {
      query["Amount"] = request.amount;
    }

    if (!Util.isUnset(request.capacity)) {
      query["Capacity"] = request.capacity;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.extendParams)) {
      query["ExtendParams"] = request.extendParams;
    }

    if (!Util.isUnset(request.fromApp)) {
      query["FromApp"] = request.fromApp;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.periodUnit)) {
      query["PeriodUnit"] = request.periodUnit;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PurchaseStorageCapacityUnit",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PurchaseStorageCapacityUnitResponse>(await this.callApi(params, req, runtime), new PurchaseStorageCapacityUnitResponse({}));
  }

  async purchaseStorageCapacityUnit(request: PurchaseStorageCapacityUnitRequest): Promise<PurchaseStorageCapacityUnitResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.purchaseStorageCapacityUnitWithOptions(request, runtime);
  }

  async queryEniQosGroupByEniWithOptions(request: QueryEniQosGroupByEniRequest, runtime: $Util.RuntimeOptions): Promise<QueryEniQosGroupByEniResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.networkInterfaceId)) {
      query["NetworkInterfaceId"] = request.networkInterfaceId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEniQosGroupByEni",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEniQosGroupByEniResponse>(await this.callApi(params, req, runtime), new QueryEniQosGroupByEniResponse({}));
  }

  async queryEniQosGroupByEni(request: QueryEniQosGroupByEniRequest): Promise<QueryEniQosGroupByEniResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEniQosGroupByEniWithOptions(request, runtime);
  }

  async queryEniQosGroupByInstanceWithOptions(request: QueryEniQosGroupByInstanceRequest, runtime: $Util.RuntimeOptions): Promise<QueryEniQosGroupByInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEniQosGroupByInstance",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEniQosGroupByInstanceResponse>(await this.callApi(params, req, runtime), new QueryEniQosGroupByInstanceResponse({}));
  }

  async queryEniQosGroupByInstance(request: QueryEniQosGroupByInstanceRequest): Promise<QueryEniQosGroupByInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEniQosGroupByInstanceWithOptions(request, runtime);
  }

  async reAddMigrationTaskInPlanWithOptions(request: ReAddMigrationTaskInPlanRequest, runtime: $Util.RuntimeOptions): Promise<ReAddMigrationTaskInPlanResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.migrationPlanId)) {
      query["MigrationPlanId"] = request.migrationPlanId;
    }

    if (!Util.isUnset(request.migrationTime)) {
      query["MigrationTime"] = request.migrationTime;
    }

    if (!Util.isUnset(request.networkMigrationType)) {
      query["NetworkMigrationType"] = request.networkMigrationType;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ReAddMigrationTaskInPlan",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReAddMigrationTaskInPlanResponse>(await this.callApi(params, req, runtime), new ReAddMigrationTaskInPlanResponse({}));
  }

  async reAddMigrationTaskInPlan(request: ReAddMigrationTaskInPlanRequest): Promise<ReAddMigrationTaskInPlanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reAddMigrationTaskInPlanWithOptions(request, runtime);
  }

  async releaseCapacityReservationWithOptions(request: ReleaseCapacityReservationRequest, runtime: $Util.RuntimeOptions): Promise<ReleaseCapacityReservationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.capacityReservationId)) {
      query["CapacityReservationId"] = request.capacityReservationId;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.token)) {
      query["Token"] = request.token;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ReleaseCapacityReservation",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReleaseCapacityReservationResponse>(await this.callApi(params, req, runtime), new ReleaseCapacityReservationResponse({}));
  }

  async releaseCapacityReservation(request: ReleaseCapacityReservationRequest): Promise<ReleaseCapacityReservationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.releaseCapacityReservationWithOptions(request, runtime);
  }

  async releaseDedicatedHostWithOptions(request: ReleaseDedicatedHostRequest, runtime: $Util.RuntimeOptions): Promise<ReleaseDedicatedHostResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dedicatedHostId)) {
      query["DedicatedHostId"] = request.dedicatedHostId;
    }

    if (!Util.isUnset(request.force)) {
      query["Force"] = request.force;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.token)) {
      query["Token"] = request.token;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ReleaseDedicatedHost",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReleaseDedicatedHostResponse>(await this.callApi(params, req, runtime), new ReleaseDedicatedHostResponse({}));
  }

  async releaseDedicatedHost(request: ReleaseDedicatedHostRequest): Promise<ReleaseDedicatedHostResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.releaseDedicatedHostWithOptions(request, runtime);
  }

  async renewDedicatedHostsWithOptions(request: RenewDedicatedHostsRequest, runtime: $Util.RuntimeOptions): Promise<RenewDedicatedHostsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.businessInfo)) {
      query["BusinessInfo"] = request.businessInfo;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.dedicatedHostIds)) {
      query["DedicatedHostIds"] = request.dedicatedHostIds;
    }

    if (!Util.isUnset(request.fromApp)) {
      query["FromApp"] = request.fromApp;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.periodUnit)) {
      query["PeriodUnit"] = request.periodUnit;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RenewDedicatedHosts",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RenewDedicatedHostsResponse>(await this.callApi(params, req, runtime), new RenewDedicatedHostsResponse({}));
  }

  async renewDedicatedHosts(request: RenewDedicatedHostsRequest): Promise<RenewDedicatedHostsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.renewDedicatedHostsWithOptions(request, runtime);
  }

  async reviewDiagnosticReportWithOptions(request: ReviewDiagnosticReportRequest, runtime: $Util.RuntimeOptions): Promise<ReviewDiagnosticReportResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.category)) {
      query["Category"] = request.category;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceSystem)) {
      query["SourceSystem"] = request.sourceSystem;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ReviewDiagnosticReport",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReviewDiagnosticReportResponse>(await this.callApi(params, req, runtime), new ReviewDiagnosticReportResponse({}));
  }

  async reviewDiagnosticReport(request: ReviewDiagnosticReportRequest): Promise<ReviewDiagnosticReportResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reviewDiagnosticReportWithOptions(request, runtime);
  }

  async runInstancesWithOptions(request: RunInstancesRequest, runtime: $Util.RuntimeOptions): Promise<RunInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.affinity)) {
      query["Affinity"] = request.affinity;
    }

    if (!Util.isUnset(request.autoReleaseTime)) {
      query["AutoReleaseTime"] = request.autoReleaseTime;
    }

    if (!Util.isUnset(request.businessInfo)) {
      query["BusinessInfo"] = request.businessInfo;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.creditSpecification)) {
      query["CreditSpecification"] = request.creditSpecification;
    }

    if (!Util.isUnset(request.dataDisk)) {
      query["DataDisk"] = request.dataDisk;
    }

    if (!Util.isUnset(request.dedicatedHostClusterId)) {
      query["DedicatedHostClusterId"] = request.dedicatedHostClusterId;
    }

    if (!Util.isUnset(request.dedicatedHostId)) {
      query["DedicatedHostId"] = request.dedicatedHostId;
    }

    if (!Util.isUnset(request.defaultVpc)) {
      query["DefaultVpc"] = request.defaultVpc;
    }

    if (!Util.isUnset(request.deletionProtection)) {
      query["DeletionProtection"] = request.deletionProtection;
    }

    if (!Util.isUnset(request.deploymentSetGroupNo)) {
      query["DeploymentSetGroupNo"] = request.deploymentSetGroupNo;
    }

    if (!Util.isUnset(request.deploymentSetId)) {
      query["DeploymentSetId"] = request.deploymentSetId;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!Util.isUnset(request.fromApp)) {
      query["FromApp"] = request.fromApp;
    }

    if (!Util.isUnset(request.hostName)) {
      query["HostName"] = request.hostName;
    }

    if (!Util.isUnset(request.hostNames)) {
      query["HostNames"] = request.hostNames;
    }

    if (!Util.isUnset(request.hpcClusterId)) {
      query["HpcClusterId"] = request.hpcClusterId;
    }

    if (!Util.isUnset(request.httpEndpoint)) {
      query["HttpEndpoint"] = request.httpEndpoint;
    }

    if (!Util.isUnset(request.httpPutResponseHopLimit)) {
      query["HttpPutResponseHopLimit"] = request.httpPutResponseHopLimit;
    }

    if (!Util.isUnset(request.httpTokens)) {
      query["HttpTokens"] = request.httpTokens;
    }

    if (!Util.isUnset(request.imageFamily)) {
      query["ImageFamily"] = request.imageFamily;
    }

    if (!Util.isUnset(request.imageId)) {
      query["ImageId"] = request.imageId;
    }

    if (!Util.isUnset($tea.toMap(request.imageOptions))) {
      query["ImageOptions"] = request.imageOptions;
    }

    if (!Util.isUnset(request.instance)) {
      query["Instance"] = request.instance;
    }

    if (!Util.isUnset(request.instanceName)) {
      query["InstanceName"] = request.instanceName;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.internetChargeType)) {
      query["InternetChargeType"] = request.internetChargeType;
    }

    if (!Util.isUnset(request.internetMaxBandwidthIn)) {
      query["InternetMaxBandwidthIn"] = request.internetMaxBandwidthIn;
    }

    if (!Util.isUnset(request.internetMaxBandwidthOut)) {
      query["InternetMaxBandwidthOut"] = request.internetMaxBandwidthOut;
    }

    if (!Util.isUnset(request.ioOptimized)) {
      query["IoOptimized"] = request.ioOptimized;
    }

    if (!Util.isUnset(request.ipv6Address)) {
      query["Ipv6Address"] = request.ipv6Address;
    }

    if (!Util.isUnset(request.ipv6AddressCount)) {
      query["Ipv6AddressCount"] = request.ipv6AddressCount;
    }

    if (!Util.isUnset(request.isp)) {
      query["Isp"] = request.isp;
    }

    if (!Util.isUnset(request.keyPairName)) {
      query["KeyPairName"] = request.keyPairName;
    }

    if (!Util.isUnset(request.maxAmount)) {
      query["MaxAmount"] = request.maxAmount;
    }

    if (!Util.isUnset(request.minAmount)) {
      query["MinAmount"] = request.minAmount;
    }

    if (!Util.isUnset(request.networkInterface)) {
      query["NetworkInterface"] = request.networkInterface;
    }

    if (!Util.isUnset(request.networkType)) {
      query["NetworkType"] = request.networkType;
    }

    if (!Util.isUnset(request.nodeControllerId)) {
      query["NodeControllerId"] = request.nodeControllerId;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.password)) {
      query["Password"] = request.password;
    }

    if (!Util.isUnset(request.passwordInherit)) {
      query["PasswordInherit"] = request.passwordInherit;
    }

    if (!Util.isUnset(request.privateIpAddress)) {
      query["PrivateIpAddress"] = request.privateIpAddress;
    }

    if (!Util.isUnset(request.ramRoleName)) {
      query["RamRoleName"] = request.ramRoleName;
    }

    if (!Util.isUnset(request.recycleBinResourceId)) {
      query["RecycleBinResourceId"] = request.recycleBinResourceId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.relationOrderId)) {
      query["RelationOrderId"] = request.relationOrderId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.securityEnhancementStrategy)) {
      query["SecurityEnhancementStrategy"] = request.securityEnhancementStrategy;
    }

    if (!Util.isUnset(request.securityGroupId)) {
      query["SecurityGroupId"] = request.securityGroupId;
    }

    if (!Util.isUnset(request.securityGroupIds)) {
      query["SecurityGroupIds"] = request.securityGroupIds;
    }

    if (!Util.isUnset(request.securityGroupRule)) {
      query["SecurityGroupRule"] = request.securityGroupRule;
    }

    if (!Util.isUnset(request.spotDuration)) {
      query["SpotDuration"] = request.spotDuration;
    }

    if (!Util.isUnset(request.spotInterruptionBehavior)) {
      query["SpotInterruptionBehavior"] = request.spotInterruptionBehavior;
    }

    if (!Util.isUnset(request.spotPriceLimit)) {
      query["SpotPriceLimit"] = request.spotPriceLimit;
    }

    if (!Util.isUnset(request.spotStrategy)) {
      query["SpotStrategy"] = request.spotStrategy;
    }

    if (!Util.isUnset(request.storageSetId)) {
      query["StorageSetId"] = request.storageSetId;
    }

    if (!Util.isUnset(request.storageSetPartitionNumber)) {
      query["StorageSetPartitionNumber"] = request.storageSetPartitionNumber;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.tenancy)) {
      query["Tenancy"] = request.tenancy;
    }

    if (!Util.isUnset(request.uniqueSuffix)) {
      query["UniqueSuffix"] = request.uniqueSuffix;
    }

    if (!Util.isUnset(request.userData)) {
      query["UserData"] = request.userData;
    }

    if (!Util.isUnset(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    if (!Util.isUnset($tea.toMap(request.hibernationOptions))) {
      query["HibernationOptions"] = request.hibernationOptions;
    }

    if (!Util.isUnset($tea.toMap(request.privatePoolOptions))) {
      query["PrivatePoolOptions"] = request.privatePoolOptions;
    }

    if (!Util.isUnset($tea.toMap(request.schedulerOptions))) {
      query["SchedulerOptions"] = request.schedulerOptions;
    }

    if (!Util.isUnset($tea.toMap(request.securityOptions))) {
      query["SecurityOptions"] = request.securityOptions;
    }

    if (!Util.isUnset($tea.toMap(request.systemDisk))) {
      query["SystemDisk"] = request.systemDisk;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RunInstances",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RunInstancesResponse>(await this.callApi(params, req, runtime), new RunInstancesResponse({}));
  }

  async runInstances(request: RunInstancesRequest): Promise<RunInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.runInstancesWithOptions(request, runtime);
  }

  async setInstanceAutoReleaseTimeWithOptions(request: SetInstanceAutoReleaseTimeRequest, runtime: $Util.RuntimeOptions): Promise<SetInstanceAutoReleaseTimeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.autoReleaseTime)) {
      query["AutoReleaseTime"] = request.autoReleaseTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetInstanceAutoReleaseTime",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetInstanceAutoReleaseTimeResponse>(await this.callApi(params, req, runtime), new SetInstanceAutoReleaseTimeResponse({}));
  }

  async setInstanceAutoReleaseTime(request: SetInstanceAutoReleaseTimeRequest): Promise<SetInstanceAutoReleaseTimeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setInstanceAutoReleaseTimeWithOptions(request, runtime);
  }

  async startNetworkInsightsAnalysisWithOptions(request: StartNetworkInsightsAnalysisRequest, runtime: $Util.RuntimeOptions): Promise<StartNetworkInsightsAnalysisResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!Util.isUnset(request.networkInsightsPathId)) {
      query["NetworkInsightsPathId"] = request.networkInsightsPathId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StartNetworkInsightsAnalysis",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartNetworkInsightsAnalysisResponse>(await this.callApi(params, req, runtime), new StartNetworkInsightsAnalysisResponse({}));
  }

  async startNetworkInsightsAnalysis(request: StartNetworkInsightsAnalysisRequest): Promise<StartNetworkInsightsAnalysisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startNetworkInsightsAnalysisWithOptions(request, runtime);
  }

  async updateServiceSettingsWithOptions(request: UpdateServiceSettingsRequest, runtime: $Util.RuntimeOptions): Promise<UpdateServiceSettingsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset($tea.toMap(request.cloudAssistantDeliverySettings))) {
      query["CloudAssistantDeliverySettings"] = request.cloudAssistantDeliverySettings;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateServiceSettings",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateServiceSettingsResponse>(await this.callApi(params, req, runtime), new UpdateServiceSettingsResponse({}));
  }

  async updateServiceSettings(request: UpdateServiceSettingsRequest): Promise<UpdateServiceSettingsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateServiceSettingsWithOptions(request, runtime);
  }

  async unmountPEDiskWithOptions(request: UnmountPEDiskRequest, runtime: $Util.RuntimeOptions): Promise<UnmountPEDiskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.category)) {
      query["Category"] = request.category;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceSystem)) {
      query["SourceSystem"] = request.sourceSystem;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "unmountPEDisk",
      version: "2016-03-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UnmountPEDiskResponse>(await this.callApi(params, req, runtime), new UnmountPEDiskResponse({}));
  }

  async unmountPEDisk(request: UnmountPEDiskRequest): Promise<UnmountPEDiskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unmountPEDiskWithOptions(request, runtime);
  }

}
