// This file is auto-generated, don't edit it
import * as $dara from '@darabonba/typescript';
import OpenApi from '@alicloud/openapi-core';
import { OpenApiUtil, $OpenApiUtil }from '@alicloud/openapi-core';


import * as $_model from './models/model';
export * from './models/model';

export default class Client extends OpenApi {

  constructor(config: $OpenApiUtil.Config) {
    super(config);
    this._endpointRule = "regional";
    this._endpointMap = {
      'cn-hangzhou': "vpc.aliyuncs.com",
      'cn-shanghai-finance-1': "vpc.aliyuncs.com",
      'cn-shenzhen-finance-1': "vpc.aliyuncs.com",
      'cn-north-2-gov-1': "vpc.aliyuncs.com",
      'ap-northeast-2-pop': "vpc.aliyuncs.com",
      'cn-beijing-finance-pop': "vpc.aliyuncs.com",
      'cn-beijing-gov-1': "vpc.aliyuncs.com",
      'cn-beijing-nu16-b01': "vpc.aliyuncs.com",
      'cn-edge-1': "vpc-nebula.cn-qingdao-nebula.aliyuncs.com",
      'cn-fujian': "vpc.aliyuncs.com",
      'cn-haidian-cm12-c01': "vpc.aliyuncs.com",
      'cn-hangzhou-bj-b01': "vpc.aliyuncs.com",
      'cn-hangzhou-finance': "vpc.aliyuncs.com",
      'cn-hangzhou-internal-prod-1': "vpc.aliyuncs.com",
      'cn-hangzhou-internal-test-1': "vpc-pre.cn-hangzhou.aliyuncs.com",
      'cn-hangzhou-internal-test-2': "vpc-inner-pre.cn-hangzhou.aliyuncs.com",
      'cn-hangzhou-internal-test-3': "vpc-pre.cn-hangzhou.aliyuncs.com",
      'cn-hangzhou-test-306': "vpc-pre.cn-hangzhou.aliyuncs.com",
      'cn-hongkong-finance-pop': "vpc.aliyuncs.com",
      'cn-huhehaote-nebula-1': "vpc-nebula.cn-qingdao-nebula.aliyuncs.com",
      'cn-qingdao-nebula': "vpc-nebula.cn-qingdao-nebula.aliyuncs.com",
      'cn-shanghai-et15-b01': "vpc-pre.cn-hangzhou.aliyuncs.com",
      'cn-shanghai-et2-b01': "vpc.aliyuncs.com",
      'cn-shanghai-inner': "vpc.aliyuncs.com",
      'cn-shanghai-internal-test-1': "vpc-pre.cn-hangzhou.aliyuncs.com",
      'cn-shenzhen-inner': "vpc.aliyuncs.com",
      'cn-shenzhen-st4-d01': "vpc.aliyuncs.com",
      'cn-shenzhen-su18-b01': "vpc.aliyuncs.com",
      'cn-wuhan': "vpc.aliyuncs.com",
      'cn-yushanfang': "vpc.aliyuncs.com",
      'cn-zhangbei': "vpc.aliyuncs.com",
      'cn-zhangbei-na61-b01': "vpc.aliyuncs.com",
      'cn-zhangjiakou-na62-a01': "vpc.cn-zhangjiakou.aliyuncs.com",
      'cn-zhengzhou-nebula-1': "vpc-nebula.cn-qingdao-nebula.aliyuncs.com",
      'eu-west-1-oxs': "vpc-nebula.cn-shenzhen-cloudstone.aliyuncs.com",
      'rus-west-1-pop': "vpc.aliyuncs.com",
    };
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("vpc", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!$dara.isNull(endpoint)) {
      return endpoint;
    }

    if (!$dara.isNull(endpointMap) && !$dara.isNull(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return OpenApiUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  /**
   * Activates a router interface that is in the Inactive state.
   * 
   * @remarks
   * After you call this operation, the router interface enters the **Activating** state. After the router interface is activated, it enters the **Active** state.
   * >  You cannot activate a router interface that has overdue payments.
   * 
   * @param request - ActivateRouterInterfaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ActivateRouterInterfaceResponse
   */
  async activateRouterInterfaceWithOptions(request: $_model.ActivateRouterInterfaceRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ActivateRouterInterfaceResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routerInterfaceId)) {
      query["RouterInterfaceId"] = request.routerInterfaceId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ActivateRouterInterface",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ActivateRouterInterfaceResponse>(await this.callApi(params, req, runtime), new $_model.ActivateRouterInterfaceResponse({}));
  }

  /**
   * Activates a router interface that is in the Inactive state.
   * 
   * @remarks
   * After you call this operation, the router interface enters the **Activating** state. After the router interface is activated, it enters the **Active** state.
   * >  You cannot activate a router interface that has overdue payments.
   * 
   * @param request - ActivateRouterInterfaceRequest
   * @returns ActivateRouterInterfaceResponse
   */
  async activateRouterInterface(request: $_model.ActivateRouterInterfaceRequest): Promise<$_model.ActivateRouterInterfaceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.activateRouterInterfaceWithOptions(request, runtime);
  }

  /**
   * Enables a flow log. After the flow log is enabled, traffic information about a resource is captured.
   * 
   * @remarks
   *   The **ActiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
   *     *   If the flow log is in the **Activating** state, the flow log is being started.
   *     *   If the flow log is in the **Active** state, the flow log is started.
   * *   You cannot repeatedly call the **ActiveFlowLog** operation to start a flow log within the specified period of time.
   * 
   * @param request - ActiveFlowLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ActiveFlowLogResponse
   */
  async activeFlowLogWithOptions(request: $_model.ActiveFlowLogRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ActiveFlowLogResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.flowLogId)) {
      query["FlowLogId"] = request.flowLogId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ActiveFlowLog",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ActiveFlowLogResponse>(await this.callApi(params, req, runtime), new $_model.ActiveFlowLogResponse({}));
  }

  /**
   * Enables a flow log. After the flow log is enabled, traffic information about a resource is captured.
   * 
   * @remarks
   *   The **ActiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
   *     *   If the flow log is in the **Activating** state, the flow log is being started.
   *     *   If the flow log is in the **Active** state, the flow log is started.
   * *   You cannot repeatedly call the **ActiveFlowLog** operation to start a flow log within the specified period of time.
   * 
   * @param request - ActiveFlowLogRequest
   * @returns ActiveFlowLogResponse
   */
  async activeFlowLog(request: $_model.ActiveFlowLogRequest): Promise<$_model.ActiveFlowLogResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.activeFlowLogWithOptions(request, runtime);
  }

  /**
   * Advertises a Border Gateway Protocol (BGP) network.
   * 
   * @param request - AddBgpNetworkRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddBgpNetworkResponse
   */
  async addBgpNetworkWithOptions(request: $_model.AddBgpNetworkRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AddBgpNetworkResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dstCidrBlock)) {
      query["DstCidrBlock"] = request.dstCidrBlock;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routerId)) {
      query["RouterId"] = request.routerId;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AddBgpNetwork",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AddBgpNetworkResponse>(await this.callApi(params, req, runtime), new $_model.AddBgpNetworkResponse({}));
  }

  /**
   * Advertises a Border Gateway Protocol (BGP) network.
   * 
   * @param request - AddBgpNetworkRequest
   * @returns AddBgpNetworkResponse
   */
  async addBgpNetwork(request: $_model.AddBgpNetworkRequest): Promise<$_model.AddBgpNetworkResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.addBgpNetworkWithOptions(request, runtime);
  }

  /**
   * Associates an elastic IP address (EIP) with an Internet Shared Bandwidth instance.
   * 
   * @remarks
   * Before you call this operation, take note of the following items:
   * *   When you call this operation to associate an EIP with an Internet Shared Bandwidth instance, make sure that the EIP meets the following requirements:
   *     *   The EIP uses the pay-as-you-go billing method.
   *     *   The EIP and the Internet Shared Bandwidth instance belong to the same region.
   *     *   The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
   * *   **AddCommonBandwidthPackageIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the operation.
   *     *   If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
   *     *   If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
   * 
   * @param request - AddCommonBandwidthPackageIpRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddCommonBandwidthPackageIpResponse
   */
  async addCommonBandwidthPackageIpWithOptions(request: $_model.AddCommonBandwidthPackageIpRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AddCommonBandwidthPackageIpResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidthPackageId)) {
      query["BandwidthPackageId"] = request.bandwidthPackageId;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ipInstanceId)) {
      query["IpInstanceId"] = request.ipInstanceId;
    }

    if (!$dara.isNull(request.ipType)) {
      query["IpType"] = request.ipType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AddCommonBandwidthPackageIp",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AddCommonBandwidthPackageIpResponse>(await this.callApi(params, req, runtime), new $_model.AddCommonBandwidthPackageIpResponse({}));
  }

  /**
   * Associates an elastic IP address (EIP) with an Internet Shared Bandwidth instance.
   * 
   * @remarks
   * Before you call this operation, take note of the following items:
   * *   When you call this operation to associate an EIP with an Internet Shared Bandwidth instance, make sure that the EIP meets the following requirements:
   *     *   The EIP uses the pay-as-you-go billing method.
   *     *   The EIP and the Internet Shared Bandwidth instance belong to the same region.
   *     *   The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
   * *   **AddCommonBandwidthPackageIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the operation.
   *     *   If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
   *     *   If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
   * 
   * @param request - AddCommonBandwidthPackageIpRequest
   * @returns AddCommonBandwidthPackageIpResponse
   */
  async addCommonBandwidthPackageIp(request: $_model.AddCommonBandwidthPackageIpRequest): Promise<$_model.AddCommonBandwidthPackageIpResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.addCommonBandwidthPackageIpWithOptions(request, runtime);
  }

  /**
   * Associates multiple elastic IP addresses (EIPs) with an Internet Shared Bandwidth instance.
   * 
   * @remarks
   *   When you call this operation to associate EIPs with an Internet Shared Bandwidth instance, make sure that the EIPs meet the following requirements:
   *     *   The EIPs use the pay-as-you-go billing method.
   *     *   The EIP and the Internet Shared Bandwidth instance belong to the same region.
   *     *   The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
   * *   **AddCommonBandwidthPackageIps** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](~~DescribeCommonBandwidthPackages~~) operation to query the status of the task.
   *     *   If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
   *     *   If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
   * 
   * @param request - AddCommonBandwidthPackageIpsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddCommonBandwidthPackageIpsResponse
   */
  async addCommonBandwidthPackageIpsWithOptions(request: $_model.AddCommonBandwidthPackageIpsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AddCommonBandwidthPackageIpsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidthPackageId)) {
      query["BandwidthPackageId"] = request.bandwidthPackageId;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ipInstanceIds)) {
      query["IpInstanceIds"] = request.ipInstanceIds;
    }

    if (!$dara.isNull(request.ipType)) {
      query["IpType"] = request.ipType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AddCommonBandwidthPackageIps",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AddCommonBandwidthPackageIpsResponse>(await this.callApi(params, req, runtime), new $_model.AddCommonBandwidthPackageIpsResponse({}));
  }

  /**
   * Associates multiple elastic IP addresses (EIPs) with an Internet Shared Bandwidth instance.
   * 
   * @remarks
   *   When you call this operation to associate EIPs with an Internet Shared Bandwidth instance, make sure that the EIPs meet the following requirements:
   *     *   The EIPs use the pay-as-you-go billing method.
   *     *   The EIP and the Internet Shared Bandwidth instance belong to the same region.
   *     *   The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
   * *   **AddCommonBandwidthPackageIps** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](~~DescribeCommonBandwidthPackages~~) operation to query the status of the task.
   *     *   If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
   *     *   If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
   * 
   * @param request - AddCommonBandwidthPackageIpsRequest
   * @returns AddCommonBandwidthPackageIpsResponse
   */
  async addCommonBandwidthPackageIps(request: $_model.AddCommonBandwidthPackageIpsRequest): Promise<$_model.AddCommonBandwidthPackageIpsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.addCommonBandwidthPackageIpsWithOptions(request, runtime);
  }

  /**
   * Associates an elastic IP address (EIP) with a shared-bandwidth Global Accelerator (GA) instance.
   * 
   * @param request - AddGlobalAccelerationInstanceIpRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddGlobalAccelerationInstanceIpResponse
   */
  async addGlobalAccelerationInstanceIpWithOptions(request: $_model.AddGlobalAccelerationInstanceIpRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AddGlobalAccelerationInstanceIpResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.globalAccelerationInstanceId)) {
      query["GlobalAccelerationInstanceId"] = request.globalAccelerationInstanceId;
    }

    if (!$dara.isNull(request.ipInstanceId)) {
      query["IpInstanceId"] = request.ipInstanceId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AddGlobalAccelerationInstanceIp",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AddGlobalAccelerationInstanceIpResponse>(await this.callApi(params, req, runtime), new $_model.AddGlobalAccelerationInstanceIpResponse({}));
  }

  /**
   * Associates an elastic IP address (EIP) with a shared-bandwidth Global Accelerator (GA) instance.
   * 
   * @param request - AddGlobalAccelerationInstanceIpRequest
   * @returns AddGlobalAccelerationInstanceIpResponse
   */
  async addGlobalAccelerationInstanceIp(request: $_model.AddGlobalAccelerationInstanceIpRequest): Promise<$_model.AddGlobalAccelerationInstanceIpResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.addGlobalAccelerationInstanceIpWithOptions(request, runtime);
  }

  /**
   * Adds an IP entry to an access control list (ACL).
   * 
   * @deprecated OpenAPI AddIPv6TranslatorAclListEntry is deprecated
   * 
   * @param request - AddIPv6TranslatorAclListEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddIPv6TranslatorAclListEntryResponse
   */
  async addIPv6TranslatorAclListEntryWithOptions(request: $_model.AddIPv6TranslatorAclListEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AddIPv6TranslatorAclListEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.aclEntryComment)) {
      query["AclEntryComment"] = request.aclEntryComment;
    }

    if (!$dara.isNull(request.aclEntryIp)) {
      query["AclEntryIp"] = request.aclEntryIp;
    }

    if (!$dara.isNull(request.aclId)) {
      query["AclId"] = request.aclId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AddIPv6TranslatorAclListEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AddIPv6TranslatorAclListEntryResponse>(await this.callApi(params, req, runtime), new $_model.AddIPv6TranslatorAclListEntryResponse({}));
  }

  /**
   * Adds an IP entry to an access control list (ACL).
   * 
   * @deprecated OpenAPI AddIPv6TranslatorAclListEntry is deprecated
   * 
   * @param request - AddIPv6TranslatorAclListEntryRequest
   * @returns AddIPv6TranslatorAclListEntryResponse
   */
  // Deprecated
  async addIPv6TranslatorAclListEntry(request: $_model.AddIPv6TranslatorAclListEntryRequest): Promise<$_model.AddIPv6TranslatorAclListEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.addIPv6TranslatorAclListEntryWithOptions(request, runtime);
  }

  /**
   * Adds a CIDR block to an IP address pool.
   * 
   * @remarks
   * Before you call this operation, take note of the following limits:
   * *   The CIDR block and the IP address pool must belong to the same region.
   * *   The CIDR block and the IP address pool must use the same line type.
   * *   **AddPublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
   *     *   If the CIDR block is in the **Modifying** state, the CIDR block is being added. In this state, you can only query the CIDR block and cannot perform other operations.
   *     *   If the CIDR block is in the **Created** state, the CIDR block is added.
   * *   You cannot repeatedly call the **AddPublicIpAddressPoolCidrBlock** operation to add a CIDR block to an IP address pool within the specified period of time.
   * 
   * @param request - AddPublicIpAddressPoolCidrBlockRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddPublicIpAddressPoolCidrBlockResponse
   */
  async addPublicIpAddressPoolCidrBlockWithOptions(request: $_model.AddPublicIpAddressPoolCidrBlockRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AddPublicIpAddressPoolCidrBlockResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.cidrBlock)) {
      query["CidrBlock"] = request.cidrBlock;
    }

    if (!$dara.isNull(request.cidrMask)) {
      query["CidrMask"] = request.cidrMask;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.publicIpAddressPoolId)) {
      query["PublicIpAddressPoolId"] = request.publicIpAddressPoolId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AddPublicIpAddressPoolCidrBlock",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AddPublicIpAddressPoolCidrBlockResponse>(await this.callApi(params, req, runtime), new $_model.AddPublicIpAddressPoolCidrBlockResponse({}));
  }

  /**
   * Adds a CIDR block to an IP address pool.
   * 
   * @remarks
   * Before you call this operation, take note of the following limits:
   * *   The CIDR block and the IP address pool must belong to the same region.
   * *   The CIDR block and the IP address pool must use the same line type.
   * *   **AddPublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
   *     *   If the CIDR block is in the **Modifying** state, the CIDR block is being added. In this state, you can only query the CIDR block and cannot perform other operations.
   *     *   If the CIDR block is in the **Created** state, the CIDR block is added.
   * *   You cannot repeatedly call the **AddPublicIpAddressPoolCidrBlock** operation to add a CIDR block to an IP address pool within the specified period of time.
   * 
   * @param request - AddPublicIpAddressPoolCidrBlockRequest
   * @returns AddPublicIpAddressPoolCidrBlockResponse
   */
  async addPublicIpAddressPoolCidrBlock(request: $_model.AddPublicIpAddressPoolCidrBlockRequest): Promise<$_model.AddPublicIpAddressPoolCidrBlockResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.addPublicIpAddressPoolCidrBlockWithOptions(request, runtime);
  }

  /**
   * Adds a traffic mirror source to a traffic mirror session.
   * 
   * @remarks
   *   **AddSourcesToTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
   *     *   If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being added to the traffic mirror session.
   *     *   If the traffic mirror session is in the **Created** state, the traffic mirror source is added to the traffic mirror session.
   * *   You cannot repeatedly call the **AddSourcesToTrafficMirrorSession** operation to add a traffic mirror source to a traffic mirror session within the specified period of time.
   * 
   * @param request - AddSourcesToTrafficMirrorSessionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddSourcesToTrafficMirrorSessionResponse
   */
  async addSourcesToTrafficMirrorSessionWithOptions(request: $_model.AddSourcesToTrafficMirrorSessionRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AddSourcesToTrafficMirrorSessionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.trafficMirrorSessionId)) {
      query["TrafficMirrorSessionId"] = request.trafficMirrorSessionId;
    }

    if (!$dara.isNull(request.trafficMirrorSourceIds)) {
      query["TrafficMirrorSourceIds"] = request.trafficMirrorSourceIds;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AddSourcesToTrafficMirrorSession",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AddSourcesToTrafficMirrorSessionResponse>(await this.callApi(params, req, runtime), new $_model.AddSourcesToTrafficMirrorSessionResponse({}));
  }

  /**
   * Adds a traffic mirror source to a traffic mirror session.
   * 
   * @remarks
   *   **AddSourcesToTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
   *     *   If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being added to the traffic mirror session.
   *     *   If the traffic mirror session is in the **Created** state, the traffic mirror source is added to the traffic mirror session.
   * *   You cannot repeatedly call the **AddSourcesToTrafficMirrorSession** operation to add a traffic mirror source to a traffic mirror session within the specified period of time.
   * 
   * @param request - AddSourcesToTrafficMirrorSessionRequest
   * @returns AddSourcesToTrafficMirrorSessionResponse
   */
  async addSourcesToTrafficMirrorSession(request: $_model.AddSourcesToTrafficMirrorSessionRequest): Promise<$_model.AddSourcesToTrafficMirrorSessionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.addSourcesToTrafficMirrorSessionWithOptions(request, runtime);
  }

  /**
   * Applies for an elastic IP address (EIP).
   * 
   * @remarks
   * Before you call this operation, make sure that you are familiar with the billing methods and pricing of EIPs. For more information, see [Billing overview](https://help.aliyun.com/document_detail/122035.html).
   * After you call this operation, the system randomly allocates an EIP that is in the **Available** state in the specified region. EIPs support only the ICMP, TCP, and UDP transport layer protocols. The IGMP and SCTP protocols are not supported.
   * 
   * @param request - AllocateEipAddressRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AllocateEipAddressResponse
   */
  async allocateEipAddressWithOptions(request: $_model.AllocateEipAddressRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AllocateEipAddressResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.activityId)) {
      query["ActivityId"] = request.activityId;
    }

    if (!$dara.isNull(request.autoPay)) {
      query["AutoPay"] = request.autoPay;
    }

    if (!$dara.isNull(request.bandwidth)) {
      query["Bandwidth"] = request.bandwidth;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.ISP)) {
      query["ISP"] = request.ISP;
    }

    if (!$dara.isNull(request.instanceChargeType)) {
      query["InstanceChargeType"] = request.instanceChargeType;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.internetChargeType)) {
      query["InternetChargeType"] = request.internetChargeType;
    }

    if (!$dara.isNull(request.ipAddress)) {
      query["IpAddress"] = request.ipAddress;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.netmode)) {
      query["Netmode"] = request.netmode;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.period)) {
      query["Period"] = request.period;
    }

    if (!$dara.isNull(request.pricingCycle)) {
      query["PricingCycle"] = request.pricingCycle;
    }

    if (!$dara.isNull(request.publicIpAddressPoolId)) {
      query["PublicIpAddressPoolId"] = request.publicIpAddressPoolId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.securityProtectionTypes)) {
      query["SecurityProtectionTypes"] = request.securityProtectionTypes;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.zone)) {
      query["Zone"] = request.zone;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AllocateEipAddress",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AllocateEipAddressResponse>(await this.callApi(params, req, runtime), new $_model.AllocateEipAddressResponse({}));
  }

  /**
   * Applies for an elastic IP address (EIP).
   * 
   * @remarks
   * Before you call this operation, make sure that you are familiar with the billing methods and pricing of EIPs. For more information, see [Billing overview](https://help.aliyun.com/document_detail/122035.html).
   * After you call this operation, the system randomly allocates an EIP that is in the **Available** state in the specified region. EIPs support only the ICMP, TCP, and UDP transport layer protocols. The IGMP and SCTP protocols are not supported.
   * 
   * @param request - AllocateEipAddressRequest
   * @returns AllocateEipAddressResponse
   */
  async allocateEipAddress(request: $_model.AllocateEipAddressRequest): Promise<$_model.AllocateEipAddressResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.allocateEipAddressWithOptions(request, runtime);
  }

  /**
   * Requests a specified elastic IP address (EIP).
   * 
   * @param request - AllocateEipAddressProRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AllocateEipAddressProResponse
   */
  async allocateEipAddressProWithOptions(request: $_model.AllocateEipAddressProRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AllocateEipAddressProResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.autoPay)) {
      query["AutoPay"] = request.autoPay;
    }

    if (!$dara.isNull(request.bandwidth)) {
      query["Bandwidth"] = request.bandwidth;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ISP)) {
      query["ISP"] = request.ISP;
    }

    if (!$dara.isNull(request.instanceChargeType)) {
      query["InstanceChargeType"] = request.instanceChargeType;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.internetChargeType)) {
      query["InternetChargeType"] = request.internetChargeType;
    }

    if (!$dara.isNull(request.ipAddress)) {
      query["IpAddress"] = request.ipAddress;
    }

    if (!$dara.isNull(request.netmode)) {
      query["Netmode"] = request.netmode;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.period)) {
      query["Period"] = request.period;
    }

    if (!$dara.isNull(request.pricingCycle)) {
      query["PricingCycle"] = request.pricingCycle;
    }

    if (!$dara.isNull(request.publicIpAddressPoolId)) {
      query["PublicIpAddressPoolId"] = request.publicIpAddressPoolId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.securityProtectionTypes)) {
      query["SecurityProtectionTypes"] = request.securityProtectionTypes;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AllocateEipAddressPro",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AllocateEipAddressProResponse>(await this.callApi(params, req, runtime), new $_model.AllocateEipAddressProResponse({}));
  }

  /**
   * Requests a specified elastic IP address (EIP).
   * 
   * @param request - AllocateEipAddressProRequest
   * @returns AllocateEipAddressProResponse
   */
  async allocateEipAddressPro(request: $_model.AllocateEipAddressProRequest): Promise<$_model.AllocateEipAddressProResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.allocateEipAddressProWithOptions(request, runtime);
  }

  /**
   * Applies for contiguous elastic IP addresses (EIPs).
   * 
   * @remarks
   * *AllocateEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns the ID of a contiguous EIP group and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
   * *   If the contiguous EIP group is in the **Allocating** state, the EIPs are being allocated. In this case, you can only perform the query operation and cannot perform other operations.
   * *   If the contiguous EIP group is in the **Allocated** state, the EIPs are allocated.
   * 
   * @deprecated OpenAPI AllocateEipSegmentAddress is deprecated
   * 
   * @param request - AllocateEipSegmentAddressRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AllocateEipSegmentAddressResponse
   */
  async allocateEipSegmentAddressWithOptions(request: $_model.AllocateEipSegmentAddressRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AllocateEipSegmentAddressResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidth)) {
      query["Bandwidth"] = request.bandwidth;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.eipMask)) {
      query["EipMask"] = request.eipMask;
    }

    if (!$dara.isNull(request.internetChargeType)) {
      query["InternetChargeType"] = request.internetChargeType;
    }

    if (!$dara.isNull(request.isp)) {
      query["Isp"] = request.isp;
    }

    if (!$dara.isNull(request.netmode)) {
      query["Netmode"] = request.netmode;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.zone)) {
      query["Zone"] = request.zone;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AllocateEipSegmentAddress",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AllocateEipSegmentAddressResponse>(await this.callApi(params, req, runtime), new $_model.AllocateEipSegmentAddressResponse({}));
  }

  /**
   * Applies for contiguous elastic IP addresses (EIPs).
   * 
   * @remarks
   * *AllocateEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns the ID of a contiguous EIP group and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
   * *   If the contiguous EIP group is in the **Allocating** state, the EIPs are being allocated. In this case, you can only perform the query operation and cannot perform other operations.
   * *   If the contiguous EIP group is in the **Allocated** state, the EIPs are allocated.
   * 
   * @deprecated OpenAPI AllocateEipSegmentAddress is deprecated
   * 
   * @param request - AllocateEipSegmentAddressRequest
   * @returns AllocateEipSegmentAddressResponse
   */
  // Deprecated
  async allocateEipSegmentAddress(request: $_model.AllocateEipSegmentAddressRequest): Promise<$_model.AllocateEipSegmentAddressResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.allocateEipSegmentAddressWithOptions(request, runtime);
  }

  /**
   * Assigns an IPv6 address.
   * 
   * @param request - AllocateIpv6AddressRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AllocateIpv6AddressResponse
   */
  async allocateIpv6AddressWithOptions(request: $_model.AllocateIpv6AddressRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AllocateIpv6AddressResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.addressType)) {
      query["AddressType"] = request.addressType;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ipv6Address)) {
      query["Ipv6Address"] = request.ipv6Address;
    }

    if (!$dara.isNull(request.ipv6AddressDescription)) {
      query["Ipv6AddressDescription"] = request.ipv6AddressDescription;
    }

    if (!$dara.isNull(request.ipv6AddressName)) {
      query["Ipv6AddressName"] = request.ipv6AddressName;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AllocateIpv6Address",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AllocateIpv6AddressResponse>(await this.callApi(params, req, runtime), new $_model.AllocateIpv6AddressResponse({}));
  }

  /**
   * Assigns an IPv6 address.
   * 
   * @param request - AllocateIpv6AddressRequest
   * @returns AllocateIpv6AddressResponse
   */
  async allocateIpv6Address(request: $_model.AllocateIpv6AddressRequest): Promise<$_model.AllocateIpv6AddressResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.allocateIpv6AddressWithOptions(request, runtime);
  }

  /**
   * Default IPv6 gateways support only private communication. You can call the AllocateIpv6InternetBandwidth operation to purchase Internet bandwidth resources for an IPv6 address. This way, ECS instances in a VPC can access the Internet through the IPv6 address. IPv6 clients can also access the ECS instances over the Internet.
   * 
   * @remarks
   *   Before you call this operation, make sure that an ECS instance that supports IPv6 is created in a VPC that has an IPv6 CIDR block. For more information, see [Create a VPC with an IPv6 CIDR block](https://help.aliyun.com/document_detail/100540.html).
   * *   You cannot repeatedly call **AllocateIpv6InternetBandwidth** within the specified period of time.
   * 
   * @param request - AllocateIpv6InternetBandwidthRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AllocateIpv6InternetBandwidthResponse
   */
  async allocateIpv6InternetBandwidthWithOptions(request: $_model.AllocateIpv6InternetBandwidthRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AllocateIpv6InternetBandwidthResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidth)) {
      query["Bandwidth"] = request.bandwidth;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.internetChargeType)) {
      query["InternetChargeType"] = request.internetChargeType;
    }

    if (!$dara.isNull(request.ipv6AddressId)) {
      query["Ipv6AddressId"] = request.ipv6AddressId;
    }

    if (!$dara.isNull(request.ipv6GatewayId)) {
      query["Ipv6GatewayId"] = request.ipv6GatewayId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AllocateIpv6InternetBandwidth",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AllocateIpv6InternetBandwidthResponse>(await this.callApi(params, req, runtime), new $_model.AllocateIpv6InternetBandwidthResponse({}));
  }

  /**
   * Default IPv6 gateways support only private communication. You can call the AllocateIpv6InternetBandwidth operation to purchase Internet bandwidth resources for an IPv6 address. This way, ECS instances in a VPC can access the Internet through the IPv6 address. IPv6 clients can also access the ECS instances over the Internet.
   * 
   * @remarks
   *   Before you call this operation, make sure that an ECS instance that supports IPv6 is created in a VPC that has an IPv6 CIDR block. For more information, see [Create a VPC with an IPv6 CIDR block](https://help.aliyun.com/document_detail/100540.html).
   * *   You cannot repeatedly call **AllocateIpv6InternetBandwidth** within the specified period of time.
   * 
   * @param request - AllocateIpv6InternetBandwidthRequest
   * @returns AllocateIpv6InternetBandwidthResponse
   */
  async allocateIpv6InternetBandwidth(request: $_model.AllocateIpv6InternetBandwidthRequest): Promise<$_model.AllocateIpv6InternetBandwidthResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.allocateIpv6InternetBandwidthWithOptions(request, runtime);
  }

  /**
   * Reserves an IPv6 CIDR block.
   * 
   * @remarks
   * # [](#)
   * The following section describes how to allocate an IPv6 CIDR block to a virtual private cloud (VPC):
   * 1.  Call the AllocateVpcIpv6Cidr operation to reserve the IPv6 CIDR block.
   * 2.  To allocate an IPv6 CIDR block to an existing VPC, call the [AssociateVpcCidrBlock](https://help.aliyun.com/document_detail/146745.html) operation. Set **RegionId**, **VpcId**, and **IPv6CidrBlock** to the IPv6 CIDR bock, and set **IpVersion** to **ipv6**. To allocate an IPv6 CIDR block when you create a VPC, call the [CreateVpc](https://help.aliyun.com/document_detail/35737.html) operation. Set **RegionId** and **Ipv6CidrBlock** to the IPv6 CIDR block, and set **EnableIpv6** to **true**.
   * 
   * @param request - AllocateVpcIpv6CidrRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AllocateVpcIpv6CidrResponse
   */
  async allocateVpcIpv6CidrWithOptions(request: $_model.AllocateVpcIpv6CidrRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AllocateVpcIpv6CidrResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.addressPoolType)) {
      query["AddressPoolType"] = request.addressPoolType;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ipv6CidrBlock)) {
      query["Ipv6CidrBlock"] = request.ipv6CidrBlock;
    }

    if (!$dara.isNull(request.ipv6Isp)) {
      query["Ipv6Isp"] = request.ipv6Isp;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AllocateVpcIpv6Cidr",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AllocateVpcIpv6CidrResponse>(await this.callApi(params, req, runtime), new $_model.AllocateVpcIpv6CidrResponse({}));
  }

  /**
   * Reserves an IPv6 CIDR block.
   * 
   * @remarks
   * # [](#)
   * The following section describes how to allocate an IPv6 CIDR block to a virtual private cloud (VPC):
   * 1.  Call the AllocateVpcIpv6Cidr operation to reserve the IPv6 CIDR block.
   * 2.  To allocate an IPv6 CIDR block to an existing VPC, call the [AssociateVpcCidrBlock](https://help.aliyun.com/document_detail/146745.html) operation. Set **RegionId**, **VpcId**, and **IPv6CidrBlock** to the IPv6 CIDR bock, and set **IpVersion** to **ipv6**. To allocate an IPv6 CIDR block when you create a VPC, call the [CreateVpc](https://help.aliyun.com/document_detail/35737.html) operation. Set **RegionId** and **Ipv6CidrBlock** to the IPv6 CIDR block, and set **EnableIpv6** to **true**.
   * 
   * @param request - AllocateVpcIpv6CidrRequest
   * @returns AllocateVpcIpv6CidrResponse
   */
  async allocateVpcIpv6Cidr(request: $_model.AllocateVpcIpv6CidrRequest): Promise<$_model.AllocateVpcIpv6CidrResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.allocateVpcIpv6CidrWithOptions(request, runtime);
  }

  /**
   * Applies for a Letter of Authorization (LOA) for an Express Connect circuit.
   * 
   * @param request - ApplyPhysicalConnectionLOARequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ApplyPhysicalConnectionLOAResponse
   */
  async applyPhysicalConnectionLOAWithOptions(request: $_model.ApplyPhysicalConnectionLOARequest, runtime: $dara.RuntimeOptions): Promise<$_model.ApplyPhysicalConnectionLOAResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidth)) {
      query["Bandwidth"] = request.bandwidth;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.companyName)) {
      query["CompanyName"] = request.companyName;
    }

    if (!$dara.isNull(request.constructionTime)) {
      query["ConstructionTime"] = request.constructionTime;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.lineType)) {
      query["LineType"] = request.lineType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.PMInfo)) {
      query["PMInfo"] = request.PMInfo;
    }

    if (!$dara.isNull(request.peerLocation)) {
      query["PeerLocation"] = request.peerLocation;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.si)) {
      query["Si"] = request.si;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ApplyPhysicalConnectionLOA",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ApplyPhysicalConnectionLOAResponse>(await this.callApi(params, req, runtime), new $_model.ApplyPhysicalConnectionLOAResponse({}));
  }

  /**
   * Applies for a Letter of Authorization (LOA) for an Express Connect circuit.
   * 
   * @param request - ApplyPhysicalConnectionLOARequest
   * @returns ApplyPhysicalConnectionLOAResponse
   */
  async applyPhysicalConnectionLOA(request: $_model.ApplyPhysicalConnectionLOARequest): Promise<$_model.ApplyPhysicalConnectionLOAResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.applyPhysicalConnectionLOAWithOptions(request, runtime);
  }

  /**
   * Associates an elastic IP address (EIP) with an instance in the same region.
   * 
   * @remarks
   *   You can associate an EIP with an Elastic Compute Service (ECS) instance, a Classic Load Balancer (CLB) instance, a secondary elastic network interface (ENI), a NAT gateway, or a high-availability virtual IP address (HAVIP) in the same region. The ECS instance and CLB instance must be deployed in a virtual private cloud (VPC).
   * *   **AssociateEipAddress** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
   *     *   If the EIP is in the **Associating** state, the EIP is being associated. In this state, you can only query the EIP and cannot perform other operations.
   *     *   If the EIP is in the **InUse** state, the EIP is associated.
   * *   You cannot call the **AssociateEipAddress** operation to associate an EIP with multiple instances at a time.
   * 
   * @param request - AssociateEipAddressRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AssociateEipAddressResponse
   */
  async associateEipAddressWithOptions(request: $_model.AssociateEipAddressRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AssociateEipAddressResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.allocationId)) {
      query["AllocationId"] = request.allocationId;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.instanceRegionId)) {
      query["InstanceRegionId"] = request.instanceRegionId;
    }

    if (!$dara.isNull(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!$dara.isNull(request.mode)) {
      query["Mode"] = request.mode;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.privateIpAddress)) {
      query["PrivateIpAddress"] = request.privateIpAddress;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AssociateEipAddress",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AssociateEipAddressResponse>(await this.callApi(params, req, runtime), new $_model.AssociateEipAddressResponse({}));
  }

  /**
   * Associates an elastic IP address (EIP) with an instance in the same region.
   * 
   * @remarks
   *   You can associate an EIP with an Elastic Compute Service (ECS) instance, a Classic Load Balancer (CLB) instance, a secondary elastic network interface (ENI), a NAT gateway, or a high-availability virtual IP address (HAVIP) in the same region. The ECS instance and CLB instance must be deployed in a virtual private cloud (VPC).
   * *   **AssociateEipAddress** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
   *     *   If the EIP is in the **Associating** state, the EIP is being associated. In this state, you can only query the EIP and cannot perform other operations.
   *     *   If the EIP is in the **InUse** state, the EIP is associated.
   * *   You cannot call the **AssociateEipAddress** operation to associate an EIP with multiple instances at a time.
   * 
   * @param request - AssociateEipAddressRequest
   * @returns AssociateEipAddressResponse
   */
  async associateEipAddress(request: $_model.AssociateEipAddressRequest): Promise<$_model.AssociateEipAddressResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.associateEipAddressWithOptions(request, runtime);
  }

  /**
   * Associates multiple elastic IP addresses (EIPs) with an instance in the same region.
   * 
   * @remarks
   *   You can call the **AssociateEipAddressBatch** operation to associate EIPs with an instance in the same region. The instance must be a NAT gateway or a secondary elastic network interface (ENI). For more information about how to associate EIPs with other instances, see [AssociateEipAddress](https://help.aliyun.com/document_detail/120195.html).
   * *   **AssociateEipAddressBatch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
   *     *   If the EIP is in the **Associating** state, the EIP is being associated. You can only query the EIP and cannot perform other operations.
   *     *   If the EIP is in the **InUse** state, the EIP is associated.
   * *   You cannot call the **AssociateEipAddressBatch** operation to associate an EIP with multiple instances at a time.
   * 
   * @param request - AssociateEipAddressBatchRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AssociateEipAddressBatchResponse
   */
  async associateEipAddressBatchWithOptions(request: $_model.AssociateEipAddressBatchRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AssociateEipAddressBatchResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bindedInstanceId)) {
      query["BindedInstanceId"] = request.bindedInstanceId;
    }

    if (!$dara.isNull(request.bindedInstanceType)) {
      query["BindedInstanceType"] = request.bindedInstanceType;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!$dara.isNull(request.mode)) {
      query["Mode"] = request.mode;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AssociateEipAddressBatch",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AssociateEipAddressBatchResponse>(await this.callApi(params, req, runtime), new $_model.AssociateEipAddressBatchResponse({}));
  }

  /**
   * Associates multiple elastic IP addresses (EIPs) with an instance in the same region.
   * 
   * @remarks
   *   You can call the **AssociateEipAddressBatch** operation to associate EIPs with an instance in the same region. The instance must be a NAT gateway or a secondary elastic network interface (ENI). For more information about how to associate EIPs with other instances, see [AssociateEipAddress](https://help.aliyun.com/document_detail/120195.html).
   * *   **AssociateEipAddressBatch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
   *     *   If the EIP is in the **Associating** state, the EIP is being associated. You can only query the EIP and cannot perform other operations.
   *     *   If the EIP is in the **InUse** state, the EIP is associated.
   * *   You cannot call the **AssociateEipAddressBatch** operation to associate an EIP with multiple instances at a time.
   * 
   * @param request - AssociateEipAddressBatchRequest
   * @returns AssociateEipAddressBatchResponse
   */
  async associateEipAddressBatch(request: $_model.AssociateEipAddressBatchRequest): Promise<$_model.AssociateEipAddressBatchResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.associateEipAddressBatchWithOptions(request, runtime);
  }

  /**
   * Associates a high-availability virtual IP address (HaVip) with an Elastic Compute Service (ECS) instance or an elastic network interface (ENI).
   * 
   * @remarks
   * When you call this operation, take note of the following limits:
   * *   An HaVip immediately takes effect after it is associated. You do not need to restart the ECS instance. However, you must associate the HaVip with the ENI of the ECS instance.
   * *   The HaVip and ECS instance must belong to the same vSwitch.
   * *   You can associate an HaVip with at most two ECS instances.
   * *   The ECS instance must be in the **Running** or **Stopped** state.
   * *   The HaVip must be in the **Available** or **InUse** state.
   * *   The **AssociateHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
   *     *   If the HaVip is in the **Associating** state, the HaVip is being associated.
   *     *   If the HaVip is in the **InUse** state, the HaVip is associated.
   * *   You cannot repeatedly call the **AssociateHaVip** operation to associate an HaVip within the specified period of time.
   * 
   * @param request - AssociateHaVipRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AssociateHaVipResponse
   */
  async associateHaVipWithOptions(request: $_model.AssociateHaVipRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AssociateHaVipResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.haVipId)) {
      query["HaVipId"] = request.haVipId;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AssociateHaVip",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AssociateHaVipResponse>(await this.callApi(params, req, runtime), new $_model.AssociateHaVipResponse({}));
  }

  /**
   * Associates a high-availability virtual IP address (HaVip) with an Elastic Compute Service (ECS) instance or an elastic network interface (ENI).
   * 
   * @remarks
   * When you call this operation, take note of the following limits:
   * *   An HaVip immediately takes effect after it is associated. You do not need to restart the ECS instance. However, you must associate the HaVip with the ENI of the ECS instance.
   * *   The HaVip and ECS instance must belong to the same vSwitch.
   * *   You can associate an HaVip with at most two ECS instances.
   * *   The ECS instance must be in the **Running** or **Stopped** state.
   * *   The HaVip must be in the **Available** or **InUse** state.
   * *   The **AssociateHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
   *     *   If the HaVip is in the **Associating** state, the HaVip is being associated.
   *     *   If the HaVip is in the **InUse** state, the HaVip is associated.
   * *   You cannot repeatedly call the **AssociateHaVip** operation to associate an HaVip within the specified period of time.
   * 
   * @param request - AssociateHaVipRequest
   * @returns AssociateHaVipResponse
   */
  async associateHaVip(request: $_model.AssociateHaVipRequest): Promise<$_model.AssociateHaVipResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.associateHaVipWithOptions(request, runtime);
  }

  /**
   * Associates a network access control list (ACL) with a vSwitch.
   * 
   * @remarks
   * ## [](#)Description
   * *   **AssociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
   *     *   If the network ACL is in the **BINDING** state, the network ACL is being associated.
   *     *   If the network ACL is in the **BINDED** state, the network ACL is associated.
   * *   You cannot repeatedly call the **AssociateNetworkAcl** operation to associate a network ACL within the specified period of time.
   * 
   * @param request - AssociateNetworkAclRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AssociateNetworkAclResponse
   */
  async associateNetworkAclWithOptions(request: $_model.AssociateNetworkAclRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AssociateNetworkAclResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.networkAclId)) {
      query["NetworkAclId"] = request.networkAclId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resource)) {
      query["Resource"] = request.resource;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AssociateNetworkAcl",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AssociateNetworkAclResponse>(await this.callApi(params, req, runtime), new $_model.AssociateNetworkAclResponse({}));
  }

  /**
   * Associates a network access control list (ACL) with a vSwitch.
   * 
   * @remarks
   * ## [](#)Description
   * *   **AssociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
   *     *   If the network ACL is in the **BINDING** state, the network ACL is being associated.
   *     *   If the network ACL is in the **BINDED** state, the network ACL is associated.
   * *   You cannot repeatedly call the **AssociateNetworkAcl** operation to associate a network ACL within the specified period of time.
   * 
   * @param request - AssociateNetworkAclRequest
   * @returns AssociateNetworkAclResponse
   */
  async associateNetworkAcl(request: $_model.AssociateNetworkAclRequest): Promise<$_model.AssociateNetworkAclResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.associateNetworkAclWithOptions(request, runtime);
  }

  /**
   * Associates a virtual border router (VBR) with a specified Express Connect circuit.
   * 
   * @param request - AssociatePhysicalConnectionToVirtualBorderRouterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AssociatePhysicalConnectionToVirtualBorderRouterResponse
   */
  async associatePhysicalConnectionToVirtualBorderRouterWithOptions(request: $_model.AssociatePhysicalConnectionToVirtualBorderRouterRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AssociatePhysicalConnectionToVirtualBorderRouterResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.circuitCode)) {
      query["CircuitCode"] = request.circuitCode;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.enableIpv6)) {
      query["EnableIpv6"] = request.enableIpv6;
    }

    if (!$dara.isNull(request.localGatewayIp)) {
      query["LocalGatewayIp"] = request.localGatewayIp;
    }

    if (!$dara.isNull(request.localIpv6GatewayIp)) {
      query["LocalIpv6GatewayIp"] = request.localIpv6GatewayIp;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.peerGatewayIp)) {
      query["PeerGatewayIp"] = request.peerGatewayIp;
    }

    if (!$dara.isNull(request.peerIpv6GatewayIp)) {
      query["PeerIpv6GatewayIp"] = request.peerIpv6GatewayIp;
    }

    if (!$dara.isNull(request.peeringIpv6SubnetMask)) {
      query["PeeringIpv6SubnetMask"] = request.peeringIpv6SubnetMask;
    }

    if (!$dara.isNull(request.peeringSubnetMask)) {
      query["PeeringSubnetMask"] = request.peeringSubnetMask;
    }

    if (!$dara.isNull(request.physicalConnectionId)) {
      query["PhysicalConnectionId"] = request.physicalConnectionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vbrId)) {
      query["VbrId"] = request.vbrId;
    }

    if (!$dara.isNull(request.vlanId)) {
      query["VlanId"] = request.vlanId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AssociatePhysicalConnectionToVirtualBorderRouter",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AssociatePhysicalConnectionToVirtualBorderRouterResponse>(await this.callApi(params, req, runtime), new $_model.AssociatePhysicalConnectionToVirtualBorderRouterResponse({}));
  }

  /**
   * Associates a virtual border router (VBR) with a specified Express Connect circuit.
   * 
   * @param request - AssociatePhysicalConnectionToVirtualBorderRouterRequest
   * @returns AssociatePhysicalConnectionToVirtualBorderRouterResponse
   */
  async associatePhysicalConnectionToVirtualBorderRouter(request: $_model.AssociatePhysicalConnectionToVirtualBorderRouterRequest): Promise<$_model.AssociatePhysicalConnectionToVirtualBorderRouterResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.associatePhysicalConnectionToVirtualBorderRouterWithOptions(request, runtime);
  }

  /**
   * Associates a custom route table with a vSwitch in the same VPC.
   * 
   * @remarks
   * *AssociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
   * *   If the vSwitch is in the **Pending** state, the route table is being associated with the vSwitch.
   * *   If the vSwitch is in the **Available** state, the route table is associated with the vSwitch.
   * 
   * @param request - AssociateRouteTableRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AssociateRouteTableResponse
   */
  async associateRouteTableWithOptions(request: $_model.AssociateRouteTableRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AssociateRouteTableResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeTableId)) {
      query["RouteTableId"] = request.routeTableId;
    }

    if (!$dara.isNull(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AssociateRouteTable",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AssociateRouteTableResponse>(await this.callApi(params, req, runtime), new $_model.AssociateRouteTableResponse({}));
  }

  /**
   * Associates a custom route table with a vSwitch in the same VPC.
   * 
   * @remarks
   * *AssociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
   * *   If the vSwitch is in the **Pending** state, the route table is being associated with the vSwitch.
   * *   If the vSwitch is in the **Available** state, the route table is associated with the vSwitch.
   * 
   * @param request - AssociateRouteTableRequest
   * @returns AssociateRouteTableResponse
   */
  async associateRouteTable(request: $_model.AssociateRouteTableRequest): Promise<$_model.AssociateRouteTableResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.associateRouteTableWithOptions(request, runtime);
  }

  /**
   * Associates a gateway route table with an IPv4 gateway in the same virtual private cloud (VPC).
   * 
   * @param request - AssociateRouteTableWithGatewayRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AssociateRouteTableWithGatewayResponse
   */
  async associateRouteTableWithGatewayWithOptions(request: $_model.AssociateRouteTableWithGatewayRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AssociateRouteTableWithGatewayResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!$dara.isNull(request.gatewayType)) {
      query["GatewayType"] = request.gatewayType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeTableId)) {
      query["RouteTableId"] = request.routeTableId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AssociateRouteTableWithGateway",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AssociateRouteTableWithGatewayResponse>(await this.callApi(params, req, runtime), new $_model.AssociateRouteTableWithGatewayResponse({}));
  }

  /**
   * Associates a gateway route table with an IPv4 gateway in the same virtual private cloud (VPC).
   * 
   * @param request - AssociateRouteTableWithGatewayRequest
   * @returns AssociateRouteTableWithGatewayResponse
   */
  async associateRouteTableWithGateway(request: $_model.AssociateRouteTableWithGatewayRequest): Promise<$_model.AssociateRouteTableWithGatewayResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.associateRouteTableWithGatewayWithOptions(request, runtime);
  }

  /**
   * Associates a route table with a gateway endpoint.
   * 
   * @remarks
   * When you call this operation, take note of the following limits:
   * *   The gateway endpoint to be associated with the route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
   * *   The route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
   * *   The gateway endpoint and route table must belong to the same virtual private cloud (VPC).
   * *   The route table cannot be shared.
   * *   You cannot associate a gateway endpoint with a virtual border router (VBR) route table.
   * *   You can associate a gateway endpoint with at most 20 route tables at a time.
   * *   **AssociateRouteTablesWithVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query whether a route table is associated with a gateway endpoint.
   *     *   If the **Associating** status is returned, the route table is being associated with the gateway endpoint.
   *     *   If the **Created** status is returned, the route table is associated with the gateway endpoint.
   * *   You cannot repeatedly call the **AssociateRouteTablesWithVpcGatewayEndpoint** operation within a specific period of time.
   * 
   * @param request - AssociateRouteTablesWithVpcGatewayEndpointRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AssociateRouteTablesWithVpcGatewayEndpointResponse
   */
  async associateRouteTablesWithVpcGatewayEndpointWithOptions(request: $_model.AssociateRouteTablesWithVpcGatewayEndpointRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AssociateRouteTablesWithVpcGatewayEndpointResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.endpointId)) {
      query["EndpointId"] = request.endpointId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeTableIds)) {
      query["RouteTableIds"] = request.routeTableIds;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AssociateRouteTablesWithVpcGatewayEndpoint",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AssociateRouteTablesWithVpcGatewayEndpointResponse>(await this.callApi(params, req, runtime), new $_model.AssociateRouteTablesWithVpcGatewayEndpointResponse({}));
  }

  /**
   * Associates a route table with a gateway endpoint.
   * 
   * @remarks
   * When you call this operation, take note of the following limits:
   * *   The gateway endpoint to be associated with the route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
   * *   The route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
   * *   The gateway endpoint and route table must belong to the same virtual private cloud (VPC).
   * *   The route table cannot be shared.
   * *   You cannot associate a gateway endpoint with a virtual border router (VBR) route table.
   * *   You can associate a gateway endpoint with at most 20 route tables at a time.
   * *   **AssociateRouteTablesWithVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query whether a route table is associated with a gateway endpoint.
   *     *   If the **Associating** status is returned, the route table is being associated with the gateway endpoint.
   *     *   If the **Created** status is returned, the route table is associated with the gateway endpoint.
   * *   You cannot repeatedly call the **AssociateRouteTablesWithVpcGatewayEndpoint** operation within a specific period of time.
   * 
   * @param request - AssociateRouteTablesWithVpcGatewayEndpointRequest
   * @returns AssociateRouteTablesWithVpcGatewayEndpointResponse
   */
  async associateRouteTablesWithVpcGatewayEndpoint(request: $_model.AssociateRouteTablesWithVpcGatewayEndpointRequest): Promise<$_model.AssociateRouteTablesWithVpcGatewayEndpointResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.associateRouteTablesWithVpcGatewayEndpointWithOptions(request, runtime);
  }

  /**
   * Adds a secondary CIDR block to a virtual private cloud (VPC).
   * 
   * @remarks
   * ## [](#)
   * *   Take note of the following limits:
   *     *   Each VPC can contain up to five secondary IPv4 CIDR blocks.
   *     *   Each VPC can contain up to five secondary IPv6 CIDR blocks.
   * *   You cannot repeatedly call the **AssociateVpcCidrBlock** operation to add secondary CIDR blocks to a VPC within the specified period of time.
   * 
   * @param request - AssociateVpcCidrBlockRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AssociateVpcCidrBlockResponse
   */
  async associateVpcCidrBlockWithOptions(request: $_model.AssociateVpcCidrBlockRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AssociateVpcCidrBlockResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.IPv6CidrBlock)) {
      query["IPv6CidrBlock"] = request.IPv6CidrBlock;
    }

    if (!$dara.isNull(request.ipVersion)) {
      query["IpVersion"] = request.ipVersion;
    }

    if (!$dara.isNull(request.ipamPoolId)) {
      query["IpamPoolId"] = request.ipamPoolId;
    }

    if (!$dara.isNull(request.ipv6CidrMask)) {
      query["Ipv6CidrMask"] = request.ipv6CidrMask;
    }

    if (!$dara.isNull(request.ipv6Isp)) {
      query["Ipv6Isp"] = request.ipv6Isp;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.secondaryCidrBlock)) {
      query["SecondaryCidrBlock"] = request.secondaryCidrBlock;
    }

    if (!$dara.isNull(request.secondaryCidrMask)) {
      query["SecondaryCidrMask"] = request.secondaryCidrMask;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AssociateVpcCidrBlock",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AssociateVpcCidrBlockResponse>(await this.callApi(params, req, runtime), new $_model.AssociateVpcCidrBlockResponse({}));
  }

  /**
   * Adds a secondary CIDR block to a virtual private cloud (VPC).
   * 
   * @remarks
   * ## [](#)
   * *   Take note of the following limits:
   *     *   Each VPC can contain up to five secondary IPv4 CIDR blocks.
   *     *   Each VPC can contain up to five secondary IPv6 CIDR blocks.
   * *   You cannot repeatedly call the **AssociateVpcCidrBlock** operation to add secondary CIDR blocks to a VPC within the specified period of time.
   * 
   * @param request - AssociateVpcCidrBlockRequest
   * @returns AssociateVpcCidrBlockResponse
   */
  async associateVpcCidrBlock(request: $_model.AssociateVpcCidrBlockRequest): Promise<$_model.AssociateVpcCidrBlockResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.associateVpcCidrBlockWithOptions(request, runtime);
  }

  /**
   * Associates a VPN gateway with a certificate.
   * 
   * @remarks
   * Before you associate a VPN gateway with an SSL certificate, take note of the following items:
   * *   You can associate only VPN gateways of the ShangMi (SM) type with SSL certificates. You need to associate a VPN gateway of the SM type with two SSL certificates, one as the encryption certificate and the other as the signature certificate.
   * *   The SSL certificates must use the SM algorithm.
   * *   You cannot specify one SSL certificate as both the encryption certificate and signature certificate for one VPN gateway.
   * *   **AssociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the SSL certificate is being associated.
   *     *   If the VPN gateway is in the **active** state, the SSL certificate is being associated.
   * *   You cannot call **AssociateVpnGatewayWithCertificate** within a specific period of time.
   * ### [](#)Prerequisites
   * Make sure that you have two SSL certificates that use the SM algorithm in the Certificate Management Service console. For more information about SSL certificates, see [What is Certificate Management Service?](https://help.aliyun.com/document_detail/28535.html).
   * 
   * @param request - AssociateVpnGatewayWithCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AssociateVpnGatewayWithCertificateResponse
   */
  async associateVpnGatewayWithCertificateWithOptions(request: $_model.AssociateVpnGatewayWithCertificateRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AssociateVpnGatewayWithCertificateResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.certificateId)) {
      query["CertificateId"] = request.certificateId;
    }

    if (!$dara.isNull(request.certificateType)) {
      query["CertificateType"] = request.certificateType;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AssociateVpnGatewayWithCertificate",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AssociateVpnGatewayWithCertificateResponse>(await this.callApi(params, req, runtime), new $_model.AssociateVpnGatewayWithCertificateResponse({}));
  }

  /**
   * Associates a VPN gateway with a certificate.
   * 
   * @remarks
   * Before you associate a VPN gateway with an SSL certificate, take note of the following items:
   * *   You can associate only VPN gateways of the ShangMi (SM) type with SSL certificates. You need to associate a VPN gateway of the SM type with two SSL certificates, one as the encryption certificate and the other as the signature certificate.
   * *   The SSL certificates must use the SM algorithm.
   * *   You cannot specify one SSL certificate as both the encryption certificate and signature certificate for one VPN gateway.
   * *   **AssociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the SSL certificate is being associated.
   *     *   If the VPN gateway is in the **active** state, the SSL certificate is being associated.
   * *   You cannot call **AssociateVpnGatewayWithCertificate** within a specific period of time.
   * ### [](#)Prerequisites
   * Make sure that you have two SSL certificates that use the SM algorithm in the Certificate Management Service console. For more information about SSL certificates, see [What is Certificate Management Service?](https://help.aliyun.com/document_detail/28535.html).
   * 
   * @param request - AssociateVpnGatewayWithCertificateRequest
   * @returns AssociateVpnGatewayWithCertificateResponse
   */
  async associateVpnGatewayWithCertificate(request: $_model.AssociateVpnGatewayWithCertificateRequest): Promise<$_model.AssociateVpnGatewayWithCertificateResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.associateVpnGatewayWithCertificateWithOptions(request, runtime);
  }

  /**
   * @remarks
   *   The **AttachDhcpOptionsSetToVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
   *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being associated.
   *     *   If the DHCP options set is in the **InUse** state, the DHCP options set is associated.
   * *   You cannot repeatedly call the **AttachDhcpOptionsSetToVpc** operation to associate DHCP options sets with a VPC within the specified period of time.
   * 
   * @param request - AttachDhcpOptionsSetToVpcRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AttachDhcpOptionsSetToVpcResponse
   */
  async attachDhcpOptionsSetToVpcWithOptions(request: $_model.AttachDhcpOptionsSetToVpcRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AttachDhcpOptionsSetToVpcResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dhcpOptionsSetId)) {
      query["DhcpOptionsSetId"] = request.dhcpOptionsSetId;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AttachDhcpOptionsSetToVpc",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AttachDhcpOptionsSetToVpcResponse>(await this.callApi(params, req, runtime), new $_model.AttachDhcpOptionsSetToVpcResponse({}));
  }

  /**
   * @remarks
   *   The **AttachDhcpOptionsSetToVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
   *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being associated.
   *     *   If the DHCP options set is in the **InUse** state, the DHCP options set is associated.
   * *   You cannot repeatedly call the **AttachDhcpOptionsSetToVpc** operation to associate DHCP options sets with a VPC within the specified period of time.
   * 
   * @param request - AttachDhcpOptionsSetToVpcRequest
   * @returns AttachDhcpOptionsSetToVpcResponse
   */
  async attachDhcpOptionsSetToVpc(request: $_model.AttachDhcpOptionsSetToVpcRequest): Promise<$_model.AttachDhcpOptionsSetToVpcResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.attachDhcpOptionsSetToVpcWithOptions(request, runtime);
  }

  /**
   * Associates a virtual border router (VBR) with a hosted connection.
   * 
   * @param request - AttachVbrToVpconnRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AttachVbrToVpconnResponse
   */
  async attachVbrToVpconnWithOptions(request: $_model.AttachVbrToVpconnRequest, runtime: $dara.RuntimeOptions): Promise<$_model.AttachVbrToVpconnResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.token)) {
      query["Token"] = request.token;
    }

    if (!$dara.isNull(request.vbrId)) {
      query["VbrId"] = request.vbrId;
    }

    if (!$dara.isNull(request.vpconnId)) {
      query["VpconnId"] = request.vpconnId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "AttachVbrToVpconn",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.AttachVbrToVpconnResponse>(await this.callApi(params, req, runtime), new $_model.AttachVbrToVpconnResponse({}));
  }

  /**
   * Associates a virtual border router (VBR) with a hosted connection.
   * 
   * @param request - AttachVbrToVpconnRequest
   * @returns AttachVbrToVpconnResponse
   */
  async attachVbrToVpconn(request: $_model.AttachVbrToVpconnRequest): Promise<$_model.AttachVbrToVpconnResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.attachVbrToVpconnWithOptions(request, runtime);
  }

  /**
   * Cancels the maximum bandwidth configured for an elastic IP address (EIP) that is associated with an Internet Shared Bandwidth instance.
   * 
   * @remarks
   * Before you call this operation, take note of the following items:
   * *   After this operation is performed, the maximum bandwidth of the EIP equals that of the Internet Shared Bandwidth instance.
   * *   You cannot repeatedly call the **CancelCommonBandwidthPackageIpBandwidth** operation within a specific time period.
   * 
   * @param request - CancelCommonBandwidthPackageIpBandwidthRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CancelCommonBandwidthPackageIpBandwidthResponse
   */
  async cancelCommonBandwidthPackageIpBandwidthWithOptions(request: $_model.CancelCommonBandwidthPackageIpBandwidthRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CancelCommonBandwidthPackageIpBandwidthResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidthPackageId)) {
      query["BandwidthPackageId"] = request.bandwidthPackageId;
    }

    if (!$dara.isNull(request.eipId)) {
      query["EipId"] = request.eipId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CancelCommonBandwidthPackageIpBandwidth",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CancelCommonBandwidthPackageIpBandwidthResponse>(await this.callApi(params, req, runtime), new $_model.CancelCommonBandwidthPackageIpBandwidthResponse({}));
  }

  /**
   * Cancels the maximum bandwidth configured for an elastic IP address (EIP) that is associated with an Internet Shared Bandwidth instance.
   * 
   * @remarks
   * Before you call this operation, take note of the following items:
   * *   After this operation is performed, the maximum bandwidth of the EIP equals that of the Internet Shared Bandwidth instance.
   * *   You cannot repeatedly call the **CancelCommonBandwidthPackageIpBandwidth** operation within a specific time period.
   * 
   * @param request - CancelCommonBandwidthPackageIpBandwidthRequest
   * @returns CancelCommonBandwidthPackageIpBandwidthResponse
   */
  async cancelCommonBandwidthPackageIpBandwidth(request: $_model.CancelCommonBandwidthPackageIpBandwidthRequest): Promise<$_model.CancelCommonBandwidthPackageIpBandwidthResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.cancelCommonBandwidthPackageIpBandwidthWithOptions(request, runtime);
  }

  /**
   * Cancels an Express Connect circuit before it is enabled. After you perform this operation, the Express Connect circuit enters the Canceled state.
   * 
   * @remarks
   * You can cancel only an Express Connect circuit that is in the **Initial**, **Approved**, **Allocated**, or **Confirmed** state.
   * 
   * @param request - CancelPhysicalConnectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CancelPhysicalConnectionResponse
   */
  async cancelPhysicalConnectionWithOptions(request: $_model.CancelPhysicalConnectionRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CancelPhysicalConnectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.physicalConnectionId)) {
      query["PhysicalConnectionId"] = request.physicalConnectionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CancelPhysicalConnection",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CancelPhysicalConnectionResponse>(await this.callApi(params, req, runtime), new $_model.CancelPhysicalConnectionResponse({}));
  }

  /**
   * Cancels an Express Connect circuit before it is enabled. After you perform this operation, the Express Connect circuit enters the Canceled state.
   * 
   * @remarks
   * You can cancel only an Express Connect circuit that is in the **Initial**, **Approved**, **Allocated**, or **Confirmed** state.
   * 
   * @param request - CancelPhysicalConnectionRequest
   * @returns CancelPhysicalConnectionResponse
   */
  async cancelPhysicalConnection(request: $_model.CancelPhysicalConnectionRequest): Promise<$_model.CancelPhysicalConnectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.cancelPhysicalConnectionWithOptions(request, runtime);
  }

  /**
   * Moves an Express Connect circuit to a new resource group.
   * 
   * @remarks
   * ## [](#)
   * You cannot repeatedly call the **ChangeResourceGroup** operation to modify the resource group of the same Express Connect circuit.
   * 
   * @param request - ChangeResourceGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ChangeResourceGroupResponse
   */
  async changeResourceGroupWithOptions(request: $_model.ChangeResourceGroupRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ChangeResourceGroupResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.newResourceGroupId)) {
      query["NewResourceGroupId"] = request.newResourceGroupId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!$dara.isNull(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ChangeResourceGroup",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ChangeResourceGroupResponse>(await this.callApi(params, req, runtime), new $_model.ChangeResourceGroupResponse({}));
  }

  /**
   * Moves an Express Connect circuit to a new resource group.
   * 
   * @remarks
   * ## [](#)
   * You cannot repeatedly call the **ChangeResourceGroup** operation to modify the resource group of the same Express Connect circuit.
   * 
   * @param request - ChangeResourceGroupRequest
   * @returns ChangeResourceGroupResponse
   */
  async changeResourceGroup(request: $_model.ChangeResourceGroupRequest): Promise<$_model.ChangeResourceGroupResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.changeResourceGroupWithOptions(request, runtime);
  }

  /**
   * Checks whether a private IP address in a specified vSwitch is available.
   * 
   * @param request - CheckCanAllocateVpcPrivateIpAddressRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CheckCanAllocateVpcPrivateIpAddressResponse
   */
  async checkCanAllocateVpcPrivateIpAddressWithOptions(request: $_model.CheckCanAllocateVpcPrivateIpAddressRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CheckCanAllocateVpcPrivateIpAddressResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ipVersion)) {
      query["IpVersion"] = request.ipVersion;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.privateIpAddress)) {
      query["PrivateIpAddress"] = request.privateIpAddress;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CheckCanAllocateVpcPrivateIpAddress",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CheckCanAllocateVpcPrivateIpAddressResponse>(await this.callApi(params, req, runtime), new $_model.CheckCanAllocateVpcPrivateIpAddressResponse({}));
  }

  /**
   * Checks whether a private IP address in a specified vSwitch is available.
   * 
   * @param request - CheckCanAllocateVpcPrivateIpAddressRequest
   * @returns CheckCanAllocateVpcPrivateIpAddressResponse
   */
  async checkCanAllocateVpcPrivateIpAddress(request: $_model.CheckCanAllocateVpcPrivateIpAddressRequest): Promise<$_model.CheckCanAllocateVpcPrivateIpAddressResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.checkCanAllocateVpcPrivateIpAddressWithOptions(request, runtime);
  }

  /**
   * Checks whether the region of an IPsec-VPN connection supports BGP.
   * 
   * @param request - CheckVpnBgpEnabledRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CheckVpnBgpEnabledResponse
   */
  async checkVpnBgpEnabledWithOptions(request: $_model.CheckVpnBgpEnabledRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CheckVpnBgpEnabledResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CheckVpnBgpEnabled",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CheckVpnBgpEnabledResponse>(await this.callApi(params, req, runtime), new $_model.CheckVpnBgpEnabledResponse({}));
  }

  /**
   * Checks whether the region of an IPsec-VPN connection supports BGP.
   * 
   * @param request - CheckVpnBgpEnabledRequest
   * @returns CheckVpnBgpEnabledResponse
   */
  async checkVpnBgpEnabled(request: $_model.CheckVpnBgpEnabledRequest): Promise<$_model.CheckVpnBgpEnabledResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.checkVpnBgpEnabledWithOptions(request, runtime);
  }

  /**
   * Generates a report for an installed Express Connect circuit.
   * 
   * @param request - CompletePhysicalConnectionLOARequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CompletePhysicalConnectionLOAResponse
   */
  async completePhysicalConnectionLOAWithOptions(request: $_model.CompletePhysicalConnectionLOARequest, runtime: $dara.RuntimeOptions): Promise<$_model.CompletePhysicalConnectionLOAResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.finishWork)) {
      query["FinishWork"] = request.finishWork;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.lineCode)) {
      query["LineCode"] = request.lineCode;
    }

    if (!$dara.isNull(request.lineLabel)) {
      query["LineLabel"] = request.lineLabel;
    }

    if (!$dara.isNull(request.lineSPContactInfo)) {
      query["LineSPContactInfo"] = request.lineSPContactInfo;
    }

    if (!$dara.isNull(request.lineServiceProvider)) {
      query["LineServiceProvider"] = request.lineServiceProvider;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CompletePhysicalConnectionLOA",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CompletePhysicalConnectionLOAResponse>(await this.callApi(params, req, runtime), new $_model.CompletePhysicalConnectionLOAResponse({}));
  }

  /**
   * Generates a report for an installed Express Connect circuit.
   * 
   * @param request - CompletePhysicalConnectionLOARequest
   * @returns CompletePhysicalConnectionLOAResponse
   */
  async completePhysicalConnectionLOA(request: $_model.CompletePhysicalConnectionLOARequest): Promise<$_model.CompletePhysicalConnectionLOAResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.completePhysicalConnectionLOAWithOptions(request, runtime);
  }

  /**
   * Changes the status of an Express Connect circuit to Confirmed.
   * 
   * @param request - ConfirmPhysicalConnectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ConfirmPhysicalConnectionResponse
   */
  async confirmPhysicalConnectionWithOptions(request: $_model.ConfirmPhysicalConnectionRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ConfirmPhysicalConnectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.physicalConnectionId)) {
      query["PhysicalConnectionId"] = request.physicalConnectionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ConfirmPhysicalConnection",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ConfirmPhysicalConnectionResponse>(await this.callApi(params, req, runtime), new $_model.ConfirmPhysicalConnectionResponse({}));
  }

  /**
   * Changes the status of an Express Connect circuit to Confirmed.
   * 
   * @param request - ConfirmPhysicalConnectionRequest
   * @returns ConfirmPhysicalConnectionResponse
   */
  async confirmPhysicalConnection(request: $_model.ConfirmPhysicalConnectionRequest): Promise<$_model.ConfirmPhysicalConnectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.confirmPhysicalConnectionWithOptions(request, runtime);
  }

  /**
   * Initiates a connection from the router interface of an initiator to the router interface of an accepter.
   * 
   * @remarks
   * After you call this operation, the router interface enters the **Connecting** state. When the connection is established, it enters the **Active** state.
   * When you call this operation, take note of the following items:
   * *   Only an initiator router interface in the **Idle** state can initiate a connection.
   * *   You can create only one pair of connected router interfaces between two routers.
   * *   You cannot initiate a connection if your Alibaba Cloud account has a router interface with overdue payments.
   * 
   * @param request - ConnectRouterInterfaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ConnectRouterInterfaceResponse
   */
  async connectRouterInterfaceWithOptions(request: $_model.ConnectRouterInterfaceRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ConnectRouterInterfaceResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routerInterfaceId)) {
      query["RouterInterfaceId"] = request.routerInterfaceId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ConnectRouterInterface",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ConnectRouterInterfaceResponse>(await this.callApi(params, req, runtime), new $_model.ConnectRouterInterfaceResponse({}));
  }

  /**
   * Initiates a connection from the router interface of an initiator to the router interface of an accepter.
   * 
   * @remarks
   * After you call this operation, the router interface enters the **Connecting** state. When the connection is established, it enters the **Active** state.
   * When you call this operation, take note of the following items:
   * *   Only an initiator router interface in the **Idle** state can initiate a connection.
   * *   You can create only one pair of connected router interfaces between two routers.
   * *   You cannot initiate a connection if your Alibaba Cloud account has a router interface with overdue payments.
   * 
   * @param request - ConnectRouterInterfaceRequest
   * @returns ConnectRouterInterfaceResponse
   */
  async connectRouterInterface(request: $_model.ConnectRouterInterfaceRequest): Promise<$_model.ConnectRouterInterfaceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.connectRouterInterfaceWithOptions(request, runtime);
  }

  /**
   * Converts a NAT service plan to an Internet Shared Bandwidth instance.
   * 
   * @remarks
   * Before you convert a NAT service plan to an Internet Shared Bandwidth instance, take note of the following limits:
   * *   You are not charged for the conversion.
   * *   When you convert a NAT service plan to an Internet Shared Bandwidth instance, you can continue to use the SNAT and DNAT features of the NAT gateway, and your workloads are not affected. However, we recommend that you convert your NAT service plan during off-peak hours.
   * *   After the NAT service plan is converted to an Internet Shared Bandwidth instance, the public IP addresses in the NAT service plan are converted to elastic IP addresses (EIPs). The maximum bandwidth and billing method of the Internet Shared Bandwidth instance are the same as those of the NAT service plan.
   * 
   * @deprecated OpenAPI ConvertBandwidthPackage is deprecated
   * 
   * @param request - ConvertBandwidthPackageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ConvertBandwidthPackageResponse
   */
  async convertBandwidthPackageWithOptions(request: $_model.ConvertBandwidthPackageRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ConvertBandwidthPackageResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidthPackageId)) {
      query["BandwidthPackageId"] = request.bandwidthPackageId;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ConvertBandwidthPackage",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ConvertBandwidthPackageResponse>(await this.callApi(params, req, runtime), new $_model.ConvertBandwidthPackageResponse({}));
  }

  /**
   * Converts a NAT service plan to an Internet Shared Bandwidth instance.
   * 
   * @remarks
   * Before you convert a NAT service plan to an Internet Shared Bandwidth instance, take note of the following limits:
   * *   You are not charged for the conversion.
   * *   When you convert a NAT service plan to an Internet Shared Bandwidth instance, you can continue to use the SNAT and DNAT features of the NAT gateway, and your workloads are not affected. However, we recommend that you convert your NAT service plan during off-peak hours.
   * *   After the NAT service plan is converted to an Internet Shared Bandwidth instance, the public IP addresses in the NAT service plan are converted to elastic IP addresses (EIPs). The maximum bandwidth and billing method of the Internet Shared Bandwidth instance are the same as those of the NAT service plan.
   * 
   * @deprecated OpenAPI ConvertBandwidthPackage is deprecated
   * 
   * @param request - ConvertBandwidthPackageRequest
   * @returns ConvertBandwidthPackageResponse
   */
  // Deprecated
  async convertBandwidthPackage(request: $_model.ConvertBandwidthPackageRequest): Promise<$_model.ConvertBandwidthPackageResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.convertBandwidthPackageWithOptions(request, runtime);
  }

  /**
   * Copies rules of a network access control list (ACL).
   * 
   * @remarks
   * ## [](#)Description
   * *   **CopyNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
   *     *   If the network ACL is in the **Modifying** state, the rules of the network ACL are being copied.
   *     *   If the network ACL is in the **Available** state, the rules of the network ACL are copied.
   * *   You cannot repeatedly call the **CopyNetworkAclEntries** operation within the specified period of time.
   * 
   * @param request - CopyNetworkAclEntriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CopyNetworkAclEntriesResponse
   */
  async copyNetworkAclEntriesWithOptions(request: $_model.CopyNetworkAclEntriesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CopyNetworkAclEntriesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.networkAclId)) {
      query["NetworkAclId"] = request.networkAclId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.sourceNetworkAclId)) {
      query["SourceNetworkAclId"] = request.sourceNetworkAclId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CopyNetworkAclEntries",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CopyNetworkAclEntriesResponse>(await this.callApi(params, req, runtime), new $_model.CopyNetworkAclEntriesResponse({}));
  }

  /**
   * Copies rules of a network access control list (ACL).
   * 
   * @remarks
   * ## [](#)Description
   * *   **CopyNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
   *     *   If the network ACL is in the **Modifying** state, the rules of the network ACL are being copied.
   *     *   If the network ACL is in the **Available** state, the rules of the network ACL are copied.
   * *   You cannot repeatedly call the **CopyNetworkAclEntries** operation within the specified period of time.
   * 
   * @param request - CopyNetworkAclEntriesRequest
   * @returns CopyNetworkAclEntriesResponse
   */
  async copyNetworkAclEntries(request: $_model.CopyNetworkAclEntriesRequest): Promise<$_model.CopyNetworkAclEntriesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.copyNetworkAclEntriesWithOptions(request, runtime);
  }

  /**
   * Creates a BGP group for a virtual border router (VBR).
   * 
   * @remarks
   * You can connect a VBR to a data center through BGP. Each BGP group is associated with a VBR. You can add a BGP peer that needs to communicate with a VBR to a BGP group and advertise the BGP network in the VBR.
   * BGP groups are used to simplify BGP configurations. You can add BGP peers that use the same configurations to one BGP group. Before you start, you must create a BGP group with the requested autonomous system number (ASN).
   * When you call this operation, take note of the following limits:
   * *   You can specify only the data center that is connected to the VBR through an Express Connect circuit as a BGP peer.
   * *   VBRs support only BGP-4.
   * *   You can create at most eight BGP peers for each VBR.
   * *   Each BGP peer supports at most 110 dynamic routes.
   * *   The ASN of Alibaba Cloud is 45104. You can specify a 2-byte or 4-byte ASN for the data center.
   * 
   * @param request - CreateBgpGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateBgpGroupResponse
   */
  async createBgpGroupWithOptions(request: $_model.CreateBgpGroupRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateBgpGroupResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.authKey)) {
      query["AuthKey"] = request.authKey;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.ipVersion)) {
      query["IpVersion"] = request.ipVersion;
    }

    if (!$dara.isNull(request.isFakeAsn)) {
      query["IsFakeAsn"] = request.isFakeAsn;
    }

    if (!$dara.isNull(request.localAsn)) {
      query["LocalAsn"] = request.localAsn;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.peerAsn)) {
      query["PeerAsn"] = request.peerAsn;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeQuota)) {
      query["RouteQuota"] = request.routeQuota;
    }

    if (!$dara.isNull(request.routerId)) {
      query["RouterId"] = request.routerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateBgpGroup",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateBgpGroupResponse>(await this.callApi(params, req, runtime), new $_model.CreateBgpGroupResponse({}));
  }

  /**
   * Creates a BGP group for a virtual border router (VBR).
   * 
   * @remarks
   * You can connect a VBR to a data center through BGP. Each BGP group is associated with a VBR. You can add a BGP peer that needs to communicate with a VBR to a BGP group and advertise the BGP network in the VBR.
   * BGP groups are used to simplify BGP configurations. You can add BGP peers that use the same configurations to one BGP group. Before you start, you must create a BGP group with the requested autonomous system number (ASN).
   * When you call this operation, take note of the following limits:
   * *   You can specify only the data center that is connected to the VBR through an Express Connect circuit as a BGP peer.
   * *   VBRs support only BGP-4.
   * *   You can create at most eight BGP peers for each VBR.
   * *   Each BGP peer supports at most 110 dynamic routes.
   * *   The ASN of Alibaba Cloud is 45104. You can specify a 2-byte or 4-byte ASN for the data center.
   * 
   * @param request - CreateBgpGroupRequest
   * @returns CreateBgpGroupResponse
   */
  async createBgpGroup(request: $_model.CreateBgpGroupRequest): Promise<$_model.CreateBgpGroupResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createBgpGroupWithOptions(request, runtime);
  }

  /**
   * Adds a Border Gateway Protocol (BGP) peer to a BGP group.
   * 
   * @param request - CreateBgpPeerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateBgpPeerResponse
   */
  async createBgpPeerWithOptions(request: $_model.CreateBgpPeerRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateBgpPeerResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bfdMultiHop)) {
      query["BfdMultiHop"] = request.bfdMultiHop;
    }

    if (!$dara.isNull(request.bgpGroupId)) {
      query["BgpGroupId"] = request.bgpGroupId;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.enableBfd)) {
      query["EnableBfd"] = request.enableBfd;
    }

    if (!$dara.isNull(request.ipVersion)) {
      query["IpVersion"] = request.ipVersion;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.peerIpAddress)) {
      query["PeerIpAddress"] = request.peerIpAddress;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateBgpPeer",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateBgpPeerResponse>(await this.callApi(params, req, runtime), new $_model.CreateBgpPeerResponse({}));
  }

  /**
   * Adds a Border Gateway Protocol (BGP) peer to a BGP group.
   * 
   * @param request - CreateBgpPeerRequest
   * @returns CreateBgpPeerResponse
   */
  async createBgpPeer(request: $_model.CreateBgpPeerRequest): Promise<$_model.CreateBgpPeerResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createBgpPeerWithOptions(request, runtime);
  }

  /**
   * Creates an Internet Shared Bandwidth instance.
   * 
   * @param request - CreateCommonBandwidthPackageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateCommonBandwidthPackageResponse
   */
  async createCommonBandwidthPackageWithOptions(request: $_model.CreateCommonBandwidthPackageRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateCommonBandwidthPackageResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidth)) {
      query["Bandwidth"] = request.bandwidth;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.ISP)) {
      query["ISP"] = request.ISP;
    }

    if (!$dara.isNull(request.internetChargeType)) {
      query["InternetChargeType"] = request.internetChargeType;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.ratio)) {
      query["Ratio"] = request.ratio;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.securityProtectionTypes)) {
      query["SecurityProtectionTypes"] = request.securityProtectionTypes;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.zone)) {
      query["Zone"] = request.zone;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateCommonBandwidthPackage",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateCommonBandwidthPackageResponse>(await this.callApi(params, req, runtime), new $_model.CreateCommonBandwidthPackageResponse({}));
  }

  /**
   * Creates an Internet Shared Bandwidth instance.
   * 
   * @param request - CreateCommonBandwidthPackageRequest
   * @returns CreateCommonBandwidthPackageResponse
   */
  async createCommonBandwidthPackage(request: $_model.CreateCommonBandwidthPackageRequest): Promise<$_model.CreateCommonBandwidthPackageResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createCommonBandwidthPackageWithOptions(request, runtime);
  }

  /**
   * Creates a customer gateway.
   * 
   * @param request - CreateCustomerGatewayRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateCustomerGatewayResponse
   */
  async createCustomerGatewayWithOptions(request: $_model.CreateCustomerGatewayRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateCustomerGatewayResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.asn)) {
      query["Asn"] = request.asn;
    }

    if (!$dara.isNull(request.authKey)) {
      query["AuthKey"] = request.authKey;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.ipAddress)) {
      query["IpAddress"] = request.ipAddress;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateCustomerGateway",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateCustomerGatewayResponse>(await this.callApi(params, req, runtime), new $_model.CreateCustomerGatewayResponse({}));
  }

  /**
   * Creates a customer gateway.
   * 
   * @param request - CreateCustomerGatewayRequest
   * @returns CreateCustomerGatewayResponse
   */
  async createCustomerGateway(request: $_model.CreateCustomerGatewayRequest): Promise<$_model.CreateCustomerGatewayResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createCustomerGatewayWithOptions(request, runtime);
  }

  /**
   * Creates a default vSwitch.
   * 
   * @remarks
   * When you call this operation, take note of the following limits:
   * *   The first IP address and last three IP addresses of a vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
   * *   The number of instances in the default vSwitch cannot exceed the remaining number of instances supported by the VPC (15,000 minus the number of existing instances).
   * *   Default vSwitches do not support multicasting or broadcasting.
   * *   After you create a default vSwitch, you cannot modify its CIDR block.
   * *   **CreateDefaultVSwitch** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of a default vSwitch:
   *     *   If a default vSwitch is in the **Pending** state, it is being configured.
   *     *   If a default vSwitch is in the **Available** state, it is available.
   * *   If a default vSwitch already exists in a region, you cannot call this operation to create a default vSwitch in this region.
   * *   Before you create a default vSwitch, make sure that a default VPC is created. You can call the [CreateDefaultVpc](https://help.aliyun.com/document_detail/609152.html) operation to create a default VPC.
   * 
   * @param request - CreateDefaultVSwitchRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDefaultVSwitchResponse
   */
  async createDefaultVSwitchWithOptions(request: $_model.CreateDefaultVSwitchRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateDefaultVSwitchResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ipv6CidrBlock)) {
      query["Ipv6CidrBlock"] = request.ipv6CidrBlock;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateDefaultVSwitch",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateDefaultVSwitchResponse>(await this.callApi(params, req, runtime), new $_model.CreateDefaultVSwitchResponse({}));
  }

  /**
   * Creates a default vSwitch.
   * 
   * @remarks
   * When you call this operation, take note of the following limits:
   * *   The first IP address and last three IP addresses of a vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
   * *   The number of instances in the default vSwitch cannot exceed the remaining number of instances supported by the VPC (15,000 minus the number of existing instances).
   * *   Default vSwitches do not support multicasting or broadcasting.
   * *   After you create a default vSwitch, you cannot modify its CIDR block.
   * *   **CreateDefaultVSwitch** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of a default vSwitch:
   *     *   If a default vSwitch is in the **Pending** state, it is being configured.
   *     *   If a default vSwitch is in the **Available** state, it is available.
   * *   If a default vSwitch already exists in a region, you cannot call this operation to create a default vSwitch in this region.
   * *   Before you create a default vSwitch, make sure that a default VPC is created. You can call the [CreateDefaultVpc](https://help.aliyun.com/document_detail/609152.html) operation to create a default VPC.
   * 
   * @param request - CreateDefaultVSwitchRequest
   * @returns CreateDefaultVSwitchResponse
   */
  async createDefaultVSwitch(request: $_model.CreateDefaultVSwitchRequest): Promise<$_model.CreateDefaultVSwitchResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createDefaultVSwitchWithOptions(request, runtime);
  }

  /**
   * Creates a default virtual private cloud (VPC).
   * 
   * @remarks
   * ## Usage notes
   * When you call this operation, take note of the following items:
   * *   After you create a default VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to it.
   * *   In each default VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
   * *   After you create a default VPC, a vRouter and a route table are automatically created for the VPC.
   * *   At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
   * *   **CreateDefaultVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
   *     *   If the default VPC is in the **Pending** state, the VPC is being configured.
   *     *   If the default VPC is in the **Available** state, the VPC is available.
   * *   You cannot repeatedly call the **CreateDefaultVpc** operation within a specific time period.
   * *   You can create only one default VPC in each region.
   * 
   * @param request - CreateDefaultVpcRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDefaultVpcResponse
   */
  async createDefaultVpcWithOptions(request: $_model.CreateDefaultVpcRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateDefaultVpcResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.enableIpv6)) {
      query["EnableIpv6"] = request.enableIpv6;
    }

    if (!$dara.isNull(request.ipv6CidrBlock)) {
      query["Ipv6CidrBlock"] = request.ipv6CidrBlock;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateDefaultVpc",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateDefaultVpcResponse>(await this.callApi(params, req, runtime), new $_model.CreateDefaultVpcResponse({}));
  }

  /**
   * Creates a default virtual private cloud (VPC).
   * 
   * @remarks
   * ## Usage notes
   * When you call this operation, take note of the following items:
   * *   After you create a default VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to it.
   * *   In each default VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
   * *   After you create a default VPC, a vRouter and a route table are automatically created for the VPC.
   * *   At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
   * *   **CreateDefaultVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
   *     *   If the default VPC is in the **Pending** state, the VPC is being configured.
   *     *   If the default VPC is in the **Available** state, the VPC is available.
   * *   You cannot repeatedly call the **CreateDefaultVpc** operation within a specific time period.
   * *   You can create only one default VPC in each region.
   * 
   * @param request - CreateDefaultVpcRequest
   * @returns CreateDefaultVpcResponse
   */
  async createDefaultVpc(request: $_model.CreateDefaultVpcRequest): Promise<$_model.CreateDefaultVpcResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createDefaultVpcWithOptions(request, runtime);
  }

  /**
   * Creates a DHCP options set.
   * 
   * @remarks
   *   **CreateDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/448820.html) to query the status of the task.
   *     *   If the vSwitch is in the **Pending** state, the DHCP options set is being configured.
   *     *   If the vSwitch is in the **Available** state, the DHCP options set is available.
   * 
   * @param request - CreateDhcpOptionsSetRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDhcpOptionsSetResponse
   */
  async createDhcpOptionsSetWithOptions(request: $_model.CreateDhcpOptionsSetRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateDhcpOptionsSetResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dhcpOptionsSetDescription)) {
      query["DhcpOptionsSetDescription"] = request.dhcpOptionsSetDescription;
    }

    if (!$dara.isNull(request.dhcpOptionsSetName)) {
      query["DhcpOptionsSetName"] = request.dhcpOptionsSetName;
    }

    if (!$dara.isNull(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!$dara.isNull(request.domainNameServers)) {
      query["DomainNameServers"] = request.domainNameServers;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ipv6LeaseTime)) {
      query["Ipv6LeaseTime"] = request.ipv6LeaseTime;
    }

    if (!$dara.isNull(request.leaseTime)) {
      query["LeaseTime"] = request.leaseTime;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateDhcpOptionsSet",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateDhcpOptionsSetResponse>(await this.callApi(params, req, runtime), new $_model.CreateDhcpOptionsSetResponse({}));
  }

  /**
   * Creates a DHCP options set.
   * 
   * @remarks
   *   **CreateDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/448820.html) to query the status of the task.
   *     *   If the vSwitch is in the **Pending** state, the DHCP options set is being configured.
   *     *   If the vSwitch is in the **Available** state, the DHCP options set is available.
   * 
   * @param request - CreateDhcpOptionsSetRequest
   * @returns CreateDhcpOptionsSetResponse
   */
  async createDhcpOptionsSet(request: $_model.CreateDhcpOptionsSetRequest): Promise<$_model.CreateDhcpOptionsSetResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createDhcpOptionsSetWithOptions(request, runtime);
  }

  /**
   * Creates an Express Cloud Connect (ECC) instance.
   * 
   * @param request - CreateExpressCloudConnectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateExpressCloudConnectionResponse
   */
  async createExpressCloudConnectionWithOptions(request: $_model.CreateExpressCloudConnectionRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateExpressCloudConnectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidth)) {
      query["Bandwidth"] = request.bandwidth;
    }

    if (!$dara.isNull(request.contactMail)) {
      query["ContactMail"] = request.contactMail;
    }

    if (!$dara.isNull(request.contactTel)) {
      query["ContactTel"] = request.contactTel;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.IDCardNo)) {
      query["IDCardNo"] = request.IDCardNo;
    }

    if (!$dara.isNull(request.idcSP)) {
      query["IdcSP"] = request.idcSP;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.peerCity)) {
      query["PeerCity"] = request.peerCity;
    }

    if (!$dara.isNull(request.peerLocation)) {
      query["PeerLocation"] = request.peerLocation;
    }

    if (!$dara.isNull(request.portType)) {
      query["PortType"] = request.portType;
    }

    if (!$dara.isNull(request.redundantEccId)) {
      query["RedundantEccId"] = request.redundantEccId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateExpressCloudConnection",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateExpressCloudConnectionResponse>(await this.callApi(params, req, runtime), new $_model.CreateExpressCloudConnectionResponse({}));
  }

  /**
   * Creates an Express Cloud Connect (ECC) instance.
   * 
   * @param request - CreateExpressCloudConnectionRequest
   * @returns CreateExpressCloudConnectionResponse
   */
  async createExpressCloudConnection(request: $_model.CreateExpressCloudConnectionRequest): Promise<$_model.CreateExpressCloudConnectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createExpressCloudConnectionWithOptions(request, runtime);
  }

  /**
   * Creates a quality of service (QoS) policy.
   * 
   * @param request - CreateExpressConnectTrafficQosRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateExpressConnectTrafficQosResponse
   */
  async createExpressConnectTrafficQosWithOptions(request: $_model.CreateExpressConnectTrafficQosRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateExpressConnectTrafficQosResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.qosDescription)) {
      query["QosDescription"] = request.qosDescription;
    }

    if (!$dara.isNull(request.qosName)) {
      query["QosName"] = request.qosName;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateExpressConnectTrafficQos",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateExpressConnectTrafficQosResponse>(await this.callApi(params, req, runtime), new $_model.CreateExpressConnectTrafficQosResponse({}));
  }

  /**
   * Creates a quality of service (QoS) policy.
   * 
   * @param request - CreateExpressConnectTrafficQosRequest
   * @returns CreateExpressConnectTrafficQosResponse
   */
  async createExpressConnectTrafficQos(request: $_model.CreateExpressConnectTrafficQosRequest): Promise<$_model.CreateExpressConnectTrafficQosResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createExpressConnectTrafficQosWithOptions(request, runtime);
  }

  /**
   * Creates a quality of service (QoS) queue.
   * 
   * @param request - CreateExpressConnectTrafficQosQueueRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateExpressConnectTrafficQosQueueResponse
   */
  async createExpressConnectTrafficQosQueueWithOptions(request: $_model.CreateExpressConnectTrafficQosQueueRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateExpressConnectTrafficQosQueueResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidthPercent)) {
      query["BandwidthPercent"] = request.bandwidthPercent;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.qosId)) {
      query["QosId"] = request.qosId;
    }

    if (!$dara.isNull(request.queueDescription)) {
      query["QueueDescription"] = request.queueDescription;
    }

    if (!$dara.isNull(request.queueName)) {
      query["QueueName"] = request.queueName;
    }

    if (!$dara.isNull(request.queueType)) {
      query["QueueType"] = request.queueType;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateExpressConnectTrafficQosQueue",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateExpressConnectTrafficQosQueueResponse>(await this.callApi(params, req, runtime), new $_model.CreateExpressConnectTrafficQosQueueResponse({}));
  }

  /**
   * Creates a quality of service (QoS) queue.
   * 
   * @param request - CreateExpressConnectTrafficQosQueueRequest
   * @returns CreateExpressConnectTrafficQosQueueResponse
   */
  async createExpressConnectTrafficQosQueue(request: $_model.CreateExpressConnectTrafficQosQueueRequest): Promise<$_model.CreateExpressConnectTrafficQosQueueResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createExpressConnectTrafficQosQueueWithOptions(request, runtime);
  }

  /**
   * Creates a quality of service (QoS) rule.
   * 
   * @param request - CreateExpressConnectTrafficQosRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateExpressConnectTrafficQosRuleResponse
   */
  async createExpressConnectTrafficQosRuleWithOptions(request: $_model.CreateExpressConnectTrafficQosRuleRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateExpressConnectTrafficQosRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dstCidr)) {
      query["DstCidr"] = request.dstCidr;
    }

    if (!$dara.isNull(request.dstIPv6Cidr)) {
      query["DstIPv6Cidr"] = request.dstIPv6Cidr;
    }

    if (!$dara.isNull(request.dstPortRange)) {
      query["DstPortRange"] = request.dstPortRange;
    }

    if (!$dara.isNull(request.matchDscp)) {
      query["MatchDscp"] = request.matchDscp;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.priority)) {
      query["Priority"] = request.priority;
    }

    if (!$dara.isNull(request.protocol)) {
      query["Protocol"] = request.protocol;
    }

    if (!$dara.isNull(request.qosId)) {
      query["QosId"] = request.qosId;
    }

    if (!$dara.isNull(request.queueId)) {
      query["QueueId"] = request.queueId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.remarkingDscp)) {
      query["RemarkingDscp"] = request.remarkingDscp;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.ruleDescription)) {
      query["RuleDescription"] = request.ruleDescription;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.srcCidr)) {
      query["SrcCidr"] = request.srcCidr;
    }

    if (!$dara.isNull(request.srcIPv6Cidr)) {
      query["SrcIPv6Cidr"] = request.srcIPv6Cidr;
    }

    if (!$dara.isNull(request.srcPortRange)) {
      query["SrcPortRange"] = request.srcPortRange;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateExpressConnectTrafficQosRule",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateExpressConnectTrafficQosRuleResponse>(await this.callApi(params, req, runtime), new $_model.CreateExpressConnectTrafficQosRuleResponse({}));
  }

  /**
   * Creates a quality of service (QoS) rule.
   * 
   * @param request - CreateExpressConnectTrafficQosRuleRequest
   * @returns CreateExpressConnectTrafficQosRuleResponse
   */
  async createExpressConnectTrafficQosRule(request: $_model.CreateExpressConnectTrafficQosRuleRequest): Promise<$_model.CreateExpressConnectTrafficQosRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createExpressConnectTrafficQosRuleWithOptions(request, runtime);
  }

  /**
   * Creates a failover test.
   * 
   * @remarks
   * You cannot create a failover test in the following scenarios:
   * *   You have created a failover test in the region and its type is StartNow.
   * *   The Express Connect circuit or hosted connection has pending orders or overdue payments.
   * *   A failover test is already performed on the Express Connect circuit or hosted connection.
   * *   More than one hosted connection is created over the Express Connect circuit.
   * *   More than one cross-account VBR is created on the Express Connect circuit.
   * *   No VBR is associated with the hosted connection.
   * *   The VLAN ID of the hosted connection is set to 0.
   * 
   * @param request - CreateFailoverTestJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateFailoverTestJobResponse
   */
  async createFailoverTestJobWithOptions(request: $_model.CreateFailoverTestJobRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateFailoverTestJobResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.jobDuration)) {
      query["JobDuration"] = request.jobDuration;
    }

    if (!$dara.isNull(request.jobType)) {
      query["JobType"] = request.jobType;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateFailoverTestJob",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateFailoverTestJobResponse>(await this.callApi(params, req, runtime), new $_model.CreateFailoverTestJobResponse({}));
  }

  /**
   * Creates a failover test.
   * 
   * @remarks
   * You cannot create a failover test in the following scenarios:
   * *   You have created a failover test in the region and its type is StartNow.
   * *   The Express Connect circuit or hosted connection has pending orders or overdue payments.
   * *   A failover test is already performed on the Express Connect circuit or hosted connection.
   * *   More than one hosted connection is created over the Express Connect circuit.
   * *   More than one cross-account VBR is created on the Express Connect circuit.
   * *   No VBR is associated with the hosted connection.
   * *   The VLAN ID of the hosted connection is set to 0.
   * 
   * @param request - CreateFailoverTestJobRequest
   * @returns CreateFailoverTestJobResponse
   */
  async createFailoverTestJob(request: $_model.CreateFailoverTestJobRequest): Promise<$_model.CreateFailoverTestJobResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createFailoverTestJobWithOptions(request, runtime);
  }

  /**
   * Creates a flow log.
   * 
   * @remarks
   * *CreateFlowLog** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of the flow log.
   * *   If the flow log is in the **Activating** state, the flow log is being created.
   * *   If the flow log is in the **Active** state, the flow log is created and started.
   * 
   * @param request - CreateFlowLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateFlowLogResponse
   */
  async createFlowLogWithOptions(request: $_model.CreateFlowLogRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateFlowLogResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.aggregationInterval)) {
      query["AggregationInterval"] = request.aggregationInterval;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.flowLogName)) {
      query["FlowLogName"] = request.flowLogName;
    }

    if (!$dara.isNull(request.ipVersion)) {
      query["IpVersion"] = request.ipVersion;
    }

    if (!$dara.isNull(request.logStoreName)) {
      query["LogStoreName"] = request.logStoreName;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.projectName)) {
      query["ProjectName"] = request.projectName;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.trafficPath)) {
      query["TrafficPath"] = request.trafficPath;
    }

    if (!$dara.isNull(request.trafficType)) {
      query["TrafficType"] = request.trafficType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateFlowLog",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateFlowLogResponse>(await this.callApi(params, req, runtime), new $_model.CreateFlowLogResponse({}));
  }

  /**
   * Creates a flow log.
   * 
   * @remarks
   * *CreateFlowLog** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of the flow log.
   * *   If the flow log is in the **Activating** state, the flow log is being created.
   * *   If the flow log is in the **Active** state, the flow log is created and started.
   * 
   * @param request - CreateFlowLogRequest
   * @returns CreateFlowLogResponse
   */
  async createFlowLog(request: $_model.CreateFlowLogRequest): Promise<$_model.CreateFlowLogResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createFlowLogWithOptions(request, runtime);
  }

  /**
   * Adds a DNAT entry to a DNAT table.
   * 
   * @remarks
   * ## [](#)
   * Each DNAT entry consists of the following parameters: **ExternalIp**, **ExternalPort**, **IpProtocol**, **InternalIp**, and **InternalPort**. After you add a DNAT entry, the NAT gateway forwards packets over the specified protocol from **ExternalIp:ExternalPort** to **InternalIp:InternalPort** and sends responses back through the same route.
   * When you call this operation, take note of the following limits:
   * *   **CreateForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
   *     *   If the DNAT entry is in the **Pending** state, the system is adding the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
   *     *   If the DNAT entry is in the **Available** state, the DNAT entry is added.
   * *   You cannot repeatedly call the **CreateForwardEntry** operation to add a DNAT entry within a specific period of time.
   * *   All combinations of **ExternalIp**, **ExternalPort**, and **IpProtocol** used in DNAT entries must be unique. You cannot distribute requests to more than one Elastic Compute Service (ECS) instance if these requests are initiated from the same source IP address, received on the same port, and use the same protocol.
   * *   The combinations of **IpProtocol**, **InternalIp**, and **InternalPort** must be unique.
   * *   If one or more DNAT entries in the DNAT table are in the **Pending** or **Modifying** state, you cannot add DNAT entries to the DNAT table.
   * *   You can add at most 100 DNAT entries to a DNAT table.
   * *   For an elastic IP address (EIP) used by an Internet NAT gateway or a NAT IP address used by a Virtual Private Cloud (VPC) NAT gateway, take note of the following limit: If the IP address has IP mapping enabled and is specified in a DNAT entry, the IP address cannot be used by another DNAT or SNAT entry.
   * 
   * @param request - CreateForwardEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateForwardEntryResponse
   */
  async createForwardEntryWithOptions(request: $_model.CreateForwardEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateForwardEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.externalIp)) {
      query["ExternalIp"] = request.externalIp;
    }

    if (!$dara.isNull(request.externalPort)) {
      query["ExternalPort"] = request.externalPort;
    }

    if (!$dara.isNull(request.forwardEntryName)) {
      query["ForwardEntryName"] = request.forwardEntryName;
    }

    if (!$dara.isNull(request.forwardTableId)) {
      query["ForwardTableId"] = request.forwardTableId;
    }

    if (!$dara.isNull(request.internalIp)) {
      query["InternalIp"] = request.internalIp;
    }

    if (!$dara.isNull(request.internalPort)) {
      query["InternalPort"] = request.internalPort;
    }

    if (!$dara.isNull(request.ipProtocol)) {
      query["IpProtocol"] = request.ipProtocol;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.portBreak)) {
      query["PortBreak"] = request.portBreak;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateForwardEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateForwardEntryResponse>(await this.callApi(params, req, runtime), new $_model.CreateForwardEntryResponse({}));
  }

  /**
   * Adds a DNAT entry to a DNAT table.
   * 
   * @remarks
   * ## [](#)
   * Each DNAT entry consists of the following parameters: **ExternalIp**, **ExternalPort**, **IpProtocol**, **InternalIp**, and **InternalPort**. After you add a DNAT entry, the NAT gateway forwards packets over the specified protocol from **ExternalIp:ExternalPort** to **InternalIp:InternalPort** and sends responses back through the same route.
   * When you call this operation, take note of the following limits:
   * *   **CreateForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
   *     *   If the DNAT entry is in the **Pending** state, the system is adding the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
   *     *   If the DNAT entry is in the **Available** state, the DNAT entry is added.
   * *   You cannot repeatedly call the **CreateForwardEntry** operation to add a DNAT entry within a specific period of time.
   * *   All combinations of **ExternalIp**, **ExternalPort**, and **IpProtocol** used in DNAT entries must be unique. You cannot distribute requests to more than one Elastic Compute Service (ECS) instance if these requests are initiated from the same source IP address, received on the same port, and use the same protocol.
   * *   The combinations of **IpProtocol**, **InternalIp**, and **InternalPort** must be unique.
   * *   If one or more DNAT entries in the DNAT table are in the **Pending** or **Modifying** state, you cannot add DNAT entries to the DNAT table.
   * *   You can add at most 100 DNAT entries to a DNAT table.
   * *   For an elastic IP address (EIP) used by an Internet NAT gateway or a NAT IP address used by a Virtual Private Cloud (VPC) NAT gateway, take note of the following limit: If the IP address has IP mapping enabled and is specified in a DNAT entry, the IP address cannot be used by another DNAT or SNAT entry.
   * 
   * @param request - CreateForwardEntryRequest
   * @returns CreateForwardEntryResponse
   */
  async createForwardEntry(request: $_model.CreateForwardEntryRequest): Promise<$_model.CreateForwardEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createForwardEntryWithOptions(request, runtime);
  }

  /**
   * Adds a FULLNAT entry to the FULLNAT table.
   * 
   * @remarks
   *   **CreateFullNatEntry** is an asynchronous operation. After you send a request to call this operation, the system returns a FULLNAT entry and the FULLNAT entry is being added in the backend. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
   *     *   If the FULLNAT entry is in the **Creating** state, the system is adding the FULLNAT entry. You can only query the status of the FULLNAT entry, but cannot perform other operations.
   *     *   If the FULLNAT entry is in the **Available** state, the FULLNAT entry is added.
   * *   You cannot repeatedly call the **CreateFullNatEntry** operation for the same VPN gateway within the specified period of time.
   * 
   * @param request - CreateFullNatEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateFullNatEntryResponse
   */
  async createFullNatEntryWithOptions(request: $_model.CreateFullNatEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateFullNatEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.accessIp)) {
      query["AccessIp"] = request.accessIp;
    }

    if (!$dara.isNull(request.accessPort)) {
      query["AccessPort"] = request.accessPort;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.fullNatEntryDescription)) {
      query["FullNatEntryDescription"] = request.fullNatEntryDescription;
    }

    if (!$dara.isNull(request.fullNatEntryName)) {
      query["FullNatEntryName"] = request.fullNatEntryName;
    }

    if (!$dara.isNull(request.fullNatTableId)) {
      query["FullNatTableId"] = request.fullNatTableId;
    }

    if (!$dara.isNull(request.ipProtocol)) {
      query["IpProtocol"] = request.ipProtocol;
    }

    if (!$dara.isNull(request.natIp)) {
      query["NatIp"] = request.natIp;
    }

    if (!$dara.isNull(request.natIpPort)) {
      query["NatIpPort"] = request.natIpPort;
    }

    if (!$dara.isNull(request.networkInterfaceId)) {
      query["NetworkInterfaceId"] = request.networkInterfaceId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateFullNatEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateFullNatEntryResponse>(await this.callApi(params, req, runtime), new $_model.CreateFullNatEntryResponse({}));
  }

  /**
   * Adds a FULLNAT entry to the FULLNAT table.
   * 
   * @remarks
   *   **CreateFullNatEntry** is an asynchronous operation. After you send a request to call this operation, the system returns a FULLNAT entry and the FULLNAT entry is being added in the backend. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
   *     *   If the FULLNAT entry is in the **Creating** state, the system is adding the FULLNAT entry. You can only query the status of the FULLNAT entry, but cannot perform other operations.
   *     *   If the FULLNAT entry is in the **Available** state, the FULLNAT entry is added.
   * *   You cannot repeatedly call the **CreateFullNatEntry** operation for the same VPN gateway within the specified period of time.
   * 
   * @param request - CreateFullNatEntryRequest
   * @returns CreateFullNatEntryResponse
   */
  async createFullNatEntry(request: $_model.CreateFullNatEntryRequest): Promise<$_model.CreateFullNatEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createFullNatEntryWithOptions(request, runtime);
  }

  /**
   * Creates a Global Accelerator (GA) instance.
   * 
   * @remarks
   * ## Usage notes
   * You can call this operation to create only pay-as-you-go GA instances.
   * 
   * @deprecated OpenAPI CreateGlobalAccelerationInstance is deprecated
   * 
   * @param request - CreateGlobalAccelerationInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateGlobalAccelerationInstanceResponse
   */
  async createGlobalAccelerationInstanceWithOptions(request: $_model.CreateGlobalAccelerationInstanceRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateGlobalAccelerationInstanceResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidth)) {
      query["Bandwidth"] = request.bandwidth;
    }

    if (!$dara.isNull(request.bandwidthType)) {
      query["BandwidthType"] = request.bandwidthType;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.serviceLocation)) {
      query["ServiceLocation"] = request.serviceLocation;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateGlobalAccelerationInstance",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateGlobalAccelerationInstanceResponse>(await this.callApi(params, req, runtime), new $_model.CreateGlobalAccelerationInstanceResponse({}));
  }

  /**
   * Creates a Global Accelerator (GA) instance.
   * 
   * @remarks
   * ## Usage notes
   * You can call this operation to create only pay-as-you-go GA instances.
   * 
   * @deprecated OpenAPI CreateGlobalAccelerationInstance is deprecated
   * 
   * @param request - CreateGlobalAccelerationInstanceRequest
   * @returns CreateGlobalAccelerationInstanceResponse
   */
  // Deprecated
  async createGlobalAccelerationInstance(request: $_model.CreateGlobalAccelerationInstanceRequest): Promise<$_model.CreateGlobalAccelerationInstanceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createGlobalAccelerationInstanceWithOptions(request, runtime);
  }

  /**
   * Creates a high-availability virtual IP address (HaVip).
   * 
   * @remarks
   * *CreateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of the task:
   * *   If the HaVip is in the **Creating** state, the HaVip is being created.
   * *   If the HaVip is in the **Available** state, the HaVip is created.
   * 
   * @param request - CreateHaVipRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateHaVipResponse
   */
  async createHaVipWithOptions(request: $_model.CreateHaVipRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateHaVipResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.ipAddress)) {
      query["IpAddress"] = request.ipAddress;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateHaVip",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateHaVipResponse>(await this.callApi(params, req, runtime), new $_model.CreateHaVipResponse({}));
  }

  /**
   * Creates a high-availability virtual IP address (HaVip).
   * 
   * @remarks
   * *CreateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of the task:
   * *   If the HaVip is in the **Creating** state, the HaVip is being created.
   * *   If the HaVip is in the **Available** state, the HaVip is created.
   * 
   * @param request - CreateHaVipRequest
   * @returns CreateHaVipResponse
   */
  async createHaVip(request: $_model.CreateHaVipRequest): Promise<$_model.CreateHaVipResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createHaVipWithOptions(request, runtime);
  }

  /**
   * Creates Express Connect circuits in high reliability mode. This improves the stability of multiple Express Connect circuits and prevents service interruptions caused by single points of failures (SPOFs).
   * 
   * @param request - CreateHighReliablePhysicalConnectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateHighReliablePhysicalConnectionResponse
   */
  async createHighReliablePhysicalConnectionWithOptions(request: $_model.CreateHighReliablePhysicalConnectionRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateHighReliablePhysicalConnectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!$dara.isNull(request.apList)) {
      query["ApList"] = request.apList;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.deviceAdvancedCapacity)) {
      query["DeviceAdvancedCapacity"] = request.deviceAdvancedCapacity;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.highReliableType)) {
      query["HighReliableType"] = request.highReliableType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.portType)) {
      query["PortType"] = request.portType;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateHighReliablePhysicalConnection",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateHighReliablePhysicalConnectionResponse>(await this.callApi(params, req, runtime), new $_model.CreateHighReliablePhysicalConnectionResponse({}));
  }

  /**
   * Creates Express Connect circuits in high reliability mode. This improves the stability of multiple Express Connect circuits and prevents service interruptions caused by single points of failures (SPOFs).
   * 
   * @param request - CreateHighReliablePhysicalConnectionRequest
   * @returns CreateHighReliablePhysicalConnectionResponse
   */
  async createHighReliablePhysicalConnection(request: $_model.CreateHighReliablePhysicalConnectionRequest): Promise<$_model.CreateHighReliablePhysicalConnectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createHighReliablePhysicalConnectionWithOptions(request, runtime);
  }

  /**
   * Creates an IPv6 Translation Service instance.
   * 
   * @deprecated OpenAPI CreateIPv6Translator is deprecated
   * 
   * @param request - CreateIPv6TranslatorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateIPv6TranslatorResponse
   */
  async createIPv6TranslatorWithOptions(request: $_model.CreateIPv6TranslatorRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateIPv6TranslatorResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.autoPay)) {
      query["AutoPay"] = request.autoPay;
    }

    if (!$dara.isNull(request.bandwidth)) {
      query["Bandwidth"] = request.bandwidth;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.duration)) {
      query["Duration"] = request.duration;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.payType)) {
      query["PayType"] = request.payType;
    }

    if (!$dara.isNull(request.pricingCycle)) {
      query["PricingCycle"] = request.pricingCycle;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.spec)) {
      query["Spec"] = request.spec;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateIPv6Translator",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateIPv6TranslatorResponse>(await this.callApi(params, req, runtime), new $_model.CreateIPv6TranslatorResponse({}));
  }

  /**
   * Creates an IPv6 Translation Service instance.
   * 
   * @deprecated OpenAPI CreateIPv6Translator is deprecated
   * 
   * @param request - CreateIPv6TranslatorRequest
   * @returns CreateIPv6TranslatorResponse
   */
  // Deprecated
  async createIPv6Translator(request: $_model.CreateIPv6TranslatorRequest): Promise<$_model.CreateIPv6TranslatorResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createIPv6TranslatorWithOptions(request, runtime);
  }

  /**
   * Creates an access control list (ACL).
   * 
   * @deprecated OpenAPI CreateIPv6TranslatorAclList is deprecated
   * 
   * @param request - CreateIPv6TranslatorAclListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateIPv6TranslatorAclListResponse
   */
  async createIPv6TranslatorAclListWithOptions(request: $_model.CreateIPv6TranslatorAclListRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateIPv6TranslatorAclListResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.aclName)) {
      query["AclName"] = request.aclName;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateIPv6TranslatorAclList",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateIPv6TranslatorAclListResponse>(await this.callApi(params, req, runtime), new $_model.CreateIPv6TranslatorAclListResponse({}));
  }

  /**
   * Creates an access control list (ACL).
   * 
   * @deprecated OpenAPI CreateIPv6TranslatorAclList is deprecated
   * 
   * @param request - CreateIPv6TranslatorAclListRequest
   * @returns CreateIPv6TranslatorAclListResponse
   */
  // Deprecated
  async createIPv6TranslatorAclList(request: $_model.CreateIPv6TranslatorAclListRequest): Promise<$_model.CreateIPv6TranslatorAclListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createIPv6TranslatorAclListWithOptions(request, runtime);
  }

  /**
   * Adds an IPv6 mapping entry to an IPv6 Translation Service instance.
   * 
   * @deprecated OpenAPI CreateIPv6TranslatorEntry is deprecated
   * 
   * @param request - CreateIPv6TranslatorEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateIPv6TranslatorEntryResponse
   */
  async createIPv6TranslatorEntryWithOptions(request: $_model.CreateIPv6TranslatorEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateIPv6TranslatorEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.aclId)) {
      query["AclId"] = request.aclId;
    }

    if (!$dara.isNull(request.aclStatus)) {
      query["AclStatus"] = request.aclStatus;
    }

    if (!$dara.isNull(request.aclType)) {
      query["AclType"] = request.aclType;
    }

    if (!$dara.isNull(request.allocateIpv6Port)) {
      query["AllocateIpv6Port"] = request.allocateIpv6Port;
    }

    if (!$dara.isNull(request.backendIpv4Addr)) {
      query["BackendIpv4Addr"] = request.backendIpv4Addr;
    }

    if (!$dara.isNull(request.backendIpv4Port)) {
      query["BackendIpv4Port"] = request.backendIpv4Port;
    }

    if (!$dara.isNull(request.entryBandwidth)) {
      query["EntryBandwidth"] = request.entryBandwidth;
    }

    if (!$dara.isNull(request.entryDescription)) {
      query["EntryDescription"] = request.entryDescription;
    }

    if (!$dara.isNull(request.entryName)) {
      query["EntryName"] = request.entryName;
    }

    if (!$dara.isNull(request.ipv6TranslatorId)) {
      query["Ipv6TranslatorId"] = request.ipv6TranslatorId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.transProtocol)) {
      query["TransProtocol"] = request.transProtocol;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateIPv6TranslatorEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateIPv6TranslatorEntryResponse>(await this.callApi(params, req, runtime), new $_model.CreateIPv6TranslatorEntryResponse({}));
  }

  /**
   * Adds an IPv6 mapping entry to an IPv6 Translation Service instance.
   * 
   * @deprecated OpenAPI CreateIPv6TranslatorEntry is deprecated
   * 
   * @param request - CreateIPv6TranslatorEntryRequest
   * @returns CreateIPv6TranslatorEntryResponse
   */
  // Deprecated
  async createIPv6TranslatorEntry(request: $_model.CreateIPv6TranslatorEntryRequest): Promise<$_model.CreateIPv6TranslatorEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createIPv6TranslatorEntryWithOptions(request, runtime);
  }

  /**
   * Creates an IPsec server.
   * 
   * @remarks
   *   Before you create an IPsec server, you must create a VPN gateway and enable the SSL-VPN feature for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
   * *   Before you create an IPsec server, make sure that no IPsec-VPN connection exists on the VPN gateway. For more information, see [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
   * *   **CreateIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the IPsec server is being created.
   *     *   If the VPN gateway is in the **active** state, the IPsec server is created.
   * *   You cannot repeatedly call **CreateIpsecServer** within the specified period of time.
   * 
   * @param request - CreateIpsecServerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateIpsecServerResponse
   */
  async createIpsecServerWithOptions(request: $_model.CreateIpsecServerRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateIpsecServerResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientIpPool)) {
      query["ClientIpPool"] = request.clientIpPool;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.effectImmediately)) {
      query["EffectImmediately"] = request.effectImmediately;
    }

    if (!$dara.isNull(request.ikeConfig)) {
      query["IkeConfig"] = request.ikeConfig;
    }

    if (!$dara.isNull(request.ipSecServerName)) {
      query["IpSecServerName"] = request.ipSecServerName;
    }

    if (!$dara.isNull(request.ipsecConfig)) {
      query["IpsecConfig"] = request.ipsecConfig;
    }

    if (!$dara.isNull(request.localSubnet)) {
      query["LocalSubnet"] = request.localSubnet;
    }

    if (!$dara.isNull(request.psk)) {
      query["Psk"] = request.psk;
    }

    if (!$dara.isNull(request.pskEnabled)) {
      query["PskEnabled"] = request.pskEnabled;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateIpsecServer",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateIpsecServerResponse>(await this.callApi(params, req, runtime), new $_model.CreateIpsecServerResponse({}));
  }

  /**
   * Creates an IPsec server.
   * 
   * @remarks
   *   Before you create an IPsec server, you must create a VPN gateway and enable the SSL-VPN feature for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
   * *   Before you create an IPsec server, make sure that no IPsec-VPN connection exists on the VPN gateway. For more information, see [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
   * *   **CreateIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the IPsec server is being created.
   *     *   If the VPN gateway is in the **active** state, the IPsec server is created.
   * *   You cannot repeatedly call **CreateIpsecServer** within the specified period of time.
   * 
   * @param request - CreateIpsecServerRequest
   * @returns CreateIpsecServerResponse
   */
  async createIpsecServer(request: $_model.CreateIpsecServerRequest): Promise<$_model.CreateIpsecServerResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createIpsecServerWithOptions(request, runtime);
  }

  /**
   * IPv4
   * 
   * @remarks
   *   **CreateIpv4Gateway** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway:
   *     *   If the IPv4 gateway is in the **Creating** state, the IPv4 gateway is being created.
   *     *   If the IPv4 gateway is in the **Created** state, the IPv4 gateway is created.
   * *   You cannot repeatedly call the **CreateIpv4Gateway** operation to create IPv4 gateways in a virtual private cloud (VPC) within the specified period of time.
   * 
   * @param request - CreateIpv4GatewayRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateIpv4GatewayResponse
   */
  async createIpv4GatewayWithOptions(request: $_model.CreateIpv4GatewayRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateIpv4GatewayResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ipv4GatewayDescription)) {
      query["Ipv4GatewayDescription"] = request.ipv4GatewayDescription;
    }

    if (!$dara.isNull(request.ipv4GatewayName)) {
      query["Ipv4GatewayName"] = request.ipv4GatewayName;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateIpv4Gateway",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateIpv4GatewayResponse>(await this.callApi(params, req, runtime), new $_model.CreateIpv4GatewayResponse({}));
  }

  /**
   * IPv4
   * 
   * @remarks
   *   **CreateIpv4Gateway** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway:
   *     *   If the IPv4 gateway is in the **Creating** state, the IPv4 gateway is being created.
   *     *   If the IPv4 gateway is in the **Created** state, the IPv4 gateway is created.
   * *   You cannot repeatedly call the **CreateIpv4Gateway** operation to create IPv4 gateways in a virtual private cloud (VPC) within the specified period of time.
   * 
   * @param request - CreateIpv4GatewayRequest
   * @returns CreateIpv4GatewayResponse
   */
  async createIpv4Gateway(request: $_model.CreateIpv4GatewayRequest): Promise<$_model.CreateIpv4GatewayResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createIpv4GatewayWithOptions(request, runtime);
  }

  /**
   * You can call CreateIpv6EgressOnlyRule to create egress-only rules to enable ECS instances in VPCs that have IPv6 enabled to access IPv6 clients. However, IPv6 clients cannot access the ECS instances over the Internet.
   * 
   * @remarks
   *   **CreateIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and creates the rule in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
   *     *   If the egress-only rule is in the **Creating** state, the egress-only rule is being created.
   *     *   If the egress-only rule is in the **Created** state, the egress-only rule is created.
   * *   You cannot repeatedly call the **CreateIpv6EgressOnlyRule** operation to add egress-only rules for an IPv6 address within the specified period of time.
   * 
   * @param request - CreateIpv6EgressOnlyRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateIpv6EgressOnlyRuleResponse
   */
  async createIpv6EgressOnlyRuleWithOptions(request: $_model.CreateIpv6EgressOnlyRuleRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateIpv6EgressOnlyRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!$dara.isNull(request.ipv6GatewayId)) {
      query["Ipv6GatewayId"] = request.ipv6GatewayId;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateIpv6EgressOnlyRule",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateIpv6EgressOnlyRuleResponse>(await this.callApi(params, req, runtime), new $_model.CreateIpv6EgressOnlyRuleResponse({}));
  }

  /**
   * You can call CreateIpv6EgressOnlyRule to create egress-only rules to enable ECS instances in VPCs that have IPv6 enabled to access IPv6 clients. However, IPv6 clients cannot access the ECS instances over the Internet.
   * 
   * @remarks
   *   **CreateIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and creates the rule in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
   *     *   If the egress-only rule is in the **Creating** state, the egress-only rule is being created.
   *     *   If the egress-only rule is in the **Created** state, the egress-only rule is created.
   * *   You cannot repeatedly call the **CreateIpv6EgressOnlyRule** operation to add egress-only rules for an IPv6 address within the specified period of time.
   * 
   * @param request - CreateIpv6EgressOnlyRuleRequest
   * @returns CreateIpv6EgressOnlyRuleResponse
   */
  async createIpv6EgressOnlyRule(request: $_model.CreateIpv6EgressOnlyRuleRequest): Promise<$_model.CreateIpv6EgressOnlyRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createIpv6EgressOnlyRuleWithOptions(request, runtime);
  }

  /**
   * IPv6 gateways are used to control the IPv6 traffic of virtual private clouds (VPCs). You can call the CreateIpv6Gateway operation to create IPv6 gateways.
   * 
   * @remarks
   *   **CreateIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task.
   *     *   If the IPv6 gateway is in the **Creating** state, the IPv6 gateway is being created.
   *     *   If the IPv6 gateway is in the **Created** state, the IPv6 gateway is created.
   * *   You cannot repeatedly call the **CreateIpv6Gateway** operation within a specific time period.
   * 
   * @param request - CreateIpv6GatewayRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateIpv6GatewayResponse
   */
  async createIpv6GatewayWithOptions(request: $_model.CreateIpv6GatewayRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateIpv6GatewayResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateIpv6Gateway",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateIpv6GatewayResponse>(await this.callApi(params, req, runtime), new $_model.CreateIpv6GatewayResponse({}));
  }

  /**
   * IPv6 gateways are used to control the IPv6 traffic of virtual private clouds (VPCs). You can call the CreateIpv6Gateway operation to create IPv6 gateways.
   * 
   * @remarks
   *   **CreateIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task.
   *     *   If the IPv6 gateway is in the **Creating** state, the IPv6 gateway is being created.
   *     *   If the IPv6 gateway is in the **Created** state, the IPv6 gateway is created.
   * *   You cannot repeatedly call the **CreateIpv6Gateway** operation within a specific time period.
   * 
   * @param request - CreateIpv6GatewayRequest
   * @returns CreateIpv6GatewayResponse
   */
  async createIpv6Gateway(request: $_model.CreateIpv6GatewayRequest): Promise<$_model.CreateIpv6GatewayResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createIpv6GatewayWithOptions(request, runtime);
  }

  /**
   * Creates an enhanced Internet NAT gateway or a Virtual Private Cloud (VPC) NAT gateway.
   * 
   * @remarks
   * ## Usage notes
   * Before you call this operation, take note of the following items:
   * *   When you create an enhanced NAT gateway for the first time, the system automatically creates the service-linked role AliyunServiceRoleForNatgw. Then, the system attaches the permission policy AliyunServiceRolePolicyForNatgw to the role. This allows the NAT gateway to access other resources on Alibaba Cloud. For more information, see [Service-linked roles](https://help.aliyun.com/document_detail/174251.html).
   * *   After you create an enhanced Internet NAT gateway, a route entry is automatically added to the route table of the VPC. The destination CIDR block of the route entry is 0.0.0.0/0 and the next hop is the NAT gateway. This ensures that traffic is routed to the NAT gateway.
   * *   **CreateNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) operation to query the status of the task.
   *     *   If a NAT gateway is in the **Creating** state, the NAT gateway is being created. In this case, you can query the NAT gateway but cannot perform other operations.
   *     *   If a NAT gateway is in the **Available** state, the NAT gateway is created.
   * It takes 1 to 3 minutes to create a NAT gateway.
   * 
   * @param tmpReq - CreateNatGatewayRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateNatGatewayResponse
   */
  async createNatGatewayWithOptions(tmpReq: $_model.CreateNatGatewayRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateNatGatewayResponse> {
    tmpReq.validate();
    let request = new $_model.CreateNatGatewayShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.accessMode)) {
      request.accessModeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.accessMode, "AccessMode", "json");
    }

    let query = { };
    if (!$dara.isNull(request.accessModeShrink)) {
      query["AccessMode"] = request.accessModeShrink;
    }

    if (!$dara.isNull(request.autoPay)) {
      query["AutoPay"] = request.autoPay;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.duration)) {
      query["Duration"] = request.duration;
    }

    if (!$dara.isNull(request.eipBindMode)) {
      query["EipBindMode"] = request.eipBindMode;
    }

    if (!$dara.isNull(request.icmpReplyEnabled)) {
      query["IcmpReplyEnabled"] = request.icmpReplyEnabled;
    }

    if (!$dara.isNull(request.instanceChargeType)) {
      query["InstanceChargeType"] = request.instanceChargeType;
    }

    if (!$dara.isNull(request.internetChargeType)) {
      query["InternetChargeType"] = request.internetChargeType;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.natType)) {
      query["NatType"] = request.natType;
    }

    if (!$dara.isNull(request.networkType)) {
      query["NetworkType"] = request.networkType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pricingCycle)) {
      query["PricingCycle"] = request.pricingCycle;
    }

    if (!$dara.isNull(request.privateLinkEnabled)) {
      query["PrivateLinkEnabled"] = request.privateLinkEnabled;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.securityProtectionEnabled)) {
      query["SecurityProtectionEnabled"] = request.securityProtectionEnabled;
    }

    if (!$dara.isNull(request.spec)) {
      query["Spec"] = request.spec;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateNatGateway",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateNatGatewayResponse>(await this.callApi(params, req, runtime), new $_model.CreateNatGatewayResponse({}));
  }

  /**
   * Creates an enhanced Internet NAT gateway or a Virtual Private Cloud (VPC) NAT gateway.
   * 
   * @remarks
   * ## Usage notes
   * Before you call this operation, take note of the following items:
   * *   When you create an enhanced NAT gateway for the first time, the system automatically creates the service-linked role AliyunServiceRoleForNatgw. Then, the system attaches the permission policy AliyunServiceRolePolicyForNatgw to the role. This allows the NAT gateway to access other resources on Alibaba Cloud. For more information, see [Service-linked roles](https://help.aliyun.com/document_detail/174251.html).
   * *   After you create an enhanced Internet NAT gateway, a route entry is automatically added to the route table of the VPC. The destination CIDR block of the route entry is 0.0.0.0/0 and the next hop is the NAT gateway. This ensures that traffic is routed to the NAT gateway.
   * *   **CreateNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) operation to query the status of the task.
   *     *   If a NAT gateway is in the **Creating** state, the NAT gateway is being created. In this case, you can query the NAT gateway but cannot perform other operations.
   *     *   If a NAT gateway is in the **Available** state, the NAT gateway is created.
   * It takes 1 to 3 minutes to create a NAT gateway.
   * 
   * @param request - CreateNatGatewayRequest
   * @returns CreateNatGatewayResponse
   */
  async createNatGateway(request: $_model.CreateNatGatewayRequest): Promise<$_model.CreateNatGatewayResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createNatGatewayWithOptions(request, runtime);
  }

  /**
   * Creates a NAT IP address.
   * 
   * @remarks
   * ## [](#)
   * **CreateNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/287000.html) operation to query the status of the task.
   * *   If a NAT IP address is in the **Creating** state, the NAT IP address is being created. In this case, you can only query the NAT IP address and cannot perform other operations.
   * *   If a NAT IP address is in the **Available** state, the NAT IP address is created.
   * You cannot repeatedly call the **CreateNatIp** operation to create a NAT IP address within a specific period of time.
   * 
   * @param request - CreateNatIpRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateNatIpResponse
   */
  async createNatIpWithOptions(request: $_model.CreateNatIpRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateNatIpResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.natGatewayId)) {
      query["NatGatewayId"] = request.natGatewayId;
    }

    if (!$dara.isNull(request.natIp)) {
      query["NatIp"] = request.natIp;
    }

    if (!$dara.isNull(request.natIpCidr)) {
      query["NatIpCidr"] = request.natIpCidr;
    }

    if (!$dara.isNull(request.natIpDescription)) {
      query["NatIpDescription"] = request.natIpDescription;
    }

    if (!$dara.isNull(request.natIpName)) {
      query["NatIpName"] = request.natIpName;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateNatIp",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateNatIpResponse>(await this.callApi(params, req, runtime), new $_model.CreateNatIpResponse({}));
  }

  /**
   * Creates a NAT IP address.
   * 
   * @remarks
   * ## [](#)
   * **CreateNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/287000.html) operation to query the status of the task.
   * *   If a NAT IP address is in the **Creating** state, the NAT IP address is being created. In this case, you can only query the NAT IP address and cannot perform other operations.
   * *   If a NAT IP address is in the **Available** state, the NAT IP address is created.
   * You cannot repeatedly call the **CreateNatIp** operation to create a NAT IP address within a specific period of time.
   * 
   * @param request - CreateNatIpRequest
   * @returns CreateNatIpResponse
   */
  async createNatIp(request: $_model.CreateNatIpRequest): Promise<$_model.CreateNatIpResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createNatIpWithOptions(request, runtime);
  }

  /**
   * Creates a NAT CIDR block.
   * 
   * @remarks
   * ## [](#)Description
   * You cannot repeatedly call the **CreateNatIpCidr** operation to create a NAT CIDR block within the specified period of time.
   * 
   * @param request - CreateNatIpCidrRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateNatIpCidrResponse
   */
  async createNatIpCidrWithOptions(request: $_model.CreateNatIpCidrRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateNatIpCidrResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.natGatewayId)) {
      query["NatGatewayId"] = request.natGatewayId;
    }

    if (!$dara.isNull(request.natIpCidr)) {
      query["NatIpCidr"] = request.natIpCidr;
    }

    if (!$dara.isNull(request.natIpCidrDescription)) {
      query["NatIpCidrDescription"] = request.natIpCidrDescription;
    }

    if (!$dara.isNull(request.natIpCidrName)) {
      query["NatIpCidrName"] = request.natIpCidrName;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateNatIpCidr",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateNatIpCidrResponse>(await this.callApi(params, req, runtime), new $_model.CreateNatIpCidrResponse({}));
  }

  /**
   * Creates a NAT CIDR block.
   * 
   * @remarks
   * ## [](#)Description
   * You cannot repeatedly call the **CreateNatIpCidr** operation to create a NAT CIDR block within the specified period of time.
   * 
   * @param request - CreateNatIpCidrRequest
   * @returns CreateNatIpCidrResponse
   */
  async createNatIpCidr(request: $_model.CreateNatIpCidrRequest): Promise<$_model.CreateNatIpCidrResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createNatIpCidrWithOptions(request, runtime);
  }

  /**
   * Creates a network ACL.
   * 
   * @param request - CreateNetworkAclRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateNetworkAclResponse
   */
  async createNetworkAclWithOptions(request: $_model.CreateNetworkAclRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateNetworkAclResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.networkAclName)) {
      query["NetworkAclName"] = request.networkAclName;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateNetworkAcl",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateNetworkAclResponse>(await this.callApi(params, req, runtime), new $_model.CreateNetworkAclResponse({}));
  }

  /**
   * Creates a network ACL.
   * 
   * @param request - CreateNetworkAclRequest
   * @returns CreateNetworkAclResponse
   */
  async createNetworkAcl(request: $_model.CreateNetworkAclRequest): Promise<$_model.CreateNetworkAclResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createNetworkAclWithOptions(request, runtime);
  }

  /**
   * Applies for an Express Connect circuit.
   * 
   * @remarks
   * You can apply for a dedicated Express Connect circuit for yourself or create a hosted connection for a tenant. After your application is approved, the Express Connect circuit changes to the **Initial** state. You can contact the connectivity provider to start construction.
   * When you call this operation, take note of the following limits:
   * *   If your Alibaba Cloud account has more than five Express Connect circuits that are not in the **Enabled** state, you cannot apply for another Express Connect circuit.
   * *   If your Alibaba Cloud account has an Express Connect circuit with overdue payments, you cannot apply for another Express Connect circuit.
   * 
   * @param request - CreatePhysicalConnectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreatePhysicalConnectionResponse
   */
  async createPhysicalConnectionWithOptions(request: $_model.CreatePhysicalConnectionRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreatePhysicalConnectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.accessPointId)) {
      query["AccessPointId"] = request.accessPointId;
    }

    if (!$dara.isNull(request.circuitCode)) {
      query["CircuitCode"] = request.circuitCode;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.deviceAdvancedCapacity)) {
      query["DeviceAdvancedCapacity"] = request.deviceAdvancedCapacity;
    }

    if (!$dara.isNull(request.lineOperator)) {
      query["LineOperator"] = request.lineOperator;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.peerLocation)) {
      query["PeerLocation"] = request.peerLocation;
    }

    if (!$dara.isNull(request.portType)) {
      query["PortType"] = request.portType;
    }

    if (!$dara.isNull(request.redundantPhysicalConnectionId)) {
      query["RedundantPhysicalConnectionId"] = request.redundantPhysicalConnectionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.type)) {
      query["Type"] = request.type;
    }

    if (!$dara.isNull(request.bandwidth)) {
      query["bandwidth"] = request.bandwidth;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreatePhysicalConnection",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreatePhysicalConnectionResponse>(await this.callApi(params, req, runtime), new $_model.CreatePhysicalConnectionResponse({}));
  }

  /**
   * Applies for an Express Connect circuit.
   * 
   * @remarks
   * You can apply for a dedicated Express Connect circuit for yourself or create a hosted connection for a tenant. After your application is approved, the Express Connect circuit changes to the **Initial** state. You can contact the connectivity provider to start construction.
   * When you call this operation, take note of the following limits:
   * *   If your Alibaba Cloud account has more than five Express Connect circuits that are not in the **Enabled** state, you cannot apply for another Express Connect circuit.
   * *   If your Alibaba Cloud account has an Express Connect circuit with overdue payments, you cannot apply for another Express Connect circuit.
   * 
   * @param request - CreatePhysicalConnectionRequest
   * @returns CreatePhysicalConnectionResponse
   */
  async createPhysicalConnection(request: $_model.CreatePhysicalConnectionRequest): Promise<$_model.CreatePhysicalConnectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createPhysicalConnectionWithOptions(request, runtime);
  }

  /**
   * Creates an order for resource occupation of an Express Connect circuit.
   * 
   * @remarks
   * >  You can call this operation only when the Express Connect circuit is in the **Complete** state.
   * 
   * @param request - CreatePhysicalConnectionOccupancyOrderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreatePhysicalConnectionOccupancyOrderResponse
   */
  async createPhysicalConnectionOccupancyOrderWithOptions(request: $_model.CreatePhysicalConnectionOccupancyOrderRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreatePhysicalConnectionOccupancyOrderResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.autoPay)) {
      query["AutoPay"] = request.autoPay;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.instanceChargeType)) {
      query["InstanceChargeType"] = request.instanceChargeType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.period)) {
      query["Period"] = request.period;
    }

    if (!$dara.isNull(request.physicalConnectionId)) {
      query["PhysicalConnectionId"] = request.physicalConnectionId;
    }

    if (!$dara.isNull(request.pricingCycle)) {
      query["PricingCycle"] = request.pricingCycle;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreatePhysicalConnectionOccupancyOrder",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreatePhysicalConnectionOccupancyOrderResponse>(await this.callApi(params, req, runtime), new $_model.CreatePhysicalConnectionOccupancyOrderResponse({}));
  }

  /**
   * Creates an order for resource occupation of an Express Connect circuit.
   * 
   * @remarks
   * >  You can call this operation only when the Express Connect circuit is in the **Complete** state.
   * 
   * @param request - CreatePhysicalConnectionOccupancyOrderRequest
   * @returns CreatePhysicalConnectionOccupancyOrderResponse
   */
  async createPhysicalConnectionOccupancyOrder(request: $_model.CreatePhysicalConnectionOccupancyOrderRequest): Promise<$_model.CreatePhysicalConnectionOccupancyOrderResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createPhysicalConnectionOccupancyOrderWithOptions(request, runtime);
  }

  /**
   * Creates an order for initial installation of an Express Connect circuit.
   * 
   * @param request - CreatePhysicalConnectionSetupOrderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreatePhysicalConnectionSetupOrderResponse
   */
  async createPhysicalConnectionSetupOrderWithOptions(request: $_model.CreatePhysicalConnectionSetupOrderRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreatePhysicalConnectionSetupOrderResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.accessPointId)) {
      query["AccessPointId"] = request.accessPointId;
    }

    if (!$dara.isNull(request.autoPay)) {
      query["AutoPay"] = request.autoPay;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.lineOperator)) {
      query["LineOperator"] = request.lineOperator;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.portType)) {
      query["PortType"] = request.portType;
    }

    if (!$dara.isNull(request.redundantPhysicalConnectionId)) {
      query["RedundantPhysicalConnectionId"] = request.redundantPhysicalConnectionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreatePhysicalConnectionSetupOrder",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreatePhysicalConnectionSetupOrderResponse>(await this.callApi(params, req, runtime), new $_model.CreatePhysicalConnectionSetupOrderResponse({}));
  }

  /**
   * Creates an order for initial installation of an Express Connect circuit.
   * 
   * @param request - CreatePhysicalConnectionSetupOrderRequest
   * @returns CreatePhysicalConnectionSetupOrderResponse
   */
  async createPhysicalConnectionSetupOrder(request: $_model.CreatePhysicalConnectionSetupOrderRequest): Promise<$_model.CreatePhysicalConnectionSetupOrderResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createPhysicalConnectionSetupOrderWithOptions(request, runtime);
  }

  /**
   * Creates an IP address pool.
   * 
   * @remarks
   * By default, the IP address pool feature is unavailable. You can apply for the privilege to use the **IP address pool feature** in the Quota Center console. For more information, see the "Request a quota increase in the Quota Center console" section in the [Manage EIP quotas](https://help.aliyun.com/document_detail/108213.html) topic.
   * 
   * @param request - CreatePublicIpAddressPoolRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreatePublicIpAddressPoolResponse
   */
  async createPublicIpAddressPoolWithOptions(request: $_model.CreatePublicIpAddressPoolRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreatePublicIpAddressPoolResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bizType)) {
      query["BizType"] = request.bizType;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.isp)) {
      query["Isp"] = request.isp;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.securityProtectionTypes)) {
      query["SecurityProtectionTypes"] = request.securityProtectionTypes;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.zones)) {
      query["Zones"] = request.zones;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreatePublicIpAddressPool",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreatePublicIpAddressPoolResponse>(await this.callApi(params, req, runtime), new $_model.CreatePublicIpAddressPoolResponse({}));
  }

  /**
   * Creates an IP address pool.
   * 
   * @remarks
   * By default, the IP address pool feature is unavailable. You can apply for the privilege to use the **IP address pool feature** in the Quota Center console. For more information, see the "Request a quota increase in the Quota Center console" section in the [Manage EIP quotas](https://help.aliyun.com/document_detail/108213.html) topic.
   * 
   * @param request - CreatePublicIpAddressPoolRequest
   * @returns CreatePublicIpAddressPoolResponse
   */
  async createPublicIpAddressPool(request: $_model.CreatePublicIpAddressPoolRequest): Promise<$_model.CreatePublicIpAddressPoolResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createPublicIpAddressPoolWithOptions(request, runtime);
  }

  /**
   * Adds custom route entries to the route table of a vRouter in a virtual private cloud (VPC).
   * 
   * @remarks
   * ## [](#)References
   * *   **CreateRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
   *     *   If the route entry is in the **Creating** state, the route entry is being created.
   *     *   If the route entry is in the **Created** state, the route entry is created.
   * *   You cannot repeatedly call the **CreateRouteEntries** operation to create the same route entry within the specified period of time.
   * **When you call this operation to add custom route entries to the route table of a vRouter, take note of the following items:**
   * *   A route table can contain up to 200 custom route entries.
   * *   The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be the same as or overlap with the CIDR block of a vSwitch in the VPC.
   * *   The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or its subnets.
   * *   The destination CIDR blocks (**DstCidrBlock**) of route entries in the same route table must be unique.
   * *   If you do not include the mask length when you specify the destination CIDR block (**DstCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
   * *   Multiple custom route entries can point to the same next hop (**NextHop**).
   * *   The next hop (**NextHop**) of a custom route entry must belong to the same VPC as the route table.
   * 
   * @param request - CreateRouteEntriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRouteEntriesResponse
   */
  async createRouteEntriesWithOptions(request: $_model.CreateRouteEntriesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateRouteEntriesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeEntries)) {
      query["RouteEntries"] = request.routeEntries;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateRouteEntries",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateRouteEntriesResponse>(await this.callApi(params, req, runtime), new $_model.CreateRouteEntriesResponse({}));
  }

  /**
   * Adds custom route entries to the route table of a vRouter in a virtual private cloud (VPC).
   * 
   * @remarks
   * ## [](#)References
   * *   **CreateRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
   *     *   If the route entry is in the **Creating** state, the route entry is being created.
   *     *   If the route entry is in the **Created** state, the route entry is created.
   * *   You cannot repeatedly call the **CreateRouteEntries** operation to create the same route entry within the specified period of time.
   * **When you call this operation to add custom route entries to the route table of a vRouter, take note of the following items:**
   * *   A route table can contain up to 200 custom route entries.
   * *   The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be the same as or overlap with the CIDR block of a vSwitch in the VPC.
   * *   The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or its subnets.
   * *   The destination CIDR blocks (**DstCidrBlock**) of route entries in the same route table must be unique.
   * *   If you do not include the mask length when you specify the destination CIDR block (**DstCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
   * *   Multiple custom route entries can point to the same next hop (**NextHop**).
   * *   The next hop (**NextHop**) of a custom route entry must belong to the same VPC as the route table.
   * 
   * @param request - CreateRouteEntriesRequest
   * @returns CreateRouteEntriesResponse
   */
  async createRouteEntries(request: $_model.CreateRouteEntriesRequest): Promise<$_model.CreateRouteEntriesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createRouteEntriesWithOptions(request, runtime);
  }

  /**
   * Creates a custom route entry in the route table of a VRouter or virtual border router (VBR).
   * 
   * @remarks
   *   **CreateRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task:
   *     *   If a route is in the **Creating** state, the route is being added.
   *     *   If a route is in the **Created** state, the route is added.
   * *   You cannot repeatedly call **CreateRouteEntry** within a specific period of time.
   * **When you call this operation to add a custom route entry to the route table of a vRouter, take note of the following limits:**
   * >  When you add a route entry from a prefix list, the quota usage is calculated by adding the number of existing route entries and the maximum number of route entries of the prefix list.
   * *   A route table can contain up to 200 custom route entries.
   * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be the same as or be a subset of the CIDR block of a vSwitch in the virtual private cloud (VPC). The destination CIDR block can contain the CIDR block of a vSwitch.
   * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
   * *   The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
   * *   If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
   * *   Multiple custom route entries can point to the same next hop (**NextHopId**).
   * *   The next hop (**NextHopId**) of a custom route entry must in the same VPC as the route table.
   * *   Equal-cost multi-path (ECMP) routing can be configured by specifying the **NextHopList** parameter.
   *     *   When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you must not specify **NextHopList**.
   *     *   When you add route entries for ECMP routing, you must specify **DestinationCidrBlock** and **NextHopList**, and you must not specify **NextHopType** or **NextHopId**.
   * **When you call this operation to add a custom route entry to the route table of a VBR, take note of the following limits:**
   * *   A route table can contain up to 200 custom route entries.
   * *   **NextHopList** is not supported.
   * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
   * *   The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
   * *   If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
   * *   Multiple custom route entries can point to the same next hop (**NextHopId**).
   * *   The next hop (**NextHopId**) of a custom route entry must be a router interface associated with the VBR.
   * *   You can add route entries only when the VBR is in the **Active** state, and the Express Connect circuit associated with the VBR is in the **Enabled** state and is not locked due to overdue payments.
   * *   Only non-ECMP route entries are supported. When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you cannot specify **NextHopList**.
   * 
   * @param request - CreateRouteEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRouteEntryResponse
   */
  async createRouteEntryWithOptions(request: $_model.CreateRouteEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateRouteEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.destinationCidrBlock)) {
      query["DestinationCidrBlock"] = request.destinationCidrBlock;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.nextHopId)) {
      query["NextHopId"] = request.nextHopId;
    }

    if (!$dara.isNull(request.nextHopList)) {
      query["NextHopList"] = request.nextHopList;
    }

    if (!$dara.isNull(request.nextHopType)) {
      query["NextHopType"] = request.nextHopType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeEntryName)) {
      query["RouteEntryName"] = request.routeEntryName;
    }

    if (!$dara.isNull(request.routeTableId)) {
      query["RouteTableId"] = request.routeTableId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateRouteEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateRouteEntryResponse>(await this.callApi(params, req, runtime), new $_model.CreateRouteEntryResponse({}));
  }

  /**
   * Creates a custom route entry in the route table of a VRouter or virtual border router (VBR).
   * 
   * @remarks
   *   **CreateRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task:
   *     *   If a route is in the **Creating** state, the route is being added.
   *     *   If a route is in the **Created** state, the route is added.
   * *   You cannot repeatedly call **CreateRouteEntry** within a specific period of time.
   * **When you call this operation to add a custom route entry to the route table of a vRouter, take note of the following limits:**
   * >  When you add a route entry from a prefix list, the quota usage is calculated by adding the number of existing route entries and the maximum number of route entries of the prefix list.
   * *   A route table can contain up to 200 custom route entries.
   * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be the same as or be a subset of the CIDR block of a vSwitch in the virtual private cloud (VPC). The destination CIDR block can contain the CIDR block of a vSwitch.
   * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
   * *   The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
   * *   If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
   * *   Multiple custom route entries can point to the same next hop (**NextHopId**).
   * *   The next hop (**NextHopId**) of a custom route entry must in the same VPC as the route table.
   * *   Equal-cost multi-path (ECMP) routing can be configured by specifying the **NextHopList** parameter.
   *     *   When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you must not specify **NextHopList**.
   *     *   When you add route entries for ECMP routing, you must specify **DestinationCidrBlock** and **NextHopList**, and you must not specify **NextHopType** or **NextHopId**.
   * **When you call this operation to add a custom route entry to the route table of a VBR, take note of the following limits:**
   * *   A route table can contain up to 200 custom route entries.
   * *   **NextHopList** is not supported.
   * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
   * *   The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
   * *   If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
   * *   Multiple custom route entries can point to the same next hop (**NextHopId**).
   * *   The next hop (**NextHopId**) of a custom route entry must be a router interface associated with the VBR.
   * *   You can add route entries only when the VBR is in the **Active** state, and the Express Connect circuit associated with the VBR is in the **Enabled** state and is not locked due to overdue payments.
   * *   Only non-ECMP route entries are supported. When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you cannot specify **NextHopList**.
   * 
   * @param request - CreateRouteEntryRequest
   * @returns CreateRouteEntryResponse
   */
  async createRouteEntry(request: $_model.CreateRouteEntryRequest): Promise<$_model.CreateRouteEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createRouteEntryWithOptions(request, runtime);
  }

  /**
   * Creates a custom route table.
   * 
   * @remarks
   *   **CreateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the operation in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
   *     *   If the custom route table is in the **Creating** state, the custom route table is being created.
   *     *   If the custom route table is in the **Created** state, the custom route table is created.
   * *   You cannot repeatedly call the **CreateRouteTable** operation within the specified period of time.
   * 
   * @param request - CreateRouteTableRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRouteTableResponse
   */
  async createRouteTableWithOptions(request: $_model.CreateRouteTableRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateRouteTableResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.associateType)) {
      query["AssociateType"] = request.associateType;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeTableName)) {
      query["RouteTableName"] = request.routeTableName;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateRouteTable",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateRouteTableResponse>(await this.callApi(params, req, runtime), new $_model.CreateRouteTableResponse({}));
  }

  /**
   * Creates a custom route table.
   * 
   * @remarks
   *   **CreateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the operation in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
   *     *   If the custom route table is in the **Creating** state, the custom route table is being created.
   *     *   If the custom route table is in the **Created** state, the custom route table is created.
   * *   You cannot repeatedly call the **CreateRouteTable** operation within the specified period of time.
   * 
   * @param request - CreateRouteTableRequest
   * @returns CreateRouteTableResponse
   */
  async createRouteTable(request: $_model.CreateRouteTableRequest): Promise<$_model.CreateRouteTableResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createRouteTableWithOptions(request, runtime);
  }

  /**
   * Creates a router interface.
   * 
   * @remarks
   * When you call this operation, take note of the following limits:
   * *   You can create only one pair of interfaces to be connected between two routers.
   * *   You can create a maximum of five router interfaces for a router.
   * *   If your Alibaba Cloud account has a router interface with overdue payments, you cannot create new router interfaces.
   * *   Each destination CIDR block of route entries in the same route table must be unique.
   * *   A virtual border router (VBR) can serve only as a requester. The VBR must be in the Activated state.
   * *   You can call this operation to create subscription and pay-as-you-go router interfaces.
   * 
   * @param request - CreateRouterInterfaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRouterInterfaceResponse
   */
  async createRouterInterfaceWithOptions(request: $_model.CreateRouterInterfaceRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateRouterInterfaceResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.accessPointId)) {
      query["AccessPointId"] = request.accessPointId;
    }

    if (!$dara.isNull(request.autoPay)) {
      query["AutoPay"] = request.autoPay;
    }

    if (!$dara.isNull(request.autoRenew)) {
      query["AutoRenew"] = request.autoRenew;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.fastLinkMode)) {
      query["FastLinkMode"] = request.fastLinkMode;
    }

    if (!$dara.isNull(request.healthCheckSourceIp)) {
      query["HealthCheckSourceIp"] = request.healthCheckSourceIp;
    }

    if (!$dara.isNull(request.healthCheckTargetIp)) {
      query["HealthCheckTargetIp"] = request.healthCheckTargetIp;
    }

    if (!$dara.isNull(request.instanceChargeType)) {
      query["InstanceChargeType"] = request.instanceChargeType;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.oppositeAccessPointId)) {
      query["OppositeAccessPointId"] = request.oppositeAccessPointId;
    }

    if (!$dara.isNull(request.oppositeInterfaceId)) {
      query["OppositeInterfaceId"] = request.oppositeInterfaceId;
    }

    if (!$dara.isNull(request.oppositeInterfaceOwnerId)) {
      query["OppositeInterfaceOwnerId"] = request.oppositeInterfaceOwnerId;
    }

    if (!$dara.isNull(request.oppositeRegionId)) {
      query["OppositeRegionId"] = request.oppositeRegionId;
    }

    if (!$dara.isNull(request.oppositeRouterId)) {
      query["OppositeRouterId"] = request.oppositeRouterId;
    }

    if (!$dara.isNull(request.oppositeRouterType)) {
      query["OppositeRouterType"] = request.oppositeRouterType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.period)) {
      query["Period"] = request.period;
    }

    if (!$dara.isNull(request.pricingCycle)) {
      query["PricingCycle"] = request.pricingCycle;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.role)) {
      query["Role"] = request.role;
    }

    if (!$dara.isNull(request.routerId)) {
      query["RouterId"] = request.routerId;
    }

    if (!$dara.isNull(request.routerType)) {
      query["RouterType"] = request.routerType;
    }

    if (!$dara.isNull(request.spec)) {
      query["Spec"] = request.spec;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateRouterInterface",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateRouterInterfaceResponse>(await this.callApi(params, req, runtime), new $_model.CreateRouterInterfaceResponse({}));
  }

  /**
   * Creates a router interface.
   * 
   * @remarks
   * When you call this operation, take note of the following limits:
   * *   You can create only one pair of interfaces to be connected between two routers.
   * *   You can create a maximum of five router interfaces for a router.
   * *   If your Alibaba Cloud account has a router interface with overdue payments, you cannot create new router interfaces.
   * *   Each destination CIDR block of route entries in the same route table must be unique.
   * *   A virtual border router (VBR) can serve only as a requester. The VBR must be in the Activated state.
   * *   You can call this operation to create subscription and pay-as-you-go router interfaces.
   * 
   * @param request - CreateRouterInterfaceRequest
   * @returns CreateRouterInterfaceResponse
   */
  async createRouterInterface(request: $_model.CreateRouterInterfaceRequest): Promise<$_model.CreateRouterInterfaceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createRouterInterfaceWithOptions(request, runtime);
  }

  /**
   * Adds an SNAT entry to an SNAT table.
   * 
   * @remarks
   * You can call this operation to add SNAT entries to Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways. In this topic, a **NAT** gateway refers to both gateway types.
   * Before you call this operation, take note of the following limits:
   * *   **CreateSnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
   *     *   If the SNAT entry is in the **Pending** state, the system is adding the SNAT entry. You can only query the status of the SNAT entry, and cannot perform other operations.
   *     *   If the SNAT entry is in the **Available** state, the SNAT entry is added.
   * *   You cannot repeatedly call the **CreateSnatEntry** operation to add an SNAT entry to an SNAT table within the specified period of time.
   * *   The vSwitch and Elastic Compute Service (ECS) instance specified in an SNAT entry must be created in the VPC where the NAT gateway is deployed.
   * *   Each vSwitch or ECS instance can be specified in only one SNAT entry.
   * *   If a high-availability virtual IP address (HAVIP) exists in a vSwitch, you cannot create SNAT entries.
   * 
   * @param request - CreateSnatEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSnatEntryResponse
   */
  async createSnatEntryWithOptions(request: $_model.CreateSnatEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateSnatEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.eipAffinity)) {
      query["EipAffinity"] = request.eipAffinity;
    }

    if (!$dara.isNull(request.networkInterfaceId)) {
      query["NetworkInterfaceId"] = request.networkInterfaceId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.snatEntryName)) {
      query["SnatEntryName"] = request.snatEntryName;
    }

    if (!$dara.isNull(request.snatIp)) {
      query["SnatIp"] = request.snatIp;
    }

    if (!$dara.isNull(request.snatTableId)) {
      query["SnatTableId"] = request.snatTableId;
    }

    if (!$dara.isNull(request.sourceCIDR)) {
      query["SourceCIDR"] = request.sourceCIDR;
    }

    if (!$dara.isNull(request.sourceVSwitchId)) {
      query["SourceVSwitchId"] = request.sourceVSwitchId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateSnatEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateSnatEntryResponse>(await this.callApi(params, req, runtime), new $_model.CreateSnatEntryResponse({}));
  }

  /**
   * Adds an SNAT entry to an SNAT table.
   * 
   * @remarks
   * You can call this operation to add SNAT entries to Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways. In this topic, a **NAT** gateway refers to both gateway types.
   * Before you call this operation, take note of the following limits:
   * *   **CreateSnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
   *     *   If the SNAT entry is in the **Pending** state, the system is adding the SNAT entry. You can only query the status of the SNAT entry, and cannot perform other operations.
   *     *   If the SNAT entry is in the **Available** state, the SNAT entry is added.
   * *   You cannot repeatedly call the **CreateSnatEntry** operation to add an SNAT entry to an SNAT table within the specified period of time.
   * *   The vSwitch and Elastic Compute Service (ECS) instance specified in an SNAT entry must be created in the VPC where the NAT gateway is deployed.
   * *   Each vSwitch or ECS instance can be specified in only one SNAT entry.
   * *   If a high-availability virtual IP address (HAVIP) exists in a vSwitch, you cannot create SNAT entries.
   * 
   * @param request - CreateSnatEntryRequest
   * @returns CreateSnatEntryResponse
   */
  async createSnatEntry(request: $_model.CreateSnatEntryRequest): Promise<$_model.CreateSnatEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createSnatEntryWithOptions(request, runtime);
  }

  /**
   * Creates an SSL client certificate.
   * 
   * @remarks
   * Before you create an SSL client certificate, make sure that an SSL server is created on the VPN gateway. For more information, see [CreateSslVpnServer](https://help.aliyun.com/document_detail/2794075.html).
   * 
   * @param request - CreateSslVpnClientCertRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSslVpnClientCertResponse
   */
  async createSslVpnClientCertWithOptions(request: $_model.CreateSslVpnClientCertRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateSslVpnClientCertResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.sslVpnServerId)) {
      query["SslVpnServerId"] = request.sslVpnServerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateSslVpnClientCert",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateSslVpnClientCertResponse>(await this.callApi(params, req, runtime), new $_model.CreateSslVpnClientCertResponse({}));
  }

  /**
   * Creates an SSL client certificate.
   * 
   * @remarks
   * Before you create an SSL client certificate, make sure that an SSL server is created on the VPN gateway. For more information, see [CreateSslVpnServer](https://help.aliyun.com/document_detail/2794075.html).
   * 
   * @param request - CreateSslVpnClientCertRequest
   * @returns CreateSslVpnClientCertResponse
   */
  async createSslVpnClientCert(request: $_model.CreateSslVpnClientCertRequest): Promise<$_model.CreateSslVpnClientCertResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createSslVpnClientCertWithOptions(request, runtime);
  }

  /**
   * Creates an SSL server.
   * 
   * @remarks
   *   **CreateSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the SSL server is being created.
   *     *   If the VPN gateway is in the **active** state, the SSL server is created.
   * *   You cannot repeatedly call the **CreateSslVpnServer** operation within the specified period of time.
   * ### [](#)Prerequisite
   * *   A VPN gateway is created, and the SSL-VPN feature is enabled for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
   * *   If you want to enable two-factor authentication for the SSL server, make sure that the VPN gateway supports two-factor authentication. You may need to upgrade the VPN gateway. For more information, see [Two-factor authentication supports IDaaS EIAM 2.0](https://help.aliyun.com/document_detail/2785320.html).
   * 
   * @param request - CreateSslVpnServerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSslVpnServerResponse
   */
  async createSslVpnServerWithOptions(request: $_model.CreateSslVpnServerRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateSslVpnServerResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.cipher)) {
      query["Cipher"] = request.cipher;
    }

    if (!$dara.isNull(request.clientIpPool)) {
      query["ClientIpPool"] = request.clientIpPool;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.compress)) {
      query["Compress"] = request.compress;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.enableMultiFactorAuth)) {
      query["EnableMultiFactorAuth"] = request.enableMultiFactorAuth;
    }

    if (!$dara.isNull(request.IDaaSApplicationId)) {
      query["IDaaSApplicationId"] = request.IDaaSApplicationId;
    }

    if (!$dara.isNull(request.IDaaSInstanceId)) {
      query["IDaaSInstanceId"] = request.IDaaSInstanceId;
    }

    if (!$dara.isNull(request.IDaaSRegionId)) {
      query["IDaaSRegionId"] = request.IDaaSRegionId;
    }

    if (!$dara.isNull(request.localSubnet)) {
      query["LocalSubnet"] = request.localSubnet;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.port)) {
      query["Port"] = request.port;
    }

    if (!$dara.isNull(request.proto)) {
      query["Proto"] = request.proto;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateSslVpnServer",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateSslVpnServerResponse>(await this.callApi(params, req, runtime), new $_model.CreateSslVpnServerResponse({}));
  }

  /**
   * Creates an SSL server.
   * 
   * @remarks
   *   **CreateSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the SSL server is being created.
   *     *   If the VPN gateway is in the **active** state, the SSL server is created.
   * *   You cannot repeatedly call the **CreateSslVpnServer** operation within the specified period of time.
   * ### [](#)Prerequisite
   * *   A VPN gateway is created, and the SSL-VPN feature is enabled for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
   * *   If you want to enable two-factor authentication for the SSL server, make sure that the VPN gateway supports two-factor authentication. You may need to upgrade the VPN gateway. For more information, see [Two-factor authentication supports IDaaS EIAM 2.0](https://help.aliyun.com/document_detail/2785320.html).
   * 
   * @param request - CreateSslVpnServerRequest
   * @returns CreateSslVpnServerResponse
   */
  async createSslVpnServer(request: $_model.CreateSslVpnServerRequest): Promise<$_model.CreateSslVpnServerResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createSslVpnServerWithOptions(request, runtime);
  }

  /**
   * Creates a filter for traffic mirror.
   * 
   * @remarks
   * *CreateTrafficMirrorFilter** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of the task.
   * *   If the filter is in the **Creating** state, the filter is being created.
   * *   If the filter is in the **Created** state, the filter is created.
   * 
   * @param request - CreateTrafficMirrorFilterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTrafficMirrorFilterResponse
   */
  async createTrafficMirrorFilterWithOptions(request: $_model.CreateTrafficMirrorFilterRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateTrafficMirrorFilterResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.egressRules)) {
      query["EgressRules"] = request.egressRules;
    }

    if (!$dara.isNull(request.ingressRules)) {
      query["IngressRules"] = request.ingressRules;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.trafficMirrorFilterDescription)) {
      query["TrafficMirrorFilterDescription"] = request.trafficMirrorFilterDescription;
    }

    if (!$dara.isNull(request.trafficMirrorFilterName)) {
      query["TrafficMirrorFilterName"] = request.trafficMirrorFilterName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateTrafficMirrorFilter",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateTrafficMirrorFilterResponse>(await this.callApi(params, req, runtime), new $_model.CreateTrafficMirrorFilterResponse({}));
  }

  /**
   * Creates a filter for traffic mirror.
   * 
   * @remarks
   * *CreateTrafficMirrorFilter** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of the task.
   * *   If the filter is in the **Creating** state, the filter is being created.
   * *   If the filter is in the **Created** state, the filter is created.
   * 
   * @param request - CreateTrafficMirrorFilterRequest
   * @returns CreateTrafficMirrorFilterResponse
   */
  async createTrafficMirrorFilter(request: $_model.CreateTrafficMirrorFilterRequest): Promise<$_model.CreateTrafficMirrorFilterResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createTrafficMirrorFilterWithOptions(request, runtime);
  }

  /**
   * Creates an inbound or outbound rule for traffic mirror.
   * 
   * @remarks
   *   **CreateTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
   *     *   If the inbound or outbound rule is in the **Creating** state, the rule is being created.
   *     *   If the inbound or outbound rule is in the **Created** state, the rule is created.
   * *   You cannot call **CreateTrafficMirrorFilterRules** within the specified period of time.
   * 
   * @param request - CreateTrafficMirrorFilterRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTrafficMirrorFilterRulesResponse
   */
  async createTrafficMirrorFilterRulesWithOptions(request: $_model.CreateTrafficMirrorFilterRulesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateTrafficMirrorFilterRulesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.egressRules)) {
      query["EgressRules"] = request.egressRules;
    }

    if (!$dara.isNull(request.ingressRules)) {
      query["IngressRules"] = request.ingressRules;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.trafficMirrorFilterId)) {
      query["TrafficMirrorFilterId"] = request.trafficMirrorFilterId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateTrafficMirrorFilterRules",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateTrafficMirrorFilterRulesResponse>(await this.callApi(params, req, runtime), new $_model.CreateTrafficMirrorFilterRulesResponse({}));
  }

  /**
   * Creates an inbound or outbound rule for traffic mirror.
   * 
   * @remarks
   *   **CreateTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
   *     *   If the inbound or outbound rule is in the **Creating** state, the rule is being created.
   *     *   If the inbound or outbound rule is in the **Created** state, the rule is created.
   * *   You cannot call **CreateTrafficMirrorFilterRules** within the specified period of time.
   * 
   * @param request - CreateTrafficMirrorFilterRulesRequest
   * @returns CreateTrafficMirrorFilterRulesResponse
   */
  async createTrafficMirrorFilterRules(request: $_model.CreateTrafficMirrorFilterRulesRequest): Promise<$_model.CreateTrafficMirrorFilterRulesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createTrafficMirrorFilterRulesWithOptions(request, runtime);
  }

  /**
   * Creates a traffic mirror session.
   * 
   * @remarks
   * *CreateTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) to query the status of the task.
   * *   If the traffic mirror session is in the **Creating** state, it is being created.
   * *   If the traffic mirror session is in the **Created** state, it is created.
   * 
   * @param request - CreateTrafficMirrorSessionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTrafficMirrorSessionResponse
   */
  async createTrafficMirrorSessionWithOptions(request: $_model.CreateTrafficMirrorSessionRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateTrafficMirrorSessionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.enabled)) {
      query["Enabled"] = request.enabled;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.packetLength)) {
      query["PacketLength"] = request.packetLength;
    }

    if (!$dara.isNull(request.priority)) {
      query["Priority"] = request.priority;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.trafficMirrorFilterId)) {
      query["TrafficMirrorFilterId"] = request.trafficMirrorFilterId;
    }

    if (!$dara.isNull(request.trafficMirrorSessionDescription)) {
      query["TrafficMirrorSessionDescription"] = request.trafficMirrorSessionDescription;
    }

    if (!$dara.isNull(request.trafficMirrorSessionName)) {
      query["TrafficMirrorSessionName"] = request.trafficMirrorSessionName;
    }

    if (!$dara.isNull(request.trafficMirrorSourceIds)) {
      query["TrafficMirrorSourceIds"] = request.trafficMirrorSourceIds;
    }

    if (!$dara.isNull(request.trafficMirrorTargetId)) {
      query["TrafficMirrorTargetId"] = request.trafficMirrorTargetId;
    }

    if (!$dara.isNull(request.trafficMirrorTargetType)) {
      query["TrafficMirrorTargetType"] = request.trafficMirrorTargetType;
    }

    if (!$dara.isNull(request.virtualNetworkId)) {
      query["VirtualNetworkId"] = request.virtualNetworkId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateTrafficMirrorSession",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateTrafficMirrorSessionResponse>(await this.callApi(params, req, runtime), new $_model.CreateTrafficMirrorSessionResponse({}));
  }

  /**
   * Creates a traffic mirror session.
   * 
   * @remarks
   * *CreateTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) to query the status of the task.
   * *   If the traffic mirror session is in the **Creating** state, it is being created.
   * *   If the traffic mirror session is in the **Created** state, it is created.
   * 
   * @param request - CreateTrafficMirrorSessionRequest
   * @returns CreateTrafficMirrorSessionResponse
   */
  async createTrafficMirrorSession(request: $_model.CreateTrafficMirrorSessionRequest): Promise<$_model.CreateTrafficMirrorSessionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createTrafficMirrorSessionWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @remarks
   * When you call this operation, take note of the following limits:
   * *   You can create at most 150 vSwitches in a virtual private cloud (VPC).
   * *   The first IP address and last three IP addresses of each vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
   * *   The number of instances in a vSwitch cannot exceed the remaining capacity of the VPC. The remaining capacity is the difference between 15,000 and the current number of instances.
   * *   Each instance can belong to only one vSwitch.
   * *   vSwitches do not support multicast or broadcast.
   * *   After you create a vSwitch, you cannot modify its CIDR block.
   * *   **CreateVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) to query the status of the task.
   *     *   If the vSwitch is in the **Pending** state, the vSwitch is being configured.
   *     *   If the vSwitch is in the **Available** state, the vSwitch is available.
   * *   You cannot repeatedly call the **CreateVSwitch** operation to create a vSwitch in a VPC within the specified period of time.
   * 
   * @param request - CreateVSwitchRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateVSwitchResponse
   */
  async createVSwitchWithOptions(request: $_model.CreateVSwitchRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateVSwitchResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.cidrBlock)) {
      query["CidrBlock"] = request.cidrBlock;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.ipv6CidrBlock)) {
      query["Ipv6CidrBlock"] = request.ipv6CidrBlock;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.vSwitchName)) {
      query["VSwitchName"] = request.vSwitchName;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    if (!$dara.isNull(request.vpcIpv6CidrBlock)) {
      query["VpcIpv6CidrBlock"] = request.vpcIpv6CidrBlock;
    }

    if (!$dara.isNull(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateVSwitch",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateVSwitchResponse>(await this.callApi(params, req, runtime), new $_model.CreateVSwitchResponse({}));
  }

  /**
   * 
   * 
   * @remarks
   * When you call this operation, take note of the following limits:
   * *   You can create at most 150 vSwitches in a virtual private cloud (VPC).
   * *   The first IP address and last three IP addresses of each vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
   * *   The number of instances in a vSwitch cannot exceed the remaining capacity of the VPC. The remaining capacity is the difference between 15,000 and the current number of instances.
   * *   Each instance can belong to only one vSwitch.
   * *   vSwitches do not support multicast or broadcast.
   * *   After you create a vSwitch, you cannot modify its CIDR block.
   * *   **CreateVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) to query the status of the task.
   *     *   If the vSwitch is in the **Pending** state, the vSwitch is being configured.
   *     *   If the vSwitch is in the **Available** state, the vSwitch is available.
   * *   You cannot repeatedly call the **CreateVSwitch** operation to create a vSwitch in a VPC within the specified period of time.
   * 
   * @param request - CreateVSwitchRequest
   * @returns CreateVSwitchResponse
   */
  async createVSwitch(request: $_model.CreateVSwitchRequest): Promise<$_model.CreateVSwitchResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createVSwitchWithOptions(request, runtime);
  }

  /**
   * Creates a reserved CIDR block for a vSwitch.
   * 
   * @remarks
   * ## [](#)Description
   * Take note of the following items:
   * *   You can create at most 10 reserved IPv4 CIDR blocks and 10 reserved IPv6 CIDR blocks for each vSwitch in a virtual private cloud (VPC).
   * *   After you create a reserved CIDR block for a vSwitch, the CIDR block cannot contain the IP address of the subnet gateway of the VPC to which the vSwitch belongs.
   * *   **CreateVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
   *     *   If the vSwitch is in the **Assigning** state, the reserved CIDR block is being created.
   *     *   If the vSwitch is in the **Assigned** state, the reserved CIDR block is created.
   * *   When you create a reserved IPv4 CIDR block for a vSwitch, the first IP address and the last three IP addresses of the vSwitch are reserved by the system. The four IP addresses will not be allocated.
   * *   When you create a reserved IPv6 CIDR block for a vSwitch, the first IP address and the last nine IP addresses of the vSwitch are reserved by the system. The 10 IP addresses will not be allocated. For example, if you create a reserved IPv4 CIDR block for a vSwitch whose CIDR block is 192.168.1.0/24, the reserved CIDR block cannot contain the following IP addresses: 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255.
   * 
   * @param request - CreateVSwitchCidrReservationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateVSwitchCidrReservationResponse
   */
  async createVSwitchCidrReservationWithOptions(request: $_model.CreateVSwitchCidrReservationRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateVSwitchCidrReservationResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ipVersion)) {
      query["IpVersion"] = request.ipVersion;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.vSwitchCidrReservationCidr)) {
      query["VSwitchCidrReservationCidr"] = request.vSwitchCidrReservationCidr;
    }

    if (!$dara.isNull(request.vSwitchCidrReservationDescription)) {
      query["VSwitchCidrReservationDescription"] = request.vSwitchCidrReservationDescription;
    }

    if (!$dara.isNull(request.vSwitchCidrReservationMask)) {
      query["VSwitchCidrReservationMask"] = request.vSwitchCidrReservationMask;
    }

    if (!$dara.isNull(request.vSwitchCidrReservationName)) {
      query["VSwitchCidrReservationName"] = request.vSwitchCidrReservationName;
    }

    if (!$dara.isNull(request.vSwitchCidrReservationType)) {
      query["VSwitchCidrReservationType"] = request.vSwitchCidrReservationType;
    }

    if (!$dara.isNull(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateVSwitchCidrReservation",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateVSwitchCidrReservationResponse>(await this.callApi(params, req, runtime), new $_model.CreateVSwitchCidrReservationResponse({}));
  }

  /**
   * Creates a reserved CIDR block for a vSwitch.
   * 
   * @remarks
   * ## [](#)Description
   * Take note of the following items:
   * *   You can create at most 10 reserved IPv4 CIDR blocks and 10 reserved IPv6 CIDR blocks for each vSwitch in a virtual private cloud (VPC).
   * *   After you create a reserved CIDR block for a vSwitch, the CIDR block cannot contain the IP address of the subnet gateway of the VPC to which the vSwitch belongs.
   * *   **CreateVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
   *     *   If the vSwitch is in the **Assigning** state, the reserved CIDR block is being created.
   *     *   If the vSwitch is in the **Assigned** state, the reserved CIDR block is created.
   * *   When you create a reserved IPv4 CIDR block for a vSwitch, the first IP address and the last three IP addresses of the vSwitch are reserved by the system. The four IP addresses will not be allocated.
   * *   When you create a reserved IPv6 CIDR block for a vSwitch, the first IP address and the last nine IP addresses of the vSwitch are reserved by the system. The 10 IP addresses will not be allocated. For example, if you create a reserved IPv4 CIDR block for a vSwitch whose CIDR block is 192.168.1.0/24, the reserved CIDR block cannot contain the following IP addresses: 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255.
   * 
   * @param request - CreateVSwitchCidrReservationRequest
   * @returns CreateVSwitchCidrReservationResponse
   */
  async createVSwitchCidrReservation(request: $_model.CreateVSwitchCidrReservationRequest): Promise<$_model.CreateVSwitchCidrReservationResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createVSwitchCidrReservationWithOptions(request, runtime);
  }

  /**
   * Creates a virtual border router (VBR) failover group.
   * 
   * @param request - CreateVbrHaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateVbrHaResponse
   */
  async createVbrHaWithOptions(request: $_model.CreateVbrHaRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateVbrHaResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.peerVbrId)) {
      query["PeerVbrId"] = request.peerVbrId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vbrId)) {
      query["VbrId"] = request.vbrId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateVbrHa",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateVbrHaResponse>(await this.callApi(params, req, runtime), new $_model.CreateVbrHaResponse({}));
  }

  /**
   * Creates a virtual border router (VBR) failover group.
   * 
   * @param request - CreateVbrHaRequest
   * @returns CreateVbrHaResponse
   */
  async createVbrHa(request: $_model.CreateVbrHaRequest): Promise<$_model.CreateVbrHaResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createVbrHaWithOptions(request, runtime);
  }

  /**
   * Adds a destination-based route for an IPsec-VPN connection.
   * 
   * @remarks
   *   The IPsec-VPN connection must be associated with a transit router. For more information, see [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468249.html).
   * *   You cannot create a destination-based route whose destination CIDR block is 0.0.0.0/0.
   * *   Do not add a destination-based route whose destination CIDR block is 100.64.0.0/10, or a CIDR block that contains 100.64.0.0/10 or belongs to 100.64.0.0/10. Such a route will make the console fail to display the status of the IPsec-VPN connection or cause IPsec negotiation failures.
   * *   **CreateVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) to query the status of the task.
   *     *   If the IPsec-VPN connection is in the **updating** state, the destination-based route is being created.
   *     *   If the IPsec-VPN connection is in the **attached** state, the destination-based route is created.
   * *   You cannot repeatedly call **CreateVcoRouteEntry** within the specified period of time.
   * 
   * @param request - CreateVcoRouteEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateVcoRouteEntryResponse
   */
  async createVcoRouteEntryWithOptions(request: $_model.CreateVcoRouteEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateVcoRouteEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.nextHop)) {
      query["NextHop"] = request.nextHop;
    }

    if (!$dara.isNull(request.overlayMode)) {
      query["OverlayMode"] = request.overlayMode;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeDest)) {
      query["RouteDest"] = request.routeDest;
    }

    if (!$dara.isNull(request.vpnConnectionId)) {
      query["VpnConnectionId"] = request.vpnConnectionId;
    }

    if (!$dara.isNull(request.weight)) {
      query["Weight"] = request.weight;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateVcoRouteEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateVcoRouteEntryResponse>(await this.callApi(params, req, runtime), new $_model.CreateVcoRouteEntryResponse({}));
  }

  /**
   * Adds a destination-based route for an IPsec-VPN connection.
   * 
   * @remarks
   *   The IPsec-VPN connection must be associated with a transit router. For more information, see [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468249.html).
   * *   You cannot create a destination-based route whose destination CIDR block is 0.0.0.0/0.
   * *   Do not add a destination-based route whose destination CIDR block is 100.64.0.0/10, or a CIDR block that contains 100.64.0.0/10 or belongs to 100.64.0.0/10. Such a route will make the console fail to display the status of the IPsec-VPN connection or cause IPsec negotiation failures.
   * *   **CreateVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) to query the status of the task.
   *     *   If the IPsec-VPN connection is in the **updating** state, the destination-based route is being created.
   *     *   If the IPsec-VPN connection is in the **attached** state, the destination-based route is created.
   * *   You cannot repeatedly call **CreateVcoRouteEntry** within the specified period of time.
   * 
   * @param request - CreateVcoRouteEntryRequest
   * @returns CreateVcoRouteEntryResponse
   */
  async createVcoRouteEntry(request: $_model.CreateVcoRouteEntryRequest): Promise<$_model.CreateVcoRouteEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createVcoRouteEntryWithOptions(request, runtime);
  }

  /**
   * Creates a virtual border router (VBR).
   * 
   * @remarks
   * After you create a VBR, the VBR is in the **active** state.
   * 
   * @param request - CreateVirtualBorderRouterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateVirtualBorderRouterResponse
   */
  async createVirtualBorderRouterWithOptions(request: $_model.CreateVirtualBorderRouterRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateVirtualBorderRouterResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidth)) {
      query["Bandwidth"] = request.bandwidth;
    }

    if (!$dara.isNull(request.circuitCode)) {
      query["CircuitCode"] = request.circuitCode;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.enableIpv6)) {
      query["EnableIpv6"] = request.enableIpv6;
    }

    if (!$dara.isNull(request.localGatewayIp)) {
      query["LocalGatewayIp"] = request.localGatewayIp;
    }

    if (!$dara.isNull(request.localIpv6GatewayIp)) {
      query["LocalIpv6GatewayIp"] = request.localIpv6GatewayIp;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.peerGatewayIp)) {
      query["PeerGatewayIp"] = request.peerGatewayIp;
    }

    if (!$dara.isNull(request.peerIpv6GatewayIp)) {
      query["PeerIpv6GatewayIp"] = request.peerIpv6GatewayIp;
    }

    if (!$dara.isNull(request.peeringIpv6SubnetMask)) {
      query["PeeringIpv6SubnetMask"] = request.peeringIpv6SubnetMask;
    }

    if (!$dara.isNull(request.peeringSubnetMask)) {
      query["PeeringSubnetMask"] = request.peeringSubnetMask;
    }

    if (!$dara.isNull(request.physicalConnectionId)) {
      query["PhysicalConnectionId"] = request.physicalConnectionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    if (!$dara.isNull(request.vbrOwnerId)) {
      query["VbrOwnerId"] = request.vbrOwnerId;
    }

    if (!$dara.isNull(request.vlanId)) {
      query["VlanId"] = request.vlanId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateVirtualBorderRouter",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateVirtualBorderRouterResponse>(await this.callApi(params, req, runtime), new $_model.CreateVirtualBorderRouterResponse({}));
  }

  /**
   * Creates a virtual border router (VBR).
   * 
   * @remarks
   * After you create a VBR, the VBR is in the **active** state.
   * 
   * @param request - CreateVirtualBorderRouterRequest
   * @returns CreateVirtualBorderRouterResponse
   */
  async createVirtualBorderRouter(request: $_model.CreateVirtualBorderRouterRequest): Promise<$_model.CreateVirtualBorderRouterResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createVirtualBorderRouterWithOptions(request, runtime);
  }

  /**
   * Creates a hosted connection over Express Connect circuit.
   * 
   * @remarks
   * # [](#)Description
   * Before you call this operation, we recommend that you learn about the workflow for creating a hosted connection and the environment requirements. For more information, see [Overview of hosted connections](https://help.aliyun.com/document_detail/146571.html) and [Operations performed by Express Connect partners](https://help.aliyun.com/document_detail/155987.html).
   * 
   * @param request - CreateVirtualPhysicalConnectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateVirtualPhysicalConnectionResponse
   */
  async createVirtualPhysicalConnectionWithOptions(request: $_model.CreateVirtualPhysicalConnectionRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateVirtualPhysicalConnectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.orderMode)) {
      query["OrderMode"] = request.orderMode;
    }

    if (!$dara.isNull(request.physicalConnectionId)) {
      query["PhysicalConnectionId"] = request.physicalConnectionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.spec)) {
      query["Spec"] = request.spec;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.token)) {
      query["Token"] = request.token;
    }

    if (!$dara.isNull(request.vlanId)) {
      query["VlanId"] = request.vlanId;
    }

    if (!$dara.isNull(request.vpconnAliUid)) {
      query["VpconnAliUid"] = request.vpconnAliUid;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateVirtualPhysicalConnection",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateVirtualPhysicalConnectionResponse>(await this.callApi(params, req, runtime), new $_model.CreateVirtualPhysicalConnectionResponse({}));
  }

  /**
   * Creates a hosted connection over Express Connect circuit.
   * 
   * @remarks
   * # [](#)Description
   * Before you call this operation, we recommend that you learn about the workflow for creating a hosted connection and the environment requirements. For more information, see [Overview of hosted connections](https://help.aliyun.com/document_detail/146571.html) and [Operations performed by Express Connect partners](https://help.aliyun.com/document_detail/155987.html).
   * 
   * @param request - CreateVirtualPhysicalConnectionRequest
   * @returns CreateVirtualPhysicalConnectionResponse
   */
  async createVirtualPhysicalConnection(request: $_model.CreateVirtualPhysicalConnectionRequest): Promise<$_model.CreateVirtualPhysicalConnectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createVirtualPhysicalConnectionWithOptions(request, runtime);
  }

  /**
   * Creates a virtual private cloud (VPC).
   * 
   * @remarks
   * When you call this operation, take note of the following items:
   * *   You can specify only one CIDR block for each VPC.
   * *   After you create a VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to the VPC.
   * *   In each VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
   * *   After you create a VPC, a vRouter and a route table are automatically created.
   * *   At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if both 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
   * *   **CreateVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
   *     *   If the VPC is in the **Creating** state, the VPC is being created.
   *     *   If the VPC is in the **Created** state, the VPC is created.
   * *   You cannot repeatedly call the **DeleteRouteEntry** operation to create default VPCs within a specific time period. However, you can repeatedly call this operation to create custom VPCs within a specific time period.
   * 
   * @param request - CreateVpcRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateVpcResponse
   */
  async createVpcWithOptions(request: $_model.CreateVpcRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateVpcResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.cidrBlock)) {
      query["CidrBlock"] = request.cidrBlock;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.enableDnsHostname)) {
      query["EnableDnsHostname"] = request.enableDnsHostname;
    }

    if (!$dara.isNull(request.enableIpv6)) {
      query["EnableIpv6"] = request.enableIpv6;
    }

    if (!$dara.isNull(request.ipv4CidrMask)) {
      query["Ipv4CidrMask"] = request.ipv4CidrMask;
    }

    if (!$dara.isNull(request.ipv4IpamPoolId)) {
      query["Ipv4IpamPoolId"] = request.ipv4IpamPoolId;
    }

    if (!$dara.isNull(request.ipv6CidrBlock)) {
      query["Ipv6CidrBlock"] = request.ipv6CidrBlock;
    }

    if (!$dara.isNull(request.ipv6CidrMask)) {
      query["Ipv6CidrMask"] = request.ipv6CidrMask;
    }

    if (!$dara.isNull(request.ipv6IpamPoolId)) {
      query["Ipv6IpamPoolId"] = request.ipv6IpamPoolId;
    }

    if (!$dara.isNull(request.ipv6Isp)) {
      query["Ipv6Isp"] = request.ipv6Isp;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.userCidr)) {
      query["UserCidr"] = request.userCidr;
    }

    if (!$dara.isNull(request.vpcName)) {
      query["VpcName"] = request.vpcName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateVpc",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateVpcResponse>(await this.callApi(params, req, runtime), new $_model.CreateVpcResponse({}));
  }

  /**
   * Creates a virtual private cloud (VPC).
   * 
   * @remarks
   * When you call this operation, take note of the following items:
   * *   You can specify only one CIDR block for each VPC.
   * *   After you create a VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to the VPC.
   * *   In each VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
   * *   After you create a VPC, a vRouter and a route table are automatically created.
   * *   At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if both 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
   * *   **CreateVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
   *     *   If the VPC is in the **Creating** state, the VPC is being created.
   *     *   If the VPC is in the **Created** state, the VPC is created.
   * *   You cannot repeatedly call the **DeleteRouteEntry** operation to create default VPCs within a specific time period. However, you can repeatedly call this operation to create custom VPCs within a specific time period.
   * 
   * @param request - CreateVpcRequest
   * @returns CreateVpcResponse
   */
  async createVpc(request: $_model.CreateVpcRequest): Promise<$_model.CreateVpcResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createVpcWithOptions(request, runtime);
  }

  /**
   * Creates a gateway endpoint.
   * 
   * @remarks
   *   **CreateVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns an **EndpointId** and runs the task in the background. You can call the [ListVpcGatewayEndpoints](https://help.aliyun.com/document_detail/448682.html) operation to query the status of the task.
   *     *   If the gateway endpoint is in the **Creating** state, the gateway endpoint is being created.
   *     *   If the gateway endpoint is in the **Created** state, the gateway endpoint is created.
   * *   You cannot repeatedly call the **CreateVpcGatewayEndpoint** operation for the same endpoint service within the specified period of time.
   * 
   * @param request - CreateVpcGatewayEndpointRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateVpcGatewayEndpointResponse
   */
  async createVpcGatewayEndpointWithOptions(request: $_model.CreateVpcGatewayEndpointRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateVpcGatewayEndpointResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.endpointDescription)) {
      query["EndpointDescription"] = request.endpointDescription;
    }

    if (!$dara.isNull(request.endpointName)) {
      query["EndpointName"] = request.endpointName;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.policyDocument)) {
      query["PolicyDocument"] = request.policyDocument;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.serviceName)) {
      query["ServiceName"] = request.serviceName;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateVpcGatewayEndpoint",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateVpcGatewayEndpointResponse>(await this.callApi(params, req, runtime), new $_model.CreateVpcGatewayEndpointResponse({}));
  }

  /**
   * Creates a gateway endpoint.
   * 
   * @remarks
   *   **CreateVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns an **EndpointId** and runs the task in the background. You can call the [ListVpcGatewayEndpoints](https://help.aliyun.com/document_detail/448682.html) operation to query the status of the task.
   *     *   If the gateway endpoint is in the **Creating** state, the gateway endpoint is being created.
   *     *   If the gateway endpoint is in the **Created** state, the gateway endpoint is created.
   * *   You cannot repeatedly call the **CreateVpcGatewayEndpoint** operation for the same endpoint service within the specified period of time.
   * 
   * @param request - CreateVpcGatewayEndpointRequest
   * @returns CreateVpcGatewayEndpointResponse
   */
  async createVpcGatewayEndpoint(request: $_model.CreateVpcGatewayEndpointRequest): Promise<$_model.CreateVpcGatewayEndpointResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createVpcGatewayEndpointWithOptions(request, runtime);
  }

  /**
   * Creates a prefix list.
   * 
   * @remarks
   * You cannot repeatedly call the **CreateVpcPrefixList** operation within the specified period of time.
   * 
   * @param request - CreateVpcPrefixListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateVpcPrefixListResponse
   */
  async createVpcPrefixListWithOptions(request: $_model.CreateVpcPrefixListRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateVpcPrefixListResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ipVersion)) {
      query["IpVersion"] = request.ipVersion;
    }

    if (!$dara.isNull(request.maxEntries)) {
      query["MaxEntries"] = request.maxEntries;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.prefixListDescription)) {
      query["PrefixListDescription"] = request.prefixListDescription;
    }

    if (!$dara.isNull(request.prefixListEntries)) {
      query["PrefixListEntries"] = request.prefixListEntries;
    }

    if (!$dara.isNull(request.prefixListName)) {
      query["PrefixListName"] = request.prefixListName;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateVpcPrefixList",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateVpcPrefixListResponse>(await this.callApi(params, req, runtime), new $_model.CreateVpcPrefixListResponse({}));
  }

  /**
   * Creates a prefix list.
   * 
   * @remarks
   * You cannot repeatedly call the **CreateVpcPrefixList** operation within the specified period of time.
   * 
   * @param request - CreateVpcPrefixListRequest
   * @returns CreateVpcPrefixListResponse
   */
  async createVpcPrefixList(request: $_model.CreateVpcPrefixListRequest): Promise<$_model.CreateVpcPrefixListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createVpcPrefixListWithOptions(request, runtime);
  }

  /**
   * Adds a shared port to a hosted connection.
   * 
   * @remarks
   * If an Express Connect partner has created a virtual border router (VBR) for a tenant before, the Express Connect partner can push the Express Connect circuit that is associated with the VBR to the tenant account by adding a shared port for the tenant account. The service of the tenant is not interrupted in this process.
   * Preparations:
   * Before the Express Connect partner performs the operation, the Express Connect partner must notify the tenant and request the tenant to enable outbound data transfer billing. For more information, see [Enable outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html).
   * What to do next:
   * 1.  After the Express Connect partner performs the operation, a shared port is added for the tenant account. The tenant must call the [ConfirmPhysicalConnection](https://help.aliyun.com/document_detail/324198.html) operation to accept the shared port.
   * 2.  Then, the Express Connect partner must call the [AttachVbrToVpconn](https://help.aliyun.com/document_detail/324191.html) operation to associate the VBR with the newly added shared port that belongs to the tenant account.
   * 
   * @param request - CreateVpconnFromVbrRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateVpconnFromVbrResponse
   */
  async createVpconnFromVbrWithOptions(request: $_model.CreateVpconnFromVbrRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateVpconnFromVbrResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.orderMode)) {
      query["OrderMode"] = request.orderMode;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.token)) {
      query["Token"] = request.token;
    }

    if (!$dara.isNull(request.vbrId)) {
      query["VbrId"] = request.vbrId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateVpconnFromVbr",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateVpconnFromVbrResponse>(await this.callApi(params, req, runtime), new $_model.CreateVpconnFromVbrResponse({}));
  }

  /**
   * Adds a shared port to a hosted connection.
   * 
   * @remarks
   * If an Express Connect partner has created a virtual border router (VBR) for a tenant before, the Express Connect partner can push the Express Connect circuit that is associated with the VBR to the tenant account by adding a shared port for the tenant account. The service of the tenant is not interrupted in this process.
   * Preparations:
   * Before the Express Connect partner performs the operation, the Express Connect partner must notify the tenant and request the tenant to enable outbound data transfer billing. For more information, see [Enable outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html).
   * What to do next:
   * 1.  After the Express Connect partner performs the operation, a shared port is added for the tenant account. The tenant must call the [ConfirmPhysicalConnection](https://help.aliyun.com/document_detail/324198.html) operation to accept the shared port.
   * 2.  Then, the Express Connect partner must call the [AttachVbrToVpconn](https://help.aliyun.com/document_detail/324191.html) operation to associate the VBR with the newly added shared port that belongs to the tenant account.
   * 
   * @param request - CreateVpconnFromVbrRequest
   * @returns CreateVpconnFromVbrResponse
   */
  async createVpconnFromVbr(request: $_model.CreateVpconnFromVbrRequest): Promise<$_model.CreateVpconnFromVbrResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createVpconnFromVbrWithOptions(request, runtime);
  }

  /**
   * Creates an IPsec-VPN connection. After you create the IPsec-VPN connection, you can associate the IPsec-VPN connection with a transit router.
   * 
   * @remarks
   *   By default, the IPsec-VPN connection created by calling the `CreateVpnAttachment` operation is not bound to any resources. You can call the [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/443993.html) operation to bind the IPsec-VPN connection to a transit router.
   * *   If you want to associate an IPsec-VPN connection with a transit router, you can create a dual-tunnel connection in some regions. For more information, see [Dual-tunnel IPsec-VPN connections](https://help.aliyun.com/document_detail/2853535.html).
   *     *   When you create a IPsec-VPN connection in dual tunnel mode, you can configure the following request parameters in addition to the required parameters: **ClientToken**, **Name**, **NetworkType**, **EffectImmediately**, **AutoConfigRoute**, **Tags** array, **ResourceGroupId**, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
   *     *   When you create a IPsec-VPN connection in single tunnel mode, you can configure the following request parameters in addition to the required parameters: **ClientToken**, **CustomerGatewayId**, **NetworkType**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **Tags** array, and **ResourceGroupId**.
   * ### [](#)Prerequisites
   * Before you create an IPsec-VPN connection, you must create a customer gateway in the region where you want to create the IPsec-VPN connection. For more information, see [CreateCustomerGateway](https://help.aliyun.com/document_detail/120368.html).
   * If you want to add BGP configurations to an IPsec-VPN connection, make sure that an autonomous system number (ASN) is assigned to the customer gateway.
   * 
   * @param request - CreateVpnAttachmentRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateVpnAttachmentResponse
   */
  async createVpnAttachmentWithOptions(request: $_model.CreateVpnAttachmentRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateVpnAttachmentResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.autoConfigRoute)) {
      query["AutoConfigRoute"] = request.autoConfigRoute;
    }

    if (!$dara.isNull(request.bgpConfig)) {
      query["BgpConfig"] = request.bgpConfig;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.customerGatewayId)) {
      query["CustomerGatewayId"] = request.customerGatewayId;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.effectImmediately)) {
      query["EffectImmediately"] = request.effectImmediately;
    }

    if (!$dara.isNull(request.enableDpd)) {
      query["EnableDpd"] = request.enableDpd;
    }

    if (!$dara.isNull(request.enableNatTraversal)) {
      query["EnableNatTraversal"] = request.enableNatTraversal;
    }

    if (!$dara.isNull(request.enableTunnelsBgp)) {
      query["EnableTunnelsBgp"] = request.enableTunnelsBgp;
    }

    if (!$dara.isNull(request.healthCheckConfig)) {
      query["HealthCheckConfig"] = request.healthCheckConfig;
    }

    if (!$dara.isNull(request.ikeConfig)) {
      query["IkeConfig"] = request.ikeConfig;
    }

    if (!$dara.isNull(request.ipsecConfig)) {
      query["IpsecConfig"] = request.ipsecConfig;
    }

    if (!$dara.isNull(request.localSubnet)) {
      query["LocalSubnet"] = request.localSubnet;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.networkType)) {
      query["NetworkType"] = request.networkType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.remoteCaCert)) {
      query["RemoteCaCert"] = request.remoteCaCert;
    }

    if (!$dara.isNull(request.remoteSubnet)) {
      query["RemoteSubnet"] = request.remoteSubnet;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    let body : {[key: string ]: any} = { };
    let bodyFlat : {[key: string ]: any} = { };
    if (!$dara.isNull(request.tunnelOptionsSpecification)) {
      bodyFlat["TunnelOptionsSpecification"] = request.tunnelOptionsSpecification;
    }

    body = {
      ...body,
      ...OpenApiUtil.query(bodyFlat),
    };
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateVpnAttachment",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateVpnAttachmentResponse>(await this.callApi(params, req, runtime), new $_model.CreateVpnAttachmentResponse({}));
  }

  /**
   * Creates an IPsec-VPN connection. After you create the IPsec-VPN connection, you can associate the IPsec-VPN connection with a transit router.
   * 
   * @remarks
   *   By default, the IPsec-VPN connection created by calling the `CreateVpnAttachment` operation is not bound to any resources. You can call the [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/443993.html) operation to bind the IPsec-VPN connection to a transit router.
   * *   If you want to associate an IPsec-VPN connection with a transit router, you can create a dual-tunnel connection in some regions. For more information, see [Dual-tunnel IPsec-VPN connections](https://help.aliyun.com/document_detail/2853535.html).
   *     *   When you create a IPsec-VPN connection in dual tunnel mode, you can configure the following request parameters in addition to the required parameters: **ClientToken**, **Name**, **NetworkType**, **EffectImmediately**, **AutoConfigRoute**, **Tags** array, **ResourceGroupId**, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
   *     *   When you create a IPsec-VPN connection in single tunnel mode, you can configure the following request parameters in addition to the required parameters: **ClientToken**, **CustomerGatewayId**, **NetworkType**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **Tags** array, and **ResourceGroupId**.
   * ### [](#)Prerequisites
   * Before you create an IPsec-VPN connection, you must create a customer gateway in the region where you want to create the IPsec-VPN connection. For more information, see [CreateCustomerGateway](https://help.aliyun.com/document_detail/120368.html).
   * If you want to add BGP configurations to an IPsec-VPN connection, make sure that an autonomous system number (ASN) is assigned to the customer gateway.
   * 
   * @param request - CreateVpnAttachmentRequest
   * @returns CreateVpnAttachmentResponse
   */
  async createVpnAttachment(request: $_model.CreateVpnAttachmentRequest): Promise<$_model.CreateVpnAttachmentResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createVpnAttachmentWithOptions(request, runtime);
  }

  /**
   * Creates an IPsec-VPN connection.
   * 
   * @remarks
   *   If the VPN gateway supports the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
   *     **ClientToken**, **Name**, **EffectImmediately**, **AutoConfigRoute**, **Tags** array, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
   *     For more information about the regions and zones that support the dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
   * *   If the VPN gateway supports only the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
   *     **ClientToken**, **CustomerGatewayId**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **RemoteCaCertificate**, and **Tags** array.
   * *   **CreateVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the IPsec-VPN connection is being created.
   *     *   If the VPN gateway is in the **active** state, the IPsec-VPN connection is created.
   * *   You cannot call **CreateVpnConnection** to create multiple IPsec-VPN connections associated with a VPN gateway at the same time.
   * 
   * @param request - CreateVpnConnectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateVpnConnectionResponse
   */
  async createVpnConnectionWithOptions(request: $_model.CreateVpnConnectionRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateVpnConnectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.autoConfigRoute)) {
      query["AutoConfigRoute"] = request.autoConfigRoute;
    }

    if (!$dara.isNull(request.bgpConfig)) {
      query["BgpConfig"] = request.bgpConfig;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.customerGatewayId)) {
      query["CustomerGatewayId"] = request.customerGatewayId;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.effectImmediately)) {
      query["EffectImmediately"] = request.effectImmediately;
    }

    if (!$dara.isNull(request.enableDpd)) {
      query["EnableDpd"] = request.enableDpd;
    }

    if (!$dara.isNull(request.enableNatTraversal)) {
      query["EnableNatTraversal"] = request.enableNatTraversal;
    }

    if (!$dara.isNull(request.enableTunnelsBgp)) {
      query["EnableTunnelsBgp"] = request.enableTunnelsBgp;
    }

    if (!$dara.isNull(request.healthCheckConfig)) {
      query["HealthCheckConfig"] = request.healthCheckConfig;
    }

    if (!$dara.isNull(request.ikeConfig)) {
      query["IkeConfig"] = request.ikeConfig;
    }

    if (!$dara.isNull(request.ipsecConfig)) {
      query["IpsecConfig"] = request.ipsecConfig;
    }

    if (!$dara.isNull(request.localSubnet)) {
      query["LocalSubnet"] = request.localSubnet;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.remoteCaCertificate)) {
      query["RemoteCaCertificate"] = request.remoteCaCertificate;
    }

    if (!$dara.isNull(request.remoteSubnet)) {
      query["RemoteSubnet"] = request.remoteSubnet;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    let body : {[key: string ]: any} = { };
    let bodyFlat : {[key: string ]: any} = { };
    if (!$dara.isNull(request.tunnelOptionsSpecification)) {
      bodyFlat["TunnelOptionsSpecification"] = request.tunnelOptionsSpecification;
    }

    body = {
      ...body,
      ...OpenApiUtil.query(bodyFlat),
    };
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateVpnConnection",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateVpnConnectionResponse>(await this.callApi(params, req, runtime), new $_model.CreateVpnConnectionResponse({}));
  }

  /**
   * Creates an IPsec-VPN connection.
   * 
   * @remarks
   *   If the VPN gateway supports the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
   *     **ClientToken**, **Name**, **EffectImmediately**, **AutoConfigRoute**, **Tags** array, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
   *     For more information about the regions and zones that support the dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
   * *   If the VPN gateway supports only the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
   *     **ClientToken**, **CustomerGatewayId**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **RemoteCaCertificate**, and **Tags** array.
   * *   **CreateVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the IPsec-VPN connection is being created.
   *     *   If the VPN gateway is in the **active** state, the IPsec-VPN connection is created.
   * *   You cannot call **CreateVpnConnection** to create multiple IPsec-VPN connections associated with a VPN gateway at the same time.
   * 
   * @param request - CreateVpnConnectionRequest
   * @returns CreateVpnConnectionResponse
   */
  async createVpnConnection(request: $_model.CreateVpnConnectionRequest): Promise<$_model.CreateVpnConnectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createVpnConnectionWithOptions(request, runtime);
  }

  /**
   * Creates a VPN gateway.
   * 
   * @remarks
   *   Before you create a VPN gateway, we recommend that you know more about the limits of VPN gateways. For more information, see the [Limits](https://help.aliyun.com/document_detail/65290.html) section in the "Create and manage a VPN gateway" topic.
   * *   VPN gateways in some regions support only IPsec-VPN connections in dual-tunnel mode. If you call `CreateVpnGateway` in these regions, you must specify **VSwitchId** and **DisasterRecoveryVSwitchId** in addition to the required parameters. For more information about the regions and zones that support the IPsec-VPN connections in dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
   * *   **CreateVpnGateway** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the endpoint service is being created in the backend. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
   *     *   If the VPN gateway is in the **provisioning** state, the VPN gateway is being created.
   *     *   If the VPN gateway is in the **active** state, the VPN gateway is created.
   * 
   * @param request - CreateVpnGatewayRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateVpnGatewayResponse
   */
  async createVpnGatewayWithOptions(request: $_model.CreateVpnGatewayRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateVpnGatewayResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.autoPay)) {
      query["AutoPay"] = request.autoPay;
    }

    if (!$dara.isNull(request.bandwidth)) {
      query["Bandwidth"] = request.bandwidth;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.disasterRecoveryVSwitchId)) {
      query["DisasterRecoveryVSwitchId"] = request.disasterRecoveryVSwitchId;
    }

    if (!$dara.isNull(request.enableIpsec)) {
      query["EnableIpsec"] = request.enableIpsec;
    }

    if (!$dara.isNull(request.enableSsl)) {
      query["EnableSsl"] = request.enableSsl;
    }

    if (!$dara.isNull(request.instanceChargeType)) {
      query["InstanceChargeType"] = request.instanceChargeType;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.networkType)) {
      query["NetworkType"] = request.networkType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.period)) {
      query["Period"] = request.period;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.sslConnections)) {
      query["SslConnections"] = request.sslConnections;
    }

    if (!$dara.isNull(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    if (!$dara.isNull(request.vpnType)) {
      query["VpnType"] = request.vpnType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateVpnGateway",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateVpnGatewayResponse>(await this.callApi(params, req, runtime), new $_model.CreateVpnGatewayResponse({}));
  }

  /**
   * Creates a VPN gateway.
   * 
   * @remarks
   *   Before you create a VPN gateway, we recommend that you know more about the limits of VPN gateways. For more information, see the [Limits](https://help.aliyun.com/document_detail/65290.html) section in the "Create and manage a VPN gateway" topic.
   * *   VPN gateways in some regions support only IPsec-VPN connections in dual-tunnel mode. If you call `CreateVpnGateway` in these regions, you must specify **VSwitchId** and **DisasterRecoveryVSwitchId** in addition to the required parameters. For more information about the regions and zones that support the IPsec-VPN connections in dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
   * *   **CreateVpnGateway** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the endpoint service is being created in the backend. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
   *     *   If the VPN gateway is in the **provisioning** state, the VPN gateway is being created.
   *     *   If the VPN gateway is in the **active** state, the VPN gateway is created.
   * 
   * @param request - CreateVpnGatewayRequest
   * @returns CreateVpnGatewayResponse
   */
  async createVpnGateway(request: $_model.CreateVpnGatewayRequest): Promise<$_model.CreateVpnGatewayResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createVpnGatewayWithOptions(request, runtime);
  }

  /**
   * Creates a policy-based route for a VPN gateway.
   * 
   * @remarks
   *   Before you call this operation, make sure that you are familiar with the match rules of and limits on policy-based routes. For more information, see [Manage policy-based routes](https://help.aliyun.com/document_detail/110777.html).
   * *   Before you create a policy-based route, make sure that an IPsec-VPN connection is created. For more information, see [CreateVpnConnection](https://help.aliyun.com/document_detail/120391.html).
   * *   **CreateVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the VPN gateway.
   *     *   If the VPN gateway is in the **updating** state, the policy-based route is being created.
   *     *   If the VPN gateway is in the **active** state, the policy-based route is created.
   * *   You cannot call the **CreateVpnPbrRouteEntry** operation to create multiple policy-based routes for a VPN gateway at a time.
   * 
   * @param request - CreateVpnPbrRouteEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateVpnPbrRouteEntryResponse
   */
  async createVpnPbrRouteEntryWithOptions(request: $_model.CreateVpnPbrRouteEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateVpnPbrRouteEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.nextHop)) {
      query["NextHop"] = request.nextHop;
    }

    if (!$dara.isNull(request.overlayMode)) {
      query["OverlayMode"] = request.overlayMode;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.priority)) {
      query["Priority"] = request.priority;
    }

    if (!$dara.isNull(request.publishVpc)) {
      query["PublishVpc"] = request.publishVpc;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeDest)) {
      query["RouteDest"] = request.routeDest;
    }

    if (!$dara.isNull(request.routeSource)) {
      query["RouteSource"] = request.routeSource;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    if (!$dara.isNull(request.weight)) {
      query["Weight"] = request.weight;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateVpnPbrRouteEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateVpnPbrRouteEntryResponse>(await this.callApi(params, req, runtime), new $_model.CreateVpnPbrRouteEntryResponse({}));
  }

  /**
   * Creates a policy-based route for a VPN gateway.
   * 
   * @remarks
   *   Before you call this operation, make sure that you are familiar with the match rules of and limits on policy-based routes. For more information, see [Manage policy-based routes](https://help.aliyun.com/document_detail/110777.html).
   * *   Before you create a policy-based route, make sure that an IPsec-VPN connection is created. For more information, see [CreateVpnConnection](https://help.aliyun.com/document_detail/120391.html).
   * *   **CreateVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the VPN gateway.
   *     *   If the VPN gateway is in the **updating** state, the policy-based route is being created.
   *     *   If the VPN gateway is in the **active** state, the policy-based route is created.
   * *   You cannot call the **CreateVpnPbrRouteEntry** operation to create multiple policy-based routes for a VPN gateway at a time.
   * 
   * @param request - CreateVpnPbrRouteEntryRequest
   * @returns CreateVpnPbrRouteEntryResponse
   */
  async createVpnPbrRouteEntry(request: $_model.CreateVpnPbrRouteEntryRequest): Promise<$_model.CreateVpnPbrRouteEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createVpnPbrRouteEntryWithOptions(request, runtime);
  }

  /**
   * Creates a destination-based route entry for a VPN gateway.
   * 
   * @remarks
   *   **CreateVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
   *     *   If a VPN gateway is in the **updating** state, the destination-based route entry is being created.
   *     *   If a VPN gateway is in the **active** state, the destination-based route entry has been created.
   * *   You cannot repeatedly call **CreateVpnRouteEntry** to create a destination-based route entry for a VPN gateway within the specified period of time.
   * 
   * @param request - CreateVpnRouteEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateVpnRouteEntryResponse
   */
  async createVpnRouteEntryWithOptions(request: $_model.CreateVpnRouteEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.CreateVpnRouteEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.nextHop)) {
      query["NextHop"] = request.nextHop;
    }

    if (!$dara.isNull(request.overlayMode)) {
      query["OverlayMode"] = request.overlayMode;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.publishVpc)) {
      query["PublishVpc"] = request.publishVpc;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeDest)) {
      query["RouteDest"] = request.routeDest;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    if (!$dara.isNull(request.weight)) {
      query["Weight"] = request.weight;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateVpnRouteEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.CreateVpnRouteEntryResponse>(await this.callApi(params, req, runtime), new $_model.CreateVpnRouteEntryResponse({}));
  }

  /**
   * Creates a destination-based route entry for a VPN gateway.
   * 
   * @remarks
   *   **CreateVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
   *     *   If a VPN gateway is in the **updating** state, the destination-based route entry is being created.
   *     *   If a VPN gateway is in the **active** state, the destination-based route entry has been created.
   * *   You cannot repeatedly call **CreateVpnRouteEntry** to create a destination-based route entry for a VPN gateway within the specified period of time.
   * 
   * @param request - CreateVpnRouteEntryRequest
   * @returns CreateVpnRouteEntryResponse
   */
  async createVpnRouteEntry(request: $_model.CreateVpnRouteEntryRequest): Promise<$_model.CreateVpnRouteEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createVpnRouteEntryWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - DeactivateRouterInterfaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeactivateRouterInterfaceResponse
   */
  async deactivateRouterInterfaceWithOptions(request: $_model.DeactivateRouterInterfaceRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeactivateRouterInterfaceResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routerInterfaceId)) {
      query["RouterInterfaceId"] = request.routerInterfaceId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeactivateRouterInterface",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeactivateRouterInterfaceResponse>(await this.callApi(params, req, runtime), new $_model.DeactivateRouterInterfaceResponse({}));
  }

  /**
   * 
   * 
   * @param request - DeactivateRouterInterfaceRequest
   * @returns DeactivateRouterInterfaceResponse
   */
  async deactivateRouterInterface(request: $_model.DeactivateRouterInterfaceRequest): Promise<$_model.DeactivateRouterInterfaceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deactivateRouterInterfaceWithOptions(request, runtime);
  }

  /**
   * Disables a flow log. After a flow log is disabled, the system no longer captures the traffic information about a resource.
   * 
   * @remarks
   *   The **DeactiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
   *     *   If the flow log is in the **Deactivating** state, the flow log is being disabled.
   *     *   If the flow log is in the **Inactive** state, the flow log is disabled.
   * *   You cannot repeatedly call the **DeactiveFlowLog** operation to disable a flow log within the specified period of time.
   * 
   * @param request - DeactiveFlowLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeactiveFlowLogResponse
   */
  async deactiveFlowLogWithOptions(request: $_model.DeactiveFlowLogRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeactiveFlowLogResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.flowLogId)) {
      query["FlowLogId"] = request.flowLogId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeactiveFlowLog",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeactiveFlowLogResponse>(await this.callApi(params, req, runtime), new $_model.DeactiveFlowLogResponse({}));
  }

  /**
   * Disables a flow log. After a flow log is disabled, the system no longer captures the traffic information about a resource.
   * 
   * @remarks
   *   The **DeactiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
   *     *   If the flow log is in the **Deactivating** state, the flow log is being disabled.
   *     *   If the flow log is in the **Inactive** state, the flow log is disabled.
   * *   You cannot repeatedly call the **DeactiveFlowLog** operation to disable a flow log within the specified period of time.
   * 
   * @param request - DeactiveFlowLogRequest
   * @returns DeactiveFlowLogResponse
   */
  async deactiveFlowLog(request: $_model.DeactiveFlowLogRequest): Promise<$_model.DeactiveFlowLogResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deactiveFlowLogWithOptions(request, runtime);
  }

  /**
   * Deletes a Border Gateway Protocol (BGP) group.
   * 
   * @param request - DeleteBgpGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteBgpGroupResponse
   */
  async deleteBgpGroupWithOptions(request: $_model.DeleteBgpGroupRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteBgpGroupResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bgpGroupId)) {
      query["BgpGroupId"] = request.bgpGroupId;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteBgpGroup",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteBgpGroupResponse>(await this.callApi(params, req, runtime), new $_model.DeleteBgpGroupResponse({}));
  }

  /**
   * Deletes a Border Gateway Protocol (BGP) group.
   * 
   * @param request - DeleteBgpGroupRequest
   * @returns DeleteBgpGroupResponse
   */
  async deleteBgpGroup(request: $_model.DeleteBgpGroupRequest): Promise<$_model.DeleteBgpGroupResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteBgpGroupWithOptions(request, runtime);
  }

  /**
   * Deletes an advertised Border Gateway Protocol (BGP) network.
   * 
   * @param request - DeleteBgpNetworkRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteBgpNetworkResponse
   */
  async deleteBgpNetworkWithOptions(request: $_model.DeleteBgpNetworkRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteBgpNetworkResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dstCidrBlock)) {
      query["DstCidrBlock"] = request.dstCidrBlock;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routerId)) {
      query["RouterId"] = request.routerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteBgpNetwork",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteBgpNetworkResponse>(await this.callApi(params, req, runtime), new $_model.DeleteBgpNetworkResponse({}));
  }

  /**
   * Deletes an advertised Border Gateway Protocol (BGP) network.
   * 
   * @param request - DeleteBgpNetworkRequest
   * @returns DeleteBgpNetworkResponse
   */
  async deleteBgpNetwork(request: $_model.DeleteBgpNetworkRequest): Promise<$_model.DeleteBgpNetworkResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteBgpNetworkWithOptions(request, runtime);
  }

  /**
   * Deletes a Border Gateway Protocol (BGP) peer.
   * 
   * @param request - DeleteBgpPeerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteBgpPeerResponse
   */
  async deleteBgpPeerWithOptions(request: $_model.DeleteBgpPeerRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteBgpPeerResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bgpPeerId)) {
      query["BgpPeerId"] = request.bgpPeerId;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteBgpPeer",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteBgpPeerResponse>(await this.callApi(params, req, runtime), new $_model.DeleteBgpPeerResponse({}));
  }

  /**
   * Deletes a Border Gateway Protocol (BGP) peer.
   * 
   * @param request - DeleteBgpPeerRequest
   * @returns DeleteBgpPeerResponse
   */
  async deleteBgpPeer(request: $_model.DeleteBgpPeerRequest): Promise<$_model.DeleteBgpPeerResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteBgpPeerWithOptions(request, runtime);
  }

  /**
   * Deletes an Internet Shared Bandwidth instance.
   * 
   * @remarks
   * You cannot repeatedly call the **DeleteCommonBandwidthPackage** operation to delete an Internet Shared Bandwidth instance within the specified period of time.
   * 
   * @param request - DeleteCommonBandwidthPackageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteCommonBandwidthPackageResponse
   */
  async deleteCommonBandwidthPackageWithOptions(request: $_model.DeleteCommonBandwidthPackageRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteCommonBandwidthPackageResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidthPackageId)) {
      query["BandwidthPackageId"] = request.bandwidthPackageId;
    }

    if (!$dara.isNull(request.force)) {
      query["Force"] = request.force;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteCommonBandwidthPackage",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteCommonBandwidthPackageResponse>(await this.callApi(params, req, runtime), new $_model.DeleteCommonBandwidthPackageResponse({}));
  }

  /**
   * Deletes an Internet Shared Bandwidth instance.
   * 
   * @remarks
   * You cannot repeatedly call the **DeleteCommonBandwidthPackage** operation to delete an Internet Shared Bandwidth instance within the specified period of time.
   * 
   * @param request - DeleteCommonBandwidthPackageRequest
   * @returns DeleteCommonBandwidthPackageResponse
   */
  async deleteCommonBandwidthPackage(request: $_model.DeleteCommonBandwidthPackageRequest): Promise<$_model.DeleteCommonBandwidthPackageResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteCommonBandwidthPackageWithOptions(request, runtime);
  }

  /**
   * Deletes a customer gateway.
   * 
   * @remarks
   * Before you delete a customer gateway, make sure that no IPsec-VPN connection is associated with the customer gateway. For more information about how to delete an IPsec-VPN connection, see [DeleteVpnAttachment](https://help.aliyun.com/document_detail/2526938.html) or [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
   * 
   * @param request - DeleteCustomerGatewayRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteCustomerGatewayResponse
   */
  async deleteCustomerGatewayWithOptions(request: $_model.DeleteCustomerGatewayRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteCustomerGatewayResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.customerGatewayId)) {
      query["CustomerGatewayId"] = request.customerGatewayId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteCustomerGateway",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteCustomerGatewayResponse>(await this.callApi(params, req, runtime), new $_model.DeleteCustomerGatewayResponse({}));
  }

  /**
   * Deletes a customer gateway.
   * 
   * @remarks
   * Before you delete a customer gateway, make sure that no IPsec-VPN connection is associated with the customer gateway. For more information about how to delete an IPsec-VPN connection, see [DeleteVpnAttachment](https://help.aliyun.com/document_detail/2526938.html) or [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
   * 
   * @param request - DeleteCustomerGatewayRequest
   * @returns DeleteCustomerGatewayResponse
   */
  async deleteCustomerGateway(request: $_model.DeleteCustomerGatewayRequest): Promise<$_model.DeleteCustomerGatewayResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteCustomerGatewayWithOptions(request, runtime);
  }

  /**
   * Deletes a DHCP options set.
   * 
   * @remarks
   * ## [](#)Description
   * *   **DeleteDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/189208.html) operation to query the status of the task.
   *     *   If the DHCP options set is in the **Deleting** state, the DHCP options set is being deleted.
   *     *   If you cannot query the DHCP options set, the DHCP options set is deleted.
   * *   You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a DHCP options set within the specified period of time.
   * 
   * @param request - DeleteDhcpOptionsSetRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDhcpOptionsSetResponse
   */
  async deleteDhcpOptionsSetWithOptions(request: $_model.DeleteDhcpOptionsSetRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteDhcpOptionsSetResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dhcpOptionsSetId)) {
      query["DhcpOptionsSetId"] = request.dhcpOptionsSetId;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteDhcpOptionsSet",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteDhcpOptionsSetResponse>(await this.callApi(params, req, runtime), new $_model.DeleteDhcpOptionsSetResponse({}));
  }

  /**
   * Deletes a DHCP options set.
   * 
   * @remarks
   * ## [](#)Description
   * *   **DeleteDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/189208.html) operation to query the status of the task.
   *     *   If the DHCP options set is in the **Deleting** state, the DHCP options set is being deleted.
   *     *   If you cannot query the DHCP options set, the DHCP options set is deleted.
   * *   You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a DHCP options set within the specified period of time.
   * 
   * @param request - DeleteDhcpOptionsSetRequest
   * @returns DeleteDhcpOptionsSetResponse
   */
  async deleteDhcpOptionsSet(request: $_model.DeleteDhcpOptionsSetRequest): Promise<$_model.DeleteDhcpOptionsSetResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteDhcpOptionsSetWithOptions(request, runtime);
  }

  /**
   * Deletes a quality of service (QoS) policy.
   * 
   * @param request - DeleteExpressConnectTrafficQosRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteExpressConnectTrafficQosResponse
   */
  async deleteExpressConnectTrafficQosWithOptions(request: $_model.DeleteExpressConnectTrafficQosRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteExpressConnectTrafficQosResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.qosId)) {
      query["QosId"] = request.qosId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteExpressConnectTrafficQos",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteExpressConnectTrafficQosResponse>(await this.callApi(params, req, runtime), new $_model.DeleteExpressConnectTrafficQosResponse({}));
  }

  /**
   * Deletes a quality of service (QoS) policy.
   * 
   * @param request - DeleteExpressConnectTrafficQosRequest
   * @returns DeleteExpressConnectTrafficQosResponse
   */
  async deleteExpressConnectTrafficQos(request: $_model.DeleteExpressConnectTrafficQosRequest): Promise<$_model.DeleteExpressConnectTrafficQosResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteExpressConnectTrafficQosWithOptions(request, runtime);
  }

  /**
   * Deletes a quality of service (QoS) queue.
   * 
   * @param request - DeleteExpressConnectTrafficQosQueueRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteExpressConnectTrafficQosQueueResponse
   */
  async deleteExpressConnectTrafficQosQueueWithOptions(request: $_model.DeleteExpressConnectTrafficQosQueueRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteExpressConnectTrafficQosQueueResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.qosId)) {
      query["QosId"] = request.qosId;
    }

    if (!$dara.isNull(request.queueId)) {
      query["QueueId"] = request.queueId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteExpressConnectTrafficQosQueue",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteExpressConnectTrafficQosQueueResponse>(await this.callApi(params, req, runtime), new $_model.DeleteExpressConnectTrafficQosQueueResponse({}));
  }

  /**
   * Deletes a quality of service (QoS) queue.
   * 
   * @param request - DeleteExpressConnectTrafficQosQueueRequest
   * @returns DeleteExpressConnectTrafficQosQueueResponse
   */
  async deleteExpressConnectTrafficQosQueue(request: $_model.DeleteExpressConnectTrafficQosQueueRequest): Promise<$_model.DeleteExpressConnectTrafficQosQueueResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteExpressConnectTrafficQosQueueWithOptions(request, runtime);
  }

  /**
   * Deletes a quality of service (QoS) rule.
   * 
   * @param request - DeleteExpressConnectTrafficQosRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteExpressConnectTrafficQosRuleResponse
   */
  async deleteExpressConnectTrafficQosRuleWithOptions(request: $_model.DeleteExpressConnectTrafficQosRuleRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteExpressConnectTrafficQosRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.qosId)) {
      query["QosId"] = request.qosId;
    }

    if (!$dara.isNull(request.queueId)) {
      query["QueueId"] = request.queueId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteExpressConnectTrafficQosRule",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteExpressConnectTrafficQosRuleResponse>(await this.callApi(params, req, runtime), new $_model.DeleteExpressConnectTrafficQosRuleResponse({}));
  }

  /**
   * Deletes a quality of service (QoS) rule.
   * 
   * @param request - DeleteExpressConnectTrafficQosRuleRequest
   * @returns DeleteExpressConnectTrafficQosRuleResponse
   */
  async deleteExpressConnectTrafficQosRule(request: $_model.DeleteExpressConnectTrafficQosRuleRequest): Promise<$_model.DeleteExpressConnectTrafficQosRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteExpressConnectTrafficQosRuleWithOptions(request, runtime);
  }

  /**
   * Deletes a failover test.
   * 
   * @remarks
   * You can delete only failover tests that are in the **Pending** or **Complete** state.
   * 
   * @param request - DeleteFailoverTestJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteFailoverTestJobResponse
   */
  async deleteFailoverTestJobWithOptions(request: $_model.DeleteFailoverTestJobRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteFailoverTestJobResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteFailoverTestJob",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteFailoverTestJobResponse>(await this.callApi(params, req, runtime), new $_model.DeleteFailoverTestJobResponse({}));
  }

  /**
   * Deletes a failover test.
   * 
   * @remarks
   * You can delete only failover tests that are in the **Pending** or **Complete** state.
   * 
   * @param request - DeleteFailoverTestJobRequest
   * @returns DeleteFailoverTestJobResponse
   */
  async deleteFailoverTestJob(request: $_model.DeleteFailoverTestJobRequest): Promise<$_model.DeleteFailoverTestJobResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteFailoverTestJobWithOptions(request, runtime);
  }

  /**
   * Deletes a flow log.
   * 
   * @remarks
   *   The **DeleteFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
   *     *   If the flow log is in the **Deleting** state, the flow log is being deleted.
   *     *   If you cannot query the flow log, the flow log is deleted.
   * *   You cannot repeatedly call the **DeleteFlowLog** operation to delete a flow log within the specified period of time.
   * 
   * @param request - DeleteFlowLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteFlowLogResponse
   */
  async deleteFlowLogWithOptions(request: $_model.DeleteFlowLogRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteFlowLogResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.flowLogId)) {
      query["FlowLogId"] = request.flowLogId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteFlowLog",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteFlowLogResponse>(await this.callApi(params, req, runtime), new $_model.DeleteFlowLogResponse({}));
  }

  /**
   * Deletes a flow log.
   * 
   * @remarks
   *   The **DeleteFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
   *     *   If the flow log is in the **Deleting** state, the flow log is being deleted.
   *     *   If you cannot query the flow log, the flow log is deleted.
   * *   You cannot repeatedly call the **DeleteFlowLog** operation to delete a flow log within the specified period of time.
   * 
   * @param request - DeleteFlowLogRequest
   * @returns DeleteFlowLogResponse
   */
  async deleteFlowLog(request: $_model.DeleteFlowLogRequest): Promise<$_model.DeleteFlowLogResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteFlowLogWithOptions(request, runtime);
  }

  /**
   * Deletes a DNAT entry.
   * 
   * @remarks
   * ## [](#)Description
   * *   **DeleteForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
   *     *   If the DNAT entry is in the **Deleting** state, the system is deleting the DNAT entry. In this case, you can only query the status of the DNAT entry, but cannot perform other operations.
   *     *   If the DNAT entry cannot be found, it is deleted.
   * >  If a DNAT table has DNAT entries in the **Pending** state, you cannot delete the DNAT entries.
   * *   You cannot repeatedly call the **DeleteForwardEntry** operation to delete a DNAT entry within the specified period of time.
   * 
   * @param request - DeleteForwardEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteForwardEntryResponse
   */
  async deleteForwardEntryWithOptions(request: $_model.DeleteForwardEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteForwardEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.forwardEntryId)) {
      query["ForwardEntryId"] = request.forwardEntryId;
    }

    if (!$dara.isNull(request.forwardTableId)) {
      query["ForwardTableId"] = request.forwardTableId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteForwardEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteForwardEntryResponse>(await this.callApi(params, req, runtime), new $_model.DeleteForwardEntryResponse({}));
  }

  /**
   * Deletes a DNAT entry.
   * 
   * @remarks
   * ## [](#)Description
   * *   **DeleteForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
   *     *   If the DNAT entry is in the **Deleting** state, the system is deleting the DNAT entry. In this case, you can only query the status of the DNAT entry, but cannot perform other operations.
   *     *   If the DNAT entry cannot be found, it is deleted.
   * >  If a DNAT table has DNAT entries in the **Pending** state, you cannot delete the DNAT entries.
   * *   You cannot repeatedly call the **DeleteForwardEntry** operation to delete a DNAT entry within the specified period of time.
   * 
   * @param request - DeleteForwardEntryRequest
   * @returns DeleteForwardEntryResponse
   */
  async deleteForwardEntry(request: $_model.DeleteForwardEntryRequest): Promise<$_model.DeleteForwardEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteForwardEntryWithOptions(request, runtime);
  }

  /**
   * Deletes a FULLNAT entry.
   * 
   * @remarks
   * ## [](#)Description
   * **DeleteFullNatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
   * *   If the FULLNAT entry is in the **Deleting** state, the system is deleting the FULLNAT entry. In this case, you can query the status of the FULLNAT entry, but cannot perform other operations.
   * *   If the FULLNAT entry cannot be found, the FULLNAT entry is deleted.
   * You cannot repeatedly call the **DeleteFullNatEntry** operation to delete a FULLNAT entry within the specified period of time.
   * 
   * @param request - DeleteFullNatEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteFullNatEntryResponse
   */
  async deleteFullNatEntryWithOptions(request: $_model.DeleteFullNatEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteFullNatEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.fullNatEntryId)) {
      query["FullNatEntryId"] = request.fullNatEntryId;
    }

    if (!$dara.isNull(request.fullNatTableId)) {
      query["FullNatTableId"] = request.fullNatTableId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteFullNatEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteFullNatEntryResponse>(await this.callApi(params, req, runtime), new $_model.DeleteFullNatEntryResponse({}));
  }

  /**
   * Deletes a FULLNAT entry.
   * 
   * @remarks
   * ## [](#)Description
   * **DeleteFullNatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
   * *   If the FULLNAT entry is in the **Deleting** state, the system is deleting the FULLNAT entry. In this case, you can query the status of the FULLNAT entry, but cannot perform other operations.
   * *   If the FULLNAT entry cannot be found, the FULLNAT entry is deleted.
   * You cannot repeatedly call the **DeleteFullNatEntry** operation to delete a FULLNAT entry within the specified period of time.
   * 
   * @param request - DeleteFullNatEntryRequest
   * @returns DeleteFullNatEntryResponse
   */
  async deleteFullNatEntry(request: $_model.DeleteFullNatEntryRequest): Promise<$_model.DeleteFullNatEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteFullNatEntryWithOptions(request, runtime);
  }

  /**
   * Deletes a Global Accelerator (GA) instance.
   * 
   * @remarks
   * When you call this operation, take note of the following items:
   * *   You can delete only pay-as-you-go instances.
   * *   Before you can delete a dedicated instance, disassociate the backend server from the instance first.
   * *   Before you can delete a shared instance, disassociate the elastic IP address (EIP) from the instance first.
   * 
   * @param request - DeleteGlobalAccelerationInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteGlobalAccelerationInstanceResponse
   */
  async deleteGlobalAccelerationInstanceWithOptions(request: $_model.DeleteGlobalAccelerationInstanceRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteGlobalAccelerationInstanceResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.globalAccelerationInstanceId)) {
      query["GlobalAccelerationInstanceId"] = request.globalAccelerationInstanceId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteGlobalAccelerationInstance",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteGlobalAccelerationInstanceResponse>(await this.callApi(params, req, runtime), new $_model.DeleteGlobalAccelerationInstanceResponse({}));
  }

  /**
   * Deletes a Global Accelerator (GA) instance.
   * 
   * @remarks
   * When you call this operation, take note of the following items:
   * *   You can delete only pay-as-you-go instances.
   * *   Before you can delete a dedicated instance, disassociate the backend server from the instance first.
   * *   Before you can delete a shared instance, disassociate the elastic IP address (EIP) from the instance first.
   * 
   * @param request - DeleteGlobalAccelerationInstanceRequest
   * @returns DeleteGlobalAccelerationInstanceResponse
   */
  async deleteGlobalAccelerationInstance(request: $_model.DeleteGlobalAccelerationInstanceRequest): Promise<$_model.DeleteGlobalAccelerationInstanceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteGlobalAccelerationInstanceWithOptions(request, runtime);
  }

  /**
   * Deletes a high-availability virtual IP address (HaVip).
   * 
   * @remarks
   * When you call this operation, take note of the following rules:
   * *   The HaVip must be in the available state before it can be deleted.
   * *   Make sure that no routes are destined for the HaVip.
   * *   Make sure that no elastic IP addresses (EIPs) are associated with the HaVip.
   * *   **DeleteHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID while deleting the HaVip in the background. Call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
   *     *   The **Deleting** state indicates the HaVip is being deleted.
   *     *   If no HaVip is found, the HaVip is deleted.
   * *   You cannot repeatedly call the **DeleteHaVip** operation to delete the same HaVip.
   * 
   * @param request - DeleteHaVipRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteHaVipResponse
   */
  async deleteHaVipWithOptions(request: $_model.DeleteHaVipRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteHaVipResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.haVipId)) {
      query["HaVipId"] = request.haVipId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteHaVip",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteHaVipResponse>(await this.callApi(params, req, runtime), new $_model.DeleteHaVipResponse({}));
  }

  /**
   * Deletes a high-availability virtual IP address (HaVip).
   * 
   * @remarks
   * When you call this operation, take note of the following rules:
   * *   The HaVip must be in the available state before it can be deleted.
   * *   Make sure that no routes are destined for the HaVip.
   * *   Make sure that no elastic IP addresses (EIPs) are associated with the HaVip.
   * *   **DeleteHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID while deleting the HaVip in the background. Call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
   *     *   The **Deleting** state indicates the HaVip is being deleted.
   *     *   If no HaVip is found, the HaVip is deleted.
   * *   You cannot repeatedly call the **DeleteHaVip** operation to delete the same HaVip.
   * 
   * @param request - DeleteHaVipRequest
   * @returns DeleteHaVipResponse
   */
  async deleteHaVip(request: $_model.DeleteHaVipRequest): Promise<$_model.DeleteHaVipResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteHaVipWithOptions(request, runtime);
  }

  /**
   * Deletes an IPv6 Translation Service instance.
   * 
   * @param request - DeleteIPv6TranslatorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteIPv6TranslatorResponse
   */
  async deleteIPv6TranslatorWithOptions(request: $_model.DeleteIPv6TranslatorRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteIPv6TranslatorResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ipv6TranslatorId)) {
      query["Ipv6TranslatorId"] = request.ipv6TranslatorId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteIPv6Translator",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteIPv6TranslatorResponse>(await this.callApi(params, req, runtime), new $_model.DeleteIPv6TranslatorResponse({}));
  }

  /**
   * Deletes an IPv6 Translation Service instance.
   * 
   * @param request - DeleteIPv6TranslatorRequest
   * @returns DeleteIPv6TranslatorResponse
   */
  async deleteIPv6Translator(request: $_model.DeleteIPv6TranslatorRequest): Promise<$_model.DeleteIPv6TranslatorResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteIPv6TranslatorWithOptions(request, runtime);
  }

  /**
   * Deletes an access control list (ACL). You can delete an ACL only when the ACL is not associated with IPv6 translation mappings.
   * 
   * @deprecated OpenAPI DeleteIPv6TranslatorAclList is deprecated
   * 
   * @param request - DeleteIPv6TranslatorAclListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteIPv6TranslatorAclListResponse
   */
  async deleteIPv6TranslatorAclListWithOptions(request: $_model.DeleteIPv6TranslatorAclListRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteIPv6TranslatorAclListResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.aclId)) {
      query["AclId"] = request.aclId;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteIPv6TranslatorAclList",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteIPv6TranslatorAclListResponse>(await this.callApi(params, req, runtime), new $_model.DeleteIPv6TranslatorAclListResponse({}));
  }

  /**
   * Deletes an access control list (ACL). You can delete an ACL only when the ACL is not associated with IPv6 translation mappings.
   * 
   * @deprecated OpenAPI DeleteIPv6TranslatorAclList is deprecated
   * 
   * @param request - DeleteIPv6TranslatorAclListRequest
   * @returns DeleteIPv6TranslatorAclListResponse
   */
  // Deprecated
  async deleteIPv6TranslatorAclList(request: $_model.DeleteIPv6TranslatorAclListRequest): Promise<$_model.DeleteIPv6TranslatorAclListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteIPv6TranslatorAclListWithOptions(request, runtime);
  }

  /**
   * Deletes an IPv6 mapping entry.
   * 
   * @deprecated OpenAPI DeleteIPv6TranslatorEntry is deprecated
   * 
   * @param request - DeleteIPv6TranslatorEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteIPv6TranslatorEntryResponse
   */
  async deleteIPv6TranslatorEntryWithOptions(request: $_model.DeleteIPv6TranslatorEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteIPv6TranslatorEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ipv6TranslatorEntryId)) {
      query["Ipv6TranslatorEntryId"] = request.ipv6TranslatorEntryId;
    }

    if (!$dara.isNull(request.ipv6TranslatorId)) {
      query["Ipv6TranslatorId"] = request.ipv6TranslatorId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteIPv6TranslatorEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteIPv6TranslatorEntryResponse>(await this.callApi(params, req, runtime), new $_model.DeleteIPv6TranslatorEntryResponse({}));
  }

  /**
   * Deletes an IPv6 mapping entry.
   * 
   * @deprecated OpenAPI DeleteIPv6TranslatorEntry is deprecated
   * 
   * @param request - DeleteIPv6TranslatorEntryRequest
   * @returns DeleteIPv6TranslatorEntryResponse
   */
  // Deprecated
  async deleteIPv6TranslatorEntry(request: $_model.DeleteIPv6TranslatorEntryRequest): Promise<$_model.DeleteIPv6TranslatorEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteIPv6TranslatorEntryWithOptions(request, runtime);
  }

  /**
   * Deletes an IPsec server.
   * 
   * @remarks
   *   **DeleteIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the IPsec server is being deleted.
   *     *   If the VPN gateway is in the **active** state, the IPsec server is deleted.
   * *   You cannot call **DeleteIpsecServer** within the specified period of time.
   * 
   * @param request - DeleteIpsecServerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteIpsecServerResponse
   */
  async deleteIpsecServerWithOptions(request: $_model.DeleteIpsecServerRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteIpsecServerResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ipsecServerId)) {
      query["IpsecServerId"] = request.ipsecServerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteIpsecServer",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteIpsecServerResponse>(await this.callApi(params, req, runtime), new $_model.DeleteIpsecServerResponse({}));
  }

  /**
   * Deletes an IPsec server.
   * 
   * @remarks
   *   **DeleteIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the IPsec server is being deleted.
   *     *   If the VPN gateway is in the **active** state, the IPsec server is deleted.
   * *   You cannot call **DeleteIpsecServer** within the specified period of time.
   * 
   * @param request - DeleteIpsecServerRequest
   * @returns DeleteIpsecServerResponse
   */
  async deleteIpsecServer(request: $_model.DeleteIpsecServerRequest): Promise<$_model.DeleteIpsecServerResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteIpsecServerWithOptions(request, runtime);
  }

  /**
   * Deletes an IPv4 gateway.
   * 
   * @remarks
   * ### [](#)Description
   * *   Before you delete an IPv4 gateway, make sure that no route tables are associated with the IPv4 gateway.
   * *   **DeleteIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of the task.
   *     *   If the IPv4 gateway is in the **Deleting** state, the IPv4 gateway is being deleted.
   *     *   If the IPv4 gateway cannot be queried, the IPv4 gateway is deleted.
   * *   After you call the **DeleteIpv4Gateway** operation to delete an IPv4 gateway, you cannot call the operation again to delete the IPv4 gateway until the deletion task is complete.
   * 
   * @param request - DeleteIpv4GatewayRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteIpv4GatewayResponse
   */
  async deleteIpv4GatewayWithOptions(request: $_model.DeleteIpv4GatewayRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteIpv4GatewayResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.internetMode)) {
      query["InternetMode"] = request.internetMode;
    }

    if (!$dara.isNull(request.ipv4GatewayId)) {
      query["Ipv4GatewayId"] = request.ipv4GatewayId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteIpv4Gateway",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteIpv4GatewayResponse>(await this.callApi(params, req, runtime), new $_model.DeleteIpv4GatewayResponse({}));
  }

  /**
   * Deletes an IPv4 gateway.
   * 
   * @remarks
   * ### [](#)Description
   * *   Before you delete an IPv4 gateway, make sure that no route tables are associated with the IPv4 gateway.
   * *   **DeleteIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of the task.
   *     *   If the IPv4 gateway is in the **Deleting** state, the IPv4 gateway is being deleted.
   *     *   If the IPv4 gateway cannot be queried, the IPv4 gateway is deleted.
   * *   After you call the **DeleteIpv4Gateway** operation to delete an IPv4 gateway, you cannot call the operation again to delete the IPv4 gateway until the deletion task is complete.
   * 
   * @param request - DeleteIpv4GatewayRequest
   * @returns DeleteIpv4GatewayResponse
   */
  async deleteIpv4Gateway(request: $_model.DeleteIpv4GatewayRequest): Promise<$_model.DeleteIpv4GatewayResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteIpv4GatewayWithOptions(request, runtime);
  }

  /**
   * Deletes an egress-only rule.
   * 
   * @remarks
   *   **DeleteIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
   *     *   If the egress-only rule is in the **Deleting** state, the egress-only rule is being deleted.
   *     *   If you cannot query the egress-only rule, the egress-only rule is deleted.
   * *   You cannot call the **DeleteIpv6EgressOnlyRule** within the specified period of time.
   * 
   * @param request - DeleteIpv6EgressOnlyRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteIpv6EgressOnlyRuleResponse
   */
  async deleteIpv6EgressOnlyRuleWithOptions(request: $_model.DeleteIpv6EgressOnlyRuleRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteIpv6EgressOnlyRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ipv6EgressOnlyRuleId)) {
      query["Ipv6EgressOnlyRuleId"] = request.ipv6EgressOnlyRuleId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteIpv6EgressOnlyRule",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteIpv6EgressOnlyRuleResponse>(await this.callApi(params, req, runtime), new $_model.DeleteIpv6EgressOnlyRuleResponse({}));
  }

  /**
   * Deletes an egress-only rule.
   * 
   * @remarks
   *   **DeleteIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
   *     *   If the egress-only rule is in the **Deleting** state, the egress-only rule is being deleted.
   *     *   If you cannot query the egress-only rule, the egress-only rule is deleted.
   * *   You cannot call the **DeleteIpv6EgressOnlyRule** within the specified period of time.
   * 
   * @param request - DeleteIpv6EgressOnlyRuleRequest
   * @returns DeleteIpv6EgressOnlyRuleResponse
   */
  async deleteIpv6EgressOnlyRule(request: $_model.DeleteIpv6EgressOnlyRuleRequest): Promise<$_model.DeleteIpv6EgressOnlyRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteIpv6EgressOnlyRuleWithOptions(request, runtime);
  }

  /**
   * Deletes an IPv6 gateway.
   * 
   * @remarks
   * Before you delete an IPv6 gateway, you must delete the egress-only rules of the IPv6 gateway. For more information, see [DeleteIpv6EgressOnlyRule](https://help.aliyun.com/document_detail/102201.html).
   * *   **DeleteIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task:
   *     *   If the IPv6 gateway is in the **Deleting** state, the IPv6 gateway is being deleted.
   *     *   If you cannot query the IPv6 gateway, the IPv6 gateway is deleted.
   * *   You cannot repeatedly call the **DeleteIpv6Gateway** operation to delete an IPv6 gateway within the specified period of time.
   * 
   * @param request - DeleteIpv6GatewayRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteIpv6GatewayResponse
   */
  async deleteIpv6GatewayWithOptions(request: $_model.DeleteIpv6GatewayRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteIpv6GatewayResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ipv6GatewayId)) {
      query["Ipv6GatewayId"] = request.ipv6GatewayId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteIpv6Gateway",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteIpv6GatewayResponse>(await this.callApi(params, req, runtime), new $_model.DeleteIpv6GatewayResponse({}));
  }

  /**
   * Deletes an IPv6 gateway.
   * 
   * @remarks
   * Before you delete an IPv6 gateway, you must delete the egress-only rules of the IPv6 gateway. For more information, see [DeleteIpv6EgressOnlyRule](https://help.aliyun.com/document_detail/102201.html).
   * *   **DeleteIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task:
   *     *   If the IPv6 gateway is in the **Deleting** state, the IPv6 gateway is being deleted.
   *     *   If you cannot query the IPv6 gateway, the IPv6 gateway is deleted.
   * *   You cannot repeatedly call the **DeleteIpv6Gateway** operation to delete an IPv6 gateway within the specified period of time.
   * 
   * @param request - DeleteIpv6GatewayRequest
   * @returns DeleteIpv6GatewayResponse
   */
  async deleteIpv6Gateway(request: $_model.DeleteIpv6GatewayRequest): Promise<$_model.DeleteIpv6GatewayResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteIpv6GatewayWithOptions(request, runtime);
  }

  /**
   * Deletes Internet bandwidth.
   * 
   * @remarks
   * You cannot call the **DeleteIpv6InternetBandwidth** operation within the specified period of time.
   * 
   * @param request - DeleteIpv6InternetBandwidthRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteIpv6InternetBandwidthResponse
   */
  async deleteIpv6InternetBandwidthWithOptions(request: $_model.DeleteIpv6InternetBandwidthRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteIpv6InternetBandwidthResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ipv6AddressId)) {
      query["Ipv6AddressId"] = request.ipv6AddressId;
    }

    if (!$dara.isNull(request.ipv6InternetBandwidthId)) {
      query["Ipv6InternetBandwidthId"] = request.ipv6InternetBandwidthId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteIpv6InternetBandwidth",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteIpv6InternetBandwidthResponse>(await this.callApi(params, req, runtime), new $_model.DeleteIpv6InternetBandwidthResponse({}));
  }

  /**
   * Deletes Internet bandwidth.
   * 
   * @remarks
   * You cannot call the **DeleteIpv6InternetBandwidth** operation within the specified period of time.
   * 
   * @param request - DeleteIpv6InternetBandwidthRequest
   * @returns DeleteIpv6InternetBandwidthResponse
   */
  async deleteIpv6InternetBandwidth(request: $_model.DeleteIpv6InternetBandwidthRequest): Promise<$_model.DeleteIpv6InternetBandwidthResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteIpv6InternetBandwidthWithOptions(request, runtime);
  }

  /**
   * Deletes a specified Internet NAT gateway.
   * 
   * @remarks
   * ## [](#)Description
   * *   **DeleteNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) to query the status of the task.
   *     *   If a NAT gateway is in the **Deleting** state, the NAT gateway is being deleted. In this case, you can query the NAT gateway but you cannot perform other operations.
   *     *   If the NAT gateway cannot be found, the NAT gateway is deleted.
   *         After you delete a NAT gateway, you cannot restore the NAT gateway. Proceed with caution.
   * *   You cannot repeatedly call the **DeleteNatGateway** operation to delete a NAT gateway within the specified period of time.
   * 
   * @param request - DeleteNatGatewayRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteNatGatewayResponse
   */
  async deleteNatGatewayWithOptions(request: $_model.DeleteNatGatewayRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteNatGatewayResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.force)) {
      query["Force"] = request.force;
    }

    if (!$dara.isNull(request.natGatewayId)) {
      query["NatGatewayId"] = request.natGatewayId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteNatGateway",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteNatGatewayResponse>(await this.callApi(params, req, runtime), new $_model.DeleteNatGatewayResponse({}));
  }

  /**
   * Deletes a specified Internet NAT gateway.
   * 
   * @remarks
   * ## [](#)Description
   * *   **DeleteNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) to query the status of the task.
   *     *   If a NAT gateway is in the **Deleting** state, the NAT gateway is being deleted. In this case, you can query the NAT gateway but you cannot perform other operations.
   *     *   If the NAT gateway cannot be found, the NAT gateway is deleted.
   *         After you delete a NAT gateway, you cannot restore the NAT gateway. Proceed with caution.
   * *   You cannot repeatedly call the **DeleteNatGateway** operation to delete a NAT gateway within the specified period of time.
   * 
   * @param request - DeleteNatGatewayRequest
   * @returns DeleteNatGatewayResponse
   */
  async deleteNatGateway(request: $_model.DeleteNatGatewayRequest): Promise<$_model.DeleteNatGatewayResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteNatGatewayWithOptions(request, runtime);
  }

  /**
   * Deletes a NAT IP address.
   * 
   * @remarks
   * ## [](#)Description
   * *   **DeleteNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/281979.html) operation to query the status of the task.
   *     *   If the NAT IP address is in the **Deleting** state, the NAT IP address is being deleted. In this case, you can only query the NAT IP address but cannot perform other operations.
   *     *   If the NAT IP address cannot be found, it is deleted.
   * *   You cannot repeatedly call the **DeleteNatIp** operation to delete a NAT IP address within the specified period of time.
   * 
   * @param request - DeleteNatIpRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteNatIpResponse
   */
  async deleteNatIpWithOptions(request: $_model.DeleteNatIpRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteNatIpResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.natIpId)) {
      query["NatIpId"] = request.natIpId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteNatIp",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteNatIpResponse>(await this.callApi(params, req, runtime), new $_model.DeleteNatIpResponse({}));
  }

  /**
   * Deletes a NAT IP address.
   * 
   * @remarks
   * ## [](#)Description
   * *   **DeleteNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/281979.html) operation to query the status of the task.
   *     *   If the NAT IP address is in the **Deleting** state, the NAT IP address is being deleted. In this case, you can only query the NAT IP address but cannot perform other operations.
   *     *   If the NAT IP address cannot be found, it is deleted.
   * *   You cannot repeatedly call the **DeleteNatIp** operation to delete a NAT IP address within the specified period of time.
   * 
   * @param request - DeleteNatIpRequest
   * @returns DeleteNatIpResponse
   */
  async deleteNatIp(request: $_model.DeleteNatIpRequest): Promise<$_model.DeleteNatIpResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteNatIpWithOptions(request, runtime);
  }

  /**
   * Deletes a NAT CIDR block.
   * 
   * @remarks
   * ## [](#)Description
   * You cannot repeatedly call the **DeleteNatIpCidr** operation to delete a NAT CIDR block within the specified period of time.
   * 
   * @param request - DeleteNatIpCidrRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteNatIpCidrResponse
   */
  async deleteNatIpCidrWithOptions(request: $_model.DeleteNatIpCidrRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteNatIpCidrResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.natGatewayId)) {
      query["NatGatewayId"] = request.natGatewayId;
    }

    if (!$dara.isNull(request.natIpCidr)) {
      query["NatIpCidr"] = request.natIpCidr;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteNatIpCidr",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteNatIpCidrResponse>(await this.callApi(params, req, runtime), new $_model.DeleteNatIpCidrResponse({}));
  }

  /**
   * Deletes a NAT CIDR block.
   * 
   * @remarks
   * ## [](#)Description
   * You cannot repeatedly call the **DeleteNatIpCidr** operation to delete a NAT CIDR block within the specified period of time.
   * 
   * @param request - DeleteNatIpCidrRequest
   * @returns DeleteNatIpCidrResponse
   */
  async deleteNatIpCidr(request: $_model.DeleteNatIpCidrRequest): Promise<$_model.DeleteNatIpCidrResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteNatIpCidrWithOptions(request, runtime);
  }

  /**
   * Deletes a network access control list (ACL).
   * 
   * @remarks
   * ## [](#)Description
   * You cannot repeatedly call the **DeleteNetworkAcl** operation within the specified period of time.
   * 
   * @param request - DeleteNetworkAclRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteNetworkAclResponse
   */
  async deleteNetworkAclWithOptions(request: $_model.DeleteNetworkAclRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteNetworkAclResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.networkAclId)) {
      query["NetworkAclId"] = request.networkAclId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteNetworkAcl",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteNetworkAclResponse>(await this.callApi(params, req, runtime), new $_model.DeleteNetworkAclResponse({}));
  }

  /**
   * Deletes a network access control list (ACL).
   * 
   * @remarks
   * ## [](#)Description
   * You cannot repeatedly call the **DeleteNetworkAcl** operation within the specified period of time.
   * 
   * @param request - DeleteNetworkAclRequest
   * @returns DeleteNetworkAclResponse
   */
  async deleteNetworkAcl(request: $_model.DeleteNetworkAclRequest): Promise<$_model.DeleteNetworkAclResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteNetworkAclWithOptions(request, runtime);
  }

  /**
   * Deletes a connection over an Express Connect circuit.
   * 
   * @remarks
   * You can only delete a connection over an Express Connect circuit that is in the **Allocated**, **Confirmed**, **Rejected**, **Canceled**, **AllocationFailed**, and **Terminated** states.
   * 
   * @param request - DeletePhysicalConnectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeletePhysicalConnectionResponse
   */
  async deletePhysicalConnectionWithOptions(request: $_model.DeletePhysicalConnectionRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeletePhysicalConnectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.physicalConnectionId)) {
      query["PhysicalConnectionId"] = request.physicalConnectionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeletePhysicalConnection",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeletePhysicalConnectionResponse>(await this.callApi(params, req, runtime), new $_model.DeletePhysicalConnectionResponse({}));
  }

  /**
   * Deletes a connection over an Express Connect circuit.
   * 
   * @remarks
   * You can only delete a connection over an Express Connect circuit that is in the **Allocated**, **Confirmed**, **Rejected**, **Canceled**, **AllocationFailed**, and **Terminated** states.
   * 
   * @param request - DeletePhysicalConnectionRequest
   * @returns DeletePhysicalConnectionResponse
   */
  async deletePhysicalConnection(request: $_model.DeletePhysicalConnectionRequest): Promise<$_model.DeletePhysicalConnectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deletePhysicalConnectionWithOptions(request, runtime);
  }

  /**
   * Deletes an IP address pool.
   * 
   * @remarks
   * Before you call this operation, take note of the following items:
   * *   Before you delete an IP address pool, make sure that no IP address in the pool is being used.
   * *   **DeletePublicIpAddressPool** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPools](https://help.aliyun.com/document_detail/429433.html) operation to query the status of the task.
   *     *   If the IP address pool is in the **Deleting** state, the IP address pool is being deleted. In this state. you can only query the IP address pool and cannot perform other operations.
   *     *   If you cannot query the IP address pool, the IP address pool is deleted.
   * *   You cannot repeatedly call the **DeletePublicIpAddressPool** operation to delete an IP address pool within the specified period of time.
   * 
   * @param request - DeletePublicIpAddressPoolRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeletePublicIpAddressPoolResponse
   */
  async deletePublicIpAddressPoolWithOptions(request: $_model.DeletePublicIpAddressPoolRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeletePublicIpAddressPoolResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.publicIpAddressPoolId)) {
      query["PublicIpAddressPoolId"] = request.publicIpAddressPoolId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeletePublicIpAddressPool",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeletePublicIpAddressPoolResponse>(await this.callApi(params, req, runtime), new $_model.DeletePublicIpAddressPoolResponse({}));
  }

  /**
   * Deletes an IP address pool.
   * 
   * @remarks
   * Before you call this operation, take note of the following items:
   * *   Before you delete an IP address pool, make sure that no IP address in the pool is being used.
   * *   **DeletePublicIpAddressPool** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPools](https://help.aliyun.com/document_detail/429433.html) operation to query the status of the task.
   *     *   If the IP address pool is in the **Deleting** state, the IP address pool is being deleted. In this state. you can only query the IP address pool and cannot perform other operations.
   *     *   If you cannot query the IP address pool, the IP address pool is deleted.
   * *   You cannot repeatedly call the **DeletePublicIpAddressPool** operation to delete an IP address pool within the specified period of time.
   * 
   * @param request - DeletePublicIpAddressPoolRequest
   * @returns DeletePublicIpAddressPoolResponse
   */
  async deletePublicIpAddressPool(request: $_model.DeletePublicIpAddressPoolRequest): Promise<$_model.DeletePublicIpAddressPoolResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deletePublicIpAddressPoolWithOptions(request, runtime);
  }

  /**
   * Deletes a CIDR block from an IP address pool.
   * 
   * @remarks
   * Before you call this operation, take note of the following items:
   * *   Before you delete a CIDR block, make sure that it is not being used.
   * *   **DeletePublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
   *     *   If the CIDR block is in the **Deleting** state, the CIDR block is being deleted. In this state, you can only query the CIDR block and cannot perform other operations.
   *     *   If you cannot query the CIDR block, the CIDR block is deleted.
   * *   You cannot repeatedly call the **DeletePublicIpAddressPoolCidrBlock** operation to delete a CIDR block within the specified period of time.
   * 
   * @param request - DeletePublicIpAddressPoolCidrBlockRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeletePublicIpAddressPoolCidrBlockResponse
   */
  async deletePublicIpAddressPoolCidrBlockWithOptions(request: $_model.DeletePublicIpAddressPoolCidrBlockRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeletePublicIpAddressPoolCidrBlockResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.cidrBlock)) {
      query["CidrBlock"] = request.cidrBlock;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.publicIpAddressPoolId)) {
      query["PublicIpAddressPoolId"] = request.publicIpAddressPoolId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeletePublicIpAddressPoolCidrBlock",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeletePublicIpAddressPoolCidrBlockResponse>(await this.callApi(params, req, runtime), new $_model.DeletePublicIpAddressPoolCidrBlockResponse({}));
  }

  /**
   * Deletes a CIDR block from an IP address pool.
   * 
   * @remarks
   * Before you call this operation, take note of the following items:
   * *   Before you delete a CIDR block, make sure that it is not being used.
   * *   **DeletePublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
   *     *   If the CIDR block is in the **Deleting** state, the CIDR block is being deleted. In this state, you can only query the CIDR block and cannot perform other operations.
   *     *   If you cannot query the CIDR block, the CIDR block is deleted.
   * *   You cannot repeatedly call the **DeletePublicIpAddressPoolCidrBlock** operation to delete a CIDR block within the specified period of time.
   * 
   * @param request - DeletePublicIpAddressPoolCidrBlockRequest
   * @returns DeletePublicIpAddressPoolCidrBlockResponse
   */
  async deletePublicIpAddressPoolCidrBlock(request: $_model.DeletePublicIpAddressPoolCidrBlockRequest): Promise<$_model.DeletePublicIpAddressPoolCidrBlockResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deletePublicIpAddressPoolCidrBlockWithOptions(request, runtime);
  }

  /**
   * Deletes multiple custom route entries at a time.
   * 
   * @remarks
   * When you call this operation, take note of the following items:
   * *   You can delete only routes that are in the **Available** state.
   * *   You cannot delete a route of a virtual private cloud (VPC) in which a vSwitch or another route is being created or deleted.
   * *   **DeleteRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
   *     *   If the route is in the **Deleting** state, the route is being deleted.
   *     *   If you cannot query the route, the route is deleted.
   * *   You cannot repeatedly call **DeleteRouteEntries** within a specific period of time.
   * 
   * @param request - DeleteRouteEntriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRouteEntriesResponse
   */
  async deleteRouteEntriesWithOptions(request: $_model.DeleteRouteEntriesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteRouteEntriesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeEntries)) {
      query["RouteEntries"] = request.routeEntries;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteRouteEntries",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteRouteEntriesResponse>(await this.callApi(params, req, runtime), new $_model.DeleteRouteEntriesResponse({}));
  }

  /**
   * Deletes multiple custom route entries at a time.
   * 
   * @remarks
   * When you call this operation, take note of the following items:
   * *   You can delete only routes that are in the **Available** state.
   * *   You cannot delete a route of a virtual private cloud (VPC) in which a vSwitch or another route is being created or deleted.
   * *   **DeleteRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
   *     *   If the route is in the **Deleting** state, the route is being deleted.
   *     *   If you cannot query the route, the route is deleted.
   * *   You cannot repeatedly call **DeleteRouteEntries** within a specific period of time.
   * 
   * @param request - DeleteRouteEntriesRequest
   * @returns DeleteRouteEntriesResponse
   */
  async deleteRouteEntries(request: $_model.DeleteRouteEntriesRequest): Promise<$_model.DeleteRouteEntriesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteRouteEntriesWithOptions(request, runtime);
  }

  /**
   * Deletes a route entry from a route table of a VRouter or virtual border router (VBR).
   * 
   * @remarks
   * When you call this operation, take note of the following items:
   * *   You can delete only routes that are in the **Available** state.
   * *   You cannot delete a route entry of a virtual private cloud (VPC) in which a vSwitch or another route entry is being created or deleted.
   * *   Before you call this operation to delete a route of a VBR route table, call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the **NextHopId** of the route first.
   * *   **DeleteRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
   *     *   If the route is in the **Deleting** state, the route is being deleted.
   *     *   If you cannot query the route entry, the route entry is deleted.
   * *   You cannot repeatedly call the **DeleteRouteEntry** operation to delete a route from the route table of a vRouter or a VBR within the specified period of time.
   * 
   * @param request - DeleteRouteEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRouteEntryResponse
   */
  async deleteRouteEntryWithOptions(request: $_model.DeleteRouteEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteRouteEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.destinationCidrBlock)) {
      query["DestinationCidrBlock"] = request.destinationCidrBlock;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.nextHopId)) {
      query["NextHopId"] = request.nextHopId;
    }

    if (!$dara.isNull(request.nextHopList)) {
      query["NextHopList"] = request.nextHopList;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeEntryId)) {
      query["RouteEntryId"] = request.routeEntryId;
    }

    if (!$dara.isNull(request.routeTableId)) {
      query["RouteTableId"] = request.routeTableId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteRouteEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteRouteEntryResponse>(await this.callApi(params, req, runtime), new $_model.DeleteRouteEntryResponse({}));
  }

  /**
   * Deletes a route entry from a route table of a VRouter or virtual border router (VBR).
   * 
   * @remarks
   * When you call this operation, take note of the following items:
   * *   You can delete only routes that are in the **Available** state.
   * *   You cannot delete a route entry of a virtual private cloud (VPC) in which a vSwitch or another route entry is being created or deleted.
   * *   Before you call this operation to delete a route of a VBR route table, call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the **NextHopId** of the route first.
   * *   **DeleteRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
   *     *   If the route is in the **Deleting** state, the route is being deleted.
   *     *   If you cannot query the route entry, the route entry is deleted.
   * *   You cannot repeatedly call the **DeleteRouteEntry** operation to delete a route from the route table of a vRouter or a VBR within the specified period of time.
   * 
   * @param request - DeleteRouteEntryRequest
   * @returns DeleteRouteEntryResponse
   */
  async deleteRouteEntry(request: $_model.DeleteRouteEntryRequest): Promise<$_model.DeleteRouteEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteRouteEntryWithOptions(request, runtime);
  }

  /**
   * Deletes a custom route table.
   * 
   * @remarks
   * ## [](#)Description
   * *   **DeleteRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
   *     *   If the custom route table is in the **Deleting** state, the custom route table is being deleted.
   *     *   If you cannot query the custom route table, the custom route table is deleted.
   * *   You cannot repeatedly call the **DeleteRouteTable** operation to delete a custom route table within the specified period of time.
   * 
   * @param request - DeleteRouteTableRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRouteTableResponse
   */
  async deleteRouteTableWithOptions(request: $_model.DeleteRouteTableRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteRouteTableResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeTableId)) {
      query["RouteTableId"] = request.routeTableId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteRouteTable",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteRouteTableResponse>(await this.callApi(params, req, runtime), new $_model.DeleteRouteTableResponse({}));
  }

  /**
   * Deletes a custom route table.
   * 
   * @remarks
   * ## [](#)Description
   * *   **DeleteRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
   *     *   If the custom route table is in the **Deleting** state, the custom route table is being deleted.
   *     *   If you cannot query the custom route table, the custom route table is deleted.
   * *   You cannot repeatedly call the **DeleteRouteTable** operation to delete a custom route table within the specified period of time.
   * 
   * @param request - DeleteRouteTableRequest
   * @returns DeleteRouteTableResponse
   */
  async deleteRouteTable(request: $_model.DeleteRouteTableRequest): Promise<$_model.DeleteRouteTableResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteRouteTableWithOptions(request, runtime);
  }

  /**
   * Deletes a router interface.
   * 
   * @remarks
   * When you call this operation, take note of the following limits:
   * *   You can delete only a router interface that is in the **Idle** or **Inactive** state.
   * *   Before you delete a router interface, you must delete all custom route entries destined for the router interface.
   * 
   * @param request - DeleteRouterInterfaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRouterInterfaceResponse
   */
  async deleteRouterInterfaceWithOptions(request: $_model.DeleteRouterInterfaceRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteRouterInterfaceResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routerInterfaceId)) {
      query["RouterInterfaceId"] = request.routerInterfaceId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteRouterInterface",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteRouterInterfaceResponse>(await this.callApi(params, req, runtime), new $_model.DeleteRouterInterfaceResponse({}));
  }

  /**
   * Deletes a router interface.
   * 
   * @remarks
   * When you call this operation, take note of the following limits:
   * *   You can delete only a router interface that is in the **Idle** or **Inactive** state.
   * *   Before you delete a router interface, you must delete all custom route entries destined for the router interface.
   * 
   * @param request - DeleteRouterInterfaceRequest
   * @returns DeleteRouterInterfaceResponse
   */
  async deleteRouterInterface(request: $_model.DeleteRouterInterfaceRequest): Promise<$_model.DeleteRouterInterfaceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteRouterInterfaceWithOptions(request, runtime);
  }

  /**
   * Deletes an SNAT entry.
   * 
   * @remarks
   * DeleteSnatEntry is an asynchronous operation. After you make a request, the ID of the request is returned but the specified SNAT entry is not deleted. The system deletes the SNAT entry in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of SNAT entries.
   * *   If the SNAT entries are in the **Deleting** state, the system is deleting the SNAT entries. In this case, you can only query the status of the SNAT entries, and cannot perform other operations.
   * *   If no SNAT entry is returned in the response, the SNAT entry is deleted.
   * If some SNAT entries are in the **Pending** state, you cannot delete these SNAT entries.
   * 
   * @param request - DeleteSnatEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteSnatEntryResponse
   */
  async deleteSnatEntryWithOptions(request: $_model.DeleteSnatEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteSnatEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.snatEntryId)) {
      query["SnatEntryId"] = request.snatEntryId;
    }

    if (!$dara.isNull(request.snatTableId)) {
      query["SnatTableId"] = request.snatTableId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteSnatEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteSnatEntryResponse>(await this.callApi(params, req, runtime), new $_model.DeleteSnatEntryResponse({}));
  }

  /**
   * Deletes an SNAT entry.
   * 
   * @remarks
   * DeleteSnatEntry is an asynchronous operation. After you make a request, the ID of the request is returned but the specified SNAT entry is not deleted. The system deletes the SNAT entry in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of SNAT entries.
   * *   If the SNAT entries are in the **Deleting** state, the system is deleting the SNAT entries. In this case, you can only query the status of the SNAT entries, and cannot perform other operations.
   * *   If no SNAT entry is returned in the response, the SNAT entry is deleted.
   * If some SNAT entries are in the **Pending** state, you cannot delete these SNAT entries.
   * 
   * @param request - DeleteSnatEntryRequest
   * @returns DeleteSnatEntryResponse
   */
  async deleteSnatEntry(request: $_model.DeleteSnatEntryRequest): Promise<$_model.DeleteSnatEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteSnatEntryWithOptions(request, runtime);
  }

  /**
   * Deletes an SSL client certificate.
   * 
   * @remarks
   *   If you delete an SSL client certificate, all SSL-VPN client connections to the SSL server are disconnected. You need to reinitiate connections from SSL clients.
   *     For example, SSL client certificate 1 and SSL client certificate 2 are created on an SSL server. After you delete certificate 1, all client connections associated with certificate 1 and certificate 2 are disconnected from the SSL server.
   *     *   If clients associated with certificate 1 require SSL-VPN connections, you need to install other certificates on the clients and reinitiate connections from the clients.
   *     *   If clients associated with certificate 2 require SSL-VPN connections, you can directly reinitiate connections from the clients.
   * *   **DeleteSslVpnClientCert** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the SSL client certificate is being deleted.
   *     *   If the VPN gateway is in the **active** state, the SSL client certificate is deleted.
   * *   You cannot call **DeleteSslVpnClientCert** within the specified period of time.
   * 
   * @param request - DeleteSslVpnClientCertRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteSslVpnClientCertResponse
   */
  async deleteSslVpnClientCertWithOptions(request: $_model.DeleteSslVpnClientCertRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteSslVpnClientCertResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.sslVpnClientCertId)) {
      query["SslVpnClientCertId"] = request.sslVpnClientCertId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteSslVpnClientCert",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteSslVpnClientCertResponse>(await this.callApi(params, req, runtime), new $_model.DeleteSslVpnClientCertResponse({}));
  }

  /**
   * Deletes an SSL client certificate.
   * 
   * @remarks
   *   If you delete an SSL client certificate, all SSL-VPN client connections to the SSL server are disconnected. You need to reinitiate connections from SSL clients.
   *     For example, SSL client certificate 1 and SSL client certificate 2 are created on an SSL server. After you delete certificate 1, all client connections associated with certificate 1 and certificate 2 are disconnected from the SSL server.
   *     *   If clients associated with certificate 1 require SSL-VPN connections, you need to install other certificates on the clients and reinitiate connections from the clients.
   *     *   If clients associated with certificate 2 require SSL-VPN connections, you can directly reinitiate connections from the clients.
   * *   **DeleteSslVpnClientCert** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the SSL client certificate is being deleted.
   *     *   If the VPN gateway is in the **active** state, the SSL client certificate is deleted.
   * *   You cannot call **DeleteSslVpnClientCert** within the specified period of time.
   * 
   * @param request - DeleteSslVpnClientCertRequest
   * @returns DeleteSslVpnClientCertResponse
   */
  async deleteSslVpnClientCert(request: $_model.DeleteSslVpnClientCertRequest): Promise<$_model.DeleteSslVpnClientCertResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteSslVpnClientCertWithOptions(request, runtime);
  }

  /**
   * Deletes an SSL server.
   * 
   * @remarks
   *   **DeleteSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the SSL server is being deleted.
   *     *   If the VPN gateway is in the **active** state, the SSL server is deleted.
   * *   You cannot repeatedly call the **DeleteSslVpnServer** operation to delete an SSL server from the same VPN gateway within the specified period of time.
   * 
   * @param request - DeleteSslVpnServerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteSslVpnServerResponse
   */
  async deleteSslVpnServerWithOptions(request: $_model.DeleteSslVpnServerRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteSslVpnServerResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.sslVpnServerId)) {
      query["SslVpnServerId"] = request.sslVpnServerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteSslVpnServer",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteSslVpnServerResponse>(await this.callApi(params, req, runtime), new $_model.DeleteSslVpnServerResponse({}));
  }

  /**
   * Deletes an SSL server.
   * 
   * @remarks
   *   **DeleteSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the SSL server is being deleted.
   *     *   If the VPN gateway is in the **active** state, the SSL server is deleted.
   * *   You cannot repeatedly call the **DeleteSslVpnServer** operation to delete an SSL server from the same VPN gateway within the specified period of time.
   * 
   * @param request - DeleteSslVpnServerRequest
   * @returns DeleteSslVpnServerResponse
   */
  async deleteSslVpnServer(request: $_model.DeleteSslVpnServerRequest): Promise<$_model.DeleteSslVpnServerResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteSslVpnServerWithOptions(request, runtime);
  }

  /**
   * Deletes a filter of traffic mirror.
   * 
   * @remarks
   *   The **DeleteTrafficMirrorFilter** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of a filter:
   *     *   If the filter is in the **Deleting** state, the filter is being deleted.
   *     *   If you cannot query the filter, the filter is deleted.
   * *   You cannot repeatedly call the **DeleteTrafficMirrorFilter** operation to delete a filter within the specified period of time.
   * 
   * @param request - DeleteTrafficMirrorFilterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTrafficMirrorFilterResponse
   */
  async deleteTrafficMirrorFilterWithOptions(request: $_model.DeleteTrafficMirrorFilterRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteTrafficMirrorFilterResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.trafficMirrorFilterId)) {
      query["TrafficMirrorFilterId"] = request.trafficMirrorFilterId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteTrafficMirrorFilter",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteTrafficMirrorFilterResponse>(await this.callApi(params, req, runtime), new $_model.DeleteTrafficMirrorFilterResponse({}));
  }

  /**
   * Deletes a filter of traffic mirror.
   * 
   * @remarks
   *   The **DeleteTrafficMirrorFilter** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of a filter:
   *     *   If the filter is in the **Deleting** state, the filter is being deleted.
   *     *   If you cannot query the filter, the filter is deleted.
   * *   You cannot repeatedly call the **DeleteTrafficMirrorFilter** operation to delete a filter within the specified period of time.
   * 
   * @param request - DeleteTrafficMirrorFilterRequest
   * @returns DeleteTrafficMirrorFilterResponse
   */
  async deleteTrafficMirrorFilter(request: $_model.DeleteTrafficMirrorFilterRequest): Promise<$_model.DeleteTrafficMirrorFilterResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteTrafficMirrorFilterWithOptions(request, runtime);
  }

  /**
   * Deletes an inbound or outbound rule of a filter for traffic mirror.
   * 
   * @remarks
   *   **DeleteTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
   *     *   If the inbound or outbound rule is in the **Deleting** state, the rule is being deleted.
   *     *   If you cannot query the rule, the rule is deleted.
   * *   You cannot repeatedly call **DeleteTrafficMirrorFilterRules** within the specified period of time.
   * 
   * @param request - DeleteTrafficMirrorFilterRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTrafficMirrorFilterRulesResponse
   */
  async deleteTrafficMirrorFilterRulesWithOptions(request: $_model.DeleteTrafficMirrorFilterRulesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteTrafficMirrorFilterRulesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.trafficMirrorFilterId)) {
      query["TrafficMirrorFilterId"] = request.trafficMirrorFilterId;
    }

    if (!$dara.isNull(request.trafficMirrorFilterRuleIds)) {
      query["TrafficMirrorFilterRuleIds"] = request.trafficMirrorFilterRuleIds;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteTrafficMirrorFilterRules",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteTrafficMirrorFilterRulesResponse>(await this.callApi(params, req, runtime), new $_model.DeleteTrafficMirrorFilterRulesResponse({}));
  }

  /**
   * Deletes an inbound or outbound rule of a filter for traffic mirror.
   * 
   * @remarks
   *   **DeleteTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
   *     *   If the inbound or outbound rule is in the **Deleting** state, the rule is being deleted.
   *     *   If you cannot query the rule, the rule is deleted.
   * *   You cannot repeatedly call **DeleteTrafficMirrorFilterRules** within the specified period of time.
   * 
   * @param request - DeleteTrafficMirrorFilterRulesRequest
   * @returns DeleteTrafficMirrorFilterRulesResponse
   */
  async deleteTrafficMirrorFilterRules(request: $_model.DeleteTrafficMirrorFilterRulesRequest): Promise<$_model.DeleteTrafficMirrorFilterRulesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteTrafficMirrorFilterRulesWithOptions(request, runtime);
  }

  /**
   * Deletes a traffic mirror session.
   * 
   * @remarks
   *   **DeleteTrafficMirrorSession** is an asynchronous operation. After you send the request, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of a traffic mirror session.
   *     *   If the traffic mirror session is in the **Deleting** state, the traffic mirror session is being deleted.
   *     *   If you cannot query the traffic mirror session, the traffic mirror session is deleted.
   * *   You cannot repeatedly call the **DeleteTrafficMirrorSession** operation to delete a traffic mirror session within the specified period of time.
   * 
   * @param request - DeleteTrafficMirrorSessionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTrafficMirrorSessionResponse
   */
  async deleteTrafficMirrorSessionWithOptions(request: $_model.DeleteTrafficMirrorSessionRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteTrafficMirrorSessionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.trafficMirrorSessionId)) {
      query["TrafficMirrorSessionId"] = request.trafficMirrorSessionId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteTrafficMirrorSession",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteTrafficMirrorSessionResponse>(await this.callApi(params, req, runtime), new $_model.DeleteTrafficMirrorSessionResponse({}));
  }

  /**
   * Deletes a traffic mirror session.
   * 
   * @remarks
   *   **DeleteTrafficMirrorSession** is an asynchronous operation. After you send the request, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of a traffic mirror session.
   *     *   If the traffic mirror session is in the **Deleting** state, the traffic mirror session is being deleted.
   *     *   If you cannot query the traffic mirror session, the traffic mirror session is deleted.
   * *   You cannot repeatedly call the **DeleteTrafficMirrorSession** operation to delete a traffic mirror session within the specified period of time.
   * 
   * @param request - DeleteTrafficMirrorSessionRequest
   * @returns DeleteTrafficMirrorSessionResponse
   */
  async deleteTrafficMirrorSession(request: $_model.DeleteTrafficMirrorSessionRequest): Promise<$_model.DeleteTrafficMirrorSessionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteTrafficMirrorSessionWithOptions(request, runtime);
  }

  /**
   * Deletes a vSwitch.
   * 
   * @remarks
   * When you call this operation, take note of the following limits:
   * *   Before you delete a vSwitch, you must first release or remove all virtual private cloud (VPC) resources, including vSwitches, instances, router interfaces, and high-availability virtual IP addresses (HaVips).
   * *   You can delete only vSwitches that are in the **Available** state.
   * *   You cannot delete a vSwitch from a VPC where a vSwitch or a route is being created or deleted.
   * *   **DeleteVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
   *     *   If the vSwitch is in the **Pending** state, the vSwitch is being deleted.
   *     *   If you cannot query the vSwitch, the vSwitch is deleted.
   * *   You cannot repeatedly call the **DeleteVSwitch** operation to delete a vSwitch within the specified period of time.
   * 
   * @param request - DeleteVSwitchRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteVSwitchResponse
   */
  async deleteVSwitchWithOptions(request: $_model.DeleteVSwitchRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteVSwitchResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteVSwitch",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteVSwitchResponse>(await this.callApi(params, req, runtime), new $_model.DeleteVSwitchResponse({}));
  }

  /**
   * Deletes a vSwitch.
   * 
   * @remarks
   * When you call this operation, take note of the following limits:
   * *   Before you delete a vSwitch, you must first release or remove all virtual private cloud (VPC) resources, including vSwitches, instances, router interfaces, and high-availability virtual IP addresses (HaVips).
   * *   You can delete only vSwitches that are in the **Available** state.
   * *   You cannot delete a vSwitch from a VPC where a vSwitch or a route is being created or deleted.
   * *   **DeleteVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
   *     *   If the vSwitch is in the **Pending** state, the vSwitch is being deleted.
   *     *   If you cannot query the vSwitch, the vSwitch is deleted.
   * *   You cannot repeatedly call the **DeleteVSwitch** operation to delete a vSwitch within the specified period of time.
   * 
   * @param request - DeleteVSwitchRequest
   * @returns DeleteVSwitchResponse
   */
  async deleteVSwitch(request: $_model.DeleteVSwitchRequest): Promise<$_model.DeleteVSwitchResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteVSwitchWithOptions(request, runtime);
  }

  /**
   * Deletes a reserved CIDR block of a vSwitch.
   * 
   * @remarks
   * ## [](#)Description
   * *   Before you call this operation, make sure that the IP address allocated to an elastic network interface (ENI) from the reserved CIDR block is deleted. If the IP address of the ENI is not deleted, call [UnassignPrivateIpAddresses](https://help.aliyun.com/document_detail/85919.html) or [UnassignIpv6Addresses](https://help.aliyun.com/document_detail/98611.html) to delete the IPv4 or IPv6 address.
   * *   **DeleteVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
   *     *   If the reserved CIDR block is in the **Releasing** state, it is being released.
   *     *   If the reserved CIDR block is in the **Released** state, it is released.
   * 
   * @param request - DeleteVSwitchCidrReservationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteVSwitchCidrReservationResponse
   */
  async deleteVSwitchCidrReservationWithOptions(request: $_model.DeleteVSwitchCidrReservationRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteVSwitchCidrReservationResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vSwitchCidrReservationId)) {
      query["VSwitchCidrReservationId"] = request.vSwitchCidrReservationId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteVSwitchCidrReservation",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteVSwitchCidrReservationResponse>(await this.callApi(params, req, runtime), new $_model.DeleteVSwitchCidrReservationResponse({}));
  }

  /**
   * Deletes a reserved CIDR block of a vSwitch.
   * 
   * @remarks
   * ## [](#)Description
   * *   Before you call this operation, make sure that the IP address allocated to an elastic network interface (ENI) from the reserved CIDR block is deleted. If the IP address of the ENI is not deleted, call [UnassignPrivateIpAddresses](https://help.aliyun.com/document_detail/85919.html) or [UnassignIpv6Addresses](https://help.aliyun.com/document_detail/98611.html) to delete the IPv4 or IPv6 address.
   * *   **DeleteVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
   *     *   If the reserved CIDR block is in the **Releasing** state, it is being released.
   *     *   If the reserved CIDR block is in the **Released** state, it is released.
   * 
   * @param request - DeleteVSwitchCidrReservationRequest
   * @returns DeleteVSwitchCidrReservationResponse
   */
  async deleteVSwitchCidrReservation(request: $_model.DeleteVSwitchCidrReservationRequest): Promise<$_model.DeleteVSwitchCidrReservationResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteVSwitchCidrReservationWithOptions(request, runtime);
  }

  /**
   * Deletes a virtual border router (VBR) failover group.
   * 
   * @param request - DeleteVbrHaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteVbrHaResponse
   */
  async deleteVbrHaWithOptions(request: $_model.DeleteVbrHaRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteVbrHaResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteVbrHa",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteVbrHaResponse>(await this.callApi(params, req, runtime), new $_model.DeleteVbrHaResponse({}));
  }

  /**
   * Deletes a virtual border router (VBR) failover group.
   * 
   * @param request - DeleteVbrHaRequest
   * @returns DeleteVbrHaResponse
   */
  async deleteVbrHa(request: $_model.DeleteVbrHaRequest): Promise<$_model.DeleteVbrHaResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteVbrHaWithOptions(request, runtime);
  }

  /**
   * Deletes a destination-based route from an IPsec-VPN connection.
   * 
   * @remarks
   *   **DeleteVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task.
   *     *   If the IPsec-VPN connection is in the **updating** state, the route is being deleted.
   *     *   If the IPsec-VPN connection is in the **attached** state, the route is deleted.
   * *   You cannot repeatedly call the **DeleteVcoRouteEntry** operation within a specific time period.
   * 
   * @param request - DeleteVcoRouteEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteVcoRouteEntryResponse
   */
  async deleteVcoRouteEntryWithOptions(request: $_model.DeleteVcoRouteEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteVcoRouteEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.nextHop)) {
      query["NextHop"] = request.nextHop;
    }

    if (!$dara.isNull(request.overlayMode)) {
      query["OverlayMode"] = request.overlayMode;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeDest)) {
      query["RouteDest"] = request.routeDest;
    }

    if (!$dara.isNull(request.vpnConnectionId)) {
      query["VpnConnectionId"] = request.vpnConnectionId;
    }

    if (!$dara.isNull(request.weight)) {
      query["Weight"] = request.weight;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteVcoRouteEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteVcoRouteEntryResponse>(await this.callApi(params, req, runtime), new $_model.DeleteVcoRouteEntryResponse({}));
  }

  /**
   * Deletes a destination-based route from an IPsec-VPN connection.
   * 
   * @remarks
   *   **DeleteVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task.
   *     *   If the IPsec-VPN connection is in the **updating** state, the route is being deleted.
   *     *   If the IPsec-VPN connection is in the **attached** state, the route is deleted.
   * *   You cannot repeatedly call the **DeleteVcoRouteEntry** operation within a specific time period.
   * 
   * @param request - DeleteVcoRouteEntryRequest
   * @returns DeleteVcoRouteEntryResponse
   */
  async deleteVcoRouteEntry(request: $_model.DeleteVcoRouteEntryRequest): Promise<$_model.DeleteVcoRouteEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteVcoRouteEntryWithOptions(request, runtime);
  }

  /**
   * Deletes a virtual border router (VBR).
   * 
   * @remarks
   * Before you call this operation, take note of the following limits:
   * *   Before you delete a VBR, you must delete all router interfaces of the VBR.
   * *   You can delete only a VBR in the **unconfirmed**, **active**, or **terminated** state.
   * *   The owner of an Express Connect circuit can delete a VBR that belongs to another account only if the VBR is in the **unconfirmed** state.
   * 
   * @param request - DeleteVirtualBorderRouterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteVirtualBorderRouterResponse
   */
  async deleteVirtualBorderRouterWithOptions(request: $_model.DeleteVirtualBorderRouterRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteVirtualBorderRouterResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vbrId)) {
      query["VbrId"] = request.vbrId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteVirtualBorderRouter",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteVirtualBorderRouterResponse>(await this.callApi(params, req, runtime), new $_model.DeleteVirtualBorderRouterResponse({}));
  }

  /**
   * Deletes a virtual border router (VBR).
   * 
   * @remarks
   * Before you call this operation, take note of the following limits:
   * *   Before you delete a VBR, you must delete all router interfaces of the VBR.
   * *   You can delete only a VBR in the **unconfirmed**, **active**, or **terminated** state.
   * *   The owner of an Express Connect circuit can delete a VBR that belongs to another account only if the VBR is in the **unconfirmed** state.
   * 
   * @param request - DeleteVirtualBorderRouterRequest
   * @returns DeleteVirtualBorderRouterResponse
   */
  async deleteVirtualBorderRouter(request: $_model.DeleteVirtualBorderRouterRequest): Promise<$_model.DeleteVirtualBorderRouterResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteVirtualBorderRouterWithOptions(request, runtime);
  }

  /**
   * Deletes a virtual private cloud (VPC).
   * 
   * @remarks
   * When you call this operation, take note of the following limits:
   * *   Before you delete a VPC, make sure that all resources deployed in the VPC are released or removed, such as vSwitches, instances, and high-availability virtual IP addresses (HaVips).
   * *   You can delete only a VPC that is in the **Available** state.
   * *   The **DeleteVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a VPC:
   *     *   If the VPC is in the **Deleting** state, the VPC is being deleted.
   *     *   If you cannot query the VPC, the VPC is deleted.
   * *   You cannot repeatedly call the **DeleteVpc** operation to delete a VPC within the specified period of time.
   * 
   * @param request - DeleteVpcRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteVpcResponse
   */
  async deleteVpcWithOptions(request: $_model.DeleteVpcRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteVpcResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.forceDelete)) {
      query["ForceDelete"] = request.forceDelete;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteVpc",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteVpcResponse>(await this.callApi(params, req, runtime), new $_model.DeleteVpcResponse({}));
  }

  /**
   * Deletes a virtual private cloud (VPC).
   * 
   * @remarks
   * When you call this operation, take note of the following limits:
   * *   Before you delete a VPC, make sure that all resources deployed in the VPC are released or removed, such as vSwitches, instances, and high-availability virtual IP addresses (HaVips).
   * *   You can delete only a VPC that is in the **Available** state.
   * *   The **DeleteVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a VPC:
   *     *   If the VPC is in the **Deleting** state, the VPC is being deleted.
   *     *   If you cannot query the VPC, the VPC is deleted.
   * *   You cannot repeatedly call the **DeleteVpc** operation to delete a VPC within the specified period of time.
   * 
   * @param request - DeleteVpcRequest
   * @returns DeleteVpcResponse
   */
  async deleteVpc(request: $_model.DeleteVpcRequest): Promise<$_model.DeleteVpcResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteVpcWithOptions(request, runtime);
  }

  /**
   * Deletes a gateway endpoint.
   * 
   * @param request - DeleteVpcGatewayEndpointRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteVpcGatewayEndpointResponse
   */
  async deleteVpcGatewayEndpointWithOptions(request: $_model.DeleteVpcGatewayEndpointRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteVpcGatewayEndpointResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.endpointId)) {
      query["EndpointId"] = request.endpointId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteVpcGatewayEndpoint",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteVpcGatewayEndpointResponse>(await this.callApi(params, req, runtime), new $_model.DeleteVpcGatewayEndpointResponse({}));
  }

  /**
   * Deletes a gateway endpoint.
   * 
   * @param request - DeleteVpcGatewayEndpointRequest
   * @returns DeleteVpcGatewayEndpointResponse
   */
  async deleteVpcGatewayEndpoint(request: $_model.DeleteVpcGatewayEndpointRequest): Promise<$_model.DeleteVpcGatewayEndpointResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteVpcGatewayEndpointWithOptions(request, runtime);
  }

  /**
   * Deletes a prefix list.
   * 
   * @remarks
   * You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a prefix list within the specified period of time.
   * 
   * @param request - DeleteVpcPrefixListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteVpcPrefixListResponse
   */
  async deleteVpcPrefixListWithOptions(request: $_model.DeleteVpcPrefixListRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteVpcPrefixListResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.prefixListId)) {
      query["PrefixListId"] = request.prefixListId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteVpcPrefixList",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteVpcPrefixListResponse>(await this.callApi(params, req, runtime), new $_model.DeleteVpcPrefixListResponse({}));
  }

  /**
   * Deletes a prefix list.
   * 
   * @remarks
   * You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a prefix list within the specified period of time.
   * 
   * @param request - DeleteVpcPrefixListRequest
   * @returns DeleteVpcPrefixListResponse
   */
  async deleteVpcPrefixList(request: $_model.DeleteVpcPrefixListRequest): Promise<$_model.DeleteVpcPrefixListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteVpcPrefixListWithOptions(request, runtime);
  }

  /**
   * Deletes an IPsec-VPN connection.
   * 
   * @remarks
   *   If an IPsec-VPN connection is associated with a transit router, you must disassociate the transit router from the IPsec-VPN connection before you delete the IPsec-VPN connection. For more information, see [DeleteTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468251.html).
   * *   If an IPsec-VPN connection is not associated with a resource, you can call `DeleteVpnAttachment` to directly delete the IPsec-VPN connection.
   * 
   * @param request - DeleteVpnAttachmentRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteVpnAttachmentResponse
   */
  async deleteVpnAttachmentWithOptions(request: $_model.DeleteVpnAttachmentRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteVpnAttachmentResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpnConnectionId)) {
      query["VpnConnectionId"] = request.vpnConnectionId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteVpnAttachment",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteVpnAttachmentResponse>(await this.callApi(params, req, runtime), new $_model.DeleteVpnAttachmentResponse({}));
  }

  /**
   * Deletes an IPsec-VPN connection.
   * 
   * @remarks
   *   If an IPsec-VPN connection is associated with a transit router, you must disassociate the transit router from the IPsec-VPN connection before you delete the IPsec-VPN connection. For more information, see [DeleteTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468251.html).
   * *   If an IPsec-VPN connection is not associated with a resource, you can call `DeleteVpnAttachment` to directly delete the IPsec-VPN connection.
   * 
   * @param request - DeleteVpnAttachmentRequest
   * @returns DeleteVpnAttachmentResponse
   */
  async deleteVpnAttachment(request: $_model.DeleteVpnAttachmentRequest): Promise<$_model.DeleteVpnAttachmentResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteVpnAttachmentWithOptions(request, runtime);
  }

  /**
   * Deletes an IPsec-VPN connection.
   * 
   * @remarks
   *   **DeleteVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
   *     *   If a VPN gateway is in the **updating** state, the IPsec-VPN connection is being deleted.
   *     *   If a VPN gateway is in the **active** state, the IPsec-VPN connection has been deleted.
   * *   You cannot call the **DeleteVpnConnection** operation to delete multiple IPsec-VPN connections for a VPN gateway at a time.
   * >  After an IPsec-VPN connection between a data center and Alibaba Cloud is deleted, the connection between the data center and Alibaba Cloud is closed.
   * 
   * @param request - DeleteVpnConnectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteVpnConnectionResponse
   */
  async deleteVpnConnectionWithOptions(request: $_model.DeleteVpnConnectionRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteVpnConnectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpnConnectionId)) {
      query["VpnConnectionId"] = request.vpnConnectionId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteVpnConnection",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteVpnConnectionResponse>(await this.callApi(params, req, runtime), new $_model.DeleteVpnConnectionResponse({}));
  }

  /**
   * Deletes an IPsec-VPN connection.
   * 
   * @remarks
   *   **DeleteVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
   *     *   If a VPN gateway is in the **updating** state, the IPsec-VPN connection is being deleted.
   *     *   If a VPN gateway is in the **active** state, the IPsec-VPN connection has been deleted.
   * *   You cannot call the **DeleteVpnConnection** operation to delete multiple IPsec-VPN connections for a VPN gateway at a time.
   * >  After an IPsec-VPN connection between a data center and Alibaba Cloud is deleted, the connection between the data center and Alibaba Cloud is closed.
   * 
   * @param request - DeleteVpnConnectionRequest
   * @returns DeleteVpnConnectionResponse
   */
  async deleteVpnConnection(request: $_model.DeleteVpnConnectionRequest): Promise<$_model.DeleteVpnConnectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteVpnConnectionWithOptions(request, runtime);
  }

  /**
   * Deletes a VPN gateway.
   * 
   * @remarks
   * >  You cannot delete a VPN gateway associated with existing IPsec-VPN connections.
   * 
   * @param request - DeleteVpnGatewayRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteVpnGatewayResponse
   */
  async deleteVpnGatewayWithOptions(request: $_model.DeleteVpnGatewayRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteVpnGatewayResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteVpnGateway",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteVpnGatewayResponse>(await this.callApi(params, req, runtime), new $_model.DeleteVpnGatewayResponse({}));
  }

  /**
   * Deletes a VPN gateway.
   * 
   * @remarks
   * >  You cannot delete a VPN gateway associated with existing IPsec-VPN connections.
   * 
   * @param request - DeleteVpnGatewayRequest
   * @returns DeleteVpnGatewayResponse
   */
  async deleteVpnGateway(request: $_model.DeleteVpnGatewayRequest): Promise<$_model.DeleteVpnGatewayResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteVpnGatewayWithOptions(request, runtime);
  }

  /**
   * Deletes a policy-based route from a VPN gateway.
   * 
   * @remarks
   *   **DeleteVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
   *     *   If a VPN gateway is in the **updating** state, the policy-based route is being deleted.
   *     *   If a VPN gateway is in the **active** state, the policy-based route has been deleted.
   * *   You cannot repeatedly call **DeleteVpnPbrRouteEntry** to delete a policy-based route within the specified period of time.
   * 
   * @param request - DeleteVpnPbrRouteEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteVpnPbrRouteEntryResponse
   */
  async deleteVpnPbrRouteEntryWithOptions(request: $_model.DeleteVpnPbrRouteEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteVpnPbrRouteEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.nextHop)) {
      query["NextHop"] = request.nextHop;
    }

    if (!$dara.isNull(request.overlayMode)) {
      query["OverlayMode"] = request.overlayMode;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.priority)) {
      query["Priority"] = request.priority;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeDest)) {
      query["RouteDest"] = request.routeDest;
    }

    if (!$dara.isNull(request.routeSource)) {
      query["RouteSource"] = request.routeSource;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    if (!$dara.isNull(request.weight)) {
      query["Weight"] = request.weight;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteVpnPbrRouteEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteVpnPbrRouteEntryResponse>(await this.callApi(params, req, runtime), new $_model.DeleteVpnPbrRouteEntryResponse({}));
  }

  /**
   * Deletes a policy-based route from a VPN gateway.
   * 
   * @remarks
   *   **DeleteVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
   *     *   If a VPN gateway is in the **updating** state, the policy-based route is being deleted.
   *     *   If a VPN gateway is in the **active** state, the policy-based route has been deleted.
   * *   You cannot repeatedly call **DeleteVpnPbrRouteEntry** to delete a policy-based route within the specified period of time.
   * 
   * @param request - DeleteVpnPbrRouteEntryRequest
   * @returns DeleteVpnPbrRouteEntryResponse
   */
  async deleteVpnPbrRouteEntry(request: $_model.DeleteVpnPbrRouteEntryRequest): Promise<$_model.DeleteVpnPbrRouteEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteVpnPbrRouteEntryWithOptions(request, runtime);
  }

  /**
   * Deletes a destination-based route from a VPN gateway.
   * 
   * @remarks
   *   **DeleteVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
   *     *   If a VPN gateway is in the **updating** state, the destination-based route is being deleted.
   *     *   If the VPN gateway is in the **active** state, the destination-based route is deleted.
   * *   You cannot repeatedly call **DeleteVpnRouteEntry** to delete a destination-based route from a VPN gateway within the specified period of time.
   * 
   * @param request - DeleteVpnRouteEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteVpnRouteEntryResponse
   */
  async deleteVpnRouteEntryWithOptions(request: $_model.DeleteVpnRouteEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeleteVpnRouteEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.nextHop)) {
      query["NextHop"] = request.nextHop;
    }

    if (!$dara.isNull(request.overlayMode)) {
      query["OverlayMode"] = request.overlayMode;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeDest)) {
      query["RouteDest"] = request.routeDest;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    if (!$dara.isNull(request.weight)) {
      query["Weight"] = request.weight;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteVpnRouteEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeleteVpnRouteEntryResponse>(await this.callApi(params, req, runtime), new $_model.DeleteVpnRouteEntryResponse({}));
  }

  /**
   * Deletes a destination-based route from a VPN gateway.
   * 
   * @remarks
   *   **DeleteVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
   *     *   If a VPN gateway is in the **updating** state, the destination-based route is being deleted.
   *     *   If the VPN gateway is in the **active** state, the destination-based route is deleted.
   * *   You cannot repeatedly call **DeleteVpnRouteEntry** to delete a destination-based route from a VPN gateway within the specified period of time.
   * 
   * @param request - DeleteVpnRouteEntryRequest
   * @returns DeleteVpnRouteEntryResponse
   */
  async deleteVpnRouteEntry(request: $_model.DeleteVpnRouteEntryRequest): Promise<$_model.DeleteVpnRouteEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteVpnRouteEntryWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @remarks
   * After you enable deletion protection for an instance, you cannot delete the instance. You must disable deletion protection before you can delete the instance.
   * 
   * @param request - DeletionProtectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeletionProtectionResponse
   */
  async deletionProtectionWithOptions(request: $_model.DeletionProtectionRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DeletionProtectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.protectionEnable)) {
      query["ProtectionEnable"] = request.protectionEnable;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeletionProtection",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DeletionProtectionResponse>(await this.callApi(params, req, runtime), new $_model.DeletionProtectionResponse({}));
  }

  /**
   * 
   * 
   * @remarks
   * After you enable deletion protection for an instance, you cannot delete the instance. You must disable deletion protection before you can delete the instance.
   * 
   * @param request - DeletionProtectionRequest
   * @returns DeletionProtectionResponse
   */
  async deletionProtection(request: $_model.DeletionProtectionRequest): Promise<$_model.DeletionProtectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deletionProtectionWithOptions(request, runtime);
  }

  /**
   * Queries traffic data of a pay-by-enhanced-95th-percentile Internet Shared Bandwidth instance.
   * 
   * @param request - Describe95TrafficRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns Describe95TrafficResponse
   */
  async describe95TrafficWithOptions(request: $_model.Describe95TrafficRequest, runtime: $dara.RuntimeOptions): Promise<$_model.Describe95TrafficResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.day)) {
      query["Day"] = request.day;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "Describe95Traffic",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.Describe95TrafficResponse>(await this.callApi(params, req, runtime), new $_model.Describe95TrafficResponse({}));
  }

  /**
   * Queries traffic data of a pay-by-enhanced-95th-percentile Internet Shared Bandwidth instance.
   * 
   * @param request - Describe95TrafficRequest
   * @returns Describe95TrafficResponse
   */
  async describe95Traffic(request: $_model.Describe95TrafficRequest): Promise<$_model.Describe95TrafficResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describe95TrafficWithOptions(request, runtime);
  }

  /**
   * Queries the access points of Express Connect circuits in a region.
   * 
   * @param request - DescribeAccessPointsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAccessPointsResponse
   */
  async describeAccessPointsWithOptions(request: $_model.DescribeAccessPointsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeAccessPointsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeAccessPoints",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeAccessPointsResponse>(await this.callApi(params, req, runtime), new $_model.DescribeAccessPointsResponse({}));
  }

  /**
   * Queries the access points of Express Connect circuits in a region.
   * 
   * @param request - DescribeAccessPointsRequest
   * @returns DescribeAccessPointsResponse
   */
  async describeAccessPoints(request: $_model.DescribeAccessPointsRequest): Promise<$_model.DescribeAccessPointsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeAccessPointsWithOptions(request, runtime);
  }

  /**
   * Queries Border Gateway Protocol (BGP) groups in a region.
   * 
   * @param request - DescribeBgpGroupsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeBgpGroupsResponse
   */
  async describeBgpGroupsWithOptions(request: $_model.DescribeBgpGroupsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeBgpGroupsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bgpGroupId)) {
      query["BgpGroupId"] = request.bgpGroupId;
    }

    if (!$dara.isNull(request.isDefault)) {
      query["IsDefault"] = request.isDefault;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routerId)) {
      query["RouterId"] = request.routerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeBgpGroups",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeBgpGroupsResponse>(await this.callApi(params, req, runtime), new $_model.DescribeBgpGroupsResponse({}));
  }

  /**
   * Queries Border Gateway Protocol (BGP) groups in a region.
   * 
   * @param request - DescribeBgpGroupsRequest
   * @returns DescribeBgpGroupsResponse
   */
  async describeBgpGroups(request: $_model.DescribeBgpGroupsRequest): Promise<$_model.DescribeBgpGroupsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeBgpGroupsWithOptions(request, runtime);
  }

  /**
   * Queries advertised Border Gateway Protocol (BGP) networks.
   * 
   * @param request - DescribeBgpNetworksRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeBgpNetworksResponse
   */
  async describeBgpNetworksWithOptions(request: $_model.DescribeBgpNetworksRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeBgpNetworksResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routerId)) {
      query["RouterId"] = request.routerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeBgpNetworks",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeBgpNetworksResponse>(await this.callApi(params, req, runtime), new $_model.DescribeBgpNetworksResponse({}));
  }

  /**
   * Queries advertised Border Gateway Protocol (BGP) networks.
   * 
   * @param request - DescribeBgpNetworksRequest
   * @returns DescribeBgpNetworksResponse
   */
  async describeBgpNetworks(request: $_model.DescribeBgpNetworksRequest): Promise<$_model.DescribeBgpNetworksResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeBgpNetworksWithOptions(request, runtime);
  }

  /**
   * Queries Border Gateway Protocol (BGP) peers in a region.
   * 
   * @param request - DescribeBgpPeersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeBgpPeersResponse
   */
  async describeBgpPeersWithOptions(request: $_model.DescribeBgpPeersRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeBgpPeersResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bgpGroupId)) {
      query["BgpGroupId"] = request.bgpGroupId;
    }

    if (!$dara.isNull(request.bgpPeerId)) {
      query["BgpPeerId"] = request.bgpPeerId;
    }

    if (!$dara.isNull(request.isDefault)) {
      query["IsDefault"] = request.isDefault;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routerId)) {
      query["RouterId"] = request.routerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeBgpPeers",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeBgpPeersResponse>(await this.callApi(params, req, runtime), new $_model.DescribeBgpPeersResponse({}));
  }

  /**
   * Queries Border Gateway Protocol (BGP) peers in a region.
   * 
   * @param request - DescribeBgpPeersRequest
   * @returns DescribeBgpPeersResponse
   */
  async describeBgpPeers(request: $_model.DescribeBgpPeersRequest): Promise<$_model.DescribeBgpPeersResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeBgpPeersWithOptions(request, runtime);
  }

  /**
   * Queries a list of Internet Shared Bandwidth instances in a region.
   * 
   * @param request - DescribeCommonBandwidthPackagesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCommonBandwidthPackagesResponse
   */
  async describeCommonBandwidthPackagesWithOptions(request: $_model.DescribeCommonBandwidthPackagesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeCommonBandwidthPackagesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidthPackageId)) {
      query["BandwidthPackageId"] = request.bandwidthPackageId;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.includeReservationData)) {
      query["IncludeReservationData"] = request.includeReservationData;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.securityProtectionEnabled)) {
      query["SecurityProtectionEnabled"] = request.securityProtectionEnabled;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeCommonBandwidthPackages",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeCommonBandwidthPackagesResponse>(await this.callApi(params, req, runtime), new $_model.DescribeCommonBandwidthPackagesResponse({}));
  }

  /**
   * Queries a list of Internet Shared Bandwidth instances in a region.
   * 
   * @param request - DescribeCommonBandwidthPackagesRequest
   * @returns DescribeCommonBandwidthPackagesResponse
   */
  async describeCommonBandwidthPackages(request: $_model.DescribeCommonBandwidthPackagesRequest): Promise<$_model.DescribeCommonBandwidthPackagesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeCommonBandwidthPackagesWithOptions(request, runtime);
  }

  /**
   * Queries details of a customer gateway.
   * 
   * @param request - DescribeCustomerGatewayRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCustomerGatewayResponse
   */
  async describeCustomerGatewayWithOptions(request: $_model.DescribeCustomerGatewayRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeCustomerGatewayResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.customerGatewayId)) {
      query["CustomerGatewayId"] = request.customerGatewayId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeCustomerGateway",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeCustomerGatewayResponse>(await this.callApi(params, req, runtime), new $_model.DescribeCustomerGatewayResponse({}));
  }

  /**
   * Queries details of a customer gateway.
   * 
   * @param request - DescribeCustomerGatewayRequest
   * @returns DescribeCustomerGatewayResponse
   */
  async describeCustomerGateway(request: $_model.DescribeCustomerGatewayRequest): Promise<$_model.DescribeCustomerGatewayResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeCustomerGatewayWithOptions(request, runtime);
  }

  /**
   * Queries customer gateways.
   * 
   * @param request - DescribeCustomerGatewaysRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCustomerGatewaysResponse
   */
  async describeCustomerGatewaysWithOptions(request: $_model.DescribeCustomerGatewaysRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeCustomerGatewaysResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.customerGatewayId)) {
      query["CustomerGatewayId"] = request.customerGatewayId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeCustomerGateways",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeCustomerGatewaysResponse>(await this.callApi(params, req, runtime), new $_model.DescribeCustomerGatewaysResponse({}));
  }

  /**
   * Queries customer gateways.
   * 
   * @param request - DescribeCustomerGatewaysRequest
   * @returns DescribeCustomerGatewaysResponse
   */
  async describeCustomerGateways(request: $_model.DescribeCustomerGatewaysRequest): Promise<$_model.DescribeCustomerGatewaysResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeCustomerGatewaysWithOptions(request, runtime);
  }

  /**
   * Queries whether permissions on a virtual private cloud (VPC) are granted to a virtual border router (VBR).
   * 
   * @param request - DescribeEcGrantRelationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeEcGrantRelationResponse
   */
  async describeEcGrantRelationWithOptions(request: $_model.DescribeEcGrantRelationRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeEcGrantRelationResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.vbrRegionNo)) {
      query["VbrRegionNo"] = request.vbrRegionNo;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeEcGrantRelation",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeEcGrantRelationResponse>(await this.callApi(params, req, runtime), new $_model.DescribeEcGrantRelationResponse({}));
  }

  /**
   * Queries whether permissions on a virtual private cloud (VPC) are granted to a virtual border router (VBR).
   * 
   * @param request - DescribeEcGrantRelationRequest
   * @returns DescribeEcGrantRelationResponse
   */
  async describeEcGrantRelation(request: $_model.DescribeEcGrantRelationRequest): Promise<$_model.DescribeEcGrantRelationResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeEcGrantRelationWithOptions(request, runtime);
  }

  /**
   * Queries elastic IP addresses (EIPs) created in a region.
   * 
   * @remarks
   * You can call this operation to query information about EIPs in a region, including maximum bandwidth, billing methods, and associated instances.
   * 
   * @param request - DescribeEipAddressesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeEipAddressesResponse
   */
  async describeEipAddressesWithOptions(request: $_model.DescribeEipAddressesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeEipAddressesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.allocationId)) {
      query["AllocationId"] = request.allocationId;
    }

    if (!$dara.isNull(request.associatedInstanceId)) {
      query["AssociatedInstanceId"] = request.associatedInstanceId;
    }

    if (!$dara.isNull(request.associatedInstanceType)) {
      query["AssociatedInstanceType"] = request.associatedInstanceType;
    }

    if (!$dara.isNull(request.chargeType)) {
      query["ChargeType"] = request.chargeType;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.eipAddress)) {
      query["EipAddress"] = request.eipAddress;
    }

    if (!$dara.isNull(request.eipName)) {
      query["EipName"] = request.eipName;
    }

    if (!$dara.isNull(request.ISP)) {
      query["ISP"] = request.ISP;
    }

    if (!$dara.isNull(request.includeReservationData)) {
      query["IncludeReservationData"] = request.includeReservationData;
    }

    if (!$dara.isNull(request.lockReason)) {
      query["LockReason"] = request.lockReason;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.publicIpAddressPoolId)) {
      query["PublicIpAddressPoolId"] = request.publicIpAddressPoolId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.securityProtectionEnabled)) {
      query["SecurityProtectionEnabled"] = request.securityProtectionEnabled;
    }

    if (!$dara.isNull(request.segmentInstanceId)) {
      query["SegmentInstanceId"] = request.segmentInstanceId;
    }

    if (!$dara.isNull(request.serviceManaged)) {
      query["ServiceManaged"] = request.serviceManaged;
    }

    if (!$dara.isNull(request.status)) {
      query["Status"] = request.status;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.filter)) {
      query["Filter"] = request.filter;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeEipAddresses",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeEipAddressesResponse>(await this.callApi(params, req, runtime), new $_model.DescribeEipAddressesResponse({}));
  }

  /**
   * Queries elastic IP addresses (EIPs) created in a region.
   * 
   * @remarks
   * You can call this operation to query information about EIPs in a region, including maximum bandwidth, billing methods, and associated instances.
   * 
   * @param request - DescribeEipAddressesRequest
   * @returns DescribeEipAddressesResponse
   */
  async describeEipAddresses(request: $_model.DescribeEipAddressesRequest): Promise<$_model.DescribeEipAddressesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeEipAddressesWithOptions(request, runtime);
  }

  /**
   * Queries the gateway and subnet mask of an elastic IP address (EIP).
   * 
   * @remarks
   * You can query only EIPs that are associated with secondary elastic network interfaces (ENIs) in multi-EIP-to-ENI mode.
   * 
   * @param request - DescribeEipGatewayInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeEipGatewayInfoResponse
   */
  async describeEipGatewayInfoWithOptions(request: $_model.DescribeEipGatewayInfoRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeEipGatewayInfoResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeEipGatewayInfo",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeEipGatewayInfoResponse>(await this.callApi(params, req, runtime), new $_model.DescribeEipGatewayInfoResponse({}));
  }

  /**
   * Queries the gateway and subnet mask of an elastic IP address (EIP).
   * 
   * @remarks
   * You can query only EIPs that are associated with secondary elastic network interfaces (ENIs) in multi-EIP-to-ENI mode.
   * 
   * @param request - DescribeEipGatewayInfoRequest
   * @returns DescribeEipGatewayInfoResponse
   */
  async describeEipGatewayInfo(request: $_model.DescribeEipGatewayInfoRequest): Promise<$_model.DescribeEipGatewayInfoResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeEipGatewayInfoWithOptions(request, runtime);
  }

  /**
   * Queries the monitoring data of an elastic IP address (EIP). You can query monitoring data within the last 30 days, and obtain up to 400 data points in each request.
   * 
   * @remarks
   * To improve user experience in querying monitoring data, we recommend that you call the DescribeMetricList API operation provided by CloudMonitor to query EIP monitoring data. For more information, see [DescribeMetricList](https://help.aliyun.com/document_detail/51936.html) and [EIP monitoring data](https://help.aliyun.com/document_detail/162874.html).
   * 
   * @param request - DescribeEipMonitorDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeEipMonitorDataResponse
   */
  async describeEipMonitorDataWithOptions(request: $_model.DescribeEipMonitorDataRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeEipMonitorDataResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.allocationId)) {
      query["AllocationId"] = request.allocationId;
    }

    if (!$dara.isNull(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.period)) {
      query["Period"] = request.period;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeEipMonitorData",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeEipMonitorDataResponse>(await this.callApi(params, req, runtime), new $_model.DescribeEipMonitorDataResponse({}));
  }

  /**
   * Queries the monitoring data of an elastic IP address (EIP). You can query monitoring data within the last 30 days, and obtain up to 400 data points in each request.
   * 
   * @remarks
   * To improve user experience in querying monitoring data, we recommend that you call the DescribeMetricList API operation provided by CloudMonitor to query EIP monitoring data. For more information, see [DescribeMetricList](https://help.aliyun.com/document_detail/51936.html) and [EIP monitoring data](https://help.aliyun.com/document_detail/162874.html).
   * 
   * @param request - DescribeEipMonitorDataRequest
   * @returns DescribeEipMonitorDataResponse
   */
  async describeEipMonitorData(request: $_model.DescribeEipMonitorDataRequest): Promise<$_model.DescribeEipMonitorDataResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeEipMonitorDataWithOptions(request, runtime);
  }

  /**
   * Queries contiguous elastic IP address (EIP) groups.
   * 
   * @param request - DescribeEipSegmentRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeEipSegmentResponse
   */
  async describeEipSegmentWithOptions(request: $_model.DescribeEipSegmentRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeEipSegmentResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.segmentInstanceId)) {
      query["SegmentInstanceId"] = request.segmentInstanceId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeEipSegment",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeEipSegmentResponse>(await this.callApi(params, req, runtime), new $_model.DescribeEipSegmentResponse({}));
  }

  /**
   * Queries contiguous elastic IP address (EIP) groups.
   * 
   * @param request - DescribeEipSegmentRequest
   * @returns DescribeEipSegmentResponse
   */
  async describeEipSegment(request: $_model.DescribeEipSegmentRequest): Promise<$_model.DescribeEipSegmentResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeEipSegmentWithOptions(request, runtime);
  }

  /**
   * Queries the quality of service (QoS) policies of Express Connect. The response can be displayed by page.
   * 
   * @param request - DescribeExpressConnectTrafficQosRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeExpressConnectTrafficQosResponse
   */
  async describeExpressConnectTrafficQosWithOptions(request: $_model.DescribeExpressConnectTrafficQosRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeExpressConnectTrafficQosResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.qosIdList)) {
      query["QosIdList"] = request.qosIdList;
    }

    if (!$dara.isNull(request.qosNameList)) {
      query["QosNameList"] = request.qosNameList;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeExpressConnectTrafficQos",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeExpressConnectTrafficQosResponse>(await this.callApi(params, req, runtime), new $_model.DescribeExpressConnectTrafficQosResponse({}));
  }

  /**
   * Queries the quality of service (QoS) policies of Express Connect. The response can be displayed by page.
   * 
   * @param request - DescribeExpressConnectTrafficQosRequest
   * @returns DescribeExpressConnectTrafficQosResponse
   */
  async describeExpressConnectTrafficQos(request: $_model.DescribeExpressConnectTrafficQosRequest): Promise<$_model.DescribeExpressConnectTrafficQosResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeExpressConnectTrafficQosWithOptions(request, runtime);
  }

  /**
   * Queries the information about the quality of service (QoS) queues of the Express Connect circuit.
   * 
   * @param request - DescribeExpressConnectTrafficQosQueueRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeExpressConnectTrafficQosQueueResponse
   */
  async describeExpressConnectTrafficQosQueueWithOptions(request: $_model.DescribeExpressConnectTrafficQosQueueRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeExpressConnectTrafficQosQueueResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.qosId)) {
      query["QosId"] = request.qosId;
    }

    if (!$dara.isNull(request.queueIdList)) {
      query["QueueIdList"] = request.queueIdList;
    }

    if (!$dara.isNull(request.queueNameList)) {
      query["QueueNameList"] = request.queueNameList;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeExpressConnectTrafficQosQueue",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeExpressConnectTrafficQosQueueResponse>(await this.callApi(params, req, runtime), new $_model.DescribeExpressConnectTrafficQosQueueResponse({}));
  }

  /**
   * Queries the information about the quality of service (QoS) queues of the Express Connect circuit.
   * 
   * @param request - DescribeExpressConnectTrafficQosQueueRequest
   * @returns DescribeExpressConnectTrafficQosQueueResponse
   */
  async describeExpressConnectTrafficQosQueue(request: $_model.DescribeExpressConnectTrafficQosQueueRequest): Promise<$_model.DescribeExpressConnectTrafficQosQueueResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeExpressConnectTrafficQosQueueWithOptions(request, runtime);
  }

  /**
   * Queries quality of service (QoS) rules. Paging parameters are not supported.
   * 
   * @param request - DescribeExpressConnectTrafficQosRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeExpressConnectTrafficQosRuleResponse
   */
  async describeExpressConnectTrafficQosRuleWithOptions(request: $_model.DescribeExpressConnectTrafficQosRuleRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeExpressConnectTrafficQosRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.qosId)) {
      query["QosId"] = request.qosId;
    }

    if (!$dara.isNull(request.queueId)) {
      query["QueueId"] = request.queueId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.ruleIdList)) {
      query["RuleIdList"] = request.ruleIdList;
    }

    if (!$dara.isNull(request.ruleNameList)) {
      query["RuleNameList"] = request.ruleNameList;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeExpressConnectTrafficQosRule",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeExpressConnectTrafficQosRuleResponse>(await this.callApi(params, req, runtime), new $_model.DescribeExpressConnectTrafficQosRuleResponse({}));
  }

  /**
   * Queries quality of service (QoS) rules. Paging parameters are not supported.
   * 
   * @param request - DescribeExpressConnectTrafficQosRuleRequest
   * @returns DescribeExpressConnectTrafficQosRuleResponse
   */
  async describeExpressConnectTrafficQosRule(request: $_model.DescribeExpressConnectTrafficQosRuleRequest): Promise<$_model.DescribeExpressConnectTrafficQosRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeExpressConnectTrafficQosRuleWithOptions(request, runtime);
  }

  /**
   * Queries failover tests.
   * 
   * @param request - DescribeFailoverTestJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeFailoverTestJobResponse
   */
  async describeFailoverTestJobWithOptions(request: $_model.DescribeFailoverTestJobRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeFailoverTestJobResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeFailoverTestJob",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeFailoverTestJobResponse>(await this.callApi(params, req, runtime), new $_model.DescribeFailoverTestJobResponse({}));
  }

  /**
   * Queries failover tests.
   * 
   * @param request - DescribeFailoverTestJobRequest
   * @returns DescribeFailoverTestJobResponse
   */
  async describeFailoverTestJob(request: $_model.DescribeFailoverTestJobRequest): Promise<$_model.DescribeFailoverTestJobResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeFailoverTestJobWithOptions(request, runtime);
  }

  /**
   * Queries failover tests for Express Connect.
   * 
   * @param request - DescribeFailoverTestJobsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeFailoverTestJobsResponse
   */
  async describeFailoverTestJobsWithOptions(request: $_model.DescribeFailoverTestJobsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeFailoverTestJobsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.filter)) {
      query["Filter"] = request.filter;
    }

    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeFailoverTestJobs",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeFailoverTestJobsResponse>(await this.callApi(params, req, runtime), new $_model.DescribeFailoverTestJobsResponse({}));
  }

  /**
   * Queries failover tests for Express Connect.
   * 
   * @param request - DescribeFailoverTestJobsRequest
   * @returns DescribeFailoverTestJobsResponse
   */
  async describeFailoverTestJobs(request: $_model.DescribeFailoverTestJobsRequest): Promise<$_model.DescribeFailoverTestJobsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeFailoverTestJobsWithOptions(request, runtime);
  }

  /**
   * Queries the information about flow logs.
   * 
   * @param request - DescribeFlowLogsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeFlowLogsResponse
   */
  async describeFlowLogsWithOptions(request: $_model.DescribeFlowLogsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeFlowLogsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.flowLogId)) {
      query["FlowLogId"] = request.flowLogId;
    }

    if (!$dara.isNull(request.flowLogName)) {
      query["FlowLogName"] = request.flowLogName;
    }

    if (!$dara.isNull(request.logStoreName)) {
      query["LogStoreName"] = request.logStoreName;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.projectName)) {
      query["ProjectName"] = request.projectName;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!$dara.isNull(request.status)) {
      query["Status"] = request.status;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    if (!$dara.isNull(request.trafficType)) {
      query["TrafficType"] = request.trafficType;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeFlowLogs",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeFlowLogsResponse>(await this.callApi(params, req, runtime), new $_model.DescribeFlowLogsResponse({}));
  }

  /**
   * Queries the information about flow logs.
   * 
   * @param request - DescribeFlowLogsRequest
   * @returns DescribeFlowLogsResponse
   */
  async describeFlowLogs(request: $_model.DescribeFlowLogsRequest): Promise<$_model.DescribeFlowLogsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeFlowLogsWithOptions(request, runtime);
  }

  /**
   * Queries DNAT entries.
   * 
   * @param request - DescribeForwardTableEntriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeForwardTableEntriesResponse
   */
  async describeForwardTableEntriesWithOptions(request: $_model.DescribeForwardTableEntriesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeForwardTableEntriesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.externalIp)) {
      query["ExternalIp"] = request.externalIp;
    }

    if (!$dara.isNull(request.externalPort)) {
      query["ExternalPort"] = request.externalPort;
    }

    if (!$dara.isNull(request.forwardEntryId)) {
      query["ForwardEntryId"] = request.forwardEntryId;
    }

    if (!$dara.isNull(request.forwardEntryName)) {
      query["ForwardEntryName"] = request.forwardEntryName;
    }

    if (!$dara.isNull(request.forwardTableId)) {
      query["ForwardTableId"] = request.forwardTableId;
    }

    if (!$dara.isNull(request.internalIp)) {
      query["InternalIp"] = request.internalIp;
    }

    if (!$dara.isNull(request.internalPort)) {
      query["InternalPort"] = request.internalPort;
    }

    if (!$dara.isNull(request.ipProtocol)) {
      query["IpProtocol"] = request.ipProtocol;
    }

    if (!$dara.isNull(request.natGatewayId)) {
      query["NatGatewayId"] = request.natGatewayId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeForwardTableEntries",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeForwardTableEntriesResponse>(await this.callApi(params, req, runtime), new $_model.DescribeForwardTableEntriesResponse({}));
  }

  /**
   * Queries DNAT entries.
   * 
   * @param request - DescribeForwardTableEntriesRequest
   * @returns DescribeForwardTableEntriesResponse
   */
  async describeForwardTableEntries(request: $_model.DescribeForwardTableEntriesRequest): Promise<$_model.DescribeForwardTableEntriesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeForwardTableEntriesWithOptions(request, runtime);
  }

  /**
   * Queries Global Accelerator (GA) instances.
   * 
   * @param request - DescribeGlobalAccelerationInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGlobalAccelerationInstancesResponse
   */
  async describeGlobalAccelerationInstancesWithOptions(request: $_model.DescribeGlobalAccelerationInstancesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeGlobalAccelerationInstancesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidthType)) {
      query["BandwidthType"] = request.bandwidthType;
    }

    if (!$dara.isNull(request.globalAccelerationInstanceId)) {
      query["GlobalAccelerationInstanceId"] = request.globalAccelerationInstanceId;
    }

    if (!$dara.isNull(request.includeReservationData)) {
      query["IncludeReservationData"] = request.includeReservationData;
    }

    if (!$dara.isNull(request.ipAddress)) {
      query["IpAddress"] = request.ipAddress;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.serverId)) {
      query["ServerId"] = request.serverId;
    }

    if (!$dara.isNull(request.serviceLocation)) {
      query["ServiceLocation"] = request.serviceLocation;
    }

    if (!$dara.isNull(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeGlobalAccelerationInstances",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeGlobalAccelerationInstancesResponse>(await this.callApi(params, req, runtime), new $_model.DescribeGlobalAccelerationInstancesResponse({}));
  }

  /**
   * Queries Global Accelerator (GA) instances.
   * 
   * @param request - DescribeGlobalAccelerationInstancesRequest
   * @returns DescribeGlobalAccelerationInstancesResponse
   */
  async describeGlobalAccelerationInstances(request: $_model.DescribeGlobalAccelerationInstancesRequest): Promise<$_model.DescribeGlobalAccelerationInstancesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeGlobalAccelerationInstancesWithOptions(request, runtime);
  }

  /**
   * VPCVBR
   * 
   * @param request - DescribeGrantRulesToCenRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGrantRulesToCenResponse
   */
  async describeGrantRulesToCenWithOptions(request: $_model.DescribeGrantRulesToCenRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeGrantRulesToCenResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeGrantRulesToCen",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeGrantRulesToCenResponse>(await this.callApi(params, req, runtime), new $_model.DescribeGrantRulesToCenResponse({}));
  }

  /**
   * VPCVBR
   * 
   * @param request - DescribeGrantRulesToCenRequest
   * @returns DescribeGrantRulesToCenResponse
   */
  async describeGrantRulesToCen(request: $_model.DescribeGrantRulesToCenRequest): Promise<$_model.DescribeGrantRulesToCenResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeGrantRulesToCenWithOptions(request, runtime);
  }

  /**
   * Queries HaVips in a region.
   * 
   * @param request - DescribeHaVipsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeHaVipsResponse
   */
  async describeHaVipsWithOptions(request: $_model.DescribeHaVipsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeHaVipsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.filter)) {
      query["Filter"] = request.filter;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeHaVips",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeHaVipsResponse>(await this.callApi(params, req, runtime), new $_model.DescribeHaVipsResponse({}));
  }

  /**
   * Queries HaVips in a region.
   * 
   * @param request - DescribeHaVipsRequest
   * @returns DescribeHaVipsResponse
   */
  async describeHaVips(request: $_model.DescribeHaVipsRequest): Promise<$_model.DescribeHaVipsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeHaVipsWithOptions(request, runtime);
  }

  /**
   * Queries configurations about the fine-grained monitoring feature of an elastic IP address (EIP).
   * 
   * @param request - DescribeHighDefinitionMonitorLogAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeHighDefinitionMonitorLogAttributeResponse
   */
  async describeHighDefinitionMonitorLogAttributeWithOptions(request: $_model.DescribeHighDefinitionMonitorLogAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeHighDefinitionMonitorLogAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeHighDefinitionMonitorLogAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeHighDefinitionMonitorLogAttributeResponse>(await this.callApi(params, req, runtime), new $_model.DescribeHighDefinitionMonitorLogAttributeResponse({}));
  }

  /**
   * Queries configurations about the fine-grained monitoring feature of an elastic IP address (EIP).
   * 
   * @param request - DescribeHighDefinitionMonitorLogAttributeRequest
   * @returns DescribeHighDefinitionMonitorLogAttributeResponse
   */
  async describeHighDefinitionMonitorLogAttribute(request: $_model.DescribeHighDefinitionMonitorLogAttributeRequest): Promise<$_model.DescribeHighDefinitionMonitorLogAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeHighDefinitionMonitorLogAttributeWithOptions(request, runtime);
  }

  /**
   * Queries the details of an access control list (ACL), including the specified IP addresses and associated IPv6 mapping entries.
   * 
   * @param request - DescribeIPv6TranslatorAclListAttributesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeIPv6TranslatorAclListAttributesResponse
   */
  async describeIPv6TranslatorAclListAttributesWithOptions(request: $_model.DescribeIPv6TranslatorAclListAttributesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeIPv6TranslatorAclListAttributesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.aclId)) {
      query["AclId"] = request.aclId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeIPv6TranslatorAclListAttributes",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeIPv6TranslatorAclListAttributesResponse>(await this.callApi(params, req, runtime), new $_model.DescribeIPv6TranslatorAclListAttributesResponse({}));
  }

  /**
   * Queries the details of an access control list (ACL), including the specified IP addresses and associated IPv6 mapping entries.
   * 
   * @param request - DescribeIPv6TranslatorAclListAttributesRequest
   * @returns DescribeIPv6TranslatorAclListAttributesResponse
   */
  async describeIPv6TranslatorAclListAttributes(request: $_model.DescribeIPv6TranslatorAclListAttributesRequest): Promise<$_model.DescribeIPv6TranslatorAclListAttributesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeIPv6TranslatorAclListAttributesWithOptions(request, runtime);
  }

  /**
   * Queries access control lists (ACLs).
   * 
   * @deprecated OpenAPI DescribeIPv6TranslatorAclLists is deprecated
   * 
   * @param request - DescribeIPv6TranslatorAclListsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeIPv6TranslatorAclListsResponse
   */
  async describeIPv6TranslatorAclListsWithOptions(request: $_model.DescribeIPv6TranslatorAclListsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeIPv6TranslatorAclListsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.aclId)) {
      query["AclId"] = request.aclId;
    }

    if (!$dara.isNull(request.aclName)) {
      query["AclName"] = request.aclName;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeIPv6TranslatorAclLists",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeIPv6TranslatorAclListsResponse>(await this.callApi(params, req, runtime), new $_model.DescribeIPv6TranslatorAclListsResponse({}));
  }

  /**
   * Queries access control lists (ACLs).
   * 
   * @deprecated OpenAPI DescribeIPv6TranslatorAclLists is deprecated
   * 
   * @param request - DescribeIPv6TranslatorAclListsRequest
   * @returns DescribeIPv6TranslatorAclListsResponse
   */
  // Deprecated
  async describeIPv6TranslatorAclLists(request: $_model.DescribeIPv6TranslatorAclListsRequest): Promise<$_model.DescribeIPv6TranslatorAclListsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeIPv6TranslatorAclListsWithOptions(request, runtime);
  }

  /**
   * Queries IPv6 mapping entries.
   * 
   * @deprecated OpenAPI DescribeIPv6TranslatorEntries is deprecated
   * 
   * @param request - DescribeIPv6TranslatorEntriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeIPv6TranslatorEntriesResponse
   */
  async describeIPv6TranslatorEntriesWithOptions(request: $_model.DescribeIPv6TranslatorEntriesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeIPv6TranslatorEntriesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.aclId)) {
      query["AclId"] = request.aclId;
    }

    if (!$dara.isNull(request.aclStatus)) {
      query["AclStatus"] = request.aclStatus;
    }

    if (!$dara.isNull(request.aclType)) {
      query["AclType"] = request.aclType;
    }

    if (!$dara.isNull(request.allocateIpv6Addr)) {
      query["AllocateIpv6Addr"] = request.allocateIpv6Addr;
    }

    if (!$dara.isNull(request.allocateIpv6Port)) {
      query["AllocateIpv6Port"] = request.allocateIpv6Port;
    }

    if (!$dara.isNull(request.backendIpv4Addr)) {
      query["BackendIpv4Addr"] = request.backendIpv4Addr;
    }

    if (!$dara.isNull(request.backendIpv4Port)) {
      query["BackendIpv4Port"] = request.backendIpv4Port;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.entryName)) {
      query["EntryName"] = request.entryName;
    }

    if (!$dara.isNull(request.ipv6TranslatorEntryId)) {
      query["Ipv6TranslatorEntryId"] = request.ipv6TranslatorEntryId;
    }

    if (!$dara.isNull(request.ipv6TranslatorId)) {
      query["Ipv6TranslatorId"] = request.ipv6TranslatorId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.transProtocol)) {
      query["TransProtocol"] = request.transProtocol;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeIPv6TranslatorEntries",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeIPv6TranslatorEntriesResponse>(await this.callApi(params, req, runtime), new $_model.DescribeIPv6TranslatorEntriesResponse({}));
  }

  /**
   * Queries IPv6 mapping entries.
   * 
   * @deprecated OpenAPI DescribeIPv6TranslatorEntries is deprecated
   * 
   * @param request - DescribeIPv6TranslatorEntriesRequest
   * @returns DescribeIPv6TranslatorEntriesResponse
   */
  // Deprecated
  async describeIPv6TranslatorEntries(request: $_model.DescribeIPv6TranslatorEntriesRequest): Promise<$_model.DescribeIPv6TranslatorEntriesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeIPv6TranslatorEntriesWithOptions(request, runtime);
  }

  /**
   * Queries IPv6 Translation Service instances.
   * 
   * @deprecated OpenAPI DescribeIPv6Translators is deprecated
   * 
   * @param request - DescribeIPv6TranslatorsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeIPv6TranslatorsResponse
   */
  async describeIPv6TranslatorsWithOptions(request: $_model.DescribeIPv6TranslatorsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeIPv6TranslatorsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.allocateIpv4Addr)) {
      query["AllocateIpv4Addr"] = request.allocateIpv4Addr;
    }

    if (!$dara.isNull(request.allocateIpv6Addr)) {
      query["AllocateIpv6Addr"] = request.allocateIpv6Addr;
    }

    if (!$dara.isNull(request.businessStatus)) {
      query["BusinessStatus"] = request.businessStatus;
    }

    if (!$dara.isNull(request.ipv6TranslatorId)) {
      query["Ipv6TranslatorId"] = request.ipv6TranslatorId;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.payType)) {
      query["PayType"] = request.payType;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.spec)) {
      query["Spec"] = request.spec;
    }

    if (!$dara.isNull(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeIPv6Translators",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeIPv6TranslatorsResponse>(await this.callApi(params, req, runtime), new $_model.DescribeIPv6TranslatorsResponse({}));
  }

  /**
   * Queries IPv6 Translation Service instances.
   * 
   * @deprecated OpenAPI DescribeIPv6Translators is deprecated
   * 
   * @param request - DescribeIPv6TranslatorsRequest
   * @returns DescribeIPv6TranslatorsResponse
   */
  // Deprecated
  async describeIPv6Translators(request: $_model.DescribeIPv6TranslatorsRequest): Promise<$_model.DescribeIPv6TranslatorsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeIPv6TranslatorsWithOptions(request, runtime);
  }

  /**
   * Queries IPv6 addresses in a region.
   * 
   * @param request - DescribeIpv6AddressesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeIpv6AddressesResponse
   */
  async describeIpv6AddressesWithOptions(request: $_model.DescribeIpv6AddressesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeIpv6AddressesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.addressType)) {
      query["AddressType"] = request.addressType;
    }

    if (!$dara.isNull(request.associatedInstanceId)) {
      query["AssociatedInstanceId"] = request.associatedInstanceId;
    }

    if (!$dara.isNull(request.associatedInstanceType)) {
      query["AssociatedInstanceType"] = request.associatedInstanceType;
    }

    if (!$dara.isNull(request.includeReservationData)) {
      query["IncludeReservationData"] = request.includeReservationData;
    }

    if (!$dara.isNull(request.ipv6Address)) {
      query["Ipv6Address"] = request.ipv6Address;
    }

    if (!$dara.isNull(request.ipv6AddressId)) {
      query["Ipv6AddressId"] = request.ipv6AddressId;
    }

    if (!$dara.isNull(request.ipv6InternetBandwidthId)) {
      query["Ipv6InternetBandwidthId"] = request.ipv6InternetBandwidthId;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.networkType)) {
      query["NetworkType"] = request.networkType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.serviceManaged)) {
      query["ServiceManaged"] = request.serviceManaged;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeIpv6Addresses",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeIpv6AddressesResponse>(await this.callApi(params, req, runtime), new $_model.DescribeIpv6AddressesResponse({}));
  }

  /**
   * Queries IPv6 addresses in a region.
   * 
   * @param request - DescribeIpv6AddressesRequest
   * @returns DescribeIpv6AddressesResponse
   */
  async describeIpv6Addresses(request: $_model.DescribeIpv6AddressesRequest): Promise<$_model.DescribeIpv6AddressesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeIpv6AddressesWithOptions(request, runtime);
  }

  /**
   * Queries egress-only rules.
   * 
   * @param request - DescribeIpv6EgressOnlyRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeIpv6EgressOnlyRulesResponse
   */
  async describeIpv6EgressOnlyRulesWithOptions(request: $_model.DescribeIpv6EgressOnlyRulesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeIpv6EgressOnlyRulesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!$dara.isNull(request.ipv6EgressOnlyRuleId)) {
      query["Ipv6EgressOnlyRuleId"] = request.ipv6EgressOnlyRuleId;
    }

    if (!$dara.isNull(request.ipv6GatewayId)) {
      query["Ipv6GatewayId"] = request.ipv6GatewayId;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeIpv6EgressOnlyRules",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeIpv6EgressOnlyRulesResponse>(await this.callApi(params, req, runtime), new $_model.DescribeIpv6EgressOnlyRulesResponse({}));
  }

  /**
   * Queries egress-only rules.
   * 
   * @param request - DescribeIpv6EgressOnlyRulesRequest
   * @returns DescribeIpv6EgressOnlyRulesResponse
   */
  async describeIpv6EgressOnlyRules(request: $_model.DescribeIpv6EgressOnlyRulesRequest): Promise<$_model.DescribeIpv6EgressOnlyRulesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeIpv6EgressOnlyRulesWithOptions(request, runtime);
  }

  /**
   * Queries the information about an IPv6 gateway, including the region, virtual private cloud (VPC), status, and billing method.
   * 
   * @param request - DescribeIpv6GatewayAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeIpv6GatewayAttributeResponse
   */
  async describeIpv6GatewayAttributeWithOptions(request: $_model.DescribeIpv6GatewayAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeIpv6GatewayAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ipv6GatewayId)) {
      query["Ipv6GatewayId"] = request.ipv6GatewayId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeIpv6GatewayAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeIpv6GatewayAttributeResponse>(await this.callApi(params, req, runtime), new $_model.DescribeIpv6GatewayAttributeResponse({}));
  }

  /**
   * Queries the information about an IPv6 gateway, including the region, virtual private cloud (VPC), status, and billing method.
   * 
   * @param request - DescribeIpv6GatewayAttributeRequest
   * @returns DescribeIpv6GatewayAttributeResponse
   */
  async describeIpv6GatewayAttribute(request: $_model.DescribeIpv6GatewayAttributeRequest): Promise<$_model.DescribeIpv6GatewayAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeIpv6GatewayAttributeWithOptions(request, runtime);
  }

  /**
   * Queries IPv6 gateways in a region.
   * 
   * @param request - DescribeIpv6GatewaysRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeIpv6GatewaysResponse
   */
  async describeIpv6GatewaysWithOptions(request: $_model.DescribeIpv6GatewaysRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeIpv6GatewaysResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ipv6GatewayId)) {
      query["Ipv6GatewayId"] = request.ipv6GatewayId;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeIpv6Gateways",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeIpv6GatewaysResponse>(await this.callApi(params, req, runtime), new $_model.DescribeIpv6GatewaysResponse({}));
  }

  /**
   * Queries IPv6 gateways in a region.
   * 
   * @param request - DescribeIpv6GatewaysRequest
   * @returns DescribeIpv6GatewaysResponse
   */
  async describeIpv6Gateways(request: $_model.DescribeIpv6GatewaysRequest): Promise<$_model.DescribeIpv6GatewaysResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeIpv6GatewaysWithOptions(request, runtime);
  }

  /**
   * NATENI
   * 
   * @param request - DescribeNatGatewayAssociateNetworkInterfacesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeNatGatewayAssociateNetworkInterfacesResponse
   */
  async describeNatGatewayAssociateNetworkInterfacesWithOptions(request: $_model.DescribeNatGatewayAssociateNetworkInterfacesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeNatGatewayAssociateNetworkInterfacesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.filter)) {
      query["Filter"] = request.filter;
    }

    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.natGatewayId)) {
      query["NatGatewayId"] = request.natGatewayId;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeNatGatewayAssociateNetworkInterfaces",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeNatGatewayAssociateNetworkInterfacesResponse>(await this.callApi(params, req, runtime), new $_model.DescribeNatGatewayAssociateNetworkInterfacesResponse({}));
  }

  /**
   * NATENI
   * 
   * @param request - DescribeNatGatewayAssociateNetworkInterfacesRequest
   * @returns DescribeNatGatewayAssociateNetworkInterfacesResponse
   */
  async describeNatGatewayAssociateNetworkInterfaces(request: $_model.DescribeNatGatewayAssociateNetworkInterfacesRequest): Promise<$_model.DescribeNatGatewayAssociateNetworkInterfacesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeNatGatewayAssociateNetworkInterfacesWithOptions(request, runtime);
  }

  /**
   * Queries NAT gateways that meet specific conditions in a specified region.
   * 
   * @remarks
   * You can call this operation to query both Virtual Private Cloud (VPC) NAT gateways and Internet NAT gateways. NAT gateways in this topic refer to both VPC NAT gateways and Internet NAT gateways.
   * 
   * @param request - DescribeNatGatewaysRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeNatGatewaysResponse
   */
  async describeNatGatewaysWithOptions(request: $_model.DescribeNatGatewaysRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeNatGatewaysResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.instanceChargeType)) {
      query["InstanceChargeType"] = request.instanceChargeType;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.natGatewayId)) {
      query["NatGatewayId"] = request.natGatewayId;
    }

    if (!$dara.isNull(request.natType)) {
      query["NatType"] = request.natType;
    }

    if (!$dara.isNull(request.networkType)) {
      query["NetworkType"] = request.networkType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.spec)) {
      query["Spec"] = request.spec;
    }

    if (!$dara.isNull(request.status)) {
      query["Status"] = request.status;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    if (!$dara.isNull(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeNatGateways",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeNatGatewaysResponse>(await this.callApi(params, req, runtime), new $_model.DescribeNatGatewaysResponse({}));
  }

  /**
   * Queries NAT gateways that meet specific conditions in a specified region.
   * 
   * @remarks
   * You can call this operation to query both Virtual Private Cloud (VPC) NAT gateways and Internet NAT gateways. NAT gateways in this topic refer to both VPC NAT gateways and Internet NAT gateways.
   * 
   * @param request - DescribeNatGatewaysRequest
   * @returns DescribeNatGatewaysResponse
   */
  async describeNatGateways(request: $_model.DescribeNatGatewaysRequest): Promise<$_model.DescribeNatGatewaysResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeNatGatewaysWithOptions(request, runtime);
  }

  /**
   * Queries network access control lists (ACLs).
   * 
   * @param request - DescribeNetworkAclAttributesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeNetworkAclAttributesResponse
   */
  async describeNetworkAclAttributesWithOptions(request: $_model.DescribeNetworkAclAttributesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeNetworkAclAttributesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.networkAclId)) {
      query["NetworkAclId"] = request.networkAclId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeNetworkAclAttributes",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeNetworkAclAttributesResponse>(await this.callApi(params, req, runtime), new $_model.DescribeNetworkAclAttributesResponse({}));
  }

  /**
   * Queries network access control lists (ACLs).
   * 
   * @param request - DescribeNetworkAclAttributesRequest
   * @returns DescribeNetworkAclAttributesResponse
   */
  async describeNetworkAclAttributes(request: $_model.DescribeNetworkAclAttributesRequest): Promise<$_model.DescribeNetworkAclAttributesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeNetworkAclAttributesWithOptions(request, runtime);
  }

  /**
   * Queries network ACLs.
   * 
   * @param request - DescribeNetworkAclsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeNetworkAclsResponse
   */
  async describeNetworkAclsWithOptions(request: $_model.DescribeNetworkAclsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeNetworkAclsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.networkAclId)) {
      query["NetworkAclId"] = request.networkAclId;
    }

    if (!$dara.isNull(request.networkAclName)) {
      query["NetworkAclName"] = request.networkAclName;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeNetworkAcls",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeNetworkAclsResponse>(await this.callApi(params, req, runtime), new $_model.DescribeNetworkAclsResponse({}));
  }

  /**
   * Queries network ACLs.
   * 
   * @param request - DescribeNetworkAclsRequest
   * @returns DescribeNetworkAclsResponse
   */
  async describeNetworkAcls(request: $_model.DescribeNetworkAclsRequest): Promise<$_model.DescribeNetworkAclsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeNetworkAclsWithOptions(request, runtime);
  }

  /**
   * LOA
   * 
   * @param request - DescribePhysicalConnectionLOARequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePhysicalConnectionLOAResponse
   */
  async describePhysicalConnectionLOAWithOptions(request: $_model.DescribePhysicalConnectionLOARequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribePhysicalConnectionLOAResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribePhysicalConnectionLOA",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribePhysicalConnectionLOAResponse>(await this.callApi(params, req, runtime), new $_model.DescribePhysicalConnectionLOAResponse({}));
  }

  /**
   * LOA
   * 
   * @param request - DescribePhysicalConnectionLOARequest
   * @returns DescribePhysicalConnectionLOAResponse
   */
  async describePhysicalConnectionLOA(request: $_model.DescribePhysicalConnectionLOARequest): Promise<$_model.DescribePhysicalConnectionLOAResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describePhysicalConnectionLOAWithOptions(request, runtime);
  }

  /**
   * Queries Express Connect circuits in a region.
   * 
   * @remarks
   * By default, the system queries information about all Express Connect circuits in the specified region. You can query Express Connect circuits that meet specific conditions by specifying filter conditions provided by the **DescribePhysicalConnections** operation. For more information about the supported filter conditions, see **Key** in the **Request parameters** section.
   * 
   * @param request - DescribePhysicalConnectionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePhysicalConnectionsResponse
   */
  async describePhysicalConnectionsWithOptions(request: $_model.DescribePhysicalConnectionsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribePhysicalConnectionsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.filter)) {
      query["Filter"] = request.filter;
    }

    if (!$dara.isNull(request.includeReservationData)) {
      query["IncludeReservationData"] = request.includeReservationData;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribePhysicalConnections",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribePhysicalConnectionsResponse>(await this.callApi(params, req, runtime), new $_model.DescribePhysicalConnectionsResponse({}));
  }

  /**
   * Queries Express Connect circuits in a region.
   * 
   * @remarks
   * By default, the system queries information about all Express Connect circuits in the specified region. You can query Express Connect circuits that meet specific conditions by specifying filter conditions provided by the **DescribePhysicalConnections** operation. For more information about the supported filter conditions, see **Key** in the **Request parameters** section.
   * 
   * @param request - DescribePhysicalConnectionsRequest
   * @returns DescribePhysicalConnectionsResponse
   */
  async describePhysicalConnections(request: $_model.DescribePhysicalConnectionsRequest): Promise<$_model.DescribePhysicalConnectionsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describePhysicalConnectionsWithOptions(request, runtime);
  }

  /**
   * Queries the public IP address range of a virtual private cloud (VPC) in a region.
   * 
   * @remarks
   * You cannot query the range of public IP addresses of a classic network by calling the **DescribePublicIpAddress** operation.
   * 
   * @param request - DescribePublicIpAddressRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePublicIpAddressResponse
   */
  async describePublicIpAddressWithOptions(request: $_model.DescribePublicIpAddressRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribePublicIpAddressResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ipVersion)) {
      query["IpVersion"] = request.ipVersion;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribePublicIpAddress",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribePublicIpAddressResponse>(await this.callApi(params, req, runtime), new $_model.DescribePublicIpAddressResponse({}));
  }

  /**
   * Queries the public IP address range of a virtual private cloud (VPC) in a region.
   * 
   * @remarks
   * You cannot query the range of public IP addresses of a classic network by calling the **DescribePublicIpAddress** operation.
   * 
   * @param request - DescribePublicIpAddressRequest
   * @returns DescribePublicIpAddressResponse
   */
  async describePublicIpAddress(request: $_model.DescribePublicIpAddressRequest): Promise<$_model.DescribePublicIpAddressResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describePublicIpAddressWithOptions(request, runtime);
  }

  /**
   * Queries the most recent region list.
   * 
   * @param request - DescribeRegionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRegionsResponse
   */
  async describeRegionsWithOptions(request: $_model.DescribeRegionsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeRegionsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.productType)) {
      query["ProductType"] = request.productType;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeRegions",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeRegionsResponse>(await this.callApi(params, req, runtime), new $_model.DescribeRegionsResponse({}));
  }

  /**
   * Queries the most recent region list.
   * 
   * @param request - DescribeRegionsRequest
   * @returns DescribeRegionsResponse
   */
  async describeRegions(request: $_model.DescribeRegionsRequest): Promise<$_model.DescribeRegionsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeRegionsWithOptions(request, runtime);
  }

  /**
   * Queries information about route entries in a route table.
   * 
   * @remarks
   * Before you call the [DeleteRouteEntry](https://help.aliyun.com/document_detail/36013.html) operation to delete a route, you can call this operation to query the next hop of the route that you want to delete.
   * 
   * @param request - DescribeRouteEntryListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRouteEntryListResponse
   */
  async describeRouteEntryListWithOptions(request: $_model.DescribeRouteEntryListRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeRouteEntryListResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.destCidrBlockList)) {
      query["DestCidrBlockList"] = request.destCidrBlockList;
    }

    if (!$dara.isNull(request.destinationCidrBlock)) {
      query["DestinationCidrBlock"] = request.destinationCidrBlock;
    }

    if (!$dara.isNull(request.ipVersion)) {
      query["IpVersion"] = request.ipVersion;
    }

    if (!$dara.isNull(request.maxResult)) {
      query["MaxResult"] = request.maxResult;
    }

    if (!$dara.isNull(request.nextHopId)) {
      query["NextHopId"] = request.nextHopId;
    }

    if (!$dara.isNull(request.nextHopType)) {
      query["NextHopType"] = request.nextHopType;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeEntryId)) {
      query["RouteEntryId"] = request.routeEntryId;
    }

    if (!$dara.isNull(request.routeEntryName)) {
      query["RouteEntryName"] = request.routeEntryName;
    }

    if (!$dara.isNull(request.routeEntryType)) {
      query["RouteEntryType"] = request.routeEntryType;
    }

    if (!$dara.isNull(request.routeTableId)) {
      query["RouteTableId"] = request.routeTableId;
    }

    if (!$dara.isNull(request.serviceType)) {
      query["ServiceType"] = request.serviceType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeRouteEntryList",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeRouteEntryListResponse>(await this.callApi(params, req, runtime), new $_model.DescribeRouteEntryListResponse({}));
  }

  /**
   * Queries information about route entries in a route table.
   * 
   * @remarks
   * Before you call the [DeleteRouteEntry](https://help.aliyun.com/document_detail/36013.html) operation to delete a route, you can call this operation to query the next hop of the route that you want to delete.
   * 
   * @param request - DescribeRouteEntryListRequest
   * @returns DescribeRouteEntryListResponse
   */
  async describeRouteEntryList(request: $_model.DescribeRouteEntryListRequest): Promise<$_model.DescribeRouteEntryListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeRouteEntryListWithOptions(request, runtime);
  }

  /**
   * Queries route tables.
   * 
   * @param request - DescribeRouteTableListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRouteTableListResponse
   */
  async describeRouteTableListWithOptions(request: $_model.DescribeRouteTableListRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeRouteTableListResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeTableId)) {
      query["RouteTableId"] = request.routeTableId;
    }

    if (!$dara.isNull(request.routeTableName)) {
      query["RouteTableName"] = request.routeTableName;
    }

    if (!$dara.isNull(request.routeTableType)) {
      query["RouteTableType"] = request.routeTableType;
    }

    if (!$dara.isNull(request.routerId)) {
      query["RouterId"] = request.routerId;
    }

    if (!$dara.isNull(request.routerType)) {
      query["RouterType"] = request.routerType;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeRouteTableList",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeRouteTableListResponse>(await this.callApi(params, req, runtime), new $_model.DescribeRouteTableListResponse({}));
  }

  /**
   * Queries route tables.
   * 
   * @param request - DescribeRouteTableListRequest
   * @returns DescribeRouteTableListResponse
   */
  async describeRouteTableList(request: $_model.DescribeRouteTableListRequest): Promise<$_model.DescribeRouteTableListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeRouteTableListWithOptions(request, runtime);
  }

  /**
   * Queries route tables.
   * 
   * @deprecated OpenAPI DescribeRouteTables is deprecated, please use Vpc::2016-04-28::DescribeRouteTableList instead.
   * 
   * @param request - DescribeRouteTablesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRouteTablesResponse
   */
  async describeRouteTablesWithOptions(request: $_model.DescribeRouteTablesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeRouteTablesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeTableId)) {
      query["RouteTableId"] = request.routeTableId;
    }

    if (!$dara.isNull(request.routeTableName)) {
      query["RouteTableName"] = request.routeTableName;
    }

    if (!$dara.isNull(request.routerId)) {
      query["RouterId"] = request.routerId;
    }

    if (!$dara.isNull(request.routerType)) {
      query["RouterType"] = request.routerType;
    }

    if (!$dara.isNull(request.type)) {
      query["Type"] = request.type;
    }

    if (!$dara.isNull(request.VRouterId)) {
      query["VRouterId"] = request.VRouterId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeRouteTables",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeRouteTablesResponse>(await this.callApi(params, req, runtime), new $_model.DescribeRouteTablesResponse({}));
  }

  /**
   * Queries route tables.
   * 
   * @deprecated OpenAPI DescribeRouteTables is deprecated, please use Vpc::2016-04-28::DescribeRouteTableList instead.
   * 
   * @param request - DescribeRouteTablesRequest
   * @returns DescribeRouteTablesResponse
   */
  // Deprecated
  async describeRouteTables(request: $_model.DescribeRouteTablesRequest): Promise<$_model.DescribeRouteTablesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeRouteTablesWithOptions(request, runtime);
  }

  /**
   * Queries the configuration of a router interface.
   * 
   * @param request - DescribeRouterInterfaceAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRouterInterfaceAttributeResponse
   */
  async describeRouterInterfaceAttributeWithOptions(request: $_model.DescribeRouterInterfaceAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeRouterInterfaceAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeRouterInterfaceAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeRouterInterfaceAttributeResponse>(await this.callApi(params, req, runtime), new $_model.DescribeRouterInterfaceAttributeResponse({}));
  }

  /**
   * Queries the configuration of a router interface.
   * 
   * @param request - DescribeRouterInterfaceAttributeRequest
   * @returns DescribeRouterInterfaceAttributeResponse
   */
  async describeRouterInterfaceAttribute(request: $_model.DescribeRouterInterfaceAttributeRequest): Promise<$_model.DescribeRouterInterfaceAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeRouterInterfaceAttributeWithOptions(request, runtime);
  }

  /**
   * Queries router interfaces in a specified region.
   * 
   * @param request - DescribeRouterInterfacesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRouterInterfacesResponse
   */
  async describeRouterInterfacesWithOptions(request: $_model.DescribeRouterInterfacesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeRouterInterfacesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.filter)) {
      query["Filter"] = request.filter;
    }

    if (!$dara.isNull(request.includeReservationData)) {
      query["IncludeReservationData"] = request.includeReservationData;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeRouterInterfaces",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeRouterInterfacesResponse>(await this.callApi(params, req, runtime), new $_model.DescribeRouterInterfacesResponse({}));
  }

  /**
   * Queries router interfaces in a specified region.
   * 
   * @param request - DescribeRouterInterfacesRequest
   * @returns DescribeRouterInterfacesResponse
   */
  async describeRouterInterfaces(request: $_model.DescribeRouterInterfacesRequest): Promise<$_model.DescribeRouterInterfacesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeRouterInterfacesWithOptions(request, runtime);
  }

  /**
   * Queries Global Accelerator (GA) instances that are associated with a backend server.
   * 
   * @remarks
   * > You can call this operation to query only dedicated-bandwidth GA instances.
   * 
   * @param request - DescribeServerRelatedGlobalAccelerationInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeServerRelatedGlobalAccelerationInstancesResponse
   */
  async describeServerRelatedGlobalAccelerationInstancesWithOptions(request: $_model.DescribeServerRelatedGlobalAccelerationInstancesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeServerRelatedGlobalAccelerationInstancesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.serverId)) {
      query["ServerId"] = request.serverId;
    }

    if (!$dara.isNull(request.serverType)) {
      query["ServerType"] = request.serverType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeServerRelatedGlobalAccelerationInstances",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeServerRelatedGlobalAccelerationInstancesResponse>(await this.callApi(params, req, runtime), new $_model.DescribeServerRelatedGlobalAccelerationInstancesResponse({}));
  }

  /**
   * Queries Global Accelerator (GA) instances that are associated with a backend server.
   * 
   * @remarks
   * > You can call this operation to query only dedicated-bandwidth GA instances.
   * 
   * @param request - DescribeServerRelatedGlobalAccelerationInstancesRequest
   * @returns DescribeServerRelatedGlobalAccelerationInstancesResponse
   */
  async describeServerRelatedGlobalAccelerationInstances(request: $_model.DescribeServerRelatedGlobalAccelerationInstancesRequest): Promise<$_model.DescribeServerRelatedGlobalAccelerationInstancesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeServerRelatedGlobalAccelerationInstancesWithOptions(request, runtime);
  }

  /**
   * Queries SNAT entries.
   * 
   * @param request - DescribeSnatTableEntriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSnatTableEntriesResponse
   */
  async describeSnatTableEntriesWithOptions(request: $_model.DescribeSnatTableEntriesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeSnatTableEntriesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.natGatewayId)) {
      query["NatGatewayId"] = request.natGatewayId;
    }

    if (!$dara.isNull(request.networkInterfaceIds)) {
      query["NetworkInterfaceIds"] = request.networkInterfaceIds;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.snatEntryId)) {
      query["SnatEntryId"] = request.snatEntryId;
    }

    if (!$dara.isNull(request.snatEntryName)) {
      query["SnatEntryName"] = request.snatEntryName;
    }

    if (!$dara.isNull(request.snatIp)) {
      query["SnatIp"] = request.snatIp;
    }

    if (!$dara.isNull(request.snatTableId)) {
      query["SnatTableId"] = request.snatTableId;
    }

    if (!$dara.isNull(request.sourceCIDR)) {
      query["SourceCIDR"] = request.sourceCIDR;
    }

    if (!$dara.isNull(request.sourceVSwitchId)) {
      query["SourceVSwitchId"] = request.sourceVSwitchId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeSnatTableEntries",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeSnatTableEntriesResponse>(await this.callApi(params, req, runtime), new $_model.DescribeSnatTableEntriesResponse({}));
  }

  /**
   * Queries SNAT entries.
   * 
   * @param request - DescribeSnatTableEntriesRequest
   * @returns DescribeSnatTableEntriesResponse
   */
  async describeSnatTableEntries(request: $_model.DescribeSnatTableEntriesRequest): Promise<$_model.DescribeSnatTableEntriesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeSnatTableEntriesWithOptions(request, runtime);
  }

  /**
   * Queries the details of an SSL client certificate.
   * 
   * @param request - DescribeSslVpnClientCertRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSslVpnClientCertResponse
   */
  async describeSslVpnClientCertWithOptions(request: $_model.DescribeSslVpnClientCertRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeSslVpnClientCertResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.sslVpnClientCertId)) {
      query["SslVpnClientCertId"] = request.sslVpnClientCertId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeSslVpnClientCert",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeSslVpnClientCertResponse>(await this.callApi(params, req, runtime), new $_model.DescribeSslVpnClientCertResponse({}));
  }

  /**
   * Queries the details of an SSL client certificate.
   * 
   * @param request - DescribeSslVpnClientCertRequest
   * @returns DescribeSslVpnClientCertResponse
   */
  async describeSslVpnClientCert(request: $_model.DescribeSslVpnClientCertRequest): Promise<$_model.DescribeSslVpnClientCertResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeSslVpnClientCertWithOptions(request, runtime);
  }

  /**
   * Queries SSL client certificates.
   * 
   * @param request - DescribeSslVpnClientCertsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSslVpnClientCertsResponse
   */
  async describeSslVpnClientCertsWithOptions(request: $_model.DescribeSslVpnClientCertsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeSslVpnClientCertsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.sslVpnClientCertId)) {
      query["SslVpnClientCertId"] = request.sslVpnClientCertId;
    }

    if (!$dara.isNull(request.sslVpnServerId)) {
      query["SslVpnServerId"] = request.sslVpnServerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeSslVpnClientCerts",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeSslVpnClientCertsResponse>(await this.callApi(params, req, runtime), new $_model.DescribeSslVpnClientCertsResponse({}));
  }

  /**
   * Queries SSL client certificates.
   * 
   * @param request - DescribeSslVpnClientCertsRequest
   * @returns DescribeSslVpnClientCertsResponse
   */
  async describeSslVpnClientCerts(request: $_model.DescribeSslVpnClientCertsRequest): Promise<$_model.DescribeSslVpnClientCertsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeSslVpnClientCertsWithOptions(request, runtime);
  }

  /**
   * Queries the clients that have connected to a VPN gateway through SSL-VPN connections.
   * 
   * @remarks
   * If your VPN gateway was created before December 10, 2022, you need to upgrade the VPN gateway to the latest version to view the connection information about SSL clients. For more information, see [Upgrade a VPN gateway](https://help.aliyun.com/document_detail/2671058.html).
   * If your VPN gateway was created after December 10, 2022, you can view the connection information about SSL clients by default.
   * 
   * @param request - DescribeSslVpnClientsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSslVpnClientsResponse
   */
  async describeSslVpnClientsWithOptions(request: $_model.DescribeSslVpnClientsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeSslVpnClientsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeSslVpnClients",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeSslVpnClientsResponse>(await this.callApi(params, req, runtime), new $_model.DescribeSslVpnClientsResponse({}));
  }

  /**
   * Queries the clients that have connected to a VPN gateway through SSL-VPN connections.
   * 
   * @remarks
   * If your VPN gateway was created before December 10, 2022, you need to upgrade the VPN gateway to the latest version to view the connection information about SSL clients. For more information, see [Upgrade a VPN gateway](https://help.aliyun.com/document_detail/2671058.html).
   * If your VPN gateway was created after December 10, 2022, you can view the connection information about SSL clients by default.
   * 
   * @param request - DescribeSslVpnClientsRequest
   * @returns DescribeSslVpnClientsResponse
   */
  async describeSslVpnClients(request: $_model.DescribeSslVpnClientsRequest): Promise<$_model.DescribeSslVpnClientsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeSslVpnClientsWithOptions(request, runtime);
  }

  /**
   * Queries one or more SSL-VPN servers.
   * 
   * @param request - DescribeSslVpnServersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSslVpnServersResponse
   */
  async describeSslVpnServersWithOptions(request: $_model.DescribeSslVpnServersRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeSslVpnServersResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.sslVpnServerId)) {
      query["SslVpnServerId"] = request.sslVpnServerId;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeSslVpnServers",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeSslVpnServersResponse>(await this.callApi(params, req, runtime), new $_model.DescribeSslVpnServersResponse({}));
  }

  /**
   * Queries one or more SSL-VPN servers.
   * 
   * @param request - DescribeSslVpnServersRequest
   * @returns DescribeSslVpnServersResponse
   */
  async describeSslVpnServers(request: $_model.DescribeSslVpnServersRequest): Promise<$_model.DescribeSslVpnServersResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeSslVpnServersWithOptions(request, runtime);
  }

  /**
   * Queries tag keys.
   * 
   * @param request - DescribeTagKeysRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTagKeysResponse
   */
  async describeTagKeysWithOptions(request: $_model.DescribeTagKeysRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeTagKeysResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!$dara.isNull(request.maxResult)) {
      query["MaxResult"] = request.maxResult;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeTagKeys",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeTagKeysResponse>(await this.callApi(params, req, runtime), new $_model.DescribeTagKeysResponse({}));
  }

  /**
   * Queries tag keys.
   * 
   * @param request - DescribeTagKeysRequest
   * @returns DescribeTagKeysResponse
   */
  async describeTagKeys(request: $_model.DescribeTagKeysRequest): Promise<$_model.DescribeTagKeysResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeTagKeysWithOptions(request, runtime);
  }

  /**
   * Queries the tags of an Express Connect circuit.
   * 
   * @param request - DescribeTagKeysForExpressConnectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTagKeysForExpressConnectResponse
   */
  async describeTagKeysForExpressConnectWithOptions(request: $_model.DescribeTagKeysForExpressConnectRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeTagKeysForExpressConnectResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!$dara.isNull(request.maxResult)) {
      query["MaxResult"] = request.maxResult;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeTagKeysForExpressConnect",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeTagKeysForExpressConnectResponse>(await this.callApi(params, req, runtime), new $_model.DescribeTagKeysForExpressConnectResponse({}));
  }

  /**
   * Queries the tags of an Express Connect circuit.
   * 
   * @param request - DescribeTagKeysForExpressConnectRequest
   * @returns DescribeTagKeysForExpressConnectResponse
   */
  async describeTagKeysForExpressConnect(request: $_model.DescribeTagKeysForExpressConnectRequest): Promise<$_model.DescribeTagKeysForExpressConnectResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeTagKeysForExpressConnectWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @remarks
   *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
   * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Tag.N.Value**, an error message is returned.
   * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
   * *   If you specify multiple key-value pairs, all tags that match the key-value pairs are returned.
   * 
   * @param request - DescribeTagsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTagsResponse
   */
  async describeTagsWithOptions(request: $_model.DescribeTagsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeTagsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.maxResult)) {
      query["MaxResult"] = request.maxResult;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeTags",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeTagsResponse>(await this.callApi(params, req, runtime), new $_model.DescribeTagsResponse({}));
  }

  /**
   * 
   * 
   * @remarks
   *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
   * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Tag.N.Value**, an error message is returned.
   * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
   * *   If you specify multiple key-value pairs, all tags that match the key-value pairs are returned.
   * 
   * @param request - DescribeTagsRequest
   * @returns DescribeTagsResponse
   */
  async describeTags(request: $_model.DescribeTagsRequest): Promise<$_model.DescribeTagsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeTagsWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - DescribeVRoutersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeVRoutersResponse
   */
  async describeVRoutersWithOptions(request: $_model.DescribeVRoutersRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeVRoutersResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.VRouterId)) {
      query["VRouterId"] = request.VRouterId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeVRouters",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeVRoutersResponse>(await this.callApi(params, req, runtime), new $_model.DescribeVRoutersResponse({}));
  }

  /**
   * 
   * 
   * @param request - DescribeVRoutersRequest
   * @returns DescribeVRoutersResponse
   */
  async describeVRouters(request: $_model.DescribeVRoutersRequest): Promise<$_model.DescribeVRoutersResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeVRoutersWithOptions(request, runtime);
  }

  /**
   * Queries the detailed information about a vSwitch.
   * 
   * @param request - DescribeVSwitchAttributesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeVSwitchAttributesResponse
   */
  async describeVSwitchAttributesWithOptions(request: $_model.DescribeVSwitchAttributesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeVSwitchAttributesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeVSwitchAttributes",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeVSwitchAttributesResponse>(await this.callApi(params, req, runtime), new $_model.DescribeVSwitchAttributesResponse({}));
  }

  /**
   * Queries the detailed information about a vSwitch.
   * 
   * @param request - DescribeVSwitchAttributesRequest
   * @returns DescribeVSwitchAttributesResponse
   */
  async describeVSwitchAttributes(request: $_model.DescribeVSwitchAttributesRequest): Promise<$_model.DescribeVSwitchAttributesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeVSwitchAttributesWithOptions(request, runtime);
  }

  /**
   * Queries the information about available vSwitches that are used for an internal network.
   * 
   * @param request - DescribeVSwitchesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeVSwitchesResponse
   */
  async describeVSwitchesWithOptions(request: $_model.DescribeVSwitchesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeVSwitchesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.enableIpv6)) {
      query["EnableIpv6"] = request.enableIpv6;
    }

    if (!$dara.isNull(request.isDefault)) {
      query["IsDefault"] = request.isDefault;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeTableId)) {
      query["RouteTableId"] = request.routeTableId;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    if (!$dara.isNull(request.vSwitchName)) {
      query["VSwitchName"] = request.vSwitchName;
    }

    if (!$dara.isNull(request.vSwitchOwnerId)) {
      query["VSwitchOwnerId"] = request.vSwitchOwnerId;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    if (!$dara.isNull(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeVSwitches",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeVSwitchesResponse>(await this.callApi(params, req, runtime), new $_model.DescribeVSwitchesResponse({}));
  }

  /**
   * Queries the information about available vSwitches that are used for an internal network.
   * 
   * @param request - DescribeVSwitchesRequest
   * @returns DescribeVSwitchesResponse
   */
  async describeVSwitches(request: $_model.DescribeVSwitchesRequest): Promise<$_model.DescribeVSwitchesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeVSwitchesWithOptions(request, runtime);
  }

  /**
   * Queries virtual border router (VBR) failover groups.
   * 
   * @param request - DescribeVbrHaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeVbrHaResponse
   */
  async describeVbrHaWithOptions(request: $_model.DescribeVbrHaRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeVbrHaResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vbrHaId)) {
      query["VbrHaId"] = request.vbrHaId;
    }

    if (!$dara.isNull(request.vbrId)) {
      query["VbrId"] = request.vbrId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeVbrHa",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeVbrHaResponse>(await this.callApi(params, req, runtime), new $_model.DescribeVbrHaResponse({}));
  }

  /**
   * Queries virtual border router (VBR) failover groups.
   * 
   * @param request - DescribeVbrHaRequest
   * @returns DescribeVbrHaResponse
   */
  async describeVbrHa(request: $_model.DescribeVbrHaRequest): Promise<$_model.DescribeVbrHaResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeVbrHaWithOptions(request, runtime);
  }

  /**
   * Queries the routes of an IPsec-VPN connection.
   * 
   * @param request - DescribeVcoRouteEntriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeVcoRouteEntriesResponse
   */
  async describeVcoRouteEntriesWithOptions(request: $_model.DescribeVcoRouteEntriesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeVcoRouteEntriesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeEntryType)) {
      query["RouteEntryType"] = request.routeEntryType;
    }

    if (!$dara.isNull(request.vpnConnectionId)) {
      query["VpnConnectionId"] = request.vpnConnectionId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeVcoRouteEntries",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeVcoRouteEntriesResponse>(await this.callApi(params, req, runtime), new $_model.DescribeVcoRouteEntriesResponse({}));
  }

  /**
   * Queries the routes of an IPsec-VPN connection.
   * 
   * @param request - DescribeVcoRouteEntriesRequest
   * @returns DescribeVcoRouteEntriesResponse
   */
  async describeVcoRouteEntries(request: $_model.DescribeVcoRouteEntriesRequest): Promise<$_model.DescribeVcoRouteEntriesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeVcoRouteEntriesWithOptions(request, runtime);
  }

  /**
   * Queries virtual border routers (VBRs).
   * 
   * @param request - DescribeVirtualBorderRoutersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeVirtualBorderRoutersResponse
   */
  async describeVirtualBorderRoutersWithOptions(request: $_model.DescribeVirtualBorderRoutersRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeVirtualBorderRoutersResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.filter)) {
      query["Filter"] = request.filter;
    }

    if (!$dara.isNull(request.includeCrossAccountVbr)) {
      query["IncludeCrossAccountVbr"] = request.includeCrossAccountVbr;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeVirtualBorderRouters",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeVirtualBorderRoutersResponse>(await this.callApi(params, req, runtime), new $_model.DescribeVirtualBorderRoutersResponse({}));
  }

  /**
   * Queries virtual border routers (VBRs).
   * 
   * @param request - DescribeVirtualBorderRoutersRequest
   * @returns DescribeVirtualBorderRoutersResponse
   */
  async describeVirtualBorderRouters(request: $_model.DescribeVirtualBorderRoutersRequest): Promise<$_model.DescribeVirtualBorderRoutersResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeVirtualBorderRoutersWithOptions(request, runtime);
  }

  /**
   * Queries the virtual border routers (VBRs) that are associated with an Express Connect circuit. The VBRs can be created by the owner of the Express Connect circuit and by other Alibaba Cloud accounts.
   * 
   * @param request - DescribeVirtualBorderRoutersForPhysicalConnectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeVirtualBorderRoutersForPhysicalConnectionResponse
   */
  async describeVirtualBorderRoutersForPhysicalConnectionWithOptions(request: $_model.DescribeVirtualBorderRoutersForPhysicalConnectionRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeVirtualBorderRoutersForPhysicalConnectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.filter)) {
      query["Filter"] = request.filter;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.physicalConnectionId)) {
      query["PhysicalConnectionId"] = request.physicalConnectionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeVirtualBorderRoutersForPhysicalConnection",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeVirtualBorderRoutersForPhysicalConnectionResponse>(await this.callApi(params, req, runtime), new $_model.DescribeVirtualBorderRoutersForPhysicalConnectionResponse({}));
  }

  /**
   * Queries the virtual border routers (VBRs) that are associated with an Express Connect circuit. The VBRs can be created by the owner of the Express Connect circuit and by other Alibaba Cloud accounts.
   * 
   * @param request - DescribeVirtualBorderRoutersForPhysicalConnectionRequest
   * @returns DescribeVirtualBorderRoutersForPhysicalConnectionResponse
   */
  async describeVirtualBorderRoutersForPhysicalConnection(request: $_model.DescribeVirtualBorderRoutersForPhysicalConnectionRequest): Promise<$_model.DescribeVirtualBorderRoutersForPhysicalConnectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeVirtualBorderRoutersForPhysicalConnectionWithOptions(request, runtime);
  }

  /**
   * Queries the configuration of a virtual private cloud (VPC).
   * 
   * @param request - DescribeVpcAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeVpcAttributeResponse
   */
  async describeVpcAttributeWithOptions(request: $_model.DescribeVpcAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeVpcAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.isDefault)) {
      query["IsDefault"] = request.isDefault;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeVpcAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeVpcAttributeResponse>(await this.callApi(params, req, runtime), new $_model.DescribeVpcAttributeResponse({}));
  }

  /**
   * Queries the configuration of a virtual private cloud (VPC).
   * 
   * @param request - DescribeVpcAttributeRequest
   * @returns DescribeVpcAttributeResponse
   */
  async describeVpcAttribute(request: $_model.DescribeVpcAttributeRequest): Promise<$_model.DescribeVpcAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeVpcAttributeWithOptions(request, runtime);
  }

  /**
   * Queries virtual private clouds (VPCs).
   * 
   * @param request - DescribeVpcsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeVpcsResponse
   */
  async describeVpcsWithOptions(request: $_model.DescribeVpcsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeVpcsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.dhcpOptionsSetId)) {
      query["DhcpOptionsSetId"] = request.dhcpOptionsSetId;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.enableIpv6)) {
      query["EnableIpv6"] = request.enableIpv6;
    }

    if (!$dara.isNull(request.isDefault)) {
      query["IsDefault"] = request.isDefault;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    if (!$dara.isNull(request.vpcName)) {
      query["VpcName"] = request.vpcName;
    }

    if (!$dara.isNull(request.vpcOwnerId)) {
      query["VpcOwnerId"] = request.vpcOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeVpcs",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeVpcsResponse>(await this.callApi(params, req, runtime), new $_model.DescribeVpcsResponse({}));
  }

  /**
   * Queries virtual private clouds (VPCs).
   * 
   * @param request - DescribeVpcsRequest
   * @returns DescribeVpcsResponse
   */
  async describeVpcs(request: $_model.DescribeVpcsRequest): Promise<$_model.DescribeVpcsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeVpcsWithOptions(request, runtime);
  }

  /**
   * Queries the IPsec-VPN connections associated with a transit router.
   * 
   * @param request - DescribeVpnAttachmentsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeVpnAttachmentsResponse
   */
  async describeVpnAttachmentsWithOptions(request: $_model.DescribeVpnAttachmentsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeVpnAttachmentsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.attachType)) {
      query["AttachType"] = request.attachType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpnConnectionId)) {
      query["VpnConnectionId"] = request.vpnConnectionId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeVpnAttachments",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeVpnAttachmentsResponse>(await this.callApi(params, req, runtime), new $_model.DescribeVpnAttachmentsResponse({}));
  }

  /**
   * Queries the IPsec-VPN connections associated with a transit router.
   * 
   * @param request - DescribeVpnAttachmentsRequest
   * @returns DescribeVpnAttachmentsResponse
   */
  async describeVpnAttachments(request: $_model.DescribeVpnAttachmentsRequest): Promise<$_model.DescribeVpnAttachmentsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeVpnAttachmentsWithOptions(request, runtime);
  }

  /**
   * Queries the detailed information about an IPsec-VPN connection.
   * 
   * @param request - DescribeVpnConnectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeVpnConnectionResponse
   */
  async describeVpnConnectionWithOptions(request: $_model.DescribeVpnConnectionRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeVpnConnectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpnConnectionId)) {
      query["VpnConnectionId"] = request.vpnConnectionId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeVpnConnection",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeVpnConnectionResponse>(await this.callApi(params, req, runtime), new $_model.DescribeVpnConnectionResponse({}));
  }

  /**
   * Queries the detailed information about an IPsec-VPN connection.
   * 
   * @param request - DescribeVpnConnectionRequest
   * @returns DescribeVpnConnectionResponse
   */
  async describeVpnConnection(request: $_model.DescribeVpnConnectionRequest): Promise<$_model.DescribeVpnConnectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeVpnConnectionWithOptions(request, runtime);
  }

  /**
   * Queries logs of IPsec-VPN connections.
   * 
   * @param request - DescribeVpnConnectionLogsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeVpnConnectionLogsResponse
   */
  async describeVpnConnectionLogsWithOptions(request: $_model.DescribeVpnConnectionLogsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeVpnConnectionLogsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.from)) {
      query["From"] = request.from;
    }

    if (!$dara.isNull(request.minutePeriod)) {
      query["MinutePeriod"] = request.minutePeriod;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.to)) {
      query["To"] = request.to;
    }

    if (!$dara.isNull(request.tunnelId)) {
      query["TunnelId"] = request.tunnelId;
    }

    if (!$dara.isNull(request.vpnConnectionId)) {
      query["VpnConnectionId"] = request.vpnConnectionId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeVpnConnectionLogs",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeVpnConnectionLogsResponse>(await this.callApi(params, req, runtime), new $_model.DescribeVpnConnectionLogsResponse({}));
  }

  /**
   * Queries logs of IPsec-VPN connections.
   * 
   * @param request - DescribeVpnConnectionLogsRequest
   * @returns DescribeVpnConnectionLogsResponse
   */
  async describeVpnConnectionLogs(request: $_model.DescribeVpnConnectionLogsRequest): Promise<$_model.DescribeVpnConnectionLogsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeVpnConnectionLogsWithOptions(request, runtime);
  }

  /**
   * Queries IPsec-VPN connections.
   * 
   * @param request - DescribeVpnConnectionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeVpnConnectionsResponse
   */
  async describeVpnConnectionsWithOptions(request: $_model.DescribeVpnConnectionsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeVpnConnectionsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.customerGatewayId)) {
      query["CustomerGatewayId"] = request.customerGatewayId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.vpnConnectionId)) {
      query["VpnConnectionId"] = request.vpnConnectionId;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeVpnConnections",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeVpnConnectionsResponse>(await this.callApi(params, req, runtime), new $_model.DescribeVpnConnectionsResponse({}));
  }

  /**
   * Queries IPsec-VPN connections.
   * 
   * @param request - DescribeVpnConnectionsRequest
   * @returns DescribeVpnConnectionsResponse
   */
  async describeVpnConnections(request: $_model.DescribeVpnConnectionsRequest): Promise<$_model.DescribeVpnConnectionsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeVpnConnectionsWithOptions(request, runtime);
  }

  /**
   * Queries the cross-account authorization information about an IPsec-VPN connection.
   * 
   * @param request - DescribeVpnCrossAccountAuthorizationsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeVpnCrossAccountAuthorizationsResponse
   */
  async describeVpnCrossAccountAuthorizationsWithOptions(request: $_model.DescribeVpnCrossAccountAuthorizationsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeVpnCrossAccountAuthorizationsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpnConnectionId)) {
      query["VpnConnectionId"] = request.vpnConnectionId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeVpnCrossAccountAuthorizations",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeVpnCrossAccountAuthorizationsResponse>(await this.callApi(params, req, runtime), new $_model.DescribeVpnCrossAccountAuthorizationsResponse({}));
  }

  /**
   * Queries the cross-account authorization information about an IPsec-VPN connection.
   * 
   * @param request - DescribeVpnCrossAccountAuthorizationsRequest
   * @returns DescribeVpnCrossAccountAuthorizationsResponse
   */
  async describeVpnCrossAccountAuthorizations(request: $_model.DescribeVpnCrossAccountAuthorizationsRequest): Promise<$_model.DescribeVpnCrossAccountAuthorizationsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeVpnCrossAccountAuthorizationsWithOptions(request, runtime);
  }

  /**
   * Queries the detailed information about a VPN gateway.
   * 
   * @param request - DescribeVpnGatewayRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeVpnGatewayResponse
   */
  async describeVpnGatewayWithOptions(request: $_model.DescribeVpnGatewayRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeVpnGatewayResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.includeReservationData)) {
      query["IncludeReservationData"] = request.includeReservationData;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeVpnGateway",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeVpnGatewayResponse>(await this.callApi(params, req, runtime), new $_model.DescribeVpnGatewayResponse({}));
  }

  /**
   * Queries the detailed information about a VPN gateway.
   * 
   * @param request - DescribeVpnGatewayRequest
   * @returns DescribeVpnGatewayResponse
   */
  async describeVpnGateway(request: $_model.DescribeVpnGatewayRequest): Promise<$_model.DescribeVpnGatewayResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeVpnGatewayWithOptions(request, runtime);
  }

  /**
   * Queries zones that support IPsec-VPN connections in a region.
   * 
   * @param request - DescribeVpnGatewayAvailableZonesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeVpnGatewayAvailableZonesResponse
   */
  async describeVpnGatewayAvailableZonesWithOptions(request: $_model.DescribeVpnGatewayAvailableZonesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeVpnGatewayAvailableZonesResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeVpnGatewayAvailableZones",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeVpnGatewayAvailableZonesResponse>(await this.callApi(params, req, runtime), new $_model.DescribeVpnGatewayAvailableZonesResponse({}));
  }

  /**
   * Queries zones that support IPsec-VPN connections in a region.
   * 
   * @param request - DescribeVpnGatewayAvailableZonesRequest
   * @returns DescribeVpnGatewayAvailableZonesResponse
   */
  async describeVpnGatewayAvailableZones(request: $_model.DescribeVpnGatewayAvailableZonesRequest): Promise<$_model.DescribeVpnGatewayAvailableZonesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeVpnGatewayAvailableZonesWithOptions(request, runtime);
  }

  /**
   * Queries VPN gateways in a region.
   * 
   * @param request - DescribeVpnGatewaysRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeVpnGatewaysResponse
   */
  async describeVpnGatewaysWithOptions(request: $_model.DescribeVpnGatewaysRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeVpnGatewaysResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.businessStatus)) {
      query["BusinessStatus"] = request.businessStatus;
    }

    if (!$dara.isNull(request.includeReservationData)) {
      query["IncludeReservationData"] = request.includeReservationData;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.status)) {
      query["Status"] = request.status;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeVpnGateways",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeVpnGatewaysResponse>(await this.callApi(params, req, runtime), new $_model.DescribeVpnGatewaysResponse({}));
  }

  /**
   * Queries VPN gateways in a region.
   * 
   * @param request - DescribeVpnGatewaysRequest
   * @returns DescribeVpnGatewaysResponse
   */
  async describeVpnGateways(request: $_model.DescribeVpnGatewaysRequest): Promise<$_model.DescribeVpnGatewaysResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeVpnGatewaysWithOptions(request, runtime);
  }

  /**
   * Queries policy-based routes configured for a VPN gateway.
   * 
   * @param request - DescribeVpnPbrRouteEntriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeVpnPbrRouteEntriesResponse
   */
  async describeVpnPbrRouteEntriesWithOptions(request: $_model.DescribeVpnPbrRouteEntriesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeVpnPbrRouteEntriesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeVpnPbrRouteEntries",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeVpnPbrRouteEntriesResponse>(await this.callApi(params, req, runtime), new $_model.DescribeVpnPbrRouteEntriesResponse({}));
  }

  /**
   * Queries policy-based routes configured for a VPN gateway.
   * 
   * @param request - DescribeVpnPbrRouteEntriesRequest
   * @returns DescribeVpnPbrRouteEntriesResponse
   */
  async describeVpnPbrRouteEntries(request: $_model.DescribeVpnPbrRouteEntriesRequest): Promise<$_model.DescribeVpnPbrRouteEntriesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeVpnPbrRouteEntriesWithOptions(request, runtime);
  }

  /**
   * Queries destination-based and BGP route entries of a VPN gateway.
   * 
   * @param request - DescribeVpnRouteEntriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeVpnRouteEntriesResponse
   */
  async describeVpnRouteEntriesWithOptions(request: $_model.DescribeVpnRouteEntriesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeVpnRouteEntriesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeEntryType)) {
      query["RouteEntryType"] = request.routeEntryType;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeVpnRouteEntries",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeVpnRouteEntriesResponse>(await this.callApi(params, req, runtime), new $_model.DescribeVpnRouteEntriesResponse({}));
  }

  /**
   * Queries destination-based and BGP route entries of a VPN gateway.
   * 
   * @param request - DescribeVpnRouteEntriesRequest
   * @returns DescribeVpnRouteEntriesResponse
   */
  async describeVpnRouteEntries(request: $_model.DescribeVpnRouteEntriesRequest): Promise<$_model.DescribeVpnRouteEntriesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeVpnRouteEntriesWithOptions(request, runtime);
  }

  /**
   * Queries the log entries of an SSL server.
   * 
   * @param request - DescribeVpnSslServerLogsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeVpnSslServerLogsResponse
   */
  async describeVpnSslServerLogsWithOptions(request: $_model.DescribeVpnSslServerLogsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeVpnSslServerLogsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.from)) {
      query["From"] = request.from;
    }

    if (!$dara.isNull(request.minutePeriod)) {
      query["MinutePeriod"] = request.minutePeriod;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.sslVpnClientCertId)) {
      query["SslVpnClientCertId"] = request.sslVpnClientCertId;
    }

    if (!$dara.isNull(request.to)) {
      query["To"] = request.to;
    }

    if (!$dara.isNull(request.vpnSslServerId)) {
      query["VpnSslServerId"] = request.vpnSslServerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeVpnSslServerLogs",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeVpnSslServerLogsResponse>(await this.callApi(params, req, runtime), new $_model.DescribeVpnSslServerLogsResponse({}));
  }

  /**
   * Queries the log entries of an SSL server.
   * 
   * @param request - DescribeVpnSslServerLogsRequest
   * @returns DescribeVpnSslServerLogsResponse
   */
  async describeVpnSslServerLogs(request: $_model.DescribeVpnSslServerLogsRequest): Promise<$_model.DescribeVpnSslServerLogsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeVpnSslServerLogsWithOptions(request, runtime);
  }

  /**
   * Queries zones in a region.
   * 
   * @param request - DescribeZonesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeZonesResponse
   */
  async describeZonesWithOptions(request: $_model.DescribeZonesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DescribeZonesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.zoneType)) {
      query["ZoneType"] = request.zoneType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeZones",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DescribeZonesResponse>(await this.callApi(params, req, runtime), new $_model.DescribeZonesResponse({}));
  }

  /**
   * Queries zones in a region.
   * 
   * @param request - DescribeZonesRequest
   * @returns DescribeZonesResponse
   */
  async describeZones(request: $_model.DescribeZonesRequest): Promise<$_model.DescribeZonesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeZonesWithOptions(request, runtime);
  }

  /**
   * Disassociates a DHCP options set from a virtual private cloud (VPC).
   * 
   * @remarks
   * ## [](#)Description
   * *   **DetachDhcpOptionsSetFromVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task.
   *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being disassociated.
   *     *   If the DHCP options set is in the **UnUsed** state, the DHCP options set is disassociated.
   * *   You cannot repeatedly call the **DetachDhcpOptionsSetFromVpc** operation to disassociate a DHCP options set from a VPC within the specified period of time.
   * 
   * @param request - DetachDhcpOptionsSetFromVpcRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DetachDhcpOptionsSetFromVpcResponse
   */
  async detachDhcpOptionsSetFromVpcWithOptions(request: $_model.DetachDhcpOptionsSetFromVpcRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DetachDhcpOptionsSetFromVpcResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dhcpOptionsSetId)) {
      query["DhcpOptionsSetId"] = request.dhcpOptionsSetId;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DetachDhcpOptionsSetFromVpc",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DetachDhcpOptionsSetFromVpcResponse>(await this.callApi(params, req, runtime), new $_model.DetachDhcpOptionsSetFromVpcResponse({}));
  }

  /**
   * Disassociates a DHCP options set from a virtual private cloud (VPC).
   * 
   * @remarks
   * ## [](#)Description
   * *   **DetachDhcpOptionsSetFromVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task.
   *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being disassociated.
   *     *   If the DHCP options set is in the **UnUsed** state, the DHCP options set is disassociated.
   * *   You cannot repeatedly call the **DetachDhcpOptionsSetFromVpc** operation to disassociate a DHCP options set from a VPC within the specified period of time.
   * 
   * @param request - DetachDhcpOptionsSetFromVpcRequest
   * @returns DetachDhcpOptionsSetFromVpcResponse
   */
  async detachDhcpOptionsSetFromVpc(request: $_model.DetachDhcpOptionsSetFromVpcRequest): Promise<$_model.DetachDhcpOptionsSetFromVpcResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.detachDhcpOptionsSetFromVpcWithOptions(request, runtime);
  }

  /**
   * Diagnoses IPsec-VPN connections.
   * 
   * @remarks
   *   If the IPsec-VPN connection is in single-tunnel mode, the request parameter `VpnConnectionIds` is required when you call the **DiagnoseVpnConnections** operation.
   * *   If the IPsec-VPN connection is in dual-tunnel mode, the request parameter `TunnelIds` is required when you call the **DiagnoseVpnConnections** operation.
   * *   After you call the **DiagnoseVpnConnections** operation, if the current IPsec-VPN connection is faulty, the operation returns the corresponding error code (**FailedReasonCode**) and log (**SourceLog**). You can troubleshoot based on the error code and log information. For more information, see [Common errors and troubleshooting methods for IPsec-VPN connections](https://help.aliyun.com/document_detail/477862.html).
   * 
   * @param request - DiagnoseVpnConnectionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DiagnoseVpnConnectionsResponse
   */
  async diagnoseVpnConnectionsWithOptions(request: $_model.DiagnoseVpnConnectionsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DiagnoseVpnConnectionsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tunnelIds)) {
      query["TunnelIds"] = request.tunnelIds;
    }

    if (!$dara.isNull(request.vpnConnectionIds)) {
      query["VpnConnectionIds"] = request.vpnConnectionIds;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DiagnoseVpnConnections",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DiagnoseVpnConnectionsResponse>(await this.callApi(params, req, runtime), new $_model.DiagnoseVpnConnectionsResponse({}));
  }

  /**
   * Diagnoses IPsec-VPN connections.
   * 
   * @remarks
   *   If the IPsec-VPN connection is in single-tunnel mode, the request parameter `VpnConnectionIds` is required when you call the **DiagnoseVpnConnections** operation.
   * *   If the IPsec-VPN connection is in dual-tunnel mode, the request parameter `TunnelIds` is required when you call the **DiagnoseVpnConnections** operation.
   * *   After you call the **DiagnoseVpnConnections** operation, if the current IPsec-VPN connection is faulty, the operation returns the corresponding error code (**FailedReasonCode**) and log (**SourceLog**). You can troubleshoot based on the error code and log information. For more information, see [Common errors and troubleshooting methods for IPsec-VPN connections](https://help.aliyun.com/document_detail/477862.html).
   * 
   * @param request - DiagnoseVpnConnectionsRequest
   * @returns DiagnoseVpnConnectionsResponse
   */
  async diagnoseVpnConnections(request: $_model.DiagnoseVpnConnectionsRequest): Promise<$_model.DiagnoseVpnConnectionsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.diagnoseVpnConnectionsWithOptions(request, runtime);
  }

  /**
   * Diagnoses a VPN gateway.
   * 
   * @param request - DiagnoseVpnGatewayRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DiagnoseVpnGatewayResponse
   */
  async diagnoseVpnGatewayWithOptions(request: $_model.DiagnoseVpnGatewayRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DiagnoseVpnGatewayResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.IPsecExtendInfo)) {
      query["IPsecExtendInfo"] = request.IPsecExtendInfo;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!$dara.isNull(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DiagnoseVpnGateway",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DiagnoseVpnGatewayResponse>(await this.callApi(params, req, runtime), new $_model.DiagnoseVpnGatewayResponse({}));
  }

  /**
   * Diagnoses a VPN gateway.
   * 
   * @param request - DiagnoseVpnGatewayRequest
   * @returns DiagnoseVpnGatewayResponse
   */
  async diagnoseVpnGateway(request: $_model.DiagnoseVpnGatewayRequest): Promise<$_model.DiagnoseVpnGatewayResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.diagnoseVpnGatewayWithOptions(request, runtime);
  }

  /**
   * Disables traffic monitoring for an Elastic Compute Service (ECS) instance.
   * 
   * @deprecated OpenAPI DisableNatGatewayEcsMetric is deprecated
   * 
   * @param request - DisableNatGatewayEcsMetricRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DisableNatGatewayEcsMetricResponse
   */
  async disableNatGatewayEcsMetricWithOptions(request: $_model.DisableNatGatewayEcsMetricRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DisableNatGatewayEcsMetricResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.natGatewayId)) {
      query["NatGatewayId"] = request.natGatewayId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DisableNatGatewayEcsMetric",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DisableNatGatewayEcsMetricResponse>(await this.callApi(params, req, runtime), new $_model.DisableNatGatewayEcsMetricResponse({}));
  }

  /**
   * Disables traffic monitoring for an Elastic Compute Service (ECS) instance.
   * 
   * @deprecated OpenAPI DisableNatGatewayEcsMetric is deprecated
   * 
   * @param request - DisableNatGatewayEcsMetricRequest
   * @returns DisableNatGatewayEcsMetricResponse
   */
  // Deprecated
  async disableNatGatewayEcsMetric(request: $_model.DisableNatGatewayEcsMetricRequest): Promise<$_model.DisableNatGatewayEcsMetricResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.disableNatGatewayEcsMetricWithOptions(request, runtime);
  }

  /**
   * Disables ClassicLink for a virtual private cloud (VPC).
   * 
   * @param request - DisableVpcClassicLinkRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DisableVpcClassicLinkResponse
   */
  async disableVpcClassicLinkWithOptions(request: $_model.DisableVpcClassicLinkRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DisableVpcClassicLinkResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DisableVpcClassicLink",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DisableVpcClassicLinkResponse>(await this.callApi(params, req, runtime), new $_model.DisableVpcClassicLinkResponse({}));
  }

  /**
   * Disables ClassicLink for a virtual private cloud (VPC).
   * 
   * @param request - DisableVpcClassicLinkRequest
   * @returns DisableVpcClassicLinkResponse
   */
  async disableVpcClassicLink(request: $_model.DisableVpcClassicLinkRequest): Promise<$_model.DisableVpcClassicLinkResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.disableVpcClassicLinkWithOptions(request, runtime);
  }

  /**
   * Disassociates a gateway route table from an IPv4 gateway.
   * 
   * @param request - DissociateRouteTableFromGatewayRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DissociateRouteTableFromGatewayResponse
   */
  async dissociateRouteTableFromGatewayWithOptions(request: $_model.DissociateRouteTableFromGatewayRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DissociateRouteTableFromGatewayResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!$dara.isNull(request.gatewayType)) {
      query["GatewayType"] = request.gatewayType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeTableId)) {
      query["RouteTableId"] = request.routeTableId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DissociateRouteTableFromGateway",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DissociateRouteTableFromGatewayResponse>(await this.callApi(params, req, runtime), new $_model.DissociateRouteTableFromGatewayResponse({}));
  }

  /**
   * Disassociates a gateway route table from an IPv4 gateway.
   * 
   * @param request - DissociateRouteTableFromGatewayRequest
   * @returns DissociateRouteTableFromGatewayResponse
   */
  async dissociateRouteTableFromGateway(request: $_model.DissociateRouteTableFromGatewayRequest): Promise<$_model.DissociateRouteTableFromGatewayResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.dissociateRouteTableFromGatewayWithOptions(request, runtime);
  }

  /**
   * Disassociates a gateway endpoint from a route table.
   * 
   * @param request - DissociateRouteTablesFromVpcGatewayEndpointRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DissociateRouteTablesFromVpcGatewayEndpointResponse
   */
  async dissociateRouteTablesFromVpcGatewayEndpointWithOptions(request: $_model.DissociateRouteTablesFromVpcGatewayEndpointRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DissociateRouteTablesFromVpcGatewayEndpointResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.endpointId)) {
      query["EndpointId"] = request.endpointId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeTableIds)) {
      query["RouteTableIds"] = request.routeTableIds;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DissociateRouteTablesFromVpcGatewayEndpoint",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DissociateRouteTablesFromVpcGatewayEndpointResponse>(await this.callApi(params, req, runtime), new $_model.DissociateRouteTablesFromVpcGatewayEndpointResponse({}));
  }

  /**
   * Disassociates a gateway endpoint from a route table.
   * 
   * @param request - DissociateRouteTablesFromVpcGatewayEndpointRequest
   * @returns DissociateRouteTablesFromVpcGatewayEndpointResponse
   */
  async dissociateRouteTablesFromVpcGatewayEndpoint(request: $_model.DissociateRouteTablesFromVpcGatewayEndpointRequest): Promise<$_model.DissociateRouteTablesFromVpcGatewayEndpointResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.dissociateRouteTablesFromVpcGatewayEndpointWithOptions(request, runtime);
  }

  /**
   * Disassociates a certificate from a VPN gateway.
   * 
   * @remarks
   *   **DissociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status the task.
   *     *   If the VPN gateway is in the **updating** state, the SSL certificate is being disassociated from the VPN gateway.
   *     *   If the VPN gateway is in the **active** state, the SSL certificate is disassociated from the VPN gateway.
   * *   You cannot repeatedly call **DissociateVpnGatewayWithCertificate** within a specific period of time.
   * 
   * @param request - DissociateVpnGatewayWithCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DissociateVpnGatewayWithCertificateResponse
   */
  async dissociateVpnGatewayWithCertificateWithOptions(request: $_model.DissociateVpnGatewayWithCertificateRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DissociateVpnGatewayWithCertificateResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.certificateId)) {
      query["CertificateId"] = request.certificateId;
    }

    if (!$dara.isNull(request.certificateType)) {
      query["CertificateType"] = request.certificateType;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DissociateVpnGatewayWithCertificate",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DissociateVpnGatewayWithCertificateResponse>(await this.callApi(params, req, runtime), new $_model.DissociateVpnGatewayWithCertificateResponse({}));
  }

  /**
   * Disassociates a certificate from a VPN gateway.
   * 
   * @remarks
   *   **DissociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status the task.
   *     *   If the VPN gateway is in the **updating** state, the SSL certificate is being disassociated from the VPN gateway.
   *     *   If the VPN gateway is in the **active** state, the SSL certificate is disassociated from the VPN gateway.
   * *   You cannot repeatedly call **DissociateVpnGatewayWithCertificate** within a specific period of time.
   * 
   * @param request - DissociateVpnGatewayWithCertificateRequest
   * @returns DissociateVpnGatewayWithCertificateResponse
   */
  async dissociateVpnGatewayWithCertificate(request: $_model.DissociateVpnGatewayWithCertificateRequest): Promise<$_model.DissociateVpnGatewayWithCertificateResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.dissociateVpnGatewayWithCertificateWithOptions(request, runtime);
  }

  /**
   * Queries the configuration of an IPsec-VPN connection.
   * 
   * @param request - DownloadVpnConnectionConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DownloadVpnConnectionConfigResponse
   */
  async downloadVpnConnectionConfigWithOptions(request: $_model.DownloadVpnConnectionConfigRequest, runtime: $dara.RuntimeOptions): Promise<$_model.DownloadVpnConnectionConfigResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpnConnectionId)) {
      query["VpnConnectionId"] = request.vpnConnectionId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DownloadVpnConnectionConfig",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.DownloadVpnConnectionConfigResponse>(await this.callApi(params, req, runtime), new $_model.DownloadVpnConnectionConfigResponse({}));
  }

  /**
   * Queries the configuration of an IPsec-VPN connection.
   * 
   * @param request - DownloadVpnConnectionConfigRequest
   * @returns DownloadVpnConnectionConfigResponse
   */
  async downloadVpnConnectionConfig(request: $_model.DownloadVpnConnectionConfigRequest): Promise<$_model.DownloadVpnConnectionConfigResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.downloadVpnConnectionConfigWithOptions(request, runtime);
  }

  /**
   * Enables Elastic Compute Service (ECS) traffic monitoring.
   * 
   * @deprecated OpenAPI EnableNatGatewayEcsMetric is deprecated
   * 
   * @param request - EnableNatGatewayEcsMetricRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnableNatGatewayEcsMetricResponse
   */
  async enableNatGatewayEcsMetricWithOptions(request: $_model.EnableNatGatewayEcsMetricRequest, runtime: $dara.RuntimeOptions): Promise<$_model.EnableNatGatewayEcsMetricResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.natGatewayId)) {
      query["NatGatewayId"] = request.natGatewayId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "EnableNatGatewayEcsMetric",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.EnableNatGatewayEcsMetricResponse>(await this.callApi(params, req, runtime), new $_model.EnableNatGatewayEcsMetricResponse({}));
  }

  /**
   * Enables Elastic Compute Service (ECS) traffic monitoring.
   * 
   * @deprecated OpenAPI EnableNatGatewayEcsMetric is deprecated
   * 
   * @param request - EnableNatGatewayEcsMetricRequest
   * @returns EnableNatGatewayEcsMetricResponse
   */
  // Deprecated
  async enableNatGatewayEcsMetric(request: $_model.EnableNatGatewayEcsMetricRequest): Promise<$_model.EnableNatGatewayEcsMetricResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.enableNatGatewayEcsMetricWithOptions(request, runtime);
  }

  /**
   * Enables an Express Connect circuit that is in the Confirmed state. After you perform this operation, the Express Connect circuit enters the Enabled state.
   * 
   * @remarks
   * When you call this operation, take note of the following limits:
   * *   You can enable only an Express Connect circuit that is in the **Confirmed** state.
   * *   After you enable an Express Connect circuit, it enters the **Enabled** state.
   * *   **EnablePhysicalConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribePhysicalConnections](https://help.aliyun.com/document_detail/36042.html) operation to query the status of the task.
   * *   You cannot repeatedly call **EnablePhysicalConnection** for an Express Connect circuit in the **Confirmed** state within a specific time period.
   * 
   * @param request - EnablePhysicalConnectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnablePhysicalConnectionResponse
   */
  async enablePhysicalConnectionWithOptions(request: $_model.EnablePhysicalConnectionRequest, runtime: $dara.RuntimeOptions): Promise<$_model.EnablePhysicalConnectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.byPassSp)) {
      query["ByPassSp"] = request.byPassSp;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.physicalConnectionId)) {
      query["PhysicalConnectionId"] = request.physicalConnectionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "EnablePhysicalConnection",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.EnablePhysicalConnectionResponse>(await this.callApi(params, req, runtime), new $_model.EnablePhysicalConnectionResponse({}));
  }

  /**
   * Enables an Express Connect circuit that is in the Confirmed state. After you perform this operation, the Express Connect circuit enters the Enabled state.
   * 
   * @remarks
   * When you call this operation, take note of the following limits:
   * *   You can enable only an Express Connect circuit that is in the **Confirmed** state.
   * *   After you enable an Express Connect circuit, it enters the **Enabled** state.
   * *   **EnablePhysicalConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribePhysicalConnections](https://help.aliyun.com/document_detail/36042.html) operation to query the status of the task.
   * *   You cannot repeatedly call **EnablePhysicalConnection** for an Express Connect circuit in the **Confirmed** state within a specific time period.
   * 
   * @param request - EnablePhysicalConnectionRequest
   * @returns EnablePhysicalConnectionResponse
   */
  async enablePhysicalConnection(request: $_model.EnablePhysicalConnectionRequest): Promise<$_model.EnablePhysicalConnectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.enablePhysicalConnectionWithOptions(request, runtime);
  }

  /**
   * Enables ClassicLink for a VPC.
   * 
   * @param request - EnableVpcClassicLinkRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnableVpcClassicLinkResponse
   */
  async enableVpcClassicLinkWithOptions(request: $_model.EnableVpcClassicLinkRequest, runtime: $dara.RuntimeOptions): Promise<$_model.EnableVpcClassicLinkResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "EnableVpcClassicLink",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.EnableVpcClassicLinkResponse>(await this.callApi(params, req, runtime), new $_model.EnableVpcClassicLinkResponse({}));
  }

  /**
   * Enables ClassicLink for a VPC.
   * 
   * @param request - EnableVpcClassicLinkRequest
   * @returns EnableVpcClassicLinkResponse
   */
  async enableVpcClassicLink(request: $_model.EnableVpcClassicLinkRequest): Promise<$_model.EnableVpcClassicLinkResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.enableVpcClassicLinkWithOptions(request, runtime);
  }

  /**
   * Activates an IPv4 gateway.
   * 
   * @remarks
   * ## [](#)Description
   * *   **EnableVpcIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway.
   *     *   If the IPv4 gateway is in the **Activating** state, the IPv4 gateway is being activated.
   *     *   If the IPv4 gateway is in the **Created** state, the IPv4 gateway is activated.
   * *   You cannot repeatedly call the **EnableVpcIpv4Gateway** operation to activate an IPv4 gateway within the specified period of time.
   * 
   * @param request - EnableVpcIpv4GatewayRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnableVpcIpv4GatewayResponse
   */
  async enableVpcIpv4GatewayWithOptions(request: $_model.EnableVpcIpv4GatewayRequest, runtime: $dara.RuntimeOptions): Promise<$_model.EnableVpcIpv4GatewayResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ipv4GatewayId)) {
      query["Ipv4GatewayId"] = request.ipv4GatewayId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeTableList)) {
      query["RouteTableList"] = request.routeTableList;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "EnableVpcIpv4Gateway",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.EnableVpcIpv4GatewayResponse>(await this.callApi(params, req, runtime), new $_model.EnableVpcIpv4GatewayResponse({}));
  }

  /**
   * Activates an IPv4 gateway.
   * 
   * @remarks
   * ## [](#)Description
   * *   **EnableVpcIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway.
   *     *   If the IPv4 gateway is in the **Activating** state, the IPv4 gateway is being activated.
   *     *   If the IPv4 gateway is in the **Created** state, the IPv4 gateway is activated.
   * *   You cannot repeatedly call the **EnableVpcIpv4Gateway** operation to activate an IPv4 gateway within the specified period of time.
   * 
   * @param request - EnableVpcIpv4GatewayRequest
   * @returns EnableVpcIpv4GatewayResponse
   */
  async enableVpcIpv4Gateway(request: $_model.EnableVpcIpv4GatewayRequest): Promise<$_model.EnableVpcIpv4GatewayResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.enableVpcIpv4GatewayWithOptions(request, runtime);
  }

  /**
   * Queries a DHCP options set.
   * 
   * @param request - GetDhcpOptionsSetRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDhcpOptionsSetResponse
   */
  async getDhcpOptionsSetWithOptions(request: $_model.GetDhcpOptionsSetRequest, runtime: $dara.RuntimeOptions): Promise<$_model.GetDhcpOptionsSetResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.dhcpOptionsSetId)) {
      query["DhcpOptionsSetId"] = request.dhcpOptionsSetId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetDhcpOptionsSet",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.GetDhcpOptionsSetResponse>(await this.callApi(params, req, runtime), new $_model.GetDhcpOptionsSetResponse({}));
  }

  /**
   * Queries a DHCP options set.
   * 
   * @param request - GetDhcpOptionsSetRequest
   * @returns GetDhcpOptionsSetResponse
   */
  async getDhcpOptionsSet(request: $_model.GetDhcpOptionsSetRequest): Promise<$_model.GetDhcpOptionsSetResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getDhcpOptionsSetWithOptions(request, runtime);
  }

  /**
   * Queries the status of a flow log.
   * 
   * @param request - GetFlowLogServiceStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetFlowLogServiceStatusResponse
   */
  async getFlowLogServiceStatusWithOptions(request: $_model.GetFlowLogServiceStatusRequest, runtime: $dara.RuntimeOptions): Promise<$_model.GetFlowLogServiceStatusResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetFlowLogServiceStatus",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.GetFlowLogServiceStatusResponse>(await this.callApi(params, req, runtime), new $_model.GetFlowLogServiceStatusResponse({}));
  }

  /**
   * Queries the status of a flow log.
   * 
   * @param request - GetFlowLogServiceStatusRequest
   * @returns GetFlowLogServiceStatusResponse
   */
  async getFlowLogServiceStatus(request: $_model.GetFlowLogServiceStatusRequest): Promise<$_model.GetFlowLogServiceStatusResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getFlowLogServiceStatusWithOptions(request, runtime);
  }

  /**
   * Queries an IPv4 gateway.
   * 
   * @param request - GetIpv4GatewayAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetIpv4GatewayAttributeResponse
   */
  async getIpv4GatewayAttributeWithOptions(request: $_model.GetIpv4GatewayAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.GetIpv4GatewayAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ipv4GatewayId)) {
      query["Ipv4GatewayId"] = request.ipv4GatewayId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetIpv4GatewayAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.GetIpv4GatewayAttributeResponse>(await this.callApi(params, req, runtime), new $_model.GetIpv4GatewayAttributeResponse({}));
  }

  /**
   * Queries an IPv4 gateway.
   * 
   * @param request - GetIpv4GatewayAttributeRequest
   * @returns GetIpv4GatewayAttributeResponse
   */
  async getIpv4GatewayAttribute(request: $_model.GetIpv4GatewayAttributeRequest): Promise<$_model.GetIpv4GatewayAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getIpv4GatewayAttributeWithOptions(request, runtime);
  }

  /**
   * NAT
   * 
   * @remarks
   * You can call this operation to query information about a specified Internet NAT gateway or Virtual Private Cloud (VPC) NAT gateway. In this topic, "NAT gateway" refers to both gateway types.
   * 
   * @param request - GetNatGatewayAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetNatGatewayAttributeResponse
   */
  async getNatGatewayAttributeWithOptions(request: $_model.GetNatGatewayAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.GetNatGatewayAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.natGatewayId)) {
      query["NatGatewayId"] = request.natGatewayId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetNatGatewayAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.GetNatGatewayAttributeResponse>(await this.callApi(params, req, runtime), new $_model.GetNatGatewayAttributeResponse({}));
  }

  /**
   * NAT
   * 
   * @remarks
   * You can call this operation to query information about a specified Internet NAT gateway or Virtual Private Cloud (VPC) NAT gateway. In this topic, "NAT gateway" refers to both gateway types.
   * 
   * @param request - GetNatGatewayAttributeRequest
   * @returns GetNatGatewayAttributeResponse
   */
  async getNatGatewayAttribute(request: $_model.GetNatGatewayAttributeRequest): Promise<$_model.GetNatGatewayAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getNatGatewayAttributeWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @remarks
   * You can call this API operation to query the status of outbound data transfer billing for the current account. For more information about outbound data transfer billing, see [Outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html) and [Billing](https://help.aliyun.com/document_detail/54582.html).
   * 
   * @param request - GetPhysicalConnectionServiceStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPhysicalConnectionServiceStatusResponse
   */
  async getPhysicalConnectionServiceStatusWithOptions(request: $_model.GetPhysicalConnectionServiceStatusRequest, runtime: $dara.RuntimeOptions): Promise<$_model.GetPhysicalConnectionServiceStatusResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetPhysicalConnectionServiceStatus",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.GetPhysicalConnectionServiceStatusResponse>(await this.callApi(params, req, runtime), new $_model.GetPhysicalConnectionServiceStatusResponse({}));
  }

  /**
   * 
   * 
   * @remarks
   * You can call this API operation to query the status of outbound data transfer billing for the current account. For more information about outbound data transfer billing, see [Outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html) and [Billing](https://help.aliyun.com/document_detail/54582.html).
   * 
   * @param request - GetPhysicalConnectionServiceStatusRequest
   * @returns GetPhysicalConnectionServiceStatusResponse
   */
  async getPhysicalConnectionServiceStatus(request: $_model.GetPhysicalConnectionServiceStatusRequest): Promise<$_model.GetPhysicalConnectionServiceStatusResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getPhysicalConnectionServiceStatusWithOptions(request, runtime);
  }

  /**
   * Queries whether the IP address pool feature is enabled.
   * 
   * @param request - GetPublicIpAddressPoolServiceStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPublicIpAddressPoolServiceStatusResponse
   */
  async getPublicIpAddressPoolServiceStatusWithOptions(request: $_model.GetPublicIpAddressPoolServiceStatusRequest, runtime: $dara.RuntimeOptions): Promise<$_model.GetPublicIpAddressPoolServiceStatusResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetPublicIpAddressPoolServiceStatus",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.GetPublicIpAddressPoolServiceStatusResponse>(await this.callApi(params, req, runtime), new $_model.GetPublicIpAddressPoolServiceStatusResponse({}));
  }

  /**
   * Queries whether the IP address pool feature is enabled.
   * 
   * @param request - GetPublicIpAddressPoolServiceStatusRequest
   * @returns GetPublicIpAddressPoolServiceStatusResponse
   */
  async getPublicIpAddressPoolServiceStatus(request: $_model.GetPublicIpAddressPoolServiceStatusRequest): Promise<$_model.GetPublicIpAddressPoolServiceStatusResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getPublicIpAddressPoolServiceStatusWithOptions(request, runtime);
  }

  /**
   * Queries the status of the traffic mirror feature.
   * 
   * @param request - GetTrafficMirrorServiceStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetTrafficMirrorServiceStatusResponse
   */
  async getTrafficMirrorServiceStatusWithOptions(request: $_model.GetTrafficMirrorServiceStatusRequest, runtime: $dara.RuntimeOptions): Promise<$_model.GetTrafficMirrorServiceStatusResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetTrafficMirrorServiceStatus",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.GetTrafficMirrorServiceStatusResponse>(await this.callApi(params, req, runtime), new $_model.GetTrafficMirrorServiceStatusResponse({}));
  }

  /**
   * Queries the status of the traffic mirror feature.
   * 
   * @param request - GetTrafficMirrorServiceStatusRequest
   * @returns GetTrafficMirrorServiceStatusResponse
   */
  async getTrafficMirrorServiceStatus(request: $_model.GetTrafficMirrorServiceStatusRequest): Promise<$_model.GetTrafficMirrorServiceStatusResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getTrafficMirrorServiceStatusWithOptions(request, runtime);
  }

  /**
   * Queries the usage of a prefix list.
   * 
   * @param request - GetVSwitchCidrReservationUsageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetVSwitchCidrReservationUsageResponse
   */
  async getVSwitchCidrReservationUsageWithOptions(request: $_model.GetVSwitchCidrReservationUsageRequest, runtime: $dara.RuntimeOptions): Promise<$_model.GetVSwitchCidrReservationUsageResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vSwitchCidrReservationId)) {
      query["VSwitchCidrReservationId"] = request.vSwitchCidrReservationId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetVSwitchCidrReservationUsage",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.GetVSwitchCidrReservationUsageResponse>(await this.callApi(params, req, runtime), new $_model.GetVSwitchCidrReservationUsageResponse({}));
  }

  /**
   * Queries the usage of a prefix list.
   * 
   * @param request - GetVSwitchCidrReservationUsageRequest
   * @returns GetVSwitchCidrReservationUsageResponse
   */
  async getVSwitchCidrReservationUsage(request: $_model.GetVSwitchCidrReservationUsageRequest): Promise<$_model.GetVSwitchCidrReservationUsageResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getVSwitchCidrReservationUsageWithOptions(request, runtime);
  }

  /**
   * Queries the attributes of a gateway endpoint.
   * 
   * @param request - GetVpcGatewayEndpointAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetVpcGatewayEndpointAttributeResponse
   */
  async getVpcGatewayEndpointAttributeWithOptions(request: $_model.GetVpcGatewayEndpointAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.GetVpcGatewayEndpointAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.endpointId)) {
      query["EndpointId"] = request.endpointId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetVpcGatewayEndpointAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.GetVpcGatewayEndpointAttributeResponse>(await this.callApi(params, req, runtime), new $_model.GetVpcGatewayEndpointAttributeResponse({}));
  }

  /**
   * Queries the attributes of a gateway endpoint.
   * 
   * @param request - GetVpcGatewayEndpointAttributeRequest
   * @returns GetVpcGatewayEndpointAttributeResponse
   */
  async getVpcGatewayEndpointAttribute(request: $_model.GetVpcGatewayEndpointAttributeRequest): Promise<$_model.GetVpcGatewayEndpointAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getVpcGatewayEndpointAttributeWithOptions(request, runtime);
  }

  /**
   * Queries the resources that are associated with a prefix list.
   * 
   * @param request - GetVpcPrefixListAssociationsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetVpcPrefixListAssociationsResponse
   */
  async getVpcPrefixListAssociationsWithOptions(request: $_model.GetVpcPrefixListAssociationsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.GetVpcPrefixListAssociationsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.prefixListId)) {
      query["PrefixListId"] = request.prefixListId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetVpcPrefixListAssociations",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.GetVpcPrefixListAssociationsResponse>(await this.callApi(params, req, runtime), new $_model.GetVpcPrefixListAssociationsResponse({}));
  }

  /**
   * Queries the resources that are associated with a prefix list.
   * 
   * @param request - GetVpcPrefixListAssociationsRequest
   * @returns GetVpcPrefixListAssociationsResponse
   */
  async getVpcPrefixListAssociations(request: $_model.GetVpcPrefixListAssociationsRequest): Promise<$_model.GetVpcPrefixListAssociationsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getVpcPrefixListAssociationsWithOptions(request, runtime);
  }

  /**
   * Queries the information about a prefix list.
   * 
   * @param request - GetVpcPrefixListEntriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetVpcPrefixListEntriesResponse
   */
  async getVpcPrefixListEntriesWithOptions(request: $_model.GetVpcPrefixListEntriesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.GetVpcPrefixListEntriesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.prefixListId)) {
      query["PrefixListId"] = request.prefixListId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetVpcPrefixListEntries",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.GetVpcPrefixListEntriesResponse>(await this.callApi(params, req, runtime), new $_model.GetVpcPrefixListEntriesResponse({}));
  }

  /**
   * Queries the information about a prefix list.
   * 
   * @param request - GetVpcPrefixListEntriesRequest
   * @returns GetVpcPrefixListEntriesResponse
   */
  async getVpcPrefixListEntries(request: $_model.GetVpcPrefixListEntriesRequest): Promise<$_model.GetVpcPrefixListEntriesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getVpcPrefixListEntriesWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - GetVpcRouteEntrySummaryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetVpcRouteEntrySummaryResponse
   */
  async getVpcRouteEntrySummaryWithOptions(request: $_model.GetVpcRouteEntrySummaryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.GetVpcRouteEntrySummaryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeEntryType)) {
      query["RouteEntryType"] = request.routeEntryType;
    }

    if (!$dara.isNull(request.routeTableId)) {
      query["RouteTableId"] = request.routeTableId;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetVpcRouteEntrySummary",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.GetVpcRouteEntrySummaryResponse>(await this.callApi(params, req, runtime), new $_model.GetVpcRouteEntrySummaryResponse({}));
  }

  /**
   * 
   * 
   * @param request - GetVpcRouteEntrySummaryRequest
   * @returns GetVpcRouteEntrySummaryResponse
   */
  async getVpcRouteEntrySummary(request: $_model.GetVpcRouteEntrySummaryRequest): Promise<$_model.GetVpcRouteEntrySummaryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getVpcRouteEntrySummaryWithOptions(request, runtime);
  }

  /**
   * Queries the diagnostic result of a VPN gateway.
   * 
   * @remarks
   * When you call the **GetVpnGatewayDiagnoseResult** operation, you must specify one of **DiagnoseId** and **VpnGatewayId**.
   * 
   * @param request - GetVpnGatewayDiagnoseResultRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetVpnGatewayDiagnoseResultResponse
   */
  async getVpnGatewayDiagnoseResultWithOptions(request: $_model.GetVpnGatewayDiagnoseResultRequest, runtime: $dara.RuntimeOptions): Promise<$_model.GetVpnGatewayDiagnoseResultResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.diagnoseId)) {
      query["DiagnoseId"] = request.diagnoseId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetVpnGatewayDiagnoseResult",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.GetVpnGatewayDiagnoseResultResponse>(await this.callApi(params, req, runtime), new $_model.GetVpnGatewayDiagnoseResultResponse({}));
  }

  /**
   * Queries the diagnostic result of a VPN gateway.
   * 
   * @remarks
   * When you call the **GetVpnGatewayDiagnoseResult** operation, you must specify one of **DiagnoseId** and **VpnGatewayId**.
   * 
   * @param request - GetVpnGatewayDiagnoseResultRequest
   * @returns GetVpnGatewayDiagnoseResultResponse
   */
  async getVpnGatewayDiagnoseResult(request: $_model.GetVpnGatewayDiagnoseResultRequest): Promise<$_model.GetVpnGatewayDiagnoseResultResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getVpnGatewayDiagnoseResultWithOptions(request, runtime);
  }

  /**
   * Grants permissions to a Cloud Enterprise Network (CEN) instance.
   * 
   * @remarks
   *   Before you can attach a network instance that belongs to another Alibaba Cloud account to your CEN instance, you must grant permissions to your CEN instance.
   * >  **GrantInstanceToCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use the `vpc.aliyuncs.com` domain name to call this operation. The API version is `2016-04-28`.
   * *   You cannot repeatedly call the **GrantInstanceToCen** operation to grant the permissions on a network instance to a CEN instance. The network instance can be a VPC, a virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
   * 
   * @param request - GrantInstanceToCenRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GrantInstanceToCenResponse
   */
  async grantInstanceToCenWithOptions(request: $_model.GrantInstanceToCenRequest, runtime: $dara.RuntimeOptions): Promise<$_model.GrantInstanceToCenResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.cenId)) {
      query["CenId"] = request.cenId;
    }

    if (!$dara.isNull(request.cenOwnerId)) {
      query["CenOwnerId"] = request.cenOwnerId;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GrantInstanceToCen",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.GrantInstanceToCenResponse>(await this.callApi(params, req, runtime), new $_model.GrantInstanceToCenResponse({}));
  }

  /**
   * Grants permissions to a Cloud Enterprise Network (CEN) instance.
   * 
   * @remarks
   *   Before you can attach a network instance that belongs to another Alibaba Cloud account to your CEN instance, you must grant permissions to your CEN instance.
   * >  **GrantInstanceToCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use the `vpc.aliyuncs.com` domain name to call this operation. The API version is `2016-04-28`.
   * *   You cannot repeatedly call the **GrantInstanceToCen** operation to grant the permissions on a network instance to a CEN instance. The network instance can be a VPC, a virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
   * 
   * @param request - GrantInstanceToCenRequest
   * @returns GrantInstanceToCenResponse
   */
  async grantInstanceToCen(request: $_model.GrantInstanceToCenRequest): Promise<$_model.GrantInstanceToCenResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.grantInstanceToCenWithOptions(request, runtime);
  }

  /**
   * Grants a virtual border router (VBR) the permissions to connect to a virtual private cloud (VPC) that belongs to another Alibaba Cloud account.
   * 
   * @remarks
   * ## Usage notes
   * When you connect a VBR to a VPC that belongs to another Alibaba Cloud account, the VBR must acquire the required permissions from the VPC.
   * 
   * @param tmpReq - GrantInstanceToVbrRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GrantInstanceToVbrResponse
   */
  async grantInstanceToVbrWithOptions(tmpReq: $_model.GrantInstanceToVbrRequest, runtime: $dara.RuntimeOptions): Promise<$_model.GrantInstanceToVbrResponse> {
    tmpReq.validate();
    let request = new $_model.GrantInstanceToVbrShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.vbrInstanceIds)) {
      request.vbrInstanceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.vbrInstanceIds, "VbrInstanceIds", "simple");
    }

    let query = { };
    if (!$dara.isNull(request.grantType)) {
      query["GrantType"] = request.grantType;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.vbrInstanceIdsShrink)) {
      query["VbrInstanceIds"] = request.vbrInstanceIdsShrink;
    }

    if (!$dara.isNull(request.vbrOwnerUid)) {
      query["VbrOwnerUid"] = request.vbrOwnerUid;
    }

    if (!$dara.isNull(request.vbrRegionNo)) {
      query["VbrRegionNo"] = request.vbrRegionNo;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GrantInstanceToVbr",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.GrantInstanceToVbrResponse>(await this.callApi(params, req, runtime), new $_model.GrantInstanceToVbrResponse({}));
  }

  /**
   * Grants a virtual border router (VBR) the permissions to connect to a virtual private cloud (VPC) that belongs to another Alibaba Cloud account.
   * 
   * @remarks
   * ## Usage notes
   * When you connect a VBR to a VPC that belongs to another Alibaba Cloud account, the VBR must acquire the required permissions from the VPC.
   * 
   * @param request - GrantInstanceToVbrRequest
   * @returns GrantInstanceToVbrResponse
   */
  async grantInstanceToVbr(request: $_model.GrantInstanceToVbrRequest): Promise<$_model.GrantInstanceToVbrResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.grantInstanceToVbrWithOptions(request, runtime);
  }

  /**
   * Queries the access points of an Express Connect circuit.
   * 
   * @param request - ListBusinessAccessPointsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListBusinessAccessPointsResponse
   */
  async listBusinessAccessPointsWithOptions(request: $_model.ListBusinessAccessPointsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListBusinessAccessPointsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListBusinessAccessPoints",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListBusinessAccessPointsResponse>(await this.callApi(params, req, runtime), new $_model.ListBusinessAccessPointsResponse({}));
  }

  /**
   * Queries the access points of an Express Connect circuit.
   * 
   * @param request - ListBusinessAccessPointsRequest
   * @returns ListBusinessAccessPointsResponse
   */
  async listBusinessAccessPoints(request: $_model.ListBusinessAccessPointsRequest): Promise<$_model.ListBusinessAccessPointsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listBusinessAccessPointsWithOptions(request, runtime);
  }

  /**
   * Queries Dynamic Host Configuration Protocol (DHCP) options sets.
   * 
   * @param request - ListDhcpOptionsSetsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDhcpOptionsSetsResponse
   */
  async listDhcpOptionsSetsWithOptions(request: $_model.ListDhcpOptionsSetsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListDhcpOptionsSetsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.dhcpOptionsSetId)) {
      query["DhcpOptionsSetId"] = request.dhcpOptionsSetId;
    }

    if (!$dara.isNull(request.dhcpOptionsSetName)) {
      query["DhcpOptionsSetName"] = request.dhcpOptionsSetName;
    }

    if (!$dara.isNull(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListDhcpOptionsSets",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListDhcpOptionsSetsResponse>(await this.callApi(params, req, runtime), new $_model.ListDhcpOptionsSetsResponse({}));
  }

  /**
   * Queries Dynamic Host Configuration Protocol (DHCP) options sets.
   * 
   * @param request - ListDhcpOptionsSetsRequest
   * @returns ListDhcpOptionsSetsResponse
   */
  async listDhcpOptionsSets(request: $_model.ListDhcpOptionsSetsRequest): Promise<$_model.ListDhcpOptionsSetsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listDhcpOptionsSetsWithOptions(request, runtime);
  }

  /**
   * Queries the zones that support NAT gateways.
   * 
   * @remarks
   * You can call this operation to query zones that support NAT gateways, including Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways.
   * 
   * @param request - ListEnhanhcedNatGatewayAvailableZonesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEnhanhcedNatGatewayAvailableZonesResponse
   */
  async listEnhanhcedNatGatewayAvailableZonesWithOptions(request: $_model.ListEnhanhcedNatGatewayAvailableZonesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListEnhanhcedNatGatewayAvailableZonesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!$dara.isNull(request.filter)) {
      query["Filter"] = request.filter;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListEnhanhcedNatGatewayAvailableZones",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListEnhanhcedNatGatewayAvailableZonesResponse>(await this.callApi(params, req, runtime), new $_model.ListEnhanhcedNatGatewayAvailableZonesResponse({}));
  }

  /**
   * Queries the zones that support NAT gateways.
   * 
   * @remarks
   * You can call this operation to query zones that support NAT gateways, including Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways.
   * 
   * @param request - ListEnhanhcedNatGatewayAvailableZonesRequest
   * @returns ListEnhanhcedNatGatewayAvailableZonesResponse
   */
  async listEnhanhcedNatGatewayAvailableZones(request: $_model.ListEnhanhcedNatGatewayAvailableZonesRequest): Promise<$_model.ListEnhanhcedNatGatewayAvailableZonesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listEnhanhcedNatGatewayAvailableZonesWithOptions(request, runtime);
  }

  /**
   * Queries FULLNAT entries.
   * 
   * @param request - ListFullNatEntriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListFullNatEntriesResponse
   */
  async listFullNatEntriesWithOptions(request: $_model.ListFullNatEntriesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListFullNatEntriesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.fullNatEntryId)) {
      query["FullNatEntryId"] = request.fullNatEntryId;
    }

    if (!$dara.isNull(request.fullNatEntryNames)) {
      query["FullNatEntryNames"] = request.fullNatEntryNames;
    }

    if (!$dara.isNull(request.fullNatTableId)) {
      query["FullNatTableId"] = request.fullNatTableId;
    }

    if (!$dara.isNull(request.ipProtocol)) {
      query["IpProtocol"] = request.ipProtocol;
    }

    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.natGatewayId)) {
      query["NatGatewayId"] = request.natGatewayId;
    }

    if (!$dara.isNull(request.natIp)) {
      query["NatIp"] = request.natIp;
    }

    if (!$dara.isNull(request.natIpPort)) {
      query["NatIpPort"] = request.natIpPort;
    }

    if (!$dara.isNull(request.networkInterfaceIds)) {
      query["NetworkInterfaceIds"] = request.networkInterfaceIds;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListFullNatEntries",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListFullNatEntriesResponse>(await this.callApi(params, req, runtime), new $_model.ListFullNatEntriesResponse({}));
  }

  /**
   * Queries FULLNAT entries.
   * 
   * @param request - ListFullNatEntriesRequest
   * @returns ListFullNatEntriesResponse
   */
  async listFullNatEntries(request: $_model.ListFullNatEntriesRequest): Promise<$_model.ListFullNatEntriesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listFullNatEntriesWithOptions(request, runtime);
  }

  /**
   * Queries route entries of a gateway route table.
   * 
   * @param request - ListGatewayRouteTableEntriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListGatewayRouteTableEntriesResponse
   */
  async listGatewayRouteTableEntriesWithOptions(request: $_model.ListGatewayRouteTableEntriesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListGatewayRouteTableEntriesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.destinationCidrBlock)) {
      query["DestinationCidrBlock"] = request.destinationCidrBlock;
    }

    if (!$dara.isNull(request.gatewayRouteTableId)) {
      query["GatewayRouteTableId"] = request.gatewayRouteTableId;
    }

    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListGatewayRouteTableEntries",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListGatewayRouteTableEntriesResponse>(await this.callApi(params, req, runtime), new $_model.ListGatewayRouteTableEntriesResponse({}));
  }

  /**
   * Queries route entries of a gateway route table.
   * 
   * @param request - ListGatewayRouteTableEntriesRequest
   * @returns ListGatewayRouteTableEntriesResponse
   */
  async listGatewayRouteTableEntries(request: $_model.ListGatewayRouteTableEntriesRequest): Promise<$_model.ListGatewayRouteTableEntriesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listGatewayRouteTableEntriesWithOptions(request, runtime);
  }

  /**
   * Queries the most recent region list.
   * 
   * @param request - ListGeographicSubRegionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListGeographicSubRegionsResponse
   */
  async listGeographicSubRegionsWithOptions(runtime: $dara.RuntimeOptions): Promise<$_model.ListGeographicSubRegionsResponse> {
    let req = new $OpenApiUtil.OpenApiRequest({ });
    let params = new $OpenApiUtil.Params({
      action: "ListGeographicSubRegions",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListGeographicSubRegionsResponse>(await this.callApi(params, req, runtime), new $_model.ListGeographicSubRegionsResponse({}));
  }

  /**
   * Queries the most recent region list.
   * @returns ListGeographicSubRegionsResponse
   */
  async listGeographicSubRegions(): Promise<$_model.ListGeographicSubRegionsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listGeographicSubRegionsWithOptions(runtime);
  }

  /**
   * Queries the logs of an IPsec server.
   * 
   * @param request - ListIpsecServerLogsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListIpsecServerLogsResponse
   */
  async listIpsecServerLogsWithOptions(request: $_model.ListIpsecServerLogsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListIpsecServerLogsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.from)) {
      query["From"] = request.from;
    }

    if (!$dara.isNull(request.ipsecServerId)) {
      query["IpsecServerId"] = request.ipsecServerId;
    }

    if (!$dara.isNull(request.minutePeriod)) {
      query["MinutePeriod"] = request.minutePeriod;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.to)) {
      query["To"] = request.to;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListIpsecServerLogs",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListIpsecServerLogsResponse>(await this.callApi(params, req, runtime), new $_model.ListIpsecServerLogsResponse({}));
  }

  /**
   * Queries the logs of an IPsec server.
   * 
   * @param request - ListIpsecServerLogsRequest
   * @returns ListIpsecServerLogsResponse
   */
  async listIpsecServerLogs(request: $_model.ListIpsecServerLogsRequest): Promise<$_model.ListIpsecServerLogsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listIpsecServerLogsWithOptions(request, runtime);
  }

  /**
   * Queries IPsec servers.
   * 
   * @param request - ListIpsecServersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListIpsecServersResponse
   */
  async listIpsecServersWithOptions(request: $_model.ListIpsecServersRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListIpsecServersResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ipsecServerId)) {
      query["IpsecServerId"] = request.ipsecServerId;
    }

    if (!$dara.isNull(request.ipsecServerName)) {
      query["IpsecServerName"] = request.ipsecServerName;
    }

    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListIpsecServers",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListIpsecServersResponse>(await this.callApi(params, req, runtime), new $_model.ListIpsecServersResponse({}));
  }

  /**
   * Queries IPsec servers.
   * 
   * @param request - ListIpsecServersRequest
   * @returns ListIpsecServersResponse
   */
  async listIpsecServers(request: $_model.ListIpsecServersRequest): Promise<$_model.ListIpsecServersResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listIpsecServersWithOptions(request, runtime);
  }

  /**
   * Queries IPv4 gateways.
   * 
   * @param request - ListIpv4GatewaysRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListIpv4GatewaysResponse
   */
  async listIpv4GatewaysWithOptions(request: $_model.ListIpv4GatewaysRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListIpv4GatewaysResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ipv4GatewayId)) {
      query["Ipv4GatewayId"] = request.ipv4GatewayId;
    }

    if (!$dara.isNull(request.ipv4GatewayName)) {
      query["Ipv4GatewayName"] = request.ipv4GatewayName;
    }

    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListIpv4Gateways",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListIpv4GatewaysResponse>(await this.callApi(params, req, runtime), new $_model.ListIpv4GatewaysResponse({}));
  }

  /**
   * Queries IPv4 gateways.
   * 
   * @param request - ListIpv4GatewaysRequest
   * @returns ListIpv4GatewaysResponse
   */
  async listIpv4Gateways(request: $_model.ListIpv4GatewaysRequest): Promise<$_model.ListIpv4GatewaysResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listIpv4GatewaysWithOptions(request, runtime);
  }

  /**
   * Queries the CIDR blocks of a specified NAT gateway.
   * 
   * @param request - ListNatIpCidrsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListNatIpCidrsResponse
   */
  async listNatIpCidrsWithOptions(request: $_model.ListNatIpCidrsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListNatIpCidrsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.natGatewayId)) {
      query["NatGatewayId"] = request.natGatewayId;
    }

    if (!$dara.isNull(request.natIpCidr)) {
      query["NatIpCidr"] = request.natIpCidr;
    }

    if (!$dara.isNull(request.natIpCidrName)) {
      query["NatIpCidrName"] = request.natIpCidrName;
    }

    if (!$dara.isNull(request.natIpCidrStatus)) {
      query["NatIpCidrStatus"] = request.natIpCidrStatus;
    }

    if (!$dara.isNull(request.natIpCidrs)) {
      query["NatIpCidrs"] = request.natIpCidrs;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListNatIpCidrs",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListNatIpCidrsResponse>(await this.callApi(params, req, runtime), new $_model.ListNatIpCidrsResponse({}));
  }

  /**
   * Queries the CIDR blocks of a specified NAT gateway.
   * 
   * @param request - ListNatIpCidrsRequest
   * @returns ListNatIpCidrsResponse
   */
  async listNatIpCidrs(request: $_model.ListNatIpCidrsRequest): Promise<$_model.ListNatIpCidrsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listNatIpCidrsWithOptions(request, runtime);
  }

  /**
   * Queries the IP addresses on a NAT gateway.
   * 
   * @param request - ListNatIpsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListNatIpsResponse
   */
  async listNatIpsWithOptions(request: $_model.ListNatIpsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListNatIpsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.natGatewayId)) {
      query["NatGatewayId"] = request.natGatewayId;
    }

    if (!$dara.isNull(request.natIpCidr)) {
      query["NatIpCidr"] = request.natIpCidr;
    }

    if (!$dara.isNull(request.natIpIds)) {
      query["NatIpIds"] = request.natIpIds;
    }

    if (!$dara.isNull(request.natIpName)) {
      query["NatIpName"] = request.natIpName;
    }

    if (!$dara.isNull(request.natIpStatus)) {
      query["NatIpStatus"] = request.natIpStatus;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListNatIps",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListNatIpsResponse>(await this.callApi(params, req, runtime), new $_model.ListNatIpsResponse({}));
  }

  /**
   * Queries the IP addresses on a NAT gateway.
   * 
   * @param request - ListNatIpsRequest
   * @returns ListNatIpsResponse
   */
  async listNatIps(request: $_model.ListNatIpsRequest): Promise<$_model.ListNatIpsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listNatIpsWithOptions(request, runtime);
  }

  /**
   * Queries prefix lists.
   * 
   * @param request - ListPrefixListsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPrefixListsResponse
   */
  async listPrefixListsWithOptions(request: $_model.ListPrefixListsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListPrefixListsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.prefixListIds)) {
      query["PrefixListIds"] = request.prefixListIds;
    }

    if (!$dara.isNull(request.prefixListName)) {
      query["PrefixListName"] = request.prefixListName;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListPrefixLists",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListPrefixListsResponse>(await this.callApi(params, req, runtime), new $_model.ListPrefixListsResponse({}));
  }

  /**
   * Queries prefix lists.
   * 
   * @param request - ListPrefixListsRequest
   * @returns ListPrefixListsResponse
   */
  async listPrefixLists(request: $_model.ListPrefixListsRequest): Promise<$_model.ListPrefixListsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listPrefixListsWithOptions(request, runtime);
  }

  /**
   * IPIP
   * 
   * @param request - ListPublicIpAddressPoolCidrBlocksRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPublicIpAddressPoolCidrBlocksResponse
   */
  async listPublicIpAddressPoolCidrBlocksWithOptions(request: $_model.ListPublicIpAddressPoolCidrBlocksRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListPublicIpAddressPoolCidrBlocksResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.cidrBlock)) {
      query["CidrBlock"] = request.cidrBlock;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.publicIpAddressPoolId)) {
      query["PublicIpAddressPoolId"] = request.publicIpAddressPoolId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListPublicIpAddressPoolCidrBlocks",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListPublicIpAddressPoolCidrBlocksResponse>(await this.callApi(params, req, runtime), new $_model.ListPublicIpAddressPoolCidrBlocksResponse({}));
  }

  /**
   * IPIP
   * 
   * @param request - ListPublicIpAddressPoolCidrBlocksRequest
   * @returns ListPublicIpAddressPoolCidrBlocksResponse
   */
  async listPublicIpAddressPoolCidrBlocks(request: $_model.ListPublicIpAddressPoolCidrBlocksRequest): Promise<$_model.ListPublicIpAddressPoolCidrBlocksResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listPublicIpAddressPoolCidrBlocksWithOptions(request, runtime);
  }

  /**
   * Queries available IP address pools.
   * 
   * @param request - ListPublicIpAddressPoolsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPublicIpAddressPoolsResponse
   */
  async listPublicIpAddressPoolsWithOptions(request: $_model.ListPublicIpAddressPoolsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListPublicIpAddressPoolsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.isp)) {
      query["Isp"] = request.isp;
    }

    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.publicIpAddressPoolIds)) {
      query["PublicIpAddressPoolIds"] = request.publicIpAddressPoolIds;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.securityProtectionEnabled)) {
      query["SecurityProtectionEnabled"] = request.securityProtectionEnabled;
    }

    if (!$dara.isNull(request.status)) {
      query["Status"] = request.status;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListPublicIpAddressPools",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListPublicIpAddressPoolsResponse>(await this.callApi(params, req, runtime), new $_model.ListPublicIpAddressPoolsResponse({}));
  }

  /**
   * Queries available IP address pools.
   * 
   * @param request - ListPublicIpAddressPoolsRequest
   * @returns ListPublicIpAddressPoolsResponse
   */
  async listPublicIpAddressPools(request: $_model.ListPublicIpAddressPoolsRequest): Promise<$_model.ListPublicIpAddressPoolsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listPublicIpAddressPoolsWithOptions(request, runtime);
  }

  /**
   * Queries the tags that are added to resources.
   * 
   * @remarks
   * ## Usage notes
   * *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
   * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
   * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
   * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
   * 
   * @param request - ListTagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTagResourcesResponse
   */
  async listTagResourcesWithOptions(request: $_model.ListTagResourcesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListTagResourcesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListTagResources",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListTagResourcesResponse>(await this.callApi(params, req, runtime), new $_model.ListTagResourcesResponse({}));
  }

  /**
   * Queries the tags that are added to resources.
   * 
   * @remarks
   * ## Usage notes
   * *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
   * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
   * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
   * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
   * 
   * @param request - ListTagResourcesRequest
   * @returns ListTagResourcesResponse
   */
  async listTagResources(request: $_model.ListTagResourcesRequest): Promise<$_model.ListTagResourcesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listTagResourcesWithOptions(request, runtime);
  }

  /**
   * Queries the tags that are added to an Express Connect circuit.
   * 
   * @remarks
   * ## [](#)
   * *   If you want to query a specific object, you must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request.
   * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
   * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
   * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
   * 
   * @param request - ListTagResourcesForExpressConnectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTagResourcesForExpressConnectResponse
   */
  async listTagResourcesForExpressConnectWithOptions(request: $_model.ListTagResourcesForExpressConnectRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListTagResourcesForExpressConnectResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListTagResourcesForExpressConnect",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListTagResourcesForExpressConnectResponse>(await this.callApi(params, req, runtime), new $_model.ListTagResourcesForExpressConnectResponse({}));
  }

  /**
   * Queries the tags that are added to an Express Connect circuit.
   * 
   * @remarks
   * ## [](#)
   * *   If you want to query a specific object, you must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request.
   * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
   * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
   * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
   * 
   * @param request - ListTagResourcesForExpressConnectRequest
   * @returns ListTagResourcesForExpressConnectResponse
   */
  async listTagResourcesForExpressConnect(request: $_model.ListTagResourcesForExpressConnectRequest): Promise<$_model.ListTagResourcesForExpressConnectResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listTagResourcesForExpressConnectWithOptions(request, runtime);
  }

  /**
   * Queries filters for traffic mirror.
   * 
   * @param request - ListTrafficMirrorFiltersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTrafficMirrorFiltersResponse
   */
  async listTrafficMirrorFiltersWithOptions(request: $_model.ListTrafficMirrorFiltersRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListTrafficMirrorFiltersResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    if (!$dara.isNull(request.trafficMirrorFilterIds)) {
      query["TrafficMirrorFilterIds"] = request.trafficMirrorFilterIds;
    }

    if (!$dara.isNull(request.trafficMirrorFilterName)) {
      query["TrafficMirrorFilterName"] = request.trafficMirrorFilterName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListTrafficMirrorFilters",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListTrafficMirrorFiltersResponse>(await this.callApi(params, req, runtime), new $_model.ListTrafficMirrorFiltersResponse({}));
  }

  /**
   * Queries filters for traffic mirror.
   * 
   * @param request - ListTrafficMirrorFiltersRequest
   * @returns ListTrafficMirrorFiltersResponse
   */
  async listTrafficMirrorFilters(request: $_model.ListTrafficMirrorFiltersRequest): Promise<$_model.ListTrafficMirrorFiltersResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listTrafficMirrorFiltersWithOptions(request, runtime);
  }

  /**
   * Queries the details of a traffic mirror session.
   * 
   * @param request - ListTrafficMirrorSessionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTrafficMirrorSessionsResponse
   */
  async listTrafficMirrorSessionsWithOptions(request: $_model.ListTrafficMirrorSessionsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListTrafficMirrorSessionsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.enabled)) {
      query["Enabled"] = request.enabled;
    }

    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.priority)) {
      query["Priority"] = request.priority;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    if (!$dara.isNull(request.trafficMirrorFilterId)) {
      query["TrafficMirrorFilterId"] = request.trafficMirrorFilterId;
    }

    if (!$dara.isNull(request.trafficMirrorSessionIds)) {
      query["TrafficMirrorSessionIds"] = request.trafficMirrorSessionIds;
    }

    if (!$dara.isNull(request.trafficMirrorSessionName)) {
      query["TrafficMirrorSessionName"] = request.trafficMirrorSessionName;
    }

    if (!$dara.isNull(request.trafficMirrorSourceId)) {
      query["TrafficMirrorSourceId"] = request.trafficMirrorSourceId;
    }

    if (!$dara.isNull(request.trafficMirrorTargetId)) {
      query["TrafficMirrorTargetId"] = request.trafficMirrorTargetId;
    }

    if (!$dara.isNull(request.virtualNetworkId)) {
      query["VirtualNetworkId"] = request.virtualNetworkId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListTrafficMirrorSessions",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListTrafficMirrorSessionsResponse>(await this.callApi(params, req, runtime), new $_model.ListTrafficMirrorSessionsResponse({}));
  }

  /**
   * Queries the details of a traffic mirror session.
   * 
   * @param request - ListTrafficMirrorSessionsRequest
   * @returns ListTrafficMirrorSessionsResponse
   */
  async listTrafficMirrorSessions(request: $_model.ListTrafficMirrorSessionsRequest): Promise<$_model.ListTrafficMirrorSessionsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listTrafficMirrorSessionsWithOptions(request, runtime);
  }

  /**
   * Queries the CIDR reservation information about vSwitches.
   * 
   * @param request - ListVSwitchCidrReservationsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListVSwitchCidrReservationsResponse
   */
  async listVSwitchCidrReservationsWithOptions(request: $_model.ListVSwitchCidrReservationsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListVSwitchCidrReservationsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ipVersion)) {
      query["IpVersion"] = request.ipVersion;
    }

    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    if (!$dara.isNull(request.vSwitchCidrReservationIds)) {
      query["VSwitchCidrReservationIds"] = request.vSwitchCidrReservationIds;
    }

    if (!$dara.isNull(request.vSwitchCidrReservationType)) {
      query["VSwitchCidrReservationType"] = request.vSwitchCidrReservationType;
    }

    if (!$dara.isNull(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListVSwitchCidrReservations",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListVSwitchCidrReservationsResponse>(await this.callApi(params, req, runtime), new $_model.ListVSwitchCidrReservationsResponse({}));
  }

  /**
   * Queries the CIDR reservation information about vSwitches.
   * 
   * @param request - ListVSwitchCidrReservationsRequest
   * @returns ListVSwitchCidrReservationsResponse
   */
  async listVSwitchCidrReservations(request: $_model.ListVSwitchCidrReservationsRequest): Promise<$_model.ListVSwitchCidrReservationsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listVSwitchCidrReservationsWithOptions(request, runtime);
  }

  /**
   * Queries hosted connections.
   * 
   * @param request - ListVirtualPhysicalConnectionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListVirtualPhysicalConnectionsResponse
   */
  async listVirtualPhysicalConnectionsWithOptions(request: $_model.ListVirtualPhysicalConnectionsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListVirtualPhysicalConnectionsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.isConfirmed)) {
      query["IsConfirmed"] = request.isConfirmed;
    }

    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.physicalConnectionId)) {
      query["PhysicalConnectionId"] = request.physicalConnectionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    if (!$dara.isNull(request.virtualPhysicalConnectionAliUids)) {
      query["VirtualPhysicalConnectionAliUids"] = request.virtualPhysicalConnectionAliUids;
    }

    if (!$dara.isNull(request.virtualPhysicalConnectionBusinessStatus)) {
      query["VirtualPhysicalConnectionBusinessStatus"] = request.virtualPhysicalConnectionBusinessStatus;
    }

    if (!$dara.isNull(request.virtualPhysicalConnectionIds)) {
      query["VirtualPhysicalConnectionIds"] = request.virtualPhysicalConnectionIds;
    }

    if (!$dara.isNull(request.virtualPhysicalConnectionStatuses)) {
      query["VirtualPhysicalConnectionStatuses"] = request.virtualPhysicalConnectionStatuses;
    }

    if (!$dara.isNull(request.vlanIds)) {
      query["VlanIds"] = request.vlanIds;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListVirtualPhysicalConnections",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListVirtualPhysicalConnectionsResponse>(await this.callApi(params, req, runtime), new $_model.ListVirtualPhysicalConnectionsResponse({}));
  }

  /**
   * Queries hosted connections.
   * 
   * @param request - ListVirtualPhysicalConnectionsRequest
   * @returns ListVirtualPhysicalConnectionsResponse
   */
  async listVirtualPhysicalConnections(request: $_model.ListVirtualPhysicalConnectionsRequest): Promise<$_model.ListVirtualPhysicalConnectionsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listVirtualPhysicalConnectionsWithOptions(request, runtime);
  }

  /**
   * Queries available endpoint services.
   * 
   * @param request - ListVpcEndpointServicesByEndUserRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListVpcEndpointServicesByEndUserResponse
   */
  async listVpcEndpointServicesByEndUserWithOptions(request: $_model.ListVpcEndpointServicesByEndUserRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListVpcEndpointServicesByEndUserResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.serviceName)) {
      query["ServiceName"] = request.serviceName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListVpcEndpointServicesByEndUser",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListVpcEndpointServicesByEndUserResponse>(await this.callApi(params, req, runtime), new $_model.ListVpcEndpointServicesByEndUserResponse({}));
  }

  /**
   * Queries available endpoint services.
   * 
   * @param request - ListVpcEndpointServicesByEndUserRequest
   * @returns ListVpcEndpointServicesByEndUserResponse
   */
  async listVpcEndpointServicesByEndUser(request: $_model.ListVpcEndpointServicesByEndUserRequest): Promise<$_model.ListVpcEndpointServicesByEndUserResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listVpcEndpointServicesByEndUserWithOptions(request, runtime);
  }

  /**
   * Queries gateway endpoints.
   * 
   * @param request - ListVpcGatewayEndpointsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListVpcGatewayEndpointsResponse
   */
  async listVpcGatewayEndpointsWithOptions(request: $_model.ListVpcGatewayEndpointsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListVpcGatewayEndpointsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.endpointId)) {
      query["EndpointId"] = request.endpointId;
    }

    if (!$dara.isNull(request.endpointName)) {
      query["EndpointName"] = request.endpointName;
    }

    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.serviceName)) {
      query["ServiceName"] = request.serviceName;
    }

    if (!$dara.isNull(request.tags)) {
      query["Tags"] = request.tags;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListVpcGatewayEndpoints",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListVpcGatewayEndpointsResponse>(await this.callApi(params, req, runtime), new $_model.ListVpcGatewayEndpointsResponse({}));
  }

  /**
   * Queries gateway endpoints.
   * 
   * @param request - ListVpcGatewayEndpointsRequest
   * @returns ListVpcGatewayEndpointsResponse
   */
  async listVpcGatewayEndpoints(request: $_model.ListVpcGatewayEndpointsRequest): Promise<$_model.ListVpcGatewayEndpointsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listVpcGatewayEndpointsWithOptions(request, runtime);
  }

  /**
   * Queries advertised routes.
   * 
   * @param request - ListVpcPublishedRouteEntriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListVpcPublishedRouteEntriesResponse
   */
  async listVpcPublishedRouteEntriesWithOptions(request: $_model.ListVpcPublishedRouteEntriesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListVpcPublishedRouteEntriesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.destinationCidrBlock)) {
      query["DestinationCidrBlock"] = request.destinationCidrBlock;
    }

    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeTableId)) {
      query["RouteTableId"] = request.routeTableId;
    }

    if (!$dara.isNull(request.targetInstanceId)) {
      query["TargetInstanceId"] = request.targetInstanceId;
    }

    if (!$dara.isNull(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListVpcPublishedRouteEntries",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListVpcPublishedRouteEntriesResponse>(await this.callApi(params, req, runtime), new $_model.ListVpcPublishedRouteEntriesResponse({}));
  }

  /**
   * Queries advertised routes.
   * 
   * @param request - ListVpcPublishedRouteEntriesRequest
   * @returns ListVpcPublishedRouteEntriesResponse
   */
  async listVpcPublishedRouteEntries(request: $_model.ListVpcPublishedRouteEntriesRequest): Promise<$_model.ListVpcPublishedRouteEntriesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listVpcPublishedRouteEntriesWithOptions(request, runtime);
  }

  /**
   * Queries the association between VPN gateways and certificates in a region.
   * 
   * @remarks
   * When you call **ListVpnCertificateAssociations**, take note of the following information:
   * *   If you specify only **RegionId**, the SSL certificates associated with all VPN gateways in the specified region are queried.
   * *   If you specify **RegionId** and **CertificateType**, the SSL certificates of the specified type that are associated with the VPN gateways in the specified region are queried.
   * *   If you specify **RegionId** and **VpnGatewayId**, the SSL certificates associated with the specified VPN gateway in the specified region are queried.
   * *   If you specify **RegionId** and **CertificateId**, the VPN gateways associated with the specified SSL certificate in the specified region are queried.
   * 
   * @param request - ListVpnCertificateAssociationsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListVpnCertificateAssociationsResponse
   */
  async listVpnCertificateAssociationsWithOptions(request: $_model.ListVpnCertificateAssociationsRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ListVpnCertificateAssociationsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.certificateId)) {
      query["CertificateId"] = request.certificateId;
    }

    if (!$dara.isNull(request.certificateType)) {
      query["CertificateType"] = request.certificateType;
    }

    if (!$dara.isNull(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListVpnCertificateAssociations",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ListVpnCertificateAssociationsResponse>(await this.callApi(params, req, runtime), new $_model.ListVpnCertificateAssociationsResponse({}));
  }

  /**
   * Queries the association between VPN gateways and certificates in a region.
   * 
   * @remarks
   * When you call **ListVpnCertificateAssociations**, take note of the following information:
   * *   If you specify only **RegionId**, the SSL certificates associated with all VPN gateways in the specified region are queried.
   * *   If you specify **RegionId** and **CertificateType**, the SSL certificates of the specified type that are associated with the VPN gateways in the specified region are queried.
   * *   If you specify **RegionId** and **VpnGatewayId**, the SSL certificates associated with the specified VPN gateway in the specified region are queried.
   * *   If you specify **RegionId** and **CertificateId**, the VPN gateways associated with the specified SSL certificate in the specified region are queried.
   * 
   * @param request - ListVpnCertificateAssociationsRequest
   * @returns ListVpnCertificateAssociationsResponse
   */
  async listVpnCertificateAssociations(request: $_model.ListVpnCertificateAssociationsRequest): Promise<$_model.ListVpnCertificateAssociationsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listVpnCertificateAssociationsWithOptions(request, runtime);
  }

  /**
   * Modifies the configuration of a Border Gateway Protocol (BGP) group.
   * 
   * @param request - ModifyBgpGroupAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyBgpGroupAttributeResponse
   */
  async modifyBgpGroupAttributeWithOptions(request: $_model.ModifyBgpGroupAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyBgpGroupAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.authKey)) {
      query["AuthKey"] = request.authKey;
    }

    if (!$dara.isNull(request.bgpGroupId)) {
      query["BgpGroupId"] = request.bgpGroupId;
    }

    if (!$dara.isNull(request.clearAuthKey)) {
      query["ClearAuthKey"] = request.clearAuthKey;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.isFakeAsn)) {
      query["IsFakeAsn"] = request.isFakeAsn;
    }

    if (!$dara.isNull(request.localAsn)) {
      query["LocalAsn"] = request.localAsn;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.peerAsn)) {
      query["PeerAsn"] = request.peerAsn;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeQuota)) {
      query["RouteQuota"] = request.routeQuota;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyBgpGroupAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyBgpGroupAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyBgpGroupAttributeResponse({}));
  }

  /**
   * Modifies the configuration of a Border Gateway Protocol (BGP) group.
   * 
   * @param request - ModifyBgpGroupAttributeRequest
   * @returns ModifyBgpGroupAttributeResponse
   */
  async modifyBgpGroupAttribute(request: $_model.ModifyBgpGroupAttributeRequest): Promise<$_model.ModifyBgpGroupAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyBgpGroupAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the configuration of a BGP peer.
   * 
   * @param request - ModifyBgpPeerAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyBgpPeerAttributeResponse
   */
  async modifyBgpPeerAttributeWithOptions(request: $_model.ModifyBgpPeerAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyBgpPeerAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bfdMultiHop)) {
      query["BfdMultiHop"] = request.bfdMultiHop;
    }

    if (!$dara.isNull(request.bgpGroupId)) {
      query["BgpGroupId"] = request.bgpGroupId;
    }

    if (!$dara.isNull(request.bgpPeerId)) {
      query["BgpPeerId"] = request.bgpPeerId;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.enableBfd)) {
      query["EnableBfd"] = request.enableBfd;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.peerIpAddress)) {
      query["PeerIpAddress"] = request.peerIpAddress;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyBgpPeerAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyBgpPeerAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyBgpPeerAttributeResponse({}));
  }

  /**
   * Modifies the configuration of a BGP peer.
   * 
   * @param request - ModifyBgpPeerAttributeRequest
   * @returns ModifyBgpPeerAttributeResponse
   */
  async modifyBgpPeerAttribute(request: $_model.ModifyBgpPeerAttributeRequest): Promise<$_model.ModifyBgpPeerAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyBgpPeerAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the name and description of an EIP bandwidth plan.
   * 
   * @param request - ModifyCommonBandwidthPackageAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyCommonBandwidthPackageAttributeResponse
   */
  async modifyCommonBandwidthPackageAttributeWithOptions(request: $_model.ModifyCommonBandwidthPackageAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyCommonBandwidthPackageAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidthPackageId)) {
      query["BandwidthPackageId"] = request.bandwidthPackageId;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyCommonBandwidthPackageAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyCommonBandwidthPackageAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyCommonBandwidthPackageAttributeResponse({}));
  }

  /**
   * Modifies the name and description of an EIP bandwidth plan.
   * 
   * @param request - ModifyCommonBandwidthPackageAttributeRequest
   * @returns ModifyCommonBandwidthPackageAttributeResponse
   */
  async modifyCommonBandwidthPackageAttribute(request: $_model.ModifyCommonBandwidthPackageAttributeRequest): Promise<$_model.ModifyCommonBandwidthPackageAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyCommonBandwidthPackageAttributeWithOptions(request, runtime);
  }

  /**
   * Sets the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance.
   * 
   * @remarks
   * You can call the **ModifyCommonBandwidthPackageIpBandwidth** operation to set the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance. This prevents an EIP from exhausting the bandwidth resources of an Internet Shared Bandwidth instance.
   * For example, two EIPs are associated with an Internet Shared Bandwidth instance whose maximum bandwidth is 800 Mbit/s. In this case, you can set the maximum bandwidth of one EIP to 500 Mbit/s and that of the other EIP to 400 Mbit/s. After you set the maximum bandwidth values, the first EIP cannot consume bandwidth higher than 500 Mbit/s. The second EIP cannot consume bandwidth higher than 400 Mbit/s.
   * When you call this operation, take note of the following items:
   * *   This operation is valid only for EIPs that are associated with Elastic Compute Service (ECS) instances. This operation is invalid for EIPs that are associated with Server Load Balancer (SLB) instances, NAT gateways, secondary elastic network interfaces (ENIs), or high-availability virtual IP addresses (HAVIPs).
   * *   This operation is in public preview. You can call this operation to set the maximum bandwidth of EIPs only if the EIPs are associated with an Internet Shared Bandwidth instance. The feature is not supported in the console.
   * *   You cannot repeatedly call this operation to set the maximum bandwidth of an EIP within the specified period of time.
   * 
   * @param request - ModifyCommonBandwidthPackageIpBandwidthRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyCommonBandwidthPackageIpBandwidthResponse
   */
  async modifyCommonBandwidthPackageIpBandwidthWithOptions(request: $_model.ModifyCommonBandwidthPackageIpBandwidthRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyCommonBandwidthPackageIpBandwidthResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidth)) {
      query["Bandwidth"] = request.bandwidth;
    }

    if (!$dara.isNull(request.bandwidthPackageId)) {
      query["BandwidthPackageId"] = request.bandwidthPackageId;
    }

    if (!$dara.isNull(request.eipId)) {
      query["EipId"] = request.eipId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyCommonBandwidthPackageIpBandwidth",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyCommonBandwidthPackageIpBandwidthResponse>(await this.callApi(params, req, runtime), new $_model.ModifyCommonBandwidthPackageIpBandwidthResponse({}));
  }

  /**
   * Sets the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance.
   * 
   * @remarks
   * You can call the **ModifyCommonBandwidthPackageIpBandwidth** operation to set the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance. This prevents an EIP from exhausting the bandwidth resources of an Internet Shared Bandwidth instance.
   * For example, two EIPs are associated with an Internet Shared Bandwidth instance whose maximum bandwidth is 800 Mbit/s. In this case, you can set the maximum bandwidth of one EIP to 500 Mbit/s and that of the other EIP to 400 Mbit/s. After you set the maximum bandwidth values, the first EIP cannot consume bandwidth higher than 500 Mbit/s. The second EIP cannot consume bandwidth higher than 400 Mbit/s.
   * When you call this operation, take note of the following items:
   * *   This operation is valid only for EIPs that are associated with Elastic Compute Service (ECS) instances. This operation is invalid for EIPs that are associated with Server Load Balancer (SLB) instances, NAT gateways, secondary elastic network interfaces (ENIs), or high-availability virtual IP addresses (HAVIPs).
   * *   This operation is in public preview. You can call this operation to set the maximum bandwidth of EIPs only if the EIPs are associated with an Internet Shared Bandwidth instance. The feature is not supported in the console.
   * *   You cannot repeatedly call this operation to set the maximum bandwidth of an EIP within the specified period of time.
   * 
   * @param request - ModifyCommonBandwidthPackageIpBandwidthRequest
   * @returns ModifyCommonBandwidthPackageIpBandwidthResponse
   */
  async modifyCommonBandwidthPackageIpBandwidth(request: $_model.ModifyCommonBandwidthPackageIpBandwidthRequest): Promise<$_model.ModifyCommonBandwidthPackageIpBandwidthResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyCommonBandwidthPackageIpBandwidthWithOptions(request, runtime);
  }

  /**
   * Modifies the maximum bandwidth of an Internet Shared Bandwidth instance.
   * 
   * @remarks
   * Before you call this operation, take note of the following items:
   * *   **ModifyCommonBandwidthPackageSpec** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the task.
   *     *   If the Internet Shared Bandwidth instance is in the **Modifying** state, the maximum bandwidth of the Internet Shared Bandwidth instance is being modified. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
   *     *   If the Internet Shared Bandwidth instance is in the **Available** state, the maximum bandwidth of the Internet Shared Bandwidth instance is modified.
   * *   You cannot repeatedly call the **ModifyCommonBandwidthPackageSpec** operation to modify the maximum bandwidth of an Internet Shared Bandwidth instance within the specified period of time.
   * 
   * @param request - ModifyCommonBandwidthPackageSpecRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyCommonBandwidthPackageSpecResponse
   */
  async modifyCommonBandwidthPackageSpecWithOptions(request: $_model.ModifyCommonBandwidthPackageSpecRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyCommonBandwidthPackageSpecResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidth)) {
      query["Bandwidth"] = request.bandwidth;
    }

    if (!$dara.isNull(request.bandwidthPackageId)) {
      query["BandwidthPackageId"] = request.bandwidthPackageId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyCommonBandwidthPackageSpec",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyCommonBandwidthPackageSpecResponse>(await this.callApi(params, req, runtime), new $_model.ModifyCommonBandwidthPackageSpecResponse({}));
  }

  /**
   * Modifies the maximum bandwidth of an Internet Shared Bandwidth instance.
   * 
   * @remarks
   * Before you call this operation, take note of the following items:
   * *   **ModifyCommonBandwidthPackageSpec** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the task.
   *     *   If the Internet Shared Bandwidth instance is in the **Modifying** state, the maximum bandwidth of the Internet Shared Bandwidth instance is being modified. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
   *     *   If the Internet Shared Bandwidth instance is in the **Available** state, the maximum bandwidth of the Internet Shared Bandwidth instance is modified.
   * *   You cannot repeatedly call the **ModifyCommonBandwidthPackageSpec** operation to modify the maximum bandwidth of an Internet Shared Bandwidth instance within the specified period of time.
   * 
   * @param request - ModifyCommonBandwidthPackageSpecRequest
   * @returns ModifyCommonBandwidthPackageSpecResponse
   */
  async modifyCommonBandwidthPackageSpec(request: $_model.ModifyCommonBandwidthPackageSpecRequest): Promise<$_model.ModifyCommonBandwidthPackageSpecResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyCommonBandwidthPackageSpecWithOptions(request, runtime);
  }

  /**
   * Modifies the configuration of a customer gateway.
   * 
   * @remarks
   *   When you call **ModifyCustomerGatewayAttribute**, if a value is assigned to **AuthKey**, the operation is asynchronous. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
   *     *   If a VPN gateway is in the **updating** state, the configurations are being modified.
   *     *   If a VPN gateway is in the **active** state, the configurations are modified.
   * *   When you call **ModifyCustomerGatewayAttribute**, if no value is assigned to **AuthKey**, the operation is synchronous.
   * *   You cannot repeatedly call **ModifyCustomerGatewayAttribute** to modify the configurations of a customer gateway within the specified period of time.
   * 
   * @param request - ModifyCustomerGatewayAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyCustomerGatewayAttributeResponse
   */
  async modifyCustomerGatewayAttributeWithOptions(request: $_model.ModifyCustomerGatewayAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyCustomerGatewayAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.authKey)) {
      query["AuthKey"] = request.authKey;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.customerGatewayId)) {
      query["CustomerGatewayId"] = request.customerGatewayId;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyCustomerGatewayAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyCustomerGatewayAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyCustomerGatewayAttributeResponse({}));
  }

  /**
   * Modifies the configuration of a customer gateway.
   * 
   * @remarks
   *   When you call **ModifyCustomerGatewayAttribute**, if a value is assigned to **AuthKey**, the operation is asynchronous. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
   *     *   If a VPN gateway is in the **updating** state, the configurations are being modified.
   *     *   If a VPN gateway is in the **active** state, the configurations are modified.
   * *   When you call **ModifyCustomerGatewayAttribute**, if no value is assigned to **AuthKey**, the operation is synchronous.
   * *   You cannot repeatedly call **ModifyCustomerGatewayAttribute** to modify the configurations of a customer gateway within the specified period of time.
   * 
   * @param request - ModifyCustomerGatewayAttributeRequest
   * @returns ModifyCustomerGatewayAttributeResponse
   */
  async modifyCustomerGatewayAttribute(request: $_model.ModifyCustomerGatewayAttributeRequest): Promise<$_model.ModifyCustomerGatewayAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyCustomerGatewayAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the name, description, and maximum bandwidth of an elastic IP address (EIP).
   * 
   * @param request - ModifyEipAddressAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyEipAddressAttributeResponse
   */
  async modifyEipAddressAttributeWithOptions(request: $_model.ModifyEipAddressAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyEipAddressAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.allocationId)) {
      query["AllocationId"] = request.allocationId;
    }

    if (!$dara.isNull(request.bandwidth)) {
      query["Bandwidth"] = request.bandwidth;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyEipAddressAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyEipAddressAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyEipAddressAttributeResponse({}));
  }

  /**
   * Modifies the name, description, and maximum bandwidth of an elastic IP address (EIP).
   * 
   * @param request - ModifyEipAddressAttributeRequest
   * @returns ModifyEipAddressAttributeResponse
   */
  async modifyEipAddressAttribute(request: $_model.ModifyEipAddressAttributeRequest): Promise<$_model.ModifyEipAddressAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyEipAddressAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the EIP forwarding mode.
   * 
   * @param request - ModifyEipForwardModeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyEipForwardModeResponse
   */
  async modifyEipForwardModeWithOptions(request: $_model.ModifyEipForwardModeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyEipForwardModeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.mode)) {
      query["Mode"] = request.mode;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyEipForwardMode",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyEipForwardModeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyEipForwardModeResponse({}));
  }

  /**
   * Modifies the EIP forwarding mode.
   * 
   * @param request - ModifyEipForwardModeRequest
   * @returns ModifyEipForwardModeResponse
   */
  async modifyEipForwardMode(request: $_model.ModifyEipForwardModeRequest): Promise<$_model.ModifyEipForwardModeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyEipForwardModeWithOptions(request, runtime);
  }

  /**
   * Modifies the configuration of an Express Cloud Connect (ECC) instance.
   * 
   * @param request - ModifyExpressCloudConnectionAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyExpressCloudConnectionAttributeResponse
   */
  async modifyExpressCloudConnectionAttributeWithOptions(request: $_model.ModifyExpressCloudConnectionAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyExpressCloudConnectionAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bgpAs)) {
      query["BgpAs"] = request.bgpAs;
    }

    if (!$dara.isNull(request.ceIp)) {
      query["CeIp"] = request.ceIp;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.eccId)) {
      query["EccId"] = request.eccId;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.peIp)) {
      query["PeIp"] = request.peIp;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyExpressCloudConnectionAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyExpressCloudConnectionAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyExpressCloudConnectionAttributeResponse({}));
  }

  /**
   * Modifies the configuration of an Express Cloud Connect (ECC) instance.
   * 
   * @param request - ModifyExpressCloudConnectionAttributeRequest
   * @returns ModifyExpressCloudConnectionAttributeResponse
   */
  async modifyExpressCloudConnectionAttribute(request: $_model.ModifyExpressCloudConnectionAttributeRequest): Promise<$_model.ModifyExpressCloudConnectionAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyExpressCloudConnectionAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the bandwidth of an Express Cloud Connect (ECC) instance.
   * 
   * @param request - ModifyExpressCloudConnectionBandwidthRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyExpressCloudConnectionBandwidthResponse
   */
  async modifyExpressCloudConnectionBandwidthWithOptions(request: $_model.ModifyExpressCloudConnectionBandwidthRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyExpressCloudConnectionBandwidthResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidth)) {
      query["Bandwidth"] = request.bandwidth;
    }

    if (!$dara.isNull(request.eccId)) {
      query["EccId"] = request.eccId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyExpressCloudConnectionBandwidth",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyExpressCloudConnectionBandwidthResponse>(await this.callApi(params, req, runtime), new $_model.ModifyExpressCloudConnectionBandwidthResponse({}));
  }

  /**
   * Modifies the bandwidth of an Express Cloud Connect (ECC) instance.
   * 
   * @param request - ModifyExpressCloudConnectionBandwidthRequest
   * @returns ModifyExpressCloudConnectionBandwidthResponse
   */
  async modifyExpressCloudConnectionBandwidth(request: $_model.ModifyExpressCloudConnectionBandwidthRequest): Promise<$_model.ModifyExpressCloudConnectionBandwidthResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyExpressCloudConnectionBandwidthWithOptions(request, runtime);
  }

  /**
   * Modifies a quality of service (QoS) policy or associates a QoS policy with a dedicated Express Connect circuit.
   * 
   * @param request - ModifyExpressConnectTrafficQosRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyExpressConnectTrafficQosResponse
   */
  async modifyExpressConnectTrafficQosWithOptions(request: $_model.ModifyExpressConnectTrafficQosRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyExpressConnectTrafficQosResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.addInstanceList)) {
      query["AddInstanceList"] = request.addInstanceList;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.qosDescription)) {
      query["QosDescription"] = request.qosDescription;
    }

    if (!$dara.isNull(request.qosId)) {
      query["QosId"] = request.qosId;
    }

    if (!$dara.isNull(request.qosName)) {
      query["QosName"] = request.qosName;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.removeInstanceList)) {
      query["RemoveInstanceList"] = request.removeInstanceList;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyExpressConnectTrafficQos",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyExpressConnectTrafficQosResponse>(await this.callApi(params, req, runtime), new $_model.ModifyExpressConnectTrafficQosResponse({}));
  }

  /**
   * Modifies a quality of service (QoS) policy or associates a QoS policy with a dedicated Express Connect circuit.
   * 
   * @param request - ModifyExpressConnectTrafficQosRequest
   * @returns ModifyExpressConnectTrafficQosResponse
   */
  async modifyExpressConnectTrafficQos(request: $_model.ModifyExpressConnectTrafficQosRequest): Promise<$_model.ModifyExpressConnectTrafficQosResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyExpressConnectTrafficQosWithOptions(request, runtime);
  }

  /**
   * Modifies a quality of service (QoS) queue.
   * 
   * @param request - ModifyExpressConnectTrafficQosQueueRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyExpressConnectTrafficQosQueueResponse
   */
  async modifyExpressConnectTrafficQosQueueWithOptions(request: $_model.ModifyExpressConnectTrafficQosQueueRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyExpressConnectTrafficQosQueueResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidthPercent)) {
      query["BandwidthPercent"] = request.bandwidthPercent;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.qosId)) {
      query["QosId"] = request.qosId;
    }

    if (!$dara.isNull(request.queueDescription)) {
      query["QueueDescription"] = request.queueDescription;
    }

    if (!$dara.isNull(request.queueId)) {
      query["QueueId"] = request.queueId;
    }

    if (!$dara.isNull(request.queueName)) {
      query["QueueName"] = request.queueName;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyExpressConnectTrafficQosQueue",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyExpressConnectTrafficQosQueueResponse>(await this.callApi(params, req, runtime), new $_model.ModifyExpressConnectTrafficQosQueueResponse({}));
  }

  /**
   * Modifies a quality of service (QoS) queue.
   * 
   * @param request - ModifyExpressConnectTrafficQosQueueRequest
   * @returns ModifyExpressConnectTrafficQosQueueResponse
   */
  async modifyExpressConnectTrafficQosQueue(request: $_model.ModifyExpressConnectTrafficQosQueueRequest): Promise<$_model.ModifyExpressConnectTrafficQosQueueResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyExpressConnectTrafficQosQueueWithOptions(request, runtime);
  }

  /**
   * Modifies a quality of service (QoS) rule.
   * 
   * @param request - ModifyExpressConnectTrafficQosRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyExpressConnectTrafficQosRuleResponse
   */
  async modifyExpressConnectTrafficQosRuleWithOptions(request: $_model.ModifyExpressConnectTrafficQosRuleRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyExpressConnectTrafficQosRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dstCidr)) {
      query["DstCidr"] = request.dstCidr;
    }

    if (!$dara.isNull(request.dstIPv6Cidr)) {
      query["DstIPv6Cidr"] = request.dstIPv6Cidr;
    }

    if (!$dara.isNull(request.dstPortRange)) {
      query["DstPortRange"] = request.dstPortRange;
    }

    if (!$dara.isNull(request.matchDscp)) {
      query["MatchDscp"] = request.matchDscp;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.priority)) {
      query["Priority"] = request.priority;
    }

    if (!$dara.isNull(request.protocol)) {
      query["Protocol"] = request.protocol;
    }

    if (!$dara.isNull(request.qosId)) {
      query["QosId"] = request.qosId;
    }

    if (!$dara.isNull(request.queueId)) {
      query["QueueId"] = request.queueId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.remarkingDscp)) {
      query["RemarkingDscp"] = request.remarkingDscp;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.ruleDescription)) {
      query["RuleDescription"] = request.ruleDescription;
    }

    if (!$dara.isNull(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.srcCidr)) {
      query["SrcCidr"] = request.srcCidr;
    }

    if (!$dara.isNull(request.srcIPv6Cidr)) {
      query["SrcIPv6Cidr"] = request.srcIPv6Cidr;
    }

    if (!$dara.isNull(request.srcPortRange)) {
      query["SrcPortRange"] = request.srcPortRange;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyExpressConnectTrafficQosRule",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyExpressConnectTrafficQosRuleResponse>(await this.callApi(params, req, runtime), new $_model.ModifyExpressConnectTrafficQosRuleResponse({}));
  }

  /**
   * Modifies a quality of service (QoS) rule.
   * 
   * @param request - ModifyExpressConnectTrafficQosRuleRequest
   * @returns ModifyExpressConnectTrafficQosRuleResponse
   */
  async modifyExpressConnectTrafficQosRule(request: $_model.ModifyExpressConnectTrafficQosRuleRequest): Promise<$_model.ModifyExpressConnectTrafficQosRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyExpressConnectTrafficQosRuleWithOptions(request, runtime);
  }

  /**
   * Modifies the name and description of a flow log.
   * 
   * @remarks
   *   **ModifyFlowLogAttribute** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
   *     *   If the flow log is in the **Modifying** state, the flow log is being modified.
   *     *   If the flow log is in the **Active** or **Inactive** state, the flow log is modified.
   * *   You cannot repeatedly call the **ModifyFlowLogAttribute** operation to modify a flow log within the specified period of time.
   * 
   * @param request - ModifyFlowLogAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyFlowLogAttributeResponse
   */
  async modifyFlowLogAttributeWithOptions(request: $_model.ModifyFlowLogAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyFlowLogAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.aggregationInterval)) {
      query["AggregationInterval"] = request.aggregationInterval;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.flowLogId)) {
      query["FlowLogId"] = request.flowLogId;
    }

    if (!$dara.isNull(request.flowLogName)) {
      query["FlowLogName"] = request.flowLogName;
    }

    if (!$dara.isNull(request.ipVersion)) {
      query["IpVersion"] = request.ipVersion;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyFlowLogAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyFlowLogAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyFlowLogAttributeResponse({}));
  }

  /**
   * Modifies the name and description of a flow log.
   * 
   * @remarks
   *   **ModifyFlowLogAttribute** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
   *     *   If the flow log is in the **Modifying** state, the flow log is being modified.
   *     *   If the flow log is in the **Active** or **Inactive** state, the flow log is modified.
   * *   You cannot repeatedly call the **ModifyFlowLogAttribute** operation to modify a flow log within the specified period of time.
   * 
   * @param request - ModifyFlowLogAttributeRequest
   * @returns ModifyFlowLogAttributeResponse
   */
  async modifyFlowLogAttribute(request: $_model.ModifyFlowLogAttributeRequest): Promise<$_model.ModifyFlowLogAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyFlowLogAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies a DNAT entry.
   * 
   * @remarks
   *   **ModifyForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
   *     *   **Pending**: indicates that the system is modifying the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
   *     *   **Available**: indicates that the DNAT entry is modified.
   * *   You cannot repeatedly call the **ModifyForwardEntry** operation to modify a DNAT entry within the specified period of time.
   * 
   * @param request - ModifyForwardEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyForwardEntryResponse
   */
  async modifyForwardEntryWithOptions(request: $_model.ModifyForwardEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyForwardEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.externalIp)) {
      query["ExternalIp"] = request.externalIp;
    }

    if (!$dara.isNull(request.externalPort)) {
      query["ExternalPort"] = request.externalPort;
    }

    if (!$dara.isNull(request.forwardEntryId)) {
      query["ForwardEntryId"] = request.forwardEntryId;
    }

    if (!$dara.isNull(request.forwardEntryName)) {
      query["ForwardEntryName"] = request.forwardEntryName;
    }

    if (!$dara.isNull(request.forwardTableId)) {
      query["ForwardTableId"] = request.forwardTableId;
    }

    if (!$dara.isNull(request.internalIp)) {
      query["InternalIp"] = request.internalIp;
    }

    if (!$dara.isNull(request.internalPort)) {
      query["InternalPort"] = request.internalPort;
    }

    if (!$dara.isNull(request.ipProtocol)) {
      query["IpProtocol"] = request.ipProtocol;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.portBreak)) {
      query["PortBreak"] = request.portBreak;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyForwardEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyForwardEntryResponse>(await this.callApi(params, req, runtime), new $_model.ModifyForwardEntryResponse({}));
  }

  /**
   * Modifies a DNAT entry.
   * 
   * @remarks
   *   **ModifyForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
   *     *   **Pending**: indicates that the system is modifying the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
   *     *   **Available**: indicates that the DNAT entry is modified.
   * *   You cannot repeatedly call the **ModifyForwardEntry** operation to modify a DNAT entry within the specified period of time.
   * 
   * @param request - ModifyForwardEntryRequest
   * @returns ModifyForwardEntryResponse
   */
  async modifyForwardEntry(request: $_model.ModifyForwardEntryRequest): Promise<$_model.ModifyForwardEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyForwardEntryWithOptions(request, runtime);
  }

  /**
   * Modifies a FULLNAT entry.
   * 
   * @remarks
   * ## [](#)
   * *   **ModifyFullNatEntryAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
   *     *   **Modifying**: indicates that the system is modifying the FULLNAT entry. You can query the FULLNAT entry, but cannot perform other operations.
   *     *   **Available**: indicates that the FULLNAT entry is modified.
   * *   You cannot repeatedly call the **ModifyFullNatEntryAttribute** operation to modify a FULLNAT entry within the specified period of time.
   * 
   * @param request - ModifyFullNatEntryAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyFullNatEntryAttributeResponse
   */
  async modifyFullNatEntryAttributeWithOptions(request: $_model.ModifyFullNatEntryAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyFullNatEntryAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.accessIp)) {
      query["AccessIp"] = request.accessIp;
    }

    if (!$dara.isNull(request.accessPort)) {
      query["AccessPort"] = request.accessPort;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.fullNatEntryDescription)) {
      query["FullNatEntryDescription"] = request.fullNatEntryDescription;
    }

    if (!$dara.isNull(request.fullNatEntryId)) {
      query["FullNatEntryId"] = request.fullNatEntryId;
    }

    if (!$dara.isNull(request.fullNatEntryName)) {
      query["FullNatEntryName"] = request.fullNatEntryName;
    }

    if (!$dara.isNull(request.fullNatTableId)) {
      query["FullNatTableId"] = request.fullNatTableId;
    }

    if (!$dara.isNull(request.ipProtocol)) {
      query["IpProtocol"] = request.ipProtocol;
    }

    if (!$dara.isNull(request.natIp)) {
      query["NatIp"] = request.natIp;
    }

    if (!$dara.isNull(request.natIpPort)) {
      query["NatIpPort"] = request.natIpPort;
    }

    if (!$dara.isNull(request.networkInterfaceId)) {
      query["NetworkInterfaceId"] = request.networkInterfaceId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyFullNatEntryAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyFullNatEntryAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyFullNatEntryAttributeResponse({}));
  }

  /**
   * Modifies a FULLNAT entry.
   * 
   * @remarks
   * ## [](#)
   * *   **ModifyFullNatEntryAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
   *     *   **Modifying**: indicates that the system is modifying the FULLNAT entry. You can query the FULLNAT entry, but cannot perform other operations.
   *     *   **Available**: indicates that the FULLNAT entry is modified.
   * *   You cannot repeatedly call the **ModifyFullNatEntryAttribute** operation to modify a FULLNAT entry within the specified period of time.
   * 
   * @param request - ModifyFullNatEntryAttributeRequest
   * @returns ModifyFullNatEntryAttributeResponse
   */
  async modifyFullNatEntryAttribute(request: $_model.ModifyFullNatEntryAttributeRequest): Promise<$_model.ModifyFullNatEntryAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyFullNatEntryAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the name and description of a Global Accelerator (GA) instance.
   * 
   * @param request - ModifyGlobalAccelerationInstanceAttributesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyGlobalAccelerationInstanceAttributesResponse
   */
  async modifyGlobalAccelerationInstanceAttributesWithOptions(request: $_model.ModifyGlobalAccelerationInstanceAttributesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyGlobalAccelerationInstanceAttributesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.globalAccelerationInstanceId)) {
      query["GlobalAccelerationInstanceId"] = request.globalAccelerationInstanceId;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyGlobalAccelerationInstanceAttributes",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyGlobalAccelerationInstanceAttributesResponse>(await this.callApi(params, req, runtime), new $_model.ModifyGlobalAccelerationInstanceAttributesResponse({}));
  }

  /**
   * Modifies the name and description of a Global Accelerator (GA) instance.
   * 
   * @param request - ModifyGlobalAccelerationInstanceAttributesRequest
   * @returns ModifyGlobalAccelerationInstanceAttributesResponse
   */
  async modifyGlobalAccelerationInstanceAttributes(request: $_model.ModifyGlobalAccelerationInstanceAttributesRequest): Promise<$_model.ModifyGlobalAccelerationInstanceAttributesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyGlobalAccelerationInstanceAttributesWithOptions(request, runtime);
  }

  /**
   * Modifies the maximum bandwidth of a Global Accelerator (GA) instance.
   * 
   * @remarks
   * ## Usage notes
   * You cannot call this operation to modify the maximum bandwidth of a subscription GA instance.
   * 
   * @param request - ModifyGlobalAccelerationInstanceSpecRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyGlobalAccelerationInstanceSpecResponse
   */
  async modifyGlobalAccelerationInstanceSpecWithOptions(request: $_model.ModifyGlobalAccelerationInstanceSpecRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyGlobalAccelerationInstanceSpecResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidth)) {
      query["Bandwidth"] = request.bandwidth;
    }

    if (!$dara.isNull(request.globalAccelerationInstanceId)) {
      query["GlobalAccelerationInstanceId"] = request.globalAccelerationInstanceId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyGlobalAccelerationInstanceSpec",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyGlobalAccelerationInstanceSpecResponse>(await this.callApi(params, req, runtime), new $_model.ModifyGlobalAccelerationInstanceSpecResponse({}));
  }

  /**
   * Modifies the maximum bandwidth of a Global Accelerator (GA) instance.
   * 
   * @remarks
   * ## Usage notes
   * You cannot call this operation to modify the maximum bandwidth of a subscription GA instance.
   * 
   * @param request - ModifyGlobalAccelerationInstanceSpecRequest
   * @returns ModifyGlobalAccelerationInstanceSpecResponse
   */
  async modifyGlobalAccelerationInstanceSpec(request: $_model.ModifyGlobalAccelerationInstanceSpecRequest): Promise<$_model.ModifyGlobalAccelerationInstanceSpecResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyGlobalAccelerationInstanceSpecWithOptions(request, runtime);
  }

  /**
   * Modifies the name and description of a high-availability virtual IP address (HaVip).
   * 
   * @remarks
   * You cannot repeatedly call the **ModifyHaVipAttribute** operation to modify the name and description of an HaVip within the specified periods of time.
   * 
   * @param request - ModifyHaVipAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyHaVipAttributeResponse
   */
  async modifyHaVipAttributeWithOptions(request: $_model.ModifyHaVipAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyHaVipAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.haVipId)) {
      query["HaVipId"] = request.haVipId;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyHaVipAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyHaVipAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyHaVipAttributeResponse({}));
  }

  /**
   * Modifies the name and description of a high-availability virtual IP address (HaVip).
   * 
   * @remarks
   * You cannot repeatedly call the **ModifyHaVipAttribute** operation to modify the name and description of an HaVip within the specified periods of time.
   * 
   * @param request - ModifyHaVipAttributeRequest
   * @returns ModifyHaVipAttributeResponse
   */
  async modifyHaVipAttribute(request: $_model.ModifyHaVipAttributeRequest): Promise<$_model.ModifyHaVipAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyHaVipAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the name of an access control list (ACL).
   * 
   * @deprecated OpenAPI ModifyIPv6TranslatorAclAttribute is deprecated
   * 
   * @param request - ModifyIPv6TranslatorAclAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyIPv6TranslatorAclAttributeResponse
   */
  async modifyIPv6TranslatorAclAttributeWithOptions(request: $_model.ModifyIPv6TranslatorAclAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyIPv6TranslatorAclAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.aclId)) {
      query["AclId"] = request.aclId;
    }

    if (!$dara.isNull(request.aclName)) {
      query["AclName"] = request.aclName;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyIPv6TranslatorAclAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyIPv6TranslatorAclAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyIPv6TranslatorAclAttributeResponse({}));
  }

  /**
   * Modifies the name of an access control list (ACL).
   * 
   * @deprecated OpenAPI ModifyIPv6TranslatorAclAttribute is deprecated
   * 
   * @param request - ModifyIPv6TranslatorAclAttributeRequest
   * @returns ModifyIPv6TranslatorAclAttributeResponse
   */
  // Deprecated
  async modifyIPv6TranslatorAclAttribute(request: $_model.ModifyIPv6TranslatorAclAttributeRequest): Promise<$_model.ModifyIPv6TranslatorAclAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyIPv6TranslatorAclAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies an IP entry in an access control list (ACL).
   * 
   * @param request - ModifyIPv6TranslatorAclListEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyIPv6TranslatorAclListEntryResponse
   */
  async modifyIPv6TranslatorAclListEntryWithOptions(request: $_model.ModifyIPv6TranslatorAclListEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyIPv6TranslatorAclListEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.aclEntryComment)) {
      query["AclEntryComment"] = request.aclEntryComment;
    }

    if (!$dara.isNull(request.aclEntryId)) {
      query["AclEntryId"] = request.aclEntryId;
    }

    if (!$dara.isNull(request.aclId)) {
      query["AclId"] = request.aclId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyIPv6TranslatorAclListEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyIPv6TranslatorAclListEntryResponse>(await this.callApi(params, req, runtime), new $_model.ModifyIPv6TranslatorAclListEntryResponse({}));
  }

  /**
   * Modifies an IP entry in an access control list (ACL).
   * 
   * @param request - ModifyIPv6TranslatorAclListEntryRequest
   * @returns ModifyIPv6TranslatorAclListEntryResponse
   */
  async modifyIPv6TranslatorAclListEntry(request: $_model.ModifyIPv6TranslatorAclListEntryRequest): Promise<$_model.ModifyIPv6TranslatorAclListEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyIPv6TranslatorAclListEntryWithOptions(request, runtime);
  }

  /**
   * Modifies the name and description of an IPv6 Translation Service instance.
   * 
   * @param request - ModifyIPv6TranslatorAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyIPv6TranslatorAttributeResponse
   */
  async modifyIPv6TranslatorAttributeWithOptions(request: $_model.ModifyIPv6TranslatorAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyIPv6TranslatorAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.ipv6TranslatorId)) {
      query["Ipv6TranslatorId"] = request.ipv6TranslatorId;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyIPv6TranslatorAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyIPv6TranslatorAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyIPv6TranslatorAttributeResponse({}));
  }

  /**
   * Modifies the name and description of an IPv6 Translation Service instance.
   * 
   * @param request - ModifyIPv6TranslatorAttributeRequest
   * @returns ModifyIPv6TranslatorAttributeResponse
   */
  async modifyIPv6TranslatorAttribute(request: $_model.ModifyIPv6TranslatorAttributeRequest): Promise<$_model.ModifyIPv6TranslatorAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyIPv6TranslatorAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the maximum bandwidth of an IPv6 Translation Service instance.
   * 
   * @param request - ModifyIPv6TranslatorBandwidthRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyIPv6TranslatorBandwidthResponse
   */
  async modifyIPv6TranslatorBandwidthWithOptions(request: $_model.ModifyIPv6TranslatorBandwidthRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyIPv6TranslatorBandwidthResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.autoPay)) {
      query["AutoPay"] = request.autoPay;
    }

    if (!$dara.isNull(request.bandwidth)) {
      query["Bandwidth"] = request.bandwidth;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ipv6TranslatorId)) {
      query["Ipv6TranslatorId"] = request.ipv6TranslatorId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyIPv6TranslatorBandwidth",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyIPv6TranslatorBandwidthResponse>(await this.callApi(params, req, runtime), new $_model.ModifyIPv6TranslatorBandwidthResponse({}));
  }

  /**
   * Modifies the maximum bandwidth of an IPv6 Translation Service instance.
   * 
   * @param request - ModifyIPv6TranslatorBandwidthRequest
   * @returns ModifyIPv6TranslatorBandwidthResponse
   */
  async modifyIPv6TranslatorBandwidth(request: $_model.ModifyIPv6TranslatorBandwidthRequest): Promise<$_model.ModifyIPv6TranslatorBandwidthResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyIPv6TranslatorBandwidthWithOptions(request, runtime);
  }

  /**
   * Modifies an IPv6 mapping entry.
   * 
   * @deprecated OpenAPI ModifyIPv6TranslatorEntry is deprecated
   * 
   * @param request - ModifyIPv6TranslatorEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyIPv6TranslatorEntryResponse
   */
  async modifyIPv6TranslatorEntryWithOptions(request: $_model.ModifyIPv6TranslatorEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyIPv6TranslatorEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.aclId)) {
      query["AclId"] = request.aclId;
    }

    if (!$dara.isNull(request.aclStatus)) {
      query["AclStatus"] = request.aclStatus;
    }

    if (!$dara.isNull(request.aclType)) {
      query["AclType"] = request.aclType;
    }

    if (!$dara.isNull(request.allocateIpv6Port)) {
      query["AllocateIpv6Port"] = request.allocateIpv6Port;
    }

    if (!$dara.isNull(request.backendIpv4Addr)) {
      query["BackendIpv4Addr"] = request.backendIpv4Addr;
    }

    if (!$dara.isNull(request.backendIpv4Port)) {
      query["BackendIpv4Port"] = request.backendIpv4Port;
    }

    if (!$dara.isNull(request.entryBandwidth)) {
      query["EntryBandwidth"] = request.entryBandwidth;
    }

    if (!$dara.isNull(request.entryDescription)) {
      query["EntryDescription"] = request.entryDescription;
    }

    if (!$dara.isNull(request.entryName)) {
      query["EntryName"] = request.entryName;
    }

    if (!$dara.isNull(request.ipv6TranslatorEntryId)) {
      query["Ipv6TranslatorEntryId"] = request.ipv6TranslatorEntryId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.transProtocol)) {
      query["TransProtocol"] = request.transProtocol;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyIPv6TranslatorEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyIPv6TranslatorEntryResponse>(await this.callApi(params, req, runtime), new $_model.ModifyIPv6TranslatorEntryResponse({}));
  }

  /**
   * Modifies an IPv6 mapping entry.
   * 
   * @deprecated OpenAPI ModifyIPv6TranslatorEntry is deprecated
   * 
   * @param request - ModifyIPv6TranslatorEntryRequest
   * @returns ModifyIPv6TranslatorEntryResponse
   */
  // Deprecated
  async modifyIPv6TranslatorEntry(request: $_model.ModifyIPv6TranslatorEntryRequest): Promise<$_model.ModifyIPv6TranslatorEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyIPv6TranslatorEntryWithOptions(request, runtime);
  }

  /**
   * Modifies the name and description of an IPv6 address.
   * 
   * @param request - ModifyIpv6AddressAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyIpv6AddressAttributeResponse
   */
  async modifyIpv6AddressAttributeWithOptions(request: $_model.ModifyIpv6AddressAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyIpv6AddressAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ipv6AddressId)) {
      query["Ipv6AddressId"] = request.ipv6AddressId;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyIpv6AddressAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyIpv6AddressAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyIpv6AddressAttributeResponse({}));
  }

  /**
   * Modifies the name and description of an IPv6 address.
   * 
   * @param request - ModifyIpv6AddressAttributeRequest
   * @returns ModifyIpv6AddressAttributeResponse
   */
  async modifyIpv6AddressAttribute(request: $_model.ModifyIpv6AddressAttributeRequest): Promise<$_model.ModifyIpv6AddressAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyIpv6AddressAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the name and description of an IPv6 gateway.
   * 
   * @param request - ModifyIpv6GatewayAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyIpv6GatewayAttributeResponse
   */
  async modifyIpv6GatewayAttributeWithOptions(request: $_model.ModifyIpv6GatewayAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyIpv6GatewayAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ipv6GatewayId)) {
      query["Ipv6GatewayId"] = request.ipv6GatewayId;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyIpv6GatewayAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyIpv6GatewayAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyIpv6GatewayAttributeResponse({}));
  }

  /**
   * Modifies the name and description of an IPv6 gateway.
   * 
   * @param request - ModifyIpv6GatewayAttributeRequest
   * @returns ModifyIpv6GatewayAttributeResponse
   */
  async modifyIpv6GatewayAttribute(request: $_model.ModifyIpv6GatewayAttributeRequest): Promise<$_model.ModifyIpv6GatewayAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyIpv6GatewayAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the Internet bandwidth of an IPv6 address.
   * 
   * @remarks
   * You cannot repeatedly call the **ModifyIpv6InternetBandwidth** operation to modify the Internet bandwidth value of an IPv6 CIDR block within the specified period of time.
   * 
   * @param request - ModifyIpv6InternetBandwidthRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyIpv6InternetBandwidthResponse
   */
  async modifyIpv6InternetBandwidthWithOptions(request: $_model.ModifyIpv6InternetBandwidthRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyIpv6InternetBandwidthResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidth)) {
      query["Bandwidth"] = request.bandwidth;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ipv6AddressId)) {
      query["Ipv6AddressId"] = request.ipv6AddressId;
    }

    if (!$dara.isNull(request.ipv6InternetBandwidthId)) {
      query["Ipv6InternetBandwidthId"] = request.ipv6InternetBandwidthId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyIpv6InternetBandwidth",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyIpv6InternetBandwidthResponse>(await this.callApi(params, req, runtime), new $_model.ModifyIpv6InternetBandwidthResponse({}));
  }

  /**
   * Modifies the Internet bandwidth of an IPv6 address.
   * 
   * @remarks
   * You cannot repeatedly call the **ModifyIpv6InternetBandwidth** operation to modify the Internet bandwidth value of an IPv6 CIDR block within the specified period of time.
   * 
   * @param request - ModifyIpv6InternetBandwidthRequest
   * @returns ModifyIpv6InternetBandwidthResponse
   */
  async modifyIpv6InternetBandwidth(request: $_model.ModifyIpv6InternetBandwidthRequest): Promise<$_model.ModifyIpv6InternetBandwidthResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyIpv6InternetBandwidthWithOptions(request, runtime);
  }

  /**
   * Modifies the name and description of a NAT gateway.
   * 
   * @remarks
   * ## [](#)Description
   * You can call this operation to query an Internet NAT gateway or a virtual private cloud (VPC) NAT gateway. The term NAT gateway in this topic refers to both NAT gateway types.
   * 
   * @param tmpReq - ModifyNatGatewayAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyNatGatewayAttributeResponse
   */
  async modifyNatGatewayAttributeWithOptions(tmpReq: $_model.ModifyNatGatewayAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyNatGatewayAttributeResponse> {
    tmpReq.validate();
    let request = new $_model.ModifyNatGatewayAttributeShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.logDelivery)) {
      request.logDeliveryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.logDelivery, "LogDelivery", "json");
    }

    let query = { };
    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.eipBindMode)) {
      query["EipBindMode"] = request.eipBindMode;
    }

    if (!$dara.isNull(request.enableSessionLog)) {
      query["EnableSessionLog"] = request.enableSessionLog;
    }

    if (!$dara.isNull(request.icmpReplyEnabled)) {
      query["IcmpReplyEnabled"] = request.icmpReplyEnabled;
    }

    if (!$dara.isNull(request.logDeliveryShrink)) {
      query["LogDelivery"] = request.logDeliveryShrink;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.natGatewayId)) {
      query["NatGatewayId"] = request.natGatewayId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyNatGatewayAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyNatGatewayAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyNatGatewayAttributeResponse({}));
  }

  /**
   * Modifies the name and description of a NAT gateway.
   * 
   * @remarks
   * ## [](#)Description
   * You can call this operation to query an Internet NAT gateway or a virtual private cloud (VPC) NAT gateway. The term NAT gateway in this topic refers to both NAT gateway types.
   * 
   * @param request - ModifyNatGatewayAttributeRequest
   * @returns ModifyNatGatewayAttributeResponse
   */
  async modifyNatGatewayAttribute(request: $_model.ModifyNatGatewayAttributeRequest): Promise<$_model.ModifyNatGatewayAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyNatGatewayAttributeWithOptions(request, runtime);
  }

  /**
   * Upgrades a subscription Internet NAT gateway.
   * 
   * @remarks
   * - You cannot call this operation to downgrade a subscription Internet NAT gateway. You can downgrade a subscription Internet NAT gateway only in the console.
   * - When you call this operation to upgrade a subscription Internet NAT gateway, an order is generated. After you complete the payment in the order center, the Internet NAT gateway is upgraded.
   * - **ModifyNatGatewaySpec** is an asynchronous operation. After you make a request, the ID of the request is returned but the Internet NAT gateway is not upgraded. The system upgrades the NAT gateway in the background. You can call the [DescribeNatGateways](/help/en/virtual-private-cloud/latest/describenatgateways) operation to query the status of an Internet NAT gateway.    - If an Internet NAT gateway is in the **Modifying** state, the NAT gateway is being upgraded. In this case, you can only query the NAT gateway but cannot perform other operations.
   *   - If an Internet NAT gateway is in the **Available** state, the Internet NAT gateway is upgraded.
   * - You cannot repeatedly call the **ModifyNatGatewaySpec** operation to resize a pay-by-specification NAT gateway.
   * Internet NAT gateways are available in different sizes. The size of an Internet NAT gateway determines the SNAT performance, which includes the maximum number of connections and the number of new connections per second. However, the size of a NAT gateway does not affect the data throughput. The following table describes the correlations between different sizes of Internet NAT gateways and SNAT performance metrics.  
   * | Size | Maximum number of connections | Number of new connections per second |
   * | ---- | ----------------------------- | ------------------------------------ |
   * | Small | 10,000 | 1,000 |
   * | Medium | 50,000 | 5,000 |
   * | Large | 200,000 | 10,000 |
   * 
   * @param request - ModifyNatGatewaySpecRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyNatGatewaySpecResponse
   */
  async modifyNatGatewaySpecWithOptions(request: $_model.ModifyNatGatewaySpecRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyNatGatewaySpecResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.autoPay)) {
      query["AutoPay"] = request.autoPay;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.natGatewayId)) {
      query["NatGatewayId"] = request.natGatewayId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.spec)) {
      query["Spec"] = request.spec;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyNatGatewaySpec",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyNatGatewaySpecResponse>(await this.callApi(params, req, runtime), new $_model.ModifyNatGatewaySpecResponse({}));
  }

  /**
   * Upgrades a subscription Internet NAT gateway.
   * 
   * @remarks
   * - You cannot call this operation to downgrade a subscription Internet NAT gateway. You can downgrade a subscription Internet NAT gateway only in the console.
   * - When you call this operation to upgrade a subscription Internet NAT gateway, an order is generated. After you complete the payment in the order center, the Internet NAT gateway is upgraded.
   * - **ModifyNatGatewaySpec** is an asynchronous operation. After you make a request, the ID of the request is returned but the Internet NAT gateway is not upgraded. The system upgrades the NAT gateway in the background. You can call the [DescribeNatGateways](/help/en/virtual-private-cloud/latest/describenatgateways) operation to query the status of an Internet NAT gateway.    - If an Internet NAT gateway is in the **Modifying** state, the NAT gateway is being upgraded. In this case, you can only query the NAT gateway but cannot perform other operations.
   *   - If an Internet NAT gateway is in the **Available** state, the Internet NAT gateway is upgraded.
   * - You cannot repeatedly call the **ModifyNatGatewaySpec** operation to resize a pay-by-specification NAT gateway.
   * Internet NAT gateways are available in different sizes. The size of an Internet NAT gateway determines the SNAT performance, which includes the maximum number of connections and the number of new connections per second. However, the size of a NAT gateway does not affect the data throughput. The following table describes the correlations between different sizes of Internet NAT gateways and SNAT performance metrics.  
   * | Size | Maximum number of connections | Number of new connections per second |
   * | ---- | ----------------------------- | ------------------------------------ |
   * | Small | 10,000 | 1,000 |
   * | Medium | 50,000 | 5,000 |
   * | Large | 200,000 | 10,000 |
   * 
   * @param request - ModifyNatGatewaySpecRequest
   * @returns ModifyNatGatewaySpecResponse
   */
  async modifyNatGatewaySpec(request: $_model.ModifyNatGatewaySpecRequest): Promise<$_model.ModifyNatGatewaySpecResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyNatGatewaySpecWithOptions(request, runtime);
  }

  /**
   * Modifies the name and description of a NAT IP address.
   * 
   * @remarks
   * ## [](#)Description
   * You cannot repeatedly call the **ModifyNatIpAttribute** operation to modify the name and description of a NAT IP address within the specified period of time.
   * 
   * @param request - ModifyNatIpAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyNatIpAttributeResponse
   */
  async modifyNatIpAttributeWithOptions(request: $_model.ModifyNatIpAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyNatIpAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.natIpDescription)) {
      query["NatIpDescription"] = request.natIpDescription;
    }

    if (!$dara.isNull(request.natIpId)) {
      query["NatIpId"] = request.natIpId;
    }

    if (!$dara.isNull(request.natIpName)) {
      query["NatIpName"] = request.natIpName;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyNatIpAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyNatIpAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyNatIpAttributeResponse({}));
  }

  /**
   * Modifies the name and description of a NAT IP address.
   * 
   * @remarks
   * ## [](#)Description
   * You cannot repeatedly call the **ModifyNatIpAttribute** operation to modify the name and description of a NAT IP address within the specified period of time.
   * 
   * @param request - ModifyNatIpAttributeRequest
   * @returns ModifyNatIpAttributeResponse
   */
  async modifyNatIpAttribute(request: $_model.ModifyNatIpAttributeRequest): Promise<$_model.ModifyNatIpAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyNatIpAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the name and description of a NAT CIDR block.
   * 
   * @param request - ModifyNatIpCidrAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyNatIpCidrAttributeResponse
   */
  async modifyNatIpCidrAttributeWithOptions(request: $_model.ModifyNatIpCidrAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyNatIpCidrAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.natGatewayId)) {
      query["NatGatewayId"] = request.natGatewayId;
    }

    if (!$dara.isNull(request.natIpCidr)) {
      query["NatIpCidr"] = request.natIpCidr;
    }

    if (!$dara.isNull(request.natIpCidrDescription)) {
      query["NatIpCidrDescription"] = request.natIpCidrDescription;
    }

    if (!$dara.isNull(request.natIpCidrName)) {
      query["NatIpCidrName"] = request.natIpCidrName;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyNatIpCidrAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyNatIpCidrAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyNatIpCidrAttributeResponse({}));
  }

  /**
   * Modifies the name and description of a NAT CIDR block.
   * 
   * @param request - ModifyNatIpCidrAttributeRequest
   * @returns ModifyNatIpCidrAttributeResponse
   */
  async modifyNatIpCidrAttribute(request: $_model.ModifyNatIpCidrAttributeRequest): Promise<$_model.ModifyNatIpCidrAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyNatIpCidrAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the attributes of a network access control list (ACL).
   * 
   * @param request - ModifyNetworkAclAttributesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyNetworkAclAttributesResponse
   */
  async modifyNetworkAclAttributesWithOptions(request: $_model.ModifyNetworkAclAttributesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyNetworkAclAttributesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.networkAclId)) {
      query["NetworkAclId"] = request.networkAclId;
    }

    if (!$dara.isNull(request.networkAclName)) {
      query["NetworkAclName"] = request.networkAclName;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyNetworkAclAttributes",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyNetworkAclAttributesResponse>(await this.callApi(params, req, runtime), new $_model.ModifyNetworkAclAttributesResponse({}));
  }

  /**
   * Modifies the attributes of a network access control list (ACL).
   * 
   * @param request - ModifyNetworkAclAttributesRequest
   * @returns ModifyNetworkAclAttributesResponse
   */
  async modifyNetworkAclAttributes(request: $_model.ModifyNetworkAclAttributesRequest): Promise<$_model.ModifyNetworkAclAttributesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyNetworkAclAttributesWithOptions(request, runtime);
  }

  /**
   * Modifies the configurations of an Express Connect circuit.
   * 
   * @remarks
   * When you call this operation, take note of the following limits:
   * *   If an Express Connect circuit is in the **Initial**, **Enabled**, or **Rejected** state, you can modify the specifications of the Express Connect circuit and the ID of the redundant circuit.
   * *   If an Express Connect circuit is in the **Canceled**, **Allocating**, **AllocationFailed**, or **Terminated** state, you cannot modify the specifications of the Express Connect circuit.
   * *   After you modify the specifications of an Express Connect circuit that is in the **Rejected** state, the Express Connect circuit enters the **Initial** state.
   * 
   * @param request - ModifyPhysicalConnectionAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyPhysicalConnectionAttributeResponse
   */
  async modifyPhysicalConnectionAttributeWithOptions(request: $_model.ModifyPhysicalConnectionAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyPhysicalConnectionAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.circuitCode)) {
      query["CircuitCode"] = request.circuitCode;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.lineOperator)) {
      query["LineOperator"] = request.lineOperator;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.peerLocation)) {
      query["PeerLocation"] = request.peerLocation;
    }

    if (!$dara.isNull(request.physicalConnectionId)) {
      query["PhysicalConnectionId"] = request.physicalConnectionId;
    }

    if (!$dara.isNull(request.portType)) {
      query["PortType"] = request.portType;
    }

    if (!$dara.isNull(request.redundantPhysicalConnectionId)) {
      query["RedundantPhysicalConnectionId"] = request.redundantPhysicalConnectionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.bandwidth)) {
      query["bandwidth"] = request.bandwidth;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyPhysicalConnectionAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyPhysicalConnectionAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyPhysicalConnectionAttributeResponse({}));
  }

  /**
   * Modifies the configurations of an Express Connect circuit.
   * 
   * @remarks
   * When you call this operation, take note of the following limits:
   * *   If an Express Connect circuit is in the **Initial**, **Enabled**, or **Rejected** state, you can modify the specifications of the Express Connect circuit and the ID of the redundant circuit.
   * *   If an Express Connect circuit is in the **Canceled**, **Allocating**, **AllocationFailed**, or **Terminated** state, you cannot modify the specifications of the Express Connect circuit.
   * *   After you modify the specifications of an Express Connect circuit that is in the **Rejected** state, the Express Connect circuit enters the **Initial** state.
   * 
   * @param request - ModifyPhysicalConnectionAttributeRequest
   * @returns ModifyPhysicalConnectionAttributeResponse
   */
  async modifyPhysicalConnectionAttribute(request: $_model.ModifyPhysicalConnectionAttributeRequest): Promise<$_model.ModifyPhysicalConnectionAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyPhysicalConnectionAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the name and description of a custom route entry.
   * 
   * @remarks
   * You cannot repeatedly call the **ModifyRouteEntry** operation to modify the name and description of a custom route within the specified period of time.
   * 
   * @param request - ModifyRouteEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyRouteEntryResponse
   */
  async modifyRouteEntryWithOptions(request: $_model.ModifyRouteEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyRouteEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.destinationCidrBlock)) {
      query["DestinationCidrBlock"] = request.destinationCidrBlock;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.newNextHopId)) {
      query["NewNextHopId"] = request.newNextHopId;
    }

    if (!$dara.isNull(request.newNextHopType)) {
      query["NewNextHopType"] = request.newNextHopType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeEntryId)) {
      query["RouteEntryId"] = request.routeEntryId;
    }

    if (!$dara.isNull(request.routeEntryName)) {
      query["RouteEntryName"] = request.routeEntryName;
    }

    if (!$dara.isNull(request.routeTableId)) {
      query["RouteTableId"] = request.routeTableId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyRouteEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyRouteEntryResponse>(await this.callApi(params, req, runtime), new $_model.ModifyRouteEntryResponse({}));
  }

  /**
   * Modifies the name and description of a custom route entry.
   * 
   * @remarks
   * You cannot repeatedly call the **ModifyRouteEntry** operation to modify the name and description of a custom route within the specified period of time.
   * 
   * @param request - ModifyRouteEntryRequest
   * @returns ModifyRouteEntryResponse
   */
  async modifyRouteEntry(request: $_model.ModifyRouteEntryRequest): Promise<$_model.ModifyRouteEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyRouteEntryWithOptions(request, runtime);
  }

  /**
   * Modifies the name and description of a route table.
   * 
   * @remarks
   * You cannot repeatedly call the **ModifyRouteTableAttributes** operation to modify the name and description of a route table within the specified period of time.
   * 
   * @param request - ModifyRouteTableAttributesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyRouteTableAttributesResponse
   */
  async modifyRouteTableAttributesWithOptions(request: $_model.ModifyRouteTableAttributesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyRouteTableAttributesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routePropagationEnable)) {
      query["RoutePropagationEnable"] = request.routePropagationEnable;
    }

    if (!$dara.isNull(request.routeTableId)) {
      query["RouteTableId"] = request.routeTableId;
    }

    if (!$dara.isNull(request.routeTableName)) {
      query["RouteTableName"] = request.routeTableName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyRouteTableAttributes",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyRouteTableAttributesResponse>(await this.callApi(params, req, runtime), new $_model.ModifyRouteTableAttributesResponse({}));
  }

  /**
   * Modifies the name and description of a route table.
   * 
   * @remarks
   * You cannot repeatedly call the **ModifyRouteTableAttributes** operation to modify the name and description of a route table within the specified period of time.
   * 
   * @param request - ModifyRouteTableAttributesRequest
   * @returns ModifyRouteTableAttributesResponse
   */
  async modifyRouteTableAttributes(request: $_model.ModifyRouteTableAttributesRequest): Promise<$_model.ModifyRouteTableAttributesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyRouteTableAttributesWithOptions(request, runtime);
  }

  /**
   * Modifies the configuration of a router interface.
   * 
   * @param request - ModifyRouterInterfaceAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyRouterInterfaceAttributeResponse
   */
  async modifyRouterInterfaceAttributeWithOptions(request: $_model.ModifyRouterInterfaceAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyRouterInterfaceAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.deleteHealthCheckIp)) {
      query["DeleteHealthCheckIp"] = request.deleteHealthCheckIp;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.hcRate)) {
      query["HcRate"] = request.hcRate;
    }

    if (!$dara.isNull(request.hcThreshold)) {
      query["HcThreshold"] = request.hcThreshold;
    }

    if (!$dara.isNull(request.healthCheckSourceIp)) {
      query["HealthCheckSourceIp"] = request.healthCheckSourceIp;
    }

    if (!$dara.isNull(request.healthCheckTargetIp)) {
      query["HealthCheckTargetIp"] = request.healthCheckTargetIp;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.oppositeInterfaceId)) {
      query["OppositeInterfaceId"] = request.oppositeInterfaceId;
    }

    if (!$dara.isNull(request.oppositeInterfaceOwnerId)) {
      query["OppositeInterfaceOwnerId"] = request.oppositeInterfaceOwnerId;
    }

    if (!$dara.isNull(request.oppositeRouterId)) {
      query["OppositeRouterId"] = request.oppositeRouterId;
    }

    if (!$dara.isNull(request.oppositeRouterType)) {
      query["OppositeRouterType"] = request.oppositeRouterType;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routerInterfaceId)) {
      query["RouterInterfaceId"] = request.routerInterfaceId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyRouterInterfaceAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyRouterInterfaceAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyRouterInterfaceAttributeResponse({}));
  }

  /**
   * Modifies the configuration of a router interface.
   * 
   * @param request - ModifyRouterInterfaceAttributeRequest
   * @returns ModifyRouterInterfaceAttributeResponse
   */
  async modifyRouterInterfaceAttribute(request: $_model.ModifyRouterInterfaceAttributeRequest): Promise<$_model.ModifyRouterInterfaceAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyRouterInterfaceAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the specification of a router interface.
   * 
   * @remarks
   * After you call this operation, the router interface enters the **Activating** state. After the router interface is activated, the router interface enters the **Active** state.
   * >  You cannot modify the specification of a router interface that has overdue payments.
   * 
   * @param request - ModifyRouterInterfaceSpecRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyRouterInterfaceSpecResponse
   */
  async modifyRouterInterfaceSpecWithOptions(request: $_model.ModifyRouterInterfaceSpecRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyRouterInterfaceSpecResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routerInterfaceId)) {
      query["RouterInterfaceId"] = request.routerInterfaceId;
    }

    if (!$dara.isNull(request.spec)) {
      query["Spec"] = request.spec;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyRouterInterfaceSpec",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyRouterInterfaceSpecResponse>(await this.callApi(params, req, runtime), new $_model.ModifyRouterInterfaceSpecResponse({}));
  }

  /**
   * Modifies the specification of a router interface.
   * 
   * @remarks
   * After you call this operation, the router interface enters the **Activating** state. After the router interface is activated, the router interface enters the **Active** state.
   * >  You cannot modify the specification of a router interface that has overdue payments.
   * 
   * @param request - ModifyRouterInterfaceSpecRequest
   * @returns ModifyRouterInterfaceSpecResponse
   */
  async modifyRouterInterfaceSpec(request: $_model.ModifyRouterInterfaceSpecRequest): Promise<$_model.ModifyRouterInterfaceSpecResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyRouterInterfaceSpecWithOptions(request, runtime);
  }

  /**
   * Modifies an SNAT entry.
   * 
   * @remarks
   * ## [](#)
   * **ModifySnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
   * *   **Pending**: indicates that the system is modifying the SNAT entry. You can only query the status of the SNAT entry, but cannot perform other operations.
   * *   **Available**: indicates that the SNAT entry is modified.
   * >  If an SNAT entry is in the **Pending** state, it indicates that you cannot modify the SNAT entry.
   * You cannot repeatedly call the **ModifySnatEntry** operation to modify an SNAT entry within a specific period of time.
   * 
   * @param request - ModifySnatEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifySnatEntryResponse
   */
  async modifySnatEntryWithOptions(request: $_model.ModifySnatEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifySnatEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.eipAffinity)) {
      query["EipAffinity"] = request.eipAffinity;
    }

    if (!$dara.isNull(request.networkInterfaceId)) {
      query["NetworkInterfaceId"] = request.networkInterfaceId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.snatEntryId)) {
      query["SnatEntryId"] = request.snatEntryId;
    }

    if (!$dara.isNull(request.snatEntryName)) {
      query["SnatEntryName"] = request.snatEntryName;
    }

    if (!$dara.isNull(request.snatIp)) {
      query["SnatIp"] = request.snatIp;
    }

    if (!$dara.isNull(request.snatTableId)) {
      query["SnatTableId"] = request.snatTableId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifySnatEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifySnatEntryResponse>(await this.callApi(params, req, runtime), new $_model.ModifySnatEntryResponse({}));
  }

  /**
   * Modifies an SNAT entry.
   * 
   * @remarks
   * ## [](#)
   * **ModifySnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
   * *   **Pending**: indicates that the system is modifying the SNAT entry. You can only query the status of the SNAT entry, but cannot perform other operations.
   * *   **Available**: indicates that the SNAT entry is modified.
   * >  If an SNAT entry is in the **Pending** state, it indicates that you cannot modify the SNAT entry.
   * You cannot repeatedly call the **ModifySnatEntry** operation to modify an SNAT entry within a specific period of time.
   * 
   * @param request - ModifySnatEntryRequest
   * @returns ModifySnatEntryResponse
   */
  async modifySnatEntry(request: $_model.ModifySnatEntryRequest): Promise<$_model.ModifySnatEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifySnatEntryWithOptions(request, runtime);
  }

  /**
   * Modifies the name of an SSL-VPN client certificate.
   * 
   * @param request - ModifySslVpnClientCertRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifySslVpnClientCertResponse
   */
  async modifySslVpnClientCertWithOptions(request: $_model.ModifySslVpnClientCertRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifySslVpnClientCertResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.sslVpnClientCertId)) {
      query["SslVpnClientCertId"] = request.sslVpnClientCertId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifySslVpnClientCert",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifySslVpnClientCertResponse>(await this.callApi(params, req, runtime), new $_model.ModifySslVpnClientCertResponse({}));
  }

  /**
   * Modifies the name of an SSL-VPN client certificate.
   * 
   * @param request - ModifySslVpnClientCertRequest
   * @returns ModifySslVpnClientCertResponse
   */
  async modifySslVpnClientCert(request: $_model.ModifySslVpnClientCertRequest): Promise<$_model.ModifySslVpnClientCertResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifySslVpnClientCertWithOptions(request, runtime);
  }

  /**
   * Modifies the configurations of an SSL server.
   * 
   * @remarks
   *   To enable two-factor authentication for an SSL server, make sure that the VPN gateway supports two-factor authentication. You may need to upgrade the VPN gateway. For more information, see [Two-factor authentication supports IDaaS EIAM 2.0](https://help.aliyun.com/document_detail/2785320.html).
   * *   If you modify only **Name**, this operation is synchronous. If you modify other parameters besides **Name**, this operation is asynchronous.
   * *   **ModifySslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the SSL server is being modified.
   *     *   If the VPN gateway is in the **active** state, the SSL server is modified.
   * *   You cannot repeatedly call **ModifySslVpnServer** within the specified period of time.
   * 
   * @param request - ModifySslVpnServerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifySslVpnServerResponse
   */
  async modifySslVpnServerWithOptions(request: $_model.ModifySslVpnServerRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifySslVpnServerResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.cipher)) {
      query["Cipher"] = request.cipher;
    }

    if (!$dara.isNull(request.clientIpPool)) {
      query["ClientIpPool"] = request.clientIpPool;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.compress)) {
      query["Compress"] = request.compress;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.enableMultiFactorAuth)) {
      query["EnableMultiFactorAuth"] = request.enableMultiFactorAuth;
    }

    if (!$dara.isNull(request.IDaaSApplicationId)) {
      query["IDaaSApplicationId"] = request.IDaaSApplicationId;
    }

    if (!$dara.isNull(request.IDaaSInstanceId)) {
      query["IDaaSInstanceId"] = request.IDaaSInstanceId;
    }

    if (!$dara.isNull(request.IDaaSRegionId)) {
      query["IDaaSRegionId"] = request.IDaaSRegionId;
    }

    if (!$dara.isNull(request.localSubnet)) {
      query["LocalSubnet"] = request.localSubnet;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.port)) {
      query["Port"] = request.port;
    }

    if (!$dara.isNull(request.proto)) {
      query["Proto"] = request.proto;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.sslVpnServerId)) {
      query["SslVpnServerId"] = request.sslVpnServerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifySslVpnServer",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifySslVpnServerResponse>(await this.callApi(params, req, runtime), new $_model.ModifySslVpnServerResponse({}));
  }

  /**
   * Modifies the configurations of an SSL server.
   * 
   * @remarks
   *   To enable two-factor authentication for an SSL server, make sure that the VPN gateway supports two-factor authentication. You may need to upgrade the VPN gateway. For more information, see [Two-factor authentication supports IDaaS EIAM 2.0](https://help.aliyun.com/document_detail/2785320.html).
   * *   If you modify only **Name**, this operation is synchronous. If you modify other parameters besides **Name**, this operation is asynchronous.
   * *   **ModifySslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the SSL server is being modified.
   *     *   If the VPN gateway is in the **active** state, the SSL server is modified.
   * *   You cannot repeatedly call **ModifySslVpnServer** within the specified period of time.
   * 
   * @param request - ModifySslVpnServerRequest
   * @returns ModifySslVpnServerResponse
   */
  async modifySslVpnServer(request: $_model.ModifySslVpnServerRequest): Promise<$_model.ModifySslVpnServerResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifySslVpnServerWithOptions(request, runtime);
  }

  /**
   * Modifies a VPN tunnel.
   * 
   * @param request - ModifyTunnelAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTunnelAttributeResponse
   */
  async modifyTunnelAttributeWithOptions(request: $_model.ModifyTunnelAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyTunnelAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.tunnelId)) {
      query["TunnelId"] = request.tunnelId;
    }

    if (!$dara.isNull(request.tunnelOptionsSpecification)) {
      query["TunnelOptionsSpecification"] = request.tunnelOptionsSpecification;
    }

    if (!$dara.isNull(request.vpnConnectionId)) {
      query["VpnConnectionId"] = request.vpnConnectionId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyTunnelAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyTunnelAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyTunnelAttributeResponse({}));
  }

  /**
   * Modifies a VPN tunnel.
   * 
   * @param request - ModifyTunnelAttributeRequest
   * @returns ModifyTunnelAttributeResponse
   */
  async modifyTunnelAttribute(request: $_model.ModifyTunnelAttributeRequest): Promise<$_model.ModifyTunnelAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyTunnelAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the name and description of a vRouter.
   * 
   * @remarks
   * You cannot repeatedly call the **ModifyVRouterAttribute** operation within a specific period of time.
   * 
   * @param request - ModifyVRouterAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyVRouterAttributeResponse
   */
  async modifyVRouterAttributeWithOptions(request: $_model.ModifyVRouterAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyVRouterAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.VRouterId)) {
      query["VRouterId"] = request.VRouterId;
    }

    if (!$dara.isNull(request.VRouterName)) {
      query["VRouterName"] = request.VRouterName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyVRouterAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyVRouterAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyVRouterAttributeResponse({}));
  }

  /**
   * Modifies the name and description of a vRouter.
   * 
   * @remarks
   * You cannot repeatedly call the **ModifyVRouterAttribute** operation within a specific period of time.
   * 
   * @param request - ModifyVRouterAttributeRequest
   * @returns ModifyVRouterAttributeResponse
   */
  async modifyVRouterAttribute(request: $_model.ModifyVRouterAttributeRequest): Promise<$_model.ModifyVRouterAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyVRouterAttributeWithOptions(request, runtime);
  }

  /**
   * VSwitch
   * 
   * @remarks
   *   **ModifyVSwitchAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
   *     *   If the vSwitch is in the **Pending** state, the name and description of the vSwitch are being modified.
   *     *   If the vSwitch is in the **Available** state, the name and description of the vSwitch are modified.
   * *   You cannot repeatedly call the **ModifyVSwitchAttribute** operation to modify the name and description of a vSwitch within the specified period of time.
   * 
   * @param request - ModifyVSwitchAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyVSwitchAttributeResponse
   */
  async modifyVSwitchAttributeWithOptions(request: $_model.ModifyVSwitchAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyVSwitchAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.enableIPv6)) {
      query["EnableIPv6"] = request.enableIPv6;
    }

    if (!$dara.isNull(request.ipv6CidrBlock)) {
      query["Ipv6CidrBlock"] = request.ipv6CidrBlock;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    if (!$dara.isNull(request.vSwitchName)) {
      query["VSwitchName"] = request.vSwitchName;
    }

    if (!$dara.isNull(request.vpcIpv6CidrBlock)) {
      query["VpcIpv6CidrBlock"] = request.vpcIpv6CidrBlock;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyVSwitchAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyVSwitchAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyVSwitchAttributeResponse({}));
  }

  /**
   * VSwitch
   * 
   * @remarks
   *   **ModifyVSwitchAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
   *     *   If the vSwitch is in the **Pending** state, the name and description of the vSwitch are being modified.
   *     *   If the vSwitch is in the **Available** state, the name and description of the vSwitch are modified.
   * *   You cannot repeatedly call the **ModifyVSwitchAttribute** operation to modify the name and description of a vSwitch within the specified period of time.
   * 
   * @param request - ModifyVSwitchAttributeRequest
   * @returns ModifyVSwitchAttributeResponse
   */
  async modifyVSwitchAttribute(request: $_model.ModifyVSwitchAttributeRequest): Promise<$_model.ModifyVSwitchAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyVSwitchAttributeWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @remarks
   * ## [](#)Usage notes
   * You cannot repeatedly call **ModifyVSwitchCidrReservationAttribute** within a specific time period.
   * 
   * @param request - ModifyVSwitchCidrReservationAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyVSwitchCidrReservationAttributeResponse
   */
  async modifyVSwitchCidrReservationAttributeWithOptions(request: $_model.ModifyVSwitchCidrReservationAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyVSwitchCidrReservationAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vSwitchCidrReservationDescription)) {
      query["VSwitchCidrReservationDescription"] = request.vSwitchCidrReservationDescription;
    }

    if (!$dara.isNull(request.vSwitchCidrReservationId)) {
      query["VSwitchCidrReservationId"] = request.vSwitchCidrReservationId;
    }

    if (!$dara.isNull(request.vSwitchCidrReservationName)) {
      query["VSwitchCidrReservationName"] = request.vSwitchCidrReservationName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyVSwitchCidrReservationAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyVSwitchCidrReservationAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyVSwitchCidrReservationAttributeResponse({}));
  }

  /**
   * 
   * 
   * @remarks
   * ## [](#)Usage notes
   * You cannot repeatedly call **ModifyVSwitchCidrReservationAttribute** within a specific time period.
   * 
   * @param request - ModifyVSwitchCidrReservationAttributeRequest
   * @returns ModifyVSwitchCidrReservationAttributeResponse
   */
  async modifyVSwitchCidrReservationAttribute(request: $_model.ModifyVSwitchCidrReservationAttributeRequest): Promise<$_model.ModifyVSwitchCidrReservationAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyVSwitchCidrReservationAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the weight of a destination-based route for an IPsec-VPN connection.
   * 
   * @remarks
   *   **ModifyVcoRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the associated IPsec-VPN connection and determine whether the weight of the specified destination-based route is modified.
   *     *   If the IPsec-VPN connection is in the **updating** state, the weight of the destination-based route is being modified.
   *     *   If the IPsec-VPN connection is in the **attached** state, the weight of the destination-based route is modified.
   * *   You cannot repeatedly call the **ModifyVcoRouteEntryWeight** operation for the same IPsec-VPN connection within the specified period of time.
   * 
   * @param request - ModifyVcoRouteEntryWeightRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyVcoRouteEntryWeightResponse
   */
  async modifyVcoRouteEntryWeightWithOptions(request: $_model.ModifyVcoRouteEntryWeightRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyVcoRouteEntryWeightResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.newWeight)) {
      query["NewWeight"] = request.newWeight;
    }

    if (!$dara.isNull(request.nextHop)) {
      query["NextHop"] = request.nextHop;
    }

    if (!$dara.isNull(request.overlayMode)) {
      query["OverlayMode"] = request.overlayMode;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeDest)) {
      query["RouteDest"] = request.routeDest;
    }

    if (!$dara.isNull(request.vpnConnectionId)) {
      query["VpnConnectionId"] = request.vpnConnectionId;
    }

    if (!$dara.isNull(request.weight)) {
      query["Weight"] = request.weight;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyVcoRouteEntryWeight",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyVcoRouteEntryWeightResponse>(await this.callApi(params, req, runtime), new $_model.ModifyVcoRouteEntryWeightResponse({}));
  }

  /**
   * Modifies the weight of a destination-based route for an IPsec-VPN connection.
   * 
   * @remarks
   *   **ModifyVcoRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the associated IPsec-VPN connection and determine whether the weight of the specified destination-based route is modified.
   *     *   If the IPsec-VPN connection is in the **updating** state, the weight of the destination-based route is being modified.
   *     *   If the IPsec-VPN connection is in the **attached** state, the weight of the destination-based route is modified.
   * *   You cannot repeatedly call the **ModifyVcoRouteEntryWeight** operation for the same IPsec-VPN connection within the specified period of time.
   * 
   * @param request - ModifyVcoRouteEntryWeightRequest
   * @returns ModifyVcoRouteEntryWeightResponse
   */
  async modifyVcoRouteEntryWeight(request: $_model.ModifyVcoRouteEntryWeightRequest): Promise<$_model.ModifyVcoRouteEntryWeightResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyVcoRouteEntryWeightWithOptions(request, runtime);
  }

  /**
   * Modifies the configuration of a virtual border router (VBR).
   * 
   * @remarks
   * # [](#)
   * *   Only the owner of an Express Connect circuit can modify the **VlanId** parameter.
   * *   One VLAN ID of an Express Connect circuit cannot be used only by one VBR at the same time.
   * *   The VLAN ID of a VBR in the **Terminated** state is reserved for seven days and cannot be used by other VBRs. The VLAN ID can be used by other VBRs after 7 days.
   * *   You cannot set **LocalGatewayIp**, **PeerGatewayIp**, or **PeeringSubnetMask** for VBRs that do not belong to your Alibaba Cloud account.
   * *   Set **PeeringSubnetMask** to a subnet mask with 24 to 30 bits in length (255.255.255.0255.255.255.252).
   * *   Set **LocalGatewayIp** and **PeerGatewayIp** to IP addresses that belong to the same CIDR block. For example, you can set LocalGatewayIp to 192.168.XX.XX, PeerGatewayIp to 192.168.XX.XX, and PeeringSubnetMask to 255.255.255.248.
   * 
   * @param request - ModifyVirtualBorderRouterAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyVirtualBorderRouterAttributeResponse
   */
  async modifyVirtualBorderRouterAttributeWithOptions(request: $_model.ModifyVirtualBorderRouterAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyVirtualBorderRouterAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.associatedPhysicalConnections)) {
      query["AssociatedPhysicalConnections"] = request.associatedPhysicalConnections;
    }

    if (!$dara.isNull(request.bandwidth)) {
      query["Bandwidth"] = request.bandwidth;
    }

    if (!$dara.isNull(request.circuitCode)) {
      query["CircuitCode"] = request.circuitCode;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.detectMultiplier)) {
      query["DetectMultiplier"] = request.detectMultiplier;
    }

    if (!$dara.isNull(request.enableIpv6)) {
      query["EnableIpv6"] = request.enableIpv6;
    }

    if (!$dara.isNull(request.localGatewayIp)) {
      query["LocalGatewayIp"] = request.localGatewayIp;
    }

    if (!$dara.isNull(request.localIpv6GatewayIp)) {
      query["LocalIpv6GatewayIp"] = request.localIpv6GatewayIp;
    }

    if (!$dara.isNull(request.minRxInterval)) {
      query["MinRxInterval"] = request.minRxInterval;
    }

    if (!$dara.isNull(request.minTxInterval)) {
      query["MinTxInterval"] = request.minTxInterval;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.peerGatewayIp)) {
      query["PeerGatewayIp"] = request.peerGatewayIp;
    }

    if (!$dara.isNull(request.peerIpv6GatewayIp)) {
      query["PeerIpv6GatewayIp"] = request.peerIpv6GatewayIp;
    }

    if (!$dara.isNull(request.peeringIpv6SubnetMask)) {
      query["PeeringIpv6SubnetMask"] = request.peeringIpv6SubnetMask;
    }

    if (!$dara.isNull(request.peeringSubnetMask)) {
      query["PeeringSubnetMask"] = request.peeringSubnetMask;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.sitelinkEnable)) {
      query["SitelinkEnable"] = request.sitelinkEnable;
    }

    if (!$dara.isNull(request.vbrId)) {
      query["VbrId"] = request.vbrId;
    }

    if (!$dara.isNull(request.vlanId)) {
      query["VlanId"] = request.vlanId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyVirtualBorderRouterAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyVirtualBorderRouterAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyVirtualBorderRouterAttributeResponse({}));
  }

  /**
   * Modifies the configuration of a virtual border router (VBR).
   * 
   * @remarks
   * # [](#)
   * *   Only the owner of an Express Connect circuit can modify the **VlanId** parameter.
   * *   One VLAN ID of an Express Connect circuit cannot be used only by one VBR at the same time.
   * *   The VLAN ID of a VBR in the **Terminated** state is reserved for seven days and cannot be used by other VBRs. The VLAN ID can be used by other VBRs after 7 days.
   * *   You cannot set **LocalGatewayIp**, **PeerGatewayIp**, or **PeeringSubnetMask** for VBRs that do not belong to your Alibaba Cloud account.
   * *   Set **PeeringSubnetMask** to a subnet mask with 24 to 30 bits in length (255.255.255.0255.255.255.252).
   * *   Set **LocalGatewayIp** and **PeerGatewayIp** to IP addresses that belong to the same CIDR block. For example, you can set LocalGatewayIp to 192.168.XX.XX, PeerGatewayIp to 192.168.XX.XX, and PeeringSubnetMask to 255.255.255.248.
   * 
   * @param request - ModifyVirtualBorderRouterAttributeRequest
   * @returns ModifyVirtualBorderRouterAttributeResponse
   */
  async modifyVirtualBorderRouterAttribute(request: $_model.ModifyVirtualBorderRouterAttributeRequest): Promise<$_model.ModifyVirtualBorderRouterAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyVirtualBorderRouterAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the name and description of a virtual private cloud (VPC).
   * 
   * @remarks
   * ## [](#)Description
   * You cannot repeatedly call the **ModifyVpcAttribute** operation to modify the name and description of a VPC within the specified period of time.
   * 
   * @param request - ModifyVpcAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyVpcAttributeResponse
   */
  async modifyVpcAttributeWithOptions(request: $_model.ModifyVpcAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyVpcAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.cidrBlock)) {
      query["CidrBlock"] = request.cidrBlock;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.enableDnsHostname)) {
      query["EnableDnsHostname"] = request.enableDnsHostname;
    }

    if (!$dara.isNull(request.enableIPv6)) {
      query["EnableIPv6"] = request.enableIPv6;
    }

    if (!$dara.isNull(request.ipv6CidrBlock)) {
      query["Ipv6CidrBlock"] = request.ipv6CidrBlock;
    }

    if (!$dara.isNull(request.ipv6Isp)) {
      query["Ipv6Isp"] = request.ipv6Isp;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    if (!$dara.isNull(request.vpcName)) {
      query["VpcName"] = request.vpcName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyVpcAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyVpcAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyVpcAttributeResponse({}));
  }

  /**
   * Modifies the name and description of a virtual private cloud (VPC).
   * 
   * @remarks
   * ## [](#)Description
   * You cannot repeatedly call the **ModifyVpcAttribute** operation to modify the name and description of a VPC within the specified period of time.
   * 
   * @param request - ModifyVpcAttributeRequest
   * @returns ModifyVpcAttributeResponse
   */
  async modifyVpcAttribute(request: $_model.ModifyVpcAttributeRequest): Promise<$_model.ModifyVpcAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyVpcAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the configuration of a prefix list.
   * 
   * @remarks
   *   **ModifyVpcPrefixList** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPrefixLists](https://help.aliyun.com/document_detail/311535.html) to query the status of the task.
   *     *   If the prefix list is in the **Modifying** state, the configuration of the prefix list is being modified.
   *     *   If the prefix list is in the **Created** state, the configuration of the prefix list is modified.
   *     *   After the configuration of the prefix list is modified, you can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) operation to query the information about the network instances that are associated with the prefix list and determine whether the associated network instances use the new CIDR blocks. If the association **status** of the prefix list is **Created**, the new CIDR blocks are used by the network instances that are associated with the prefix list.
   * *   You cannot repeatedly call **ModifyVpcPrefixList** to modify the configuration of a prefix list within the specified period of time.
   * 
   * @param request - ModifyVpcPrefixListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyVpcPrefixListResponse
   */
  async modifyVpcPrefixListWithOptions(request: $_model.ModifyVpcPrefixListRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyVpcPrefixListResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.addPrefixListEntry)) {
      query["AddPrefixListEntry"] = request.addPrefixListEntry;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.maxEntries)) {
      query["MaxEntries"] = request.maxEntries;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.prefixListDescription)) {
      query["PrefixListDescription"] = request.prefixListDescription;
    }

    if (!$dara.isNull(request.prefixListId)) {
      query["PrefixListId"] = request.prefixListId;
    }

    if (!$dara.isNull(request.prefixListName)) {
      query["PrefixListName"] = request.prefixListName;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.removePrefixListEntry)) {
      query["RemovePrefixListEntry"] = request.removePrefixListEntry;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyVpcPrefixList",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyVpcPrefixListResponse>(await this.callApi(params, req, runtime), new $_model.ModifyVpcPrefixListResponse({}));
  }

  /**
   * Modifies the configuration of a prefix list.
   * 
   * @remarks
   *   **ModifyVpcPrefixList** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPrefixLists](https://help.aliyun.com/document_detail/311535.html) to query the status of the task.
   *     *   If the prefix list is in the **Modifying** state, the configuration of the prefix list is being modified.
   *     *   If the prefix list is in the **Created** state, the configuration of the prefix list is modified.
   *     *   After the configuration of the prefix list is modified, you can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) operation to query the information about the network instances that are associated with the prefix list and determine whether the associated network instances use the new CIDR blocks. If the association **status** of the prefix list is **Created**, the new CIDR blocks are used by the network instances that are associated with the prefix list.
   * *   You cannot repeatedly call **ModifyVpcPrefixList** to modify the configuration of a prefix list within the specified period of time.
   * 
   * @param request - ModifyVpcPrefixListRequest
   * @returns ModifyVpcPrefixListResponse
   */
  async modifyVpcPrefixList(request: $_model.ModifyVpcPrefixListRequest): Promise<$_model.ModifyVpcPrefixListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyVpcPrefixListWithOptions(request, runtime);
  }

  /**
   * Modifies the configuration of an IPsec-VPN connection.
   * 
   * @remarks
   *   When you modify a IPsec-VPN connection in dual-tunnel mode, you can configure the following parameters in addition to the required request parameters: **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
   * *   When you modify a IPsec-VPN connection in single tunnel mode, you can configure the following parameters in addition to the required request parameters: **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **CustomerGatewayId**.
   * *   **ModifyVpnAttachmentAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task:
   *     *   If the IPsec-VPN connection is in the **updating** state, the IPsec-VPN connection is being modified.
   *     *   If the IPsec-VPN connection is in the **attached** state, the IPsec-VPN connection is modified.
   * *   You cannot concurrently call **ModifyVpnAttachmentAttribute** within the specified period of time.
   * *   You cannot call **ModifyVpnAttachmentAttribute** to modify the gateway type of an IPsec-VPN connection.
   * 
   * @param request - ModifyVpnAttachmentAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyVpnAttachmentAttributeResponse
   */
  async modifyVpnAttachmentAttributeWithOptions(request: $_model.ModifyVpnAttachmentAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyVpnAttachmentAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.autoConfigRoute)) {
      query["AutoConfigRoute"] = request.autoConfigRoute;
    }

    if (!$dara.isNull(request.bgpConfig)) {
      query["BgpConfig"] = request.bgpConfig;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.customerGatewayId)) {
      query["CustomerGatewayId"] = request.customerGatewayId;
    }

    if (!$dara.isNull(request.effectImmediately)) {
      query["EffectImmediately"] = request.effectImmediately;
    }

    if (!$dara.isNull(request.enableDpd)) {
      query["EnableDpd"] = request.enableDpd;
    }

    if (!$dara.isNull(request.enableNatTraversal)) {
      query["EnableNatTraversal"] = request.enableNatTraversal;
    }

    if (!$dara.isNull(request.enableTunnelsBgp)) {
      query["EnableTunnelsBgp"] = request.enableTunnelsBgp;
    }

    if (!$dara.isNull(request.healthCheckConfig)) {
      query["HealthCheckConfig"] = request.healthCheckConfig;
    }

    if (!$dara.isNull(request.ikeConfig)) {
      query["IkeConfig"] = request.ikeConfig;
    }

    if (!$dara.isNull(request.ipsecConfig)) {
      query["IpsecConfig"] = request.ipsecConfig;
    }

    if (!$dara.isNull(request.localSubnet)) {
      query["LocalSubnet"] = request.localSubnet;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.networkType)) {
      query["NetworkType"] = request.networkType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.remoteCaCert)) {
      query["RemoteCaCert"] = request.remoteCaCert;
    }

    if (!$dara.isNull(request.remoteSubnet)) {
      query["RemoteSubnet"] = request.remoteSubnet;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpnConnectionId)) {
      query["VpnConnectionId"] = request.vpnConnectionId;
    }

    let body : {[key: string ]: any} = { };
    let bodyFlat : {[key: string ]: any} = { };
    if (!$dara.isNull(request.tunnelOptionsSpecification)) {
      bodyFlat["TunnelOptionsSpecification"] = request.tunnelOptionsSpecification;
    }

    body = {
      ...body,
      ...OpenApiUtil.query(bodyFlat),
    };
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyVpnAttachmentAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyVpnAttachmentAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyVpnAttachmentAttributeResponse({}));
  }

  /**
   * Modifies the configuration of an IPsec-VPN connection.
   * 
   * @remarks
   *   When you modify a IPsec-VPN connection in dual-tunnel mode, you can configure the following parameters in addition to the required request parameters: **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
   * *   When you modify a IPsec-VPN connection in single tunnel mode, you can configure the following parameters in addition to the required request parameters: **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **CustomerGatewayId**.
   * *   **ModifyVpnAttachmentAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task:
   *     *   If the IPsec-VPN connection is in the **updating** state, the IPsec-VPN connection is being modified.
   *     *   If the IPsec-VPN connection is in the **attached** state, the IPsec-VPN connection is modified.
   * *   You cannot concurrently call **ModifyVpnAttachmentAttribute** within the specified period of time.
   * *   You cannot call **ModifyVpnAttachmentAttribute** to modify the gateway type of an IPsec-VPN connection.
   * 
   * @param request - ModifyVpnAttachmentAttributeRequest
   * @returns ModifyVpnAttachmentAttributeResponse
   */
  async modifyVpnAttachmentAttribute(request: $_model.ModifyVpnAttachmentAttributeRequest): Promise<$_model.ModifyVpnAttachmentAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyVpnAttachmentAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the configuration of an IPsec-VPN connection.
   * 
   * @remarks
   *   If you want to modify a IPsec-VPN connection in dual-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
   *     **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification**, and **EnableTunnelsBgp**.
   * *   If you want to modify a IPsec-VPN connection in single-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
   *     **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **RemoteCaCertificate**.
   * *   **ModifyVpnConnectionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and modifies the configuration of the IPsec-VPN connection in the backend. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
   *     *   If the VPN gateway is in the **updating** state, the configuration of the IPsec-VPN connection is being modified.
   *     *   If the VPN gateway is in the **active** state, the configuration of the IPsec-VPN connection is modified.
   * *   You cannot repeatedly call the **ModifyVpnConnectionAttribute** operation for the same VPN gateway within the specified period of time.
   * 
   * @param request - ModifyVpnConnectionAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyVpnConnectionAttributeResponse
   */
  async modifyVpnConnectionAttributeWithOptions(request: $_model.ModifyVpnConnectionAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyVpnConnectionAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.autoConfigRoute)) {
      query["AutoConfigRoute"] = request.autoConfigRoute;
    }

    if (!$dara.isNull(request.bgpConfig)) {
      query["BgpConfig"] = request.bgpConfig;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.effectImmediately)) {
      query["EffectImmediately"] = request.effectImmediately;
    }

    if (!$dara.isNull(request.enableDpd)) {
      query["EnableDpd"] = request.enableDpd;
    }

    if (!$dara.isNull(request.enableNatTraversal)) {
      query["EnableNatTraversal"] = request.enableNatTraversal;
    }

    if (!$dara.isNull(request.enableTunnelsBgp)) {
      query["EnableTunnelsBgp"] = request.enableTunnelsBgp;
    }

    if (!$dara.isNull(request.healthCheckConfig)) {
      query["HealthCheckConfig"] = request.healthCheckConfig;
    }

    if (!$dara.isNull(request.ikeConfig)) {
      query["IkeConfig"] = request.ikeConfig;
    }

    if (!$dara.isNull(request.ipsecConfig)) {
      query["IpsecConfig"] = request.ipsecConfig;
    }

    if (!$dara.isNull(request.localSubnet)) {
      query["LocalSubnet"] = request.localSubnet;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.remoteCaCertificate)) {
      query["RemoteCaCertificate"] = request.remoteCaCertificate;
    }

    if (!$dara.isNull(request.remoteSubnet)) {
      query["RemoteSubnet"] = request.remoteSubnet;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpnConnectionId)) {
      query["VpnConnectionId"] = request.vpnConnectionId;
    }

    let body : {[key: string ]: any} = { };
    let bodyFlat : {[key: string ]: any} = { };
    if (!$dara.isNull(request.tunnelOptionsSpecification)) {
      bodyFlat["TunnelOptionsSpecification"] = request.tunnelOptionsSpecification;
    }

    body = {
      ...body,
      ...OpenApiUtil.query(bodyFlat),
    };
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyVpnConnectionAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyVpnConnectionAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyVpnConnectionAttributeResponse({}));
  }

  /**
   * Modifies the configuration of an IPsec-VPN connection.
   * 
   * @remarks
   *   If you want to modify a IPsec-VPN connection in dual-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
   *     **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification**, and **EnableTunnelsBgp**.
   * *   If you want to modify a IPsec-VPN connection in single-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
   *     **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **RemoteCaCertificate**.
   * *   **ModifyVpnConnectionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and modifies the configuration of the IPsec-VPN connection in the backend. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
   *     *   If the VPN gateway is in the **updating** state, the configuration of the IPsec-VPN connection is being modified.
   *     *   If the VPN gateway is in the **active** state, the configuration of the IPsec-VPN connection is modified.
   * *   You cannot repeatedly call the **ModifyVpnConnectionAttribute** operation for the same VPN gateway within the specified period of time.
   * 
   * @param request - ModifyVpnConnectionAttributeRequest
   * @returns ModifyVpnConnectionAttributeResponse
   */
  async modifyVpnConnectionAttribute(request: $_model.ModifyVpnConnectionAttributeRequest): Promise<$_model.ModifyVpnConnectionAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyVpnConnectionAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the name and description of a VPN gateway.
   * 
   * @remarks
   *   **ModifyVpnGatewayAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the VPN gateway is being modified.
   *     *   If the VPN gateway is in the **active** state, the VPN gateway is modified.
   * *   You cannot repeatedly call **ModifyVpnGatewayAttribute** to modify a VPN gateway within the specified period of time.
   * 
   * @param request - ModifyVpnGatewayAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyVpnGatewayAttributeResponse
   */
  async modifyVpnGatewayAttributeWithOptions(request: $_model.ModifyVpnGatewayAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyVpnGatewayAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.autoPropagate)) {
      query["AutoPropagate"] = request.autoPropagate;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyVpnGatewayAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyVpnGatewayAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyVpnGatewayAttributeResponse({}));
  }

  /**
   * Modifies the name and description of a VPN gateway.
   * 
   * @remarks
   *   **ModifyVpnGatewayAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the VPN gateway is being modified.
   *     *   If the VPN gateway is in the **active** state, the VPN gateway is modified.
   * *   You cannot repeatedly call **ModifyVpnGatewayAttribute** to modify a VPN gateway within the specified period of time.
   * 
   * @param request - ModifyVpnGatewayAttributeRequest
   * @returns ModifyVpnGatewayAttributeResponse
   */
  async modifyVpnGatewayAttribute(request: $_model.ModifyVpnGatewayAttributeRequest): Promise<$_model.ModifyVpnGatewayAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyVpnGatewayAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the weight and priority of a policy-based route.
   * 
   * @remarks
   *   You can call the **ModifyVpnPbrRouteEntryAttribute** operation to modify the weight and priority of a policy-based route.
   *     *   If you want to modify only the weight of a policy-based route, call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html).
   *     *   If you want to modify only the priority of a policy-based route, call [ModifyVpnPbrRouteEntryPriority](https://help.aliyun.com/document_detail/466870.html).
   *     *   If a policy-based route does not support priorities, you can only call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html) to modify its weight.
   * *   The **ModifyVpnPbrRouteEntryAttribute** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
   *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
   *     *   If a VPN gateway is in the **active** state, the policy-based route entry is modified.
   * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryAttribute** operation for the same VPN gateway within the specified period of time.
   * 
   * @param request - ModifyVpnPbrRouteEntryAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyVpnPbrRouteEntryAttributeResponse
   */
  async modifyVpnPbrRouteEntryAttributeWithOptions(request: $_model.ModifyVpnPbrRouteEntryAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyVpnPbrRouteEntryAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.newPriority)) {
      query["NewPriority"] = request.newPriority;
    }

    if (!$dara.isNull(request.newWeight)) {
      query["NewWeight"] = request.newWeight;
    }

    if (!$dara.isNull(request.nextHop)) {
      query["NextHop"] = request.nextHop;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.priority)) {
      query["Priority"] = request.priority;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeDest)) {
      query["RouteDest"] = request.routeDest;
    }

    if (!$dara.isNull(request.routeSource)) {
      query["RouteSource"] = request.routeSource;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    if (!$dara.isNull(request.weight)) {
      query["Weight"] = request.weight;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyVpnPbrRouteEntryAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyVpnPbrRouteEntryAttributeResponse>(await this.callApi(params, req, runtime), new $_model.ModifyVpnPbrRouteEntryAttributeResponse({}));
  }

  /**
   * Modifies the weight and priority of a policy-based route.
   * 
   * @remarks
   *   You can call the **ModifyVpnPbrRouteEntryAttribute** operation to modify the weight and priority of a policy-based route.
   *     *   If you want to modify only the weight of a policy-based route, call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html).
   *     *   If you want to modify only the priority of a policy-based route, call [ModifyVpnPbrRouteEntryPriority](https://help.aliyun.com/document_detail/466870.html).
   *     *   If a policy-based route does not support priorities, you can only call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html) to modify its weight.
   * *   The **ModifyVpnPbrRouteEntryAttribute** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
   *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
   *     *   If a VPN gateway is in the **active** state, the policy-based route entry is modified.
   * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryAttribute** operation for the same VPN gateway within the specified period of time.
   * 
   * @param request - ModifyVpnPbrRouteEntryAttributeRequest
   * @returns ModifyVpnPbrRouteEntryAttributeResponse
   */
  async modifyVpnPbrRouteEntryAttribute(request: $_model.ModifyVpnPbrRouteEntryAttributeRequest): Promise<$_model.ModifyVpnPbrRouteEntryAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyVpnPbrRouteEntryAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the priority of a policy-based route.
   * 
   * @remarks
   *   **ModifyVpnPbrRouteEntryPriority** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
   *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
   *     *   If the VPN gateway is in the **active** state, the policy-based route is created.
   * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryPriority** operation for the same VPN gateway within the specified period of time.
   * 
   * @param request - ModifyVpnPbrRouteEntryPriorityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyVpnPbrRouteEntryPriorityResponse
   */
  async modifyVpnPbrRouteEntryPriorityWithOptions(request: $_model.ModifyVpnPbrRouteEntryPriorityRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyVpnPbrRouteEntryPriorityResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.newPriority)) {
      query["NewPriority"] = request.newPriority;
    }

    if (!$dara.isNull(request.nextHop)) {
      query["NextHop"] = request.nextHop;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.priority)) {
      query["Priority"] = request.priority;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeDest)) {
      query["RouteDest"] = request.routeDest;
    }

    if (!$dara.isNull(request.routeSource)) {
      query["RouteSource"] = request.routeSource;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    if (!$dara.isNull(request.weight)) {
      query["Weight"] = request.weight;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyVpnPbrRouteEntryPriority",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyVpnPbrRouteEntryPriorityResponse>(await this.callApi(params, req, runtime), new $_model.ModifyVpnPbrRouteEntryPriorityResponse({}));
  }

  /**
   * Modifies the priority of a policy-based route.
   * 
   * @remarks
   *   **ModifyVpnPbrRouteEntryPriority** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
   *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
   *     *   If the VPN gateway is in the **active** state, the policy-based route is created.
   * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryPriority** operation for the same VPN gateway within the specified period of time.
   * 
   * @param request - ModifyVpnPbrRouteEntryPriorityRequest
   * @returns ModifyVpnPbrRouteEntryPriorityResponse
   */
  async modifyVpnPbrRouteEntryPriority(request: $_model.ModifyVpnPbrRouteEntryPriorityRequest): Promise<$_model.ModifyVpnPbrRouteEntryPriorityResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyVpnPbrRouteEntryPriorityWithOptions(request, runtime);
  }

  /**
   * Modifies the weight of a policy-based route of a VPN gateway.
   * 
   * @remarks
   *   **ModifyVpnPbrRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
   *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
   *     *   If a VPN gateway is in the **active** state, the policy-based route entry is modified.
   * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryWeight** operation for the same VPN gateway within the specified period of time.
   * 
   * @param request - ModifyVpnPbrRouteEntryWeightRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyVpnPbrRouteEntryWeightResponse
   */
  async modifyVpnPbrRouteEntryWeightWithOptions(request: $_model.ModifyVpnPbrRouteEntryWeightRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyVpnPbrRouteEntryWeightResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.newWeight)) {
      query["NewWeight"] = request.newWeight;
    }

    if (!$dara.isNull(request.nextHop)) {
      query["NextHop"] = request.nextHop;
    }

    if (!$dara.isNull(request.overlayMode)) {
      query["OverlayMode"] = request.overlayMode;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.priority)) {
      query["Priority"] = request.priority;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeDest)) {
      query["RouteDest"] = request.routeDest;
    }

    if (!$dara.isNull(request.routeSource)) {
      query["RouteSource"] = request.routeSource;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    if (!$dara.isNull(request.weight)) {
      query["Weight"] = request.weight;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyVpnPbrRouteEntryWeight",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyVpnPbrRouteEntryWeightResponse>(await this.callApi(params, req, runtime), new $_model.ModifyVpnPbrRouteEntryWeightResponse({}));
  }

  /**
   * Modifies the weight of a policy-based route of a VPN gateway.
   * 
   * @remarks
   *   **ModifyVpnPbrRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
   *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
   *     *   If a VPN gateway is in the **active** state, the policy-based route entry is modified.
   * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryWeight** operation for the same VPN gateway within the specified period of time.
   * 
   * @param request - ModifyVpnPbrRouteEntryWeightRequest
   * @returns ModifyVpnPbrRouteEntryWeightResponse
   */
  async modifyVpnPbrRouteEntryWeight(request: $_model.ModifyVpnPbrRouteEntryWeightRequest): Promise<$_model.ModifyVpnPbrRouteEntryWeightResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyVpnPbrRouteEntryWeightWithOptions(request, runtime);
  }

  /**
   * Modifies the weight of a destination-based route.
   * 
   * @remarks
   *   In scenarios where a VPN gateway has an active and a standby destination-based route, if you need to modify the weight of the active destination-based route, you must first delete the standby destination-based route. After you modify the active destination-based route, configure a standby destination-based route. If you need to modify the weight of the standby destination-based route, you also need to delete the active destination-based route first. After you modify the standby destination-based route, configure an active destination-based route. For more information about how to delete a destination-based route, see [DeleteVpnRouteEntry](https://help.aliyun.com/document_detail/2526961.html).
   * *   **ModifyVpnRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the weight of the destination-based route is being modified.
   *     *   If the VPN gateway is in the **active** state, the weight of the destination-based route is modified.
   * *   You cannot repeatedly call the **ModifyVpnRouteEntryWeight** operation to modify the weight of destination-based route for the same VPN gateway within the specified period of time.
   * 
   * @param request - ModifyVpnRouteEntryWeightRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyVpnRouteEntryWeightResponse
   */
  async modifyVpnRouteEntryWeightWithOptions(request: $_model.ModifyVpnRouteEntryWeightRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ModifyVpnRouteEntryWeightResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.newWeight)) {
      query["NewWeight"] = request.newWeight;
    }

    if (!$dara.isNull(request.nextHop)) {
      query["NextHop"] = request.nextHop;
    }

    if (!$dara.isNull(request.overlayMode)) {
      query["OverlayMode"] = request.overlayMode;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeDest)) {
      query["RouteDest"] = request.routeDest;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    if (!$dara.isNull(request.weight)) {
      query["Weight"] = request.weight;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyVpnRouteEntryWeight",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ModifyVpnRouteEntryWeightResponse>(await this.callApi(params, req, runtime), new $_model.ModifyVpnRouteEntryWeightResponse({}));
  }

  /**
   * Modifies the weight of a destination-based route.
   * 
   * @remarks
   *   In scenarios where a VPN gateway has an active and a standby destination-based route, if you need to modify the weight of the active destination-based route, you must first delete the standby destination-based route. After you modify the active destination-based route, configure a standby destination-based route. If you need to modify the weight of the standby destination-based route, you also need to delete the active destination-based route first. After you modify the standby destination-based route, configure an active destination-based route. For more information about how to delete a destination-based route, see [DeleteVpnRouteEntry](https://help.aliyun.com/document_detail/2526961.html).
   * *   **ModifyVpnRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the weight of the destination-based route is being modified.
   *     *   If the VPN gateway is in the **active** state, the weight of the destination-based route is modified.
   * *   You cannot repeatedly call the **ModifyVpnRouteEntryWeight** operation to modify the weight of destination-based route for the same VPN gateway within the specified period of time.
   * 
   * @param request - ModifyVpnRouteEntryWeightRequest
   * @returns ModifyVpnRouteEntryWeightResponse
   */
  async modifyVpnRouteEntryWeight(request: $_model.ModifyVpnRouteEntryWeightRequest): Promise<$_model.ModifyVpnRouteEntryWeightResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyVpnRouteEntryWeightWithOptions(request, runtime);
  }

  /**
   * Moves a resource to another resource group.
   * 
   * @param request - MoveResourceGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns MoveResourceGroupResponse
   */
  async moveResourceGroupWithOptions(request: $_model.MoveResourceGroupRequest, runtime: $dara.RuntimeOptions): Promise<$_model.MoveResourceGroupResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.newResourceGroupId)) {
      query["NewResourceGroupId"] = request.newResourceGroupId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "MoveResourceGroup",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.MoveResourceGroupResponse>(await this.callApi(params, req, runtime), new $_model.MoveResourceGroupResponse({}));
  }

  /**
   * Moves a resource to another resource group.
   * 
   * @param request - MoveResourceGroupRequest
   * @returns MoveResourceGroupResponse
   */
  async moveResourceGroup(request: $_model.MoveResourceGroupRequest): Promise<$_model.MoveResourceGroupResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.moveResourceGroupWithOptions(request, runtime);
  }

  /**
   * Moves a VPN gateway resource to a new resource group.
   * 
   * @param request - MoveVpnResourceGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns MoveVpnResourceGroupResponse
   */
  async moveVpnResourceGroupWithOptions(request: $_model.MoveVpnResourceGroupRequest, runtime: $dara.RuntimeOptions): Promise<$_model.MoveVpnResourceGroupResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.newResourceGroupId)) {
      query["NewResourceGroupId"] = request.newResourceGroupId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "MoveVpnResourceGroup",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.MoveVpnResourceGroupResponse>(await this.callApi(params, req, runtime), new $_model.MoveVpnResourceGroupResponse({}));
  }

  /**
   * Moves a VPN gateway resource to a new resource group.
   * 
   * @param request - MoveVpnResourceGroupRequest
   * @returns MoveVpnResourceGroupResponse
   */
  async moveVpnResourceGroup(request: $_model.MoveVpnResourceGroupRequest): Promise<$_model.MoveVpnResourceGroupResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.moveVpnResourceGroupWithOptions(request, runtime);
  }

  /**
   * Enables the flow log feature.
   * 
   * @remarks
   *   You cannot repeatedly call the **OpenFlowLogService** operation within the specified period of time by using an Alibaba Cloud account.
   * *   You can call the [GetFlowLogServiceStatus](https://help.aliyun.com/document_detail/449624.html) operation to query the status of the flow log feature.
   * 
   * @param request - OpenFlowLogServiceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns OpenFlowLogServiceResponse
   */
  async openFlowLogServiceWithOptions(request: $_model.OpenFlowLogServiceRequest, runtime: $dara.RuntimeOptions): Promise<$_model.OpenFlowLogServiceResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "OpenFlowLogService",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.OpenFlowLogServiceResponse>(await this.callApi(params, req, runtime), new $_model.OpenFlowLogServiceResponse({}));
  }

  /**
   * Enables the flow log feature.
   * 
   * @remarks
   *   You cannot repeatedly call the **OpenFlowLogService** operation within the specified period of time by using an Alibaba Cloud account.
   * *   You can call the [GetFlowLogServiceStatus](https://help.aliyun.com/document_detail/449624.html) operation to query the status of the flow log feature.
   * 
   * @param request - OpenFlowLogServiceRequest
   * @returns OpenFlowLogServiceResponse
   */
  async openFlowLogService(request: $_model.OpenFlowLogServiceRequest): Promise<$_model.OpenFlowLogServiceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.openFlowLogServiceWithOptions(request, runtime);
  }

  /**
   * Enables billing for outbound data transfer.
   * 
   * @param request - OpenPhysicalConnectionServiceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns OpenPhysicalConnectionServiceResponse
   */
  async openPhysicalConnectionServiceWithOptions(request: $_model.OpenPhysicalConnectionServiceRequest, runtime: $dara.RuntimeOptions): Promise<$_model.OpenPhysicalConnectionServiceResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "OpenPhysicalConnectionService",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.OpenPhysicalConnectionServiceResponse>(await this.callApi(params, req, runtime), new $_model.OpenPhysicalConnectionServiceResponse({}));
  }

  /**
   * Enables billing for outbound data transfer.
   * 
   * @param request - OpenPhysicalConnectionServiceRequest
   * @returns OpenPhysicalConnectionServiceResponse
   */
  async openPhysicalConnectionService(request: $_model.OpenPhysicalConnectionServiceRequest): Promise<$_model.OpenPhysicalConnectionServiceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.openPhysicalConnectionServiceWithOptions(request, runtime);
  }

  /**
   * IP
   * 
   * @param request - OpenPublicIpAddressPoolServiceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns OpenPublicIpAddressPoolServiceResponse
   */
  async openPublicIpAddressPoolServiceWithOptions(request: $_model.OpenPublicIpAddressPoolServiceRequest, runtime: $dara.RuntimeOptions): Promise<$_model.OpenPublicIpAddressPoolServiceResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "OpenPublicIpAddressPoolService",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.OpenPublicIpAddressPoolServiceResponse>(await this.callApi(params, req, runtime), new $_model.OpenPublicIpAddressPoolServiceResponse({}));
  }

  /**
   * IP
   * 
   * @param request - OpenPublicIpAddressPoolServiceRequest
   * @returns OpenPublicIpAddressPoolServiceResponse
   */
  async openPublicIpAddressPoolService(request: $_model.OpenPublicIpAddressPoolServiceRequest): Promise<$_model.OpenPublicIpAddressPoolServiceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.openPublicIpAddressPoolServiceWithOptions(request, runtime);
  }

  /**
   * Enables traffic mirror.
   * 
   * @remarks
   * ## [](#)Usage notes
   * You can enable traffic mirror for different regions. You cannot repeatedly call the **OpenTrafficMirrorService** operation to enable traffic mirror for one region within the specified period of time.
   * 
   * @param request - OpenTrafficMirrorServiceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns OpenTrafficMirrorServiceResponse
   */
  async openTrafficMirrorServiceWithOptions(request: $_model.OpenTrafficMirrorServiceRequest, runtime: $dara.RuntimeOptions): Promise<$_model.OpenTrafficMirrorServiceResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "OpenTrafficMirrorService",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.OpenTrafficMirrorServiceResponse>(await this.callApi(params, req, runtime), new $_model.OpenTrafficMirrorServiceResponse({}));
  }

  /**
   * Enables traffic mirror.
   * 
   * @remarks
   * ## [](#)Usage notes
   * You can enable traffic mirror for different regions. You cannot repeatedly call the **OpenTrafficMirrorService** operation to enable traffic mirror for one region within the specified period of time.
   * 
   * @param request - OpenTrafficMirrorServiceRequest
   * @returns OpenTrafficMirrorServiceResponse
   */
  async openTrafficMirrorService(request: $_model.OpenTrafficMirrorServiceRequest): Promise<$_model.OpenTrafficMirrorServiceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.openTrafficMirrorServiceWithOptions(request, runtime);
  }

  /**
   * Advertises VPC routes to an external component.
   * 
   * @param request - PublishVpcRouteEntriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PublishVpcRouteEntriesResponse
   */
  async publishVpcRouteEntriesWithOptions(request: $_model.PublishVpcRouteEntriesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.PublishVpcRouteEntriesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeEntries)) {
      query["RouteEntries"] = request.routeEntries;
    }

    if (!$dara.isNull(request.targetInstanceId)) {
      query["TargetInstanceId"] = request.targetInstanceId;
    }

    if (!$dara.isNull(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "PublishVpcRouteEntries",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.PublishVpcRouteEntriesResponse>(await this.callApi(params, req, runtime), new $_model.PublishVpcRouteEntriesResponse({}));
  }

  /**
   * Advertises VPC routes to an external component.
   * 
   * @param request - PublishVpcRouteEntriesRequest
   * @returns PublishVpcRouteEntriesResponse
   */
  async publishVpcRouteEntries(request: $_model.PublishVpcRouteEntriesRequest): Promise<$_model.PublishVpcRouteEntriesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.publishVpcRouteEntriesWithOptions(request, runtime);
  }

  /**
   * Advertises a VPN route to a VPC.
   * 
   * @param request - PublishVpnRouteEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PublishVpnRouteEntryResponse
   */
  async publishVpnRouteEntryWithOptions(request: $_model.PublishVpnRouteEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.PublishVpnRouteEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.nextHop)) {
      query["NextHop"] = request.nextHop;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.publishVpc)) {
      query["PublishVpc"] = request.publishVpc;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeDest)) {
      query["RouteDest"] = request.routeDest;
    }

    if (!$dara.isNull(request.routeType)) {
      query["RouteType"] = request.routeType;
    }

    if (!$dara.isNull(request.vpnGatewayId)) {
      query["VpnGatewayId"] = request.vpnGatewayId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "PublishVpnRouteEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.PublishVpnRouteEntryResponse>(await this.callApi(params, req, runtime), new $_model.PublishVpnRouteEntryResponse({}));
  }

  /**
   * Advertises a VPN route to a VPC.
   * 
   * @param request - PublishVpnRouteEntryRequest
   * @returns PublishVpnRouteEntryResponse
   */
  async publishVpnRouteEntry(request: $_model.PublishVpnRouteEntryRequest): Promise<$_model.PublishVpnRouteEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.publishVpnRouteEntryWithOptions(request, runtime);
  }

  /**
   * Resumes an Express Connect circuit.
   * 
   * @remarks
   * # [](#)Description
   * You can call this API operation to resume a suspended Express Connect circuit. You can resume only shared Express Connect circuits by calling this API operation.
   * 
   * @param request - RecoverPhysicalConnectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RecoverPhysicalConnectionResponse
   */
  async recoverPhysicalConnectionWithOptions(request: $_model.RecoverPhysicalConnectionRequest, runtime: $dara.RuntimeOptions): Promise<$_model.RecoverPhysicalConnectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.token)) {
      query["Token"] = request.token;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "RecoverPhysicalConnection",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.RecoverPhysicalConnectionResponse>(await this.callApi(params, req, runtime), new $_model.RecoverPhysicalConnectionResponse({}));
  }

  /**
   * Resumes an Express Connect circuit.
   * 
   * @remarks
   * # [](#)Description
   * You can call this API operation to resume a suspended Express Connect circuit. You can resume only shared Express Connect circuits by calling this API operation.
   * 
   * @param request - RecoverPhysicalConnectionRequest
   * @returns RecoverPhysicalConnectionResponse
   */
  async recoverPhysicalConnection(request: $_model.RecoverPhysicalConnectionRequest): Promise<$_model.RecoverPhysicalConnectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.recoverPhysicalConnectionWithOptions(request, runtime);
  }

  /**
   * Enables a disabled virtual border router (VBR).
   * 
   * @remarks
   * After you call this operation, the VBR changes from the **terminated** state to the **recovering** state. After the operation is performed, the VBR enters the **active** state.
   * When you call this operation, take note of the following items:
   * *   Only the owner of the Express Connect circuit can call this operation.
   * *   The Express Connect circuit to which the VBR connects must be in the **Enabled** state.
   * 
   * @param request - RecoverVirtualBorderRouterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RecoverVirtualBorderRouterResponse
   */
  async recoverVirtualBorderRouterWithOptions(request: $_model.RecoverVirtualBorderRouterRequest, runtime: $dara.RuntimeOptions): Promise<$_model.RecoverVirtualBorderRouterResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vbrId)) {
      query["VbrId"] = request.vbrId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "RecoverVirtualBorderRouter",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.RecoverVirtualBorderRouterResponse>(await this.callApi(params, req, runtime), new $_model.RecoverVirtualBorderRouterResponse({}));
  }

  /**
   * Enables a disabled virtual border router (VBR).
   * 
   * @remarks
   * After you call this operation, the VBR changes from the **terminated** state to the **recovering** state. After the operation is performed, the VBR enters the **active** state.
   * When you call this operation, take note of the following items:
   * *   Only the owner of the Express Connect circuit can call this operation.
   * *   The Express Connect circuit to which the VBR connects must be in the **Enabled** state.
   * 
   * @param request - RecoverVirtualBorderRouterRequest
   * @returns RecoverVirtualBorderRouterResponse
   */
  async recoverVirtualBorderRouter(request: $_model.RecoverVirtualBorderRouterRequest): Promise<$_model.RecoverVirtualBorderRouterResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.recoverVirtualBorderRouterWithOptions(request, runtime);
  }

  /**
   * Releases an elastic IP address (EIP).
   * 
   * @remarks
   * Before you call this operation, take note of the following items:
   * *   Before you release an EIP, make sure that the EIP meets the following requirements:
   *     *   You can release only an EIP that is in the **Available** state.
   *     *   You can release only a pay-as-you-go EIP. You cannot release a subscription EIP.
   * *   **ReleaseEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task:
   *     *   If the EIP is in the **Releasing** state, the EIP is being released. In this state, you can only query the EIP and cannot perform other operations.
   *     *   If you cannot query the EIP, the EIP is released.
   * *   You cannot repeatedly call the **ReleaseEipAddress** operation to release an EIP within the specified period of time.
   * 
   * @param request - ReleaseEipAddressRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ReleaseEipAddressResponse
   */
  async releaseEipAddressWithOptions(request: $_model.ReleaseEipAddressRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ReleaseEipAddressResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.allocationId)) {
      query["AllocationId"] = request.allocationId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ReleaseEipAddress",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ReleaseEipAddressResponse>(await this.callApi(params, req, runtime), new $_model.ReleaseEipAddressResponse({}));
  }

  /**
   * Releases an elastic IP address (EIP).
   * 
   * @remarks
   * Before you call this operation, take note of the following items:
   * *   Before you release an EIP, make sure that the EIP meets the following requirements:
   *     *   You can release only an EIP that is in the **Available** state.
   *     *   You can release only a pay-as-you-go EIP. You cannot release a subscription EIP.
   * *   **ReleaseEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task:
   *     *   If the EIP is in the **Releasing** state, the EIP is being released. In this state, you can only query the EIP and cannot perform other operations.
   *     *   If you cannot query the EIP, the EIP is released.
   * *   You cannot repeatedly call the **ReleaseEipAddress** operation to release an EIP within the specified period of time.
   * 
   * @param request - ReleaseEipAddressRequest
   * @returns ReleaseEipAddressResponse
   */
  async releaseEipAddress(request: $_model.ReleaseEipAddressRequest): Promise<$_model.ReleaseEipAddressResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.releaseEipAddressWithOptions(request, runtime);
  }

  /**
   * Releases contiguous elastic IP addresses (EIPs).
   * 
   * @remarks
   *   After you call the **ReleaseEipSegmentAddress** operation, all EIPs in the specified group are released.
   * *   **ReleaseEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
   *     *   If the group is in the **Releasing** state, EIPs in the group are being released. In this state, you can only query the group and cannot perform other operations.
   *     *   If you cannot query the group of contiguous EIPs, the contiguous EIPs are released.
   * *   You cannot repeatedly call the **ReleaseEipSegmentAddress** operation to release a group of contiguous EIPs within the specified period of time.
   * 
   * @param request - ReleaseEipSegmentAddressRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ReleaseEipSegmentAddressResponse
   */
  async releaseEipSegmentAddressWithOptions(request: $_model.ReleaseEipSegmentAddressRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ReleaseEipSegmentAddressResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.segmentInstanceId)) {
      query["SegmentInstanceId"] = request.segmentInstanceId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ReleaseEipSegmentAddress",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ReleaseEipSegmentAddressResponse>(await this.callApi(params, req, runtime), new $_model.ReleaseEipSegmentAddressResponse({}));
  }

  /**
   * Releases contiguous elastic IP addresses (EIPs).
   * 
   * @remarks
   *   After you call the **ReleaseEipSegmentAddress** operation, all EIPs in the specified group are released.
   * *   **ReleaseEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
   *     *   If the group is in the **Releasing** state, EIPs in the group are being released. In this state, you can only query the group and cannot perform other operations.
   *     *   If you cannot query the group of contiguous EIPs, the contiguous EIPs are released.
   * *   You cannot repeatedly call the **ReleaseEipSegmentAddress** operation to release a group of contiguous EIPs within the specified period of time.
   * 
   * @param request - ReleaseEipSegmentAddressRequest
   * @returns ReleaseEipSegmentAddressResponse
   */
  async releaseEipSegmentAddress(request: $_model.ReleaseEipSegmentAddressRequest): Promise<$_model.ReleaseEipSegmentAddressResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.releaseEipSegmentAddressWithOptions(request, runtime);
  }

  /**
   * Releases an idle IPv6 address.
   * 
   * @param request - ReleaseIpv6AddressRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ReleaseIpv6AddressResponse
   */
  async releaseIpv6AddressWithOptions(request: $_model.ReleaseIpv6AddressRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ReleaseIpv6AddressResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ipv6AddressId)) {
      query["Ipv6AddressId"] = request.ipv6AddressId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ReleaseIpv6Address",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ReleaseIpv6AddressResponse>(await this.callApi(params, req, runtime), new $_model.ReleaseIpv6AddressResponse({}));
  }

  /**
   * Releases an idle IPv6 address.
   * 
   * @param request - ReleaseIpv6AddressRequest
   * @returns ReleaseIpv6AddressResponse
   */
  async releaseIpv6Address(request: $_model.ReleaseIpv6AddressRequest): Promise<$_model.ReleaseIpv6AddressResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.releaseIpv6AddressWithOptions(request, runtime);
  }

  /**
   * Disassociates an EIP from an Internet Shared Bandwidth instance.
   * 
   * @param request - RemoveCommonBandwidthPackageIpRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveCommonBandwidthPackageIpResponse
   */
  async removeCommonBandwidthPackageIpWithOptions(request: $_model.RemoveCommonBandwidthPackageIpRequest, runtime: $dara.RuntimeOptions): Promise<$_model.RemoveCommonBandwidthPackageIpResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidthPackageId)) {
      query["BandwidthPackageId"] = request.bandwidthPackageId;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ipInstanceId)) {
      query["IpInstanceId"] = request.ipInstanceId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "RemoveCommonBandwidthPackageIp",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.RemoveCommonBandwidthPackageIpResponse>(await this.callApi(params, req, runtime), new $_model.RemoveCommonBandwidthPackageIpResponse({}));
  }

  /**
   * Disassociates an EIP from an Internet Shared Bandwidth instance.
   * 
   * @param request - RemoveCommonBandwidthPackageIpRequest
   * @returns RemoveCommonBandwidthPackageIpResponse
   */
  async removeCommonBandwidthPackageIp(request: $_model.RemoveCommonBandwidthPackageIpRequest): Promise<$_model.RemoveCommonBandwidthPackageIpResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.removeCommonBandwidthPackageIpWithOptions(request, runtime);
  }

  /**
   * @param request - RemoveGlobalAccelerationInstanceIpRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveGlobalAccelerationInstanceIpResponse
   */
  async removeGlobalAccelerationInstanceIpWithOptions(request: $_model.RemoveGlobalAccelerationInstanceIpRequest, runtime: $dara.RuntimeOptions): Promise<$_model.RemoveGlobalAccelerationInstanceIpResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.globalAccelerationInstanceId)) {
      query["GlobalAccelerationInstanceId"] = request.globalAccelerationInstanceId;
    }

    if (!$dara.isNull(request.ipInstanceId)) {
      query["IpInstanceId"] = request.ipInstanceId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "RemoveGlobalAccelerationInstanceIp",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.RemoveGlobalAccelerationInstanceIpResponse>(await this.callApi(params, req, runtime), new $_model.RemoveGlobalAccelerationInstanceIpResponse({}));
  }

  /**
   * @param request - RemoveGlobalAccelerationInstanceIpRequest
   * @returns RemoveGlobalAccelerationInstanceIpResponse
   */
  async removeGlobalAccelerationInstanceIp(request: $_model.RemoveGlobalAccelerationInstanceIpRequest): Promise<$_model.RemoveGlobalAccelerationInstanceIpResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.removeGlobalAccelerationInstanceIpWithOptions(request, runtime);
  }

  /**
   * Deletes an IP entry from an ACL.
   * 
   * @param request - RemoveIPv6TranslatorAclListEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveIPv6TranslatorAclListEntryResponse
   */
  async removeIPv6TranslatorAclListEntryWithOptions(request: $_model.RemoveIPv6TranslatorAclListEntryRequest, runtime: $dara.RuntimeOptions): Promise<$_model.RemoveIPv6TranslatorAclListEntryResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.aclEntryId)) {
      query["AclEntryId"] = request.aclEntryId;
    }

    if (!$dara.isNull(request.aclId)) {
      query["AclId"] = request.aclId;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "RemoveIPv6TranslatorAclListEntry",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.RemoveIPv6TranslatorAclListEntryResponse>(await this.callApi(params, req, runtime), new $_model.RemoveIPv6TranslatorAclListEntryResponse({}));
  }

  /**
   * Deletes an IP entry from an ACL.
   * 
   * @param request - RemoveIPv6TranslatorAclListEntryRequest
   * @returns RemoveIPv6TranslatorAclListEntryResponse
   */
  async removeIPv6TranslatorAclListEntry(request: $_model.RemoveIPv6TranslatorAclListEntryRequest): Promise<$_model.RemoveIPv6TranslatorAclListEntryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.removeIPv6TranslatorAclListEntryWithOptions(request, runtime);
  }

  /**
   * Deletes a traffic mirror source from a traffic mirror session.
   * 
   * @remarks
   *   **RemoveSourcesFromTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
   *     *   If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being deleted.
   *     *   If the traffic mirror session is in the **Created** state, the traffic mirror source is deleted.
   * *   You cannot repeatedly call **RemoveSourcesFromTrafficMirrorSession** within the specified period of time.
   * 
   * @param request - RemoveSourcesFromTrafficMirrorSessionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveSourcesFromTrafficMirrorSessionResponse
   */
  async removeSourcesFromTrafficMirrorSessionWithOptions(request: $_model.RemoveSourcesFromTrafficMirrorSessionRequest, runtime: $dara.RuntimeOptions): Promise<$_model.RemoveSourcesFromTrafficMirrorSessionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.trafficMirrorSessionId)) {
      query["TrafficMirrorSessionId"] = request.trafficMirrorSessionId;
    }

    if (!$dara.isNull(request.trafficMirrorSourceIds)) {
      query["TrafficMirrorSourceIds"] = request.trafficMirrorSourceIds;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "RemoveSourcesFromTrafficMirrorSession",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.RemoveSourcesFromTrafficMirrorSessionResponse>(await this.callApi(params, req, runtime), new $_model.RemoveSourcesFromTrafficMirrorSessionResponse({}));
  }

  /**
   * Deletes a traffic mirror source from a traffic mirror session.
   * 
   * @remarks
   *   **RemoveSourcesFromTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
   *     *   If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being deleted.
   *     *   If the traffic mirror session is in the **Created** state, the traffic mirror source is deleted.
   * *   You cannot repeatedly call **RemoveSourcesFromTrafficMirrorSession** within the specified period of time.
   * 
   * @param request - RemoveSourcesFromTrafficMirrorSessionRequest
   * @returns RemoveSourcesFromTrafficMirrorSessionResponse
   */
  async removeSourcesFromTrafficMirrorSession(request: $_model.RemoveSourcesFromTrafficMirrorSessionRequest): Promise<$_model.RemoveSourcesFromTrafficMirrorSessionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.removeSourcesFromTrafficMirrorSessionWithOptions(request, runtime);
  }

  /**
   * DHCPVPC
   * 
   * @remarks
   *   The **ReplaceVpcDhcpOptionsSet** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
   *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being replaced.
   *     *   If the DHCP options set is in the **InUse** state, the DHCP options set is replaced.
   * *   You cannot repeatedly call the **ReplaceVpcDhcpOptionsSet** operation to replace the DHCP options set associated with a VPC within the specified period of time.
   * 
   * @param request - ReplaceVpcDhcpOptionsSetRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ReplaceVpcDhcpOptionsSetResponse
   */
  async replaceVpcDhcpOptionsSetWithOptions(request: $_model.ReplaceVpcDhcpOptionsSetRequest, runtime: $dara.RuntimeOptions): Promise<$_model.ReplaceVpcDhcpOptionsSetResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dhcpOptionsSetId)) {
      query["DhcpOptionsSetId"] = request.dhcpOptionsSetId;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ReplaceVpcDhcpOptionsSet",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.ReplaceVpcDhcpOptionsSetResponse>(await this.callApi(params, req, runtime), new $_model.ReplaceVpcDhcpOptionsSetResponse({}));
  }

  /**
   * DHCPVPC
   * 
   * @remarks
   *   The **ReplaceVpcDhcpOptionsSet** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
   *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being replaced.
   *     *   If the DHCP options set is in the **InUse** state, the DHCP options set is replaced.
   * *   You cannot repeatedly call the **ReplaceVpcDhcpOptionsSet** operation to replace the DHCP options set associated with a VPC within the specified period of time.
   * 
   * @param request - ReplaceVpcDhcpOptionsSetRequest
   * @returns ReplaceVpcDhcpOptionsSetResponse
   */
  async replaceVpcDhcpOptionsSet(request: $_model.ReplaceVpcDhcpOptionsSetRequest): Promise<$_model.ReplaceVpcDhcpOptionsSetResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.replaceVpcDhcpOptionsSetWithOptions(request, runtime);
  }

  /**
   * Re-applies a prefix list.
   * 
   * @remarks
   *   If you modify the information about a prefix list but the modification is not automatically applied to the route table that is associated with the prefix list, you can call this operation to apply the latest prefix list to the associated route table.
   * *   The **RetryVpcPrefixListAssociation** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the background. You can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) to check whether the prefix list is re-applied.
   *     *   If the prefix list is in the **Modifying** state, the prefix list is being re-applied.
   *     *   If the prefix list is in the **ModifyFailed** state, the prefix list fails to be re-applied.
   *     *   If the prefix list is in the **Created** state, the prefix list is re-applied.
   * *   After you call the **RetryVpcPrefixListAssociation** operation to re-apply a prefix list, you cannot call the operation again until the current task is complete.
   * 
   * @param request - RetryVpcPrefixListAssociationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RetryVpcPrefixListAssociationResponse
   */
  async retryVpcPrefixListAssociationWithOptions(request: $_model.RetryVpcPrefixListAssociationRequest, runtime: $dara.RuntimeOptions): Promise<$_model.RetryVpcPrefixListAssociationResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.prefixListId)) {
      query["PrefixListId"] = request.prefixListId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "RetryVpcPrefixListAssociation",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.RetryVpcPrefixListAssociationResponse>(await this.callApi(params, req, runtime), new $_model.RetryVpcPrefixListAssociationResponse({}));
  }

  /**
   * Re-applies a prefix list.
   * 
   * @remarks
   *   If you modify the information about a prefix list but the modification is not automatically applied to the route table that is associated with the prefix list, you can call this operation to apply the latest prefix list to the associated route table.
   * *   The **RetryVpcPrefixListAssociation** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the background. You can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) to check whether the prefix list is re-applied.
   *     *   If the prefix list is in the **Modifying** state, the prefix list is being re-applied.
   *     *   If the prefix list is in the **ModifyFailed** state, the prefix list fails to be re-applied.
   *     *   If the prefix list is in the **Created** state, the prefix list is re-applied.
   * *   After you call the **RetryVpcPrefixListAssociation** operation to re-apply a prefix list, you cannot call the operation again until the current task is complete.
   * 
   * @param request - RetryVpcPrefixListAssociationRequest
   * @returns RetryVpcPrefixListAssociationResponse
   */
  async retryVpcPrefixListAssociation(request: $_model.RetryVpcPrefixListAssociationRequest): Promise<$_model.RetryVpcPrefixListAssociationResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.retryVpcPrefixListAssociationWithOptions(request, runtime);
  }

  /**
   * Revokes the permissions granted to a Cloud Enterprise Network (CEN) instance on a network instance.
   * 
   * @remarks
   * ## [](#)Usage notes
   * *   **RevokeInstanceFromCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use `vpc.aliyuncs.com` as the domain name when you call this operation. The API version is `2016-04-28`.
   * *   You cannot repeatedly call the **RevokeInstanceFromCen** operation to revoke the permissions on a network instance that is attached to a CEN instance within the specified period of time. The network instance can be a VPC, virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
   * 
   * @param request - RevokeInstanceFromCenRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RevokeInstanceFromCenResponse
   */
  async revokeInstanceFromCenWithOptions(request: $_model.RevokeInstanceFromCenRequest, runtime: $dara.RuntimeOptions): Promise<$_model.RevokeInstanceFromCenResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.cenId)) {
      query["CenId"] = request.cenId;
    }

    if (!$dara.isNull(request.cenOwnerId)) {
      query["CenOwnerId"] = request.cenOwnerId;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "RevokeInstanceFromCen",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.RevokeInstanceFromCenResponse>(await this.callApi(params, req, runtime), new $_model.RevokeInstanceFromCenResponse({}));
  }

  /**
   * Revokes the permissions granted to a Cloud Enterprise Network (CEN) instance on a network instance.
   * 
   * @remarks
   * ## [](#)Usage notes
   * *   **RevokeInstanceFromCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use `vpc.aliyuncs.com` as the domain name when you call this operation. The API version is `2016-04-28`.
   * *   You cannot repeatedly call the **RevokeInstanceFromCen** operation to revoke the permissions on a network instance that is attached to a CEN instance within the specified period of time. The network instance can be a VPC, virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
   * 
   * @param request - RevokeInstanceFromCenRequest
   * @returns RevokeInstanceFromCenResponse
   */
  async revokeInstanceFromCen(request: $_model.RevokeInstanceFromCenRequest): Promise<$_model.RevokeInstanceFromCenResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.revokeInstanceFromCenWithOptions(request, runtime);
  }

  /**
   * Revokes the permissions granted to a virtual border router (VBR) on a virtual private cloud (VPC).
   * 
   * @param tmpReq - RevokeInstanceFromVbrRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RevokeInstanceFromVbrResponse
   */
  async revokeInstanceFromVbrWithOptions(tmpReq: $_model.RevokeInstanceFromVbrRequest, runtime: $dara.RuntimeOptions): Promise<$_model.RevokeInstanceFromVbrResponse> {
    tmpReq.validate();
    let request = new $_model.RevokeInstanceFromVbrShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.vbrInstanceIds)) {
      request.vbrInstanceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.vbrInstanceIds, "VbrInstanceIds", "simple");
    }

    let query = { };
    if (!$dara.isNull(request.grantType)) {
      query["GrantType"] = request.grantType;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.vbrInstanceIdsShrink)) {
      query["VbrInstanceIds"] = request.vbrInstanceIdsShrink;
    }

    if (!$dara.isNull(request.vbrOwnerUid)) {
      query["VbrOwnerUid"] = request.vbrOwnerUid;
    }

    if (!$dara.isNull(request.vbrRegionNo)) {
      query["VbrRegionNo"] = request.vbrRegionNo;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "RevokeInstanceFromVbr",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.RevokeInstanceFromVbrResponse>(await this.callApi(params, req, runtime), new $_model.RevokeInstanceFromVbrResponse({}));
  }

  /**
   * Revokes the permissions granted to a virtual border router (VBR) on a virtual private cloud (VPC).
   * 
   * @param request - RevokeInstanceFromVbrRequest
   * @returns RevokeInstanceFromVbrResponse
   */
  async revokeInstanceFromVbr(request: $_model.RevokeInstanceFromVbrRequest): Promise<$_model.RevokeInstanceFromVbrResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.revokeInstanceFromVbrWithOptions(request, runtime);
  }

  /**
   * If your application for a Letter of Authorization (LOA) by calling the ApplyPhysicalConnectionLOA operation is denied, you can call this operation to apply again.
   * 
   * @param request - SecondApplyPhysicalConnectionLOARequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SecondApplyPhysicalConnectionLOAResponse
   */
  async secondApplyPhysicalConnectionLOAWithOptions(request: $_model.SecondApplyPhysicalConnectionLOARequest, runtime: $dara.RuntimeOptions): Promise<$_model.SecondApplyPhysicalConnectionLOAResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidth)) {
      query["Bandwidth"] = request.bandwidth;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.companyName)) {
      query["CompanyName"] = request.companyName;
    }

    if (!$dara.isNull(request.constructionTime)) {
      query["ConstructionTime"] = request.constructionTime;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.lineType)) {
      query["LineType"] = request.lineType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.PMInfo)) {
      query["PMInfo"] = request.PMInfo;
    }

    if (!$dara.isNull(request.peerLocation)) {
      query["PeerLocation"] = request.peerLocation;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.si)) {
      query["Si"] = request.si;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "SecondApplyPhysicalConnectionLOA",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.SecondApplyPhysicalConnectionLOAResponse>(await this.callApi(params, req, runtime), new $_model.SecondApplyPhysicalConnectionLOAResponse({}));
  }

  /**
   * If your application for a Letter of Authorization (LOA) by calling the ApplyPhysicalConnectionLOA operation is denied, you can call this operation to apply again.
   * 
   * @param request - SecondApplyPhysicalConnectionLOARequest
   * @returns SecondApplyPhysicalConnectionLOAResponse
   */
  async secondApplyPhysicalConnectionLOA(request: $_model.SecondApplyPhysicalConnectionLOARequest): Promise<$_model.SecondApplyPhysicalConnectionLOAResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.secondApplyPhysicalConnectionLOAWithOptions(request, runtime);
  }

  /**
   * Configures fine-grained monitoring for an elastic IP address (EIP).
   * 
   * @remarks
   * You cannot repeatedly call **SetHighDefinitionMonitorLogStatus** within a specific period of time.
   * 
   * @param request - SetHighDefinitionMonitorLogStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetHighDefinitionMonitorLogStatusResponse
   */
  async setHighDefinitionMonitorLogStatusWithOptions(request: $_model.SetHighDefinitionMonitorLogStatusRequest, runtime: $dara.RuntimeOptions): Promise<$_model.SetHighDefinitionMonitorLogStatusResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!$dara.isNull(request.logProject)) {
      query["LogProject"] = request.logProject;
    }

    if (!$dara.isNull(request.logStore)) {
      query["LogStore"] = request.logStore;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "SetHighDefinitionMonitorLogStatus",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.SetHighDefinitionMonitorLogStatusResponse>(await this.callApi(params, req, runtime), new $_model.SetHighDefinitionMonitorLogStatusResponse({}));
  }

  /**
   * Configures fine-grained monitoring for an elastic IP address (EIP).
   * 
   * @remarks
   * You cannot repeatedly call **SetHighDefinitionMonitorLogStatus** within a specific period of time.
   * 
   * @param request - SetHighDefinitionMonitorLogStatusRequest
   * @returns SetHighDefinitionMonitorLogStatusResponse
   */
  async setHighDefinitionMonitorLogStatus(request: $_model.SetHighDefinitionMonitorLogStatusRequest): Promise<$_model.SetHighDefinitionMonitorLogStatusResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.setHighDefinitionMonitorLogStatusWithOptions(request, runtime);
  }

  /**
   * Performs a failover test.
   * 
   * @remarks
   * You can perform only failover tests that are in the **Pending** state.
   * 
   * @param request - StartFailoverTestJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StartFailoverTestJobResponse
   */
  async startFailoverTestJobWithOptions(request: $_model.StartFailoverTestJobRequest, runtime: $dara.RuntimeOptions): Promise<$_model.StartFailoverTestJobResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "StartFailoverTestJob",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.StartFailoverTestJobResponse>(await this.callApi(params, req, runtime), new $_model.StartFailoverTestJobResponse({}));
  }

  /**
   * Performs a failover test.
   * 
   * @remarks
   * You can perform only failover tests that are in the **Pending** state.
   * 
   * @param request - StartFailoverTestJobRequest
   * @returns StartFailoverTestJobResponse
   */
  async startFailoverTestJob(request: $_model.StartFailoverTestJobRequest): Promise<$_model.StartFailoverTestJobResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.startFailoverTestJobWithOptions(request, runtime);
  }

  /**
   * Terminates a failover test.
   * 
   * @param request - StopFailoverTestJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StopFailoverTestJobResponse
   */
  async stopFailoverTestJobWithOptions(request: $_model.StopFailoverTestJobRequest, runtime: $dara.RuntimeOptions): Promise<$_model.StopFailoverTestJobResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "StopFailoverTestJob",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.StopFailoverTestJobResponse>(await this.callApi(params, req, runtime), new $_model.StopFailoverTestJobResponse({}));
  }

  /**
   * Terminates a failover test.
   * 
   * @param request - StopFailoverTestJobRequest
   * @returns StopFailoverTestJobResponse
   */
  async stopFailoverTestJob(request: $_model.StopFailoverTestJobRequest): Promise<$_model.StopFailoverTestJobResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.stopFailoverTestJobWithOptions(request, runtime);
  }

  /**
   * Creates and adds tags to resources.
   * 
   * @remarks
   * Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following limits:
   * *   The keys of tags that are added to the same instance must be unique.
   * *   You cannot create tags without adding them to instances. All tags must be added to instances.
   * *   Tag information is not shared across regions.
   *     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
   * *   Virtual private clouds (VPCs), route tables, vSwitches, and elastic IP addresses (EIPs) that belong to the same Alibaba Cloud account and are deployed in the same region share tag information with each other.
   *     For example, if you added a tag to a VPC, the tag is available to vSwitches, route tables, and EIPs that belong to the same account and are deployed in the same region in which the VPC is created. You can select this tag from the editing page without the need to enter the tag again. You can modify the key and the value of a tag or remove a tag from an instance. After you delete an instance, all tags that are added to the instance are deleted.
   * *   You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
   * 
   * @param request - TagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns TagResourcesResponse
   */
  async tagResourcesWithOptions(request: $_model.TagResourcesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.TagResourcesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "TagResources",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.TagResourcesResponse>(await this.callApi(params, req, runtime), new $_model.TagResourcesResponse({}));
  }

  /**
   * Creates and adds tags to resources.
   * 
   * @remarks
   * Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following limits:
   * *   The keys of tags that are added to the same instance must be unique.
   * *   You cannot create tags without adding them to instances. All tags must be added to instances.
   * *   Tag information is not shared across regions.
   *     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
   * *   Virtual private clouds (VPCs), route tables, vSwitches, and elastic IP addresses (EIPs) that belong to the same Alibaba Cloud account and are deployed in the same region share tag information with each other.
   *     For example, if you added a tag to a VPC, the tag is available to vSwitches, route tables, and EIPs that belong to the same account and are deployed in the same region in which the VPC is created. You can select this tag from the editing page without the need to enter the tag again. You can modify the key and the value of a tag or remove a tag from an instance. After you delete an instance, all tags that are added to the instance are deleted.
   * *   You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
   * 
   * @param request - TagResourcesRequest
   * @returns TagResourcesResponse
   */
  async tagResources(request: $_model.TagResourcesRequest): Promise<$_model.TagResourcesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.tagResourcesWithOptions(request, runtime);
  }

  /**
   * Creates tags and adds the tags to an Express Connect circuit.
   * 
   * @remarks
   * ## [](#)
   * Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following items:
   * *   Each tag key that is added to an instance must be unique.
   * *   You cannot create tags without adding them to instances. All tags must be added to instances.
   * *   Tag information is not shared across regions.
   *     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
   * *   You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
   * 
   * @param request - TagResourcesForExpressConnectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns TagResourcesForExpressConnectResponse
   */
  async tagResourcesForExpressConnectWithOptions(request: $_model.TagResourcesForExpressConnectRequest, runtime: $dara.RuntimeOptions): Promise<$_model.TagResourcesForExpressConnectResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "TagResourcesForExpressConnect",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.TagResourcesForExpressConnectResponse>(await this.callApi(params, req, runtime), new $_model.TagResourcesForExpressConnectResponse({}));
  }

  /**
   * Creates tags and adds the tags to an Express Connect circuit.
   * 
   * @remarks
   * ## [](#)
   * Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following items:
   * *   Each tag key that is added to an instance must be unique.
   * *   You cannot create tags without adding them to instances. All tags must be added to instances.
   * *   Tag information is not shared across regions.
   *     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
   * *   You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
   * 
   * @param request - TagResourcesForExpressConnectRequest
   * @returns TagResourcesForExpressConnectResponse
   */
  async tagResourcesForExpressConnect(request: $_model.TagResourcesForExpressConnectRequest): Promise<$_model.TagResourcesForExpressConnectResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.tagResourcesForExpressConnectWithOptions(request, runtime);
  }

  /**
   * Disables an Express Connect circuit after it is enabled.
   * 
   * @remarks
   * After you call this operation, the specified Express Connect circuit changes to the **Terminating** state. After the Express Connect circuit is disabled, it changes to the **Terminated** state. When you call this operation, take note of the following limits:
   * *   You can only disable an Express Connect circuit that is in the **Enabled** state.
   * *   Before you disable an Express Connect circuit, you must delete the virtual border routers (VBRs) associated with it.
   * 
   * @param request - TerminatePhysicalConnectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns TerminatePhysicalConnectionResponse
   */
  async terminatePhysicalConnectionWithOptions(request: $_model.TerminatePhysicalConnectionRequest, runtime: $dara.RuntimeOptions): Promise<$_model.TerminatePhysicalConnectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.physicalConnectionId)) {
      query["PhysicalConnectionId"] = request.physicalConnectionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "TerminatePhysicalConnection",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.TerminatePhysicalConnectionResponse>(await this.callApi(params, req, runtime), new $_model.TerminatePhysicalConnectionResponse({}));
  }

  /**
   * Disables an Express Connect circuit after it is enabled.
   * 
   * @remarks
   * After you call this operation, the specified Express Connect circuit changes to the **Terminating** state. After the Express Connect circuit is disabled, it changes to the **Terminated** state. When you call this operation, take note of the following limits:
   * *   You can only disable an Express Connect circuit that is in the **Enabled** state.
   * *   Before you disable an Express Connect circuit, you must delete the virtual border routers (VBRs) associated with it.
   * 
   * @param request - TerminatePhysicalConnectionRequest
   * @returns TerminatePhysicalConnectionResponse
   */
  async terminatePhysicalConnection(request: $_model.TerminatePhysicalConnectionRequest): Promise<$_model.TerminatePhysicalConnectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.terminatePhysicalConnectionWithOptions(request, runtime);
  }

  /**
   * Terminates a virtual border router (VBR).
   * 
   * @remarks
   * After you call this operation, the VBR enters the **terminating** state from the **active** state. After the VBR is terminated, the VBR enters the **terminated** state.
   * >  Only the owner of an Express Connect circuit can call this operation.
   * 
   * @param request - TerminateVirtualBorderRouterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns TerminateVirtualBorderRouterResponse
   */
  async terminateVirtualBorderRouterWithOptions(request: $_model.TerminateVirtualBorderRouterRequest, runtime: $dara.RuntimeOptions): Promise<$_model.TerminateVirtualBorderRouterResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vbrId)) {
      query["VbrId"] = request.vbrId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "TerminateVirtualBorderRouter",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.TerminateVirtualBorderRouterResponse>(await this.callApi(params, req, runtime), new $_model.TerminateVirtualBorderRouterResponse({}));
  }

  /**
   * Terminates a virtual border router (VBR).
   * 
   * @remarks
   * After you call this operation, the VBR enters the **terminating** state from the **active** state. After the VBR is terminated, the VBR enters the **terminated** state.
   * >  Only the owner of an Express Connect circuit can call this operation.
   * 
   * @param request - TerminateVirtualBorderRouterRequest
   * @returns TerminateVirtualBorderRouterResponse
   */
  async terminateVirtualBorderRouter(request: $_model.TerminateVirtualBorderRouterRequest): Promise<$_model.TerminateVirtualBorderRouterResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.terminateVirtualBorderRouterWithOptions(request, runtime);
  }

  /**
   * Migrate contiguous EIP groups to IP address pool by calling TransformEipSegmentToPublicIpAddressPool.
   * 
   * @param request - TransformEipSegmentToPublicIpAddressPoolRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns TransformEipSegmentToPublicIpAddressPoolResponse
   */
  async transformEipSegmentToPublicIpAddressPoolWithOptions(request: $_model.TransformEipSegmentToPublicIpAddressPoolRequest, runtime: $dara.RuntimeOptions): Promise<$_model.TransformEipSegmentToPublicIpAddressPoolResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "TransformEipSegmentToPublicIpAddressPool",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.TransformEipSegmentToPublicIpAddressPoolResponse>(await this.callApi(params, req, runtime), new $_model.TransformEipSegmentToPublicIpAddressPoolResponse({}));
  }

  /**
   * Migrate contiguous EIP groups to IP address pool by calling TransformEipSegmentToPublicIpAddressPool.
   * 
   * @param request - TransformEipSegmentToPublicIpAddressPoolRequest
   * @returns TransformEipSegmentToPublicIpAddressPoolResponse
   */
  async transformEipSegmentToPublicIpAddressPool(request: $_model.TransformEipSegmentToPublicIpAddressPoolRequest): Promise<$_model.TransformEipSegmentToPublicIpAddressPoolResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.transformEipSegmentToPublicIpAddressPoolWithOptions(request, runtime);
  }

  /**
   * Removes tags from resources.
   * 
   * @param request - UnTagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UnTagResourcesResponse
   */
  async unTagResourcesWithOptions(request: $_model.UnTagResourcesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UnTagResourcesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.all)) {
      query["All"] = request.all;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!$dara.isNull(request.tagKey)) {
      query["TagKey"] = request.tagKey;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UnTagResources",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UnTagResourcesResponse>(await this.callApi(params, req, runtime), new $_model.UnTagResourcesResponse({}));
  }

  /**
   * Removes tags from resources.
   * 
   * @param request - UnTagResourcesRequest
   * @returns UnTagResourcesResponse
   */
  async unTagResources(request: $_model.UnTagResourcesRequest): Promise<$_model.UnTagResourcesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.unTagResourcesWithOptions(request, runtime);
  }

  /**
   * Disassociates an elastic IP address (EIP) from a cloud resource.
   * 
   * @remarks
   *   **UnassociateEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
   *     *   If the EIP is in the **Unassociating** state, the EIP is being disassociated. In this state, you can only query the EIP and cannot perform other operations.
   *     *   If the EIP is in the **Available** state, the EIP is disassociated.
   * *   You cannot repeatedly call the **UnassociateEipAddress** operation within the specified period of time.
   * 
   * @param request - UnassociateEipAddressRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UnassociateEipAddressResponse
   */
  async unassociateEipAddressWithOptions(request: $_model.UnassociateEipAddressRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UnassociateEipAddressResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.allocationId)) {
      query["AllocationId"] = request.allocationId;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.force)) {
      query["Force"] = request.force;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.privateIpAddress)) {
      query["PrivateIpAddress"] = request.privateIpAddress;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UnassociateEipAddress",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UnassociateEipAddressResponse>(await this.callApi(params, req, runtime), new $_model.UnassociateEipAddressResponse({}));
  }

  /**
   * Disassociates an elastic IP address (EIP) from a cloud resource.
   * 
   * @remarks
   *   **UnassociateEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
   *     *   If the EIP is in the **Unassociating** state, the EIP is being disassociated. In this state, you can only query the EIP and cannot perform other operations.
   *     *   If the EIP is in the **Available** state, the EIP is disassociated.
   * *   You cannot repeatedly call the **UnassociateEipAddress** operation within the specified period of time.
   * 
   * @param request - UnassociateEipAddressRequest
   * @returns UnassociateEipAddressResponse
   */
  async unassociateEipAddress(request: $_model.UnassociateEipAddressRequest): Promise<$_model.UnassociateEipAddressResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.unassociateEipAddressWithOptions(request, runtime);
  }

  /**
   * Disassociates a Global Accelerator (GA) instance from a backend server.
   * 
   * @param request - UnassociateGlobalAccelerationInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UnassociateGlobalAccelerationInstanceResponse
   */
  async unassociateGlobalAccelerationInstanceWithOptions(request: $_model.UnassociateGlobalAccelerationInstanceRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UnassociateGlobalAccelerationInstanceResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.globalAccelerationInstanceId)) {
      query["GlobalAccelerationInstanceId"] = request.globalAccelerationInstanceId;
    }

    if (!$dara.isNull(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UnassociateGlobalAccelerationInstance",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UnassociateGlobalAccelerationInstanceResponse>(await this.callApi(params, req, runtime), new $_model.UnassociateGlobalAccelerationInstanceResponse({}));
  }

  /**
   * Disassociates a Global Accelerator (GA) instance from a backend server.
   * 
   * @param request - UnassociateGlobalAccelerationInstanceRequest
   * @returns UnassociateGlobalAccelerationInstanceResponse
   */
  async unassociateGlobalAccelerationInstance(request: $_model.UnassociateGlobalAccelerationInstanceRequest): Promise<$_model.UnassociateGlobalAccelerationInstanceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.unassociateGlobalAccelerationInstanceWithOptions(request, runtime);
  }

  /**
   * Disassociates a high-availability virtual IP address (HaVip) from an Elastic Compute Service (ECS) in a virtual private cloud (VPC) or from an elastic network interface (ENI).
   * 
   * @remarks
   * ## [](#)
   * When you call this operation, take note of the following limits:
   * *   The ECS instance must be in the **Running** or **Stopped** state.
   * *   The HaVip must be in the **Available** or **InUse** state.
   * *   **UnassociateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and an instance ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
   *     *   If the HaVip is in the **Unassociating** state, the HaVip is being disassociated.
   *     *   If the HaVip is in the **Inuse** or **Available** state, the HaVip is disassociated.
   * *   You cannot repeatedly call the **UnassociateHaVip** operation to disassociate an HaVip within the specified period of time.
   * 
   * @param request - UnassociateHaVipRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UnassociateHaVipResponse
   */
  async unassociateHaVipWithOptions(request: $_model.UnassociateHaVipRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UnassociateHaVipResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.force)) {
      query["Force"] = request.force;
    }

    if (!$dara.isNull(request.haVipId)) {
      query["HaVipId"] = request.haVipId;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UnassociateHaVip",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UnassociateHaVipResponse>(await this.callApi(params, req, runtime), new $_model.UnassociateHaVipResponse({}));
  }

  /**
   * Disassociates a high-availability virtual IP address (HaVip) from an Elastic Compute Service (ECS) in a virtual private cloud (VPC) or from an elastic network interface (ENI).
   * 
   * @remarks
   * ## [](#)
   * When you call this operation, take note of the following limits:
   * *   The ECS instance must be in the **Running** or **Stopped** state.
   * *   The HaVip must be in the **Available** or **InUse** state.
   * *   **UnassociateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and an instance ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
   *     *   If the HaVip is in the **Unassociating** state, the HaVip is being disassociated.
   *     *   If the HaVip is in the **Inuse** or **Available** state, the HaVip is disassociated.
   * *   You cannot repeatedly call the **UnassociateHaVip** operation to disassociate an HaVip within the specified period of time.
   * 
   * @param request - UnassociateHaVipRequest
   * @returns UnassociateHaVipResponse
   */
  async unassociateHaVip(request: $_model.UnassociateHaVipRequest): Promise<$_model.UnassociateHaVipResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.unassociateHaVipWithOptions(request, runtime);
  }

  /**
   * Disassociates a network access control list (ACL) from a vSwitch.
   * 
   * @remarks
   * ## [](#)Description
   * *   **UnassociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
   *     *   If the network ACL is in the **UNBINDING** state, the network ACL is being disassociated from the vSwitch.
   *     *   If the network ACL is in the **UNBINDED** state, the network ACL is disassociated from the vSwitch.
   * *   You cannot repeatedly call the **UnassociateNetworkAcl** operation to disassociate a network ACL from a vSwitch within the specified period of time.
   * 
   * @param request - UnassociateNetworkAclRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UnassociateNetworkAclResponse
   */
  async unassociateNetworkAclWithOptions(request: $_model.UnassociateNetworkAclRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UnassociateNetworkAclResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.networkAclId)) {
      query["NetworkAclId"] = request.networkAclId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resource)) {
      query["Resource"] = request.resource;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UnassociateNetworkAcl",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UnassociateNetworkAclResponse>(await this.callApi(params, req, runtime), new $_model.UnassociateNetworkAclResponse({}));
  }

  /**
   * Disassociates a network access control list (ACL) from a vSwitch.
   * 
   * @remarks
   * ## [](#)Description
   * *   **UnassociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
   *     *   If the network ACL is in the **UNBINDING** state, the network ACL is being disassociated from the vSwitch.
   *     *   If the network ACL is in the **UNBINDED** state, the network ACL is disassociated from the vSwitch.
   * *   You cannot repeatedly call the **UnassociateNetworkAcl** operation to disassociate a network ACL from a vSwitch within the specified period of time.
   * 
   * @param request - UnassociateNetworkAclRequest
   * @returns UnassociateNetworkAclResponse
   */
  async unassociateNetworkAcl(request: $_model.UnassociateNetworkAclRequest): Promise<$_model.UnassociateNetworkAclResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.unassociateNetworkAclWithOptions(request, runtime);
  }

  /**
   * Disassociates a virtual border router (VBR) from an Express Connect circuit.
   * 
   * @param request - UnassociatePhysicalConnectionFromVirtualBorderRouterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UnassociatePhysicalConnectionFromVirtualBorderRouterResponse
   */
  async unassociatePhysicalConnectionFromVirtualBorderRouterWithOptions(request: $_model.UnassociatePhysicalConnectionFromVirtualBorderRouterRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UnassociatePhysicalConnectionFromVirtualBorderRouterResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.physicalConnectionId)) {
      query["PhysicalConnectionId"] = request.physicalConnectionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vbrId)) {
      query["VbrId"] = request.vbrId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UnassociatePhysicalConnectionFromVirtualBorderRouter",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UnassociatePhysicalConnectionFromVirtualBorderRouterResponse>(await this.callApi(params, req, runtime), new $_model.UnassociatePhysicalConnectionFromVirtualBorderRouterResponse({}));
  }

  /**
   * Disassociates a virtual border router (VBR) from an Express Connect circuit.
   * 
   * @param request - UnassociatePhysicalConnectionFromVirtualBorderRouterRequest
   * @returns UnassociatePhysicalConnectionFromVirtualBorderRouterResponse
   */
  async unassociatePhysicalConnectionFromVirtualBorderRouter(request: $_model.UnassociatePhysicalConnectionFromVirtualBorderRouterRequest): Promise<$_model.UnassociatePhysicalConnectionFromVirtualBorderRouterResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.unassociatePhysicalConnectionFromVirtualBorderRouterWithOptions(request, runtime);
  }

  /**
   * Disassociates a route table from a vSwitch.
   * 
   * @remarks
   * ## [](#)References
   * *   **UnassociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task.
   *     *   If the vSwitch is in the **Pending** state, the route table is being disassociated.
   *     *   If the vSwitch is in the **Available** state, the route table is disassociated.
   * *   You cannot repeatedly call the **UnassociateRouteTable** operation to disassociate a route table from a vSwitch within the specified period of time.
   * 
   * @param request - UnassociateRouteTableRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UnassociateRouteTableResponse
   */
  async unassociateRouteTableWithOptions(request: $_model.UnassociateRouteTableRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UnassociateRouteTableResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeTableId)) {
      query["RouteTableId"] = request.routeTableId;
    }

    if (!$dara.isNull(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UnassociateRouteTable",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UnassociateRouteTableResponse>(await this.callApi(params, req, runtime), new $_model.UnassociateRouteTableResponse({}));
  }

  /**
   * Disassociates a route table from a vSwitch.
   * 
   * @remarks
   * ## [](#)References
   * *   **UnassociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task.
   *     *   If the vSwitch is in the **Pending** state, the route table is being disassociated.
   *     *   If the vSwitch is in the **Available** state, the route table is disassociated.
   * *   You cannot repeatedly call the **UnassociateRouteTable** operation to disassociate a route table from a vSwitch within the specified period of time.
   * 
   * @param request - UnassociateRouteTableRequest
   * @returns UnassociateRouteTableResponse
   */
  async unassociateRouteTable(request: $_model.UnassociateRouteTableRequest): Promise<$_model.UnassociateRouteTableResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.unassociateRouteTableWithOptions(request, runtime);
  }

  /**
   * Removes a secondary CIDR block from a virtual private cloud (VPC).
   * 
   * @remarks
   *   Before you delete a secondary CIDR block from a VPC, delete the vSwitch which is created with the CIDR block. For more information, see [DeleteVSwitch](https://help.aliyun.com/document_detail/35746.html).
   * *   You cannot repeatedly call the **UnassociateVpcCidrBlock** operation to delete a secondary CIDR block from a VPC within the specified period of time.
   * 
   * @param request - UnassociateVpcCidrBlockRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UnassociateVpcCidrBlockResponse
   */
  async unassociateVpcCidrBlockWithOptions(request: $_model.UnassociateVpcCidrBlockRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UnassociateVpcCidrBlockResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.IPv6CidrBlock)) {
      query["IPv6CidrBlock"] = request.IPv6CidrBlock;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.secondaryCidrBlock)) {
      query["SecondaryCidrBlock"] = request.secondaryCidrBlock;
    }

    if (!$dara.isNull(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UnassociateVpcCidrBlock",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UnassociateVpcCidrBlockResponse>(await this.callApi(params, req, runtime), new $_model.UnassociateVpcCidrBlockResponse({}));
  }

  /**
   * Removes a secondary CIDR block from a virtual private cloud (VPC).
   * 
   * @remarks
   *   Before you delete a secondary CIDR block from a VPC, delete the vSwitch which is created with the CIDR block. For more information, see [DeleteVSwitch](https://help.aliyun.com/document_detail/35746.html).
   * *   You cannot repeatedly call the **UnassociateVpcCidrBlock** operation to delete a secondary CIDR block from a VPC within the specified period of time.
   * 
   * @param request - UnassociateVpcCidrBlockRequest
   * @returns UnassociateVpcCidrBlockResponse
   */
  async unassociateVpcCidrBlock(request: $_model.UnassociateVpcCidrBlockRequest): Promise<$_model.UnassociateVpcCidrBlockResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.unassociateVpcCidrBlockWithOptions(request, runtime);
  }

  /**
   * Removes tags from an Express Connect circuit at a time.
   * 
   * @param request - UntagResourcesForExpressConnectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UntagResourcesForExpressConnectResponse
   */
  async untagResourcesForExpressConnectWithOptions(request: $_model.UntagResourcesForExpressConnectRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UntagResourcesForExpressConnectResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.all)) {
      query["All"] = request.all;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!$dara.isNull(request.tagKey)) {
      query["TagKey"] = request.tagKey;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UntagResourcesForExpressConnect",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UntagResourcesForExpressConnectResponse>(await this.callApi(params, req, runtime), new $_model.UntagResourcesForExpressConnectResponse({}));
  }

  /**
   * Removes tags from an Express Connect circuit at a time.
   * 
   * @param request - UntagResourcesForExpressConnectRequest
   * @returns UntagResourcesForExpressConnectResponse
   */
  async untagResourcesForExpressConnect(request: $_model.UntagResourcesForExpressConnectRequest): Promise<$_model.UntagResourcesForExpressConnectResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.untagResourcesForExpressConnectWithOptions(request, runtime);
  }

  /**
   * Dhcp
   * 
   * @param request - UpdateDhcpOptionsSetAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDhcpOptionsSetAttributeResponse
   */
  async updateDhcpOptionsSetAttributeWithOptions(request: $_model.UpdateDhcpOptionsSetAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UpdateDhcpOptionsSetAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dhcpOptionsSetDescription)) {
      query["DhcpOptionsSetDescription"] = request.dhcpOptionsSetDescription;
    }

    if (!$dara.isNull(request.dhcpOptionsSetId)) {
      query["DhcpOptionsSetId"] = request.dhcpOptionsSetId;
    }

    if (!$dara.isNull(request.dhcpOptionsSetName)) {
      query["DhcpOptionsSetName"] = request.dhcpOptionsSetName;
    }

    if (!$dara.isNull(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!$dara.isNull(request.domainNameServers)) {
      query["DomainNameServers"] = request.domainNameServers;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ipv6LeaseTime)) {
      query["Ipv6LeaseTime"] = request.ipv6LeaseTime;
    }

    if (!$dara.isNull(request.leaseTime)) {
      query["LeaseTime"] = request.leaseTime;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateDhcpOptionsSetAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UpdateDhcpOptionsSetAttributeResponse>(await this.callApi(params, req, runtime), new $_model.UpdateDhcpOptionsSetAttributeResponse({}));
  }

  /**
   * Dhcp
   * 
   * @param request - UpdateDhcpOptionsSetAttributeRequest
   * @returns UpdateDhcpOptionsSetAttributeResponse
   */
  async updateDhcpOptionsSetAttribute(request: $_model.UpdateDhcpOptionsSetAttributeRequest): Promise<$_model.UpdateDhcpOptionsSetAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateDhcpOptionsSetAttributeWithOptions(request, runtime);
  }

  /**
   * Updates a failover test.
   * 
   * @param request - UpdateFailoverTestJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateFailoverTestJobResponse
   */
  async updateFailoverTestJobWithOptions(request: $_model.UpdateFailoverTestJobRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UpdateFailoverTestJobResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.jobDuration)) {
      query["JobDuration"] = request.jobDuration;
    }

    if (!$dara.isNull(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateFailoverTestJob",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UpdateFailoverTestJobResponse>(await this.callApi(params, req, runtime), new $_model.UpdateFailoverTestJobResponse({}));
  }

  /**
   * Updates a failover test.
   * 
   * @param request - UpdateFailoverTestJobRequest
   * @returns UpdateFailoverTestJobResponse
   */
  async updateFailoverTestJob(request: $_model.UpdateFailoverTestJobRequest): Promise<$_model.UpdateFailoverTestJobResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateFailoverTestJobWithOptions(request, runtime);
  }

  /**
   * Modifies the next hop type and next hop of the route entry in a gateway route table.
   * 
   * @param request - UpdateGatewayRouteTableEntryAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayRouteTableEntryAttributeResponse
   */
  async updateGatewayRouteTableEntryAttributeWithOptions(request: $_model.UpdateGatewayRouteTableEntryAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UpdateGatewayRouteTableEntryAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.destinationCidrBlock)) {
      query["DestinationCidrBlock"] = request.destinationCidrBlock;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.gatewayRouteTableId)) {
      query["GatewayRouteTableId"] = request.gatewayRouteTableId;
    }

    if (!$dara.isNull(request.IPv4GatewayRouteTableId)) {
      query["IPv4GatewayRouteTableId"] = request.IPv4GatewayRouteTableId;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.nextHopId)) {
      query["NextHopId"] = request.nextHopId;
    }

    if (!$dara.isNull(request.nextHopType)) {
      query["NextHopType"] = request.nextHopType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateGatewayRouteTableEntryAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UpdateGatewayRouteTableEntryAttributeResponse>(await this.callApi(params, req, runtime), new $_model.UpdateGatewayRouteTableEntryAttributeResponse({}));
  }

  /**
   * Modifies the next hop type and next hop of the route entry in a gateway route table.
   * 
   * @param request - UpdateGatewayRouteTableEntryAttributeRequest
   * @returns UpdateGatewayRouteTableEntryAttributeResponse
   */
  async updateGatewayRouteTableEntryAttribute(request: $_model.UpdateGatewayRouteTableEntryAttributeRequest): Promise<$_model.UpdateGatewayRouteTableEntryAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateGatewayRouteTableEntryAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the configuration of an IPsec server.
   * 
   * @remarks
   *   If you modify only **IpsecServerName** of the IPsec server, this operation is synchronous. If you modify other parameters besides **IpsecServerName**, this operation is asynchronous.
   * *   If **UpdateIpsecServer** is an asynchronous operation, after a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the IPsec server is being modified.
   *     *   If the VPN gateway is in the **active** state, the IPsec server is modified.
   * *   You cannot repeatedly call **UpdateIpsecServer** within the specified period of time.
   * 
   * @param request - UpdateIpsecServerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateIpsecServerResponse
   */
  async updateIpsecServerWithOptions(request: $_model.UpdateIpsecServerRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UpdateIpsecServerResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientIpPool)) {
      query["ClientIpPool"] = request.clientIpPool;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.effectImmediately)) {
      query["EffectImmediately"] = request.effectImmediately;
    }

    if (!$dara.isNull(request.ikeConfig)) {
      query["IkeConfig"] = request.ikeConfig;
    }

    if (!$dara.isNull(request.ipsecConfig)) {
      query["IpsecConfig"] = request.ipsecConfig;
    }

    if (!$dara.isNull(request.ipsecServerId)) {
      query["IpsecServerId"] = request.ipsecServerId;
    }

    if (!$dara.isNull(request.ipsecServerName)) {
      query["IpsecServerName"] = request.ipsecServerName;
    }

    if (!$dara.isNull(request.localSubnet)) {
      query["LocalSubnet"] = request.localSubnet;
    }

    if (!$dara.isNull(request.psk)) {
      query["Psk"] = request.psk;
    }

    if (!$dara.isNull(request.pskEnabled)) {
      query["PskEnabled"] = request.pskEnabled;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateIpsecServer",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UpdateIpsecServerResponse>(await this.callApi(params, req, runtime), new $_model.UpdateIpsecServerResponse({}));
  }

  /**
   * Modifies the configuration of an IPsec server.
   * 
   * @remarks
   *   If you modify only **IpsecServerName** of the IPsec server, this operation is synchronous. If you modify other parameters besides **IpsecServerName**, this operation is asynchronous.
   * *   If **UpdateIpsecServer** is an asynchronous operation, after a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
   *     *   If the VPN gateway is in the **updating** state, the IPsec server is being modified.
   *     *   If the VPN gateway is in the **active** state, the IPsec server is modified.
   * *   You cannot repeatedly call **UpdateIpsecServer** within the specified period of time.
   * 
   * @param request - UpdateIpsecServerRequest
   * @returns UpdateIpsecServerResponse
   */
  async updateIpsecServer(request: $_model.UpdateIpsecServerRequest): Promise<$_model.UpdateIpsecServerResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateIpsecServerWithOptions(request, runtime);
  }

  /**
   * Modifies the description or name of an IPv4 gateway.
   * 
   * @remarks
   * You cannot repeatedly call the **UpdateIpv4GatewayAttribute** operation to modify the name or description of an IPv4 gateway within the specified period of time.
   * 
   * @param request - UpdateIpv4GatewayAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateIpv4GatewayAttributeResponse
   */
  async updateIpv4GatewayAttributeWithOptions(request: $_model.UpdateIpv4GatewayAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UpdateIpv4GatewayAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ipv4GatewayDescription)) {
      query["Ipv4GatewayDescription"] = request.ipv4GatewayDescription;
    }

    if (!$dara.isNull(request.ipv4GatewayId)) {
      query["Ipv4GatewayId"] = request.ipv4GatewayId;
    }

    if (!$dara.isNull(request.ipv4GatewayName)) {
      query["Ipv4GatewayName"] = request.ipv4GatewayName;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateIpv4GatewayAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UpdateIpv4GatewayAttributeResponse>(await this.callApi(params, req, runtime), new $_model.UpdateIpv4GatewayAttributeResponse({}));
  }

  /**
   * Modifies the description or name of an IPv4 gateway.
   * 
   * @remarks
   * You cannot repeatedly call the **UpdateIpv4GatewayAttribute** operation to modify the name or description of an IPv4 gateway within the specified period of time.
   * 
   * @param request - UpdateIpv4GatewayAttributeRequest
   * @returns UpdateIpv4GatewayAttributeResponse
   */
  async updateIpv4GatewayAttribute(request: $_model.UpdateIpv4GatewayAttributeRequest): Promise<$_model.UpdateIpv4GatewayAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateIpv4GatewayAttributeWithOptions(request, runtime);
  }

  /**
   * Upgrades a standard NAT gateway to an enhanced NAT gateway.
   * 
   * @remarks
   * Before you call this operation, take note of the following limits:
   * *   **UpdateNatGatewayNatType** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the NAT gateway is still being upgraded in the backend. You can call the GetNatGatewayConvertStatus operation to query the upgrade progress of a NAT gateway. For more information, see [GetNatGatewayConvertStatus](https://help.aliyun.com/document_detail/184744.html).
   *     *   If the NAT gateway is in the **processing** state, the NAT gateway is being upgraded. You can only query the status of the NAT gateway but cannot perform other operations.
   *     *   If the NAT gateway is in the **successful** state, the NAT gateway is upgraded.
   *     *   If the NAT gateway is in the **failed** state, the system failed to upgrade the NAT gateway.
   * *   You cannot repeatedly call the **UpdateNatGatewayNatType** operation for the same VPN gateway within the specified period of time.
   * *   The billing method and billable items remain the same after the upgrade.
   * *   It takes about five minutes to upgrade a standard NAT gateway to an enhanced NAT gateway. During the upgrade, transient connection errors may occur once or twice. The service can be recovered by reconnection. You can determine whether to enable automatic reconnection or use manual reconnection based on your business requirements.
   * *   You can only upgrade standard NAT gateways to enhanced NAT gateways. You are not allowed to downgrade enhanced NAT gateways to standard NAT gateways.
   * 
   * @deprecated OpenAPI UpdateNatGatewayNatType is deprecated
   * 
   * @param request - UpdateNatGatewayNatTypeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateNatGatewayNatTypeResponse
   */
  async updateNatGatewayNatTypeWithOptions(request: $_model.UpdateNatGatewayNatTypeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UpdateNatGatewayNatTypeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.natGatewayId)) {
      query["NatGatewayId"] = request.natGatewayId;
    }

    if (!$dara.isNull(request.natType)) {
      query["NatType"] = request.natType;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateNatGatewayNatType",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UpdateNatGatewayNatTypeResponse>(await this.callApi(params, req, runtime), new $_model.UpdateNatGatewayNatTypeResponse({}));
  }

  /**
   * Upgrades a standard NAT gateway to an enhanced NAT gateway.
   * 
   * @remarks
   * Before you call this operation, take note of the following limits:
   * *   **UpdateNatGatewayNatType** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the NAT gateway is still being upgraded in the backend. You can call the GetNatGatewayConvertStatus operation to query the upgrade progress of a NAT gateway. For more information, see [GetNatGatewayConvertStatus](https://help.aliyun.com/document_detail/184744.html).
   *     *   If the NAT gateway is in the **processing** state, the NAT gateway is being upgraded. You can only query the status of the NAT gateway but cannot perform other operations.
   *     *   If the NAT gateway is in the **successful** state, the NAT gateway is upgraded.
   *     *   If the NAT gateway is in the **failed** state, the system failed to upgrade the NAT gateway.
   * *   You cannot repeatedly call the **UpdateNatGatewayNatType** operation for the same VPN gateway within the specified period of time.
   * *   The billing method and billable items remain the same after the upgrade.
   * *   It takes about five minutes to upgrade a standard NAT gateway to an enhanced NAT gateway. During the upgrade, transient connection errors may occur once or twice. The service can be recovered by reconnection. You can determine whether to enable automatic reconnection or use manual reconnection based on your business requirements.
   * *   You can only upgrade standard NAT gateways to enhanced NAT gateways. You are not allowed to downgrade enhanced NAT gateways to standard NAT gateways.
   * 
   * @deprecated OpenAPI UpdateNatGatewayNatType is deprecated
   * 
   * @param request - UpdateNatGatewayNatTypeRequest
   * @returns UpdateNatGatewayNatTypeResponse
   */
  // Deprecated
  async updateNatGatewayNatType(request: $_model.UpdateNatGatewayNatTypeRequest): Promise<$_model.UpdateNatGatewayNatTypeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateNatGatewayNatTypeWithOptions(request, runtime);
  }

  /**
   * Updates the rules of a network access control list (ACL).
   * 
   * @remarks
   *   **UpdateNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of a network ACL:
   *     *   If the network ACL is in the **Modifying** state, the rules of the network ACL are being updated.
   *     *   If the network ACL is in the **Available** state, the rules of the network ACL are updated.
   * *   You cannot repeatedly call the **UpdateNetworkAclEntries** operation to update the rules of a network ACL within the specified period of time.
   * 
   * @param request - UpdateNetworkAclEntriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateNetworkAclEntriesResponse
   */
  async updateNetworkAclEntriesWithOptions(request: $_model.UpdateNetworkAclEntriesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UpdateNetworkAclEntriesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.egressAclEntries)) {
      query["EgressAclEntries"] = request.egressAclEntries;
    }

    if (!$dara.isNull(request.ingressAclEntries)) {
      query["IngressAclEntries"] = request.ingressAclEntries;
    }

    if (!$dara.isNull(request.networkAclId)) {
      query["NetworkAclId"] = request.networkAclId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.updateEgressAclEntries)) {
      query["UpdateEgressAclEntries"] = request.updateEgressAclEntries;
    }

    if (!$dara.isNull(request.updateIngressAclEntries)) {
      query["UpdateIngressAclEntries"] = request.updateIngressAclEntries;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateNetworkAclEntries",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UpdateNetworkAclEntriesResponse>(await this.callApi(params, req, runtime), new $_model.UpdateNetworkAclEntriesResponse({}));
  }

  /**
   * Updates the rules of a network access control list (ACL).
   * 
   * @remarks
   *   **UpdateNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of a network ACL:
   *     *   If the network ACL is in the **Modifying** state, the rules of the network ACL are being updated.
   *     *   If the network ACL is in the **Available** state, the rules of the network ACL are updated.
   * *   You cannot repeatedly call the **UpdateNetworkAclEntries** operation to update the rules of a network ACL within the specified period of time.
   * 
   * @param request - UpdateNetworkAclEntriesRequest
   * @returns UpdateNetworkAclEntriesResponse
   */
  async updateNetworkAclEntries(request: $_model.UpdateNetworkAclEntriesRequest): Promise<$_model.UpdateNetworkAclEntriesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateNetworkAclEntriesWithOptions(request, runtime);
  }

  /**
   * Modifies the attributes of an IP address pool.
   * 
   * @remarks
   * You cannot repeatedly call the **UpdatePublicIpAddressPoolAttribute** operation to modify the attributes of an IP address pool within the specified period of time.
   * 
   * @param request - UpdatePublicIpAddressPoolAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdatePublicIpAddressPoolAttributeResponse
   */
  async updatePublicIpAddressPoolAttributeWithOptions(request: $_model.UpdatePublicIpAddressPoolAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UpdatePublicIpAddressPoolAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.publicIpAddressPoolId)) {
      query["PublicIpAddressPoolId"] = request.publicIpAddressPoolId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdatePublicIpAddressPoolAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UpdatePublicIpAddressPoolAttributeResponse>(await this.callApi(params, req, runtime), new $_model.UpdatePublicIpAddressPoolAttributeResponse({}));
  }

  /**
   * Modifies the attributes of an IP address pool.
   * 
   * @remarks
   * You cannot repeatedly call the **UpdatePublicIpAddressPoolAttribute** operation to modify the attributes of an IP address pool within the specified period of time.
   * 
   * @param request - UpdatePublicIpAddressPoolAttributeRequest
   * @returns UpdatePublicIpAddressPoolAttributeResponse
   */
  async updatePublicIpAddressPoolAttribute(request: $_model.UpdatePublicIpAddressPoolAttributeRequest): Promise<$_model.UpdatePublicIpAddressPoolAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updatePublicIpAddressPoolAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the configuration of a filter for traffic mirror.
   * 
   * @remarks
   * You cannot repeatedly call the **UpdateTrafficMirrorFilterAttribute** operation to modify the configuration of a filter for traffic mirror within the specified period of time.
   * 
   * @param request - UpdateTrafficMirrorFilterAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTrafficMirrorFilterAttributeResponse
   */
  async updateTrafficMirrorFilterAttributeWithOptions(request: $_model.UpdateTrafficMirrorFilterAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UpdateTrafficMirrorFilterAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.trafficMirrorFilterDescription)) {
      query["TrafficMirrorFilterDescription"] = request.trafficMirrorFilterDescription;
    }

    if (!$dara.isNull(request.trafficMirrorFilterId)) {
      query["TrafficMirrorFilterId"] = request.trafficMirrorFilterId;
    }

    if (!$dara.isNull(request.trafficMirrorFilterName)) {
      query["TrafficMirrorFilterName"] = request.trafficMirrorFilterName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateTrafficMirrorFilterAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UpdateTrafficMirrorFilterAttributeResponse>(await this.callApi(params, req, runtime), new $_model.UpdateTrafficMirrorFilterAttributeResponse({}));
  }

  /**
   * Modifies the configuration of a filter for traffic mirror.
   * 
   * @remarks
   * You cannot repeatedly call the **UpdateTrafficMirrorFilterAttribute** operation to modify the configuration of a filter for traffic mirror within the specified period of time.
   * 
   * @param request - UpdateTrafficMirrorFilterAttributeRequest
   * @returns UpdateTrafficMirrorFilterAttributeResponse
   */
  async updateTrafficMirrorFilterAttribute(request: $_model.UpdateTrafficMirrorFilterAttributeRequest): Promise<$_model.UpdateTrafficMirrorFilterAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateTrafficMirrorFilterAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the configuration of an inbound or outbound rule for traffic mirroring.
   * 
   * @remarks
   *   The **UpdateTrafficMirrorFilterRuleAttribute** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of an inbound or outbound rule:
   *     *   If the rule is in the **Modifying** state, the rule is being modified.
   *     *   If the rule is in the **Created** state, the rule is modified.
   * *   You cannot repeatedly call the **UpdateTrafficMirrorFilterRuleAttribute** operation to modify an inbound or outbound rule within the specified period of time.
   * 
   * @param request - UpdateTrafficMirrorFilterRuleAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTrafficMirrorFilterRuleAttributeResponse
   */
  async updateTrafficMirrorFilterRuleAttributeWithOptions(request: $_model.UpdateTrafficMirrorFilterRuleAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UpdateTrafficMirrorFilterRuleAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.destinationCidrBlock)) {
      query["DestinationCidrBlock"] = request.destinationCidrBlock;
    }

    if (!$dara.isNull(request.destinationPortRange)) {
      query["DestinationPortRange"] = request.destinationPortRange;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.priority)) {
      query["Priority"] = request.priority;
    }

    if (!$dara.isNull(request.protocol)) {
      query["Protocol"] = request.protocol;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.ruleAction)) {
      query["RuleAction"] = request.ruleAction;
    }

    if (!$dara.isNull(request.sourceCidrBlock)) {
      query["SourceCidrBlock"] = request.sourceCidrBlock;
    }

    if (!$dara.isNull(request.sourcePortRange)) {
      query["SourcePortRange"] = request.sourcePortRange;
    }

    if (!$dara.isNull(request.trafficMirrorFilterRuleId)) {
      query["TrafficMirrorFilterRuleId"] = request.trafficMirrorFilterRuleId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateTrafficMirrorFilterRuleAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UpdateTrafficMirrorFilterRuleAttributeResponse>(await this.callApi(params, req, runtime), new $_model.UpdateTrafficMirrorFilterRuleAttributeResponse({}));
  }

  /**
   * Modifies the configuration of an inbound or outbound rule for traffic mirroring.
   * 
   * @remarks
   *   The **UpdateTrafficMirrorFilterRuleAttribute** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of an inbound or outbound rule:
   *     *   If the rule is in the **Modifying** state, the rule is being modified.
   *     *   If the rule is in the **Created** state, the rule is modified.
   * *   You cannot repeatedly call the **UpdateTrafficMirrorFilterRuleAttribute** operation to modify an inbound or outbound rule within the specified period of time.
   * 
   * @param request - UpdateTrafficMirrorFilterRuleAttributeRequest
   * @returns UpdateTrafficMirrorFilterRuleAttributeResponse
   */
  async updateTrafficMirrorFilterRuleAttribute(request: $_model.UpdateTrafficMirrorFilterRuleAttributeRequest): Promise<$_model.UpdateTrafficMirrorFilterRuleAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateTrafficMirrorFilterRuleAttributeWithOptions(request, runtime);
  }

  /**
   * Modifies the configuration of a traffic mirror session.
   * 
   * @remarks
   * ## Usage notes
   * *   **UpdateTrafficMirrorSessionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
   *     *   If the traffic mirror session is in the **Modifying** state, the configuration of the traffic mirror session is being modified.
   *     *   If the traffic mirror session is in the **Created** state, the configuration of the traffic mirror session is modified.
   * *   You cannot repeatedly call the **UpdateTrafficMirrorSessionAttribute** operation within a specific period of time.
   * 
   * @param request - UpdateTrafficMirrorSessionAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTrafficMirrorSessionAttributeResponse
   */
  async updateTrafficMirrorSessionAttributeWithOptions(request: $_model.UpdateTrafficMirrorSessionAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UpdateTrafficMirrorSessionAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.enabled)) {
      query["Enabled"] = request.enabled;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.packetLength)) {
      query["PacketLength"] = request.packetLength;
    }

    if (!$dara.isNull(request.priority)) {
      query["Priority"] = request.priority;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.trafficMirrorFilterId)) {
      query["TrafficMirrorFilterId"] = request.trafficMirrorFilterId;
    }

    if (!$dara.isNull(request.trafficMirrorSessionDescription)) {
      query["TrafficMirrorSessionDescription"] = request.trafficMirrorSessionDescription;
    }

    if (!$dara.isNull(request.trafficMirrorSessionId)) {
      query["TrafficMirrorSessionId"] = request.trafficMirrorSessionId;
    }

    if (!$dara.isNull(request.trafficMirrorSessionName)) {
      query["TrafficMirrorSessionName"] = request.trafficMirrorSessionName;
    }

    if (!$dara.isNull(request.trafficMirrorTargetId)) {
      query["TrafficMirrorTargetId"] = request.trafficMirrorTargetId;
    }

    if (!$dara.isNull(request.trafficMirrorTargetType)) {
      query["TrafficMirrorTargetType"] = request.trafficMirrorTargetType;
    }

    if (!$dara.isNull(request.virtualNetworkId)) {
      query["VirtualNetworkId"] = request.virtualNetworkId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateTrafficMirrorSessionAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UpdateTrafficMirrorSessionAttributeResponse>(await this.callApi(params, req, runtime), new $_model.UpdateTrafficMirrorSessionAttributeResponse({}));
  }

  /**
   * Modifies the configuration of a traffic mirror session.
   * 
   * @remarks
   * ## Usage notes
   * *   **UpdateTrafficMirrorSessionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
   *     *   If the traffic mirror session is in the **Modifying** state, the configuration of the traffic mirror session is being modified.
   *     *   If the traffic mirror session is in the **Created** state, the configuration of the traffic mirror session is modified.
   * *   You cannot repeatedly call the **UpdateTrafficMirrorSessionAttribute** operation within a specific period of time.
   * 
   * @param request - UpdateTrafficMirrorSessionAttributeRequest
   * @returns UpdateTrafficMirrorSessionAttributeResponse
   */
  async updateTrafficMirrorSessionAttribute(request: $_model.UpdateTrafficMirrorSessionAttributeRequest): Promise<$_model.UpdateTrafficMirrorSessionAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateTrafficMirrorSessionAttributeWithOptions(request, runtime);
  }

  /**
   * Updates the maximum bandwidth value of outbound data transfer for a virtual border router (VBR).
   * 
   * @param request - UpdateVirtualBorderBandwidthRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateVirtualBorderBandwidthResponse
   */
  async updateVirtualBorderBandwidthWithOptions(request: $_model.UpdateVirtualBorderBandwidthRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UpdateVirtualBorderBandwidthResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.bandwidth)) {
      query["Bandwidth"] = request.bandwidth;
    }

    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.virtualBorderRouterId)) {
      query["VirtualBorderRouterId"] = request.virtualBorderRouterId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateVirtualBorderBandwidth",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UpdateVirtualBorderBandwidthResponse>(await this.callApi(params, req, runtime), new $_model.UpdateVirtualBorderBandwidthResponse({}));
  }

  /**
   * Updates the maximum bandwidth value of outbound data transfer for a virtual border router (VBR).
   * 
   * @param request - UpdateVirtualBorderBandwidthRequest
   * @returns UpdateVirtualBorderBandwidthResponse
   */
  async updateVirtualBorderBandwidth(request: $_model.UpdateVirtualBorderBandwidthRequest): Promise<$_model.UpdateVirtualBorderBandwidthResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateVirtualBorderBandwidthWithOptions(request, runtime);
  }

  /**
   * Changes the virtual local area network (VLAN) ID of a hosted connection over Express Connect circuit.
   * 
   * @param request - UpdateVirtualPhysicalConnectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateVirtualPhysicalConnectionResponse
   */
  async updateVirtualPhysicalConnectionWithOptions(request: $_model.UpdateVirtualPhysicalConnectionRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UpdateVirtualPhysicalConnectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.expectSpec)) {
      query["ExpectSpec"] = request.expectSpec;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.token)) {
      query["Token"] = request.token;
    }

    if (!$dara.isNull(request.vlanId)) {
      query["VlanId"] = request.vlanId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateVirtualPhysicalConnection",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UpdateVirtualPhysicalConnectionResponse>(await this.callApi(params, req, runtime), new $_model.UpdateVirtualPhysicalConnectionResponse({}));
  }

  /**
   * Changes the virtual local area network (VLAN) ID of a hosted connection over Express Connect circuit.
   * 
   * @param request - UpdateVirtualPhysicalConnectionRequest
   * @returns UpdateVirtualPhysicalConnectionResponse
   */
  async updateVirtualPhysicalConnection(request: $_model.UpdateVirtualPhysicalConnectionRequest): Promise<$_model.UpdateVirtualPhysicalConnectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateVirtualPhysicalConnectionWithOptions(request, runtime);
  }

  /**
   * Modifies the configuration of a gateway endpoint.
   * 
   * @remarks
   *   **UpdateVpcGatewayEndpointAttribute** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query the status of the task.
   *     *   If the gateway endpoint is in the **Updating** state, it is being modified.
   *     *   If the gateway endpoint is in the **Created** state, it is modified.
   * *   You cannot call the **UpdateVpcGatewayEndpointAttribute** operation within a specific period of time.
   * 
   * @param request - UpdateVpcGatewayEndpointAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateVpcGatewayEndpointAttributeResponse
   */
  async updateVpcGatewayEndpointAttributeWithOptions(request: $_model.UpdateVpcGatewayEndpointAttributeRequest, runtime: $dara.RuntimeOptions): Promise<$_model.UpdateVpcGatewayEndpointAttributeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.endpointDescription)) {
      query["EndpointDescription"] = request.endpointDescription;
    }

    if (!$dara.isNull(request.endpointId)) {
      query["EndpointId"] = request.endpointId;
    }

    if (!$dara.isNull(request.endpointName)) {
      query["EndpointName"] = request.endpointName;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.policyDocument)) {
      query["PolicyDocument"] = request.policyDocument;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateVpcGatewayEndpointAttribute",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.UpdateVpcGatewayEndpointAttributeResponse>(await this.callApi(params, req, runtime), new $_model.UpdateVpcGatewayEndpointAttributeResponse({}));
  }

  /**
   * Modifies the configuration of a gateway endpoint.
   * 
   * @remarks
   *   **UpdateVpcGatewayEndpointAttribute** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query the status of the task.
   *     *   If the gateway endpoint is in the **Updating** state, it is being modified.
   *     *   If the gateway endpoint is in the **Created** state, it is modified.
   * *   You cannot call the **UpdateVpcGatewayEndpointAttribute** operation within a specific period of time.
   * 
   * @param request - UpdateVpcGatewayEndpointAttributeRequest
   * @returns UpdateVpcGatewayEndpointAttributeResponse
   */
  async updateVpcGatewayEndpointAttribute(request: $_model.UpdateVpcGatewayEndpointAttributeRequest): Promise<$_model.UpdateVpcGatewayEndpointAttributeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateVpcGatewayEndpointAttributeWithOptions(request, runtime);
  }

  /**
   * eni quota
   * 
   * @remarks
   * Before you call this operation, make sure that a VPC NAT gateway is created. For more information, see [CreateNatGateway](https://help.aliyun.com/document_detail/120219.html).
   * 
   * @param request - VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse
   */
  async vpcDescribeVpcNatGatewayNetworkInterfaceQuotaWithOptions(request: $_model.VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest, runtime: $dara.RuntimeOptions): Promise<$_model.VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.natGatewayId)) {
      query["NatGatewayId"] = request.natGatewayId;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.resourceUid)) {
      query["ResourceUid"] = request.resourceUid;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "VpcDescribeVpcNatGatewayNetworkInterfaceQuota",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse>(await this.callApi(params, req, runtime), new $_model.VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse({}));
  }

  /**
   * eni quota
   * 
   * @remarks
   * Before you call this operation, make sure that a VPC NAT gateway is created. For more information, see [CreateNatGateway](https://help.aliyun.com/document_detail/120219.html).
   * 
   * @param request - VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest
   * @returns VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse
   */
  async vpcDescribeVpcNatGatewayNetworkInterfaceQuota(request: $_model.VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest): Promise<$_model.VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.vpcDescribeVpcNatGatewayNetworkInterfaceQuotaWithOptions(request, runtime);
  }

  /**
   * Withdraw advertised Virtual Private Cloud (VPC) routes.
   * 
   * @param request - WithdrawVpcPublishedRouteEntriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns WithdrawVpcPublishedRouteEntriesResponse
   */
  async withdrawVpcPublishedRouteEntriesWithOptions(request: $_model.WithdrawVpcPublishedRouteEntriesRequest, runtime: $dara.RuntimeOptions): Promise<$_model.WithdrawVpcPublishedRouteEntriesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceOwnerAccount)) {
      query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
    }

    if (!$dara.isNull(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!$dara.isNull(request.routeEntries)) {
      query["RouteEntries"] = request.routeEntries;
    }

    if (!$dara.isNull(request.targetInstanceId)) {
      query["TargetInstanceId"] = request.targetInstanceId;
    }

    if (!$dara.isNull(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "WithdrawVpcPublishedRouteEntries",
      version: "2016-04-28",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $dara.cast<$_model.WithdrawVpcPublishedRouteEntriesResponse>(await this.callApi(params, req, runtime), new $_model.WithdrawVpcPublishedRouteEntriesResponse({}));
  }

  /**
   * Withdraw advertised Virtual Private Cloud (VPC) routes.
   * 
   * @param request - WithdrawVpcPublishedRouteEntriesRequest
   * @returns WithdrawVpcPublishedRouteEntriesResponse
   */
  async withdrawVpcPublishedRouteEntries(request: $_model.WithdrawVpcPublishedRouteEntriesRequest): Promise<$_model.WithdrawVpcPublishedRouteEntriesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.withdrawVpcPublishedRouteEntriesWithOptions(request, runtime);
  }

}
