// This file is auto-generated, don't edit it
/**
 *
 */
import Util, * as $Util from '@alicloud/tea-util';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class AddCasterComponentRequest extends $tea.Model {
  captionLayerContent?: string;
  casterId?: string;
  componentLayer?: string;
  componentName?: string;
  componentType?: string;
  effect?: string;
  htmlLayerContent?: string;
  imageLayerContent?: string;
  layerOrder?: string;
  locationId?: string;
  ownerId?: number;
  textLayerContent?: string;
  static names(): { [key: string]: string } {
    return {
      captionLayerContent: 'CaptionLayerContent',
      casterId: 'CasterId',
      componentLayer: 'ComponentLayer',
      componentName: 'ComponentName',
      componentType: 'ComponentType',
      effect: 'Effect',
      htmlLayerContent: 'HtmlLayerContent',
      imageLayerContent: 'ImageLayerContent',
      layerOrder: 'LayerOrder',
      locationId: 'LocationId',
      ownerId: 'OwnerId',
      textLayerContent: 'TextLayerContent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      captionLayerContent: 'string',
      casterId: 'string',
      componentLayer: 'string',
      componentName: 'string',
      componentType: 'string',
      effect: 'string',
      htmlLayerContent: 'string',
      imageLayerContent: 'string',
      layerOrder: 'string',
      locationId: 'string',
      ownerId: 'number',
      textLayerContent: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterComponentResponseBody extends $tea.Model {
  componentId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      componentId: 'ComponentId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      componentId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterComponentResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddCasterComponentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddCasterComponentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterEpisodeRequest extends $tea.Model {
  casterId?: string;
  componentId?: string[];
  endTime?: string;
  episodeName?: string;
  episodeType?: string;
  ownerId?: number;
  resourceId?: string;
  startTime?: string;
  switchType?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      componentId: 'ComponentId',
      endTime: 'EndTime',
      episodeName: 'EpisodeName',
      episodeType: 'EpisodeType',
      ownerId: 'OwnerId',
      resourceId: 'ResourceId',
      startTime: 'StartTime',
      switchType: 'SwitchType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      componentId: { 'type': 'array', 'itemType': 'string' },
      endTime: 'string',
      episodeName: 'string',
      episodeType: 'string',
      ownerId: 'number',
      resourceId: 'string',
      startTime: 'string',
      switchType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterEpisodeResponseBody extends $tea.Model {
  episodeId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      episodeId: 'EpisodeId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      episodeId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterEpisodeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddCasterEpisodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddCasterEpisodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterEpisodeGroupRequest extends $tea.Model {
  callbackUrl?: string;
  clientToken?: string;
  domainName?: string;
  item?: AddCasterEpisodeGroupRequestItem[];
  ownerId?: number;
  repeatNum?: number;
  sideOutputUrl?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      callbackUrl: 'CallbackUrl',
      clientToken: 'ClientToken',
      domainName: 'DomainName',
      item: 'Item',
      ownerId: 'OwnerId',
      repeatNum: 'RepeatNum',
      sideOutputUrl: 'SideOutputUrl',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      callbackUrl: 'string',
      clientToken: 'string',
      domainName: 'string',
      item: { 'type': 'array', 'itemType': AddCasterEpisodeGroupRequestItem },
      ownerId: 'number',
      repeatNum: 'number',
      sideOutputUrl: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterEpisodeGroupResponseBody extends $tea.Model {
  itemIds?: AddCasterEpisodeGroupResponseBodyItemIds;
  programId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      itemIds: 'ItemIds',
      programId: 'ProgramId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemIds: AddCasterEpisodeGroupResponseBodyItemIds,
      programId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterEpisodeGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddCasterEpisodeGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddCasterEpisodeGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterEpisodeGroupContentRequest extends $tea.Model {
  clientToken?: string;
  content?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      content: 'Content',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      content: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterEpisodeGroupContentResponseBody extends $tea.Model {
  itemIds?: AddCasterEpisodeGroupContentResponseBodyItemIds;
  programId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      itemIds: 'ItemIds',
      programId: 'ProgramId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemIds: AddCasterEpisodeGroupContentResponseBodyItemIds,
      programId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterEpisodeGroupContentResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddCasterEpisodeGroupContentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddCasterEpisodeGroupContentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterLayoutRequest extends $tea.Model {
  audioLayer?: AddCasterLayoutRequestAudioLayer[];
  blendList?: string[];
  casterId?: string;
  mixList?: string[];
  ownerId?: number;
  videoLayer?: AddCasterLayoutRequestVideoLayer[];
  static names(): { [key: string]: string } {
    return {
      audioLayer: 'AudioLayer',
      blendList: 'BlendList',
      casterId: 'CasterId',
      mixList: 'MixList',
      ownerId: 'OwnerId',
      videoLayer: 'VideoLayer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioLayer: { 'type': 'array', 'itemType': AddCasterLayoutRequestAudioLayer },
      blendList: { 'type': 'array', 'itemType': 'string' },
      casterId: 'string',
      mixList: { 'type': 'array', 'itemType': 'string' },
      ownerId: 'number',
      videoLayer: { 'type': 'array', 'itemType': AddCasterLayoutRequestVideoLayer },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterLayoutResponseBody extends $tea.Model {
  layoutId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      layoutId: 'LayoutId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      layoutId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterLayoutResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddCasterLayoutResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddCasterLayoutResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterProgramRequest extends $tea.Model {
  casterId?: string;
  episode?: AddCasterProgramRequestEpisode[];
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      episode: 'Episode',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      episode: { 'type': 'array', 'itemType': AddCasterProgramRequestEpisode },
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterProgramResponseBody extends $tea.Model {
  episodeIds?: AddCasterProgramResponseBodyEpisodeIds;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      episodeIds: 'EpisodeIds',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      episodeIds: AddCasterProgramResponseBodyEpisodeIds,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterProgramResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddCasterProgramResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddCasterProgramResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterVideoResourceRequest extends $tea.Model {
  beginOffset?: number;
  casterId?: string;
  endOffset?: number;
  fixedDelayDuration?: number;
  liveStreamUrl?: string;
  locationId?: string;
  materialId?: string;
  ownerId?: number;
  ptsCallbackInterval?: number;
  repeatNum?: number;
  resourceName?: string;
  streamId?: string;
  vodUrl?: string;
  static names(): { [key: string]: string } {
    return {
      beginOffset: 'BeginOffset',
      casterId: 'CasterId',
      endOffset: 'EndOffset',
      fixedDelayDuration: 'FixedDelayDuration',
      liveStreamUrl: 'LiveStreamUrl',
      locationId: 'LocationId',
      materialId: 'MaterialId',
      ownerId: 'OwnerId',
      ptsCallbackInterval: 'PtsCallbackInterval',
      repeatNum: 'RepeatNum',
      resourceName: 'ResourceName',
      streamId: 'StreamId',
      vodUrl: 'VodUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      beginOffset: 'number',
      casterId: 'string',
      endOffset: 'number',
      fixedDelayDuration: 'number',
      liveStreamUrl: 'string',
      locationId: 'string',
      materialId: 'string',
      ownerId: 'number',
      ptsCallbackInterval: 'number',
      repeatNum: 'number',
      resourceName: 'string',
      streamId: 'string',
      vodUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterVideoResourceResponseBody extends $tea.Model {
  requestId?: string;
  resourceId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      resourceId: 'ResourceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      resourceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterVideoResourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddCasterVideoResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddCasterVideoResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCustomLiveStreamTranscodeRequest extends $tea.Model {
  app?: string;
  audioBitrate?: number;
  audioChannelNum?: number;
  audioCodec?: string;
  audioProfile?: string;
  audioRate?: number;
  domain?: string;
  encryptParameters?: string;
  FPS?: number;
  gop?: string;
  height?: number;
  kmsKeyExpireInterval?: string;
  kmsKeyID?: string;
  kmsUID?: string;
  ownerId?: number;
  profile?: number;
  template?: string;
  templateType?: string;
  videoBitrate?: number;
  width?: number;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      audioBitrate: 'AudioBitrate',
      audioChannelNum: 'AudioChannelNum',
      audioCodec: 'AudioCodec',
      audioProfile: 'AudioProfile',
      audioRate: 'AudioRate',
      domain: 'Domain',
      encryptParameters: 'EncryptParameters',
      FPS: 'FPS',
      gop: 'Gop',
      height: 'Height',
      kmsKeyExpireInterval: 'KmsKeyExpireInterval',
      kmsKeyID: 'KmsKeyID',
      kmsUID: 'KmsUID',
      ownerId: 'OwnerId',
      profile: 'Profile',
      template: 'Template',
      templateType: 'TemplateType',
      videoBitrate: 'VideoBitrate',
      width: 'Width',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      audioBitrate: 'number',
      audioChannelNum: 'number',
      audioCodec: 'string',
      audioProfile: 'string',
      audioRate: 'number',
      domain: 'string',
      encryptParameters: 'string',
      FPS: 'number',
      gop: 'string',
      height: 'number',
      kmsKeyExpireInterval: 'string',
      kmsKeyID: 'string',
      kmsUID: 'string',
      ownerId: 'number',
      profile: 'number',
      template: 'string',
      templateType: 'string',
      videoBitrate: 'number',
      width: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCustomLiveStreamTranscodeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCustomLiveStreamTranscodeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddCustomLiveStreamTranscodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddCustomLiveStreamTranscodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveAppRecordConfigRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  endTime?: string;
  onDemand?: number;
  ossBucket?: string;
  ossEndpoint?: string;
  ownerId?: number;
  recordFormat?: AddLiveAppRecordConfigRequestRecordFormat[];
  securityToken?: string;
  startTime?: string;
  streamName?: string;
  transcodeRecordFormat?: AddLiveAppRecordConfigRequestTranscodeRecordFormat[];
  transcodeTemplates?: string[];
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      endTime: 'EndTime',
      onDemand: 'OnDemand',
      ossBucket: 'OssBucket',
      ossEndpoint: 'OssEndpoint',
      ownerId: 'OwnerId',
      recordFormat: 'RecordFormat',
      securityToken: 'SecurityToken',
      startTime: 'StartTime',
      streamName: 'StreamName',
      transcodeRecordFormat: 'TranscodeRecordFormat',
      transcodeTemplates: 'TranscodeTemplates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      endTime: 'string',
      onDemand: 'number',
      ossBucket: 'string',
      ossEndpoint: 'string',
      ownerId: 'number',
      recordFormat: { 'type': 'array', 'itemType': AddLiveAppRecordConfigRequestRecordFormat },
      securityToken: 'string',
      startTime: 'string',
      streamName: 'string',
      transcodeRecordFormat: { 'type': 'array', 'itemType': AddLiveAppRecordConfigRequestTranscodeRecordFormat },
      transcodeTemplates: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveAppRecordConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveAppRecordConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddLiveAppRecordConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddLiveAppRecordConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveAppSnapshotConfigRequest extends $tea.Model {
  appName?: string;
  callback?: string;
  domainName?: string;
  ossBucket?: string;
  ossEndpoint?: string;
  overwriteOssObject?: string;
  ownerId?: number;
  securityToken?: string;
  sequenceOssObject?: string;
  timeInterval?: number;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      callback: 'Callback',
      domainName: 'DomainName',
      ossBucket: 'OssBucket',
      ossEndpoint: 'OssEndpoint',
      overwriteOssObject: 'OverwriteOssObject',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
      sequenceOssObject: 'SequenceOssObject',
      timeInterval: 'TimeInterval',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      callback: 'string',
      domainName: 'string',
      ossBucket: 'string',
      ossEndpoint: 'string',
      overwriteOssObject: 'string',
      ownerId: 'number',
      securityToken: 'string',
      sequenceOssObject: 'string',
      timeInterval: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveAppSnapshotConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveAppSnapshotConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddLiveAppSnapshotConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddLiveAppSnapshotConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveAudioAuditConfigRequest extends $tea.Model {
  appName?: string;
  bizType?: string;
  domainName?: string;
  ossBucket?: string;
  ossEndpoint?: string;
  ossObject?: string;
  ownerId?: number;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      bizType: 'BizType',
      domainName: 'DomainName',
      ossBucket: 'OssBucket',
      ossEndpoint: 'OssEndpoint',
      ossObject: 'OssObject',
      ownerId: 'OwnerId',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      bizType: 'string',
      domainName: 'string',
      ossBucket: 'string',
      ossEndpoint: 'string',
      ossObject: 'string',
      ownerId: 'number',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveAudioAuditConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveAudioAuditConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddLiveAudioAuditConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddLiveAudioAuditConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveAudioAuditNotifyConfigRequest extends $tea.Model {
  callback?: string;
  callbackTemplate?: string;
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      callback: 'Callback',
      callbackTemplate: 'CallbackTemplate',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      callback: 'string',
      callbackTemplate: 'string',
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveAudioAuditNotifyConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveAudioAuditNotifyConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddLiveAudioAuditNotifyConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddLiveAudioAuditNotifyConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveDetectNotifyConfigRequest extends $tea.Model {
  domainName?: string;
  notifyUrl?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      notifyUrl: 'NotifyUrl',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      notifyUrl: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveDetectNotifyConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveDetectNotifyConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddLiveDetectNotifyConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddLiveDetectNotifyConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveDomainRequest extends $tea.Model {
  checkUrl?: string;
  domainName?: string;
  liveDomainType?: string;
  ownerAccount?: string;
  ownerId?: number;
  region?: string;
  scope?: string;
  securityToken?: string;
  topLevelDomain?: string;
  static names(): { [key: string]: string } {
    return {
      checkUrl: 'CheckUrl',
      domainName: 'DomainName',
      liveDomainType: 'LiveDomainType',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      region: 'Region',
      scope: 'Scope',
      securityToken: 'SecurityToken',
      topLevelDomain: 'TopLevelDomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkUrl: 'string',
      domainName: 'string',
      liveDomainType: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      region: 'string',
      scope: 'string',
      securityToken: 'string',
      topLevelDomain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveDomainResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveDomainResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddLiveDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddLiveDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveDomainMappingRequest extends $tea.Model {
  ownerId?: number;
  pullDomain?: string;
  pushDomain?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      pullDomain: 'PullDomain',
      pushDomain: 'PushDomain',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      pullDomain: 'string',
      pushDomain: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveDomainMappingResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveDomainMappingResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddLiveDomainMappingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddLiveDomainMappingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveDomainPlayMappingRequest extends $tea.Model {
  ownerId?: number;
  playDomain?: string;
  pullDomain?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      playDomain: 'PlayDomain',
      pullDomain: 'PullDomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      playDomain: 'string',
      pullDomain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveDomainPlayMappingResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveDomainPlayMappingResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddLiveDomainPlayMappingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddLiveDomainPlayMappingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLivePullStreamInfoConfigRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  endTime?: string;
  ownerId?: number;
  sourceUrl?: string;
  startTime?: string;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      endTime: 'EndTime',
      ownerId: 'OwnerId',
      sourceUrl: 'SourceUrl',
      startTime: 'StartTime',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      endTime: 'string',
      ownerId: 'number',
      sourceUrl: 'string',
      startTime: 'string',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLivePullStreamInfoConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLivePullStreamInfoConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddLivePullStreamInfoConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddLivePullStreamInfoConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveRecordNotifyConfigRequest extends $tea.Model {
  domainName?: string;
  needStatusNotify?: boolean;
  notifyUrl?: string;
  onDemandUrl?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      needStatusNotify: 'NeedStatusNotify',
      notifyUrl: 'NotifyUrl',
      onDemandUrl: 'OnDemandUrl',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      needStatusNotify: 'boolean',
      notifyUrl: 'string',
      onDemandUrl: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveRecordNotifyConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveRecordNotifyConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddLiveRecordNotifyConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddLiveRecordNotifyConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveRecordVodConfigRequest extends $tea.Model {
  appName?: string;
  autoCompose?: string;
  composeVodTranscodeGroupId?: string;
  cycleDuration?: number;
  domainName?: string;
  ownerId?: number;
  storageLocation?: string;
  streamName?: string;
  vodTranscodeGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      autoCompose: 'AutoCompose',
      composeVodTranscodeGroupId: 'ComposeVodTranscodeGroupId',
      cycleDuration: 'CycleDuration',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      storageLocation: 'StorageLocation',
      streamName: 'StreamName',
      vodTranscodeGroupId: 'VodTranscodeGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      autoCompose: 'string',
      composeVodTranscodeGroupId: 'string',
      cycleDuration: 'number',
      domainName: 'string',
      ownerId: 'number',
      storageLocation: 'string',
      streamName: 'string',
      vodTranscodeGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveRecordVodConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveRecordVodConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddLiveRecordVodConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddLiveRecordVodConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveSnapshotDetectPornConfigRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  interval?: number;
  ossBucket?: string;
  ossEndpoint?: string;
  ossObject?: string;
  ownerId?: number;
  scene?: string[];
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      interval: 'Interval',
      ossBucket: 'OssBucket',
      ossEndpoint: 'OssEndpoint',
      ossObject: 'OssObject',
      ownerId: 'OwnerId',
      scene: 'Scene',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      interval: 'number',
      ossBucket: 'string',
      ossEndpoint: 'string',
      ossObject: 'string',
      ownerId: 'number',
      scene: { 'type': 'array', 'itemType': 'string' },
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveSnapshotDetectPornConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveSnapshotDetectPornConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddLiveSnapshotDetectPornConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddLiveSnapshotDetectPornConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveSnapshotNotifyConfigRequest extends $tea.Model {
  domainName?: string;
  notifyAuthKey?: string;
  notifyReqAuth?: string;
  notifyUrl?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      notifyAuthKey: 'NotifyAuthKey',
      notifyReqAuth: 'NotifyReqAuth',
      notifyUrl: 'NotifyUrl',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      notifyAuthKey: 'string',
      notifyReqAuth: 'string',
      notifyUrl: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveSnapshotNotifyConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveSnapshotNotifyConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddLiveSnapshotNotifyConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddLiveSnapshotNotifyConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveStreamTranscodeRequest extends $tea.Model {
  app?: string;
  domain?: string;
  encryptParameters?: string;
  lazy?: string;
  ownerId?: number;
  template?: string;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      domain: 'Domain',
      encryptParameters: 'EncryptParameters',
      lazy: 'Lazy',
      ownerId: 'OwnerId',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      domain: 'string',
      encryptParameters: 'string',
      lazy: 'string',
      ownerId: 'number',
      template: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveStreamTranscodeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveStreamTranscodeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddLiveStreamTranscodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddLiveStreamTranscodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveStreamWatermarkRequest extends $tea.Model {
  description?: string;
  height?: number;
  name?: string;
  offsetCorner?: string;
  ownerId?: number;
  pictureUrl?: string;
  refHeight?: number;
  refWidth?: number;
  transparency?: number;
  type?: number;
  XOffset?: number;
  YOffset?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      height: 'Height',
      name: 'Name',
      offsetCorner: 'OffsetCorner',
      ownerId: 'OwnerId',
      pictureUrl: 'PictureUrl',
      refHeight: 'RefHeight',
      refWidth: 'RefWidth',
      transparency: 'Transparency',
      type: 'Type',
      XOffset: 'XOffset',
      YOffset: 'YOffset',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      height: 'number',
      name: 'string',
      offsetCorner: 'string',
      ownerId: 'number',
      pictureUrl: 'string',
      refHeight: 'number',
      refWidth: 'number',
      transparency: 'number',
      type: 'number',
      XOffset: 'number',
      YOffset: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveStreamWatermarkResponseBody extends $tea.Model {
  requestId?: string;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveStreamWatermarkResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddLiveStreamWatermarkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddLiveStreamWatermarkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveStreamWatermarkRuleRequest extends $tea.Model {
  app?: string;
  description?: string;
  domain?: string;
  name?: string;
  ownerId?: number;
  stream?: string;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      description: 'Description',
      domain: 'Domain',
      name: 'Name',
      ownerId: 'OwnerId',
      stream: 'Stream',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      description: 'string',
      domain: 'string',
      name: 'string',
      ownerId: 'number',
      stream: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveStreamWatermarkRuleResponseBody extends $tea.Model {
  requestId?: string;
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveStreamWatermarkRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddLiveStreamWatermarkRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddLiveStreamWatermarkRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMultiRateConfigRequest extends $tea.Model {
  app?: string;
  avFormat?: string;
  domainName?: string;
  groupId?: string;
  isLazy?: string;
  isTimeAlign?: string;
  ownerId?: number;
  templates?: string;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      avFormat: 'AvFormat',
      domainName: 'DomainName',
      groupId: 'GroupId',
      isLazy: 'IsLazy',
      isTimeAlign: 'IsTimeAlign',
      ownerId: 'OwnerId',
      templates: 'Templates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      avFormat: 'string',
      domainName: 'string',
      groupId: 'string',
      isLazy: 'string',
      isTimeAlign: 'string',
      ownerId: 'number',
      templates: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMultiRateConfigResponseBody extends $tea.Model {
  body?: AddMultiRateConfigResponseBodyBody;
  code?: number;
  message?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      body: 'Body',
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      body: AddMultiRateConfigResponseBodyBody,
      code: 'number',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMultiRateConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddMultiRateConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddMultiRateConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPlaylistItemsRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  programConfig?: string;
  programId?: string;
  programItems?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
      programConfig: 'ProgramConfig',
      programId: 'ProgramId',
      programItems: 'ProgramItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
      programConfig: 'string',
      programId: 'string',
      programItems: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPlaylistItemsResponseBody extends $tea.Model {
  items?: AddPlaylistItemsResponseBodyItems;
  programId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      programId: 'ProgramId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: AddPlaylistItemsResponseBodyItems,
      programId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPlaylistItemsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddPlaylistItemsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddPlaylistItemsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddRtsLiveStreamTranscodeRequest extends $tea.Model {
  app?: string;
  audioBitrate?: number;
  audioChannelNum?: number;
  audioCodec?: string;
  audioProfile?: string;
  audioRate?: number;
  deleteBframes?: boolean;
  domain?: string;
  FPS?: number;
  gop?: string;
  height?: number;
  lazy?: string;
  opus?: boolean;
  ownerId?: number;
  profile?: number;
  template?: string;
  templateType?: string;
  videoBitrate?: number;
  width?: number;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      audioBitrate: 'AudioBitrate',
      audioChannelNum: 'AudioChannelNum',
      audioCodec: 'AudioCodec',
      audioProfile: 'AudioProfile',
      audioRate: 'AudioRate',
      deleteBframes: 'DeleteBframes',
      domain: 'Domain',
      FPS: 'FPS',
      gop: 'Gop',
      height: 'Height',
      lazy: 'Lazy',
      opus: 'Opus',
      ownerId: 'OwnerId',
      profile: 'Profile',
      template: 'Template',
      templateType: 'TemplateType',
      videoBitrate: 'VideoBitrate',
      width: 'Width',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      audioBitrate: 'number',
      audioChannelNum: 'number',
      audioCodec: 'string',
      audioProfile: 'string',
      audioRate: 'number',
      deleteBframes: 'boolean',
      domain: 'string',
      FPS: 'number',
      gop: 'string',
      height: 'number',
      lazy: 'string',
      opus: 'boolean',
      ownerId: 'number',
      profile: 'number',
      template: 'string',
      templateType: 'string',
      videoBitrate: 'number',
      width: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddRtsLiveStreamTranscodeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddRtsLiveStreamTranscodeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddRtsLiveStreamTranscodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddRtsLiveStreamTranscodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddShowIntoShowListRequest extends $tea.Model {
  casterId?: string;
  duration?: number;
  liveInputType?: number;
  ownerId?: number;
  repeatTimes?: number;
  resourceId?: string;
  resourceType?: string;
  resourceUrl?: string;
  showName?: string;
  spot?: number;
  isBatchMode?: boolean;
  showList?: AddShowIntoShowListRequestShowList[];
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      duration: 'Duration',
      liveInputType: 'LiveInputType',
      ownerId: 'OwnerId',
      repeatTimes: 'RepeatTimes',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      resourceUrl: 'ResourceUrl',
      showName: 'ShowName',
      spot: 'Spot',
      isBatchMode: 'isBatchMode',
      showList: 'showList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      duration: 'number',
      liveInputType: 'number',
      ownerId: 'number',
      repeatTimes: 'number',
      resourceId: 'string',
      resourceType: 'string',
      resourceUrl: 'string',
      showName: 'string',
      spot: 'number',
      isBatchMode: 'boolean',
      showList: { 'type': 'array', 'itemType': AddShowIntoShowListRequestShowList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddShowIntoShowListResponseBody extends $tea.Model {
  requestId?: string;
  showId?: string;
  failedList?: string;
  successfulShowIds?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      showId: 'ShowId',
      failedList: 'failedList',
      successfulShowIds: 'successfulShowIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      showId: 'string',
      failedList: 'string',
      successfulShowIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddShowIntoShowListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddShowIntoShowListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddShowIntoShowListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddStudioLayoutRequest extends $tea.Model {
  bgImageConfig?: string;
  casterId?: string;
  commonConfig?: string;
  layerOrderConfigList?: string;
  layoutName?: string;
  layoutType?: string;
  mediaInputConfigList?: string;
  ownerId?: number;
  screenInputConfigList?: string;
  static names(): { [key: string]: string } {
    return {
      bgImageConfig: 'BgImageConfig',
      casterId: 'CasterId',
      commonConfig: 'CommonConfig',
      layerOrderConfigList: 'LayerOrderConfigList',
      layoutName: 'LayoutName',
      layoutType: 'LayoutType',
      mediaInputConfigList: 'MediaInputConfigList',
      ownerId: 'OwnerId',
      screenInputConfigList: 'ScreenInputConfigList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bgImageConfig: 'string',
      casterId: 'string',
      commonConfig: 'string',
      layerOrderConfigList: 'string',
      layoutName: 'string',
      layoutType: 'string',
      mediaInputConfigList: 'string',
      ownerId: 'number',
      screenInputConfigList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddStudioLayoutResponseBody extends $tea.Model {
  layoutId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      layoutId: 'LayoutId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      layoutId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddStudioLayoutResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddStudioLayoutResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddStudioLayoutResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTrancodeSEIRequest extends $tea.Model {
  appName?: string;
  delay?: number;
  domainName?: string;
  ownerId?: number;
  pattern?: string;
  repeat?: number;
  streamName?: string;
  text?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      delay: 'Delay',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      pattern: 'Pattern',
      repeat: 'Repeat',
      streamName: 'StreamName',
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      delay: 'number',
      domainName: 'string',
      ownerId: 'number',
      pattern: 'string',
      repeat: 'number',
      streamName: 'string',
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTrancodeSEIResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTrancodeSEIResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddTrancodeSEIResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddTrancodeSEIResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AllowPushStreamRequest extends $tea.Model {
  appId?: string;
  ownerId?: number;
  roomId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      ownerId: 'OwnerId',
      roomId: 'RoomId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      ownerId: 'number',
      roomId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AllowPushStreamResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AllowPushStreamResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AllowPushStreamResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AllowPushStreamResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteLiveDomainConfigsRequest extends $tea.Model {
  domainNames?: string;
  functionNames?: string;
  ownerAccount?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainNames: 'DomainNames',
      functionNames: 'FunctionNames',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainNames: 'string',
      functionNames: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteLiveDomainConfigsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteLiveDomainConfigsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchDeleteLiveDomainConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchDeleteLiveDomainConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetLiveDomainConfigsRequest extends $tea.Model {
  domainNames?: string;
  functions?: string;
  ownerAccount?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainNames: 'DomainNames',
      functions: 'Functions',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainNames: 'string',
      functions: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetLiveDomainConfigsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetLiveDomainConfigsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchSetLiveDomainConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchSetLiveDomainConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelMuteAllGroupUserRequest extends $tea.Model {
  appId?: string;
  groupId?: string;
  operatorUserId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      groupId: 'GroupId',
      operatorUserId: 'OperatorUserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      groupId: 'string',
      operatorUserId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelMuteAllGroupUserResponseBody extends $tea.Model {
  requestId?: string;
  result?: CancelMuteAllGroupUserResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: CancelMuteAllGroupUserResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelMuteAllGroupUserResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CancelMuteAllGroupUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CancelMuteAllGroupUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseLiveShiftRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  ownerId?: number;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      ownerId: 'number',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseLiveShiftResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseLiveShiftResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CloseLiveShiftResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CloseLiveShiftResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyCasterRequest extends $tea.Model {
  casterName?: string;
  clientToken?: string;
  ownerId?: number;
  srcCasterId?: string;
  static names(): { [key: string]: string } {
    return {
      casterName: 'CasterName',
      clientToken: 'ClientToken',
      ownerId: 'OwnerId',
      srcCasterId: 'SrcCasterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterName: 'string',
      clientToken: 'string',
      ownerId: 'number',
      srcCasterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyCasterResponseBody extends $tea.Model {
  casterId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyCasterResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CopyCasterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CopyCasterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyCasterSceneConfigRequest extends $tea.Model {
  casterId?: string;
  fromSceneId?: string;
  ownerId?: number;
  toSceneId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      fromSceneId: 'FromSceneId',
      ownerId: 'OwnerId',
      toSceneId: 'ToSceneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      fromSceneId: 'string',
      ownerId: 'number',
      toSceneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyCasterSceneConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyCasterSceneConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CopyCasterSceneConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CopyCasterSceneConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCasterRequest extends $tea.Model {
  casterName?: string;
  casterTemplate?: string;
  chargeType?: string;
  clientToken?: string;
  expireTime?: string;
  normType?: number;
  ownerId?: number;
  purchaseTime?: string;
  static names(): { [key: string]: string } {
    return {
      casterName: 'CasterName',
      casterTemplate: 'CasterTemplate',
      chargeType: 'ChargeType',
      clientToken: 'ClientToken',
      expireTime: 'ExpireTime',
      normType: 'NormType',
      ownerId: 'OwnerId',
      purchaseTime: 'PurchaseTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterName: 'string',
      casterTemplate: 'string',
      chargeType: 'string',
      clientToken: 'string',
      expireTime: 'string',
      normType: 'number',
      ownerId: 'number',
      purchaseTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCasterResponseBody extends $tea.Model {
  casterId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCasterResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateCasterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCasterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCustomTemplateRequest extends $tea.Model {
  customTemplate?: string;
  ownerId?: number;
  template?: string;
  static names(): { [key: string]: string } {
    return {
      customTemplate: 'CustomTemplate',
      ownerId: 'OwnerId',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customTemplate: 'string',
      ownerId: 'number',
      template: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCustomTemplateResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCustomTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateCustomTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCustomTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLiveRealTimeLogDeliveryRequest extends $tea.Model {
  domainName?: string;
  logstore?: string;
  ownerId?: number;
  project?: string;
  region?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      logstore: 'Logstore',
      ownerId: 'OwnerId',
      project: 'Project',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      logstore: 'string',
      ownerId: 'number',
      project: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLiveRealTimeLogDeliveryResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLiveRealTimeLogDeliveryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateLiveRealTimeLogDeliveryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateLiveRealTimeLogDeliveryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLiveStreamMonitorRequest extends $tea.Model {
  app?: string;
  domain?: string;
  inputList?: string;
  monitorName?: string;
  outputTemplate?: string;
  ownerId?: number;
  stream?: string;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      domain: 'Domain',
      inputList: 'InputList',
      monitorName: 'MonitorName',
      outputTemplate: 'OutputTemplate',
      ownerId: 'OwnerId',
      stream: 'Stream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      domain: 'string',
      inputList: 'string',
      monitorName: 'string',
      outputTemplate: 'string',
      ownerId: 'number',
      stream: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLiveStreamMonitorResponseBody extends $tea.Model {
  monitorId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      monitorId: 'MonitorId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLiveStreamMonitorResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateLiveStreamMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateLiveStreamMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLiveStreamRecordIndexFilesRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  endTime?: string;
  ossBucket?: string;
  ossEndpoint?: string;
  ossObject?: string;
  ownerId?: number;
  securityToken?: string;
  startTime?: string;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      endTime: 'EndTime',
      ossBucket: 'OssBucket',
      ossEndpoint: 'OssEndpoint',
      ossObject: 'OssObject',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
      startTime: 'StartTime',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      endTime: 'string',
      ossBucket: 'string',
      ossEndpoint: 'string',
      ossObject: 'string',
      ownerId: 'number',
      securityToken: 'string',
      startTime: 'string',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLiveStreamRecordIndexFilesResponseBody extends $tea.Model {
  recordInfo?: CreateLiveStreamRecordIndexFilesResponseBodyRecordInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recordInfo: 'RecordInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordInfo: CreateLiveStreamRecordIndexFilesResponseBodyRecordInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLiveStreamRecordIndexFilesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateLiveStreamRecordIndexFilesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateLiveStreamRecordIndexFilesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLiveTranscodeTemplateRequest extends $tea.Model {
  ownerId?: number;
  securityToken?: string;
  templateConfig?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
      templateConfig: 'TemplateConfig',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      securityToken: 'string',
      templateConfig: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLiveTranscodeTemplateResponseBody extends $tea.Model {
  requestId?: string;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLiveTranscodeTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateLiveTranscodeTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateLiveTranscodeTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMessageAppRequest extends $tea.Model {
  appConfig?: { [key: string]: string };
  appName?: string;
  extension?: { [key: string]: string };
  static names(): { [key: string]: string } {
    return {
      appConfig: 'AppConfig',
      appName: 'AppName',
      extension: 'Extension',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      appName: 'string',
      extension: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMessageAppShrinkRequest extends $tea.Model {
  appConfigShrink?: string;
  appName?: string;
  extensionShrink?: string;
  static names(): { [key: string]: string } {
    return {
      appConfigShrink: 'AppConfig',
      appName: 'AppName',
      extensionShrink: 'Extension',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appConfigShrink: 'string',
      appName: 'string',
      extensionShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMessageAppResponseBody extends $tea.Model {
  requestId?: string;
  result?: CreateMessageAppResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: CreateMessageAppResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMessageAppResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateMessageAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMessageAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMessageGroupRequest extends $tea.Model {
  appId?: string;
  creatorId?: string;
  extension?: { [key: string]: string };
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      creatorId: 'CreatorId',
      extension: 'Extension',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      creatorId: 'string',
      extension: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMessageGroupShrinkRequest extends $tea.Model {
  appId?: string;
  creatorId?: string;
  extensionShrink?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      creatorId: 'CreatorId',
      extensionShrink: 'Extension',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      creatorId: 'string',
      extensionShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMessageGroupResponseBody extends $tea.Model {
  requestId?: string;
  result?: CreateMessageGroupResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: CreateMessageGroupResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMessageGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateMessageGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMessageGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMixStreamRequest extends $tea.Model {
  callbackConfig?: string;
  domainName?: string;
  inputStreamList?: string;
  layoutId?: string;
  outputConfig?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      callbackConfig: 'CallbackConfig',
      domainName: 'DomainName',
      inputStreamList: 'InputStreamList',
      layoutId: 'LayoutId',
      outputConfig: 'OutputConfig',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      callbackConfig: 'string',
      domainName: 'string',
      inputStreamList: 'string',
      layoutId: 'string',
      outputConfig: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMixStreamResponseBody extends $tea.Model {
  mixStreamId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      mixStreamId: 'MixStreamId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mixStreamId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMixStreamResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateMixStreamResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMixStreamResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterResponseBody extends $tea.Model {
  casterId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteCasterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCasterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterComponentRequest extends $tea.Model {
  casterId?: string;
  componentId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      componentId: 'ComponentId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      componentId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterComponentResponseBody extends $tea.Model {
  casterId?: string;
  componentId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      componentId: 'ComponentId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      componentId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterComponentResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteCasterComponentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCasterComponentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterEpisodeRequest extends $tea.Model {
  casterId?: string;
  episodeId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      episodeId: 'EpisodeId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      episodeId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterEpisodeResponseBody extends $tea.Model {
  casterId?: string;
  episodeId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      episodeId: 'EpisodeId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      episodeId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterEpisodeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteCasterEpisodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCasterEpisodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterEpisodeGroupRequest extends $tea.Model {
  ownerId?: number;
  programId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      programId: 'ProgramId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      programId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterEpisodeGroupResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterEpisodeGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteCasterEpisodeGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCasterEpisodeGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterLayoutRequest extends $tea.Model {
  casterId?: string;
  layoutId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      layoutId: 'LayoutId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      layoutId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterLayoutResponseBody extends $tea.Model {
  casterId?: string;
  layoutId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      layoutId: 'LayoutId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      layoutId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterLayoutResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteCasterLayoutResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCasterLayoutResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterProgramRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterProgramResponseBody extends $tea.Model {
  casterId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterProgramResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteCasterProgramResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCasterProgramResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterSceneConfigRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  sceneId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
      sceneId: 'SceneId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
      sceneId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterSceneConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterSceneConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteCasterSceneConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCasterSceneConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterVideoResourceRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  resourceId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
      resourceId: 'ResourceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
      resourceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterVideoResourceResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCasterVideoResourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteCasterVideoResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCasterVideoResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCustomTemplateRequest extends $tea.Model {
  ownerId?: number;
  template?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      template: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCustomTemplateResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCustomTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteCustomTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCustomTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveAppRecordConfigRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveAppRecordConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveAppRecordConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveAppRecordConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveAppRecordConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveAppSnapshotConfigRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveAppSnapshotConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveAppSnapshotConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveAppSnapshotConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveAppSnapshotConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveAudioAuditConfigRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  ownerId?: number;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      ownerId: 'number',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveAudioAuditConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveAudioAuditConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveAudioAuditConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveAudioAuditConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveAudioAuditNotifyConfigRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveAudioAuditNotifyConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveAudioAuditNotifyConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveAudioAuditNotifyConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveAudioAuditNotifyConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveDetectNotifyConfigRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveDetectNotifyConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveDetectNotifyConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveDetectNotifyConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveDetectNotifyConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveDomainRequest extends $tea.Model {
  domainName?: string;
  ownerAccount?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveDomainResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveDomainResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveDomainMappingRequest extends $tea.Model {
  ownerId?: number;
  pullDomain?: string;
  pushDomain?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      pullDomain: 'PullDomain',
      pushDomain: 'PushDomain',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      pullDomain: 'string',
      pushDomain: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveDomainMappingResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveDomainMappingResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveDomainMappingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveDomainMappingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveDomainPlayMappingRequest extends $tea.Model {
  ownerId?: number;
  playDomain?: string;
  pullDomain?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      playDomain: 'PlayDomain',
      pullDomain: 'PullDomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      playDomain: 'string',
      pullDomain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveDomainPlayMappingResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveDomainPlayMappingResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveDomainPlayMappingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveDomainPlayMappingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveEdgeTransferRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveEdgeTransferResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveEdgeTransferResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveEdgeTransferResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveEdgeTransferResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveLazyPullStreamInfoConfigRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveLazyPullStreamInfoConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveLazyPullStreamInfoConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveLazyPullStreamInfoConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveLazyPullStreamInfoConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLivePullStreamInfoConfigRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  ownerId?: number;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      ownerId: 'number',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLivePullStreamInfoConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLivePullStreamInfoConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLivePullStreamInfoConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLivePullStreamInfoConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveRealTimeLogLogstoreRequest extends $tea.Model {
  logstore?: string;
  ownerId?: number;
  project?: string;
  region?: string;
  static names(): { [key: string]: string } {
    return {
      logstore: 'Logstore',
      ownerId: 'OwnerId',
      project: 'Project',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logstore: 'string',
      ownerId: 'number',
      project: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveRealTimeLogLogstoreResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveRealTimeLogLogstoreResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveRealTimeLogLogstoreResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveRealTimeLogLogstoreResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveRealtimeLogDeliveryRequest extends $tea.Model {
  domainName?: string;
  logstore?: string;
  ownerId?: number;
  project?: string;
  region?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      logstore: 'Logstore',
      ownerId: 'OwnerId',
      project: 'Project',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      logstore: 'string',
      ownerId: 'number',
      project: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveRealtimeLogDeliveryResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveRealtimeLogDeliveryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveRealtimeLogDeliveryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveRealtimeLogDeliveryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveRecordNotifyConfigRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveRecordNotifyConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveRecordNotifyConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveRecordNotifyConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveRecordNotifyConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveRecordVodConfigRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  ownerId?: number;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      ownerId: 'number',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveRecordVodConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveRecordVodConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveRecordVodConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveRecordVodConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveSnapshotDetectPornConfigRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveSnapshotDetectPornConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveSnapshotDetectPornConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveSnapshotDetectPornConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveSnapshotDetectPornConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveSnapshotNotifyConfigRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveSnapshotNotifyConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveSnapshotNotifyConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveSnapshotNotifyConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveSnapshotNotifyConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveSpecificStagingConfigRequest extends $tea.Model {
  configId?: string;
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveSpecificStagingConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveSpecificStagingConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveSpecificStagingConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveSpecificStagingConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveStreamMonitorRequest extends $tea.Model {
  monitorId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      monitorId: 'MonitorId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveStreamMonitorResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveStreamMonitorResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveStreamMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveStreamMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveStreamRecordIndexFilesRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  ownerId?: number;
  recordId?: string[];
  removeFile?: string;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      recordId: 'RecordId',
      removeFile: 'RemoveFile',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      ownerId: 'number',
      recordId: { 'type': 'array', 'itemType': 'string' },
      removeFile: 'string',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveStreamRecordIndexFilesResponseBody extends $tea.Model {
  code?: string;
  message?: string;
  recordDeleteInfoList?: DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      recordDeleteInfoList: 'RecordDeleteInfoList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      recordDeleteInfoList: DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveStreamRecordIndexFilesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveStreamRecordIndexFilesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveStreamRecordIndexFilesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveStreamTranscodeRequest extends $tea.Model {
  app?: string;
  domain?: string;
  ownerId?: number;
  securityToken?: string;
  template?: string;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      domain: 'Domain',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      domain: 'string',
      ownerId: 'number',
      securityToken: 'string',
      template: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveStreamTranscodeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveStreamTranscodeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveStreamTranscodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveStreamTranscodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveStreamWatermarkRequest extends $tea.Model {
  ownerId?: number;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveStreamWatermarkResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveStreamWatermarkResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveStreamWatermarkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveStreamWatermarkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveStreamWatermarkRuleRequest extends $tea.Model {
  app?: string;
  domain?: string;
  ownerId?: number;
  ruleId?: string;
  stream?: string;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      domain: 'Domain',
      ownerId: 'OwnerId',
      ruleId: 'RuleId',
      stream: 'Stream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      domain: 'string',
      ownerId: 'number',
      ruleId: 'string',
      stream: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveStreamWatermarkRuleResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveStreamWatermarkRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveStreamWatermarkRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveStreamWatermarkRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveStreamsNotifyUrlConfigRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveStreamsNotifyUrlConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveStreamsNotifyUrlConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLiveStreamsNotifyUrlConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveStreamsNotifyUrlConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMessageAppRequest extends $tea.Model {
  appId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMessageAppResponseBody extends $tea.Model {
  requestId?: string;
  result?: DeleteMessageAppResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DeleteMessageAppResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMessageAppResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteMessageAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMessageAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMixStreamRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  mixStreamId?: string;
  ownerId?: number;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      mixStreamId: 'MixStreamId',
      ownerId: 'OwnerId',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      mixStreamId: 'string',
      ownerId: 'number',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMixStreamResponseBody extends $tea.Model {
  mixStreamId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      mixStreamId: 'MixStreamId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mixStreamId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMixStreamResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteMixStreamResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMixStreamResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMultiRateConfigRequest extends $tea.Model {
  app?: string;
  deleteAll?: string;
  domainName?: string;
  groupId?: string;
  ownerId?: number;
  templates?: string;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      deleteAll: 'DeleteAll',
      domainName: 'DomainName',
      groupId: 'GroupId',
      ownerId: 'OwnerId',
      templates: 'Templates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      deleteAll: 'string',
      domainName: 'string',
      groupId: 'string',
      ownerId: 'number',
      templates: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMultiRateConfigResponseBody extends $tea.Model {
  code?: number;
  message?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMultiRateConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteMultiRateConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMultiRateConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePlaylistRequest extends $tea.Model {
  ownerId?: number;
  programId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      programId: 'ProgramId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      programId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePlaylistResponseBody extends $tea.Model {
  programId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      programId: 'ProgramId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      programId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePlaylistResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeletePlaylistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeletePlaylistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePlaylistItemsRequest extends $tea.Model {
  ownerId?: number;
  programId?: string;
  programItemIds?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      programId: 'ProgramId',
      programItemIds: 'ProgramItemIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      programId: 'string',
      programItemIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePlaylistItemsResponseBody extends $tea.Model {
  programId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      programId: 'ProgramId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      programId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePlaylistItemsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeletePlaylistItemsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeletePlaylistItemsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoomRequest extends $tea.Model {
  appId?: string;
  ownerId?: number;
  roomId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      ownerId: 'OwnerId',
      roomId: 'RoomId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      ownerId: 'number',
      roomId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoomResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoomResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteRoomResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRoomResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSnapshotCallbackAuthRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSnapshotCallbackAuthResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSnapshotCallbackAuthResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteSnapshotCallbackAuthResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSnapshotCallbackAuthResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSnapshotFilesRequest extends $tea.Model {
  appName?: string;
  createTimestampList?: number[];
  domainName?: string;
  ownerId?: number;
  removeFile?: boolean;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      createTimestampList: 'CreateTimestampList',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      removeFile: 'RemoveFile',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      createTimestampList: { 'type': 'array', 'itemType': 'number' },
      domainName: 'string',
      ownerId: 'number',
      removeFile: 'boolean',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSnapshotFilesResponseBody extends $tea.Model {
  failureCount?: number;
  requestId?: string;
  snapshotDeleteInfoList?: DeleteSnapshotFilesResponseBodySnapshotDeleteInfoList;
  successCount?: number;
  static names(): { [key: string]: string } {
    return {
      failureCount: 'FailureCount',
      requestId: 'RequestId',
      snapshotDeleteInfoList: 'SnapshotDeleteInfoList',
      successCount: 'SuccessCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failureCount: 'number',
      requestId: 'string',
      snapshotDeleteInfoList: DeleteSnapshotFilesResponseBodySnapshotDeleteInfoList,
      successCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSnapshotFilesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteSnapshotFilesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSnapshotFilesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStudioLayoutRequest extends $tea.Model {
  casterId?: string;
  layoutId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      layoutId: 'LayoutId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      layoutId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStudioLayoutResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStudioLayoutResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteStudioLayoutResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteStudioLayoutResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoShowListTasksRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoShowListTasksResponseBody extends $tea.Model {
  autoShowListTasks?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      autoShowListTasks: 'AutoShowListTasks',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoShowListTasks: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoShowListTasksResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAutoShowListTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAutoShowListTasksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterChannelsRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterChannelsResponseBody extends $tea.Model {
  channels?: DescribeCasterChannelsResponseBodyChannels;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      channels: 'Channels',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channels: DescribeCasterChannelsResponseBodyChannels,
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterChannelsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCasterChannelsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCasterChannelsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterComponentsRequest extends $tea.Model {
  casterId?: string;
  componentId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      componentId: 'ComponentId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      componentId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterComponentsResponseBody extends $tea.Model {
  components?: DescribeCasterComponentsResponseBodyComponents;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      components: 'Components',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      components: DescribeCasterComponentsResponseBodyComponents,
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterComponentsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCasterComponentsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCasterComponentsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterConfigRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterConfigResponseBody extends $tea.Model {
  callbackUrl?: string;
  casterId?: string;
  casterName?: string;
  channelEnable?: number;
  delay?: number;
  domainName?: string;
  programEffect?: number;
  programName?: string;
  recordConfig?: DescribeCasterConfigResponseBodyRecordConfig;
  requestId?: string;
  sideOutputUrl?: string;
  sideOutputUrlList?: string;
  syncGroupsConfig?: DescribeCasterConfigResponseBodySyncGroupsConfig;
  transcodeConfig?: DescribeCasterConfigResponseBodyTranscodeConfig;
  urgentLiveStreamUrl?: string;
  urgentMaterialId?: string;
  static names(): { [key: string]: string } {
    return {
      callbackUrl: 'CallbackUrl',
      casterId: 'CasterId',
      casterName: 'CasterName',
      channelEnable: 'ChannelEnable',
      delay: 'Delay',
      domainName: 'DomainName',
      programEffect: 'ProgramEffect',
      programName: 'ProgramName',
      recordConfig: 'RecordConfig',
      requestId: 'RequestId',
      sideOutputUrl: 'SideOutputUrl',
      sideOutputUrlList: 'SideOutputUrlList',
      syncGroupsConfig: 'SyncGroupsConfig',
      transcodeConfig: 'TranscodeConfig',
      urgentLiveStreamUrl: 'UrgentLiveStreamUrl',
      urgentMaterialId: 'UrgentMaterialId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      callbackUrl: 'string',
      casterId: 'string',
      casterName: 'string',
      channelEnable: 'number',
      delay: 'number',
      domainName: 'string',
      programEffect: 'number',
      programName: 'string',
      recordConfig: DescribeCasterConfigResponseBodyRecordConfig,
      requestId: 'string',
      sideOutputUrl: 'string',
      sideOutputUrlList: 'string',
      syncGroupsConfig: DescribeCasterConfigResponseBodySyncGroupsConfig,
      transcodeConfig: DescribeCasterConfigResponseBodyTranscodeConfig,
      urgentLiveStreamUrl: 'string',
      urgentMaterialId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCasterConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCasterConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterLayoutsRequest extends $tea.Model {
  casterId?: string;
  layoutId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      layoutId: 'LayoutId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      layoutId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterLayoutsResponseBody extends $tea.Model {
  layouts?: DescribeCasterLayoutsResponseBodyLayouts;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      layouts: 'Layouts',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      layouts: DescribeCasterLayoutsResponseBodyLayouts,
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterLayoutsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCasterLayoutsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCasterLayoutsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterProgramRequest extends $tea.Model {
  casterId?: string;
  endTime?: string;
  episodeId?: string;
  episodeType?: string;
  ownerId?: number;
  pageNum?: number;
  pageSize?: number;
  startTime?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      endTime: 'EndTime',
      episodeId: 'EpisodeId',
      episodeType: 'EpisodeType',
      ownerId: 'OwnerId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      endTime: 'string',
      episodeId: 'string',
      episodeType: 'string',
      ownerId: 'number',
      pageNum: 'number',
      pageSize: 'number',
      startTime: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterProgramResponseBody extends $tea.Model {
  casterId?: string;
  episodes?: DescribeCasterProgramResponseBodyEpisodes;
  programEffect?: number;
  programName?: string;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      episodes: 'Episodes',
      programEffect: 'ProgramEffect',
      programName: 'ProgramName',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      episodes: DescribeCasterProgramResponseBodyEpisodes,
      programEffect: 'number',
      programName: 'string',
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterProgramResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCasterProgramResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCasterProgramResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterSceneAudioRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  sceneId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
      sceneId: 'SceneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
      sceneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterSceneAudioResponseBody extends $tea.Model {
  audioLayers?: DescribeCasterSceneAudioResponseBodyAudioLayers;
  casterId?: string;
  followEnable?: number;
  mixList?: DescribeCasterSceneAudioResponseBodyMixList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      audioLayers: 'AudioLayers',
      casterId: 'CasterId',
      followEnable: 'FollowEnable',
      mixList: 'MixList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioLayers: DescribeCasterSceneAudioResponseBodyAudioLayers,
      casterId: 'string',
      followEnable: 'number',
      mixList: DescribeCasterSceneAudioResponseBodyMixList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterSceneAudioResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCasterSceneAudioResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCasterSceneAudioResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterScenesRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  sceneId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
      sceneId: 'SceneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
      sceneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterScenesResponseBody extends $tea.Model {
  requestId?: string;
  sceneList?: DescribeCasterScenesResponseBodySceneList;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      sceneList: 'SceneList',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      sceneList: DescribeCasterScenesResponseBodySceneList,
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterScenesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCasterScenesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCasterScenesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterStreamUrlRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterStreamUrlResponseBody extends $tea.Model {
  casterId?: string;
  casterStreams?: DescribeCasterStreamUrlResponseBodyCasterStreams;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      casterStreams: 'CasterStreams',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      casterStreams: DescribeCasterStreamUrlResponseBodyCasterStreams,
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterStreamUrlResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCasterStreamUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCasterStreamUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterSyncGroupRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterSyncGroupResponseBody extends $tea.Model {
  casterId?: string;
  requestId?: string;
  syncGroups?: DescribeCasterSyncGroupResponseBodySyncGroups;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      requestId: 'RequestId',
      syncGroups: 'SyncGroups',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      requestId: 'string',
      syncGroups: DescribeCasterSyncGroupResponseBodySyncGroups,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterSyncGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCasterSyncGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCasterSyncGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterVideoResourcesRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterVideoResourcesResponseBody extends $tea.Model {
  requestId?: string;
  total?: number;
  videoResources?: DescribeCasterVideoResourcesResponseBodyVideoResources;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      total: 'Total',
      videoResources: 'VideoResources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      total: 'number',
      videoResources: DescribeCasterVideoResourcesResponseBodyVideoResources,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterVideoResourcesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCasterVideoResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCasterVideoResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCastersRequest extends $tea.Model {
  casterId?: string;
  casterName?: string;
  chargeType?: number;
  endTime?: string;
  normType?: string;
  orderByModifyAsc?: string;
  ownerId?: number;
  pageNum?: number;
  pageSize?: number;
  startTime?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      casterName: 'CasterName',
      chargeType: 'ChargeType',
      endTime: 'EndTime',
      normType: 'NormType',
      orderByModifyAsc: 'OrderByModifyAsc',
      ownerId: 'OwnerId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      casterName: 'string',
      chargeType: 'number',
      endTime: 'string',
      normType: 'string',
      orderByModifyAsc: 'string',
      ownerId: 'number',
      pageNum: 'number',
      pageSize: 'number',
      startTime: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCastersResponseBody extends $tea.Model {
  casterList?: DescribeCastersResponseBodyCasterList;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      casterList: 'CasterList',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterList: DescribeCastersResponseBodyCasterList,
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCastersResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCastersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCastersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainUsageDataRequest extends $tea.Model {
  area?: string;
  dataProtocol?: string;
  domainName?: string;
  endTime?: string;
  field?: string;
  interval?: string;
  ownerId?: number;
  startTime?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      area: 'Area',
      dataProtocol: 'DataProtocol',
      domainName: 'DomainName',
      endTime: 'EndTime',
      field: 'Field',
      interval: 'Interval',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      area: 'string',
      dataProtocol: 'string',
      domainName: 'string',
      endTime: 'string',
      field: 'string',
      interval: 'string',
      ownerId: 'number',
      startTime: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainUsageDataResponseBody extends $tea.Model {
  area?: string;
  dataInterval?: string;
  domainName?: string;
  endTime?: string;
  requestId?: string;
  startTime?: string;
  type?: string;
  usageDataPerInterval?: DescribeDomainUsageDataResponseBodyUsageDataPerInterval;
  static names(): { [key: string]: string } {
    return {
      area: 'Area',
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
      type: 'Type',
      usageDataPerInterval: 'UsageDataPerInterval',
    };
  }

  static types(): { [key: string]: any } {
    return {
      area: 'string',
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
      type: 'string',
      usageDataPerInterval: DescribeDomainUsageDataResponseBodyUsageDataPerInterval,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainUsageDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeDomainUsageDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainUsageDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainWithIntegrityRequest extends $tea.Model {
  endTime?: string;
  integrity?: number;
  ownerId?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      integrity: 'Integrity',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      integrity: 'number',
      ownerId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainWithIntegrityResponseBody extends $tea.Model {
  content?: DescribeDomainWithIntegrityResponseBodyContent[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'array', 'itemType': DescribeDomainWithIntegrityResponseBodyContent },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainWithIntegrityResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeDomainWithIntegrityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainWithIntegrityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeForbidPushStreamRoomListRequest extends $tea.Model {
  appId?: string;
  order?: string;
  ownerId?: number;
  pageNum?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      order: 'Order',
      ownerId: 'OwnerId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      order: 'string',
      ownerId: 'number',
      pageNum: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeForbidPushStreamRoomListResponseBody extends $tea.Model {
  requestId?: string;
  roomList?: DescribeForbidPushStreamRoomListResponseBodyRoomList[];
  totalNum?: number;
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      roomList: 'RoomList',
      totalNum: 'TotalNum',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      roomList: { 'type': 'array', 'itemType': DescribeForbidPushStreamRoomListResponseBodyRoomList },
      totalNum: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeForbidPushStreamRoomListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeForbidPushStreamRoomListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeForbidPushStreamRoomListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHlsLiveStreamRealTimeBpsDataRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  time?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHlsLiveStreamRealTimeBpsDataResponseBody extends $tea.Model {
  requestId?: string;
  time?: string;
  usageData?: DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      time: 'Time',
      usageData: 'UsageData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      time: 'string',
      usageData: { 'type': 'array', 'itemType': DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHlsLiveStreamRealTimeBpsDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeHlsLiveStreamRealTimeBpsDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeHlsLiveStreamRealTimeBpsDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveAudioAuditConfigRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  ownerId?: number;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      ownerId: 'number',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveAudioAuditConfigResponseBody extends $tea.Model {
  liveAudioAuditConfigList?: DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      liveAudioAuditConfigList: 'LiveAudioAuditConfigList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveAudioAuditConfigList: DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveAudioAuditConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveAudioAuditConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveAudioAuditConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveAudioAuditNotifyConfigRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveAudioAuditNotifyConfigResponseBody extends $tea.Model {
  liveAudioAuditNotifyConfigList?: DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      liveAudioAuditNotifyConfigList: 'LiveAudioAuditNotifyConfigList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveAudioAuditNotifyConfigList: DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveAudioAuditNotifyConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveAudioAuditNotifyConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveAudioAuditNotifyConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveCertificateDetailRequest extends $tea.Model {
  certName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      certName: 'CertName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveCertificateDetailResponseBody extends $tea.Model {
  cert?: string;
  certId?: number;
  certName?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      cert: 'Cert',
      certId: 'CertId',
      certName: 'CertName',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cert: 'string',
      certId: 'number',
      certName: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveCertificateDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveCertificateDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveCertificateDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveCertificateListRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveCertificateListResponseBody extends $tea.Model {
  certificateListModel?: DescribeLiveCertificateListResponseBodyCertificateListModel;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      certificateListModel: 'CertificateListModel',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certificateListModel: DescribeLiveCertificateListResponseBodyCertificateListModel,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveCertificateListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveCertificateListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveCertificateListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDetectNotifyConfigRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDetectNotifyConfigResponseBody extends $tea.Model {
  liveDetectNotifyConfig?: DescribeLiveDetectNotifyConfigResponseBodyLiveDetectNotifyConfig;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      liveDetectNotifyConfig: 'LiveDetectNotifyConfig',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveDetectNotifyConfig: DescribeLiveDetectNotifyConfigResponseBodyLiveDetectNotifyConfig,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDetectNotifyConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDetectNotifyConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDetectNotifyConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDetectPornDataRequest extends $tea.Model {
  app?: string;
  domainName?: string;
  endTime?: string;
  fee?: string;
  ownerId?: number;
  region?: string;
  scene?: string;
  splitBy?: string;
  startTime?: string;
  stream?: string;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      domainName: 'DomainName',
      endTime: 'EndTime',
      fee: 'Fee',
      ownerId: 'OwnerId',
      region: 'Region',
      scene: 'Scene',
      splitBy: 'SplitBy',
      startTime: 'StartTime',
      stream: 'Stream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      domainName: 'string',
      endTime: 'string',
      fee: 'string',
      ownerId: 'number',
      region: 'string',
      scene: 'string',
      splitBy: 'string',
      startTime: 'string',
      stream: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDetectPornDataResponseBody extends $tea.Model {
  detectPornData?: DescribeLiveDetectPornDataResponseBodyDetectPornData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      detectPornData: 'DetectPornData',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      detectPornData: DescribeLiveDetectPornDataResponseBodyDetectPornData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDetectPornDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDetectPornDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDetectPornDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainBpsDataRequest extends $tea.Model {
  domainName?: string;
  endTime?: string;
  interval?: string;
  ispNameEn?: string;
  locationNameEn?: string;
  ownerId?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      ispNameEn: 'IspNameEn',
      locationNameEn: 'LocationNameEn',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      ispNameEn: 'string',
      locationNameEn: 'string',
      ownerId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainBpsDataResponseBody extends $tea.Model {
  bpsDataPerInterval?: DescribeLiveDomainBpsDataResponseBodyBpsDataPerInterval;
  dataInterval?: string;
  domainName?: string;
  endTime?: string;
  requestId?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      bpsDataPerInterval: 'BpsDataPerInterval',
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bpsDataPerInterval: DescribeLiveDomainBpsDataResponseBodyBpsDataPerInterval,
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainBpsDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainBpsDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainBpsDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainBpsDataByLayerRequest extends $tea.Model {
  domainName?: string;
  endTime?: string;
  interval?: string;
  ispNameEn?: string;
  layer?: string;
  locationNameEn?: string;
  ownerId?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      ispNameEn: 'IspNameEn',
      layer: 'Layer',
      locationNameEn: 'LocationNameEn',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      ispNameEn: 'string',
      layer: 'string',
      locationNameEn: 'string',
      ownerId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainBpsDataByLayerResponseBody extends $tea.Model {
  bpsDataInterval?: DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataInterval;
  dataInterval?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      bpsDataInterval: 'BpsDataInterval',
      dataInterval: 'DataInterval',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bpsDataInterval: DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataInterval,
      dataInterval: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainBpsDataByLayerResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainBpsDataByLayerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainBpsDataByLayerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainBpsDataByTimeStampRequest extends $tea.Model {
  domainName?: string;
  ispNames?: string;
  locationNames?: string;
  ownerId?: number;
  timePoint?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ispNames: 'IspNames',
      locationNames: 'LocationNames',
      ownerId: 'OwnerId',
      timePoint: 'TimePoint',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ispNames: 'string',
      locationNames: 'string',
      ownerId: 'number',
      timePoint: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainBpsDataByTimeStampResponseBody extends $tea.Model {
  bpsDataList?: DescribeLiveDomainBpsDataByTimeStampResponseBodyBpsDataList;
  domainName?: string;
  requestId?: string;
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      bpsDataList: 'BpsDataList',
      domainName: 'DomainName',
      requestId: 'RequestId',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bpsDataList: DescribeLiveDomainBpsDataByTimeStampResponseBodyBpsDataList,
      domainName: 'string',
      requestId: 'string',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainBpsDataByTimeStampResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainBpsDataByTimeStampResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainBpsDataByTimeStampResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainCertificateInfoRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainCertificateInfoResponseBody extends $tea.Model {
  certInfos?: DescribeLiveDomainCertificateInfoResponseBodyCertInfos;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      certInfos: 'CertInfos',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certInfos: DescribeLiveDomainCertificateInfoResponseBodyCertInfos,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainCertificateInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainCertificateInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainCertificateInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainConfigsRequest extends $tea.Model {
  domainName?: string;
  functionNames?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      functionNames: 'FunctionNames',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      functionNames: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainConfigsResponseBody extends $tea.Model {
  domainConfigs?: DescribeLiveDomainConfigsResponseBodyDomainConfigs;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainConfigs: 'DomainConfigs',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainConfigs: DescribeLiveDomainConfigsResponseBodyDomainConfigs,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainConfigsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainDetailRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainDetailResponseBody extends $tea.Model {
  domainDetail?: DescribeLiveDomainDetailResponseBodyDomainDetail;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainDetail: 'DomainDetail',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainDetail: DescribeLiveDomainDetailResponseBodyDomainDetail,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainFrameRateAndBitRateDataRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  queryTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      queryTime: 'QueryTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      queryTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainFrameRateAndBitRateDataResponseBody extends $tea.Model {
  frameRateAndBitRateInfos?: DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      frameRateAndBitRateInfos: 'FrameRateAndBitRateInfos',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      frameRateAndBitRateInfos: DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainFrameRateAndBitRateDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainFrameRateAndBitRateDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainFrameRateAndBitRateDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainLimitRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainLimitResponseBody extends $tea.Model {
  liveDomainLimitList?: DescribeLiveDomainLimitResponseBodyLiveDomainLimitList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      liveDomainLimitList: 'LiveDomainLimitList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveDomainLimitList: DescribeLiveDomainLimitResponseBodyLiveDomainLimitList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainLimitResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainLimitResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainLimitResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainLogRequest extends $tea.Model {
  domainName?: string;
  endTime?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainLogResponseBody extends $tea.Model {
  domainLogDetails?: DescribeLiveDomainLogResponseBodyDomainLogDetails;
  domainName?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainLogDetails: 'DomainLogDetails',
      domainName: 'DomainName',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainLogDetails: DescribeLiveDomainLogResponseBodyDomainLogDetails,
      domainName: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainLogResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainMappingRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainMappingResponseBody extends $tea.Model {
  liveDomainModels?: DescribeLiveDomainMappingResponseBodyLiveDomainModels;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      liveDomainModels: 'LiveDomainModels',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveDomainModels: DescribeLiveDomainMappingResponseBodyLiveDomainModels,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainMappingResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainMappingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainMappingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainOnlineUserNumRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  queryTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      queryTime: 'QueryTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      queryTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainOnlineUserNumResponseBody extends $tea.Model {
  onlineUserInfo?: DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfo;
  requestId?: string;
  streamCount?: number;
  userCount?: number;
  static names(): { [key: string]: string } {
    return {
      onlineUserInfo: 'OnlineUserInfo',
      requestId: 'RequestId',
      streamCount: 'StreamCount',
      userCount: 'UserCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      onlineUserInfo: DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfo,
      requestId: 'string',
      streamCount: 'number',
      userCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainOnlineUserNumResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainOnlineUserNumResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainOnlineUserNumResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainPushBpsDataRequest extends $tea.Model {
  domainName?: string;
  endTime?: string;
  interval?: string;
  ispNameEn?: string;
  locationNameEn?: string;
  ownerId?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      ispNameEn: 'IspNameEn',
      locationNameEn: 'LocationNameEn',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      ispNameEn: 'string',
      locationNameEn: 'string',
      ownerId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainPushBpsDataResponseBody extends $tea.Model {
  bpsDataPerInterval?: DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerInterval;
  dataInterval?: string;
  domainName?: string;
  endTime?: string;
  requestId?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      bpsDataPerInterval: 'BpsDataPerInterval',
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bpsDataPerInterval: DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerInterval,
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainPushBpsDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainPushBpsDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainPushBpsDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainPushTrafficDataRequest extends $tea.Model {
  domainName?: string;
  endTime?: string;
  interval?: string;
  ispNameEn?: string;
  locationNameEn?: string;
  ownerId?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      ispNameEn: 'IspNameEn',
      locationNameEn: 'LocationNameEn',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      ispNameEn: 'string',
      locationNameEn: 'string',
      ownerId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainPushTrafficDataResponseBody extends $tea.Model {
  dataInterval?: string;
  domainName?: string;
  endTime?: string;
  requestId?: string;
  startTime?: string;
  trafficDataPerInterval?: DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerInterval;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
      trafficDataPerInterval: 'TrafficDataPerInterval',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
      trafficDataPerInterval: DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerInterval,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainPushTrafficDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainPushTrafficDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainPushTrafficDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainPvUvDataRequest extends $tea.Model {
  domainName?: string;
  endTime?: string;
  ownerId?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      ownerId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainPvUvDataResponseBody extends $tea.Model {
  dataInterval?: string;
  domainName?: string;
  endTime?: string;
  pvUvDataInfos?: DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfos;
  requestId?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      pvUvDataInfos: 'PvUvDataInfos',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      pvUvDataInfos: DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfos,
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainPvUvDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainPvUvDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainPvUvDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRealTimeBpsDataRequest extends $tea.Model {
  domainName?: string;
  endTime?: string;
  ispNameEn?: string;
  locationNameEn?: string;
  ownerId?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      ispNameEn: 'IspNameEn',
      locationNameEn: 'LocationNameEn',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      ispNameEn: 'string',
      locationNameEn: 'string',
      ownerId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRealTimeBpsDataResponseBody extends $tea.Model {
  dataInterval?: string;
  domainName?: string;
  endTime?: string;
  realTimeBpsDataPerInterval?: DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerInterval;
  requestId?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      realTimeBpsDataPerInterval: 'RealTimeBpsDataPerInterval',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      realTimeBpsDataPerInterval: DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerInterval,
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRealTimeBpsDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainRealTimeBpsDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainRealTimeBpsDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRealTimeHttpCodeDataRequest extends $tea.Model {
  domainName?: string;
  endTime?: string;
  ispNameEn?: string;
  locationNameEn?: string;
  ownerId?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      ispNameEn: 'IspNameEn',
      locationNameEn: 'LocationNameEn',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      ispNameEn: 'string',
      locationNameEn: 'string',
      ownerId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRealTimeHttpCodeDataResponseBody extends $tea.Model {
  dataInterval?: string;
  domainName?: string;
  endTime?: string;
  realTimeHttpCodeData?: DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData;
  requestId?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      realTimeHttpCodeData: 'RealTimeHttpCodeData',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      realTimeHttpCodeData: DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData,
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRealTimeHttpCodeDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainRealTimeHttpCodeDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainRealTimeHttpCodeDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRealTimeTrafficDataRequest extends $tea.Model {
  domainName?: string;
  endTime?: string;
  ispNameEn?: string;
  locationNameEn?: string;
  ownerId?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      ispNameEn: 'IspNameEn',
      locationNameEn: 'LocationNameEn',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      ispNameEn: 'string',
      locationNameEn: 'string',
      ownerId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRealTimeTrafficDataResponseBody extends $tea.Model {
  dataInterval?: string;
  domainName?: string;
  endTime?: string;
  realTimeTrafficDataPerInterval?: DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval;
  requestId?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      realTimeTrafficDataPerInterval: 'RealTimeTrafficDataPerInterval',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      realTimeTrafficDataPerInterval: DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval,
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRealTimeTrafficDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainRealTimeTrafficDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainRealTimeTrafficDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRealtimeLogDeliveryRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRealtimeLogDeliveryResponseBody extends $tea.Model {
  logstore?: string;
  project?: string;
  region?: string;
  requestId?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      logstore: 'Logstore',
      project: 'Project',
      region: 'Region',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logstore: 'string',
      project: 'string',
      region: 'string',
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRealtimeLogDeliveryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainRealtimeLogDeliveryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainRealtimeLogDeliveryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRecordDataRequest extends $tea.Model {
  domainName?: string;
  endTime?: string;
  ownerId?: number;
  recordType?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      ownerId: 'OwnerId',
      recordType: 'RecordType',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      ownerId: 'number',
      recordType: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRecordDataResponseBody extends $tea.Model {
  recordDataInfos?: DescribeLiveDomainRecordDataResponseBodyRecordDataInfos;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recordDataInfos: 'RecordDataInfos',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordDataInfos: DescribeLiveDomainRecordDataResponseBodyRecordDataInfos,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRecordDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainRecordDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainRecordDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRecordUsageDataRequest extends $tea.Model {
  domainName?: string;
  endTime?: string;
  ownerId?: number;
  splitBy?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      ownerId: 'OwnerId',
      splitBy: 'SplitBy',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      ownerId: 'number',
      splitBy: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRecordUsageDataResponseBody extends $tea.Model {
  recordUsageData?: DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recordUsageData: 'RecordUsageData',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordUsageData: DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRecordUsageDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainRecordUsageDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainRecordUsageDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainSnapshotDataRequest extends $tea.Model {
  domainName?: string;
  endTime?: string;
  ownerId?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      ownerId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainSnapshotDataResponseBody extends $tea.Model {
  requestId?: string;
  snapshotDataInfos?: DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfos;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      snapshotDataInfos: 'SnapshotDataInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      snapshotDataInfos: DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfos,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainSnapshotDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainSnapshotDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainSnapshotDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainStagingConfigRequest extends $tea.Model {
  domainName?: string;
  functionNames?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      functionNames: 'FunctionNames',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      functionNames: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainStagingConfigResponseBody extends $tea.Model {
  domainConfigs?: DescribeLiveDomainStagingConfigResponseBodyDomainConfigs[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainConfigs: 'DomainConfigs',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainConfigs: { 'type': 'array', 'itemType': DescribeLiveDomainStagingConfigResponseBodyDomainConfigs },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainStagingConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainStagingConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainStagingConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainStreamTranscodeDataRequest extends $tea.Model {
  domainName?: string;
  endTime?: string;
  interval?: string;
  ownerId?: number;
  split?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      ownerId: 'OwnerId',
      split: 'Split',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      ownerId: 'number',
      split: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainStreamTranscodeDataResponseBody extends $tea.Model {
  requestId?: string;
  transcodeDataList?: DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      transcodeDataList: 'TranscodeDataList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      transcodeDataList: DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainStreamTranscodeDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainStreamTranscodeDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainStreamTranscodeDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainTimeShiftDataRequest extends $tea.Model {
  domainName?: string;
  endTime?: string;
  interval?: string;
  ownerId?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      ownerId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainTimeShiftDataResponseBody extends $tea.Model {
  requestId?: string;
  timeShiftData?: DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftData;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      timeShiftData: 'TimeShiftData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      timeShiftData: DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainTimeShiftDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainTimeShiftDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainTimeShiftDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainTrafficDataRequest extends $tea.Model {
  domainName?: string;
  endTime?: string;
  interval?: string;
  ispNameEn?: string;
  locationNameEn?: string;
  ownerId?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      ispNameEn: 'IspNameEn',
      locationNameEn: 'LocationNameEn',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      ispNameEn: 'string',
      locationNameEn: 'string',
      ownerId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainTrafficDataResponseBody extends $tea.Model {
  dataInterval?: string;
  domainName?: string;
  endTime?: string;
  requestId?: string;
  startTime?: string;
  trafficDataPerInterval?: DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerInterval;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
      trafficDataPerInterval: 'TrafficDataPerInterval',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
      trafficDataPerInterval: DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerInterval,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainTrafficDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainTrafficDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainTrafficDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainTranscodeDataRequest extends $tea.Model {
  domainName?: string;
  endTime?: string;
  ownerId?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      ownerId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainTranscodeDataResponseBody extends $tea.Model {
  requestId?: string;
  transcodeDataInfos?: DescribeLiveDomainTranscodeDataResponseBodyTranscodeDataInfos;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      transcodeDataInfos: 'TranscodeDataInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      transcodeDataInfos: DescribeLiveDomainTranscodeDataResponseBodyTranscodeDataInfos,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainTranscodeDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDomainTranscodeDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDomainTranscodeDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDrmUsageDataRequest extends $tea.Model {
  domainName?: string;
  endTime?: string;
  interval?: string;
  ownerId?: number;
  splitBy?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      ownerId: 'OwnerId',
      splitBy: 'SplitBy',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      ownerId: 'number',
      splitBy: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDrmUsageDataResponseBody extends $tea.Model {
  drmUsageData?: DescribeLiveDrmUsageDataResponseBodyDrmUsageData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      drmUsageData: 'DrmUsageData',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      drmUsageData: DescribeLiveDrmUsageDataResponseBodyDrmUsageData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDrmUsageDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveDrmUsageDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveDrmUsageDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveEdgeTransferRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveEdgeTransferResponseBody extends $tea.Model {
  appName?: string;
  domainName?: string;
  httpDns?: string;
  requestId?: string;
  streamName?: string;
  targetDomainList?: string;
  transferArgs?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      httpDns: 'HttpDns',
      requestId: 'RequestId',
      streamName: 'StreamName',
      targetDomainList: 'TargetDomainList',
      transferArgs: 'TransferArgs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      httpDns: 'string',
      requestId: 'string',
      streamName: 'string',
      targetDomainList: 'string',
      transferArgs: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveEdgeTransferResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveEdgeTransferResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveEdgeTransferResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveLazyPullStreamConfigRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveLazyPullStreamConfigResponseBody extends $tea.Model {
  liveLazyPullConfigList?: DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      liveLazyPullConfigList: 'LiveLazyPullConfigList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveLazyPullConfigList: DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveLazyPullStreamConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveLazyPullStreamConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveLazyPullStreamConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveProducerUsageDataRequest extends $tea.Model {
  domainName?: string;
  endTime?: string;
  instance?: string;
  interval?: string;
  ownerId?: number;
  region?: string;
  splitBy?: string;
  startTime?: string;
  type?: string;
  app?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      instance: 'Instance',
      interval: 'Interval',
      ownerId: 'OwnerId',
      region: 'Region',
      splitBy: 'SplitBy',
      startTime: 'StartTime',
      type: 'Type',
      app: 'app',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      instance: 'string',
      interval: 'string',
      ownerId: 'number',
      region: 'string',
      splitBy: 'string',
      startTime: 'string',
      type: 'string',
      app: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveProducerUsageDataResponseBody extends $tea.Model {
  billProducerData?: DescribeLiveProducerUsageDataResponseBodyBillProducerData;
  endTime?: string;
  requestId?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      billProducerData: 'BillProducerData',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      billProducerData: DescribeLiveProducerUsageDataResponseBodyBillProducerData,
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveProducerUsageDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveProducerUsageDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveProducerUsageDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLivePullStreamConfigRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLivePullStreamConfigResponseBody extends $tea.Model {
  liveAppRecordList?: DescribeLivePullStreamConfigResponseBodyLiveAppRecordList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      liveAppRecordList: 'LiveAppRecordList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveAppRecordList: DescribeLivePullStreamConfigResponseBodyLiveAppRecordList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLivePullStreamConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLivePullStreamConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLivePullStreamConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRealtimeDeliveryAccRequest extends $tea.Model {
  domainName?: string;
  endTime?: string;
  interval?: string;
  logStore?: string;
  ownerId?: number;
  project?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      logStore: 'LogStore',
      ownerId: 'OwnerId',
      project: 'Project',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      logStore: 'string',
      ownerId: 'number',
      project: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRealtimeDeliveryAccResponseBody extends $tea.Model {
  realTimeDeliveryAccData?: DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      realTimeDeliveryAccData: 'RealTimeDeliveryAccData',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      realTimeDeliveryAccData: DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRealtimeDeliveryAccResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveRealtimeDeliveryAccResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveRealtimeDeliveryAccResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRealtimeLogAuthorizedRequest extends $tea.Model {
  liveOpenapiReserve?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      liveOpenapiReserve: 'LiveOpenapiReserve',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveOpenapiReserve: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRealtimeLogAuthorizedResponseBody extends $tea.Model {
  authorizedStatus?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      authorizedStatus: 'AuthorizedStatus',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorizedStatus: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRealtimeLogAuthorizedResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveRealtimeLogAuthorizedResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveRealtimeLogAuthorizedResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRecordConfigRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  order?: string;
  ownerId?: number;
  pageNum?: number;
  pageSize?: number;
  securityToken?: string;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      order: 'Order',
      ownerId: 'OwnerId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      order: 'string',
      ownerId: 'number',
      pageNum: 'number',
      pageSize: 'number',
      securityToken: 'string',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRecordConfigResponseBody extends $tea.Model {
  liveAppRecordList?: DescribeLiveRecordConfigResponseBodyLiveAppRecordList;
  order?: string;
  pageNum?: number;
  pageSize?: number;
  requestId?: string;
  totalNum?: number;
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      liveAppRecordList: 'LiveAppRecordList',
      order: 'Order',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalNum: 'TotalNum',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveAppRecordList: DescribeLiveRecordConfigResponseBodyLiveAppRecordList,
      order: 'string',
      pageNum: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalNum: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRecordConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveRecordConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveRecordConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRecordNotifyConfigRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRecordNotifyConfigResponseBody extends $tea.Model {
  liveRecordNotifyConfig?: DescribeLiveRecordNotifyConfigResponseBodyLiveRecordNotifyConfig;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      liveRecordNotifyConfig: 'LiveRecordNotifyConfig',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveRecordNotifyConfig: DescribeLiveRecordNotifyConfigResponseBodyLiveRecordNotifyConfig,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRecordNotifyConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveRecordNotifyConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveRecordNotifyConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRecordVodConfigsRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  ownerId?: number;
  pageNum?: number;
  pageSize?: number;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      ownerId: 'number',
      pageNum: 'number',
      pageSize: 'number',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRecordVodConfigsResponseBody extends $tea.Model {
  liveRecordVodConfigs?: DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigs;
  pageNum?: number;
  pageSize?: number;
  requestId?: string;
  total?: string;
  static names(): { [key: string]: string } {
    return {
      liveRecordVodConfigs: 'LiveRecordVodConfigs',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveRecordVodConfigs: DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigs,
      pageNum: 'number',
      pageSize: 'number',
      requestId: 'string',
      total: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRecordVodConfigsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveRecordVodConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveRecordVodConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveShiftConfigsRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveShiftConfigsResponseBody extends $tea.Model {
  content?: DescribeLiveShiftConfigsResponseBodyContent;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: DescribeLiveShiftConfigsResponseBodyContent,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveShiftConfigsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveShiftConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveShiftConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveSnapshotConfigRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  order?: string;
  ownerId?: number;
  pageNum?: number;
  pageSize?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      order: 'Order',
      ownerId: 'OwnerId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      order: 'string',
      ownerId: 'number',
      pageNum: 'number',
      pageSize: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveSnapshotConfigResponseBody extends $tea.Model {
  liveStreamSnapshotConfigList?: DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigList;
  order?: string;
  pageNum?: number;
  pageSize?: number;
  requestId?: string;
  totalNum?: number;
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      liveStreamSnapshotConfigList: 'LiveStreamSnapshotConfigList',
      order: 'Order',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalNum: 'TotalNum',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveStreamSnapshotConfigList: DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigList,
      order: 'string',
      pageNum: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalNum: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveSnapshotConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveSnapshotConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveSnapshotConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveSnapshotDetectPornConfigRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  order?: string;
  ownerId?: number;
  pageNum?: number;
  pageSize?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      order: 'Order',
      ownerId: 'OwnerId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      order: 'string',
      ownerId: 'number',
      pageNum: 'number',
      pageSize: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveSnapshotDetectPornConfigResponseBody extends $tea.Model {
  liveSnapshotDetectPornConfigList?: DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigList;
  order?: string;
  pageNum?: number;
  pageSize?: number;
  requestId?: string;
  totalNum?: number;
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      liveSnapshotDetectPornConfigList: 'LiveSnapshotDetectPornConfigList',
      order: 'Order',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalNum: 'TotalNum',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveSnapshotDetectPornConfigList: DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigList,
      order: 'string',
      pageNum: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalNum: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveSnapshotDetectPornConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveSnapshotDetectPornConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveSnapshotDetectPornConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveSnapshotNotifyConfigRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveSnapshotNotifyConfigResponseBody extends $tea.Model {
  domainName?: string;
  notifyAuthKey?: string;
  notifyReqAuth?: string;
  notifyUrl?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      notifyAuthKey: 'NotifyAuthKey',
      notifyReqAuth: 'NotifyReqAuth',
      notifyUrl: 'NotifyUrl',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      notifyAuthKey: 'string',
      notifyReqAuth: 'string',
      notifyUrl: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveSnapshotNotifyConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveSnapshotNotifyConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveSnapshotNotifyConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamAuthCheckingRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamAuthCheckingResponseBody extends $tea.Model {
  description?: string;
  requestId?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamAuthCheckingResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamAuthCheckingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamAuthCheckingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamBitRateDataRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  endTime?: string;
  ownerId?: number;
  securityToken?: string;
  startTime?: string;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      endTime: 'EndTime',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
      startTime: 'StartTime',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      endTime: 'string',
      ownerId: 'number',
      securityToken: 'string',
      startTime: 'string',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamBitRateDataResponseBody extends $tea.Model {
  frameRateAndBitRateInfos?: DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfos;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      frameRateAndBitRateInfos: 'FrameRateAndBitRateInfos',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      frameRateAndBitRateInfos: DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfos,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamBitRateDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamBitRateDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamBitRateDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamCountRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamCountResponseBody extends $tea.Model {
  requestId?: string;
  streamCountInfos?: DescribeLiveStreamCountResponseBodyStreamCountInfos;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      streamCountInfos: 'StreamCountInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      streamCountInfos: DescribeLiveStreamCountResponseBodyStreamCountInfos,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamCountResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamDelayConfigRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamDelayConfigResponseBody extends $tea.Model {
  liveStreamFlvDelayConfig?: DescribeLiveStreamDelayConfigResponseBodyLiveStreamFlvDelayConfig;
  liveStreamHlsDelayConfig?: DescribeLiveStreamDelayConfigResponseBodyLiveStreamHlsDelayConfig;
  liveStreamRtmpDelayConfig?: DescribeLiveStreamDelayConfigResponseBodyLiveStreamRtmpDelayConfig;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      liveStreamFlvDelayConfig: 'LiveStreamFlvDelayConfig',
      liveStreamHlsDelayConfig: 'LiveStreamHlsDelayConfig',
      liveStreamRtmpDelayConfig: 'LiveStreamRtmpDelayConfig',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveStreamFlvDelayConfig: DescribeLiveStreamDelayConfigResponseBodyLiveStreamFlvDelayConfig,
      liveStreamHlsDelayConfig: DescribeLiveStreamDelayConfigResponseBodyLiveStreamHlsDelayConfig,
      liveStreamRtmpDelayConfig: DescribeLiveStreamDelayConfigResponseBodyLiveStreamRtmpDelayConfig,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamDelayConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamDelayConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamDelayConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamHistoryUserNumRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  endTime?: string;
  ownerId?: number;
  securityToken?: string;
  startTime?: string;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      endTime: 'EndTime',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
      startTime: 'StartTime',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      endTime: 'string',
      ownerId: 'number',
      securityToken: 'string',
      startTime: 'string',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamHistoryUserNumResponseBody extends $tea.Model {
  liveStreamUserNumInfos?: DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfos;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      liveStreamUserNumInfos: 'LiveStreamUserNumInfos',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveStreamUserNumInfos: DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfos,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamHistoryUserNumResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamHistoryUserNumResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamHistoryUserNumResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamMetricDetailDataRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  endTime?: string;
  nextPageToken?: string;
  ownerId?: number;
  protocol?: string;
  startTime?: string;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      endTime: 'EndTime',
      nextPageToken: 'NextPageToken',
      ownerId: 'OwnerId',
      protocol: 'Protocol',
      startTime: 'StartTime',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      endTime: 'string',
      nextPageToken: 'string',
      ownerId: 'number',
      protocol: 'string',
      startTime: 'string',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamMetricDetailDataResponseBody extends $tea.Model {
  domainName?: string;
  endTime?: string;
  nextPageToken?: string;
  pageSize?: number;
  requestId?: string;
  startTime?: string;
  streamDetailData?: DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailData;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      nextPageToken: 'NextPageToken',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      startTime: 'StartTime',
      streamDetailData: 'StreamDetailData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      nextPageToken: 'string',
      pageSize: 'number',
      requestId: 'string',
      startTime: 'string',
      streamDetailData: DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamMetricDetailDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamMetricDetailDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamMetricDetailDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamMonitorListRequest extends $tea.Model {
  monitorId?: string;
  orderRule?: number;
  ownerId?: number;
  pageNum?: number;
  pageSize?: number;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      monitorId: 'MonitorId',
      orderRule: 'OrderRule',
      ownerId: 'OwnerId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorId: 'string',
      orderRule: 'number',
      ownerId: 'number',
      pageNum: 'number',
      pageSize: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamMonitorListResponseBody extends $tea.Model {
  liveStreamMonitorList?: DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList[];
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      liveStreamMonitorList: 'LiveStreamMonitorList',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveStreamMonitorList: { 'type': 'array', 'itemType': DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList },
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamMonitorListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamMonitorListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamMonitorListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamOptimizedFeatureConfigRequest extends $tea.Model {
  configName?: string;
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      configName: 'ConfigName',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configName: 'string',
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamOptimizedFeatureConfigResponseBody extends $tea.Model {
  liveStreamOptimizedFeatureConfigList?: DescribeLiveStreamOptimizedFeatureConfigResponseBodyLiveStreamOptimizedFeatureConfigList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      liveStreamOptimizedFeatureConfigList: 'LiveStreamOptimizedFeatureConfigList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveStreamOptimizedFeatureConfigList: DescribeLiveStreamOptimizedFeatureConfigResponseBodyLiveStreamOptimizedFeatureConfigList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamOptimizedFeatureConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamOptimizedFeatureConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamOptimizedFeatureConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamRecordContentRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  endTime?: string;
  ownerId?: number;
  securityToken?: string;
  startTime?: string;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      endTime: 'EndTime',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
      startTime: 'StartTime',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      endTime: 'string',
      ownerId: 'number',
      securityToken: 'string',
      startTime: 'string',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamRecordContentResponseBody extends $tea.Model {
  recordContentInfoList?: DescribeLiveStreamRecordContentResponseBodyRecordContentInfoList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recordContentInfoList: 'RecordContentInfoList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordContentInfoList: DescribeLiveStreamRecordContentResponseBodyRecordContentInfoList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamRecordContentResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamRecordContentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamRecordContentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamRecordIndexFileRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  ownerId?: number;
  recordId?: string;
  securityToken?: string;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      recordId: 'RecordId',
      securityToken: 'SecurityToken',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      ownerId: 'number',
      recordId: 'string',
      securityToken: 'string',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamRecordIndexFileResponseBody extends $tea.Model {
  recordIndexInfo?: DescribeLiveStreamRecordIndexFileResponseBodyRecordIndexInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recordIndexInfo: 'RecordIndexInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordIndexInfo: DescribeLiveStreamRecordIndexFileResponseBodyRecordIndexInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamRecordIndexFileResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamRecordIndexFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamRecordIndexFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamRecordIndexFilesRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  endTime?: string;
  order?: string;
  ownerId?: number;
  pageNum?: number;
  pageSize?: number;
  securityToken?: string;
  startTime?: string;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      endTime: 'EndTime',
      order: 'Order',
      ownerId: 'OwnerId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      startTime: 'StartTime',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      endTime: 'string',
      order: 'string',
      ownerId: 'number',
      pageNum: 'number',
      pageSize: 'number',
      securityToken: 'string',
      startTime: 'string',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamRecordIndexFilesResponseBody extends $tea.Model {
  order?: string;
  pageNum?: number;
  pageSize?: number;
  recordIndexInfoList?: DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoList;
  requestId?: string;
  totalNum?: number;
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      order: 'Order',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      recordIndexInfoList: 'RecordIndexInfoList',
      requestId: 'RequestId',
      totalNum: 'TotalNum',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      order: 'string',
      pageNum: 'number',
      pageSize: 'number',
      recordIndexInfoList: DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoList,
      requestId: 'string',
      totalNum: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamRecordIndexFilesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamRecordIndexFilesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamRecordIndexFilesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamSnapshotInfoRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  endTime?: string;
  limit?: number;
  order?: string;
  ownerId?: number;
  securityToken?: string;
  startTime?: string;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      endTime: 'EndTime',
      limit: 'Limit',
      order: 'Order',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
      startTime: 'StartTime',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      endTime: 'string',
      limit: 'number',
      order: 'string',
      ownerId: 'number',
      securityToken: 'string',
      startTime: 'string',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamSnapshotInfoResponseBody extends $tea.Model {
  liveStreamSnapshotInfoList?: DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoList;
  nextStartTime?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      liveStreamSnapshotInfoList: 'LiveStreamSnapshotInfoList',
      nextStartTime: 'NextStartTime',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveStreamSnapshotInfoList: DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoList,
      nextStartTime: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamSnapshotInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamSnapshotInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamSnapshotInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamStateRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  ownerId?: number;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      ownerId: 'number',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamStateResponseBody extends $tea.Model {
  requestId?: string;
  streamState?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      streamState: 'StreamState',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      streamState: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamStateResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamStateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamStateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamTranscodeInfoRequest extends $tea.Model {
  domainTranscodeName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainTranscodeName: 'DomainTranscodeName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainTranscodeName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamTranscodeInfoResponseBody extends $tea.Model {
  domainTranscodeList?: DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainTranscodeList: 'DomainTranscodeList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainTranscodeList: DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamTranscodeInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamTranscodeInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamTranscodeInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamTranscodeStreamNumRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamTranscodeStreamNumResponseBody extends $tea.Model {
  lazyTranscodedNumber?: number;
  requestId?: string;
  total?: number;
  transcodedNumber?: number;
  untranscodeNumber?: number;
  static names(): { [key: string]: string } {
    return {
      lazyTranscodedNumber: 'LazyTranscodedNumber',
      requestId: 'RequestId',
      total: 'Total',
      transcodedNumber: 'TranscodedNumber',
      untranscodeNumber: 'UntranscodeNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lazyTranscodedNumber: 'number',
      requestId: 'string',
      total: 'number',
      transcodedNumber: 'number',
      untranscodeNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamTranscodeStreamNumResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamTranscodeStreamNumResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamTranscodeStreamNumResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamWatermarkRulesRequest extends $tea.Model {
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamWatermarkRulesResponseBody extends $tea.Model {
  requestId?: string;
  ruleInfoList?: DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      ruleInfoList: 'RuleInfoList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      ruleInfoList: DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamWatermarkRulesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamWatermarkRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamWatermarkRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamWatermarksRequest extends $tea.Model {
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamWatermarksResponseBody extends $tea.Model {
  requestId?: string;
  watermarkList?: DescribeLiveStreamWatermarksResponseBodyWatermarkList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      watermarkList: 'WatermarkList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      watermarkList: DescribeLiveStreamWatermarksResponseBodyWatermarkList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamWatermarksResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamWatermarksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamWatermarksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsBlockListRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  pageNum?: number;
  pageSize?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      pageNum: 'number',
      pageSize: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsBlockListResponseBody extends $tea.Model {
  domainName?: string;
  pageNum?: number;
  pageSize?: number;
  requestId?: string;
  streamUrls?: DescribeLiveStreamsBlockListResponseBodyStreamUrls;
  totalNum?: number;
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      streamUrls: 'StreamUrls',
      totalNum: 'TotalNum',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      pageNum: 'number',
      pageSize: 'number',
      requestId: 'string',
      streamUrls: DescribeLiveStreamsBlockListResponseBodyStreamUrls,
      totalNum: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsBlockListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamsBlockListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamsBlockListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsControlHistoryRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  endTime?: string;
  ownerId?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      endTime: 'EndTime',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      endTime: 'string',
      ownerId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsControlHistoryResponseBody extends $tea.Model {
  controlInfo?: DescribeLiveStreamsControlHistoryResponseBodyControlInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      controlInfo: 'ControlInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      controlInfo: DescribeLiveStreamsControlHistoryResponseBodyControlInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsControlHistoryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamsControlHistoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamsControlHistoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsNotifyRecordsRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  endTime?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  startTime?: string;
  status?: string;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      endTime: 'EndTime',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTime: 'StartTime',
      status: 'Status',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      endTime: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      startTime: 'string',
      status: 'string',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsNotifyRecordsResponseBody extends $tea.Model {
  notifyRecordsInfo?: DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfo;
  pageNum?: number;
  pageSize?: number;
  requestId?: string;
  totalNum?: number;
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      notifyRecordsInfo: 'NotifyRecordsInfo',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalNum: 'TotalNum',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      notifyRecordsInfo: DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfo,
      pageNum: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalNum: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsNotifyRecordsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamsNotifyRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamsNotifyRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsNotifyUrlConfigRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsNotifyUrlConfigResponseBody extends $tea.Model {
  liveStreamsNotifyConfig?: DescribeLiveStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      liveStreamsNotifyConfig: 'LiveStreamsNotifyConfig',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveStreamsNotifyConfig: DescribeLiveStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsNotifyUrlConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamsNotifyUrlConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamsNotifyUrlConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsOnlineListRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  onlyStream?: string;
  ownerId?: number;
  pageNum?: number;
  pageSize?: number;
  queryType?: string;
  streamName?: string;
  streamType?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      onlyStream: 'OnlyStream',
      ownerId: 'OwnerId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      queryType: 'QueryType',
      streamName: 'StreamName',
      streamType: 'StreamType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      onlyStream: 'string',
      ownerId: 'number',
      pageNum: 'number',
      pageSize: 'number',
      queryType: 'string',
      streamName: 'string',
      streamType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsOnlineListResponseBody extends $tea.Model {
  onlineInfo?: DescribeLiveStreamsOnlineListResponseBodyOnlineInfo;
  pageNum?: number;
  pageSize?: number;
  requestId?: string;
  totalNum?: number;
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      onlineInfo: 'OnlineInfo',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalNum: 'TotalNum',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      onlineInfo: DescribeLiveStreamsOnlineListResponseBodyOnlineInfo,
      pageNum: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalNum: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsOnlineListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamsOnlineListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamsOnlineListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsPublishListRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  endTime?: string;
  orderBy?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  queryType?: string;
  startTime?: string;
  streamName?: string;
  streamType?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      endTime: 'EndTime',
      orderBy: 'OrderBy',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      queryType: 'QueryType',
      startTime: 'StartTime',
      streamName: 'StreamName',
      streamType: 'StreamType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      endTime: 'string',
      orderBy: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      queryType: 'string',
      startTime: 'string',
      streamName: 'string',
      streamType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsPublishListResponseBody extends $tea.Model {
  pageNum?: number;
  pageSize?: number;
  publishInfo?: DescribeLiveStreamsPublishListResponseBodyPublishInfo;
  requestId?: string;
  totalNum?: number;
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      publishInfo: 'PublishInfo',
      requestId: 'RequestId',
      totalNum: 'TotalNum',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNum: 'number',
      pageSize: 'number',
      publishInfo: DescribeLiveStreamsPublishListResponseBodyPublishInfo,
      requestId: 'string',
      totalNum: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsPublishListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveStreamsPublishListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveStreamsPublishListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveTagResourcesRequest extends $tea.Model {
  ownerId?: number;
  resourceId?: string[];
  resourceType?: string;
  tag?: DescribeLiveTagResourcesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tag: { 'type': 'array', 'itemType': DescribeLiveTagResourcesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveTagResourcesResponseBody extends $tea.Model {
  requestId?: string;
  tagResources?: DescribeLiveTagResourcesResponseBodyTagResources[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tagResources: 'TagResources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tagResources: { 'type': 'array', 'itemType': DescribeLiveTagResourcesResponseBodyTagResources },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveTagResourcesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveTagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveTagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveTopDomainsByFlowRequest extends $tea.Model {
  endTime?: string;
  limit?: number;
  ownerId?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      limit: 'Limit',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      limit: 'number',
      ownerId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveTopDomainsByFlowResponseBody extends $tea.Model {
  domainCount?: number;
  domainOnlineCount?: number;
  endTime?: string;
  requestId?: string;
  startTime?: string;
  topDomains?: DescribeLiveTopDomainsByFlowResponseBodyTopDomains;
  static names(): { [key: string]: string } {
    return {
      domainCount: 'DomainCount',
      domainOnlineCount: 'DomainOnlineCount',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
      topDomains: 'TopDomains',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainCount: 'number',
      domainOnlineCount: 'number',
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
      topDomains: DescribeLiveTopDomainsByFlowResponseBodyTopDomains,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveTopDomainsByFlowResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveTopDomainsByFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveTopDomainsByFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveUserBillPredictionRequest extends $tea.Model {
  area?: string;
  dimension?: string;
  endTime?: string;
  ownerId?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      area: 'Area',
      dimension: 'Dimension',
      endTime: 'EndTime',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      area: 'string',
      dimension: 'string',
      endTime: 'string',
      ownerId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveUserBillPredictionResponseBody extends $tea.Model {
  billPredictionData?: DescribeLiveUserBillPredictionResponseBodyBillPredictionData;
  billType?: string;
  endTime?: string;
  requestId?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      billPredictionData: 'BillPredictionData',
      billType: 'BillType',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      billPredictionData: DescribeLiveUserBillPredictionResponseBodyBillPredictionData,
      billType: 'string',
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveUserBillPredictionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveUserBillPredictionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveUserBillPredictionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveUserDomainsRequest extends $tea.Model {
  domainName?: string;
  domainSearchType?: string;
  domainStatus?: string;
  liveDomainType?: string;
  ownerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionName?: string;
  securityToken?: string;
  tag?: DescribeLiveUserDomainsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      domainSearchType: 'DomainSearchType',
      domainStatus: 'DomainStatus',
      liveDomainType: 'LiveDomainType',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionName: 'RegionName',
      securityToken: 'SecurityToken',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      domainSearchType: 'string',
      domainStatus: 'string',
      liveDomainType: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionName: 'string',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': DescribeLiveUserDomainsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveUserDomainsResponseBody extends $tea.Model {
  domains?: DescribeLiveUserDomainsResponseBodyDomains;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: DescribeLiveUserDomainsResponseBodyDomains,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveUserDomainsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveUserDomainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveUserDomainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveUserTagsRequest extends $tea.Model {
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveUserTagsResponseBody extends $tea.Model {
  requestId?: string;
  tags?: DescribeLiveUserTagsResponseBodyTags[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tags: { 'type': 'array', 'itemType': DescribeLiveUserTagsResponseBodyTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveUserTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLiveUserTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLiveUserTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMeterLiveRtcDurationRequest extends $tea.Model {
  endTime?: string;
  interval?: string;
  serviceArea?: string;
  startTime?: string;
  appId?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      interval: 'Interval',
      serviceArea: 'ServiceArea',
      startTime: 'StartTime',
      appId: 'appId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      interval: 'string',
      serviceArea: 'string',
      startTime: 'string',
      appId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMeterLiveRtcDurationResponseBody extends $tea.Model {
  audioSummaryDuration?: number;
  data?: DescribeMeterLiveRtcDurationResponseBodyData[];
  requestId?: string;
  totalSummaryDuration?: number;
  v1080SummaryDuration?: number;
  v480SummaryDuration?: number;
  v720SummaryDuration?: number;
  static names(): { [key: string]: string } {
    return {
      audioSummaryDuration: 'AudioSummaryDuration',
      data: 'Data',
      requestId: 'RequestId',
      totalSummaryDuration: 'TotalSummaryDuration',
      v1080SummaryDuration: 'V1080SummaryDuration',
      v480SummaryDuration: 'V480SummaryDuration',
      v720SummaryDuration: 'V720SummaryDuration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioSummaryDuration: 'number',
      data: { 'type': 'array', 'itemType': DescribeMeterLiveRtcDurationResponseBodyData },
      requestId: 'string',
      totalSummaryDuration: 'number',
      v1080SummaryDuration: 'number',
      v480SummaryDuration: 'number',
      v720SummaryDuration: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMeterLiveRtcDurationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeMeterLiveRtcDurationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMeterLiveRtcDurationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMixStreamListRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  endTime?: string;
  mixStreamId?: string;
  ownerId?: number;
  pageNo?: number;
  pageSize?: number;
  startTime?: string;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      endTime: 'EndTime',
      mixStreamId: 'MixStreamId',
      ownerId: 'OwnerId',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      startTime: 'StartTime',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      endTime: 'string',
      mixStreamId: 'string',
      ownerId: 'number',
      pageNo: 'number',
      pageSize: 'number',
      startTime: 'string',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMixStreamListResponseBody extends $tea.Model {
  mixStreamList?: DescribeMixStreamListResponseBodyMixStreamList[];
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      mixStreamList: 'MixStreamList',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mixStreamList: { 'type': 'array', 'itemType': DescribeMixStreamListResponseBodyMixStreamList },
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMixStreamListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeMixStreamListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMixStreamListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKFirstFrameCostRequest extends $tea.Model {
  dataInterval?: string;
  domainNameList?: string[];
  endTime?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainNameList: 'DomainNameList',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainNameList: { 'type': 'array', 'itemType': 'string' },
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKFirstFrameCostShrinkRequest extends $tea.Model {
  dataInterval?: string;
  domainNameListShrink?: string;
  endTime?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainNameListShrink: 'DomainNameList',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainNameListShrink: 'string',
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKFirstFrameCostResponseBody extends $tea.Model {
  dataInterval?: string;
  endTime?: string;
  firstFrameCostData?: DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData[];
  requestId?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      endTime: 'EndTime',
      firstFrameCostData: 'FirstFrameCostData',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      endTime: 'string',
      firstFrameCostData: { 'type': 'array', 'itemType': DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData },
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKFirstFrameCostResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeRTSNativeSDKFirstFrameCostResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRTSNativeSDKFirstFrameCostResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKFirstFrameDelayRequest extends $tea.Model {
  dataInterval?: string;
  domainNameList?: string[];
  endTime?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainNameList: 'DomainNameList',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainNameList: { 'type': 'array', 'itemType': 'string' },
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKFirstFrameDelayShrinkRequest extends $tea.Model {
  dataInterval?: string;
  domainNameListShrink?: string;
  endTime?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainNameListShrink: 'DomainNameList',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainNameListShrink: 'string',
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKFirstFrameDelayResponseBody extends $tea.Model {
  dataInterval?: string;
  endTime?: string;
  frameDelayData?: DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData[];
  requestId?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      endTime: 'EndTime',
      frameDelayData: 'FrameDelayData',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      endTime: 'string',
      frameDelayData: { 'type': 'array', 'itemType': DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData },
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKFirstFrameDelayResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeRTSNativeSDKFirstFrameDelayResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRTSNativeSDKFirstFrameDelayResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKPlayFailStatusRequest extends $tea.Model {
  dataInterval?: string;
  domainNameList?: string[];
  endTime?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainNameList: 'DomainNameList',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainNameList: { 'type': 'array', 'itemType': 'string' },
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKPlayFailStatusShrinkRequest extends $tea.Model {
  dataInterval?: string;
  domainNameListShrink?: string;
  endTime?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainNameListShrink: 'DomainNameList',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainNameListShrink: 'string',
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKPlayFailStatusResponseBody extends $tea.Model {
  dataInterval?: string;
  endTime?: string;
  playFailStatus?: DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus[];
  requestId?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      endTime: 'EndTime',
      playFailStatus: 'PlayFailStatus',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      endTime: 'string',
      playFailStatus: { 'type': 'array', 'itemType': DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus },
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKPlayFailStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeRTSNativeSDKPlayFailStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRTSNativeSDKPlayFailStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKPlayTimeRequest extends $tea.Model {
  dataInterval?: string;
  domainNameList?: string[];
  endTime?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainNameList: 'DomainNameList',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainNameList: { 'type': 'array', 'itemType': 'string' },
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKPlayTimeShrinkRequest extends $tea.Model {
  dataInterval?: string;
  domainNameListShrink?: string;
  endTime?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainNameListShrink: 'DomainNameList',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainNameListShrink: 'string',
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKPlayTimeResponseBody extends $tea.Model {
  dataInterval?: string;
  endTime?: string;
  playTimeData?: DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData[];
  requestId?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      endTime: 'EndTime',
      playTimeData: 'PlayTimeData',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      endTime: 'string',
      playTimeData: { 'type': 'array', 'itemType': DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData },
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKPlayTimeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeRTSNativeSDKPlayTimeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRTSNativeSDKPlayTimeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKVvDataRequest extends $tea.Model {
  dataInterval?: string;
  domainNameList?: string[];
  endTime?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainNameList: 'DomainNameList',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainNameList: { 'type': 'array', 'itemType': 'string' },
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKVvDataShrinkRequest extends $tea.Model {
  dataInterval?: string;
  domainNameListShrink?: string;
  endTime?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainNameListShrink: 'DomainNameList',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainNameListShrink: 'string',
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKVvDataResponseBody extends $tea.Model {
  dataInterval?: string;
  endTime?: string;
  requestId?: string;
  startTime?: string;
  vvData?: DescribeRTSNativeSDKVvDataResponseBodyVvData[];
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
      vvData: 'VvData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
      vvData: { 'type': 'array', 'itemType': DescribeRTSNativeSDKVvDataResponseBodyVvData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKVvDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeRTSNativeSDKVvDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRTSNativeSDKVvDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoomKickoutUserListRequest extends $tea.Model {
  appId?: string;
  order?: string;
  ownerId?: number;
  pageNum?: number;
  pageSize?: number;
  roomId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      order: 'Order',
      ownerId: 'OwnerId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      roomId: 'RoomId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      order: 'string',
      ownerId: 'number',
      pageNum: 'number',
      pageSize: 'number',
      roomId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoomKickoutUserListResponseBody extends $tea.Model {
  requestId?: string;
  totalNum?: number;
  totalPage?: number;
  userList?: DescribeRoomKickoutUserListResponseBodyUserList[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      totalNum: 'TotalNum',
      totalPage: 'TotalPage',
      userList: 'UserList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      totalNum: 'number',
      totalPage: 'number',
      userList: { 'type': 'array', 'itemType': DescribeRoomKickoutUserListResponseBodyUserList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoomKickoutUserListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeRoomKickoutUserListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRoomKickoutUserListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoomListRequest extends $tea.Model {
  anchorId?: string;
  appId?: string;
  endTime?: string;
  order?: string;
  ownerId?: number;
  pageNum?: number;
  pageSize?: number;
  roomId?: string;
  roomStatus?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      anchorId: 'AnchorId',
      appId: 'AppId',
      endTime: 'EndTime',
      order: 'Order',
      ownerId: 'OwnerId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      roomId: 'RoomId',
      roomStatus: 'RoomStatus',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      anchorId: 'string',
      appId: 'string',
      endTime: 'string',
      order: 'string',
      ownerId: 'number',
      pageNum: 'number',
      pageSize: 'number',
      roomId: 'string',
      roomStatus: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoomListResponseBody extends $tea.Model {
  requestId?: string;
  roomList?: DescribeRoomListResponseBodyRoomList[];
  totalNum?: number;
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      roomList: 'RoomList',
      totalNum: 'TotalNum',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      roomList: { 'type': 'array', 'itemType': DescribeRoomListResponseBodyRoomList },
      totalNum: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoomListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeRoomListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRoomListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoomStatusRequest extends $tea.Model {
  appId?: string;
  ownerId?: number;
  roomId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      ownerId: 'OwnerId',
      roomId: 'RoomId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      ownerId: 'number',
      roomId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoomStatusResponseBody extends $tea.Model {
  requestId?: string;
  roomStatus?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      roomStatus: 'RoomStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      roomStatus: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoomStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeRoomStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRoomStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeShowListRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeShowListResponseBody extends $tea.Model {
  requestId?: string;
  showList?: string;
  showListInfo?: DescribeShowListResponseBodyShowListInfo;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      showList: 'ShowList',
      showListInfo: 'ShowListInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      showList: 'string',
      showListInfo: DescribeShowListResponseBodyShowListInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeShowListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeShowListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeShowListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStudioLayoutsRequest extends $tea.Model {
  casterId?: string;
  layoutId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      layoutId: 'LayoutId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      layoutId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStudioLayoutsResponseBody extends $tea.Model {
  requestId?: string;
  studioLayouts?: DescribeStudioLayoutsResponseBodyStudioLayouts[];
  total?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      studioLayouts: 'StudioLayouts',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      studioLayouts: { 'type': 'array', 'itemType': DescribeStudioLayoutsResponseBodyStudioLayouts },
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStudioLayoutsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeStudioLayoutsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeStudioLayoutsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeToutiaoLivePlayRequest extends $tea.Model {
  app?: string;
  domain?: string;
  endTime?: string;
  ownerId?: number;
  startTime?: string;
  stream?: string;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      domain: 'Domain',
      endTime: 'EndTime',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
      stream: 'Stream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      domain: 'string',
      endTime: 'string',
      ownerId: 'number',
      startTime: 'string',
      stream: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeToutiaoLivePlayResponseBody extends $tea.Model {
  content?: DescribeToutiaoLivePlayResponseBodyContent[];
  description?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      description: 'Description',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'array', 'itemType': DescribeToutiaoLivePlayResponseBodyContent },
      description: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeToutiaoLivePlayResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeToutiaoLivePlayResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeToutiaoLivePlayResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeToutiaoLivePublishRequest extends $tea.Model {
  app?: string;
  domain?: string;
  endTime?: string;
  ownerId?: number;
  startTime?: string;
  stream?: string;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      domain: 'Domain',
      endTime: 'EndTime',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
      stream: 'Stream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      domain: 'string',
      endTime: 'string',
      ownerId: 'number',
      startTime: 'string',
      stream: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeToutiaoLivePublishResponseBody extends $tea.Model {
  content?: DescribeToutiaoLivePublishResponseBodyContent[];
  description?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      description: 'Description',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'array', 'itemType': DescribeToutiaoLivePublishResponseBodyContent },
      description: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeToutiaoLivePublishResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeToutiaoLivePublishResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeToutiaoLivePublishResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpBpsPeakDataRequest extends $tea.Model {
  domainName?: string;
  domainSwitch?: string;
  endTime?: string;
  ownerId?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      domainSwitch: 'DomainSwitch',
      endTime: 'EndTime',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      domainSwitch: 'string',
      endTime: 'string',
      ownerId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpBpsPeakDataResponseBody extends $tea.Model {
  describeUpPeakTraffics?: DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTraffics;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      describeUpPeakTraffics: 'DescribeUpPeakTraffics',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      describeUpPeakTraffics: DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTraffics,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpBpsPeakDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeUpBpsPeakDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUpBpsPeakDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpBpsPeakOfLineRequest extends $tea.Model {
  domainName?: string;
  domainSwitch?: string;
  endTime?: string;
  line?: string;
  ownerId?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      domainSwitch: 'DomainSwitch',
      endTime: 'EndTime',
      line: 'Line',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      domainSwitch: 'string',
      endTime: 'string',
      line: 'string',
      ownerId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpBpsPeakOfLineResponseBody extends $tea.Model {
  describeUpBpsPeakOfLines?: DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLines;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      describeUpBpsPeakOfLines: 'DescribeUpBpsPeakOfLines',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      describeUpBpsPeakOfLines: DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLines,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpBpsPeakOfLineResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeUpBpsPeakOfLineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUpBpsPeakOfLineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpPeakPublishStreamDataRequest extends $tea.Model {
  domainName?: string;
  domainSwitch?: string;
  endTime?: string;
  ownerId?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      domainSwitch: 'DomainSwitch',
      endTime: 'EndTime',
      ownerId: 'OwnerId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      domainSwitch: 'string',
      endTime: 'string',
      ownerId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpPeakPublishStreamDataResponseBody extends $tea.Model {
  describeUpPeakPublishStreamDatas?: DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatas;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      describeUpPeakPublishStreamDatas: 'DescribeUpPeakPublishStreamDatas',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      describeUpPeakPublishStreamDatas: DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatas,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpPeakPublishStreamDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeUpPeakPublishStreamDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUpPeakPublishStreamDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableLiveRealtimeLogDeliveryRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableLiveRealtimeLogDeliveryResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableLiveRealtimeLogDeliveryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DisableLiveRealtimeLogDeliveryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DisableLiveRealtimeLogDeliveryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DynamicUpdateWaterMarkStreamRuleRequest extends $tea.Model {
  app?: string;
  domain?: string;
  ownerId?: number;
  stream?: string;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      domain: 'Domain',
      ownerId: 'OwnerId',
      stream: 'Stream',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      domain: 'string',
      ownerId: 'number',
      stream: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DynamicUpdateWaterMarkStreamRuleResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DynamicUpdateWaterMarkStreamRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DynamicUpdateWaterMarkStreamRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DynamicUpdateWaterMarkStreamRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditPlaylistRequest extends $tea.Model {
  ownerId?: number;
  programConfig?: string;
  programId?: string;
  programItems?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      programConfig: 'ProgramConfig',
      programId: 'ProgramId',
      programItems: 'ProgramItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      programConfig: 'string',
      programId: 'string',
      programItems: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditPlaylistResponseBody extends $tea.Model {
  casterId?: string;
  items?: EditPlaylistResponseBodyItems;
  programId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      items: 'Items',
      programId: 'ProgramId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      items: EditPlaylistResponseBodyItems,
      programId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditPlaylistResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: EditPlaylistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EditPlaylistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditShowAndReplaceRequest extends $tea.Model {
  casterId?: string;
  endTime?: number;
  ownerId?: number;
  showId?: string;
  startTime?: number;
  storageInfo?: string;
  userData?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      endTime: 'EndTime',
      ownerId: 'OwnerId',
      showId: 'ShowId',
      startTime: 'StartTime',
      storageInfo: 'StorageInfo',
      userData: 'UserData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      endTime: 'number',
      ownerId: 'number',
      showId: 'string',
      startTime: 'number',
      storageInfo: 'string',
      userData: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditShowAndReplaceResponseBody extends $tea.Model {
  jobInfo?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      jobInfo: 'JobInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobInfo: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditShowAndReplaceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: EditShowAndReplaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EditShowAndReplaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EffectCasterUrgentRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  sceneId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
      sceneId: 'SceneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
      sceneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EffectCasterUrgentResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EffectCasterUrgentResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: EffectCasterUrgentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EffectCasterUrgentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EffectCasterVideoResourceRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  resourceId?: string;
  sceneId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
      resourceId: 'ResourceId',
      sceneId: 'SceneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
      resourceId: 'string',
      sceneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EffectCasterVideoResourceResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EffectCasterVideoResourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: EffectCasterVideoResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EffectCasterVideoResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableLiveRealtimeLogDeliveryRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableLiveRealtimeLogDeliveryResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableLiveRealtimeLogDeliveryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: EnableLiveRealtimeLogDeliveryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableLiveRealtimeLogDeliveryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ForbidLiveStreamRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  liveStreamType?: string;
  oneshot?: string;
  ownerId?: number;
  resumeTime?: string;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      liveStreamType: 'LiveStreamType',
      oneshot: 'Oneshot',
      ownerId: 'OwnerId',
      resumeTime: 'ResumeTime',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      liveStreamType: 'string',
      oneshot: 'string',
      ownerId: 'number',
      resumeTime: 'string',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ForbidLiveStreamResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ForbidLiveStreamResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ForbidLiveStreamResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ForbidLiveStreamResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ForbidPushStreamRequest extends $tea.Model {
  appId?: string;
  endTime?: string;
  ownerId?: number;
  roomId?: string;
  userData?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      endTime: 'EndTime',
      ownerId: 'OwnerId',
      roomId: 'RoomId',
      userData: 'UserData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      endTime: 'string',
      ownerId: 'number',
      roomId: 'string',
      userData: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ForbidPushStreamResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ForbidPushStreamResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ForbidPushStreamResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ForbidPushStreamResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAllCustomTemplatesRequest extends $tea.Model {
  ownerId?: number;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAllCustomTemplatesResponseBody extends $tea.Model {
  customTemplates?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      customTemplates: 'CustomTemplates',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customTemplates: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAllCustomTemplatesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetAllCustomTemplatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAllCustomTemplatesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCustomTemplateRequest extends $tea.Model {
  ownerId?: number;
  template?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      template: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCustomTemplateResponseBody extends $tea.Model {
  customTemplate?: string;
  requestId?: string;
  template?: string;
  static names(): { [key: string]: string } {
    return {
      customTemplate: 'CustomTemplate',
      requestId: 'RequestId',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customTemplate: 'string',
      requestId: 'string',
      template: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCustomTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetCustomTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCustomTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEditingJobInfoRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  showId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
      showId: 'ShowId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
      showId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEditingJobInfoResponseBody extends $tea.Model {
  casterId?: string;
  editingTasksInfo?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      editingTasksInfo: 'EditingTasksInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      editingTasksInfo: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEditingJobInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetEditingJobInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetEditingJobInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMessageAppRequest extends $tea.Model {
  appId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMessageAppResponseBody extends $tea.Model {
  requestId?: string;
  result?: GetMessageAppResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: GetMessageAppResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMessageAppResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetMessageAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMessageAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMessageGroupRequest extends $tea.Model {
  appId?: string;
  groupId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      groupId: 'GroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      groupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMessageGroupResponseBody extends $tea.Model {
  requestId?: string;
  result?: GetMessageGroupResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: GetMessageGroupResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMessageGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetMessageGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMessageGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMessageTokenRequest extends $tea.Model {
  appId?: string;
  deviceId?: string;
  deviceType?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      deviceId: 'DeviceId',
      deviceType: 'DeviceType',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      deviceId: 'string',
      deviceType: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMessageTokenResponseBody extends $tea.Model {
  requestId?: string;
  result?: GetMessageTokenResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: GetMessageTokenResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMessageTokenResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetMessageTokenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMessageTokenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMultiRateConfigRequest extends $tea.Model {
  app?: string;
  domainName?: string;
  groupId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      domainName: 'DomainName',
      groupId: 'GroupId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      domainName: 'string',
      groupId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMultiRateConfigResponseBody extends $tea.Model {
  app?: string;
  avFormat?: string;
  code?: number;
  domain?: string;
  groupId?: string;
  isLazy?: string;
  isTimeAlign?: string;
  message?: string;
  requestId?: string;
  stream?: string;
  templatesInfo?: GetMultiRateConfigResponseBodyTemplatesInfo;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      avFormat: 'AvFormat',
      code: 'Code',
      domain: 'Domain',
      groupId: 'GroupId',
      isLazy: 'IsLazy',
      isTimeAlign: 'IsTimeAlign',
      message: 'Message',
      requestId: 'RequestId',
      stream: 'Stream',
      templatesInfo: 'TemplatesInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      avFormat: 'string',
      code: 'number',
      domain: 'string',
      groupId: 'string',
      isLazy: 'string',
      isTimeAlign: 'string',
      message: 'string',
      requestId: 'string',
      stream: 'string',
      templatesInfo: GetMultiRateConfigResponseBodyTemplatesInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMultiRateConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetMultiRateConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMultiRateConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMultiRateConfigListRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMultiRateConfigListResponseBody extends $tea.Model {
  code?: number;
  groupInfo?: GetMultiRateConfigListResponseBodyGroupInfo;
  message?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      groupInfo: 'GroupInfo',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      groupInfo: GetMultiRateConfigListResponseBodyGroupInfo,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMultiRateConfigListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetMultiRateConfigListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMultiRateConfigListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class HotLiveRtcStreamRequest extends $tea.Model {
  appName?: string;
  audioMsid?: string;
  connectionTimeout?: string;
  domainName?: string;
  mediaTimeout?: string;
  ownerId?: number;
  regionCode?: string;
  streamName?: string;
  videoMsid?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      audioMsid: 'AudioMsid',
      connectionTimeout: 'ConnectionTimeout',
      domainName: 'DomainName',
      mediaTimeout: 'MediaTimeout',
      ownerId: 'OwnerId',
      regionCode: 'RegionCode',
      streamName: 'StreamName',
      videoMsid: 'VideoMsid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      audioMsid: 'string',
      connectionTimeout: 'string',
      domainName: 'string',
      mediaTimeout: 'string',
      ownerId: 'number',
      regionCode: 'string',
      streamName: 'string',
      videoMsid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class HotLiveRtcStreamResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class HotLiveRtcStreamResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: HotLiveRtcStreamResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: HotLiveRtcStreamResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InitializeAutoShowListTaskRequest extends $tea.Model {
  callBackUrl?: string;
  casterConfig?: string;
  domainName?: string;
  endTime?: number;
  ownerId?: number;
  resourceIds?: string;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      callBackUrl: 'CallBackUrl',
      casterConfig: 'CasterConfig',
      domainName: 'DomainName',
      endTime: 'EndTime',
      ownerId: 'OwnerId',
      resourceIds: 'ResourceIds',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      callBackUrl: 'string',
      casterConfig: 'string',
      domainName: 'string',
      endTime: 'number',
      ownerId: 'number',
      resourceIds: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InitializeAutoShowListTaskResponseBody extends $tea.Model {
  casterId?: string;
  requestId?: string;
  streamList?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      requestId: 'RequestId',
      streamList: 'StreamList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      requestId: 'string',
      streamList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InitializeAutoShowListTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: InitializeAutoShowListTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InitializeAutoShowListTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinMessageGroupRequest extends $tea.Model {
  appId?: string;
  broadCastStatistics?: boolean;
  broadCastType?: number;
  groupId?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      broadCastStatistics: 'BroadCastStatistics',
      broadCastType: 'BroadCastType',
      groupId: 'GroupId',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      broadCastStatistics: 'boolean',
      broadCastType: 'number',
      groupId: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinMessageGroupResponseBody extends $tea.Model {
  requestId?: string;
  result?: JoinMessageGroupResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: JoinMessageGroupResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinMessageGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: JoinMessageGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: JoinMessageGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LeaveMessageGroupRequest extends $tea.Model {
  appId?: string;
  broadCastStatistics?: boolean;
  broadCastType?: number;
  groupId?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      broadCastStatistics: 'BroadCastStatistics',
      broadCastType: 'BroadCastType',
      groupId: 'GroupId',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      broadCastStatistics: 'boolean',
      broadCastType: 'number',
      groupId: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LeaveMessageGroupResponseBody extends $tea.Model {
  requestId?: string;
  result?: LeaveMessageGroupResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: LeaveMessageGroupResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LeaveMessageGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: LeaveMessageGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: LeaveMessageGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLiveRealtimeLogDeliveryRequest extends $tea.Model {
  liveOpenapiReserve?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      liveOpenapiReserve: 'LiveOpenapiReserve',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveOpenapiReserve: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLiveRealtimeLogDeliveryResponseBody extends $tea.Model {
  content?: ListLiveRealtimeLogDeliveryResponseBodyContent;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: ListLiveRealtimeLogDeliveryResponseBodyContent,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLiveRealtimeLogDeliveryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListLiveRealtimeLogDeliveryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListLiveRealtimeLogDeliveryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLiveRealtimeLogDeliveryDomainsRequest extends $tea.Model {
  logstore?: string;
  ownerId?: number;
  project?: string;
  region?: string;
  static names(): { [key: string]: string } {
    return {
      logstore: 'Logstore',
      ownerId: 'OwnerId',
      project: 'Project',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logstore: 'string',
      ownerId: 'number',
      project: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLiveRealtimeLogDeliveryDomainsResponseBody extends $tea.Model {
  content?: ListLiveRealtimeLogDeliveryDomainsResponseBodyContent;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: ListLiveRealtimeLogDeliveryDomainsResponseBodyContent,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLiveRealtimeLogDeliveryDomainsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListLiveRealtimeLogDeliveryDomainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListLiveRealtimeLogDeliveryDomainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLiveRealtimeLogDeliveryInfosRequest extends $tea.Model {
  liveOpenapiReserve?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      liveOpenapiReserve: 'LiveOpenapiReserve',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveOpenapiReserve: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLiveRealtimeLogDeliveryInfosResponseBody extends $tea.Model {
  content?: ListLiveRealtimeLogDeliveryInfosResponseBodyContent;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: ListLiveRealtimeLogDeliveryInfosResponseBodyContent,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLiveRealtimeLogDeliveryInfosResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListLiveRealtimeLogDeliveryInfosResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListLiveRealtimeLogDeliveryInfosResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageRequest extends $tea.Model {
  appId?: string;
  groupId?: string;
  pageNum?: number;
  pageSize?: number;
  sortType?: number;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      groupId: 'GroupId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      sortType: 'SortType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      groupId: 'string',
      pageNum: 'number',
      pageSize: 'number',
      sortType: 'number',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageResponseBody extends $tea.Model {
  requestId?: string;
  result?: ListMessageResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: ListMessageResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListMessageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListMessageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageAppRequest extends $tea.Model {
  pageNum?: number;
  pageSize?: number;
  sortType?: number;
  static names(): { [key: string]: string } {
    return {
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      sortType: 'SortType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNum: 'number',
      pageSize: 'number',
      sortType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageAppResponseBody extends $tea.Model {
  requestId?: string;
  result?: ListMessageAppResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: ListMessageAppResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageAppResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListMessageAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListMessageAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageGroupRequest extends $tea.Model {
  appId?: string;
  pageNum?: number;
  pageSize?: number;
  sortType?: number;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      sortType: 'SortType',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      pageNum: 'number',
      pageSize: 'number',
      sortType: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageGroupResponseBody extends $tea.Model {
  requestId?: string;
  result?: ListMessageGroupResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: ListMessageGroupResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListMessageGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListMessageGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageGroupUserRequest extends $tea.Model {
  appId?: string;
  groupId?: string;
  pageNum?: number;
  pageSize?: number;
  sortType?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      groupId: 'GroupId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      sortType: 'SortType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      groupId: 'string',
      pageNum: 'number',
      pageSize: 'number',
      sortType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageGroupUserResponseBody extends $tea.Model {
  requestId?: string;
  result?: ListMessageGroupUserResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: ListMessageGroupUserResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageGroupUserResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListMessageGroupUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListMessageGroupUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageGroupUserByIdRequest extends $tea.Model {
  appId?: string;
  groupId?: string;
  userIdList?: string[];
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      groupId: 'GroupId',
      userIdList: 'UserIdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      groupId: 'string',
      userIdList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageGroupUserByIdShrinkRequest extends $tea.Model {
  appId?: string;
  groupId?: string;
  userIdListShrink?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      groupId: 'GroupId',
      userIdListShrink: 'UserIdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      groupId: 'string',
      userIdListShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageGroupUserByIdResponseBody extends $tea.Model {
  requestId?: string;
  result?: ListMessageGroupUserByIdResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: ListMessageGroupUserByIdResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageGroupUserByIdResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListMessageGroupUserByIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListMessageGroupUserByIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPlaylistRequest extends $tea.Model {
  ownerId?: number;
  page?: number;
  pageSize?: number;
  programId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      page: 'Page',
      pageSize: 'PageSize',
      programId: 'ProgramId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      page: 'number',
      pageSize: 'number',
      programId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPlaylistResponseBody extends $tea.Model {
  programList?: ListPlaylistResponseBodyProgramList[];
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      programList: 'ProgramList',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      programList: { 'type': 'array', 'itemType': ListPlaylistResponseBodyProgramList },
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPlaylistResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListPlaylistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPlaylistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPlaylistItemsRequest extends $tea.Model {
  ownerId?: number;
  programId?: string;
  programItemIds?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      programId: 'ProgramId',
      programItemIds: 'ProgramItemIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      programId: 'string',
      programItemIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPlaylistItemsResponseBody extends $tea.Model {
  programItems?: ListPlaylistItemsResponseBodyProgramItems[];
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      programItems: 'ProgramItems',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      programItems: { 'type': 'array', 'itemType': ListPlaylistItemsResponseBodyProgramItems },
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPlaylistItemsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListPlaylistItemsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPlaylistItemsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCasterComponentRequest extends $tea.Model {
  captionLayerContent?: string;
  casterId?: string;
  componentId?: string;
  componentLayer?: string;
  componentName?: string;
  componentType?: string;
  effect?: string;
  imageLayerContent?: string;
  ownerId?: number;
  textLayerContent?: string;
  static names(): { [key: string]: string } {
    return {
      captionLayerContent: 'CaptionLayerContent',
      casterId: 'CasterId',
      componentId: 'ComponentId',
      componentLayer: 'ComponentLayer',
      componentName: 'ComponentName',
      componentType: 'ComponentType',
      effect: 'Effect',
      imageLayerContent: 'ImageLayerContent',
      ownerId: 'OwnerId',
      textLayerContent: 'TextLayerContent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      captionLayerContent: 'string',
      casterId: 'string',
      componentId: 'string',
      componentLayer: 'string',
      componentName: 'string',
      componentType: 'string',
      effect: 'string',
      imageLayerContent: 'string',
      ownerId: 'number',
      textLayerContent: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCasterComponentResponseBody extends $tea.Model {
  componentId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      componentId: 'ComponentId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      componentId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCasterComponentResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyCasterComponentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyCasterComponentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCasterEpisodeRequest extends $tea.Model {
  casterId?: string;
  componentId?: string[];
  endTime?: string;
  episodeId?: string;
  episodeName?: string;
  ownerId?: number;
  resourceId?: string;
  startTime?: string;
  switchType?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      componentId: 'ComponentId',
      endTime: 'EndTime',
      episodeId: 'EpisodeId',
      episodeName: 'EpisodeName',
      ownerId: 'OwnerId',
      resourceId: 'ResourceId',
      startTime: 'StartTime',
      switchType: 'SwitchType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      componentId: { 'type': 'array', 'itemType': 'string' },
      endTime: 'string',
      episodeId: 'string',
      episodeName: 'string',
      ownerId: 'number',
      resourceId: 'string',
      startTime: 'string',
      switchType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCasterEpisodeResponseBody extends $tea.Model {
  casterId?: string;
  episodeId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      episodeId: 'EpisodeId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      episodeId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCasterEpisodeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyCasterEpisodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyCasterEpisodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCasterLayoutRequest extends $tea.Model {
  audioLayer?: ModifyCasterLayoutRequestAudioLayer[];
  blendList?: string[];
  casterId?: string;
  layoutId?: string;
  mixList?: string[];
  ownerId?: number;
  videoLayer?: ModifyCasterLayoutRequestVideoLayer[];
  static names(): { [key: string]: string } {
    return {
      audioLayer: 'AudioLayer',
      blendList: 'BlendList',
      casterId: 'CasterId',
      layoutId: 'LayoutId',
      mixList: 'MixList',
      ownerId: 'OwnerId',
      videoLayer: 'VideoLayer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioLayer: { 'type': 'array', 'itemType': ModifyCasterLayoutRequestAudioLayer },
      blendList: { 'type': 'array', 'itemType': 'string' },
      casterId: 'string',
      layoutId: 'string',
      mixList: { 'type': 'array', 'itemType': 'string' },
      ownerId: 'number',
      videoLayer: { 'type': 'array', 'itemType': ModifyCasterLayoutRequestVideoLayer },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCasterLayoutResponseBody extends $tea.Model {
  layoutId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      layoutId: 'LayoutId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      layoutId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCasterLayoutResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyCasterLayoutResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyCasterLayoutResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCasterProgramRequest extends $tea.Model {
  casterId?: string;
  episode?: ModifyCasterProgramRequestEpisode[];
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      episode: 'Episode',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      episode: { 'type': 'array', 'itemType': ModifyCasterProgramRequestEpisode },
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCasterProgramResponseBody extends $tea.Model {
  casterId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCasterProgramResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyCasterProgramResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyCasterProgramResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCasterVideoResourceRequest extends $tea.Model {
  beginOffset?: number;
  casterId?: string;
  endOffset?: number;
  liveStreamUrl?: string;
  materialId?: string;
  ownerId?: number;
  ptsCallbackInterval?: number;
  repeatNum?: number;
  resourceId?: string;
  resourceName?: string;
  vodUrl?: string;
  static names(): { [key: string]: string } {
    return {
      beginOffset: 'BeginOffset',
      casterId: 'CasterId',
      endOffset: 'EndOffset',
      liveStreamUrl: 'LiveStreamUrl',
      materialId: 'MaterialId',
      ownerId: 'OwnerId',
      ptsCallbackInterval: 'PtsCallbackInterval',
      repeatNum: 'RepeatNum',
      resourceId: 'ResourceId',
      resourceName: 'ResourceName',
      vodUrl: 'VodUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      beginOffset: 'number',
      casterId: 'string',
      endOffset: 'number',
      liveStreamUrl: 'string',
      materialId: 'string',
      ownerId: 'number',
      ptsCallbackInterval: 'number',
      repeatNum: 'number',
      resourceId: 'string',
      resourceName: 'string',
      vodUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCasterVideoResourceResponseBody extends $tea.Model {
  casterId?: string;
  requestId?: string;
  resourceId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      requestId: 'RequestId',
      resourceId: 'ResourceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      requestId: 'string',
      resourceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCasterVideoResourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyCasterVideoResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyCasterVideoResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLiveDomainSchdmByPropertyRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  property?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      property: 'Property',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      property: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLiveDomainSchdmByPropertyResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLiveDomainSchdmByPropertyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyLiveDomainSchdmByPropertyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyLiveDomainSchdmByPropertyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLiveRealtimeLogDeliveryRequest extends $tea.Model {
  domainName?: string;
  logstore?: string;
  ownerId?: number;
  project?: string;
  region?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      logstore: 'Logstore',
      ownerId: 'OwnerId',
      project: 'Project',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      logstore: 'string',
      ownerId: 'number',
      project: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLiveRealtimeLogDeliveryResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLiveRealtimeLogDeliveryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyLiveRealtimeLogDeliveryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyLiveRealtimeLogDeliveryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyShowListRequest extends $tea.Model {
  casterId?: string;
  highPriorityShowId?: string;
  highPriorityShowStartTime?: string;
  ownerId?: number;
  repeatTimes?: number;
  showId?: string;
  spot?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      highPriorityShowId: 'HighPriorityShowId',
      highPriorityShowStartTime: 'HighPriorityShowStartTime',
      ownerId: 'OwnerId',
      repeatTimes: 'RepeatTimes',
      showId: 'ShowId',
      spot: 'Spot',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      highPriorityShowId: 'string',
      highPriorityShowStartTime: 'string',
      ownerId: 'number',
      repeatTimes: 'number',
      showId: 'string',
      spot: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyShowListResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyShowListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyShowListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyShowListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStudioLayoutRequest extends $tea.Model {
  bgImageConfig?: string;
  casterId?: string;
  commonConfig?: string;
  layerOrderConfigList?: string;
  layoutId?: string;
  layoutName?: string;
  mediaInputConfigList?: string;
  ownerId?: number;
  screenInputConfigList?: string;
  static names(): { [key: string]: string } {
    return {
      bgImageConfig: 'BgImageConfig',
      casterId: 'CasterId',
      commonConfig: 'CommonConfig',
      layerOrderConfigList: 'LayerOrderConfigList',
      layoutId: 'LayoutId',
      layoutName: 'LayoutName',
      mediaInputConfigList: 'MediaInputConfigList',
      ownerId: 'OwnerId',
      screenInputConfigList: 'ScreenInputConfigList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bgImageConfig: 'string',
      casterId: 'string',
      commonConfig: 'string',
      layerOrderConfigList: 'string',
      layoutId: 'string',
      layoutName: 'string',
      mediaInputConfigList: 'string',
      ownerId: 'number',
      screenInputConfigList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStudioLayoutResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStudioLayoutResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyStudioLayoutResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyStudioLayoutResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenLiveShiftRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  duration?: number;
  ignoreTranscode?: boolean;
  ownerId?: number;
  streamName?: string;
  vision?: number;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      duration: 'Duration',
      ignoreTranscode: 'IgnoreTranscode',
      ownerId: 'OwnerId',
      streamName: 'StreamName',
      vision: 'Vision',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      duration: 'number',
      ignoreTranscode: 'boolean',
      ownerId: 'number',
      streamName: 'string',
      vision: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenLiveShiftResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenLiveShiftResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: OpenLiveShiftResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OpenLiveShiftResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PlayChoosenShowRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  showId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
      showId: 'ShowId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
      showId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PlayChoosenShowResponseBody extends $tea.Model {
  requestId?: string;
  showId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      showId: 'ShowId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      showId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PlayChoosenShowResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: PlayChoosenShowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PlayChoosenShowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishLiveStagingConfigToProductionRequest extends $tea.Model {
  domainName?: string;
  functionName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      functionName: 'FunctionName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      functionName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishLiveStagingConfigToProductionResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishLiveStagingConfigToProductionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: PublishLiveStagingConfigToProductionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PublishLiveStagingConfigToProductionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMessageAppRequest extends $tea.Model {
  appId?: string;
  appName?: string;
  pageNum?: number;
  pageSize?: number;
  sortType?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      sortType: 'SortType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appName: 'string',
      pageNum: 'number',
      pageSize: 'number',
      sortType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMessageAppResponseBody extends $tea.Model {
  requestId?: string;
  result?: QueryMessageAppResponseBodyResult[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': QueryMessageAppResponseBodyResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMessageAppResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryMessageAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryMessageAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySnapshotCallbackAuthRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySnapshotCallbackAuthResponseBody extends $tea.Model {
  callbackAuthKey?: string;
  callbackReqAuth?: string;
  domainName?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      callbackAuthKey: 'CallbackAuthKey',
      callbackReqAuth: 'CallbackReqAuth',
      domainName: 'DomainName',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      callbackAuthKey: 'string',
      callbackReqAuth: 'string',
      domainName: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySnapshotCallbackAuthResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QuerySnapshotCallbackAuthResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySnapshotCallbackAuthResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RealTimeRecordCommandRequest extends $tea.Model {
  appName?: string;
  command?: string;
  domainName?: string;
  ownerId?: number;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      command: 'Command',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      command: 'string',
      domainName: 'string',
      ownerId: 'number',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RealTimeRecordCommandResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RealTimeRecordCommandResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RealTimeRecordCommandResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RealTimeRecordCommandResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RealTimeSnapshotCommandRequest extends $tea.Model {
  appName?: string;
  command?: string;
  domainName?: string;
  interval?: number;
  mode?: number;
  ownerId?: number;
  source?: number;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      command: 'Command',
      domainName: 'DomainName',
      interval: 'Interval',
      mode: 'Mode',
      ownerId: 'OwnerId',
      source: 'Source',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      command: 'string',
      domainName: 'string',
      interval: 'number',
      mode: 'number',
      ownerId: 'number',
      source: 'number',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RealTimeSnapshotCommandResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RealTimeSnapshotCommandResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RealTimeSnapshotCommandResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RealTimeSnapshotCommandResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveShowFromShowListRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  showId?: string;
  isBatchMode?: boolean;
  showIdList?: string[];
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
      showId: 'ShowId',
      isBatchMode: 'isBatchMode',
      showIdList: 'showIdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
      showId: 'string',
      isBatchMode: 'boolean',
      showIdList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveShowFromShowListResponseBody extends $tea.Model {
  requestId?: string;
  showId?: string;
  failedList?: string;
  successfulShowIds?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      showId: 'ShowId',
      failedList: 'failedList',
      successfulShowIds: 'successfulShowIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      showId: 'string',
      failedList: 'string',
      successfulShowIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveShowFromShowListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RemoveShowFromShowListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveShowFromShowListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RestartCasterRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RestartCasterResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RestartCasterResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RestartCasterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RestartCasterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeLiveStreamRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  liveStreamType?: string;
  ownerId?: number;
  securityToken?: string;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      liveStreamType: 'LiveStreamType',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      liveStreamType: 'string',
      ownerId: 'number',
      securityToken: 'string',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeLiveStreamResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeLiveStreamResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ResumeLiveStreamResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResumeLiveStreamResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RollbackLiveStagingConfigRequest extends $tea.Model {
  domainName?: string;
  functionName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      functionName: 'FunctionName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      functionName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RollbackLiveStagingConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RollbackLiveStagingConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RollbackLiveStagingConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RollbackLiveStagingConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendLikeRequest extends $tea.Model {
  appId?: string;
  broadCastType?: number;
  count?: string;
  groupId?: string;
  operatorUserId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      broadCastType: 'BroadCastType',
      count: 'Count',
      groupId: 'GroupId',
      operatorUserId: 'OperatorUserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      broadCastType: 'number',
      count: 'string',
      groupId: 'string',
      operatorUserId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendLikeResponseBody extends $tea.Model {
  requestId?: string;
  result?: SendLikeResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: SendLikeResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendLikeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SendLikeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SendLikeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendMessageToGroupRequest extends $tea.Model {
  appId?: string;
  data?: string;
  groupId?: string;
  operatorUserId?: string;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      data: 'Data',
      groupId: 'GroupId',
      operatorUserId: 'OperatorUserId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      data: 'string',
      groupId: 'string',
      operatorUserId: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendMessageToGroupResponseBody extends $tea.Model {
  requestId?: string;
  result?: SendMessageToGroupResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: SendMessageToGroupResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendMessageToGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SendMessageToGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SendMessageToGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendMessageToGroupUsersRequest extends $tea.Model {
  appId?: string;
  data?: string;
  groupId?: string;
  operatorUserId?: string;
  receiverIdList?: string[];
  type?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      data: 'Data',
      groupId: 'GroupId',
      operatorUserId: 'OperatorUserId',
      receiverIdList: 'ReceiverIdList',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      data: 'string',
      groupId: 'string',
      operatorUserId: 'string',
      receiverIdList: { 'type': 'array', 'itemType': 'string' },
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendMessageToGroupUsersShrinkRequest extends $tea.Model {
  appId?: string;
  data?: string;
  groupId?: string;
  operatorUserId?: string;
  receiverIdListShrink?: string;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      data: 'Data',
      groupId: 'GroupId',
      operatorUserId: 'OperatorUserId',
      receiverIdListShrink: 'ReceiverIdList',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      data: 'string',
      groupId: 'string',
      operatorUserId: 'string',
      receiverIdListShrink: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendMessageToGroupUsersResponseBody extends $tea.Model {
  requestId?: string;
  result?: SendMessageToGroupUsersResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: SendMessageToGroupUsersResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendMessageToGroupUsersResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SendMessageToGroupUsersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SendMessageToGroupUsersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendRoomNotificationRequest extends $tea.Model {
  appId?: string;
  appUid?: string;
  data?: string;
  ownerId?: number;
  priority?: number;
  roomId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appUid: 'AppUid',
      data: 'Data',
      ownerId: 'OwnerId',
      priority: 'Priority',
      roomId: 'RoomId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appUid: 'string',
      data: 'string',
      ownerId: 'number',
      priority: 'number',
      roomId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendRoomNotificationResponseBody extends $tea.Model {
  messageId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendRoomNotificationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SendRoomNotificationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SendRoomNotificationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendRoomUserNotificationRequest extends $tea.Model {
  appId?: string;
  appUid?: string;
  data?: string;
  ownerId?: number;
  priority?: number;
  roomId?: string;
  toAppUid?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appUid: 'AppUid',
      data: 'Data',
      ownerId: 'OwnerId',
      priority: 'Priority',
      roomId: 'RoomId',
      toAppUid: 'ToAppUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appUid: 'string',
      data: 'string',
      ownerId: 'number',
      priority: 'number',
      roomId: 'string',
      toAppUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendRoomUserNotificationResponseBody extends $tea.Model {
  messageId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendRoomUserNotificationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SendRoomUserNotificationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SendRoomUserNotificationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCasterChannelRequest extends $tea.Model {
  casterId?: string;
  channelId?: string;
  faceBeauty?: string;
  ownerId?: number;
  playStatus?: number;
  resourceId?: string;
  seekOffset?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      channelId: 'ChannelId',
      faceBeauty: 'FaceBeauty',
      ownerId: 'OwnerId',
      playStatus: 'PlayStatus',
      resourceId: 'ResourceId',
      seekOffset: 'SeekOffset',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      channelId: 'string',
      faceBeauty: 'string',
      ownerId: 'number',
      playStatus: 'number',
      resourceId: 'string',
      seekOffset: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCasterChannelResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCasterChannelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetCasterChannelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetCasterChannelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCasterConfigRequest extends $tea.Model {
  callbackUrl?: string;
  casterId?: string;
  casterName?: string;
  channelEnable?: number;
  delay?: number;
  domainName?: string;
  ownerId?: number;
  programEffect?: number;
  programName?: string;
  recordConfig?: string;
  sideOutputUrl?: string;
  sideOutputUrlList?: string;
  syncGroupsConfig?: string;
  transcodeConfig?: string;
  urgentLiveStreamUrl?: string;
  urgentMaterialId?: string;
  static names(): { [key: string]: string } {
    return {
      callbackUrl: 'CallbackUrl',
      casterId: 'CasterId',
      casterName: 'CasterName',
      channelEnable: 'ChannelEnable',
      delay: 'Delay',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      programEffect: 'ProgramEffect',
      programName: 'ProgramName',
      recordConfig: 'RecordConfig',
      sideOutputUrl: 'SideOutputUrl',
      sideOutputUrlList: 'SideOutputUrlList',
      syncGroupsConfig: 'SyncGroupsConfig',
      transcodeConfig: 'TranscodeConfig',
      urgentLiveStreamUrl: 'UrgentLiveStreamUrl',
      urgentMaterialId: 'UrgentMaterialId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      callbackUrl: 'string',
      casterId: 'string',
      casterName: 'string',
      channelEnable: 'number',
      delay: 'number',
      domainName: 'string',
      ownerId: 'number',
      programEffect: 'number',
      programName: 'string',
      recordConfig: 'string',
      sideOutputUrl: 'string',
      sideOutputUrlList: 'string',
      syncGroupsConfig: 'string',
      transcodeConfig: 'string',
      urgentLiveStreamUrl: 'string',
      urgentMaterialId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCasterConfigResponseBody extends $tea.Model {
  casterId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCasterConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetCasterConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetCasterConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCasterSceneConfigRequest extends $tea.Model {
  casterId?: string;
  componentId?: string[];
  layoutId?: string;
  ownerId?: number;
  sceneId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      componentId: 'ComponentId',
      layoutId: 'LayoutId',
      ownerId: 'OwnerId',
      sceneId: 'SceneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      componentId: { 'type': 'array', 'itemType': 'string' },
      layoutId: 'string',
      ownerId: 'number',
      sceneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCasterSceneConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCasterSceneConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetCasterSceneConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetCasterSceneConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCasterSyncGroupRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  syncGroup?: SetCasterSyncGroupRequestSyncGroup[];
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
      syncGroup: 'SyncGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
      syncGroup: { 'type': 'array', 'itemType': SetCasterSyncGroupRequestSyncGroup },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCasterSyncGroupResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCasterSyncGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetCasterSyncGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetCasterSyncGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCasterTimedEventRequest extends $tea.Model {
  casterId?: string;
  eventName?: string;
  ownerId?: number;
  startTimeUTC?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      eventName: 'EventName',
      ownerId: 'OwnerId',
      startTimeUTC: 'StartTimeUTC',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      eventName: 'string',
      ownerId: 'number',
      startTimeUTC: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCasterTimedEventResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCasterTimedEventResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetCasterTimedEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetCasterTimedEventResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetLiveDomainCertificateRequest extends $tea.Model {
  certName?: string;
  certType?: string;
  domainName?: string;
  forceSet?: string;
  ownerId?: number;
  SSLPri?: string;
  SSLProtocol?: string;
  SSLPub?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      certName: 'CertName',
      certType: 'CertType',
      domainName: 'DomainName',
      forceSet: 'ForceSet',
      ownerId: 'OwnerId',
      SSLPri: 'SSLPri',
      SSLProtocol: 'SSLProtocol',
      SSLPub: 'SSLPub',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certName: 'string',
      certType: 'string',
      domainName: 'string',
      forceSet: 'string',
      ownerId: 'number',
      SSLPri: 'string',
      SSLProtocol: 'string',
      SSLPub: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetLiveDomainCertificateResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetLiveDomainCertificateResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetLiveDomainCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetLiveDomainCertificateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetLiveDomainStagingConfigRequest extends $tea.Model {
  domainName?: string;
  functions?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      functions: 'Functions',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      functions: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetLiveDomainStagingConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetLiveDomainStagingConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetLiveDomainStagingConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetLiveDomainStagingConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetLiveEdgeTransferRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  httpDns?: string;
  ownerId?: number;
  streamName?: string;
  targetDomainList?: string;
  transferArgs?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      httpDns: 'HttpDns',
      ownerId: 'OwnerId',
      streamName: 'StreamName',
      targetDomainList: 'TargetDomainList',
      transferArgs: 'TransferArgs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      httpDns: 'string',
      ownerId: 'number',
      streamName: 'string',
      targetDomainList: 'string',
      transferArgs: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetLiveEdgeTransferResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetLiveEdgeTransferResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetLiveEdgeTransferResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetLiveEdgeTransferResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetLiveLazyPullStreamInfoConfigRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  ownerId?: number;
  pullAppName?: string;
  pullDomainName?: string;
  pullProtocol?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      pullAppName: 'PullAppName',
      pullDomainName: 'PullDomainName',
      pullProtocol: 'PullProtocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      ownerId: 'number',
      pullAppName: 'string',
      pullDomainName: 'string',
      pullProtocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetLiveLazyPullStreamInfoConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetLiveLazyPullStreamInfoConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetLiveLazyPullStreamInfoConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetLiveLazyPullStreamInfoConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetLiveStreamDelayConfigRequest extends $tea.Model {
  domainName?: string;
  flvDelay?: number;
  flvLevel?: string;
  hlsDelay?: number;
  hlsLevel?: string;
  ownerId?: number;
  rtmpDelay?: number;
  rtmpLevel?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      flvDelay: 'FlvDelay',
      flvLevel: 'FlvLevel',
      hlsDelay: 'HlsDelay',
      hlsLevel: 'HlsLevel',
      ownerId: 'OwnerId',
      rtmpDelay: 'RtmpDelay',
      rtmpLevel: 'RtmpLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      flvDelay: 'number',
      flvLevel: 'string',
      hlsDelay: 'number',
      hlsLevel: 'string',
      ownerId: 'number',
      rtmpDelay: 'number',
      rtmpLevel: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetLiveStreamDelayConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetLiveStreamDelayConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetLiveStreamDelayConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetLiveStreamDelayConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetLiveStreamOptimizedFeatureConfigRequest extends $tea.Model {
  configName?: string;
  configStatus?: string;
  configValue?: string;
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      configName: 'ConfigName',
      configStatus: 'ConfigStatus',
      configValue: 'ConfigValue',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configName: 'string',
      configStatus: 'string',
      configValue: 'string',
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetLiveStreamOptimizedFeatureConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetLiveStreamOptimizedFeatureConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetLiveStreamOptimizedFeatureConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetLiveStreamOptimizedFeatureConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetLiveStreamsNotifyUrlConfigRequest extends $tea.Model {
  domainName?: string;
  notifyAuthKey?: string;
  notifyReqAuth?: string;
  notifyUrl?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      notifyAuthKey: 'NotifyAuthKey',
      notifyReqAuth: 'NotifyReqAuth',
      notifyUrl: 'NotifyUrl',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      notifyAuthKey: 'string',
      notifyReqAuth: 'string',
      notifyUrl: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetLiveStreamsNotifyUrlConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetLiveStreamsNotifyUrlConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetLiveStreamsNotifyUrlConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetLiveStreamsNotifyUrlConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetSnapshotCallbackAuthRequest extends $tea.Model {
  callbackAuthKey?: string;
  callbackReqAuth?: string;
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      callbackAuthKey: 'CallbackAuthKey',
      callbackReqAuth: 'CallbackReqAuth',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      callbackAuthKey: 'string',
      callbackReqAuth: 'string',
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetSnapshotCallbackAuthResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetSnapshotCallbackAuthResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetSnapshotCallbackAuthResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetSnapshotCallbackAuthResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCasterRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCasterResponseBody extends $tea.Model {
  pgmSceneInfos?: StartCasterResponseBodyPgmSceneInfos;
  pvwSceneInfos?: StartCasterResponseBodyPvwSceneInfos;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pgmSceneInfos: 'PgmSceneInfos',
      pvwSceneInfos: 'PvwSceneInfos',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pgmSceneInfos: StartCasterResponseBodyPgmSceneInfos,
      pvwSceneInfos: StartCasterResponseBodyPvwSceneInfos,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCasterResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: StartCasterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartCasterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCasterSceneRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  sceneId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
      sceneId: 'SceneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
      sceneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCasterSceneResponseBody extends $tea.Model {
  requestId?: string;
  streamUrl?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      streamUrl: 'StreamUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      streamUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCasterSceneResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: StartCasterSceneResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartCasterSceneResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartLiveDomainRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartLiveDomainResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartLiveDomainResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: StartLiveDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartLiveDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartLiveStreamMonitorRequest extends $tea.Model {
  monitorId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      monitorId: 'MonitorId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartLiveStreamMonitorResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartLiveStreamMonitorResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: StartLiveStreamMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartLiveStreamMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartPlaylistRequest extends $tea.Model {
  offset?: number;
  ownerId?: number;
  programId?: string;
  resumeMode?: string;
  startItemId?: string;
  static names(): { [key: string]: string } {
    return {
      offset: 'Offset',
      ownerId: 'OwnerId',
      programId: 'ProgramId',
      resumeMode: 'ResumeMode',
      startItemId: 'StartItemId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      offset: 'number',
      ownerId: 'number',
      programId: 'string',
      resumeMode: 'string',
      startItemId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartPlaylistResponseBody extends $tea.Model {
  programId?: string;
  requestId?: string;
  streamInfo?: StartPlaylistResponseBodyStreamInfo;
  static names(): { [key: string]: string } {
    return {
      programId: 'ProgramId',
      requestId: 'RequestId',
      streamInfo: 'StreamInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      programId: 'string',
      requestId: 'string',
      streamInfo: StartPlaylistResponseBodyStreamInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartPlaylistResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: StartPlaylistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartPlaylistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopCasterRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopCasterResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopCasterResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: StopCasterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopCasterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopCasterSceneRequest extends $tea.Model {
  casterId?: string;
  ownerId?: number;
  sceneId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      ownerId: 'OwnerId',
      sceneId: 'SceneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      ownerId: 'number',
      sceneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopCasterSceneResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopCasterSceneResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: StopCasterSceneResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopCasterSceneResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopLiveDomainRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopLiveDomainResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopLiveDomainResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: StopLiveDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopLiveDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopLiveStreamMonitorRequest extends $tea.Model {
  monitorId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      monitorId: 'MonitorId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopLiveStreamMonitorResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopLiveStreamMonitorResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: StopLiveStreamMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopLiveStreamMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopPlaylistRequest extends $tea.Model {
  ownerId?: number;
  programId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      programId: 'ProgramId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      programId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopPlaylistResponseBody extends $tea.Model {
  programId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      programId: 'ProgramId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      programId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopPlaylistResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: StopPlaylistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopPlaylistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagLiveResourcesRequest extends $tea.Model {
  ownerId?: number;
  resourceId?: string[];
  resourceType?: string;
  tag?: TagLiveResourcesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tag: { 'type': 'array', 'itemType': TagLiveResourcesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagLiveResourcesResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagLiveResourcesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: TagLiveResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TagLiveResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnTagLiveResourcesRequest extends $tea.Model {
  all?: boolean;
  ownerId?: number;
  resourceId?: string[];
  resourceType?: string;
  tagKey?: string[];
  static names(): { [key: string]: string } {
    return {
      all: 'All',
      ownerId: 'OwnerId',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      all: 'boolean',
      ownerId: 'number',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tagKey: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnTagLiveResourcesResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnTagLiveResourcesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UnTagLiveResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UnTagLiveResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCasterSceneAudioRequest extends $tea.Model {
  audioLayer?: UpdateCasterSceneAudioRequestAudioLayer[];
  casterId?: string;
  followEnable?: number;
  mixList?: string[];
  ownerId?: number;
  sceneId?: string;
  static names(): { [key: string]: string } {
    return {
      audioLayer: 'AudioLayer',
      casterId: 'CasterId',
      followEnable: 'FollowEnable',
      mixList: 'MixList',
      ownerId: 'OwnerId',
      sceneId: 'SceneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioLayer: { 'type': 'array', 'itemType': UpdateCasterSceneAudioRequestAudioLayer },
      casterId: 'string',
      followEnable: 'number',
      mixList: { 'type': 'array', 'itemType': 'string' },
      ownerId: 'number',
      sceneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCasterSceneAudioResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCasterSceneAudioResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateCasterSceneAudioResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCasterSceneAudioResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCasterSceneConfigRequest extends $tea.Model {
  casterId?: string;
  componentId?: string[];
  layoutId?: string;
  ownerId?: number;
  sceneId?: string;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      componentId: 'ComponentId',
      layoutId: 'LayoutId',
      ownerId: 'OwnerId',
      sceneId: 'SceneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      componentId: { 'type': 'array', 'itemType': 'string' },
      layoutId: 'string',
      ownerId: 'number',
      sceneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCasterSceneConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCasterSceneConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateCasterSceneConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCasterSceneConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveAppSnapshotConfigRequest extends $tea.Model {
  appName?: string;
  callback?: string;
  domainName?: string;
  ossBucket?: string;
  ossEndpoint?: string;
  overwriteOssObject?: string;
  ownerId?: number;
  securityToken?: string;
  sequenceOssObject?: string;
  timeInterval?: number;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      callback: 'Callback',
      domainName: 'DomainName',
      ossBucket: 'OssBucket',
      ossEndpoint: 'OssEndpoint',
      overwriteOssObject: 'OverwriteOssObject',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
      sequenceOssObject: 'SequenceOssObject',
      timeInterval: 'TimeInterval',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      callback: 'string',
      domainName: 'string',
      ossBucket: 'string',
      ossEndpoint: 'string',
      overwriteOssObject: 'string',
      ownerId: 'number',
      securityToken: 'string',
      sequenceOssObject: 'string',
      timeInterval: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveAppSnapshotConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveAppSnapshotConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateLiveAppSnapshotConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateLiveAppSnapshotConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveAudioAuditConfigRequest extends $tea.Model {
  appName?: string;
  bizType?: string;
  domainName?: string;
  ossBucket?: string;
  ossEndpoint?: string;
  ossObject?: string;
  ownerId?: number;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      bizType: 'BizType',
      domainName: 'DomainName',
      ossBucket: 'OssBucket',
      ossEndpoint: 'OssEndpoint',
      ossObject: 'OssObject',
      ownerId: 'OwnerId',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      bizType: 'string',
      domainName: 'string',
      ossBucket: 'string',
      ossEndpoint: 'string',
      ossObject: 'string',
      ownerId: 'number',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveAudioAuditConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveAudioAuditConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateLiveAudioAuditConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateLiveAudioAuditConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveAudioAuditNotifyConfigRequest extends $tea.Model {
  callback?: string;
  callbackTemplate?: string;
  domainName?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      callback: 'Callback',
      callbackTemplate: 'CallbackTemplate',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      callback: 'string',
      callbackTemplate: 'string',
      domainName: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveAudioAuditNotifyConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveAudioAuditNotifyConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateLiveAudioAuditNotifyConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateLiveAudioAuditNotifyConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveDetectNotifyConfigRequest extends $tea.Model {
  domainName?: string;
  notifyUrl?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      notifyUrl: 'NotifyUrl',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      notifyUrl: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveDetectNotifyConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveDetectNotifyConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateLiveDetectNotifyConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateLiveDetectNotifyConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLivePullStreamInfoConfigRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  endTime?: string;
  ownerId?: number;
  sourceUrl?: string;
  startTime?: string;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      endTime: 'EndTime',
      ownerId: 'OwnerId',
      sourceUrl: 'SourceUrl',
      startTime: 'StartTime',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      endTime: 'string',
      ownerId: 'number',
      sourceUrl: 'string',
      startTime: 'string',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLivePullStreamInfoConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLivePullStreamInfoConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateLivePullStreamInfoConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateLivePullStreamInfoConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveRecordNotifyConfigRequest extends $tea.Model {
  domainName?: string;
  needStatusNotify?: boolean;
  notifyUrl?: string;
  onDemandUrl?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      needStatusNotify: 'NeedStatusNotify',
      notifyUrl: 'NotifyUrl',
      onDemandUrl: 'OnDemandUrl',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      needStatusNotify: 'boolean',
      notifyUrl: 'string',
      onDemandUrl: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveRecordNotifyConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveRecordNotifyConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateLiveRecordNotifyConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateLiveRecordNotifyConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveSnapshotDetectPornConfigRequest extends $tea.Model {
  appName?: string;
  domainName?: string;
  interval?: number;
  ossBucket?: string;
  ossEndpoint?: string;
  ossObject?: string;
  ownerId?: number;
  scene?: string[];
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      interval: 'Interval',
      ossBucket: 'OssBucket',
      ossEndpoint: 'OssEndpoint',
      ossObject: 'OssObject',
      ownerId: 'OwnerId',
      scene: 'Scene',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      interval: 'number',
      ossBucket: 'string',
      ossEndpoint: 'string',
      ossObject: 'string',
      ownerId: 'number',
      scene: { 'type': 'array', 'itemType': 'string' },
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveSnapshotDetectPornConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveSnapshotDetectPornConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateLiveSnapshotDetectPornConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateLiveSnapshotDetectPornConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveSnapshotNotifyConfigRequest extends $tea.Model {
  domainName?: string;
  notifyAuthKey?: string;
  notifyReqAuth?: string;
  notifyUrl?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      notifyAuthKey: 'NotifyAuthKey',
      notifyReqAuth: 'NotifyReqAuth',
      notifyUrl: 'NotifyUrl',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      notifyAuthKey: 'string',
      notifyReqAuth: 'string',
      notifyUrl: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveSnapshotNotifyConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveSnapshotNotifyConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateLiveSnapshotNotifyConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateLiveSnapshotNotifyConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveStreamMonitorRequest extends $tea.Model {
  app?: string;
  domain?: string;
  inputList?: string;
  monitorId?: string;
  monitorName?: string;
  outputTemplate?: string;
  ownerId?: number;
  stream?: string;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      domain: 'Domain',
      inputList: 'InputList',
      monitorId: 'MonitorId',
      monitorName: 'MonitorName',
      outputTemplate: 'OutputTemplate',
      ownerId: 'OwnerId',
      stream: 'Stream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      domain: 'string',
      inputList: 'string',
      monitorId: 'string',
      monitorName: 'string',
      outputTemplate: 'string',
      ownerId: 'number',
      stream: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveStreamMonitorResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveStreamMonitorResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateLiveStreamMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateLiveStreamMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveStreamWatermarkRequest extends $tea.Model {
  description?: string;
  height?: number;
  name?: string;
  offsetCorner?: string;
  ownerId?: number;
  pictureUrl?: string;
  refHeight?: number;
  refWidth?: number;
  templateId?: string;
  transparency?: number;
  XOffset?: number;
  YOffset?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      height: 'Height',
      name: 'Name',
      offsetCorner: 'OffsetCorner',
      ownerId: 'OwnerId',
      pictureUrl: 'PictureUrl',
      refHeight: 'RefHeight',
      refWidth: 'RefWidth',
      templateId: 'TemplateId',
      transparency: 'Transparency',
      XOffset: 'XOffset',
      YOffset: 'YOffset',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      height: 'number',
      name: 'string',
      offsetCorner: 'string',
      ownerId: 'number',
      pictureUrl: 'string',
      refHeight: 'number',
      refWidth: 'number',
      templateId: 'string',
      transparency: 'number',
      XOffset: 'number',
      YOffset: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveStreamWatermarkResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveStreamWatermarkResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateLiveStreamWatermarkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateLiveStreamWatermarkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveStreamWatermarkRuleRequest extends $tea.Model {
  description?: string;
  name?: string;
  ownerId?: number;
  ruleId?: string;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      ownerId: 'OwnerId',
      ruleId: 'RuleId',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      ownerId: 'number',
      ruleId: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveStreamWatermarkRuleResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveStreamWatermarkRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateLiveStreamWatermarkRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateLiveStreamWatermarkRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveTopLevelDomainRequest extends $tea.Model {
  domainName?: string;
  securityToken?: string;
  topLevelDomain?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      securityToken: 'SecurityToken',
      topLevelDomain: 'TopLevelDomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      securityToken: 'string',
      topLevelDomain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveTopLevelDomainResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveTopLevelDomainResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateLiveTopLevelDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateLiveTopLevelDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMessageAppRequest extends $tea.Model {
  appConfig?: { [key: string]: string };
  appId?: string;
  appName?: string;
  extension?: { [key: string]: string };
  static names(): { [key: string]: string } {
    return {
      appConfig: 'AppConfig',
      appId: 'AppId',
      appName: 'AppName',
      extension: 'Extension',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      appId: 'string',
      appName: 'string',
      extension: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMessageAppShrinkRequest extends $tea.Model {
  appConfigShrink?: string;
  appId?: string;
  appName?: string;
  extensionShrink?: string;
  static names(): { [key: string]: string } {
    return {
      appConfigShrink: 'AppConfig',
      appId: 'AppId',
      appName: 'AppName',
      extensionShrink: 'Extension',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appConfigShrink: 'string',
      appId: 'string',
      appName: 'string',
      extensionShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMessageAppResponseBody extends $tea.Model {
  requestId?: string;
  result?: UpdateMessageAppResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: UpdateMessageAppResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMessageAppResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateMessageAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateMessageAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMessageGroupRequest extends $tea.Model {
  appId?: string;
  extension?: { [key: string]: string };
  groupId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      extension: 'Extension',
      groupId: 'GroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      extension: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      groupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMessageGroupShrinkRequest extends $tea.Model {
  appId?: string;
  extensionShrink?: string;
  groupId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      extensionShrink: 'Extension',
      groupId: 'GroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      extensionShrink: 'string',
      groupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMessageGroupResponseBody extends $tea.Model {
  requestId?: string;
  result?: UpdateMessageGroupResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: UpdateMessageGroupResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMessageGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateMessageGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateMessageGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMixStreamRequest extends $tea.Model {
  domainName?: string;
  inputStreamList?: string;
  layoutId?: string;
  mixStreamId?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      inputStreamList: 'InputStreamList',
      layoutId: 'LayoutId',
      mixStreamId: 'MixStreamId',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      inputStreamList: 'string',
      layoutId: 'string',
      mixStreamId: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMixStreamResponseBody extends $tea.Model {
  mixStreamId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      mixStreamId: 'MixStreamId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mixStreamId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMixStreamResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateMixStreamResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateMixStreamResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class VerifyLiveDomainOwnerRequest extends $tea.Model {
  domainName?: string;
  ownerId?: number;
  verifyType?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      verifyType: 'VerifyType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      verifyType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class VerifyLiveDomainOwnerResponseBody extends $tea.Model {
  content?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class VerifyLiveDomainOwnerResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: VerifyLiveDomainOwnerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: VerifyLiveDomainOwnerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterEpisodeGroupRequestItem extends $tea.Model {
  itemName?: string;
  vodUrl?: string;
  static names(): { [key: string]: string } {
    return {
      itemName: 'ItemName',
      vodUrl: 'VodUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemName: 'string',
      vodUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterEpisodeGroupResponseBodyItemIds extends $tea.Model {
  itemId?: string[];
  static names(): { [key: string]: string } {
    return {
      itemId: 'ItemId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterEpisodeGroupContentResponseBodyItemIds extends $tea.Model {
  itemId?: string[];
  static names(): { [key: string]: string } {
    return {
      itemId: 'ItemId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterLayoutRequestAudioLayer extends $tea.Model {
  fixedDelayDuration?: number;
  validChannel?: string;
  volumeRate?: number;
  static names(): { [key: string]: string } {
    return {
      fixedDelayDuration: 'FixedDelayDuration',
      validChannel: 'ValidChannel',
      volumeRate: 'VolumeRate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fixedDelayDuration: 'number',
      validChannel: 'string',
      volumeRate: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterLayoutRequestVideoLayer extends $tea.Model {
  fillMode?: string;
  fixedDelayDuration?: number;
  heightNormalized?: number;
  positionNormalized?: number[];
  positionRefer?: string;
  widthNormalized?: number;
  static names(): { [key: string]: string } {
    return {
      fillMode: 'FillMode',
      fixedDelayDuration: 'FixedDelayDuration',
      heightNormalized: 'HeightNormalized',
      positionNormalized: 'PositionNormalized',
      positionRefer: 'PositionRefer',
      widthNormalized: 'WidthNormalized',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fillMode: 'string',
      fixedDelayDuration: 'number',
      heightNormalized: 'number',
      positionNormalized: { 'type': 'array', 'itemType': 'number' },
      positionRefer: 'string',
      widthNormalized: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterProgramRequestEpisode extends $tea.Model {
  componentId?: string[];
  endTime?: string;
  episodeName?: string;
  episodeType?: string;
  resourceId?: string;
  startTime?: string;
  switchType?: string;
  static names(): { [key: string]: string } {
    return {
      componentId: 'ComponentId',
      endTime: 'EndTime',
      episodeName: 'EpisodeName',
      episodeType: 'EpisodeType',
      resourceId: 'ResourceId',
      startTime: 'StartTime',
      switchType: 'SwitchType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      componentId: { 'type': 'array', 'itemType': 'string' },
      endTime: 'string',
      episodeName: 'string',
      episodeType: 'string',
      resourceId: 'string',
      startTime: 'string',
      switchType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterProgramResponseBodyEpisodeIdsEpisodeId extends $tea.Model {
  episodeId?: string;
  static names(): { [key: string]: string } {
    return {
      episodeId: 'EpisodeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      episodeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCasterProgramResponseBodyEpisodeIds extends $tea.Model {
  episodeId?: AddCasterProgramResponseBodyEpisodeIdsEpisodeId[];
  static names(): { [key: string]: string } {
    return {
      episodeId: 'EpisodeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      episodeId: { 'type': 'array', 'itemType': AddCasterProgramResponseBodyEpisodeIdsEpisodeId },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveAppRecordConfigRequestRecordFormat extends $tea.Model {
  cycleDuration?: number;
  format?: string;
  ossObjectPrefix?: string;
  sliceDuration?: number;
  sliceOssObjectPrefix?: string;
  static names(): { [key: string]: string } {
    return {
      cycleDuration: 'CycleDuration',
      format: 'Format',
      ossObjectPrefix: 'OssObjectPrefix',
      sliceDuration: 'SliceDuration',
      sliceOssObjectPrefix: 'SliceOssObjectPrefix',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cycleDuration: 'number',
      format: 'string',
      ossObjectPrefix: 'string',
      sliceDuration: 'number',
      sliceOssObjectPrefix: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLiveAppRecordConfigRequestTranscodeRecordFormat extends $tea.Model {
  cycleDuration?: number;
  format?: string;
  ossObjectPrefix?: string;
  sliceDuration?: number;
  sliceOssObjectPrefix?: string;
  static names(): { [key: string]: string } {
    return {
      cycleDuration: 'CycleDuration',
      format: 'Format',
      ossObjectPrefix: 'OssObjectPrefix',
      sliceDuration: 'SliceDuration',
      sliceOssObjectPrefix: 'SliceOssObjectPrefix',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cycleDuration: 'number',
      format: 'string',
      ossObjectPrefix: 'string',
      sliceDuration: 'number',
      sliceOssObjectPrefix: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMultiRateConfigResponseBodyBodyFailedTemplates extends $tea.Model {
  audioBitrate?: number;
  audioChannelNum?: number;
  audioCodec?: string;
  audioProfile?: string;
  audioRate?: number;
  bandWidth?: number;
  fps?: number;
  gop?: string;
  height?: number;
  profile?: number;
  template?: string;
  templateType?: string;
  videoBitrate?: number;
  width?: number;
  static names(): { [key: string]: string } {
    return {
      audioBitrate: 'AudioBitrate',
      audioChannelNum: 'AudioChannelNum',
      audioCodec: 'AudioCodec',
      audioProfile: 'AudioProfile',
      audioRate: 'AudioRate',
      bandWidth: 'BandWidth',
      fps: 'Fps',
      gop: 'Gop',
      height: 'Height',
      profile: 'Profile',
      template: 'Template',
      templateType: 'TemplateType',
      videoBitrate: 'VideoBitrate',
      width: 'Width',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioBitrate: 'number',
      audioChannelNum: 'number',
      audioCodec: 'string',
      audioProfile: 'string',
      audioRate: 'number',
      bandWidth: 'number',
      fps: 'number',
      gop: 'string',
      height: 'number',
      profile: 'number',
      template: 'string',
      templateType: 'string',
      videoBitrate: 'number',
      width: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMultiRateConfigResponseBodyBody extends $tea.Model {
  failedTemplates?: AddMultiRateConfigResponseBodyBodyFailedTemplates[];
  static names(): { [key: string]: string } {
    return {
      failedTemplates: 'FailedTemplates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedTemplates: { 'type': 'array', 'itemType': AddMultiRateConfigResponseBodyBodyFailedTemplates },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPlaylistItemsResponseBodyItemsFailedItems extends $tea.Model {
  itemId?: string;
  itemName?: string;
  static names(): { [key: string]: string } {
    return {
      itemId: 'ItemId',
      itemName: 'ItemName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemId: 'string',
      itemName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPlaylistItemsResponseBodyItemsSuccessItems extends $tea.Model {
  itemId?: string;
  itemName?: string;
  static names(): { [key: string]: string } {
    return {
      itemId: 'ItemId',
      itemName: 'ItemName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemId: 'string',
      itemName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPlaylistItemsResponseBodyItems extends $tea.Model {
  failedItems?: AddPlaylistItemsResponseBodyItemsFailedItems[];
  successItems?: AddPlaylistItemsResponseBodyItemsSuccessItems[];
  static names(): { [key: string]: string } {
    return {
      failedItems: 'FailedItems',
      successItems: 'SuccessItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedItems: { 'type': 'array', 'itemType': AddPlaylistItemsResponseBodyItemsFailedItems },
      successItems: { 'type': 'array', 'itemType': AddPlaylistItemsResponseBodyItemsSuccessItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddShowIntoShowListRequestShowList extends $tea.Model {
  duration?: number;
  liveInputType?: number;
  repeatTimes?: number;
  resourceId?: string;
  resourceType?: string;
  resourceUrl?: string;
  showName?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'duration',
      liveInputType: 'liveInputType',
      repeatTimes: 'repeatTimes',
      resourceId: 'resourceId',
      resourceType: 'resourceType',
      resourceUrl: 'resourceUrl',
      showName: 'showName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'number',
      liveInputType: 'number',
      repeatTimes: 'number',
      resourceId: 'string',
      resourceType: 'string',
      resourceUrl: 'string',
      showName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelMuteAllGroupUserResponseBodyResult extends $tea.Model {
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLiveStreamRecordIndexFilesResponseBodyRecordInfo extends $tea.Model {
  appName?: string;
  createTime?: string;
  domainName?: string;
  duration?: number;
  endTime?: string;
  height?: number;
  ossBucket?: string;
  ossEndpoint?: string;
  ossObject?: string;
  recordId?: string;
  recordUrl?: string;
  startTime?: string;
  streamName?: string;
  width?: number;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      createTime: 'CreateTime',
      domainName: 'DomainName',
      duration: 'Duration',
      endTime: 'EndTime',
      height: 'Height',
      ossBucket: 'OssBucket',
      ossEndpoint: 'OssEndpoint',
      ossObject: 'OssObject',
      recordId: 'RecordId',
      recordUrl: 'RecordUrl',
      startTime: 'StartTime',
      streamName: 'StreamName',
      width: 'Width',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      createTime: 'string',
      domainName: 'string',
      duration: 'number',
      endTime: 'string',
      height: 'number',
      ossBucket: 'string',
      ossEndpoint: 'string',
      ossObject: 'string',
      recordId: 'string',
      recordUrl: 'string',
      startTime: 'string',
      streamName: 'string',
      width: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMessageAppResponseBodyResult extends $tea.Model {
  appId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMessageGroupResponseBodyResult extends $tea.Model {
  extension?: { [key: string]: any };
  groupId?: string;
  static names(): { [key: string]: string } {
    return {
      extension: 'Extension',
      groupId: 'GroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extension: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      groupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo extends $tea.Model {
  message?: string;
  recordId?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      recordId: 'RecordId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      recordId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoList extends $tea.Model {
  recordDeleteInfo?: DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo[];
  static names(): { [key: string]: string } {
    return {
      recordDeleteInfo: 'RecordDeleteInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordDeleteInfo: { 'type': 'array', 'itemType': DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMessageAppResponseBodyResult extends $tea.Model {
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo extends $tea.Model {
  createTimestamp?: number;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      createTimestamp: 'CreateTimestamp',
      message: 'Message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTimestamp: 'number',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSnapshotFilesResponseBodySnapshotDeleteInfoList extends $tea.Model {
  snapshotDeleteInfo?: DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo[];
  static names(): { [key: string]: string } {
    return {
      snapshotDeleteInfo: 'SnapshotDeleteInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      snapshotDeleteInfo: { 'type': 'array', 'itemType': DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterChannelsResponseBodyChannelsChannel extends $tea.Model {
  channelId?: string;
  faceBeauty?: string;
  resourceId?: string;
  rtmpUrl?: string;
  streamUrl?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      faceBeauty: 'FaceBeauty',
      resourceId: 'ResourceId',
      rtmpUrl: 'RtmpUrl',
      streamUrl: 'StreamUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      faceBeauty: 'string',
      resourceId: 'string',
      rtmpUrl: 'string',
      streamUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterChannelsResponseBodyChannels extends $tea.Model {
  channel?: DescribeCasterChannelsResponseBodyChannelsChannel[];
  static names(): { [key: string]: string } {
    return {
      channel: 'Channel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channel: { 'type': 'array', 'itemType': DescribeCasterChannelsResponseBodyChannelsChannel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterComponentsResponseBodyComponentsComponentCaptionLayerContent extends $tea.Model {
  borderColor?: string;
  borderWidthNormalized?: number;
  color?: string;
  fontName?: string;
  lineSpaceNormalized?: number;
  locationId?: string;
  ptsOffset?: number;
  showSourceLan?: boolean;
  sizeNormalized?: number;
  sourceLan?: string;
  targetLan?: string;
  wordCountPerLine?: number;
  wordSpaceNormalized?: number;
  wordsCount?: number;
  static names(): { [key: string]: string } {
    return {
      borderColor: 'BorderColor',
      borderWidthNormalized: 'BorderWidthNormalized',
      color: 'Color',
      fontName: 'FontName',
      lineSpaceNormalized: 'LineSpaceNormalized',
      locationId: 'LocationId',
      ptsOffset: 'PtsOffset',
      showSourceLan: 'ShowSourceLan',
      sizeNormalized: 'SizeNormalized',
      sourceLan: 'SourceLan',
      targetLan: 'TargetLan',
      wordCountPerLine: 'WordCountPerLine',
      wordSpaceNormalized: 'WordSpaceNormalized',
      wordsCount: 'WordsCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      borderColor: 'string',
      borderWidthNormalized: 'number',
      color: 'string',
      fontName: 'string',
      lineSpaceNormalized: 'number',
      locationId: 'string',
      ptsOffset: 'number',
      showSourceLan: 'boolean',
      sizeNormalized: 'number',
      sourceLan: 'string',
      targetLan: 'string',
      wordCountPerLine: 'number',
      wordSpaceNormalized: 'number',
      wordsCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterComponentsResponseBodyComponentsComponentComponentLayerPositionNormalizeds extends $tea.Model {
  position?: number[];
  static names(): { [key: string]: string } {
    return {
      position: 'Position',
    };
  }

  static types(): { [key: string]: any } {
    return {
      position: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterComponentsResponseBodyComponentsComponentComponentLayer extends $tea.Model {
  heightNormalized?: number;
  positionNormalizeds?: DescribeCasterComponentsResponseBodyComponentsComponentComponentLayerPositionNormalizeds;
  positionRefer?: string;
  transparency?: number;
  widthNormalized?: number;
  static names(): { [key: string]: string } {
    return {
      heightNormalized: 'HeightNormalized',
      positionNormalizeds: 'PositionNormalizeds',
      positionRefer: 'PositionRefer',
      transparency: 'Transparency',
      widthNormalized: 'WidthNormalized',
    };
  }

  static types(): { [key: string]: any } {
    return {
      heightNormalized: 'number',
      positionNormalizeds: DescribeCasterComponentsResponseBodyComponentsComponentComponentLayerPositionNormalizeds,
      positionRefer: 'string',
      transparency: 'number',
      widthNormalized: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterComponentsResponseBodyComponentsComponentImageLayerContent extends $tea.Model {
  materialId?: string;
  static names(): { [key: string]: string } {
    return {
      materialId: 'MaterialId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      materialId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterComponentsResponseBodyComponentsComponentTextLayerContent extends $tea.Model {
  borderColor?: string;
  borderWidthNormalized?: number;
  color?: string;
  fontName?: string;
  sizeNormalized?: number;
  text?: string;
  static names(): { [key: string]: string } {
    return {
      borderColor: 'BorderColor',
      borderWidthNormalized: 'BorderWidthNormalized',
      color: 'Color',
      fontName: 'FontName',
      sizeNormalized: 'SizeNormalized',
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      borderColor: 'string',
      borderWidthNormalized: 'number',
      color: 'string',
      fontName: 'string',
      sizeNormalized: 'number',
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterComponentsResponseBodyComponentsComponent extends $tea.Model {
  captionLayerContent?: DescribeCasterComponentsResponseBodyComponentsComponentCaptionLayerContent;
  componentId?: string;
  componentLayer?: DescribeCasterComponentsResponseBodyComponentsComponentComponentLayer;
  componentName?: string;
  componentType?: string;
  effect?: string;
  imageLayerContent?: DescribeCasterComponentsResponseBodyComponentsComponentImageLayerContent;
  locationId?: string;
  textLayerContent?: DescribeCasterComponentsResponseBodyComponentsComponentTextLayerContent;
  static names(): { [key: string]: string } {
    return {
      captionLayerContent: 'CaptionLayerContent',
      componentId: 'ComponentId',
      componentLayer: 'ComponentLayer',
      componentName: 'ComponentName',
      componentType: 'ComponentType',
      effect: 'Effect',
      imageLayerContent: 'ImageLayerContent',
      locationId: 'LocationId',
      textLayerContent: 'TextLayerContent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      captionLayerContent: DescribeCasterComponentsResponseBodyComponentsComponentCaptionLayerContent,
      componentId: 'string',
      componentLayer: DescribeCasterComponentsResponseBodyComponentsComponentComponentLayer,
      componentName: 'string',
      componentType: 'string',
      effect: 'string',
      imageLayerContent: DescribeCasterComponentsResponseBodyComponentsComponentImageLayerContent,
      locationId: 'string',
      textLayerContent: DescribeCasterComponentsResponseBodyComponentsComponentTextLayerContent,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterComponentsResponseBodyComponents extends $tea.Model {
  component?: DescribeCasterComponentsResponseBodyComponentsComponent[];
  static names(): { [key: string]: string } {
    return {
      component: 'Component',
    };
  }

  static types(): { [key: string]: any } {
    return {
      component: { 'type': 'array', 'itemType': DescribeCasterComponentsResponseBodyComponentsComponent },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat extends $tea.Model {
  cycleDuration?: number;
  format?: string;
  ossObjectPrefix?: string;
  sliceOssObjectPrefix?: string;
  static names(): { [key: string]: string } {
    return {
      cycleDuration: 'CycleDuration',
      format: 'Format',
      ossObjectPrefix: 'OssObjectPrefix',
      sliceOssObjectPrefix: 'SliceOssObjectPrefix',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cycleDuration: 'number',
      format: 'string',
      ossObjectPrefix: 'string',
      sliceOssObjectPrefix: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterConfigResponseBodyRecordConfigRecordFormat extends $tea.Model {
  recordFormat?: DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat[];
  static names(): { [key: string]: string } {
    return {
      recordFormat: 'RecordFormat',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordFormat: { 'type': 'array', 'itemType': DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterConfigResponseBodyRecordConfig extends $tea.Model {
  ossBucket?: string;
  ossEndpoint?: string;
  recordFormat?: DescribeCasterConfigResponseBodyRecordConfigRecordFormat;
  static names(): { [key: string]: string } {
    return {
      ossBucket: 'OssBucket',
      ossEndpoint: 'OssEndpoint',
      recordFormat: 'RecordFormat',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ossBucket: 'string',
      ossEndpoint: 'string',
      recordFormat: DescribeCasterConfigResponseBodyRecordConfigRecordFormat,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroupResourceIds extends $tea.Model {
  resourceId?: string[];
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup extends $tea.Model {
  hostResourceId?: string;
  mode?: number;
  resourceIds?: DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroupResourceIds;
  static names(): { [key: string]: string } {
    return {
      hostResourceId: 'HostResourceId',
      mode: 'Mode',
      resourceIds: 'ResourceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hostResourceId: 'string',
      mode: 'number',
      resourceIds: DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroupResourceIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterConfigResponseBodySyncGroupsConfig extends $tea.Model {
  syncGroup?: DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup[];
  static names(): { [key: string]: string } {
    return {
      syncGroup: 'SyncGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      syncGroup: { 'type': 'array', 'itemType': DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterConfigResponseBodyTranscodeConfigLiveTemplateIds extends $tea.Model {
  locationId?: string[];
  static names(): { [key: string]: string } {
    return {
      locationId: 'LocationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      locationId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterConfigResponseBodyTranscodeConfig extends $tea.Model {
  casterTemplate?: string;
  liveTemplateIds?: DescribeCasterConfigResponseBodyTranscodeConfigLiveTemplateIds;
  static names(): { [key: string]: string } {
    return {
      casterTemplate: 'CasterTemplate',
      liveTemplateIds: 'LiveTemplateIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterTemplate: 'string',
      liveTemplateIds: DescribeCasterConfigResponseBodyTranscodeConfigLiveTemplateIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer extends $tea.Model {
  fixedDelayDuration?: number;
  validChannel?: string;
  volumeRate?: number;
  static names(): { [key: string]: string } {
    return {
      fixedDelayDuration: 'FixedDelayDuration',
      validChannel: 'ValidChannel',
      volumeRate: 'VolumeRate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fixedDelayDuration: 'number',
      validChannel: 'string',
      volumeRate: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayers extends $tea.Model {
  audioLayer?: DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer[];
  static names(): { [key: string]: string } {
    return {
      audioLayer: 'AudioLayer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioLayer: { 'type': 'array', 'itemType': DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterLayoutsResponseBodyLayoutsLayoutBlendList extends $tea.Model {
  locationId?: string[];
  static names(): { [key: string]: string } {
    return {
      locationId: 'LocationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      locationId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterLayoutsResponseBodyLayoutsLayoutMixList extends $tea.Model {
  locationId?: string[];
  static names(): { [key: string]: string } {
    return {
      locationId: 'LocationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      locationId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayerPositionNormalizeds extends $tea.Model {
  position?: number[];
  static names(): { [key: string]: string } {
    return {
      position: 'Position',
    };
  }

  static types(): { [key: string]: any } {
    return {
      position: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer extends $tea.Model {
  fillMode?: string;
  fixedDelayDuration?: number;
  heightNormalized?: number;
  positionNormalizeds?: DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayerPositionNormalizeds;
  positionRefer?: string;
  widthNormalized?: number;
  static names(): { [key: string]: string } {
    return {
      fillMode: 'FillMode',
      fixedDelayDuration: 'FixedDelayDuration',
      heightNormalized: 'HeightNormalized',
      positionNormalizeds: 'PositionNormalizeds',
      positionRefer: 'PositionRefer',
      widthNormalized: 'WidthNormalized',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fillMode: 'string',
      fixedDelayDuration: 'number',
      heightNormalized: 'number',
      positionNormalizeds: DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayerPositionNormalizeds,
      positionRefer: 'string',
      widthNormalized: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayers extends $tea.Model {
  videoLayer?: DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer[];
  static names(): { [key: string]: string } {
    return {
      videoLayer: 'VideoLayer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoLayer: { 'type': 'array', 'itemType': DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterLayoutsResponseBodyLayoutsLayout extends $tea.Model {
  audioLayers?: DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayers;
  blendList?: DescribeCasterLayoutsResponseBodyLayoutsLayoutBlendList;
  layoutId?: string;
  mixList?: DescribeCasterLayoutsResponseBodyLayoutsLayoutMixList;
  videoLayers?: DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayers;
  static names(): { [key: string]: string } {
    return {
      audioLayers: 'AudioLayers',
      blendList: 'BlendList',
      layoutId: 'LayoutId',
      mixList: 'MixList',
      videoLayers: 'VideoLayers',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioLayers: DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayers,
      blendList: DescribeCasterLayoutsResponseBodyLayoutsLayoutBlendList,
      layoutId: 'string',
      mixList: DescribeCasterLayoutsResponseBodyLayoutsLayoutMixList,
      videoLayers: DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayers,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterLayoutsResponseBodyLayouts extends $tea.Model {
  layout?: DescribeCasterLayoutsResponseBodyLayoutsLayout[];
  static names(): { [key: string]: string } {
    return {
      layout: 'Layout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      layout: { 'type': 'array', 'itemType': DescribeCasterLayoutsResponseBodyLayoutsLayout },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterProgramResponseBodyEpisodesEpisodeComponentIds extends $tea.Model {
  componentId?: string[];
  static names(): { [key: string]: string } {
    return {
      componentId: 'ComponentId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      componentId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterProgramResponseBodyEpisodesEpisode extends $tea.Model {
  componentIds?: DescribeCasterProgramResponseBodyEpisodesEpisodeComponentIds;
  endTime?: string;
  episodeId?: string;
  episodeName?: string;
  episodeType?: string;
  resourceId?: string;
  startTime?: string;
  status?: number;
  switchType?: string;
  static names(): { [key: string]: string } {
    return {
      componentIds: 'ComponentIds',
      endTime: 'EndTime',
      episodeId: 'EpisodeId',
      episodeName: 'EpisodeName',
      episodeType: 'EpisodeType',
      resourceId: 'ResourceId',
      startTime: 'StartTime',
      status: 'Status',
      switchType: 'SwitchType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      componentIds: DescribeCasterProgramResponseBodyEpisodesEpisodeComponentIds,
      endTime: 'string',
      episodeId: 'string',
      episodeName: 'string',
      episodeType: 'string',
      resourceId: 'string',
      startTime: 'string',
      status: 'number',
      switchType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterProgramResponseBodyEpisodes extends $tea.Model {
  episode?: DescribeCasterProgramResponseBodyEpisodesEpisode[];
  static names(): { [key: string]: string } {
    return {
      episode: 'Episode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      episode: { 'type': 'array', 'itemType': DescribeCasterProgramResponseBodyEpisodesEpisode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer extends $tea.Model {
  fixedDelayDuration?: number;
  validChannel?: string;
  volumeRate?: number;
  static names(): { [key: string]: string } {
    return {
      fixedDelayDuration: 'FixedDelayDuration',
      validChannel: 'ValidChannel',
      volumeRate: 'VolumeRate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fixedDelayDuration: 'number',
      validChannel: 'string',
      volumeRate: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterSceneAudioResponseBodyAudioLayers extends $tea.Model {
  audioLayer?: DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer[];
  static names(): { [key: string]: string } {
    return {
      audioLayer: 'AudioLayer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioLayer: { 'type': 'array', 'itemType': DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterSceneAudioResponseBodyMixList extends $tea.Model {
  locationId?: string[];
  static names(): { [key: string]: string } {
    return {
      locationId: 'LocationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      locationId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterScenesResponseBodySceneListSceneComponentIds extends $tea.Model {
  componentId?: string[];
  static names(): { [key: string]: string } {
    return {
      componentId: 'componentId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      componentId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo extends $tea.Model {
  outputStreamUrl?: string;
  transcodeConfig?: string;
  videoFormat?: string;
  static names(): { [key: string]: string } {
    return {
      outputStreamUrl: 'OutputStreamUrl',
      transcodeConfig: 'TranscodeConfig',
      videoFormat: 'VideoFormat',
    };
  }

  static types(): { [key: string]: any } {
    return {
      outputStreamUrl: 'string',
      transcodeConfig: 'string',
      videoFormat: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterScenesResponseBodySceneListSceneStreamInfos extends $tea.Model {
  streamInfo?: DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo[];
  static names(): { [key: string]: string } {
    return {
      streamInfo: 'StreamInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      streamInfo: { 'type': 'array', 'itemType': DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterScenesResponseBodySceneListScene extends $tea.Model {
  componentIds?: DescribeCasterScenesResponseBodySceneListSceneComponentIds;
  layoutId?: string;
  outputType?: string;
  sceneId?: string;
  sceneName?: string;
  status?: number;
  streamInfos?: DescribeCasterScenesResponseBodySceneListSceneStreamInfos;
  streamUrl?: string;
  static names(): { [key: string]: string } {
    return {
      componentIds: 'ComponentIds',
      layoutId: 'LayoutId',
      outputType: 'OutputType',
      sceneId: 'SceneId',
      sceneName: 'SceneName',
      status: 'Status',
      streamInfos: 'StreamInfos',
      streamUrl: 'StreamUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      componentIds: DescribeCasterScenesResponseBodySceneListSceneComponentIds,
      layoutId: 'string',
      outputType: 'string',
      sceneId: 'string',
      sceneName: 'string',
      status: 'number',
      streamInfos: DescribeCasterScenesResponseBodySceneListSceneStreamInfos,
      streamUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterScenesResponseBodySceneList extends $tea.Model {
  scene?: DescribeCasterScenesResponseBodySceneListScene[];
  static names(): { [key: string]: string } {
    return {
      scene: 'Scene',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scene: { 'type': 'array', 'itemType': DescribeCasterScenesResponseBodySceneListScene },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo extends $tea.Model {
  outputStreamUrl?: string;
  transcodeConfig?: string;
  videoFormat?: string;
  static names(): { [key: string]: string } {
    return {
      outputStreamUrl: 'OutputStreamUrl',
      transcodeConfig: 'TranscodeConfig',
      videoFormat: 'VideoFormat',
    };
  }

  static types(): { [key: string]: any } {
    return {
      outputStreamUrl: 'string',
      transcodeConfig: 'string',
      videoFormat: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfos extends $tea.Model {
  streamInfo?: DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo[];
  static names(): { [key: string]: string } {
    return {
      streamInfo: 'StreamInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      streamInfo: { 'type': 'array', 'itemType': DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream extends $tea.Model {
  outputType?: number;
  rtmpUrl?: string;
  sceneId?: string;
  streamInfos?: DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfos;
  streamUrl?: string;
  static names(): { [key: string]: string } {
    return {
      outputType: 'OutputType',
      rtmpUrl: 'RtmpUrl',
      sceneId: 'SceneId',
      streamInfos: 'StreamInfos',
      streamUrl: 'StreamUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      outputType: 'number',
      rtmpUrl: 'string',
      sceneId: 'string',
      streamInfos: DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfos,
      streamUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterStreamUrlResponseBodyCasterStreams extends $tea.Model {
  casterStream?: DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream[];
  static names(): { [key: string]: string } {
    return {
      casterStream: 'CasterStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterStream: { 'type': 'array', 'itemType': DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterSyncGroupResponseBodySyncGroupsSyncGroupResourceIds extends $tea.Model {
  resourceId?: string[];
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterSyncGroupResponseBodySyncGroupsSyncGroup extends $tea.Model {
  hostResourceId?: string;
  mode?: number;
  resourceIds?: DescribeCasterSyncGroupResponseBodySyncGroupsSyncGroupResourceIds;
  static names(): { [key: string]: string } {
    return {
      hostResourceId: 'HostResourceId',
      mode: 'Mode',
      resourceIds: 'ResourceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hostResourceId: 'string',
      mode: 'number',
      resourceIds: DescribeCasterSyncGroupResponseBodySyncGroupsSyncGroupResourceIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterSyncGroupResponseBodySyncGroups extends $tea.Model {
  syncGroup?: DescribeCasterSyncGroupResponseBodySyncGroupsSyncGroup[];
  static names(): { [key: string]: string } {
    return {
      syncGroup: 'SyncGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      syncGroup: { 'type': 'array', 'itemType': DescribeCasterSyncGroupResponseBodySyncGroupsSyncGroup },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource extends $tea.Model {
  beginOffset?: number;
  endOffset?: number;
  flvUrl?: string;
  liveStreamUrl?: string;
  locationId?: string;
  materialId?: string;
  ptsCallbackInterval?: number;
  repeatNum?: number;
  resourceId?: string;
  resourceName?: string;
  vodUrl?: string;
  static names(): { [key: string]: string } {
    return {
      beginOffset: 'BeginOffset',
      endOffset: 'EndOffset',
      flvUrl: 'FlvUrl',
      liveStreamUrl: 'LiveStreamUrl',
      locationId: 'LocationId',
      materialId: 'MaterialId',
      ptsCallbackInterval: 'PtsCallbackInterval',
      repeatNum: 'RepeatNum',
      resourceId: 'ResourceId',
      resourceName: 'ResourceName',
      vodUrl: 'VodUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      beginOffset: 'number',
      endOffset: 'number',
      flvUrl: 'string',
      liveStreamUrl: 'string',
      locationId: 'string',
      materialId: 'string',
      ptsCallbackInterval: 'number',
      repeatNum: 'number',
      resourceId: 'string',
      resourceName: 'string',
      vodUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCasterVideoResourcesResponseBodyVideoResources extends $tea.Model {
  videoResource?: DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource[];
  static names(): { [key: string]: string } {
    return {
      videoResource: 'VideoResource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoResource: { 'type': 'array', 'itemType': DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCastersResponseBodyCasterListCaster extends $tea.Model {
  casterId?: string;
  casterName?: string;
  casterTemplate?: string;
  channelEnable?: number;
  chargeType?: string;
  createTime?: string;
  duration?: string;
  expireTime?: string;
  lastModified?: string;
  normType?: number;
  purchaseTime?: string;
  startTime?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      casterName: 'CasterName',
      casterTemplate: 'CasterTemplate',
      channelEnable: 'ChannelEnable',
      chargeType: 'ChargeType',
      createTime: 'CreateTime',
      duration: 'Duration',
      expireTime: 'ExpireTime',
      lastModified: 'LastModified',
      normType: 'NormType',
      purchaseTime: 'PurchaseTime',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      casterName: 'string',
      casterTemplate: 'string',
      channelEnable: 'number',
      chargeType: 'string',
      createTime: 'string',
      duration: 'string',
      expireTime: 'string',
      lastModified: 'string',
      normType: 'number',
      purchaseTime: 'string',
      startTime: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCastersResponseBodyCasterList extends $tea.Model {
  caster?: DescribeCastersResponseBodyCasterListCaster[];
  static names(): { [key: string]: string } {
    return {
      caster: 'Caster',
    };
  }

  static types(): { [key: string]: any } {
    return {
      caster: { 'type': 'array', 'itemType': DescribeCastersResponseBodyCasterListCaster },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule extends $tea.Model {
  timeStamp?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      timeStamp: 'TimeStamp',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeStamp: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainUsageDataResponseBodyUsageDataPerInterval extends $tea.Model {
  dataModule?: DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainWithIntegrityResponseBodyContent extends $tea.Model {
  columns?: string[];
  name?: string;
  points?: string[];
  static names(): { [key: string]: string } {
    return {
      columns: 'Columns',
      name: 'Name',
      points: 'Points',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columns: { 'type': 'array', 'itemType': 'string' },
      name: 'string',
      points: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeForbidPushStreamRoomListResponseBodyRoomList extends $tea.Model {
  anchorId?: string;
  opEndTime?: string;
  opStartTime?: string;
  roomId?: string;
  static names(): { [key: string]: string } {
    return {
      anchorId: 'AnchorId',
      opEndTime: 'OpEndTime',
      opStartTime: 'OpStartTime',
      roomId: 'RoomId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      anchorId: 'string',
      opEndTime: 'string',
      opStartTime: 'string',
      roomId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos extends $tea.Model {
  downFlow?: number;
  online?: number;
  rate?: string;
  static names(): { [key: string]: string } {
    return {
      downFlow: 'DownFlow',
      online: 'Online',
      rate: 'Rate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downFlow: 'number',
      online: 'number',
      rate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos extends $tea.Model {
  infos?: DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos[];
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      infos: 'Infos',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      infos: { 'type': 'array', 'itemType': DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos },
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData extends $tea.Model {
  domainName?: string;
  streamInfos?: DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos[];
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      streamInfos: 'StreamInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      streamInfos: { 'type': 'array', 'itemType': DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfigScenes extends $tea.Model {
  scene?: string[];
  static names(): { [key: string]: string } {
    return {
      scene: 'scene',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scene: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig extends $tea.Model {
  appName?: string;
  bizType?: string;
  domainName?: string;
  scenes?: DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfigScenes;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      bizType: 'BizType',
      domainName: 'DomainName',
      scenes: 'Scenes',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      bizType: 'string',
      domainName: 'string',
      scenes: DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfigScenes,
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigList extends $tea.Model {
  liveAudioAuditConfig?: DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig[];
  static names(): { [key: string]: string } {
    return {
      liveAudioAuditConfig: 'LiveAudioAuditConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveAudioAuditConfig: { 'type': 'array', 'itemType': DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig extends $tea.Model {
  callback?: string;
  callbackTemplate?: string;
  domainName?: string;
  static names(): { [key: string]: string } {
    return {
      callback: 'Callback',
      callbackTemplate: 'CallbackTemplate',
      domainName: 'DomainName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      callback: 'string',
      callbackTemplate: 'string',
      domainName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigList extends $tea.Model {
  liveAudioAuditNotifyConfig?: DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig[];
  static names(): { [key: string]: string } {
    return {
      liveAudioAuditNotifyConfig: 'LiveAudioAuditNotifyConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveAudioAuditNotifyConfig: { 'type': 'array', 'itemType': DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert extends $tea.Model {
  certId?: number;
  certName?: string;
  common?: string;
  fingerprint?: string;
  issuer?: string;
  lastTime?: number;
  static names(): { [key: string]: string } {
    return {
      certId: 'CertId',
      certName: 'CertName',
      common: 'Common',
      fingerprint: 'Fingerprint',
      issuer: 'Issuer',
      lastTime: 'LastTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certId: 'number',
      certName: 'string',
      common: 'string',
      fingerprint: 'string',
      issuer: 'string',
      lastTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveCertificateListResponseBodyCertificateListModelCertList extends $tea.Model {
  cert?: DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert[];
  static names(): { [key: string]: string } {
    return {
      cert: 'Cert',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cert: { 'type': 'array', 'itemType': DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveCertificateListResponseBodyCertificateListModel extends $tea.Model {
  certList?: DescribeLiveCertificateListResponseBodyCertificateListModelCertList;
  count?: number;
  static names(): { [key: string]: string } {
    return {
      certList: 'CertList',
      count: 'Count',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certList: DescribeLiveCertificateListResponseBodyCertificateListModelCertList,
      count: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDetectNotifyConfigResponseBodyLiveDetectNotifyConfig extends $tea.Model {
  domainName?: string;
  notifyUrl?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      notifyUrl: 'NotifyUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      notifyUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule extends $tea.Model {
  app?: string;
  count?: number;
  domain?: string;
  fee?: string;
  region?: string;
  scene?: string;
  stream?: string;
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      count: 'Count',
      domain: 'Domain',
      fee: 'Fee',
      region: 'Region',
      scene: 'Scene',
      stream: 'Stream',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      count: 'number',
      domain: 'string',
      fee: 'string',
      region: 'string',
      scene: 'string',
      stream: 'string',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDetectPornDataResponseBodyDetectPornData extends $tea.Model {
  dataModule?: DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule extends $tea.Model {
  bpsValue?: string;
  httpBpsValue?: string;
  httpsBpsValue?: string;
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      bpsValue: 'BpsValue',
      httpBpsValue: 'HttpBpsValue',
      httpsBpsValue: 'HttpsBpsValue',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bpsValue: 'string',
      httpBpsValue: 'string',
      httpsBpsValue: 'string',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainBpsDataResponseBodyBpsDataPerInterval extends $tea.Model {
  dataModule?: DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule extends $tea.Model {
  timeStamp?: string;
  trafficValue?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      timeStamp: 'TimeStamp',
      trafficValue: 'TrafficValue',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeStamp: 'string',
      trafficValue: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataInterval extends $tea.Model {
  dataModule?: DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel extends $tea.Model {
  bps?: number;
  ispName?: string;
  locationName?: string;
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      bps: 'Bps',
      ispName: 'IspName',
      locationName: 'LocationName',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bps: 'number',
      ispName: 'string',
      locationName: 'string',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainBpsDataByTimeStampResponseBodyBpsDataList extends $tea.Model {
  bpsDataModel?: DescribeLiveDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel[];
  static names(): { [key: string]: string } {
    return {
      bpsDataModel: 'BpsDataModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bpsDataModel: { 'type': 'array', 'itemType': DescribeLiveDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo extends $tea.Model {
  certDomainName?: string;
  certExpireTime?: string;
  certLife?: string;
  certName?: string;
  certOrg?: string;
  certType?: string;
  domainName?: string;
  SSLProtocol?: string;
  SSLPub?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      certDomainName: 'CertDomainName',
      certExpireTime: 'CertExpireTime',
      certLife: 'CertLife',
      certName: 'CertName',
      certOrg: 'CertOrg',
      certType: 'CertType',
      domainName: 'DomainName',
      SSLProtocol: 'SSLProtocol',
      SSLPub: 'SSLPub',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certDomainName: 'string',
      certExpireTime: 'string',
      certLife: 'string',
      certName: 'string',
      certOrg: 'string',
      certType: 'string',
      domainName: 'string',
      SSLProtocol: 'string',
      SSLPub: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainCertificateInfoResponseBodyCertInfos extends $tea.Model {
  certInfo?: DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo[];
  static names(): { [key: string]: string } {
    return {
      certInfo: 'CertInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certInfo: { 'type': 'array', 'itemType': DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg extends $tea.Model {
  argName?: string;
  argValue?: string;
  static names(): { [key: string]: string } {
    return {
      argName: 'ArgName',
      argValue: 'ArgValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      argName: 'string',
      argValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs extends $tea.Model {
  functionArg?: DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg[];
  static names(): { [key: string]: string } {
    return {
      functionArg: 'FunctionArg',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionArg: { 'type': 'array', 'itemType': DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig extends $tea.Model {
  configId?: string;
  functionArgs?: DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs;
  functionName?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      functionArgs: 'FunctionArgs',
      functionName: 'FunctionName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      functionArgs: DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs,
      functionName: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainConfigsResponseBodyDomainConfigs extends $tea.Model {
  domainConfig?: DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig[];
  static names(): { [key: string]: string } {
    return {
      domainConfig: 'DomainConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainConfig: { 'type': 'array', 'itemType': DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainDetailResponseBodyDomainDetail extends $tea.Model {
  certName?: string;
  cname?: string;
  description?: string;
  domainName?: string;
  domainStatus?: string;
  gmtCreated?: string;
  gmtModified?: string;
  liveDomainType?: string;
  region?: string;
  SSLProtocol?: string;
  SSLPub?: string;
  scope?: string;
  static names(): { [key: string]: string } {
    return {
      certName: 'CertName',
      cname: 'Cname',
      description: 'Description',
      domainName: 'DomainName',
      domainStatus: 'DomainStatus',
      gmtCreated: 'GmtCreated',
      gmtModified: 'GmtModified',
      liveDomainType: 'LiveDomainType',
      region: 'Region',
      SSLProtocol: 'SSLProtocol',
      SSLPub: 'SSLPub',
      scope: 'Scope',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certName: 'string',
      cname: 'string',
      description: 'string',
      domainName: 'string',
      domainStatus: 'string',
      gmtCreated: 'string',
      gmtModified: 'string',
      liveDomainType: 'string',
      region: 'string',
      SSLProtocol: 'string',
      SSLPub: 'string',
      scope: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo extends $tea.Model {
  audioFrameRate?: number;
  bitRate?: number;
  streamUrl?: string;
  videoFrameRate?: number;
  static names(): { [key: string]: string } {
    return {
      audioFrameRate: 'AudioFrameRate',
      bitRate: 'BitRate',
      streamUrl: 'StreamUrl',
      videoFrameRate: 'VideoFrameRate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFrameRate: 'number',
      bitRate: 'number',
      streamUrl: 'string',
      videoFrameRate: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos extends $tea.Model {
  frameRateAndBitRateInfo?: DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo[];
  static names(): { [key: string]: string } {
    return {
      frameRateAndBitRateInfo: 'FrameRateAndBitRateInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      frameRateAndBitRateInfo: { 'type': 'array', 'itemType': DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit extends $tea.Model {
  domainName?: string;
  limitNum?: number;
  limitTranscodeNum?: number;
  limitTransferNum?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      limitNum: 'LimitNum',
      limitTranscodeNum: 'LimitTranscodeNum',
      limitTransferNum: 'LimitTransferNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      limitNum: 'number',
      limitTranscodeNum: 'number',
      limitTransferNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainLimitResponseBodyLiveDomainLimitList extends $tea.Model {
  liveDomainLimit?: DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit[];
  static names(): { [key: string]: string } {
    return {
      liveDomainLimit: 'LiveDomainLimit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveDomainLimit: { 'type': 'array', 'itemType': DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail extends $tea.Model {
  endTime?: string;
  logName?: string;
  logPath?: string;
  logSize?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      logName: 'LogName',
      logPath: 'LogPath',
      logSize: 'LogSize',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      logName: 'string',
      logPath: 'string',
      logSize: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos extends $tea.Model {
  logInfoDetail?: DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail[];
  static names(): { [key: string]: string } {
    return {
      logInfoDetail: 'LogInfoDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logInfoDetail: { 'type': 'array', 'itemType': DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos extends $tea.Model {
  pageIndex?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      pageIndex: 'PageIndex',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageIndex: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail extends $tea.Model {
  logCount?: number;
  logInfos?: DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos;
  pageInfos?: DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos;
  static names(): { [key: string]: string } {
    return {
      logCount: 'LogCount',
      logInfos: 'LogInfos',
      pageInfos: 'PageInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logCount: 'number',
      logInfos: DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos,
      pageInfos: DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainLogResponseBodyDomainLogDetails extends $tea.Model {
  domainLogDetail?: DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail[];
  static names(): { [key: string]: string } {
    return {
      domainLogDetail: 'DomainLogDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainLogDetail: { 'type': 'array', 'itemType': DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel extends $tea.Model {
  domainName?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainMappingResponseBodyLiveDomainModels extends $tea.Model {
  liveDomainModel?: DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel[];
  static names(): { [key: string]: string } {
    return {
      liveDomainModel: 'LiveDomainModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveDomainModel: { 'type': 'array', 'itemType': DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo extends $tea.Model {
  transcodeTemplate?: string;
  userNumber?: number;
  static names(): { [key: string]: string } {
    return {
      transcodeTemplate: 'TranscodeTemplate',
      userNumber: 'UserNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      transcodeTemplate: 'string',
      userNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfos extends $tea.Model {
  info?: DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo[];
  static names(): { [key: string]: string } {
    return {
      info: 'Info',
    };
  }

  static types(): { [key: string]: any } {
    return {
      info: { 'type': 'array', 'itemType': DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo extends $tea.Model {
  infos?: DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfos;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      infos: 'Infos',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      infos: DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfos,
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfo extends $tea.Model {
  liveStreamOnlineUserNumInfo?: DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo[];
  static names(): { [key: string]: string } {
    return {
      liveStreamOnlineUserNumInfo: 'LiveStreamOnlineUserNumInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveStreamOnlineUserNumInfo: { 'type': 'array', 'itemType': DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule extends $tea.Model {
  bpsValue?: string;
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      bpsValue: 'BpsValue',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bpsValue: 'string',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerInterval extends $tea.Model {
  dataModule?: DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule extends $tea.Model {
  timeStamp?: string;
  trafficValue?: string;
  static names(): { [key: string]: string } {
    return {
      timeStamp: 'TimeStamp',
      trafficValue: 'TrafficValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeStamp: 'string',
      trafficValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerInterval extends $tea.Model {
  dataModule?: DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo extends $tea.Model {
  PV?: string;
  timeStamp?: string;
  UV?: string;
  static names(): { [key: string]: string } {
    return {
      PV: 'PV',
      timeStamp: 'TimeStamp',
      UV: 'UV',
    };
  }

  static types(): { [key: string]: any } {
    return {
      PV: 'string',
      timeStamp: 'string',
      UV: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfos extends $tea.Model {
  pvUvDataInfo?: DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo[];
  static names(): { [key: string]: string } {
    return {
      pvUvDataInfo: 'PvUvDataInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pvUvDataInfo: { 'type': 'array', 'itemType': DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule extends $tea.Model {
  timeStamp?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      timeStamp: 'TimeStamp',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeStamp: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerInterval extends $tea.Model {
  dataModule?: DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData extends $tea.Model {
  code?: string;
  count?: string;
  proportion?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      count: 'Count',
      proportion: 'Proportion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      count: 'string',
      proportion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue extends $tea.Model {
  realTimeCodeProportionData?: DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData[];
  static names(): { [key: string]: string } {
    return {
      realTimeCodeProportionData: 'RealTimeCodeProportionData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      realTimeCodeProportionData: { 'type': 'array', 'itemType': DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData extends $tea.Model {
  timeStamp?: string;
  value?: DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue;
  static names(): { [key: string]: string } {
    return {
      timeStamp: 'TimeStamp',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeStamp: 'string',
      value: DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData extends $tea.Model {
  usageData?: DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData[];
  static names(): { [key: string]: string } {
    return {
      usageData: 'UsageData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      usageData: { 'type': 'array', 'itemType': DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule extends $tea.Model {
  timeStamp?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      timeStamp: 'TimeStamp',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeStamp: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval extends $tea.Model {
  dataModule?: DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRecordDataResponseBodyRecordDataInfosRecordDataInfoDetail extends $tea.Model {
  FLV?: number;
  MP4?: number;
  TS?: number;
  static names(): { [key: string]: string } {
    return {
      FLV: 'FLV',
      MP4: 'MP4',
      TS: 'TS',
    };
  }

  static types(): { [key: string]: any } {
    return {
      FLV: 'number',
      MP4: 'number',
      TS: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRecordDataResponseBodyRecordDataInfosRecordDataInfo extends $tea.Model {
  date?: string;
  detail?: DescribeLiveDomainRecordDataResponseBodyRecordDataInfosRecordDataInfoDetail;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      date: 'Date',
      detail: 'Detail',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'string',
      detail: DescribeLiveDomainRecordDataResponseBodyRecordDataInfosRecordDataInfoDetail,
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRecordDataResponseBodyRecordDataInfos extends $tea.Model {
  recordDataInfo?: DescribeLiveDomainRecordDataResponseBodyRecordDataInfosRecordDataInfo[];
  static names(): { [key: string]: string } {
    return {
      recordDataInfo: 'RecordDataInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordDataInfo: { 'type': 'array', 'itemType': DescribeLiveDomainRecordDataResponseBodyRecordDataInfosRecordDataInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule extends $tea.Model {
  count?: number;
  domain?: string;
  duration?: number;
  timeStamp?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      domain: 'Domain',
      duration: 'Duration',
      timeStamp: 'TimeStamp',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      domain: 'string',
      duration: 'number',
      timeStamp: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageData extends $tea.Model {
  dataModule?: DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo extends $tea.Model {
  date?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      date: 'Date',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfos extends $tea.Model {
  snapshotDataInfo?: DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo[];
  static names(): { [key: string]: string } {
    return {
      snapshotDataInfo: 'SnapshotDataInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      snapshotDataInfo: { 'type': 'array', 'itemType': DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs extends $tea.Model {
  argName?: string;
  argValue?: string;
  static names(): { [key: string]: string } {
    return {
      argName: 'ArgName',
      argValue: 'ArgValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      argName: 'string',
      argValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainStagingConfigResponseBodyDomainConfigs extends $tea.Model {
  configId?: string;
  functionArgs?: DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs[];
  functionName?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      functionArgs: 'FunctionArgs',
      functionName: 'FunctionName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      functionArgs: { 'type': 'array', 'itemType': DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs },
      functionName: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData extends $tea.Model {
  domain?: string;
  duration?: number;
  fps?: string;
  region?: string;
  resolution?: string;
  tanscodeType?: string;
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      duration: 'Duration',
      fps: 'Fps',
      region: 'Region',
      resolution: 'Resolution',
      tanscodeType: 'TanscodeType',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      duration: 'number',
      fps: 'string',
      region: 'string',
      resolution: 'string',
      tanscodeType: 'string',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataList extends $tea.Model {
  transcodeData?: DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData[];
  static names(): { [key: string]: string } {
    return {
      transcodeData: 'TranscodeData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      transcodeData: { 'type': 'array', 'itemType': DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule extends $tea.Model {
  size?: string;
  timeStamp?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      size: 'Size',
      timeStamp: 'TimeStamp',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      size: 'string',
      timeStamp: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftData extends $tea.Model {
  dataModule?: DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule extends $tea.Model {
  httpTrafficValue?: string;
  httpsTrafficValue?: string;
  timeStamp?: string;
  trafficValue?: string;
  static names(): { [key: string]: string } {
    return {
      httpTrafficValue: 'HttpTrafficValue',
      httpsTrafficValue: 'HttpsTrafficValue',
      timeStamp: 'TimeStamp',
      trafficValue: 'TrafficValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      httpTrafficValue: 'string',
      httpsTrafficValue: 'string',
      timeStamp: 'string',
      trafficValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerInterval extends $tea.Model {
  dataModule?: DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainTranscodeDataResponseBodyTranscodeDataInfosTranscodeDataInfo extends $tea.Model {
  date?: string;
  detail?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      date: 'Date',
      detail: 'Detail',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'string',
      detail: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDomainTranscodeDataResponseBodyTranscodeDataInfos extends $tea.Model {
  transcodeDataInfo?: DescribeLiveDomainTranscodeDataResponseBodyTranscodeDataInfosTranscodeDataInfo[];
  static names(): { [key: string]: string } {
    return {
      transcodeDataInfo: 'TranscodeDataInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      transcodeDataInfo: { 'type': 'array', 'itemType': DescribeLiveDomainTranscodeDataResponseBodyTranscodeDataInfosTranscodeDataInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule extends $tea.Model {
  count?: number;
  domain?: string;
  drmType?: string;
  region?: string;
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      domain: 'Domain',
      drmType: 'DrmType',
      region: 'Region',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      domain: 'string',
      drmType: 'string',
      region: 'string',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveDrmUsageDataResponseBodyDrmUsageData extends $tea.Model {
  dataModule?: DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig extends $tea.Model {
  appName?: string;
  domainName?: string;
  pullAppName?: string;
  pullDomainName?: string;
  pullProtocol?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      pullAppName: 'PullAppName',
      pullDomainName: 'PullDomainName',
      pullProtocol: 'PullProtocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      pullAppName: 'string',
      pullDomainName: 'string',
      pullProtocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigList extends $tea.Model {
  liveLazyPullConfig?: DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig[];
  static names(): { [key: string]: string } {
    return {
      liveLazyPullConfig: 'LiveLazyPullConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveLazyPullConfig: { 'type': 'array', 'itemType': DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem extends $tea.Model {
  domainName?: string;
  instance?: string;
  outputHdDuration?: number;
  outputLdDuration?: number;
  outputSdDuration?: number;
  region?: string;
  timeStamp?: string;
  tranHdDuration?: number;
  tranLdDuration?: number;
  tranSdDuration?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      instance: 'Instance',
      outputHdDuration: 'OutputHdDuration',
      outputLdDuration: 'OutputLdDuration',
      outputSdDuration: 'OutputSdDuration',
      region: 'Region',
      timeStamp: 'TimeStamp',
      tranHdDuration: 'TranHdDuration',
      tranLdDuration: 'TranLdDuration',
      tranSdDuration: 'TranSdDuration',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      instance: 'string',
      outputHdDuration: 'number',
      outputLdDuration: 'number',
      outputSdDuration: 'number',
      region: 'string',
      timeStamp: 'string',
      tranHdDuration: 'number',
      tranLdDuration: 'number',
      tranSdDuration: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveProducerUsageDataResponseBodyBillProducerData extends $tea.Model {
  billProducerDataItem?: DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem[];
  static names(): { [key: string]: string } {
    return {
      billProducerDataItem: 'BillProducerDataItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      billProducerDataItem: { 'type': 'array', 'itemType': DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord extends $tea.Model {
  appName?: string;
  domainName?: string;
  endTime?: string;
  sourceUrl?: string;
  sourceUsing?: string;
  startTime?: string;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      endTime: 'EndTime',
      sourceUrl: 'SourceUrl',
      sourceUsing: 'SourceUsing',
      startTime: 'StartTime',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      endTime: 'string',
      sourceUrl: 'string',
      sourceUsing: 'string',
      startTime: 'string',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLivePullStreamConfigResponseBodyLiveAppRecordList extends $tea.Model {
  liveAppRecord?: DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord[];
  static names(): { [key: string]: string } {
    return {
      liveAppRecord: 'LiveAppRecord',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveAppRecord: { 'type': 'array', 'itemType': DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData extends $tea.Model {
  failedNum?: number;
  successNum?: number;
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      failedNum: 'FailedNum',
      successNum: 'SuccessNum',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedNum: 'number',
      successNum: 'number',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccData extends $tea.Model {
  accData?: DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData[];
  static names(): { [key: string]: string } {
    return {
      accData: 'AccData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accData: { 'type': 'array', 'itemType': DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat extends $tea.Model {
  cycleDuration?: number;
  format?: string;
  ossObjectPrefix?: string;
  sliceDuration?: number;
  sliceOssObjectPrefix?: string;
  static names(): { [key: string]: string } {
    return {
      cycleDuration: 'CycleDuration',
      format: 'Format',
      ossObjectPrefix: 'OssObjectPrefix',
      sliceDuration: 'SliceDuration',
      sliceOssObjectPrefix: 'SliceOssObjectPrefix',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cycleDuration: 'number',
      format: 'string',
      ossObjectPrefix: 'string',
      sliceDuration: 'number',
      sliceOssObjectPrefix: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatList extends $tea.Model {
  recordFormat?: DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat[];
  static names(): { [key: string]: string } {
    return {
      recordFormat: 'RecordFormat',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordFormat: { 'type': 'array', 'itemType': DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat extends $tea.Model {
  cycleDuration?: number;
  format?: string;
  ossObjectPrefix?: string;
  sliceDuration?: number;
  sliceOssObjectPrefix?: string;
  static names(): { [key: string]: string } {
    return {
      cycleDuration: 'CycleDuration',
      format: 'Format',
      ossObjectPrefix: 'OssObjectPrefix',
      sliceDuration: 'SliceDuration',
      sliceOssObjectPrefix: 'SliceOssObjectPrefix',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cycleDuration: 'number',
      format: 'string',
      ossObjectPrefix: 'string',
      sliceDuration: 'number',
      sliceOssObjectPrefix: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatList extends $tea.Model {
  recordFormat?: DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat[];
  static names(): { [key: string]: string } {
    return {
      recordFormat: 'RecordFormat',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordFormat: { 'type': 'array', 'itemType': DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeTemplates extends $tea.Model {
  templates?: string[];
  static names(): { [key: string]: string } {
    return {
      templates: 'Templates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      templates: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord extends $tea.Model {
  appName?: string;
  createTime?: string;
  domainName?: string;
  endTime?: string;
  onDemond?: number;
  ossBucket?: string;
  ossEndpoint?: string;
  recordFormatList?: DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatList;
  startTime?: string;
  streamName?: string;
  transcodeRecordFormatList?: DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatList;
  transcodeTemplates?: DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeTemplates;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      createTime: 'CreateTime',
      domainName: 'DomainName',
      endTime: 'EndTime',
      onDemond: 'OnDemond',
      ossBucket: 'OssBucket',
      ossEndpoint: 'OssEndpoint',
      recordFormatList: 'RecordFormatList',
      startTime: 'StartTime',
      streamName: 'StreamName',
      transcodeRecordFormatList: 'TranscodeRecordFormatList',
      transcodeTemplates: 'TranscodeTemplates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      createTime: 'string',
      domainName: 'string',
      endTime: 'string',
      onDemond: 'number',
      ossBucket: 'string',
      ossEndpoint: 'string',
      recordFormatList: DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatList,
      startTime: 'string',
      streamName: 'string',
      transcodeRecordFormatList: DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatList,
      transcodeTemplates: DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeTemplates,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRecordConfigResponseBodyLiveAppRecordList extends $tea.Model {
  liveAppRecord?: DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord[];
  static names(): { [key: string]: string } {
    return {
      liveAppRecord: 'LiveAppRecord',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveAppRecord: { 'type': 'array', 'itemType': DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRecordNotifyConfigResponseBodyLiveRecordNotifyConfig extends $tea.Model {
  domainName?: string;
  needStatusNotify?: boolean;
  notifyUrl?: string;
  onDemandUrl?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      needStatusNotify: 'NeedStatusNotify',
      notifyUrl: 'NotifyUrl',
      onDemandUrl: 'OnDemandUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      needStatusNotify: 'boolean',
      notifyUrl: 'string',
      onDemandUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig extends $tea.Model {
  appName?: string;
  autoCompose?: string;
  composeVodTranscodeGroupId?: string;
  createTime?: string;
  cycleDuration?: number;
  domainName?: string;
  streamName?: string;
  vodTranscodeGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      autoCompose: 'AutoCompose',
      composeVodTranscodeGroupId: 'ComposeVodTranscodeGroupId',
      createTime: 'CreateTime',
      cycleDuration: 'CycleDuration',
      domainName: 'DomainName',
      streamName: 'StreamName',
      vodTranscodeGroupId: 'VodTranscodeGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      autoCompose: 'string',
      composeVodTranscodeGroupId: 'string',
      createTime: 'string',
      cycleDuration: 'number',
      domainName: 'string',
      streamName: 'string',
      vodTranscodeGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigs extends $tea.Model {
  liveRecordVodConfig?: DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig[];
  static names(): { [key: string]: string } {
    return {
      liveRecordVodConfig: 'LiveRecordVodConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveRecordVodConfig: { 'type': 'array', 'itemType': DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveShiftConfigsResponseBodyContentConfig extends $tea.Model {
  appName?: string;
  domainName?: string;
  ignoreTranscode?: boolean;
  streamName?: string;
  vision?: number;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      ignoreTranscode: 'IgnoreTranscode',
      streamName: 'StreamName',
      vision: 'Vision',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      ignoreTranscode: 'boolean',
      streamName: 'string',
      vision: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveShiftConfigsResponseBodyContent extends $tea.Model {
  config?: DescribeLiveShiftConfigsResponseBodyContentConfig[];
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: { 'type': 'array', 'itemType': DescribeLiveShiftConfigsResponseBodyContentConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig extends $tea.Model {
  appName?: string;
  callback?: string;
  createTime?: string;
  domainName?: string;
  ossBucket?: string;
  ossEndpoint?: string;
  overwriteOssObject?: string;
  sequenceOssObject?: string;
  timeInterval?: number;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      callback: 'Callback',
      createTime: 'CreateTime',
      domainName: 'DomainName',
      ossBucket: 'OssBucket',
      ossEndpoint: 'OssEndpoint',
      overwriteOssObject: 'OverwriteOssObject',
      sequenceOssObject: 'SequenceOssObject',
      timeInterval: 'TimeInterval',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      callback: 'string',
      createTime: 'string',
      domainName: 'string',
      ossBucket: 'string',
      ossEndpoint: 'string',
      overwriteOssObject: 'string',
      sequenceOssObject: 'string',
      timeInterval: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigList extends $tea.Model {
  liveStreamSnapshotConfig?: DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig[];
  static names(): { [key: string]: string } {
    return {
      liveStreamSnapshotConfig: 'LiveStreamSnapshotConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveStreamSnapshotConfig: { 'type': 'array', 'itemType': DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfigScenes extends $tea.Model {
  scene?: string[];
  static names(): { [key: string]: string } {
    return {
      scene: 'scene',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scene: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig extends $tea.Model {
  appName?: string;
  domainName?: string;
  interval?: number;
  ossBucket?: string;
  ossEndpoint?: string;
  ossObject?: string;
  scenes?: DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfigScenes;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      interval: 'Interval',
      ossBucket: 'OssBucket',
      ossEndpoint: 'OssEndpoint',
      ossObject: 'OssObject',
      scenes: 'Scenes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      interval: 'number',
      ossBucket: 'string',
      ossEndpoint: 'string',
      ossObject: 'string',
      scenes: DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfigScenes,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigList extends $tea.Model {
  liveSnapshotDetectPornConfig?: DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig[];
  static names(): { [key: string]: string } {
    return {
      liveSnapshotDetectPornConfig: 'LiveSnapshotDetectPornConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveSnapshotDetectPornConfig: { 'type': 'array', 'itemType': DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo extends $tea.Model {
  audioFrameRate?: number;
  bitRate?: number;
  streamUrl?: string;
  time?: string;
  videoFrameRate?: number;
  static names(): { [key: string]: string } {
    return {
      audioFrameRate: 'AudioFrameRate',
      bitRate: 'BitRate',
      streamUrl: 'StreamUrl',
      time: 'Time',
      videoFrameRate: 'VideoFrameRate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFrameRate: 'number',
      bitRate: 'number',
      streamUrl: 'string',
      time: 'string',
      videoFrameRate: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfos extends $tea.Model {
  frameRateAndBitRateInfo?: DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo[];
  static names(): { [key: string]: string } {
    return {
      frameRateAndBitRateInfo: 'FrameRateAndBitRateInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      frameRateAndBitRateInfo: { 'type': 'array', 'itemType': DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail extends $tea.Model {
  count?: number;
  format?: string;
  videoDataRate?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      format: 'Format',
      videoDataRate: 'VideoDataRate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      format: 'string',
      videoDataRate: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetails extends $tea.Model {
  streamCountDetail?: DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail[];
  static names(): { [key: string]: string } {
    return {
      streamCountDetail: 'StreamCountDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      streamCountDetail: { 'type': 'array', 'itemType': DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo extends $tea.Model {
  count?: number;
  limit?: number;
  streamCountDetails?: DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetails;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      limit: 'Limit',
      streamCountDetails: 'StreamCountDetails',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      limit: 'number',
      streamCountDetails: DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetails,
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamCountResponseBodyStreamCountInfos extends $tea.Model {
  streamCountInfo?: DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo[];
  static names(): { [key: string]: string } {
    return {
      streamCountInfo: 'StreamCountInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      streamCountInfo: { 'type': 'array', 'itemType': DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamDelayConfigResponseBodyLiveStreamFlvDelayConfig extends $tea.Model {
  delay?: number;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      delay: 'Delay',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      delay: 'number',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamDelayConfigResponseBodyLiveStreamHlsDelayConfig extends $tea.Model {
  delay?: number;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      delay: 'Delay',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      delay: 'number',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamDelayConfigResponseBodyLiveStreamRtmpDelayConfig extends $tea.Model {
  delay?: number;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      delay: 'Delay',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      delay: 'number',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo extends $tea.Model {
  streamTime?: string;
  userNum?: string;
  static names(): { [key: string]: string } {
    return {
      streamTime: 'StreamTime',
      userNum: 'UserNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      streamTime: 'string',
      userNum: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfos extends $tea.Model {
  liveStreamUserNumInfo?: DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo[];
  static names(): { [key: string]: string } {
    return {
      liveStreamUserNumInfo: 'LiveStreamUserNumInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveStreamUserNumInfo: { 'type': 'array', 'itemType': DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData extends $tea.Model {
  appName?: string;
  bps?: number;
  count?: number;
  flvBps?: number;
  flvCount?: number;
  flvTraffic?: number;
  hlsBps?: number;
  hlsCount?: number;
  hlsTraffic?: number;
  p2pBps?: number;
  p2pCount?: number;
  p2pTraffic?: number;
  rtmpBps?: number;
  rtmpCount?: number;
  rtmpTraffic?: number;
  rtsBps?: number;
  rtsCount?: number;
  rtsTraffic?: number;
  streamName?: string;
  timeStamp?: string;
  traffic?: number;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      bps: 'Bps',
      count: 'Count',
      flvBps: 'FlvBps',
      flvCount: 'FlvCount',
      flvTraffic: 'FlvTraffic',
      hlsBps: 'HlsBps',
      hlsCount: 'HlsCount',
      hlsTraffic: 'HlsTraffic',
      p2pBps: 'P2pBps',
      p2pCount: 'P2pCount',
      p2pTraffic: 'P2pTraffic',
      rtmpBps: 'RtmpBps',
      rtmpCount: 'RtmpCount',
      rtmpTraffic: 'RtmpTraffic',
      rtsBps: 'RtsBps',
      rtsCount: 'RtsCount',
      rtsTraffic: 'RtsTraffic',
      streamName: 'StreamName',
      timeStamp: 'TimeStamp',
      traffic: 'Traffic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      bps: 'number',
      count: 'number',
      flvBps: 'number',
      flvCount: 'number',
      flvTraffic: 'number',
      hlsBps: 'number',
      hlsCount: 'number',
      hlsTraffic: 'number',
      p2pBps: 'number',
      p2pCount: 'number',
      p2pTraffic: 'number',
      rtmpBps: 'number',
      rtmpCount: 'number',
      rtmpTraffic: 'number',
      rtsBps: 'number',
      rtsCount: 'number',
      rtsTraffic: 'number',
      streamName: 'string',
      timeStamp: 'string',
      traffic: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailData extends $tea.Model {
  streamData?: DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData[];
  static names(): { [key: string]: string } {
    return {
      streamData: 'StreamData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      streamData: { 'type': 'array', 'itemType': DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListLayoutConfig extends $tea.Model {
  fillMode?: string;
  positionNormalized?: number[];
  positionRefer?: string;
  sizeNormalized?: number[];
  static names(): { [key: string]: string } {
    return {
      fillMode: 'FillMode',
      positionNormalized: 'PositionNormalized',
      positionRefer: 'PositionRefer',
      sizeNormalized: 'SizeNormalized',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fillMode: 'string',
      positionNormalized: { 'type': 'array', 'itemType': 'number' },
      positionRefer: 'string',
      sizeNormalized: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListPlayConfig extends $tea.Model {
  volumeRate?: number;
  static names(): { [key: string]: string } {
    return {
      volumeRate: 'VolumeRate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      volumeRate: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList extends $tea.Model {
  index?: number;
  inputUrl?: string;
  layoutConfig?: DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListLayoutConfig;
  layoutId?: number;
  playConfig?: DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListPlayConfig;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      inputUrl: 'InputUrl',
      layoutConfig: 'LayoutConfig',
      layoutId: 'LayoutId',
      playConfig: 'PlayConfig',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'number',
      inputUrl: 'string',
      layoutConfig: DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListLayoutConfig,
      layoutId: 'number',
      playConfig: DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListPlayConfig,
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListOutputUrls extends $tea.Model {
  flvUrl?: string;
  rtmpUrl?: string;
  static names(): { [key: string]: string } {
    return {
      flvUrl: 'FlvUrl',
      rtmpUrl: 'RtmpUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flvUrl: 'string',
      rtmpUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList extends $tea.Model {
  audioFrom?: number;
  domain?: string;
  inputList?: DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList[];
  monitorId?: string;
  monitorName?: string;
  outputTemplate?: string;
  outputUrls?: DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListOutputUrls;
  region?: string;
  startTime?: string;
  status?: number;
  stopTime?: string;
  static names(): { [key: string]: string } {
    return {
      audioFrom: 'AudioFrom',
      domain: 'Domain',
      inputList: 'InputList',
      monitorId: 'MonitorId',
      monitorName: 'MonitorName',
      outputTemplate: 'OutputTemplate',
      outputUrls: 'OutputUrls',
      region: 'Region',
      startTime: 'StartTime',
      status: 'Status',
      stopTime: 'StopTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFrom: 'number',
      domain: 'string',
      inputList: { 'type': 'array', 'itemType': DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList },
      monitorId: 'string',
      monitorName: 'string',
      outputTemplate: 'string',
      outputUrls: DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListOutputUrls,
      region: 'string',
      startTime: 'string',
      status: 'number',
      stopTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamOptimizedFeatureConfigResponseBodyLiveStreamOptimizedFeatureConfigListLiveStreamOptimizedFeatureConfig extends $tea.Model {
  configName?: string;
  configStatus?: string;
  configValue?: string;
  domainName?: string;
  static names(): { [key: string]: string } {
    return {
      configName: 'ConfigName',
      configStatus: 'ConfigStatus',
      configValue: 'ConfigValue',
      domainName: 'DomainName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configName: 'string',
      configStatus: 'string',
      configValue: 'string',
      domainName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamOptimizedFeatureConfigResponseBodyLiveStreamOptimizedFeatureConfigList extends $tea.Model {
  liveStreamOptimizedFeatureConfig?: DescribeLiveStreamOptimizedFeatureConfigResponseBodyLiveStreamOptimizedFeatureConfigListLiveStreamOptimizedFeatureConfig[];
  static names(): { [key: string]: string } {
    return {
      liveStreamOptimizedFeatureConfig: 'LiveStreamOptimizedFeatureConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveStreamOptimizedFeatureConfig: { 'type': 'array', 'itemType': DescribeLiveStreamOptimizedFeatureConfigResponseBodyLiveStreamOptimizedFeatureConfigListLiveStreamOptimizedFeatureConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo extends $tea.Model {
  duration?: number;
  endTime?: string;
  ossBucket?: string;
  ossEndpoint?: string;
  ossObjectPrefix?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
      endTime: 'EndTime',
      ossBucket: 'OssBucket',
      ossEndpoint: 'OssEndpoint',
      ossObjectPrefix: 'OssObjectPrefix',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'number',
      endTime: 'string',
      ossBucket: 'string',
      ossEndpoint: 'string',
      ossObjectPrefix: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamRecordContentResponseBodyRecordContentInfoList extends $tea.Model {
  recordContentInfo?: DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo[];
  static names(): { [key: string]: string } {
    return {
      recordContentInfo: 'RecordContentInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordContentInfo: { 'type': 'array', 'itemType': DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamRecordIndexFileResponseBodyRecordIndexInfo extends $tea.Model {
  appName?: string;
  createTime?: string;
  domainName?: string;
  duration?: number;
  endTime?: string;
  height?: number;
  ossBucket?: string;
  ossEndpoint?: string;
  ossObject?: string;
  recordId?: string;
  recordUrl?: string;
  startTime?: string;
  streamName?: string;
  width?: number;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      createTime: 'CreateTime',
      domainName: 'DomainName',
      duration: 'Duration',
      endTime: 'EndTime',
      height: 'Height',
      ossBucket: 'OssBucket',
      ossEndpoint: 'OssEndpoint',
      ossObject: 'OssObject',
      recordId: 'RecordId',
      recordUrl: 'RecordUrl',
      startTime: 'StartTime',
      streamName: 'StreamName',
      width: 'Width',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      createTime: 'string',
      domainName: 'string',
      duration: 'number',
      endTime: 'string',
      height: 'number',
      ossBucket: 'string',
      ossEndpoint: 'string',
      ossObject: 'string',
      recordId: 'string',
      recordUrl: 'string',
      startTime: 'string',
      streamName: 'string',
      width: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo extends $tea.Model {
  appName?: string;
  createTime?: string;
  domainName?: string;
  duration?: number;
  endTime?: string;
  height?: number;
  ossBucket?: string;
  ossEndpoint?: string;
  ossObject?: string;
  recordId?: string;
  recordUrl?: string;
  startTime?: string;
  streamName?: string;
  width?: number;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      createTime: 'CreateTime',
      domainName: 'DomainName',
      duration: 'Duration',
      endTime: 'EndTime',
      height: 'Height',
      ossBucket: 'OssBucket',
      ossEndpoint: 'OssEndpoint',
      ossObject: 'OssObject',
      recordId: 'RecordId',
      recordUrl: 'RecordUrl',
      startTime: 'StartTime',
      streamName: 'StreamName',
      width: 'Width',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      createTime: 'string',
      domainName: 'string',
      duration: 'number',
      endTime: 'string',
      height: 'number',
      ossBucket: 'string',
      ossEndpoint: 'string',
      ossObject: 'string',
      recordId: 'string',
      recordUrl: 'string',
      startTime: 'string',
      streamName: 'string',
      width: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoList extends $tea.Model {
  recordIndexInfo?: DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo[];
  static names(): { [key: string]: string } {
    return {
      recordIndexInfo: 'RecordIndexInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordIndexInfo: { 'type': 'array', 'itemType': DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo extends $tea.Model {
  createTime?: string;
  createTimestamp?: number;
  isOverlay?: boolean;
  ossBucket?: string;
  ossEndpoint?: string;
  ossObject?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      isOverlay: 'IsOverlay',
      ossBucket: 'OssBucket',
      ossEndpoint: 'OssEndpoint',
      ossObject: 'OssObject',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      createTimestamp: 'number',
      isOverlay: 'boolean',
      ossBucket: 'string',
      ossEndpoint: 'string',
      ossObject: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoList extends $tea.Model {
  liveStreamSnapshotInfo?: DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo[];
  static names(): { [key: string]: string } {
    return {
      liveStreamSnapshotInfo: 'LiveStreamSnapshotInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveStreamSnapshotInfo: { 'type': 'array', 'itemType': DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoCustomTranscodeParameters extends $tea.Model {
  audioBitrate?: number;
  audioChannelNum?: number;
  audioCodec?: string;
  audioProfile?: string;
  audioRate?: number;
  bframes?: string;
  FPS?: number;
  gop?: string;
  height?: number;
  rtsFlag?: string;
  templateType?: string;
  videoBitrate?: number;
  videoProfile?: string;
  width?: number;
  static names(): { [key: string]: string } {
    return {
      audioBitrate: 'AudioBitrate',
      audioChannelNum: 'AudioChannelNum',
      audioCodec: 'AudioCodec',
      audioProfile: 'AudioProfile',
      audioRate: 'AudioRate',
      bframes: 'Bframes',
      FPS: 'FPS',
      gop: 'Gop',
      height: 'Height',
      rtsFlag: 'RtsFlag',
      templateType: 'TemplateType',
      videoBitrate: 'VideoBitrate',
      videoProfile: 'VideoProfile',
      width: 'Width',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioBitrate: 'number',
      audioChannelNum: 'number',
      audioCodec: 'string',
      audioProfile: 'string',
      audioRate: 'number',
      bframes: 'string',
      FPS: 'number',
      gop: 'string',
      height: 'number',
      rtsFlag: 'string',
      templateType: 'string',
      videoBitrate: 'number',
      videoProfile: 'string',
      width: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoEncryptParameters extends $tea.Model {
  encryptType?: string;
  kmsKeyExpireInterval?: string;
  kmsKeyID?: string;
  static names(): { [key: string]: string } {
    return {
      encryptType: 'EncryptType',
      kmsKeyExpireInterval: 'KmsKeyExpireInterval',
      kmsKeyID: 'KmsKeyID',
    };
  }

  static types(): { [key: string]: any } {
    return {
      encryptType: 'string',
      kmsKeyExpireInterval: 'string',
      kmsKeyID: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo extends $tea.Model {
  customTranscodeParameters?: DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoCustomTranscodeParameters;
  encryptParameters?: DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoEncryptParameters;
  isLazy?: boolean;
  transcodeApp?: string;
  transcodeName?: string;
  transcodeTemplate?: string;
  static names(): { [key: string]: string } {
    return {
      customTranscodeParameters: 'CustomTranscodeParameters',
      encryptParameters: 'EncryptParameters',
      isLazy: 'IsLazy',
      transcodeApp: 'TranscodeApp',
      transcodeName: 'TranscodeName',
      transcodeTemplate: 'TranscodeTemplate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customTranscodeParameters: DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoCustomTranscodeParameters,
      encryptParameters: DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoEncryptParameters,
      isLazy: 'boolean',
      transcodeApp: 'string',
      transcodeName: 'string',
      transcodeTemplate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeList extends $tea.Model {
  domainTranscodeInfo?: DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo[];
  static names(): { [key: string]: string } {
    return {
      domainTranscodeInfo: 'DomainTranscodeInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainTranscodeInfo: { 'type': 'array', 'itemType': DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo extends $tea.Model {
  app?: string;
  description?: string;
  domain?: string;
  name?: string;
  ruleId?: string;
  stream?: string;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      description: 'Description',
      domain: 'Domain',
      name: 'Name',
      ruleId: 'RuleId',
      stream: 'Stream',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      description: 'string',
      domain: 'string',
      name: 'string',
      ruleId: 'string',
      stream: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoList extends $tea.Model {
  ruleInfo?: DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo[];
  static names(): { [key: string]: string } {
    return {
      ruleInfo: 'RuleInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleInfo: { 'type': 'array', 'itemType': DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark extends $tea.Model {
  description?: string;
  height?: number;
  name?: string;
  offsetCorner?: string;
  pictureUrl?: string;
  refHeight?: number;
  refWidth?: number;
  templateId?: string;
  transparency?: number;
  type?: number;
  XOffset?: number;
  YOffset?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      height: 'Height',
      name: 'Name',
      offsetCorner: 'OffsetCorner',
      pictureUrl: 'PictureUrl',
      refHeight: 'RefHeight',
      refWidth: 'RefWidth',
      templateId: 'TemplateId',
      transparency: 'Transparency',
      type: 'Type',
      XOffset: 'XOffset',
      YOffset: 'YOffset',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      height: 'number',
      name: 'string',
      offsetCorner: 'string',
      pictureUrl: 'string',
      refHeight: 'number',
      refWidth: 'number',
      templateId: 'string',
      transparency: 'number',
      type: 'number',
      XOffset: 'number',
      YOffset: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamWatermarksResponseBodyWatermarkList extends $tea.Model {
  watermark?: DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark[];
  static names(): { [key: string]: string } {
    return {
      watermark: 'Watermark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      watermark: { 'type': 'array', 'itemType': DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsBlockListResponseBodyStreamUrls extends $tea.Model {
  streamUrl?: string[];
  static names(): { [key: string]: string } {
    return {
      streamUrl: 'StreamUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      streamUrl: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo extends $tea.Model {
  action?: string;
  clientIP?: string;
  streamName?: string;
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      clientIP: 'ClientIP',
      streamName: 'StreamName',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      clientIP: 'string',
      streamName: 'string',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsControlHistoryResponseBodyControlInfo extends $tea.Model {
  liveStreamControlInfo?: DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo[];
  static names(): { [key: string]: string } {
    return {
      liveStreamControlInfo: 'LiveStreamControlInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveStreamControlInfo: { 'type': 'array', 'itemType': DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo extends $tea.Model {
  appName?: string;
  description?: string;
  domainName?: string;
  notifyContent?: string;
  notifyResult?: string;
  notifyTime?: string;
  notifyType?: string;
  notifyUrl?: string;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      description: 'Description',
      domainName: 'DomainName',
      notifyContent: 'NotifyContent',
      notifyResult: 'NotifyResult',
      notifyTime: 'NotifyTime',
      notifyType: 'NotifyType',
      notifyUrl: 'NotifyUrl',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      description: 'string',
      domainName: 'string',
      notifyContent: 'string',
      notifyResult: 'string',
      notifyTime: 'string',
      notifyType: 'string',
      notifyUrl: 'string',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfo extends $tea.Model {
  liveStreamNotifyRecordsInfo?: DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo[];
  static names(): { [key: string]: string } {
    return {
      liveStreamNotifyRecordsInfo: 'LiveStreamNotifyRecordsInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveStreamNotifyRecordsInfo: { 'type': 'array', 'itemType': DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig extends $tea.Model {
  domainName?: string;
  notifyAuthKey?: string;
  notifyReqAuth?: string;
  notifyUrl?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      notifyAuthKey: 'NotifyAuthKey',
      notifyReqAuth: 'NotifyReqAuth',
      notifyUrl: 'NotifyUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      notifyAuthKey: 'string',
      notifyReqAuth: 'string',
      notifyUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo extends $tea.Model {
  appName?: string;
  audioCodecId?: number;
  clientIp?: string;
  domainName?: string;
  frameRate?: number;
  height?: number;
  publishDomain?: string;
  publishTime?: string;
  publishType?: string;
  publishUrl?: string;
  serverIp?: string;
  streamName?: string;
  transcoded?: string;
  videoCodecId?: number;
  width?: number;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      audioCodecId: 'AudioCodecId',
      clientIp: 'ClientIp',
      domainName: 'DomainName',
      frameRate: 'FrameRate',
      height: 'Height',
      publishDomain: 'PublishDomain',
      publishTime: 'PublishTime',
      publishType: 'PublishType',
      publishUrl: 'PublishUrl',
      serverIp: 'ServerIp',
      streamName: 'StreamName',
      transcoded: 'Transcoded',
      videoCodecId: 'VideoCodecId',
      width: 'Width',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      audioCodecId: 'number',
      clientIp: 'string',
      domainName: 'string',
      frameRate: 'number',
      height: 'number',
      publishDomain: 'string',
      publishTime: 'string',
      publishType: 'string',
      publishUrl: 'string',
      serverIp: 'string',
      streamName: 'string',
      transcoded: 'string',
      videoCodecId: 'number',
      width: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsOnlineListResponseBodyOnlineInfo extends $tea.Model {
  liveStreamOnlineInfo?: DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo[];
  static names(): { [key: string]: string } {
    return {
      liveStreamOnlineInfo: 'LiveStreamOnlineInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveStreamOnlineInfo: { 'type': 'array', 'itemType': DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo extends $tea.Model {
  appName?: string;
  clientAddr?: string;
  domainName?: string;
  edgeNodeAddr?: string;
  publishDomain?: string;
  publishTime?: string;
  publishType?: string;
  publishUrl?: string;
  stopTime?: string;
  streamName?: string;
  streamUrl?: string;
  transcodeId?: string;
  transcoded?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      clientAddr: 'ClientAddr',
      domainName: 'DomainName',
      edgeNodeAddr: 'EdgeNodeAddr',
      publishDomain: 'PublishDomain',
      publishTime: 'PublishTime',
      publishType: 'PublishType',
      publishUrl: 'PublishUrl',
      stopTime: 'StopTime',
      streamName: 'StreamName',
      streamUrl: 'StreamUrl',
      transcodeId: 'TranscodeId',
      transcoded: 'Transcoded',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      clientAddr: 'string',
      domainName: 'string',
      edgeNodeAddr: 'string',
      publishDomain: 'string',
      publishTime: 'string',
      publishType: 'string',
      publishUrl: 'string',
      stopTime: 'string',
      streamName: 'string',
      streamUrl: 'string',
      transcodeId: 'string',
      transcoded: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveStreamsPublishListResponseBodyPublishInfo extends $tea.Model {
  liveStreamPublishInfo?: DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo[];
  static names(): { [key: string]: string } {
    return {
      liveStreamPublishInfo: 'LiveStreamPublishInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveStreamPublishInfo: { 'type': 'array', 'itemType': DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveTagResourcesRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveTagResourcesResponseBodyTagResourcesTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveTagResourcesResponseBodyTagResources extends $tea.Model {
  resourceId?: string;
  tag?: DescribeLiveTagResourcesResponseBodyTagResourcesTag[];
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: 'string',
      tag: { 'type': 'array', 'itemType': DescribeLiveTagResourcesResponseBodyTagResourcesTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain extends $tea.Model {
  domainName?: string;
  maxBps?: number;
  maxBpsTime?: string;
  rank?: number;
  totalAccess?: number;
  totalTraffic?: string;
  trafficPercent?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      maxBps: 'MaxBps',
      maxBpsTime: 'MaxBpsTime',
      rank: 'Rank',
      totalAccess: 'TotalAccess',
      totalTraffic: 'TotalTraffic',
      trafficPercent: 'TrafficPercent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      maxBps: 'number',
      maxBpsTime: 'string',
      rank: 'number',
      totalAccess: 'number',
      totalTraffic: 'string',
      trafficPercent: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveTopDomainsByFlowResponseBodyTopDomains extends $tea.Model {
  topDomain?: DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain[];
  static names(): { [key: string]: string } {
    return {
      topDomain: 'TopDomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topDomain: { 'type': 'array', 'itemType': DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem extends $tea.Model {
  area?: string;
  timeStp?: string;
  value?: number;
  static names(): { [key: string]: string } {
    return {
      area: 'Area',
      timeStp: 'TimeStp',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      area: 'string',
      timeStp: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveUserBillPredictionResponseBodyBillPredictionData extends $tea.Model {
  billPredictionDataItem?: DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem[];
  static names(): { [key: string]: string } {
    return {
      billPredictionDataItem: 'BillPredictionDataItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      billPredictionDataItem: { 'type': 'array', 'itemType': DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveUserDomainsRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveUserDomainsResponseBodyDomainsPageData extends $tea.Model {
  cname?: string;
  description?: string;
  domainName?: string;
  gmtCreated?: string;
  gmtModified?: string;
  liveDomainStatus?: string;
  liveDomainType?: string;
  regionName?: string;
  static names(): { [key: string]: string } {
    return {
      cname: 'Cname',
      description: 'Description',
      domainName: 'DomainName',
      gmtCreated: 'GmtCreated',
      gmtModified: 'GmtModified',
      liveDomainStatus: 'LiveDomainStatus',
      liveDomainType: 'LiveDomainType',
      regionName: 'RegionName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cname: 'string',
      description: 'string',
      domainName: 'string',
      gmtCreated: 'string',
      gmtModified: 'string',
      liveDomainStatus: 'string',
      liveDomainType: 'string',
      regionName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveUserDomainsResponseBodyDomains extends $tea.Model {
  pageData?: DescribeLiveUserDomainsResponseBodyDomainsPageData[];
  static names(): { [key: string]: string } {
    return {
      pageData: 'PageData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageData: { 'type': 'array', 'itemType': DescribeLiveUserDomainsResponseBodyDomainsPageData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLiveUserTagsResponseBodyTags extends $tea.Model {
  key?: string;
  value?: string[];
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMeterLiveRtcDurationResponseBodyData extends $tea.Model {
  audioDuration?: number;
  timestamp?: string;
  totalDuration?: number;
  v1080Duration?: number;
  v480Duration?: number;
  v720Duration?: number;
  static names(): { [key: string]: string } {
    return {
      audioDuration: 'AudioDuration',
      timestamp: 'Timestamp',
      totalDuration: 'TotalDuration',
      v1080Duration: 'V1080Duration',
      v480Duration: 'V480Duration',
      v720Duration: 'V720Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioDuration: 'number',
      timestamp: 'string',
      totalDuration: 'number',
      v1080Duration: 'number',
      v480Duration: 'number',
      v720Duration: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMixStreamListResponseBodyMixStreamList extends $tea.Model {
  appName?: string;
  domainName?: string;
  gmtCreate?: string;
  gmtModified?: string;
  inputStreamNumber?: number;
  layoutId?: string;
  mixStreamTemplate?: string;
  mixstreamId?: string;
  streamName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      inputStreamNumber: 'InputStreamNumber',
      layoutId: 'LayoutId',
      mixStreamTemplate: 'MixStreamTemplate',
      mixstreamId: 'MixstreamId',
      streamName: 'StreamName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      inputStreamNumber: 'number',
      layoutId: 'string',
      mixStreamTemplate: 'string',
      mixstreamId: 'string',
      streamName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData extends $tea.Model {
  connected?: string;
  finishGetStreamInfo?: string;
  firstFrameComplete?: string;
  firstPacket?: string;
  initialized?: string;
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      connected: 'Connected',
      finishGetStreamInfo: 'FinishGetStreamInfo',
      firstFrameComplete: 'FirstFrameComplete',
      firstPacket: 'FirstPacket',
      initialized: 'Initialized',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connected: 'string',
      finishGetStreamInfo: 'string',
      firstFrameComplete: 'string',
      firstPacket: 'string',
      initialized: 'string',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData extends $tea.Model {
  frameDelay?: string;
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      frameDelay: 'FrameDelay',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      frameDelay: 'string',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus extends $tea.Model {
  timeStamp?: string;
  v20001?: string;
  v20002?: string;
  v20011?: string;
  v20012?: string;
  v20013?: string;
  v20052?: string;
  static names(): { [key: string]: string } {
    return {
      timeStamp: 'TimeStamp',
      v20001: 'V20001',
      v20002: 'V20002',
      v20011: 'V20011',
      v20012: 'V20012',
      v20013: 'V20013',
      v20052: 'V20052',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeStamp: 'string',
      v20001: 'string',
      v20002: 'string',
      v20011: 'string',
      v20012: 'string',
      v20013: 'string',
      v20052: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData extends $tea.Model {
  playTime?: string;
  stallTime?: string;
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      playTime: 'PlayTime',
      stallTime: 'StallTime',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      playTime: 'string',
      stallTime: 'string',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRTSNativeSDKVvDataResponseBodyVvData extends $tea.Model {
  timeStamp?: string;
  vvSuccess?: string;
  vvTotal?: string;
  static names(): { [key: string]: string } {
    return {
      timeStamp: 'TimeStamp',
      vvSuccess: 'VvSuccess',
      vvTotal: 'VvTotal',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeStamp: 'string',
      vvSuccess: 'string',
      vvTotal: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoomKickoutUserListResponseBodyUserList extends $tea.Model {
  appUid?: string;
  opEndTime?: string;
  opStartTime?: string;
  static names(): { [key: string]: string } {
    return {
      appUid: 'AppUid',
      opEndTime: 'OpEndTime',
      opStartTime: 'OpStartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appUid: 'string',
      opEndTime: 'string',
      opStartTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoomListResponseBodyRoomList extends $tea.Model {
  anchorId?: string;
  createTime?: string;
  forbidStream?: string;
  roomId?: string;
  roomStatus?: number;
  static names(): { [key: string]: string } {
    return {
      anchorId: 'AnchorId',
      createTime: 'CreateTime',
      forbidStream: 'ForbidStream',
      roomId: 'RoomId',
      roomStatus: 'RoomStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      anchorId: 'string',
      createTime: 'string',
      forbidStream: 'string',
      roomId: 'string',
      roomStatus: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeShowListResponseBodyShowListInfoShowListShowResourceInfo extends $tea.Model {
  liveInputType?: number;
  resourceId?: string;
  resourceType?: string;
  resourceUrl?: string;
  static names(): { [key: string]: string } {
    return {
      liveInputType: 'LiveInputType',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      resourceUrl: 'ResourceUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveInputType: 'number',
      resourceId: 'string',
      resourceType: 'string',
      resourceUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeShowListResponseBodyShowListInfoShowListShow extends $tea.Model {
  duration?: number;
  repeatTimes?: number;
  resourceInfo?: DescribeShowListResponseBodyShowListInfoShowListShowResourceInfo;
  showId?: string;
  showName?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
      repeatTimes: 'RepeatTimes',
      resourceInfo: 'ResourceInfo',
      showId: 'ShowId',
      showName: 'ShowName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'number',
      repeatTimes: 'number',
      resourceInfo: DescribeShowListResponseBodyShowListInfoShowListShowResourceInfo,
      showId: 'string',
      showName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeShowListResponseBodyShowListInfoShowList extends $tea.Model {
  show?: DescribeShowListResponseBodyShowListInfoShowListShow[];
  static names(): { [key: string]: string } {
    return {
      show: 'Show',
    };
  }

  static types(): { [key: string]: any } {
    return {
      show: { 'type': 'array', 'itemType': DescribeShowListResponseBodyShowListInfoShowListShow },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeShowListResponseBodyShowListInfo extends $tea.Model {
  currentShowId?: string;
  highPriorityShowId?: string;
  highPriorityShowStartTime?: string;
  showList?: DescribeShowListResponseBodyShowListInfoShowList;
  showListRepeatTimes?: number;
  totalShowListRepeatTimes?: number;
  static names(): { [key: string]: string } {
    return {
      currentShowId: 'CurrentShowId',
      highPriorityShowId: 'HighPriorityShowId',
      highPriorityShowStartTime: 'HighPriorityShowStartTime',
      showList: 'ShowList',
      showListRepeatTimes: 'ShowListRepeatTimes',
      totalShowListRepeatTimes: 'TotalShowListRepeatTimes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentShowId: 'string',
      highPriorityShowId: 'string',
      highPriorityShowStartTime: 'string',
      showList: DescribeShowListResponseBodyShowListInfoShowList,
      showListRepeatTimes: 'number',
      totalShowListRepeatTimes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStudioLayoutsResponseBodyStudioLayoutsBgImageConfig extends $tea.Model {
  id?: string;
  imageUrl?: string;
  locationId?: string;
  materialId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      imageUrl: 'ImageUrl',
      locationId: 'LocationId',
      materialId: 'MaterialId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      imageUrl: 'string',
      locationId: 'string',
      materialId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStudioLayoutsResponseBodyStudioLayoutsCommonConfig extends $tea.Model {
  channelId?: string;
  videoResourceId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      videoResourceId: 'VideoResourceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      videoResourceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList extends $tea.Model {
  id?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList extends $tea.Model {
  channelId?: string;
  fillMode?: string;
  heightNormalized?: number;
  id?: string;
  imageMaterialId?: string;
  index?: number;
  positionNormalized?: number[];
  positionRefer?: string;
  videoResourceId?: string;
  widthNormalized?: number;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      fillMode: 'FillMode',
      heightNormalized: 'HeightNormalized',
      id: 'Id',
      imageMaterialId: 'ImageMaterialId',
      index: 'Index',
      positionNormalized: 'PositionNormalized',
      positionRefer: 'PositionRefer',
      videoResourceId: 'VideoResourceId',
      widthNormalized: 'WidthNormalized',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      fillMode: 'string',
      heightNormalized: 'number',
      id: 'string',
      imageMaterialId: 'string',
      index: 'number',
      positionNormalized: { 'type': 'array', 'itemType': 'number' },
      positionRefer: 'string',
      videoResourceId: 'string',
      widthNormalized: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigListAudioConfig extends $tea.Model {
  validChannel?: string;
  volumeRate?: number;
  static names(): { [key: string]: string } {
    return {
      validChannel: 'ValidChannel',
      volumeRate: 'VolumeRate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      validChannel: 'string',
      volumeRate: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList extends $tea.Model {
  audioConfig?: DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigListAudioConfig;
  channelId?: string;
  color?: string;
  heightNormalized?: number;
  id?: string;
  index?: number;
  onlyAudio?: boolean;
  portraitType?: number;
  positionX?: string;
  positionY?: string;
  videoResourceId?: string;
  static names(): { [key: string]: string } {
    return {
      audioConfig: 'AudioConfig',
      channelId: 'ChannelId',
      color: 'Color',
      heightNormalized: 'HeightNormalized',
      id: 'Id',
      index: 'Index',
      onlyAudio: 'OnlyAudio',
      portraitType: 'PortraitType',
      positionX: 'PositionX',
      positionY: 'PositionY',
      videoResourceId: 'VideoResourceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioConfig: DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigListAudioConfig,
      channelId: 'string',
      color: 'string',
      heightNormalized: 'number',
      id: 'string',
      index: 'number',
      onlyAudio: 'boolean',
      portraitType: 'number',
      positionX: 'string',
      positionY: 'string',
      videoResourceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStudioLayoutsResponseBodyStudioLayouts extends $tea.Model {
  bgImageConfig?: DescribeStudioLayoutsResponseBodyStudioLayoutsBgImageConfig;
  commonConfig?: DescribeStudioLayoutsResponseBodyStudioLayoutsCommonConfig;
  layerOrderConfigList?: DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList[];
  layoutId?: string;
  layoutName?: string;
  layoutType?: string;
  mediaInputConfigList?: DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList[];
  screenInputConfigList?: DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList[];
  static names(): { [key: string]: string } {
    return {
      bgImageConfig: 'BgImageConfig',
      commonConfig: 'CommonConfig',
      layerOrderConfigList: 'LayerOrderConfigList',
      layoutId: 'LayoutId',
      layoutName: 'LayoutName',
      layoutType: 'LayoutType',
      mediaInputConfigList: 'MediaInputConfigList',
      screenInputConfigList: 'ScreenInputConfigList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bgImageConfig: DescribeStudioLayoutsResponseBodyStudioLayoutsBgImageConfig,
      commonConfig: DescribeStudioLayoutsResponseBodyStudioLayoutsCommonConfig,
      layerOrderConfigList: { 'type': 'array', 'itemType': DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList },
      layoutId: 'string',
      layoutName: 'string',
      layoutType: 'string',
      mediaInputConfigList: { 'type': 'array', 'itemType': DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList },
      screenInputConfigList: { 'type': 'array', 'itemType': DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeToutiaoLivePlayResponseBodyContent extends $tea.Model {
  app?: string;
  bandwidth?: number;
  cdnName?: string;
  domain?: string;
  playNum?: number;
  streamName?: string;
  timestamp?: number;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      bandwidth: 'Bandwidth',
      cdnName: 'CdnName',
      domain: 'Domain',
      playNum: 'PlayNum',
      streamName: 'StreamName',
      timestamp: 'Timestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      bandwidth: 'number',
      cdnName: 'string',
      domain: 'string',
      playNum: 'number',
      streamName: 'string',
      timestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeToutiaoLivePublishResponseBodyContent extends $tea.Model {
  app?: string;
  bitrate?: number;
  bwDiff?: number;
  cdnName?: string;
  domain?: string;
  flr?: number;
  fps?: number;
  streamName?: string;
  timestamp?: number;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      bitrate: 'Bitrate',
      bwDiff: 'BwDiff',
      cdnName: 'CdnName',
      domain: 'Domain',
      flr: 'Flr',
      fps: 'Fps',
      streamName: 'StreamName',
      timestamp: 'Timestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      bitrate: 'number',
      bwDiff: 'number',
      cdnName: 'string',
      domain: 'string',
      flr: 'number',
      fps: 'number',
      streamName: 'string',
      timestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic extends $tea.Model {
  bandWidth?: string;
  peakTime?: string;
  queryTime?: string;
  statName?: string;
  static names(): { [key: string]: string } {
    return {
      bandWidth: 'BandWidth',
      peakTime: 'PeakTime',
      queryTime: 'QueryTime',
      statName: 'StatName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bandWidth: 'string',
      peakTime: 'string',
      queryTime: 'string',
      statName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTraffics extends $tea.Model {
  describeUpPeakTraffic?: DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic[];
  static names(): { [key: string]: string } {
    return {
      describeUpPeakTraffic: 'DescribeUpPeakTraffic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      describeUpPeakTraffic: { 'type': 'array', 'itemType': DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine extends $tea.Model {
  bandWidth?: number;
  peakTime?: string;
  queryTime?: string;
  statName?: string;
  static names(): { [key: string]: string } {
    return {
      bandWidth: 'BandWidth',
      peakTime: 'PeakTime',
      queryTime: 'QueryTime',
      statName: 'StatName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bandWidth: 'number',
      peakTime: 'string',
      queryTime: 'string',
      statName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLines extends $tea.Model {
  describeUpBpsPeakOfLine?: DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine[];
  static names(): { [key: string]: string } {
    return {
      describeUpBpsPeakOfLine: 'DescribeUpBpsPeakOfLine',
    };
  }

  static types(): { [key: string]: any } {
    return {
      describeUpBpsPeakOfLine: { 'type': 'array', 'itemType': DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData extends $tea.Model {
  bandWidth?: string;
  peakTime?: string;
  publishStreamNum?: number;
  queryTime?: string;
  statName?: string;
  static names(): { [key: string]: string } {
    return {
      bandWidth: 'BandWidth',
      peakTime: 'PeakTime',
      publishStreamNum: 'PublishStreamNum',
      queryTime: 'QueryTime',
      statName: 'StatName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bandWidth: 'string',
      peakTime: 'string',
      publishStreamNum: 'number',
      queryTime: 'string',
      statName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatas extends $tea.Model {
  describeUpPeakPublishStreamData?: DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData[];
  static names(): { [key: string]: string } {
    return {
      describeUpPeakPublishStreamData: 'DescribeUpPeakPublishStreamData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      describeUpPeakPublishStreamData: { 'type': 'array', 'itemType': DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditPlaylistResponseBodyItemsFailedItems extends $tea.Model {
  itemId?: string;
  itemName?: string;
  static names(): { [key: string]: string } {
    return {
      itemId: 'ItemId',
      itemName: 'ItemName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemId: 'string',
      itemName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditPlaylistResponseBodyItemsSuccessItems extends $tea.Model {
  itemId?: string;
  itemName?: string;
  static names(): { [key: string]: string } {
    return {
      itemId: 'ItemId',
      itemName: 'ItemName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemId: 'string',
      itemName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditPlaylistResponseBodyItems extends $tea.Model {
  failedItems?: EditPlaylistResponseBodyItemsFailedItems[];
  successItems?: EditPlaylistResponseBodyItemsSuccessItems[];
  static names(): { [key: string]: string } {
    return {
      failedItems: 'FailedItems',
      successItems: 'SuccessItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedItems: { 'type': 'array', 'itemType': EditPlaylistResponseBodyItemsFailedItems },
      successItems: { 'type': 'array', 'itemType': EditPlaylistResponseBodyItemsSuccessItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMessageAppResponseBodyResult extends $tea.Model {
  appConfig?: { [key: string]: string };
  appId?: string;
  appName?: string;
  createTime?: number;
  extension?: { [key: string]: string };
  status?: number;
  static names(): { [key: string]: string } {
    return {
      appConfig: 'AppConfig',
      appId: 'AppId',
      appName: 'AppName',
      createTime: 'CreateTime',
      extension: 'Extension',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      appId: 'string',
      appName: 'string',
      createTime: 'number',
      extension: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMessageGroupResponseBodyResult extends $tea.Model {
  createTime?: number;
  creatorId?: string;
  extension?: { [key: string]: any };
  groupId?: string;
  isMuteAll?: boolean;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      extension: 'Extension',
      groupId: 'GroupId',
      isMuteAll: 'IsMuteAll',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      creatorId: 'string',
      extension: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      groupId: 'string',
      isMuteAll: 'boolean',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMessageTokenResponseBodyResult extends $tea.Model {
  accessToken?: string;
  accessTokenExpiredTime?: number;
  refreshToken?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'AccessToken',
      accessTokenExpiredTime: 'AccessTokenExpiredTime',
      refreshToken: 'RefreshToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      accessTokenExpiredTime: 'number',
      refreshToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMultiRateConfigResponseBodyTemplatesInfoDetail extends $tea.Model {
  audioBitrate?: number;
  audioChannelNum?: number;
  audioCodec?: string;
  audioProfile?: string;
  audioRate?: number;
  bandWidth?: number;
  fps?: number;
  gop?: string;
  height?: number;
  profile?: number;
  template?: string;
  templateType?: string;
  videoBitrate?: number;
  width?: number;
  static names(): { [key: string]: string } {
    return {
      audioBitrate: 'AudioBitrate',
      audioChannelNum: 'AudioChannelNum',
      audioCodec: 'AudioCodec',
      audioProfile: 'AudioProfile',
      audioRate: 'AudioRate',
      bandWidth: 'BandWidth',
      fps: 'Fps',
      gop: 'Gop',
      height: 'Height',
      profile: 'Profile',
      template: 'Template',
      templateType: 'TemplateType',
      videoBitrate: 'VideoBitrate',
      width: 'Width',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioBitrate: 'number',
      audioChannelNum: 'number',
      audioCodec: 'string',
      audioProfile: 'string',
      audioRate: 'number',
      bandWidth: 'number',
      fps: 'number',
      gop: 'string',
      height: 'number',
      profile: 'number',
      template: 'string',
      templateType: 'string',
      videoBitrate: 'number',
      width: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMultiRateConfigResponseBodyTemplatesInfo extends $tea.Model {
  detail?: GetMultiRateConfigResponseBodyTemplatesInfoDetail[];
  static names(): { [key: string]: string } {
    return {
      detail: 'Detail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      detail: { 'type': 'array', 'itemType': GetMultiRateConfigResponseBodyTemplatesInfoDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMultiRateConfigListResponseBodyGroupInfoInfo extends $tea.Model {
  app?: string;
  avFormat?: string;
  count?: number;
  groupId?: string;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      avFormat: 'AvFormat',
      count: 'Count',
      groupId: 'GroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      avFormat: 'string',
      count: 'number',
      groupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMultiRateConfigListResponseBodyGroupInfo extends $tea.Model {
  info?: GetMultiRateConfigListResponseBodyGroupInfoInfo[];
  static names(): { [key: string]: string } {
    return {
      info: 'Info',
    };
  }

  static types(): { [key: string]: any } {
    return {
      info: { 'type': 'array', 'itemType': GetMultiRateConfigListResponseBodyGroupInfoInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinMessageGroupResponseBodyResult extends $tea.Model {
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LeaveMessageGroupResponseBodyResult extends $tea.Model {
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo extends $tea.Model {
  dmId?: number;
  domainName?: string;
  logstore?: string;
  project?: string;
  region?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      dmId: 'DmId',
      domainName: 'DomainName',
      logstore: 'Logstore',
      project: 'Project',
      region: 'Region',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dmId: 'number',
      domainName: 'string',
      logstore: 'string',
      project: 'string',
      region: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLiveRealtimeLogDeliveryResponseBodyContent extends $tea.Model {
  realtimeLogDeliveryInfo?: ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo[];
  static names(): { [key: string]: string } {
    return {
      realtimeLogDeliveryInfo: 'RealtimeLogDeliveryInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      realtimeLogDeliveryInfo: { 'type': 'array', 'itemType': ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains extends $tea.Model {
  domainName?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLiveRealtimeLogDeliveryDomainsResponseBodyContent extends $tea.Model {
  domains?: ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains[];
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: { 'type': 'array', 'itemType': ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos extends $tea.Model {
  logstore?: string;
  project?: string;
  region?: string;
  static names(): { [key: string]: string } {
    return {
      logstore: 'Logstore',
      project: 'Project',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logstore: 'string',
      project: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLiveRealtimeLogDeliveryInfosResponseBodyContent extends $tea.Model {
  realtimeLogDeliveryInfos?: ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos[];
  static names(): { [key: string]: string } {
    return {
      realtimeLogDeliveryInfos: 'RealtimeLogDeliveryInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      realtimeLogDeliveryInfos: { 'type': 'array', 'itemType': ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageResponseBodyResultMessageList extends $tea.Model {
  data?: string;
  groupId?: string;
  messageId?: string;
  senderId?: string;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      groupId: 'GroupId',
      messageId: 'MessageId',
      senderId: 'SenderId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      groupId: 'string',
      messageId: 'string',
      senderId: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageResponseBodyResult extends $tea.Model {
  hasMore?: boolean;
  messageList?: ListMessageResponseBodyResultMessageList[];
  static names(): { [key: string]: string } {
    return {
      hasMore: 'HasMore',
      messageList: 'MessageList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hasMore: 'boolean',
      messageList: { 'type': 'array', 'itemType': ListMessageResponseBodyResultMessageList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageAppResponseBodyResultAppList extends $tea.Model {
  appConfig?: { [key: string]: string };
  appId?: string;
  appName?: string;
  createTime?: number;
  extension?: { [key: string]: string };
  status?: number;
  static names(): { [key: string]: string } {
    return {
      appConfig: 'AppConfig',
      appId: 'AppId',
      appName: 'AppName',
      createTime: 'CreateTime',
      extension: 'Extension',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      appId: 'string',
      appName: 'string',
      createTime: 'number',
      extension: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageAppResponseBodyResult extends $tea.Model {
  appList?: ListMessageAppResponseBodyResultAppList[];
  hasMore?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      appList: 'AppList',
      hasMore: 'HasMore',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appList: { 'type': 'array', 'itemType': ListMessageAppResponseBodyResultAppList },
      hasMore: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageGroupResponseBodyResultGroupList extends $tea.Model {
  appId?: string;
  createTime?: number;
  creatorId?: string;
  extension?: { [key: string]: string };
  groupId?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      extension: 'Extension',
      groupId: 'GroupId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      createTime: 'number',
      creatorId: 'string',
      extension: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      groupId: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageGroupResponseBodyResult extends $tea.Model {
  groupList?: ListMessageGroupResponseBodyResultGroupList[];
  hasMore?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      groupList: 'GroupList',
      hasMore: 'HasMore',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupList: { 'type': 'array', 'itemType': ListMessageGroupResponseBodyResultGroupList },
      hasMore: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageGroupUserResponseBodyResultUserList extends $tea.Model {
  joinTime?: number;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      joinTime: 'JoinTime',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      joinTime: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageGroupUserResponseBodyResult extends $tea.Model {
  hasMore?: boolean;
  total?: number;
  userList?: ListMessageGroupUserResponseBodyResultUserList[];
  static names(): { [key: string]: string } {
    return {
      hasMore: 'HasMore',
      total: 'Total',
      userList: 'UserList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hasMore: 'boolean',
      total: 'number',
      userList: { 'type': 'array', 'itemType': ListMessageGroupUserResponseBodyResultUserList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageGroupUserByIdResponseBodyResultUserList extends $tea.Model {
  isMute?: boolean;
  muteBy?: string[];
  userAvatar?: string;
  userExtension?: string;
  userId?: string;
  userNick?: string;
  static names(): { [key: string]: string } {
    return {
      isMute: 'IsMute',
      muteBy: 'MuteBy',
      userAvatar: 'UserAvatar',
      userExtension: 'UserExtension',
      userId: 'UserId',
      userNick: 'UserNick',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isMute: 'boolean',
      muteBy: { 'type': 'array', 'itemType': 'string' },
      userAvatar: 'string',
      userExtension: 'string',
      userId: 'string',
      userNick: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMessageGroupUserByIdResponseBodyResult extends $tea.Model {
  hasMore?: boolean;
  total?: number;
  userList?: ListMessageGroupUserByIdResponseBodyResultUserList[];
  static names(): { [key: string]: string } {
    return {
      hasMore: 'HasMore',
      total: 'Total',
      userList: 'UserList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hasMore: 'boolean',
      total: 'number',
      userList: { 'type': 'array', 'itemType': ListMessageGroupUserByIdResponseBodyResultUserList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPlaylistResponseBodyProgramList extends $tea.Model {
  casterId?: string;
  domainName?: string;
  programId?: string;
  programName?: string;
  repeatNumber?: number;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      casterId: 'CasterId',
      domainName: 'DomainName',
      programId: 'ProgramId',
      programName: 'ProgramName',
      repeatNumber: 'RepeatNumber',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casterId: 'string',
      domainName: 'string',
      programId: 'string',
      programName: 'string',
      repeatNumber: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPlaylistItemsResponseBodyProgramItems extends $tea.Model {
  index?: number;
  programId?: string;
  programItemId?: string;
  programItemName?: string;
  resourceType?: string;
  resourceValue?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      programId: 'ProgramId',
      programItemId: 'ProgramItemId',
      programItemName: 'ProgramItemName',
      resourceType: 'ResourceType',
      resourceValue: 'ResourceValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'number',
      programId: 'string',
      programItemId: 'string',
      programItemName: 'string',
      resourceType: 'string',
      resourceValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCasterLayoutRequestAudioLayer extends $tea.Model {
  fixedDelayDuration?: number;
  validChannel?: string;
  volumeRate?: number;
  static names(): { [key: string]: string } {
    return {
      fixedDelayDuration: 'FixedDelayDuration',
      validChannel: 'ValidChannel',
      volumeRate: 'VolumeRate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fixedDelayDuration: 'number',
      validChannel: 'string',
      volumeRate: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCasterLayoutRequestVideoLayer extends $tea.Model {
  fillMode?: string;
  fixedDelayDuration?: number;
  heightNormalized?: number;
  positionNormalized?: number[];
  positionRefer?: string;
  widthNormalized?: number;
  static names(): { [key: string]: string } {
    return {
      fillMode: 'FillMode',
      fixedDelayDuration: 'FixedDelayDuration',
      heightNormalized: 'HeightNormalized',
      positionNormalized: 'PositionNormalized',
      positionRefer: 'PositionRefer',
      widthNormalized: 'WidthNormalized',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fillMode: 'string',
      fixedDelayDuration: 'number',
      heightNormalized: 'number',
      positionNormalized: { 'type': 'array', 'itemType': 'number' },
      positionRefer: 'string',
      widthNormalized: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCasterProgramRequestEpisode extends $tea.Model {
  componentId?: string[];
  endTime?: string;
  episodeId?: string;
  episodeName?: string;
  episodeType?: string;
  resourceId?: string;
  startTime?: string;
  switchType?: string;
  static names(): { [key: string]: string } {
    return {
      componentId: 'ComponentId',
      endTime: 'EndTime',
      episodeId: 'EpisodeId',
      episodeName: 'EpisodeName',
      episodeType: 'EpisodeType',
      resourceId: 'ResourceId',
      startTime: 'StartTime',
      switchType: 'SwitchType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      componentId: { 'type': 'array', 'itemType': 'string' },
      endTime: 'string',
      episodeId: 'string',
      episodeName: 'string',
      episodeType: 'string',
      resourceId: 'string',
      startTime: 'string',
      switchType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMessageAppResponseBodyResultAppList extends $tea.Model {
  appConfig?: { [key: string]: string };
  appId?: string;
  appName?: string;
  createTime?: number;
  extension?: { [key: string]: string };
  status?: number;
  static names(): { [key: string]: string } {
    return {
      appConfig: 'AppConfig',
      appId: 'AppId',
      appName: 'AppName',
      createTime: 'CreateTime',
      extension: 'Extension',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      appId: 'string',
      appName: 'string',
      createTime: 'number',
      extension: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMessageAppResponseBodyResult extends $tea.Model {
  appList?: QueryMessageAppResponseBodyResultAppList[];
  hasMore?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      appList: 'AppList',
      hasMore: 'HasMore',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appList: { 'type': 'array', 'itemType': QueryMessageAppResponseBodyResultAppList },
      hasMore: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendLikeResponseBodyResult extends $tea.Model {
  likeCount?: number;
  static names(): { [key: string]: string } {
    return {
      likeCount: 'LikeCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      likeCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendMessageToGroupResponseBodyResult extends $tea.Model {
  messageId?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendMessageToGroupUsersResponseBodyResult extends $tea.Model {
  messageId?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCasterSyncGroupRequestSyncGroup extends $tea.Model {
  hostResourceId?: string;
  mode?: number;
  resourceIds?: string[];
  syncDelayThreshold?: number;
  syncOffsets?: number[];
  static names(): { [key: string]: string } {
    return {
      hostResourceId: 'HostResourceId',
      mode: 'Mode',
      resourceIds: 'ResourceIds',
      syncDelayThreshold: 'SyncDelayThreshold',
      syncOffsets: 'SyncOffsets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hostResourceId: 'string',
      mode: 'number',
      resourceIds: { 'type': 'array', 'itemType': 'string' },
      syncDelayThreshold: 'number',
      syncOffsets: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo extends $tea.Model {
  outputStreamUrl?: string;
  transcodeConfig?: string;
  videoFormat?: string;
  static names(): { [key: string]: string } {
    return {
      outputStreamUrl: 'OutputStreamUrl',
      transcodeConfig: 'TranscodeConfig',
      videoFormat: 'VideoFormat',
    };
  }

  static types(): { [key: string]: any } {
    return {
      outputStreamUrl: 'string',
      transcodeConfig: 'string',
      videoFormat: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfos extends $tea.Model {
  streamInfo?: StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo[];
  static names(): { [key: string]: string } {
    return {
      streamInfo: 'StreamInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      streamInfo: { 'type': 'array', 'itemType': StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCasterResponseBodyPgmSceneInfosSceneInfo extends $tea.Model {
  sceneId?: string;
  streamInfos?: StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfos;
  streamUrl?: string;
  static names(): { [key: string]: string } {
    return {
      sceneId: 'SceneId',
      streamInfos: 'StreamInfos',
      streamUrl: 'StreamUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sceneId: 'string',
      streamInfos: StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfos,
      streamUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCasterResponseBodyPgmSceneInfos extends $tea.Model {
  sceneInfo?: StartCasterResponseBodyPgmSceneInfosSceneInfo[];
  static names(): { [key: string]: string } {
    return {
      sceneInfo: 'SceneInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sceneInfo: { 'type': 'array', 'itemType': StartCasterResponseBodyPgmSceneInfosSceneInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCasterResponseBodyPvwSceneInfosSceneInfo extends $tea.Model {
  sceneId?: string;
  streamUrl?: string;
  static names(): { [key: string]: string } {
    return {
      sceneId: 'SceneId',
      streamUrl: 'StreamUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sceneId: 'string',
      streamUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCasterResponseBodyPvwSceneInfos extends $tea.Model {
  sceneInfo?: StartCasterResponseBodyPvwSceneInfosSceneInfo[];
  static names(): { [key: string]: string } {
    return {
      sceneInfo: 'SceneInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sceneInfo: { 'type': 'array', 'itemType': StartCasterResponseBodyPvwSceneInfosSceneInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartPlaylistResponseBodyStreamInfoStreamsStream extends $tea.Model {
  pullFlvUrl?: string;
  pullM3U8Url?: string;
  pullRtmpUrl?: string;
  quality?: string;
  static names(): { [key: string]: string } {
    return {
      pullFlvUrl: 'PullFlvUrl',
      pullM3U8Url: 'PullM3U8Url',
      pullRtmpUrl: 'PullRtmpUrl',
      quality: 'Quality',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pullFlvUrl: 'string',
      pullM3U8Url: 'string',
      pullRtmpUrl: 'string',
      quality: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartPlaylistResponseBodyStreamInfoStreams extends $tea.Model {
  stream?: StartPlaylistResponseBodyStreamInfoStreamsStream[];
  static names(): { [key: string]: string } {
    return {
      stream: 'Stream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      stream: { 'type': 'array', 'itemType': StartPlaylistResponseBodyStreamInfoStreamsStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartPlaylistResponseBodyStreamInfo extends $tea.Model {
  appName?: string;
  domainName?: string;
  streamName?: string;
  streams?: StartPlaylistResponseBodyStreamInfoStreams;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      domainName: 'DomainName',
      streamName: 'StreamName',
      streams: 'Streams',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      domainName: 'string',
      streamName: 'string',
      streams: StartPlaylistResponseBodyStreamInfoStreams,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagLiveResourcesRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCasterSceneAudioRequestAudioLayer extends $tea.Model {
  fixedDelayDuration?: number;
  validChannel?: string;
  volumeRate?: number;
  static names(): { [key: string]: string } {
    return {
      fixedDelayDuration: 'FixedDelayDuration',
      validChannel: 'ValidChannel',
      volumeRate: 'VolumeRate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fixedDelayDuration: 'number',
      validChannel: 'string',
      volumeRate: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMessageAppResponseBodyResult extends $tea.Model {
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMessageGroupResponseBodyResult extends $tea.Model {
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "regional";
    this._endpointMap = {
      'cn-qingdao': "live.aliyuncs.com",
      'cn-beijing': "live.aliyuncs.com",
      'cn-hangzhou': "live.aliyuncs.com",
      'cn-shanghai': "live.aliyuncs.com",
      'cn-shenzhen': "live.aliyuncs.com",
      'ap-southeast-1': "live.aliyuncs.com",
      'ap-southeast-5': "live.aliyuncs.com",
      'ap-northeast-1': "live.aliyuncs.com",
      'eu-central-1': "live.aliyuncs.com",
      'ap-south-1': "live.aliyuncs.com",
      'ap-northeast-2-pop': "live.aliyuncs.com",
      'ap-southeast-2': "live.aliyuncs.com",
      'ap-southeast-3': "live.aliyuncs.com",
      'cn-beijing-finance-1': "live.aliyuncs.com",
      'cn-beijing-finance-pop': "live.aliyuncs.com",
      'cn-beijing-gov-1': "live.aliyuncs.com",
      'cn-beijing-nu16-b01': "live.aliyuncs.com",
      'cn-chengdu': "live.aliyuncs.com",
      'cn-edge-1': "live.aliyuncs.com",
      'cn-fujian': "live.aliyuncs.com",
      'cn-haidian-cm12-c01': "live.aliyuncs.com",
      'cn-hangzhou-bj-b01': "live.aliyuncs.com",
      'cn-hangzhou-finance': "live.aliyuncs.com",
      'cn-hangzhou-internal-prod-1': "live.aliyuncs.com",
      'cn-hangzhou-internal-test-1': "live.aliyuncs.com",
      'cn-hangzhou-internal-test-2': "live.aliyuncs.com",
      'cn-hangzhou-internal-test-3': "live.aliyuncs.com",
      'cn-hangzhou-test-306': "live.aliyuncs.com",
      'cn-hongkong': "live.aliyuncs.com",
      'cn-hongkong-finance-pop': "live.aliyuncs.com",
      'cn-huhehaote': "live.aliyuncs.com",
      'cn-huhehaote-nebula-1': "live.aliyuncs.com",
      'cn-north-2-gov-1': "live.aliyuncs.com",
      'cn-qingdao-nebula': "live.aliyuncs.com",
      'cn-shanghai-et15-b01': "live.aliyuncs.com",
      'cn-shanghai-et2-b01': "live.aliyuncs.com",
      'cn-shanghai-finance-1': "live.aliyuncs.com",
      'cn-shanghai-inner': "live.aliyuncs.com",
      'cn-shanghai-internal-test-1': "live.aliyuncs.com",
      'cn-shenzhen-finance-1': "live.aliyuncs.com",
      'cn-shenzhen-inner': "live.aliyuncs.com",
      'cn-shenzhen-st4-d01': "live.aliyuncs.com",
      'cn-shenzhen-su18-b01': "live.aliyuncs.com",
      'cn-wuhan': "live.aliyuncs.com",
      'cn-wulanchabu': "live.aliyuncs.com",
      'cn-yushanfang': "live.aliyuncs.com",
      'cn-zhangbei': "live.aliyuncs.com",
      'cn-zhangbei-na61-b01': "live.aliyuncs.com",
      'cn-zhangjiakou': "live.aliyuncs.com",
      'cn-zhangjiakou-na62-a01': "live.aliyuncs.com",
      'cn-zhengzhou-nebula-1': "live.aliyuncs.com",
      'eu-west-1': "live.aliyuncs.com",
      'eu-west-1-oxs': "live.aliyuncs.com",
      'me-east-1': "live.aliyuncs.com",
      'rus-west-1-pop': "live.aliyuncs.com",
      'us-east-1': "live.aliyuncs.com",
      'us-west-1': "live.aliyuncs.com",
    };
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("live", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  async addCasterComponentWithOptions(request: AddCasterComponentRequest, runtime: $Util.RuntimeOptions): Promise<AddCasterComponentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.captionLayerContent)) {
      query["CaptionLayerContent"] = request.captionLayerContent;
    }

    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.componentLayer)) {
      query["ComponentLayer"] = request.componentLayer;
    }

    if (!Util.isUnset(request.componentName)) {
      query["ComponentName"] = request.componentName;
    }

    if (!Util.isUnset(request.componentType)) {
      query["ComponentType"] = request.componentType;
    }

    if (!Util.isUnset(request.effect)) {
      query["Effect"] = request.effect;
    }

    if (!Util.isUnset(request.htmlLayerContent)) {
      query["HtmlLayerContent"] = request.htmlLayerContent;
    }

    if (!Util.isUnset(request.imageLayerContent)) {
      query["ImageLayerContent"] = request.imageLayerContent;
    }

    if (!Util.isUnset(request.layerOrder)) {
      query["LayerOrder"] = request.layerOrder;
    }

    if (!Util.isUnset(request.locationId)) {
      query["LocationId"] = request.locationId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.textLayerContent)) {
      query["TextLayerContent"] = request.textLayerContent;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddCasterComponent",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddCasterComponentResponse>(await this.callApi(params, req, runtime), new AddCasterComponentResponse({}));
  }

  async addCasterComponent(request: AddCasterComponentRequest): Promise<AddCasterComponentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addCasterComponentWithOptions(request, runtime);
  }

  async addCasterEpisodeWithOptions(request: AddCasterEpisodeRequest, runtime: $Util.RuntimeOptions): Promise<AddCasterEpisodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.componentId)) {
      query["ComponentId"] = request.componentId;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.episodeName)) {
      query["EpisodeName"] = request.episodeName;
    }

    if (!Util.isUnset(request.episodeType)) {
      query["EpisodeType"] = request.episodeType;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.switchType)) {
      query["SwitchType"] = request.switchType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddCasterEpisode",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddCasterEpisodeResponse>(await this.callApi(params, req, runtime), new AddCasterEpisodeResponse({}));
  }

  async addCasterEpisode(request: AddCasterEpisodeRequest): Promise<AddCasterEpisodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addCasterEpisodeWithOptions(request, runtime);
  }

  async addCasterEpisodeGroupWithOptions(request: AddCasterEpisodeGroupRequest, runtime: $Util.RuntimeOptions): Promise<AddCasterEpisodeGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.callbackUrl)) {
      query["CallbackUrl"] = request.callbackUrl;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.item)) {
      query["Item"] = request.item;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.repeatNum)) {
      query["RepeatNum"] = request.repeatNum;
    }

    if (!Util.isUnset(request.sideOutputUrl)) {
      query["SideOutputUrl"] = request.sideOutputUrl;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddCasterEpisodeGroup",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddCasterEpisodeGroupResponse>(await this.callApi(params, req, runtime), new AddCasterEpisodeGroupResponse({}));
  }

  async addCasterEpisodeGroup(request: AddCasterEpisodeGroupRequest): Promise<AddCasterEpisodeGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addCasterEpisodeGroupWithOptions(request, runtime);
  }

  async addCasterEpisodeGroupContentWithOptions(request: AddCasterEpisodeGroupContentRequest, runtime: $Util.RuntimeOptions): Promise<AddCasterEpisodeGroupContentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.content)) {
      query["Content"] = request.content;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddCasterEpisodeGroupContent",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddCasterEpisodeGroupContentResponse>(await this.callApi(params, req, runtime), new AddCasterEpisodeGroupContentResponse({}));
  }

  async addCasterEpisodeGroupContent(request: AddCasterEpisodeGroupContentRequest): Promise<AddCasterEpisodeGroupContentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addCasterEpisodeGroupContentWithOptions(request, runtime);
  }

  async addCasterLayoutWithOptions(request: AddCasterLayoutRequest, runtime: $Util.RuntimeOptions): Promise<AddCasterLayoutResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.audioLayer)) {
      query["AudioLayer"] = request.audioLayer;
    }

    if (!Util.isUnset(request.blendList)) {
      query["BlendList"] = request.blendList;
    }

    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.mixList)) {
      query["MixList"] = request.mixList;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.videoLayer)) {
      query["VideoLayer"] = request.videoLayer;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddCasterLayout",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddCasterLayoutResponse>(await this.callApi(params, req, runtime), new AddCasterLayoutResponse({}));
  }

  async addCasterLayout(request: AddCasterLayoutRequest): Promise<AddCasterLayoutResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addCasterLayoutWithOptions(request, runtime);
  }

  async addCasterProgramWithOptions(request: AddCasterProgramRequest, runtime: $Util.RuntimeOptions): Promise<AddCasterProgramResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.episode)) {
      query["Episode"] = request.episode;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddCasterProgram",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddCasterProgramResponse>(await this.callApi(params, req, runtime), new AddCasterProgramResponse({}));
  }

  async addCasterProgram(request: AddCasterProgramRequest): Promise<AddCasterProgramResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addCasterProgramWithOptions(request, runtime);
  }

  async addCasterVideoResourceWithOptions(request: AddCasterVideoResourceRequest, runtime: $Util.RuntimeOptions): Promise<AddCasterVideoResourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.beginOffset)) {
      query["BeginOffset"] = request.beginOffset;
    }

    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.endOffset)) {
      query["EndOffset"] = request.endOffset;
    }

    if (!Util.isUnset(request.fixedDelayDuration)) {
      query["FixedDelayDuration"] = request.fixedDelayDuration;
    }

    if (!Util.isUnset(request.liveStreamUrl)) {
      query["LiveStreamUrl"] = request.liveStreamUrl;
    }

    if (!Util.isUnset(request.locationId)) {
      query["LocationId"] = request.locationId;
    }

    if (!Util.isUnset(request.materialId)) {
      query["MaterialId"] = request.materialId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.ptsCallbackInterval)) {
      query["PtsCallbackInterval"] = request.ptsCallbackInterval;
    }

    if (!Util.isUnset(request.repeatNum)) {
      query["RepeatNum"] = request.repeatNum;
    }

    if (!Util.isUnset(request.resourceName)) {
      query["ResourceName"] = request.resourceName;
    }

    if (!Util.isUnset(request.streamId)) {
      query["StreamId"] = request.streamId;
    }

    if (!Util.isUnset(request.vodUrl)) {
      query["VodUrl"] = request.vodUrl;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddCasterVideoResource",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddCasterVideoResourceResponse>(await this.callApi(params, req, runtime), new AddCasterVideoResourceResponse({}));
  }

  async addCasterVideoResource(request: AddCasterVideoResourceRequest): Promise<AddCasterVideoResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addCasterVideoResourceWithOptions(request, runtime);
  }

  async addCustomLiveStreamTranscodeWithOptions(request: AddCustomLiveStreamTranscodeRequest, runtime: $Util.RuntimeOptions): Promise<AddCustomLiveStreamTranscodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.app)) {
      query["App"] = request.app;
    }

    if (!Util.isUnset(request.audioBitrate)) {
      query["AudioBitrate"] = request.audioBitrate;
    }

    if (!Util.isUnset(request.audioChannelNum)) {
      query["AudioChannelNum"] = request.audioChannelNum;
    }

    if (!Util.isUnset(request.audioCodec)) {
      query["AudioCodec"] = request.audioCodec;
    }

    if (!Util.isUnset(request.audioProfile)) {
      query["AudioProfile"] = request.audioProfile;
    }

    if (!Util.isUnset(request.audioRate)) {
      query["AudioRate"] = request.audioRate;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.encryptParameters)) {
      query["EncryptParameters"] = request.encryptParameters;
    }

    if (!Util.isUnset(request.FPS)) {
      query["FPS"] = request.FPS;
    }

    if (!Util.isUnset(request.gop)) {
      query["Gop"] = request.gop;
    }

    if (!Util.isUnset(request.height)) {
      query["Height"] = request.height;
    }

    if (!Util.isUnset(request.kmsKeyExpireInterval)) {
      query["KmsKeyExpireInterval"] = request.kmsKeyExpireInterval;
    }

    if (!Util.isUnset(request.kmsKeyID)) {
      query["KmsKeyID"] = request.kmsKeyID;
    }

    if (!Util.isUnset(request.kmsUID)) {
      query["KmsUID"] = request.kmsUID;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.profile)) {
      query["Profile"] = request.profile;
    }

    if (!Util.isUnset(request.template)) {
      query["Template"] = request.template;
    }

    if (!Util.isUnset(request.templateType)) {
      query["TemplateType"] = request.templateType;
    }

    if (!Util.isUnset(request.videoBitrate)) {
      query["VideoBitrate"] = request.videoBitrate;
    }

    if (!Util.isUnset(request.width)) {
      query["Width"] = request.width;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddCustomLiveStreamTranscode",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddCustomLiveStreamTranscodeResponse>(await this.callApi(params, req, runtime), new AddCustomLiveStreamTranscodeResponse({}));
  }

  async addCustomLiveStreamTranscode(request: AddCustomLiveStreamTranscodeRequest): Promise<AddCustomLiveStreamTranscodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addCustomLiveStreamTranscodeWithOptions(request, runtime);
  }

  async addLiveAppRecordConfigWithOptions(request: AddLiveAppRecordConfigRequest, runtime: $Util.RuntimeOptions): Promise<AddLiveAppRecordConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.onDemand)) {
      query["OnDemand"] = request.onDemand;
    }

    if (!Util.isUnset(request.ossBucket)) {
      query["OssBucket"] = request.ossBucket;
    }

    if (!Util.isUnset(request.ossEndpoint)) {
      query["OssEndpoint"] = request.ossEndpoint;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.recordFormat)) {
      query["RecordFormat"] = request.recordFormat;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    if (!Util.isUnset(request.transcodeRecordFormat)) {
      query["TranscodeRecordFormat"] = request.transcodeRecordFormat;
    }

    if (!Util.isUnset(request.transcodeTemplates)) {
      query["TranscodeTemplates"] = request.transcodeTemplates;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddLiveAppRecordConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddLiveAppRecordConfigResponse>(await this.callApi(params, req, runtime), new AddLiveAppRecordConfigResponse({}));
  }

  async addLiveAppRecordConfig(request: AddLiveAppRecordConfigRequest): Promise<AddLiveAppRecordConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addLiveAppRecordConfigWithOptions(request, runtime);
  }

  async addLiveAppSnapshotConfigWithOptions(request: AddLiveAppSnapshotConfigRequest, runtime: $Util.RuntimeOptions): Promise<AddLiveAppSnapshotConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.callback)) {
      query["Callback"] = request.callback;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ossBucket)) {
      query["OssBucket"] = request.ossBucket;
    }

    if (!Util.isUnset(request.ossEndpoint)) {
      query["OssEndpoint"] = request.ossEndpoint;
    }

    if (!Util.isUnset(request.overwriteOssObject)) {
      query["OverwriteOssObject"] = request.overwriteOssObject;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.sequenceOssObject)) {
      query["SequenceOssObject"] = request.sequenceOssObject;
    }

    if (!Util.isUnset(request.timeInterval)) {
      query["TimeInterval"] = request.timeInterval;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddLiveAppSnapshotConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddLiveAppSnapshotConfigResponse>(await this.callApi(params, req, runtime), new AddLiveAppSnapshotConfigResponse({}));
  }

  async addLiveAppSnapshotConfig(request: AddLiveAppSnapshotConfigRequest): Promise<AddLiveAppSnapshotConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addLiveAppSnapshotConfigWithOptions(request, runtime);
  }

  async addLiveAudioAuditConfigWithOptions(request: AddLiveAudioAuditConfigRequest, runtime: $Util.RuntimeOptions): Promise<AddLiveAudioAuditConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.bizType)) {
      query["BizType"] = request.bizType;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ossBucket)) {
      query["OssBucket"] = request.ossBucket;
    }

    if (!Util.isUnset(request.ossEndpoint)) {
      query["OssEndpoint"] = request.ossEndpoint;
    }

    if (!Util.isUnset(request.ossObject)) {
      query["OssObject"] = request.ossObject;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddLiveAudioAuditConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddLiveAudioAuditConfigResponse>(await this.callApi(params, req, runtime), new AddLiveAudioAuditConfigResponse({}));
  }

  async addLiveAudioAuditConfig(request: AddLiveAudioAuditConfigRequest): Promise<AddLiveAudioAuditConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addLiveAudioAuditConfigWithOptions(request, runtime);
  }

  async addLiveAudioAuditNotifyConfigWithOptions(request: AddLiveAudioAuditNotifyConfigRequest, runtime: $Util.RuntimeOptions): Promise<AddLiveAudioAuditNotifyConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.callback)) {
      query["Callback"] = request.callback;
    }

    if (!Util.isUnset(request.callbackTemplate)) {
      query["CallbackTemplate"] = request.callbackTemplate;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddLiveAudioAuditNotifyConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddLiveAudioAuditNotifyConfigResponse>(await this.callApi(params, req, runtime), new AddLiveAudioAuditNotifyConfigResponse({}));
  }

  async addLiveAudioAuditNotifyConfig(request: AddLiveAudioAuditNotifyConfigRequest): Promise<AddLiveAudioAuditNotifyConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addLiveAudioAuditNotifyConfigWithOptions(request, runtime);
  }

  async addLiveDetectNotifyConfigWithOptions(request: AddLiveDetectNotifyConfigRequest, runtime: $Util.RuntimeOptions): Promise<AddLiveDetectNotifyConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.notifyUrl)) {
      query["NotifyUrl"] = request.notifyUrl;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddLiveDetectNotifyConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddLiveDetectNotifyConfigResponse>(await this.callApi(params, req, runtime), new AddLiveDetectNotifyConfigResponse({}));
  }

  async addLiveDetectNotifyConfig(request: AddLiveDetectNotifyConfigRequest): Promise<AddLiveDetectNotifyConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addLiveDetectNotifyConfigWithOptions(request, runtime);
  }

  async addLiveDomainWithOptions(request: AddLiveDomainRequest, runtime: $Util.RuntimeOptions): Promise<AddLiveDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkUrl)) {
      query["CheckUrl"] = request.checkUrl;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.liveDomainType)) {
      query["LiveDomainType"] = request.liveDomainType;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.scope)) {
      query["Scope"] = request.scope;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.topLevelDomain)) {
      query["TopLevelDomain"] = request.topLevelDomain;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddLiveDomain",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddLiveDomainResponse>(await this.callApi(params, req, runtime), new AddLiveDomainResponse({}));
  }

  async addLiveDomain(request: AddLiveDomainRequest): Promise<AddLiveDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addLiveDomainWithOptions(request, runtime);
  }

  async addLiveDomainMappingWithOptions(request: AddLiveDomainMappingRequest, runtime: $Util.RuntimeOptions): Promise<AddLiveDomainMappingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pullDomain)) {
      query["PullDomain"] = request.pullDomain;
    }

    if (!Util.isUnset(request.pushDomain)) {
      query["PushDomain"] = request.pushDomain;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddLiveDomainMapping",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddLiveDomainMappingResponse>(await this.callApi(params, req, runtime), new AddLiveDomainMappingResponse({}));
  }

  async addLiveDomainMapping(request: AddLiveDomainMappingRequest): Promise<AddLiveDomainMappingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addLiveDomainMappingWithOptions(request, runtime);
  }

  async addLiveDomainPlayMappingWithOptions(request: AddLiveDomainPlayMappingRequest, runtime: $Util.RuntimeOptions): Promise<AddLiveDomainPlayMappingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.playDomain)) {
      query["PlayDomain"] = request.playDomain;
    }

    if (!Util.isUnset(request.pullDomain)) {
      query["PullDomain"] = request.pullDomain;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddLiveDomainPlayMapping",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddLiveDomainPlayMappingResponse>(await this.callApi(params, req, runtime), new AddLiveDomainPlayMappingResponse({}));
  }

  async addLiveDomainPlayMapping(request: AddLiveDomainPlayMappingRequest): Promise<AddLiveDomainPlayMappingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addLiveDomainPlayMappingWithOptions(request, runtime);
  }

  async addLivePullStreamInfoConfigWithOptions(request: AddLivePullStreamInfoConfigRequest, runtime: $Util.RuntimeOptions): Promise<AddLivePullStreamInfoConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.sourceUrl)) {
      query["SourceUrl"] = request.sourceUrl;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddLivePullStreamInfoConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddLivePullStreamInfoConfigResponse>(await this.callApi(params, req, runtime), new AddLivePullStreamInfoConfigResponse({}));
  }

  async addLivePullStreamInfoConfig(request: AddLivePullStreamInfoConfigRequest): Promise<AddLivePullStreamInfoConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addLivePullStreamInfoConfigWithOptions(request, runtime);
  }

  async addLiveRecordNotifyConfigWithOptions(request: AddLiveRecordNotifyConfigRequest, runtime: $Util.RuntimeOptions): Promise<AddLiveRecordNotifyConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.needStatusNotify)) {
      query["NeedStatusNotify"] = request.needStatusNotify;
    }

    if (!Util.isUnset(request.notifyUrl)) {
      query["NotifyUrl"] = request.notifyUrl;
    }

    if (!Util.isUnset(request.onDemandUrl)) {
      query["OnDemandUrl"] = request.onDemandUrl;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddLiveRecordNotifyConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddLiveRecordNotifyConfigResponse>(await this.callApi(params, req, runtime), new AddLiveRecordNotifyConfigResponse({}));
  }

  async addLiveRecordNotifyConfig(request: AddLiveRecordNotifyConfigRequest): Promise<AddLiveRecordNotifyConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addLiveRecordNotifyConfigWithOptions(request, runtime);
  }

  async addLiveRecordVodConfigWithOptions(request: AddLiveRecordVodConfigRequest, runtime: $Util.RuntimeOptions): Promise<AddLiveRecordVodConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.autoCompose)) {
      query["AutoCompose"] = request.autoCompose;
    }

    if (!Util.isUnset(request.composeVodTranscodeGroupId)) {
      query["ComposeVodTranscodeGroupId"] = request.composeVodTranscodeGroupId;
    }

    if (!Util.isUnset(request.cycleDuration)) {
      query["CycleDuration"] = request.cycleDuration;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.storageLocation)) {
      query["StorageLocation"] = request.storageLocation;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    if (!Util.isUnset(request.vodTranscodeGroupId)) {
      query["VodTranscodeGroupId"] = request.vodTranscodeGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddLiveRecordVodConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddLiveRecordVodConfigResponse>(await this.callApi(params, req, runtime), new AddLiveRecordVodConfigResponse({}));
  }

  async addLiveRecordVodConfig(request: AddLiveRecordVodConfigRequest): Promise<AddLiveRecordVodConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addLiveRecordVodConfigWithOptions(request, runtime);
  }

  async addLiveSnapshotDetectPornConfigWithOptions(request: AddLiveSnapshotDetectPornConfigRequest, runtime: $Util.RuntimeOptions): Promise<AddLiveSnapshotDetectPornConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ossBucket)) {
      query["OssBucket"] = request.ossBucket;
    }

    if (!Util.isUnset(request.ossEndpoint)) {
      query["OssEndpoint"] = request.ossEndpoint;
    }

    if (!Util.isUnset(request.ossObject)) {
      query["OssObject"] = request.ossObject;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.scene)) {
      query["Scene"] = request.scene;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddLiveSnapshotDetectPornConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddLiveSnapshotDetectPornConfigResponse>(await this.callApi(params, req, runtime), new AddLiveSnapshotDetectPornConfigResponse({}));
  }

  async addLiveSnapshotDetectPornConfig(request: AddLiveSnapshotDetectPornConfigRequest): Promise<AddLiveSnapshotDetectPornConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addLiveSnapshotDetectPornConfigWithOptions(request, runtime);
  }

  async addLiveSnapshotNotifyConfigWithOptions(request: AddLiveSnapshotNotifyConfigRequest, runtime: $Util.RuntimeOptions): Promise<AddLiveSnapshotNotifyConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.notifyAuthKey)) {
      query["NotifyAuthKey"] = request.notifyAuthKey;
    }

    if (!Util.isUnset(request.notifyReqAuth)) {
      query["NotifyReqAuth"] = request.notifyReqAuth;
    }

    if (!Util.isUnset(request.notifyUrl)) {
      query["NotifyUrl"] = request.notifyUrl;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddLiveSnapshotNotifyConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddLiveSnapshotNotifyConfigResponse>(await this.callApi(params, req, runtime), new AddLiveSnapshotNotifyConfigResponse({}));
  }

  async addLiveSnapshotNotifyConfig(request: AddLiveSnapshotNotifyConfigRequest): Promise<AddLiveSnapshotNotifyConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addLiveSnapshotNotifyConfigWithOptions(request, runtime);
  }

  async addLiveStreamTranscodeWithOptions(request: AddLiveStreamTranscodeRequest, runtime: $Util.RuntimeOptions): Promise<AddLiveStreamTranscodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.app)) {
      query["App"] = request.app;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.encryptParameters)) {
      query["EncryptParameters"] = request.encryptParameters;
    }

    if (!Util.isUnset(request.lazy)) {
      query["Lazy"] = request.lazy;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.template)) {
      query["Template"] = request.template;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddLiveStreamTranscode",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddLiveStreamTranscodeResponse>(await this.callApi(params, req, runtime), new AddLiveStreamTranscodeResponse({}));
  }

  async addLiveStreamTranscode(request: AddLiveStreamTranscodeRequest): Promise<AddLiveStreamTranscodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addLiveStreamTranscodeWithOptions(request, runtime);
  }

  async addLiveStreamWatermarkWithOptions(request: AddLiveStreamWatermarkRequest, runtime: $Util.RuntimeOptions): Promise<AddLiveStreamWatermarkResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.height)) {
      query["Height"] = request.height;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.offsetCorner)) {
      query["OffsetCorner"] = request.offsetCorner;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pictureUrl)) {
      query["PictureUrl"] = request.pictureUrl;
    }

    if (!Util.isUnset(request.refHeight)) {
      query["RefHeight"] = request.refHeight;
    }

    if (!Util.isUnset(request.refWidth)) {
      query["RefWidth"] = request.refWidth;
    }

    if (!Util.isUnset(request.transparency)) {
      query["Transparency"] = request.transparency;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.XOffset)) {
      query["XOffset"] = request.XOffset;
    }

    if (!Util.isUnset(request.YOffset)) {
      query["YOffset"] = request.YOffset;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddLiveStreamWatermark",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddLiveStreamWatermarkResponse>(await this.callApi(params, req, runtime), new AddLiveStreamWatermarkResponse({}));
  }

  async addLiveStreamWatermark(request: AddLiveStreamWatermarkRequest): Promise<AddLiveStreamWatermarkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addLiveStreamWatermarkWithOptions(request, runtime);
  }

  async addLiveStreamWatermarkRuleWithOptions(request: AddLiveStreamWatermarkRuleRequest, runtime: $Util.RuntimeOptions): Promise<AddLiveStreamWatermarkRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.app)) {
      query["App"] = request.app;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.stream)) {
      query["Stream"] = request.stream;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddLiveStreamWatermarkRule",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddLiveStreamWatermarkRuleResponse>(await this.callApi(params, req, runtime), new AddLiveStreamWatermarkRuleResponse({}));
  }

  async addLiveStreamWatermarkRule(request: AddLiveStreamWatermarkRuleRequest): Promise<AddLiveStreamWatermarkRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addLiveStreamWatermarkRuleWithOptions(request, runtime);
  }

  async addMultiRateConfigWithOptions(request: AddMultiRateConfigRequest, runtime: $Util.RuntimeOptions): Promise<AddMultiRateConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.app)) {
      query["App"] = request.app;
    }

    if (!Util.isUnset(request.avFormat)) {
      query["AvFormat"] = request.avFormat;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.isLazy)) {
      query["IsLazy"] = request.isLazy;
    }

    if (!Util.isUnset(request.isTimeAlign)) {
      query["IsTimeAlign"] = request.isTimeAlign;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.templates)) {
      query["Templates"] = request.templates;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddMultiRateConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddMultiRateConfigResponse>(await this.callApi(params, req, runtime), new AddMultiRateConfigResponse({}));
  }

  async addMultiRateConfig(request: AddMultiRateConfigRequest): Promise<AddMultiRateConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addMultiRateConfigWithOptions(request, runtime);
  }

  async addPlaylistItemsWithOptions(request: AddPlaylistItemsRequest, runtime: $Util.RuntimeOptions): Promise<AddPlaylistItemsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.programConfig)) {
      query["ProgramConfig"] = request.programConfig;
    }

    if (!Util.isUnset(request.programId)) {
      query["ProgramId"] = request.programId;
    }

    if (!Util.isUnset(request.programItems)) {
      query["ProgramItems"] = request.programItems;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddPlaylistItems",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddPlaylistItemsResponse>(await this.callApi(params, req, runtime), new AddPlaylistItemsResponse({}));
  }

  async addPlaylistItems(request: AddPlaylistItemsRequest): Promise<AddPlaylistItemsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addPlaylistItemsWithOptions(request, runtime);
  }

  async addRtsLiveStreamTranscodeWithOptions(request: AddRtsLiveStreamTranscodeRequest, runtime: $Util.RuntimeOptions): Promise<AddRtsLiveStreamTranscodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.app)) {
      query["App"] = request.app;
    }

    if (!Util.isUnset(request.audioBitrate)) {
      query["AudioBitrate"] = request.audioBitrate;
    }

    if (!Util.isUnset(request.audioChannelNum)) {
      query["AudioChannelNum"] = request.audioChannelNum;
    }

    if (!Util.isUnset(request.audioCodec)) {
      query["AudioCodec"] = request.audioCodec;
    }

    if (!Util.isUnset(request.audioProfile)) {
      query["AudioProfile"] = request.audioProfile;
    }

    if (!Util.isUnset(request.audioRate)) {
      query["AudioRate"] = request.audioRate;
    }

    if (!Util.isUnset(request.deleteBframes)) {
      query["DeleteBframes"] = request.deleteBframes;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.FPS)) {
      query["FPS"] = request.FPS;
    }

    if (!Util.isUnset(request.gop)) {
      query["Gop"] = request.gop;
    }

    if (!Util.isUnset(request.height)) {
      query["Height"] = request.height;
    }

    if (!Util.isUnset(request.lazy)) {
      query["Lazy"] = request.lazy;
    }

    if (!Util.isUnset(request.opus)) {
      query["Opus"] = request.opus;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.profile)) {
      query["Profile"] = request.profile;
    }

    if (!Util.isUnset(request.template)) {
      query["Template"] = request.template;
    }

    if (!Util.isUnset(request.templateType)) {
      query["TemplateType"] = request.templateType;
    }

    if (!Util.isUnset(request.videoBitrate)) {
      query["VideoBitrate"] = request.videoBitrate;
    }

    if (!Util.isUnset(request.width)) {
      query["Width"] = request.width;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddRtsLiveStreamTranscode",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddRtsLiveStreamTranscodeResponse>(await this.callApi(params, req, runtime), new AddRtsLiveStreamTranscodeResponse({}));
  }

  async addRtsLiveStreamTranscode(request: AddRtsLiveStreamTranscodeRequest): Promise<AddRtsLiveStreamTranscodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addRtsLiveStreamTranscodeWithOptions(request, runtime);
  }

  async addShowIntoShowListWithOptions(request: AddShowIntoShowListRequest, runtime: $Util.RuntimeOptions): Promise<AddShowIntoShowListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.duration)) {
      query["Duration"] = request.duration;
    }

    if (!Util.isUnset(request.liveInputType)) {
      query["LiveInputType"] = request.liveInputType;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.repeatTimes)) {
      query["RepeatTimes"] = request.repeatTimes;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.resourceUrl)) {
      query["ResourceUrl"] = request.resourceUrl;
    }

    if (!Util.isUnset(request.showName)) {
      query["ShowName"] = request.showName;
    }

    if (!Util.isUnset(request.spot)) {
      query["Spot"] = request.spot;
    }

    if (!Util.isUnset(request.isBatchMode)) {
      query["isBatchMode"] = request.isBatchMode;
    }

    if (!Util.isUnset(request.showList)) {
      query["showList"] = request.showList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddShowIntoShowList",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddShowIntoShowListResponse>(await this.callApi(params, req, runtime), new AddShowIntoShowListResponse({}));
  }

  async addShowIntoShowList(request: AddShowIntoShowListRequest): Promise<AddShowIntoShowListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addShowIntoShowListWithOptions(request, runtime);
  }

  async addStudioLayoutWithOptions(request: AddStudioLayoutRequest, runtime: $Util.RuntimeOptions): Promise<AddStudioLayoutResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bgImageConfig)) {
      query["BgImageConfig"] = request.bgImageConfig;
    }

    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.commonConfig)) {
      query["CommonConfig"] = request.commonConfig;
    }

    if (!Util.isUnset(request.layerOrderConfigList)) {
      query["LayerOrderConfigList"] = request.layerOrderConfigList;
    }

    if (!Util.isUnset(request.layoutName)) {
      query["LayoutName"] = request.layoutName;
    }

    if (!Util.isUnset(request.layoutType)) {
      query["LayoutType"] = request.layoutType;
    }

    if (!Util.isUnset(request.mediaInputConfigList)) {
      query["MediaInputConfigList"] = request.mediaInputConfigList;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.screenInputConfigList)) {
      query["ScreenInputConfigList"] = request.screenInputConfigList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddStudioLayout",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddStudioLayoutResponse>(await this.callApi(params, req, runtime), new AddStudioLayoutResponse({}));
  }

  async addStudioLayout(request: AddStudioLayoutRequest): Promise<AddStudioLayoutResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addStudioLayoutWithOptions(request, runtime);
  }

  async addTrancodeSEIWithOptions(request: AddTrancodeSEIRequest, runtime: $Util.RuntimeOptions): Promise<AddTrancodeSEIResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.delay)) {
      query["Delay"] = request.delay;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pattern)) {
      query["Pattern"] = request.pattern;
    }

    if (!Util.isUnset(request.repeat)) {
      query["Repeat"] = request.repeat;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    if (!Util.isUnset(request.text)) {
      query["Text"] = request.text;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddTrancodeSEI",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddTrancodeSEIResponse>(await this.callApi(params, req, runtime), new AddTrancodeSEIResponse({}));
  }

  async addTrancodeSEI(request: AddTrancodeSEIRequest): Promise<AddTrancodeSEIResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addTrancodeSEIWithOptions(request, runtime);
  }

  async allowPushStreamWithOptions(request: AllowPushStreamRequest, runtime: $Util.RuntimeOptions): Promise<AllowPushStreamResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.roomId)) {
      query["RoomId"] = request.roomId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AllowPushStream",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AllowPushStreamResponse>(await this.callApi(params, req, runtime), new AllowPushStreamResponse({}));
  }

  async allowPushStream(request: AllowPushStreamRequest): Promise<AllowPushStreamResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.allowPushStreamWithOptions(request, runtime);
  }

  async batchDeleteLiveDomainConfigsWithOptions(request: BatchDeleteLiveDomainConfigsRequest, runtime: $Util.RuntimeOptions): Promise<BatchDeleteLiveDomainConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainNames)) {
      query["DomainNames"] = request.domainNames;
    }

    if (!Util.isUnset(request.functionNames)) {
      query["FunctionNames"] = request.functionNames;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchDeleteLiveDomainConfigs",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchDeleteLiveDomainConfigsResponse>(await this.callApi(params, req, runtime), new BatchDeleteLiveDomainConfigsResponse({}));
  }

  async batchDeleteLiveDomainConfigs(request: BatchDeleteLiveDomainConfigsRequest): Promise<BatchDeleteLiveDomainConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchDeleteLiveDomainConfigsWithOptions(request, runtime);
  }

  async batchSetLiveDomainConfigsWithOptions(request: BatchSetLiveDomainConfigsRequest, runtime: $Util.RuntimeOptions): Promise<BatchSetLiveDomainConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainNames)) {
      query["DomainNames"] = request.domainNames;
    }

    if (!Util.isUnset(request.functions)) {
      query["Functions"] = request.functions;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchSetLiveDomainConfigs",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchSetLiveDomainConfigsResponse>(await this.callApi(params, req, runtime), new BatchSetLiveDomainConfigsResponse({}));
  }

  async batchSetLiveDomainConfigs(request: BatchSetLiveDomainConfigsRequest): Promise<BatchSetLiveDomainConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchSetLiveDomainConfigsWithOptions(request, runtime);
  }

  async cancelMuteAllGroupUserWithOptions(request: CancelMuteAllGroupUserRequest, runtime: $Util.RuntimeOptions): Promise<CancelMuteAllGroupUserResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.groupId)) {
      body["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.operatorUserId)) {
      body["OperatorUserId"] = request.operatorUserId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CancelMuteAllGroupUser",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CancelMuteAllGroupUserResponse>(await this.callApi(params, req, runtime), new CancelMuteAllGroupUserResponse({}));
  }

  async cancelMuteAllGroupUser(request: CancelMuteAllGroupUserRequest): Promise<CancelMuteAllGroupUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelMuteAllGroupUserWithOptions(request, runtime);
  }

  async closeLiveShiftWithOptions(request: CloseLiveShiftRequest, runtime: $Util.RuntimeOptions): Promise<CloseLiveShiftResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CloseLiveShift",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CloseLiveShiftResponse>(await this.callApi(params, req, runtime), new CloseLiveShiftResponse({}));
  }

  async closeLiveShift(request: CloseLiveShiftRequest): Promise<CloseLiveShiftResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.closeLiveShiftWithOptions(request, runtime);
  }

  async copyCasterWithOptions(request: CopyCasterRequest, runtime: $Util.RuntimeOptions): Promise<CopyCasterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterName)) {
      query["CasterName"] = request.casterName;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.srcCasterId)) {
      query["SrcCasterId"] = request.srcCasterId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CopyCaster",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CopyCasterResponse>(await this.callApi(params, req, runtime), new CopyCasterResponse({}));
  }

  async copyCaster(request: CopyCasterRequest): Promise<CopyCasterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.copyCasterWithOptions(request, runtime);
  }

  async copyCasterSceneConfigWithOptions(request: CopyCasterSceneConfigRequest, runtime: $Util.RuntimeOptions): Promise<CopyCasterSceneConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.fromSceneId)) {
      query["FromSceneId"] = request.fromSceneId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.toSceneId)) {
      query["ToSceneId"] = request.toSceneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CopyCasterSceneConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CopyCasterSceneConfigResponse>(await this.callApi(params, req, runtime), new CopyCasterSceneConfigResponse({}));
  }

  async copyCasterSceneConfig(request: CopyCasterSceneConfigRequest): Promise<CopyCasterSceneConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.copyCasterSceneConfigWithOptions(request, runtime);
  }

  async createCasterWithOptions(request: CreateCasterRequest, runtime: $Util.RuntimeOptions): Promise<CreateCasterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterName)) {
      query["CasterName"] = request.casterName;
    }

    if (!Util.isUnset(request.casterTemplate)) {
      query["CasterTemplate"] = request.casterTemplate;
    }

    if (!Util.isUnset(request.chargeType)) {
      query["ChargeType"] = request.chargeType;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.expireTime)) {
      query["ExpireTime"] = request.expireTime;
    }

    if (!Util.isUnset(request.normType)) {
      query["NormType"] = request.normType;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.purchaseTime)) {
      query["PurchaseTime"] = request.purchaseTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateCaster",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateCasterResponse>(await this.callApi(params, req, runtime), new CreateCasterResponse({}));
  }

  async createCaster(request: CreateCasterRequest): Promise<CreateCasterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createCasterWithOptions(request, runtime);
  }

  async createCustomTemplateWithOptions(request: CreateCustomTemplateRequest, runtime: $Util.RuntimeOptions): Promise<CreateCustomTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.customTemplate)) {
      query["CustomTemplate"] = request.customTemplate;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.template)) {
      query["Template"] = request.template;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateCustomTemplate",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateCustomTemplateResponse>(await this.callApi(params, req, runtime), new CreateCustomTemplateResponse({}));
  }

  async createCustomTemplate(request: CreateCustomTemplateRequest): Promise<CreateCustomTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createCustomTemplateWithOptions(request, runtime);
  }

  async createLiveRealTimeLogDeliveryWithOptions(request: CreateLiveRealTimeLogDeliveryRequest, runtime: $Util.RuntimeOptions): Promise<CreateLiveRealTimeLogDeliveryResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateLiveRealTimeLogDelivery",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateLiveRealTimeLogDeliveryResponse>(await this.callApi(params, req, runtime), new CreateLiveRealTimeLogDeliveryResponse({}));
  }

  async createLiveRealTimeLogDelivery(request: CreateLiveRealTimeLogDeliveryRequest): Promise<CreateLiveRealTimeLogDeliveryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createLiveRealTimeLogDeliveryWithOptions(request, runtime);
  }

  async createLiveStreamMonitorWithOptions(request: CreateLiveStreamMonitorRequest, runtime: $Util.RuntimeOptions): Promise<CreateLiveStreamMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.app)) {
      query["App"] = request.app;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.inputList)) {
      query["InputList"] = request.inputList;
    }

    if (!Util.isUnset(request.monitorName)) {
      query["MonitorName"] = request.monitorName;
    }

    if (!Util.isUnset(request.outputTemplate)) {
      query["OutputTemplate"] = request.outputTemplate;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.stream)) {
      query["Stream"] = request.stream;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateLiveStreamMonitor",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateLiveStreamMonitorResponse>(await this.callApi(params, req, runtime), new CreateLiveStreamMonitorResponse({}));
  }

  async createLiveStreamMonitor(request: CreateLiveStreamMonitorRequest): Promise<CreateLiveStreamMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createLiveStreamMonitorWithOptions(request, runtime);
  }

  async createLiveStreamRecordIndexFilesWithOptions(request: CreateLiveStreamRecordIndexFilesRequest, runtime: $Util.RuntimeOptions): Promise<CreateLiveStreamRecordIndexFilesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ossBucket)) {
      query["OssBucket"] = request.ossBucket;
    }

    if (!Util.isUnset(request.ossEndpoint)) {
      query["OssEndpoint"] = request.ossEndpoint;
    }

    if (!Util.isUnset(request.ossObject)) {
      query["OssObject"] = request.ossObject;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateLiveStreamRecordIndexFiles",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateLiveStreamRecordIndexFilesResponse>(await this.callApi(params, req, runtime), new CreateLiveStreamRecordIndexFilesResponse({}));
  }

  async createLiveStreamRecordIndexFiles(request: CreateLiveStreamRecordIndexFilesRequest): Promise<CreateLiveStreamRecordIndexFilesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createLiveStreamRecordIndexFilesWithOptions(request, runtime);
  }

  async createLiveTranscodeTemplateWithOptions(request: CreateLiveTranscodeTemplateRequest, runtime: $Util.RuntimeOptions): Promise<CreateLiveTranscodeTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.templateConfig)) {
      query["TemplateConfig"] = request.templateConfig;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateLiveTranscodeTemplate",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateLiveTranscodeTemplateResponse>(await this.callApi(params, req, runtime), new CreateLiveTranscodeTemplateResponse({}));
  }

  async createLiveTranscodeTemplate(request: CreateLiveTranscodeTemplateRequest): Promise<CreateLiveTranscodeTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createLiveTranscodeTemplateWithOptions(request, runtime);
  }

  async createMessageAppWithOptions(tmpReq: CreateMessageAppRequest, runtime: $Util.RuntimeOptions): Promise<CreateMessageAppResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateMessageAppShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.appConfig)) {
      request.appConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.appConfig, "AppConfig", "json");
    }

    if (!Util.isUnset(tmpReq.extension)) {
      request.extensionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extension, "Extension", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appConfigShrink)) {
      body["AppConfig"] = request.appConfigShrink;
    }

    if (!Util.isUnset(request.appName)) {
      body["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.extensionShrink)) {
      body["Extension"] = request.extensionShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateMessageApp",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateMessageAppResponse>(await this.callApi(params, req, runtime), new CreateMessageAppResponse({}));
  }

  async createMessageApp(request: CreateMessageAppRequest): Promise<CreateMessageAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createMessageAppWithOptions(request, runtime);
  }

  async createMessageGroupWithOptions(tmpReq: CreateMessageGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateMessageGroupResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateMessageGroupShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.extension)) {
      request.extensionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extension, "Extension", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.creatorId)) {
      body["CreatorId"] = request.creatorId;
    }

    if (!Util.isUnset(request.extensionShrink)) {
      body["Extension"] = request.extensionShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateMessageGroup",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateMessageGroupResponse>(await this.callApi(params, req, runtime), new CreateMessageGroupResponse({}));
  }

  async createMessageGroup(request: CreateMessageGroupRequest): Promise<CreateMessageGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createMessageGroupWithOptions(request, runtime);
  }

  async createMixStreamWithOptions(request: CreateMixStreamRequest, runtime: $Util.RuntimeOptions): Promise<CreateMixStreamResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.callbackConfig)) {
      query["CallbackConfig"] = request.callbackConfig;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.inputStreamList)) {
      query["InputStreamList"] = request.inputStreamList;
    }

    if (!Util.isUnset(request.layoutId)) {
      query["LayoutId"] = request.layoutId;
    }

    if (!Util.isUnset(request.outputConfig)) {
      query["OutputConfig"] = request.outputConfig;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateMixStream",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateMixStreamResponse>(await this.callApi(params, req, runtime), new CreateMixStreamResponse({}));
  }

  async createMixStream(request: CreateMixStreamRequest): Promise<CreateMixStreamResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createMixStreamWithOptions(request, runtime);
  }

  async deleteCasterWithOptions(request: DeleteCasterRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCasterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCaster",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteCasterResponse>(await this.callApi(params, req, runtime), new DeleteCasterResponse({}));
  }

  async deleteCaster(request: DeleteCasterRequest): Promise<DeleteCasterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCasterWithOptions(request, runtime);
  }

  async deleteCasterComponentWithOptions(request: DeleteCasterComponentRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCasterComponentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.componentId)) {
      query["ComponentId"] = request.componentId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCasterComponent",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteCasterComponentResponse>(await this.callApi(params, req, runtime), new DeleteCasterComponentResponse({}));
  }

  async deleteCasterComponent(request: DeleteCasterComponentRequest): Promise<DeleteCasterComponentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCasterComponentWithOptions(request, runtime);
  }

  async deleteCasterEpisodeWithOptions(request: DeleteCasterEpisodeRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCasterEpisodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.episodeId)) {
      query["EpisodeId"] = request.episodeId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCasterEpisode",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteCasterEpisodeResponse>(await this.callApi(params, req, runtime), new DeleteCasterEpisodeResponse({}));
  }

  async deleteCasterEpisode(request: DeleteCasterEpisodeRequest): Promise<DeleteCasterEpisodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCasterEpisodeWithOptions(request, runtime);
  }

  async deleteCasterEpisodeGroupWithOptions(request: DeleteCasterEpisodeGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCasterEpisodeGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.programId)) {
      query["ProgramId"] = request.programId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCasterEpisodeGroup",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteCasterEpisodeGroupResponse>(await this.callApi(params, req, runtime), new DeleteCasterEpisodeGroupResponse({}));
  }

  async deleteCasterEpisodeGroup(request: DeleteCasterEpisodeGroupRequest): Promise<DeleteCasterEpisodeGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCasterEpisodeGroupWithOptions(request, runtime);
  }

  async deleteCasterLayoutWithOptions(request: DeleteCasterLayoutRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCasterLayoutResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.layoutId)) {
      query["LayoutId"] = request.layoutId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCasterLayout",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteCasterLayoutResponse>(await this.callApi(params, req, runtime), new DeleteCasterLayoutResponse({}));
  }

  async deleteCasterLayout(request: DeleteCasterLayoutRequest): Promise<DeleteCasterLayoutResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCasterLayoutWithOptions(request, runtime);
  }

  async deleteCasterProgramWithOptions(request: DeleteCasterProgramRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCasterProgramResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCasterProgram",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteCasterProgramResponse>(await this.callApi(params, req, runtime), new DeleteCasterProgramResponse({}));
  }

  async deleteCasterProgram(request: DeleteCasterProgramRequest): Promise<DeleteCasterProgramResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCasterProgramWithOptions(request, runtime);
  }

  async deleteCasterSceneConfigWithOptions(request: DeleteCasterSceneConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCasterSceneConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.sceneId)) {
      query["SceneId"] = request.sceneId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCasterSceneConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteCasterSceneConfigResponse>(await this.callApi(params, req, runtime), new DeleteCasterSceneConfigResponse({}));
  }

  async deleteCasterSceneConfig(request: DeleteCasterSceneConfigRequest): Promise<DeleteCasterSceneConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCasterSceneConfigWithOptions(request, runtime);
  }

  async deleteCasterVideoResourceWithOptions(request: DeleteCasterVideoResourceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCasterVideoResourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCasterVideoResource",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteCasterVideoResourceResponse>(await this.callApi(params, req, runtime), new DeleteCasterVideoResourceResponse({}));
  }

  async deleteCasterVideoResource(request: DeleteCasterVideoResourceRequest): Promise<DeleteCasterVideoResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCasterVideoResourceWithOptions(request, runtime);
  }

  async deleteCustomTemplateWithOptions(request: DeleteCustomTemplateRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCustomTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.template)) {
      query["Template"] = request.template;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCustomTemplate",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteCustomTemplateResponse>(await this.callApi(params, req, runtime), new DeleteCustomTemplateResponse({}));
  }

  async deleteCustomTemplate(request: DeleteCustomTemplateRequest): Promise<DeleteCustomTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCustomTemplateWithOptions(request, runtime);
  }

  async deleteLiveAppRecordConfigWithOptions(request: DeleteLiveAppRecordConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveAppRecordConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveAppRecordConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveAppRecordConfigResponse>(await this.callApi(params, req, runtime), new DeleteLiveAppRecordConfigResponse({}));
  }

  async deleteLiveAppRecordConfig(request: DeleteLiveAppRecordConfigRequest): Promise<DeleteLiveAppRecordConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveAppRecordConfigWithOptions(request, runtime);
  }

  async deleteLiveAppSnapshotConfigWithOptions(request: DeleteLiveAppSnapshotConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveAppSnapshotConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveAppSnapshotConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveAppSnapshotConfigResponse>(await this.callApi(params, req, runtime), new DeleteLiveAppSnapshotConfigResponse({}));
  }

  async deleteLiveAppSnapshotConfig(request: DeleteLiveAppSnapshotConfigRequest): Promise<DeleteLiveAppSnapshotConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveAppSnapshotConfigWithOptions(request, runtime);
  }

  async deleteLiveAudioAuditConfigWithOptions(request: DeleteLiveAudioAuditConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveAudioAuditConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveAudioAuditConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveAudioAuditConfigResponse>(await this.callApi(params, req, runtime), new DeleteLiveAudioAuditConfigResponse({}));
  }

  async deleteLiveAudioAuditConfig(request: DeleteLiveAudioAuditConfigRequest): Promise<DeleteLiveAudioAuditConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveAudioAuditConfigWithOptions(request, runtime);
  }

  async deleteLiveAudioAuditNotifyConfigWithOptions(request: DeleteLiveAudioAuditNotifyConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveAudioAuditNotifyConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveAudioAuditNotifyConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveAudioAuditNotifyConfigResponse>(await this.callApi(params, req, runtime), new DeleteLiveAudioAuditNotifyConfigResponse({}));
  }

  async deleteLiveAudioAuditNotifyConfig(request: DeleteLiveAudioAuditNotifyConfigRequest): Promise<DeleteLiveAudioAuditNotifyConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveAudioAuditNotifyConfigWithOptions(request, runtime);
  }

  async deleteLiveDetectNotifyConfigWithOptions(request: DeleteLiveDetectNotifyConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveDetectNotifyConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveDetectNotifyConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveDetectNotifyConfigResponse>(await this.callApi(params, req, runtime), new DeleteLiveDetectNotifyConfigResponse({}));
  }

  async deleteLiveDetectNotifyConfig(request: DeleteLiveDetectNotifyConfigRequest): Promise<DeleteLiveDetectNotifyConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveDetectNotifyConfigWithOptions(request, runtime);
  }

  async deleteLiveDomainWithOptions(request: DeleteLiveDomainRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveDomain",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveDomainResponse>(await this.callApi(params, req, runtime), new DeleteLiveDomainResponse({}));
  }

  async deleteLiveDomain(request: DeleteLiveDomainRequest): Promise<DeleteLiveDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveDomainWithOptions(request, runtime);
  }

  async deleteLiveDomainMappingWithOptions(request: DeleteLiveDomainMappingRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveDomainMappingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pullDomain)) {
      query["PullDomain"] = request.pullDomain;
    }

    if (!Util.isUnset(request.pushDomain)) {
      query["PushDomain"] = request.pushDomain;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveDomainMapping",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveDomainMappingResponse>(await this.callApi(params, req, runtime), new DeleteLiveDomainMappingResponse({}));
  }

  async deleteLiveDomainMapping(request: DeleteLiveDomainMappingRequest): Promise<DeleteLiveDomainMappingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveDomainMappingWithOptions(request, runtime);
  }

  async deleteLiveDomainPlayMappingWithOptions(request: DeleteLiveDomainPlayMappingRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveDomainPlayMappingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.playDomain)) {
      query["PlayDomain"] = request.playDomain;
    }

    if (!Util.isUnset(request.pullDomain)) {
      query["PullDomain"] = request.pullDomain;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveDomainPlayMapping",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveDomainPlayMappingResponse>(await this.callApi(params, req, runtime), new DeleteLiveDomainPlayMappingResponse({}));
  }

  async deleteLiveDomainPlayMapping(request: DeleteLiveDomainPlayMappingRequest): Promise<DeleteLiveDomainPlayMappingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveDomainPlayMappingWithOptions(request, runtime);
  }

  async deleteLiveEdgeTransferWithOptions(request: DeleteLiveEdgeTransferRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveEdgeTransferResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveEdgeTransfer",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveEdgeTransferResponse>(await this.callApi(params, req, runtime), new DeleteLiveEdgeTransferResponse({}));
  }

  async deleteLiveEdgeTransfer(request: DeleteLiveEdgeTransferRequest): Promise<DeleteLiveEdgeTransferResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveEdgeTransferWithOptions(request, runtime);
  }

  async deleteLiveLazyPullStreamInfoConfigWithOptions(request: DeleteLiveLazyPullStreamInfoConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveLazyPullStreamInfoConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveLazyPullStreamInfoConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveLazyPullStreamInfoConfigResponse>(await this.callApi(params, req, runtime), new DeleteLiveLazyPullStreamInfoConfigResponse({}));
  }

  async deleteLiveLazyPullStreamInfoConfig(request: DeleteLiveLazyPullStreamInfoConfigRequest): Promise<DeleteLiveLazyPullStreamInfoConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveLazyPullStreamInfoConfigWithOptions(request, runtime);
  }

  async deleteLivePullStreamInfoConfigWithOptions(request: DeleteLivePullStreamInfoConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLivePullStreamInfoConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLivePullStreamInfoConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLivePullStreamInfoConfigResponse>(await this.callApi(params, req, runtime), new DeleteLivePullStreamInfoConfigResponse({}));
  }

  async deleteLivePullStreamInfoConfig(request: DeleteLivePullStreamInfoConfigRequest): Promise<DeleteLivePullStreamInfoConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLivePullStreamInfoConfigWithOptions(request, runtime);
  }

  async deleteLiveRealTimeLogLogstoreWithOptions(request: DeleteLiveRealTimeLogLogstoreRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveRealTimeLogLogstoreResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveRealTimeLogLogstore",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveRealTimeLogLogstoreResponse>(await this.callApi(params, req, runtime), new DeleteLiveRealTimeLogLogstoreResponse({}));
  }

  async deleteLiveRealTimeLogLogstore(request: DeleteLiveRealTimeLogLogstoreRequest): Promise<DeleteLiveRealTimeLogLogstoreResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveRealTimeLogLogstoreWithOptions(request, runtime);
  }

  async deleteLiveRealtimeLogDeliveryWithOptions(request: DeleteLiveRealtimeLogDeliveryRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveRealtimeLogDeliveryResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveRealtimeLogDelivery",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveRealtimeLogDeliveryResponse>(await this.callApi(params, req, runtime), new DeleteLiveRealtimeLogDeliveryResponse({}));
  }

  async deleteLiveRealtimeLogDelivery(request: DeleteLiveRealtimeLogDeliveryRequest): Promise<DeleteLiveRealtimeLogDeliveryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveRealtimeLogDeliveryWithOptions(request, runtime);
  }

  async deleteLiveRecordNotifyConfigWithOptions(request: DeleteLiveRecordNotifyConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveRecordNotifyConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveRecordNotifyConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveRecordNotifyConfigResponse>(await this.callApi(params, req, runtime), new DeleteLiveRecordNotifyConfigResponse({}));
  }

  async deleteLiveRecordNotifyConfig(request: DeleteLiveRecordNotifyConfigRequest): Promise<DeleteLiveRecordNotifyConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveRecordNotifyConfigWithOptions(request, runtime);
  }

  async deleteLiveRecordVodConfigWithOptions(request: DeleteLiveRecordVodConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveRecordVodConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveRecordVodConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveRecordVodConfigResponse>(await this.callApi(params, req, runtime), new DeleteLiveRecordVodConfigResponse({}));
  }

  async deleteLiveRecordVodConfig(request: DeleteLiveRecordVodConfigRequest): Promise<DeleteLiveRecordVodConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveRecordVodConfigWithOptions(request, runtime);
  }

  async deleteLiveSnapshotDetectPornConfigWithOptions(request: DeleteLiveSnapshotDetectPornConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveSnapshotDetectPornConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveSnapshotDetectPornConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveSnapshotDetectPornConfigResponse>(await this.callApi(params, req, runtime), new DeleteLiveSnapshotDetectPornConfigResponse({}));
  }

  async deleteLiveSnapshotDetectPornConfig(request: DeleteLiveSnapshotDetectPornConfigRequest): Promise<DeleteLiveSnapshotDetectPornConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveSnapshotDetectPornConfigWithOptions(request, runtime);
  }

  async deleteLiveSnapshotNotifyConfigWithOptions(request: DeleteLiveSnapshotNotifyConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveSnapshotNotifyConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveSnapshotNotifyConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveSnapshotNotifyConfigResponse>(await this.callApi(params, req, runtime), new DeleteLiveSnapshotNotifyConfigResponse({}));
  }

  async deleteLiveSnapshotNotifyConfig(request: DeleteLiveSnapshotNotifyConfigRequest): Promise<DeleteLiveSnapshotNotifyConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveSnapshotNotifyConfigWithOptions(request, runtime);
  }

  async deleteLiveSpecificStagingConfigWithOptions(request: DeleteLiveSpecificStagingConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveSpecificStagingConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveSpecificStagingConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveSpecificStagingConfigResponse>(await this.callApi(params, req, runtime), new DeleteLiveSpecificStagingConfigResponse({}));
  }

  async deleteLiveSpecificStagingConfig(request: DeleteLiveSpecificStagingConfigRequest): Promise<DeleteLiveSpecificStagingConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveSpecificStagingConfigWithOptions(request, runtime);
  }

  async deleteLiveStreamMonitorWithOptions(request: DeleteLiveStreamMonitorRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveStreamMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.monitorId)) {
      query["MonitorId"] = request.monitorId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveStreamMonitor",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveStreamMonitorResponse>(await this.callApi(params, req, runtime), new DeleteLiveStreamMonitorResponse({}));
  }

  async deleteLiveStreamMonitor(request: DeleteLiveStreamMonitorRequest): Promise<DeleteLiveStreamMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveStreamMonitorWithOptions(request, runtime);
  }

  async deleteLiveStreamRecordIndexFilesWithOptions(request: DeleteLiveStreamRecordIndexFilesRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveStreamRecordIndexFilesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.recordId)) {
      query["RecordId"] = request.recordId;
    }

    if (!Util.isUnset(request.removeFile)) {
      query["RemoveFile"] = request.removeFile;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveStreamRecordIndexFiles",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveStreamRecordIndexFilesResponse>(await this.callApi(params, req, runtime), new DeleteLiveStreamRecordIndexFilesResponse({}));
  }

  async deleteLiveStreamRecordIndexFiles(request: DeleteLiveStreamRecordIndexFilesRequest): Promise<DeleteLiveStreamRecordIndexFilesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveStreamRecordIndexFilesWithOptions(request, runtime);
  }

  async deleteLiveStreamTranscodeWithOptions(request: DeleteLiveStreamTranscodeRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveStreamTranscodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.app)) {
      query["App"] = request.app;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.template)) {
      query["Template"] = request.template;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveStreamTranscode",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveStreamTranscodeResponse>(await this.callApi(params, req, runtime), new DeleteLiveStreamTranscodeResponse({}));
  }

  async deleteLiveStreamTranscode(request: DeleteLiveStreamTranscodeRequest): Promise<DeleteLiveStreamTranscodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveStreamTranscodeWithOptions(request, runtime);
  }

  async deleteLiveStreamWatermarkWithOptions(request: DeleteLiveStreamWatermarkRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveStreamWatermarkResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveStreamWatermark",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveStreamWatermarkResponse>(await this.callApi(params, req, runtime), new DeleteLiveStreamWatermarkResponse({}));
  }

  async deleteLiveStreamWatermark(request: DeleteLiveStreamWatermarkRequest): Promise<DeleteLiveStreamWatermarkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveStreamWatermarkWithOptions(request, runtime);
  }

  async deleteLiveStreamWatermarkRuleWithOptions(request: DeleteLiveStreamWatermarkRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveStreamWatermarkRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.app)) {
      query["App"] = request.app;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.stream)) {
      query["Stream"] = request.stream;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveStreamWatermarkRule",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveStreamWatermarkRuleResponse>(await this.callApi(params, req, runtime), new DeleteLiveStreamWatermarkRuleResponse({}));
  }

  async deleteLiveStreamWatermarkRule(request: DeleteLiveStreamWatermarkRuleRequest): Promise<DeleteLiveStreamWatermarkRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveStreamWatermarkRuleWithOptions(request, runtime);
  }

  async deleteLiveStreamsNotifyUrlConfigWithOptions(request: DeleteLiveStreamsNotifyUrlConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLiveStreamsNotifyUrlConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLiveStreamsNotifyUrlConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveStreamsNotifyUrlConfigResponse>(await this.callApi(params, req, runtime), new DeleteLiveStreamsNotifyUrlConfigResponse({}));
  }

  async deleteLiveStreamsNotifyUrlConfig(request: DeleteLiveStreamsNotifyUrlConfigRequest): Promise<DeleteLiveStreamsNotifyUrlConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLiveStreamsNotifyUrlConfigWithOptions(request, runtime);
  }

  async deleteMessageAppWithOptions(request: DeleteMessageAppRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMessageAppResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMessageApp",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMessageAppResponse>(await this.callApi(params, req, runtime), new DeleteMessageAppResponse({}));
  }

  async deleteMessageApp(request: DeleteMessageAppRequest): Promise<DeleteMessageAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMessageAppWithOptions(request, runtime);
  }

  async deleteMixStreamWithOptions(request: DeleteMixStreamRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMixStreamResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.mixStreamId)) {
      query["MixStreamId"] = request.mixStreamId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMixStream",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMixStreamResponse>(await this.callApi(params, req, runtime), new DeleteMixStreamResponse({}));
  }

  async deleteMixStream(request: DeleteMixStreamRequest): Promise<DeleteMixStreamResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMixStreamWithOptions(request, runtime);
  }

  async deleteMultiRateConfigWithOptions(request: DeleteMultiRateConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMultiRateConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.app)) {
      query["App"] = request.app;
    }

    if (!Util.isUnset(request.deleteAll)) {
      query["DeleteAll"] = request.deleteAll;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.templates)) {
      query["Templates"] = request.templates;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMultiRateConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMultiRateConfigResponse>(await this.callApi(params, req, runtime), new DeleteMultiRateConfigResponse({}));
  }

  async deleteMultiRateConfig(request: DeleteMultiRateConfigRequest): Promise<DeleteMultiRateConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMultiRateConfigWithOptions(request, runtime);
  }

  async deletePlaylistWithOptions(request: DeletePlaylistRequest, runtime: $Util.RuntimeOptions): Promise<DeletePlaylistResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.programId)) {
      query["ProgramId"] = request.programId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeletePlaylist",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeletePlaylistResponse>(await this.callApi(params, req, runtime), new DeletePlaylistResponse({}));
  }

  async deletePlaylist(request: DeletePlaylistRequest): Promise<DeletePlaylistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deletePlaylistWithOptions(request, runtime);
  }

  async deletePlaylistItemsWithOptions(request: DeletePlaylistItemsRequest, runtime: $Util.RuntimeOptions): Promise<DeletePlaylistItemsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.programId)) {
      query["ProgramId"] = request.programId;
    }

    if (!Util.isUnset(request.programItemIds)) {
      query["ProgramItemIds"] = request.programItemIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeletePlaylistItems",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeletePlaylistItemsResponse>(await this.callApi(params, req, runtime), new DeletePlaylistItemsResponse({}));
  }

  async deletePlaylistItems(request: DeletePlaylistItemsRequest): Promise<DeletePlaylistItemsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deletePlaylistItemsWithOptions(request, runtime);
  }

  async deleteRoomWithOptions(request: DeleteRoomRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRoomResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.roomId)) {
      query["RoomId"] = request.roomId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRoom",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteRoomResponse>(await this.callApi(params, req, runtime), new DeleteRoomResponse({}));
  }

  async deleteRoom(request: DeleteRoomRequest): Promise<DeleteRoomResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRoomWithOptions(request, runtime);
  }

  async deleteSnapshotCallbackAuthWithOptions(request: DeleteSnapshotCallbackAuthRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSnapshotCallbackAuthResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSnapshotCallbackAuth",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSnapshotCallbackAuthResponse>(await this.callApi(params, req, runtime), new DeleteSnapshotCallbackAuthResponse({}));
  }

  async deleteSnapshotCallbackAuth(request: DeleteSnapshotCallbackAuthRequest): Promise<DeleteSnapshotCallbackAuthResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSnapshotCallbackAuthWithOptions(request, runtime);
  }

  async deleteSnapshotFilesWithOptions(request: DeleteSnapshotFilesRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSnapshotFilesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.createTimestampList)) {
      query["CreateTimestampList"] = request.createTimestampList;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.removeFile)) {
      query["RemoveFile"] = request.removeFile;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSnapshotFiles",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSnapshotFilesResponse>(await this.callApi(params, req, runtime), new DeleteSnapshotFilesResponse({}));
  }

  async deleteSnapshotFiles(request: DeleteSnapshotFilesRequest): Promise<DeleteSnapshotFilesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSnapshotFilesWithOptions(request, runtime);
  }

  async deleteStudioLayoutWithOptions(request: DeleteStudioLayoutRequest, runtime: $Util.RuntimeOptions): Promise<DeleteStudioLayoutResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.layoutId)) {
      query["LayoutId"] = request.layoutId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteStudioLayout",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteStudioLayoutResponse>(await this.callApi(params, req, runtime), new DeleteStudioLayoutResponse({}));
  }

  async deleteStudioLayout(request: DeleteStudioLayoutRequest): Promise<DeleteStudioLayoutResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteStudioLayoutWithOptions(request, runtime);
  }

  async describeAutoShowListTasksWithOptions(request: DescribeAutoShowListTasksRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAutoShowListTasksResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAutoShowListTasks",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAutoShowListTasksResponse>(await this.callApi(params, req, runtime), new DescribeAutoShowListTasksResponse({}));
  }

  async describeAutoShowListTasks(request: DescribeAutoShowListTasksRequest): Promise<DescribeAutoShowListTasksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAutoShowListTasksWithOptions(request, runtime);
  }

  async describeCasterChannelsWithOptions(request: DescribeCasterChannelsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCasterChannelsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCasterChannels",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCasterChannelsResponse>(await this.callApi(params, req, runtime), new DescribeCasterChannelsResponse({}));
  }

  async describeCasterChannels(request: DescribeCasterChannelsRequest): Promise<DescribeCasterChannelsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCasterChannelsWithOptions(request, runtime);
  }

  async describeCasterComponentsWithOptions(request: DescribeCasterComponentsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCasterComponentsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.componentId)) {
      query["ComponentId"] = request.componentId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCasterComponents",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCasterComponentsResponse>(await this.callApi(params, req, runtime), new DescribeCasterComponentsResponse({}));
  }

  async describeCasterComponents(request: DescribeCasterComponentsRequest): Promise<DescribeCasterComponentsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCasterComponentsWithOptions(request, runtime);
  }

  async describeCasterConfigWithOptions(request: DescribeCasterConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCasterConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCasterConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCasterConfigResponse>(await this.callApi(params, req, runtime), new DescribeCasterConfigResponse({}));
  }

  async describeCasterConfig(request: DescribeCasterConfigRequest): Promise<DescribeCasterConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCasterConfigWithOptions(request, runtime);
  }

  async describeCasterLayoutsWithOptions(request: DescribeCasterLayoutsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCasterLayoutsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.layoutId)) {
      query["LayoutId"] = request.layoutId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCasterLayouts",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCasterLayoutsResponse>(await this.callApi(params, req, runtime), new DescribeCasterLayoutsResponse({}));
  }

  async describeCasterLayouts(request: DescribeCasterLayoutsRequest): Promise<DescribeCasterLayoutsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCasterLayoutsWithOptions(request, runtime);
  }

  async describeCasterProgramWithOptions(request: DescribeCasterProgramRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCasterProgramResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.episodeId)) {
      query["EpisodeId"] = request.episodeId;
    }

    if (!Util.isUnset(request.episodeType)) {
      query["EpisodeType"] = request.episodeType;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCasterProgram",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCasterProgramResponse>(await this.callApi(params, req, runtime), new DescribeCasterProgramResponse({}));
  }

  async describeCasterProgram(request: DescribeCasterProgramRequest): Promise<DescribeCasterProgramResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCasterProgramWithOptions(request, runtime);
  }

  async describeCasterSceneAudioWithOptions(request: DescribeCasterSceneAudioRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCasterSceneAudioResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.sceneId)) {
      query["SceneId"] = request.sceneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCasterSceneAudio",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCasterSceneAudioResponse>(await this.callApi(params, req, runtime), new DescribeCasterSceneAudioResponse({}));
  }

  async describeCasterSceneAudio(request: DescribeCasterSceneAudioRequest): Promise<DescribeCasterSceneAudioResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCasterSceneAudioWithOptions(request, runtime);
  }

  async describeCasterScenesWithOptions(request: DescribeCasterScenesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCasterScenesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.sceneId)) {
      query["SceneId"] = request.sceneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCasterScenes",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCasterScenesResponse>(await this.callApi(params, req, runtime), new DescribeCasterScenesResponse({}));
  }

  async describeCasterScenes(request: DescribeCasterScenesRequest): Promise<DescribeCasterScenesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCasterScenesWithOptions(request, runtime);
  }

  async describeCasterStreamUrlWithOptions(request: DescribeCasterStreamUrlRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCasterStreamUrlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCasterStreamUrl",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCasterStreamUrlResponse>(await this.callApi(params, req, runtime), new DescribeCasterStreamUrlResponse({}));
  }

  async describeCasterStreamUrl(request: DescribeCasterStreamUrlRequest): Promise<DescribeCasterStreamUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCasterStreamUrlWithOptions(request, runtime);
  }

  async describeCasterSyncGroupWithOptions(request: DescribeCasterSyncGroupRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCasterSyncGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCasterSyncGroup",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCasterSyncGroupResponse>(await this.callApi(params, req, runtime), new DescribeCasterSyncGroupResponse({}));
  }

  async describeCasterSyncGroup(request: DescribeCasterSyncGroupRequest): Promise<DescribeCasterSyncGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCasterSyncGroupWithOptions(request, runtime);
  }

  async describeCasterVideoResourcesWithOptions(request: DescribeCasterVideoResourcesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCasterVideoResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCasterVideoResources",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCasterVideoResourcesResponse>(await this.callApi(params, req, runtime), new DescribeCasterVideoResourcesResponse({}));
  }

  async describeCasterVideoResources(request: DescribeCasterVideoResourcesRequest): Promise<DescribeCasterVideoResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCasterVideoResourcesWithOptions(request, runtime);
  }

  async describeCastersWithOptions(request: DescribeCastersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCastersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.casterName)) {
      query["CasterName"] = request.casterName;
    }

    if (!Util.isUnset(request.chargeType)) {
      query["ChargeType"] = request.chargeType;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.normType)) {
      query["NormType"] = request.normType;
    }

    if (!Util.isUnset(request.orderByModifyAsc)) {
      query["OrderByModifyAsc"] = request.orderByModifyAsc;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCasters",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCastersResponse>(await this.callApi(params, req, runtime), new DescribeCastersResponse({}));
  }

  async describeCasters(request: DescribeCastersRequest): Promise<DescribeCastersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCastersWithOptions(request, runtime);
  }

  async describeDomainUsageDataWithOptions(request: DescribeDomainUsageDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainUsageDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.area)) {
      query["Area"] = request.area;
    }

    if (!Util.isUnset(request.dataProtocol)) {
      query["DataProtocol"] = request.dataProtocol;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.field)) {
      query["Field"] = request.field;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainUsageData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainUsageDataResponse>(await this.callApi(params, req, runtime), new DescribeDomainUsageDataResponse({}));
  }

  async describeDomainUsageData(request: DescribeDomainUsageDataRequest): Promise<DescribeDomainUsageDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainUsageDataWithOptions(request, runtime);
  }

  async describeDomainWithIntegrityWithOptions(request: DescribeDomainWithIntegrityRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainWithIntegrityResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainWithIntegrity",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainWithIntegrityResponse>(await this.callApi(params, req, runtime), new DescribeDomainWithIntegrityResponse({}));
  }

  async describeDomainWithIntegrity(request: DescribeDomainWithIntegrityRequest): Promise<DescribeDomainWithIntegrityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainWithIntegrityWithOptions(request, runtime);
  }

  async describeForbidPushStreamRoomListWithOptions(request: DescribeForbidPushStreamRoomListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeForbidPushStreamRoomListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.order)) {
      query["Order"] = request.order;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeForbidPushStreamRoomList",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeForbidPushStreamRoomListResponse>(await this.callApi(params, req, runtime), new DescribeForbidPushStreamRoomListResponse({}));
  }

  async describeForbidPushStreamRoomList(request: DescribeForbidPushStreamRoomListRequest): Promise<DescribeForbidPushStreamRoomListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeForbidPushStreamRoomListWithOptions(request, runtime);
  }

  async describeHlsLiveStreamRealTimeBpsDataWithOptions(request: DescribeHlsLiveStreamRealTimeBpsDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeHlsLiveStreamRealTimeBpsDataResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeHlsLiveStreamRealTimeBpsData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeHlsLiveStreamRealTimeBpsDataResponse>(await this.callApi(params, req, runtime), new DescribeHlsLiveStreamRealTimeBpsDataResponse({}));
  }

  async describeHlsLiveStreamRealTimeBpsData(request: DescribeHlsLiveStreamRealTimeBpsDataRequest): Promise<DescribeHlsLiveStreamRealTimeBpsDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeHlsLiveStreamRealTimeBpsDataWithOptions(request, runtime);
  }

  async describeLiveAudioAuditConfigWithOptions(request: DescribeLiveAudioAuditConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveAudioAuditConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveAudioAuditConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveAudioAuditConfigResponse>(await this.callApi(params, req, runtime), new DescribeLiveAudioAuditConfigResponse({}));
  }

  async describeLiveAudioAuditConfig(request: DescribeLiveAudioAuditConfigRequest): Promise<DescribeLiveAudioAuditConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveAudioAuditConfigWithOptions(request, runtime);
  }

  async describeLiveAudioAuditNotifyConfigWithOptions(request: DescribeLiveAudioAuditNotifyConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveAudioAuditNotifyConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveAudioAuditNotifyConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveAudioAuditNotifyConfigResponse>(await this.callApi(params, req, runtime), new DescribeLiveAudioAuditNotifyConfigResponse({}));
  }

  async describeLiveAudioAuditNotifyConfig(request: DescribeLiveAudioAuditNotifyConfigRequest): Promise<DescribeLiveAudioAuditNotifyConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveAudioAuditNotifyConfigWithOptions(request, runtime);
  }

  async describeLiveCertificateDetailWithOptions(request: DescribeLiveCertificateDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveCertificateDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.certName)) {
      query["CertName"] = request.certName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveCertificateDetail",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveCertificateDetailResponse>(await this.callApi(params, req, runtime), new DescribeLiveCertificateDetailResponse({}));
  }

  async describeLiveCertificateDetail(request: DescribeLiveCertificateDetailRequest): Promise<DescribeLiveCertificateDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveCertificateDetailWithOptions(request, runtime);
  }

  async describeLiveCertificateListWithOptions(request: DescribeLiveCertificateListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveCertificateListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveCertificateList",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveCertificateListResponse>(await this.callApi(params, req, runtime), new DescribeLiveCertificateListResponse({}));
  }

  async describeLiveCertificateList(request: DescribeLiveCertificateListRequest): Promise<DescribeLiveCertificateListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveCertificateListWithOptions(request, runtime);
  }

  async describeLiveDetectNotifyConfigWithOptions(request: DescribeLiveDetectNotifyConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDetectNotifyConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDetectNotifyConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDetectNotifyConfigResponse>(await this.callApi(params, req, runtime), new DescribeLiveDetectNotifyConfigResponse({}));
  }

  async describeLiveDetectNotifyConfig(request: DescribeLiveDetectNotifyConfigRequest): Promise<DescribeLiveDetectNotifyConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDetectNotifyConfigWithOptions(request, runtime);
  }

  async describeLiveDetectPornDataWithOptions(request: DescribeLiveDetectPornDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDetectPornDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.app)) {
      query["App"] = request.app;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.fee)) {
      query["Fee"] = request.fee;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.scene)) {
      query["Scene"] = request.scene;
    }

    if (!Util.isUnset(request.splitBy)) {
      query["SplitBy"] = request.splitBy;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.stream)) {
      query["Stream"] = request.stream;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDetectPornData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDetectPornDataResponse>(await this.callApi(params, req, runtime), new DescribeLiveDetectPornDataResponse({}));
  }

  async describeLiveDetectPornData(request: DescribeLiveDetectPornDataRequest): Promise<DescribeLiveDetectPornDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDetectPornDataWithOptions(request, runtime);
  }

  async describeLiveDomainBpsDataWithOptions(request: DescribeLiveDomainBpsDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainBpsDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispNameEn)) {
      query["IspNameEn"] = request.ispNameEn;
    }

    if (!Util.isUnset(request.locationNameEn)) {
      query["LocationNameEn"] = request.locationNameEn;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainBpsData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainBpsDataResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainBpsDataResponse({}));
  }

  async describeLiveDomainBpsData(request: DescribeLiveDomainBpsDataRequest): Promise<DescribeLiveDomainBpsDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainBpsDataWithOptions(request, runtime);
  }

  async describeLiveDomainBpsDataByLayerWithOptions(request: DescribeLiveDomainBpsDataByLayerRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainBpsDataByLayerResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispNameEn)) {
      query["IspNameEn"] = request.ispNameEn;
    }

    if (!Util.isUnset(request.layer)) {
      query["Layer"] = request.layer;
    }

    if (!Util.isUnset(request.locationNameEn)) {
      query["LocationNameEn"] = request.locationNameEn;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainBpsDataByLayer",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainBpsDataByLayerResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainBpsDataByLayerResponse({}));
  }

  async describeLiveDomainBpsDataByLayer(request: DescribeLiveDomainBpsDataByLayerRequest): Promise<DescribeLiveDomainBpsDataByLayerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainBpsDataByLayerWithOptions(request, runtime);
  }

  async describeLiveDomainBpsDataByTimeStampWithOptions(request: DescribeLiveDomainBpsDataByTimeStampRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainBpsDataByTimeStampResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ispNames)) {
      query["IspNames"] = request.ispNames;
    }

    if (!Util.isUnset(request.locationNames)) {
      query["LocationNames"] = request.locationNames;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.timePoint)) {
      query["TimePoint"] = request.timePoint;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainBpsDataByTimeStamp",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainBpsDataByTimeStampResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainBpsDataByTimeStampResponse({}));
  }

  async describeLiveDomainBpsDataByTimeStamp(request: DescribeLiveDomainBpsDataByTimeStampRequest): Promise<DescribeLiveDomainBpsDataByTimeStampResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainBpsDataByTimeStampWithOptions(request, runtime);
  }

  async describeLiveDomainCertificateInfoWithOptions(request: DescribeLiveDomainCertificateInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainCertificateInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainCertificateInfo",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainCertificateInfoResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainCertificateInfoResponse({}));
  }

  async describeLiveDomainCertificateInfo(request: DescribeLiveDomainCertificateInfoRequest): Promise<DescribeLiveDomainCertificateInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainCertificateInfoWithOptions(request, runtime);
  }

  async describeLiveDomainConfigsWithOptions(request: DescribeLiveDomainConfigsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.functionNames)) {
      query["FunctionNames"] = request.functionNames;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainConfigs",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainConfigsResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainConfigsResponse({}));
  }

  async describeLiveDomainConfigs(request: DescribeLiveDomainConfigsRequest): Promise<DescribeLiveDomainConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainConfigsWithOptions(request, runtime);
  }

  async describeLiveDomainDetailWithOptions(request: DescribeLiveDomainDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainDetail",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainDetailResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainDetailResponse({}));
  }

  async describeLiveDomainDetail(request: DescribeLiveDomainDetailRequest): Promise<DescribeLiveDomainDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainDetailWithOptions(request, runtime);
  }

  async describeLiveDomainFrameRateAndBitRateDataWithOptions(request: DescribeLiveDomainFrameRateAndBitRateDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainFrameRateAndBitRateDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.queryTime)) {
      query["QueryTime"] = request.queryTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainFrameRateAndBitRateData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainFrameRateAndBitRateDataResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainFrameRateAndBitRateDataResponse({}));
  }

  async describeLiveDomainFrameRateAndBitRateData(request: DescribeLiveDomainFrameRateAndBitRateDataRequest): Promise<DescribeLiveDomainFrameRateAndBitRateDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainFrameRateAndBitRateDataWithOptions(request, runtime);
  }

  async describeLiveDomainLimitWithOptions(request: DescribeLiveDomainLimitRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainLimitResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainLimit",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainLimitResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainLimitResponse({}));
  }

  async describeLiveDomainLimit(request: DescribeLiveDomainLimitRequest): Promise<DescribeLiveDomainLimitResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainLimitWithOptions(request, runtime);
  }

  async describeLiveDomainLogWithOptions(request: DescribeLiveDomainLogRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainLog",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainLogResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainLogResponse({}));
  }

  async describeLiveDomainLog(request: DescribeLiveDomainLogRequest): Promise<DescribeLiveDomainLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainLogWithOptions(request, runtime);
  }

  async describeLiveDomainMappingWithOptions(request: DescribeLiveDomainMappingRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainMappingResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainMapping",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainMappingResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainMappingResponse({}));
  }

  async describeLiveDomainMapping(request: DescribeLiveDomainMappingRequest): Promise<DescribeLiveDomainMappingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainMappingWithOptions(request, runtime);
  }

  async describeLiveDomainOnlineUserNumWithOptions(request: DescribeLiveDomainOnlineUserNumRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainOnlineUserNumResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.queryTime)) {
      query["QueryTime"] = request.queryTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainOnlineUserNum",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainOnlineUserNumResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainOnlineUserNumResponse({}));
  }

  async describeLiveDomainOnlineUserNum(request: DescribeLiveDomainOnlineUserNumRequest): Promise<DescribeLiveDomainOnlineUserNumResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainOnlineUserNumWithOptions(request, runtime);
  }

  async describeLiveDomainPushBpsDataWithOptions(request: DescribeLiveDomainPushBpsDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainPushBpsDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispNameEn)) {
      query["IspNameEn"] = request.ispNameEn;
    }

    if (!Util.isUnset(request.locationNameEn)) {
      query["LocationNameEn"] = request.locationNameEn;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainPushBpsData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainPushBpsDataResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainPushBpsDataResponse({}));
  }

  async describeLiveDomainPushBpsData(request: DescribeLiveDomainPushBpsDataRequest): Promise<DescribeLiveDomainPushBpsDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainPushBpsDataWithOptions(request, runtime);
  }

  async describeLiveDomainPushTrafficDataWithOptions(request: DescribeLiveDomainPushTrafficDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainPushTrafficDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispNameEn)) {
      query["IspNameEn"] = request.ispNameEn;
    }

    if (!Util.isUnset(request.locationNameEn)) {
      query["LocationNameEn"] = request.locationNameEn;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainPushTrafficData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainPushTrafficDataResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainPushTrafficDataResponse({}));
  }

  async describeLiveDomainPushTrafficData(request: DescribeLiveDomainPushTrafficDataRequest): Promise<DescribeLiveDomainPushTrafficDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainPushTrafficDataWithOptions(request, runtime);
  }

  async describeLiveDomainPvUvDataWithOptions(request: DescribeLiveDomainPvUvDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainPvUvDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainPvUvData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainPvUvDataResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainPvUvDataResponse({}));
  }

  async describeLiveDomainPvUvData(request: DescribeLiveDomainPvUvDataRequest): Promise<DescribeLiveDomainPvUvDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainPvUvDataWithOptions(request, runtime);
  }

  async describeLiveDomainRealTimeBpsDataWithOptions(request: DescribeLiveDomainRealTimeBpsDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainRealTimeBpsDataResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainRealTimeBpsData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainRealTimeBpsDataResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainRealTimeBpsDataResponse({}));
  }

  async describeLiveDomainRealTimeBpsData(request: DescribeLiveDomainRealTimeBpsDataRequest): Promise<DescribeLiveDomainRealTimeBpsDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainRealTimeBpsDataWithOptions(request, runtime);
  }

  async describeLiveDomainRealTimeHttpCodeDataWithOptions(request: DescribeLiveDomainRealTimeHttpCodeDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainRealTimeHttpCodeDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ispNameEn)) {
      query["IspNameEn"] = request.ispNameEn;
    }

    if (!Util.isUnset(request.locationNameEn)) {
      query["LocationNameEn"] = request.locationNameEn;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainRealTimeHttpCodeData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainRealTimeHttpCodeDataResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainRealTimeHttpCodeDataResponse({}));
  }

  async describeLiveDomainRealTimeHttpCodeData(request: DescribeLiveDomainRealTimeHttpCodeDataRequest): Promise<DescribeLiveDomainRealTimeHttpCodeDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainRealTimeHttpCodeDataWithOptions(request, runtime);
  }

  async describeLiveDomainRealTimeTrafficDataWithOptions(request: DescribeLiveDomainRealTimeTrafficDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainRealTimeTrafficDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ispNameEn)) {
      query["IspNameEn"] = request.ispNameEn;
    }

    if (!Util.isUnset(request.locationNameEn)) {
      query["LocationNameEn"] = request.locationNameEn;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainRealTimeTrafficData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainRealTimeTrafficDataResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainRealTimeTrafficDataResponse({}));
  }

  async describeLiveDomainRealTimeTrafficData(request: DescribeLiveDomainRealTimeTrafficDataRequest): Promise<DescribeLiveDomainRealTimeTrafficDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainRealTimeTrafficDataWithOptions(request, runtime);
  }

  async describeLiveDomainRealtimeLogDeliveryWithOptions(request: DescribeLiveDomainRealtimeLogDeliveryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainRealtimeLogDeliveryResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainRealtimeLogDelivery",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainRealtimeLogDeliveryResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainRealtimeLogDeliveryResponse({}));
  }

  async describeLiveDomainRealtimeLogDelivery(request: DescribeLiveDomainRealtimeLogDeliveryRequest): Promise<DescribeLiveDomainRealtimeLogDeliveryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainRealtimeLogDeliveryWithOptions(request, runtime);
  }

  async describeLiveDomainRecordDataWithOptions(request: DescribeLiveDomainRecordDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainRecordDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.recordType)) {
      query["RecordType"] = request.recordType;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainRecordData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainRecordDataResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainRecordDataResponse({}));
  }

  async describeLiveDomainRecordData(request: DescribeLiveDomainRecordDataRequest): Promise<DescribeLiveDomainRecordDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainRecordDataWithOptions(request, runtime);
  }

  async describeLiveDomainRecordUsageDataWithOptions(request: DescribeLiveDomainRecordUsageDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainRecordUsageDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.splitBy)) {
      query["SplitBy"] = request.splitBy;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainRecordUsageData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainRecordUsageDataResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainRecordUsageDataResponse({}));
  }

  async describeLiveDomainRecordUsageData(request: DescribeLiveDomainRecordUsageDataRequest): Promise<DescribeLiveDomainRecordUsageDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainRecordUsageDataWithOptions(request, runtime);
  }

  async describeLiveDomainSnapshotDataWithOptions(request: DescribeLiveDomainSnapshotDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainSnapshotDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainSnapshotData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainSnapshotDataResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainSnapshotDataResponse({}));
  }

  async describeLiveDomainSnapshotData(request: DescribeLiveDomainSnapshotDataRequest): Promise<DescribeLiveDomainSnapshotDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainSnapshotDataWithOptions(request, runtime);
  }

  async describeLiveDomainStagingConfigWithOptions(request: DescribeLiveDomainStagingConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainStagingConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.functionNames)) {
      query["FunctionNames"] = request.functionNames;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainStagingConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainStagingConfigResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainStagingConfigResponse({}));
  }

  async describeLiveDomainStagingConfig(request: DescribeLiveDomainStagingConfigRequest): Promise<DescribeLiveDomainStagingConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainStagingConfigWithOptions(request, runtime);
  }

  async describeLiveDomainStreamTranscodeDataWithOptions(request: DescribeLiveDomainStreamTranscodeDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainStreamTranscodeDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.split)) {
      query["Split"] = request.split;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainStreamTranscodeData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainStreamTranscodeDataResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainStreamTranscodeDataResponse({}));
  }

  async describeLiveDomainStreamTranscodeData(request: DescribeLiveDomainStreamTranscodeDataRequest): Promise<DescribeLiveDomainStreamTranscodeDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainStreamTranscodeDataWithOptions(request, runtime);
  }

  async describeLiveDomainTimeShiftDataWithOptions(request: DescribeLiveDomainTimeShiftDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainTimeShiftDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainTimeShiftData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainTimeShiftDataResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainTimeShiftDataResponse({}));
  }

  async describeLiveDomainTimeShiftData(request: DescribeLiveDomainTimeShiftDataRequest): Promise<DescribeLiveDomainTimeShiftDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainTimeShiftDataWithOptions(request, runtime);
  }

  async describeLiveDomainTrafficDataWithOptions(request: DescribeLiveDomainTrafficDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainTrafficDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispNameEn)) {
      query["IspNameEn"] = request.ispNameEn;
    }

    if (!Util.isUnset(request.locationNameEn)) {
      query["LocationNameEn"] = request.locationNameEn;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainTrafficData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainTrafficDataResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainTrafficDataResponse({}));
  }

  async describeLiveDomainTrafficData(request: DescribeLiveDomainTrafficDataRequest): Promise<DescribeLiveDomainTrafficDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainTrafficDataWithOptions(request, runtime);
  }

  async describeLiveDomainTranscodeDataWithOptions(request: DescribeLiveDomainTranscodeDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDomainTranscodeDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDomainTranscodeData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDomainTranscodeDataResponse>(await this.callApi(params, req, runtime), new DescribeLiveDomainTranscodeDataResponse({}));
  }

  async describeLiveDomainTranscodeData(request: DescribeLiveDomainTranscodeDataRequest): Promise<DescribeLiveDomainTranscodeDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDomainTranscodeDataWithOptions(request, runtime);
  }

  async describeLiveDrmUsageDataWithOptions(request: DescribeLiveDrmUsageDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveDrmUsageDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.splitBy)) {
      query["SplitBy"] = request.splitBy;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveDrmUsageData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveDrmUsageDataResponse>(await this.callApi(params, req, runtime), new DescribeLiveDrmUsageDataResponse({}));
  }

  async describeLiveDrmUsageData(request: DescribeLiveDrmUsageDataRequest): Promise<DescribeLiveDrmUsageDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveDrmUsageDataWithOptions(request, runtime);
  }

  async describeLiveEdgeTransferWithOptions(request: DescribeLiveEdgeTransferRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveEdgeTransferResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveEdgeTransfer",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveEdgeTransferResponse>(await this.callApi(params, req, runtime), new DescribeLiveEdgeTransferResponse({}));
  }

  async describeLiveEdgeTransfer(request: DescribeLiveEdgeTransferRequest): Promise<DescribeLiveEdgeTransferResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveEdgeTransferWithOptions(request, runtime);
  }

  async describeLiveLazyPullStreamConfigWithOptions(request: DescribeLiveLazyPullStreamConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveLazyPullStreamConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveLazyPullStreamConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveLazyPullStreamConfigResponse>(await this.callApi(params, req, runtime), new DescribeLiveLazyPullStreamConfigResponse({}));
  }

  async describeLiveLazyPullStreamConfig(request: DescribeLiveLazyPullStreamConfigRequest): Promise<DescribeLiveLazyPullStreamConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveLazyPullStreamConfigWithOptions(request, runtime);
  }

  async describeLiveProducerUsageDataWithOptions(request: DescribeLiveProducerUsageDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveProducerUsageDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instance)) {
      query["Instance"] = request.instance;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.splitBy)) {
      query["SplitBy"] = request.splitBy;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.app)) {
      query["app"] = request.app;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveProducerUsageData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveProducerUsageDataResponse>(await this.callApi(params, req, runtime), new DescribeLiveProducerUsageDataResponse({}));
  }

  async describeLiveProducerUsageData(request: DescribeLiveProducerUsageDataRequest): Promise<DescribeLiveProducerUsageDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveProducerUsageDataWithOptions(request, runtime);
  }

  async describeLivePullStreamConfigWithOptions(request: DescribeLivePullStreamConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLivePullStreamConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLivePullStreamConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLivePullStreamConfigResponse>(await this.callApi(params, req, runtime), new DescribeLivePullStreamConfigResponse({}));
  }

  async describeLivePullStreamConfig(request: DescribeLivePullStreamConfigRequest): Promise<DescribeLivePullStreamConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLivePullStreamConfigWithOptions(request, runtime);
  }

  async describeLiveRealtimeDeliveryAccWithOptions(request: DescribeLiveRealtimeDeliveryAccRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveRealtimeDeliveryAccResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.logStore)) {
      query["LogStore"] = request.logStore;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.project)) {
      query["Project"] = request.project;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveRealtimeDeliveryAcc",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveRealtimeDeliveryAccResponse>(await this.callApi(params, req, runtime), new DescribeLiveRealtimeDeliveryAccResponse({}));
  }

  async describeLiveRealtimeDeliveryAcc(request: DescribeLiveRealtimeDeliveryAccRequest): Promise<DescribeLiveRealtimeDeliveryAccResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveRealtimeDeliveryAccWithOptions(request, runtime);
  }

  async describeLiveRealtimeLogAuthorizedWithOptions(request: DescribeLiveRealtimeLogAuthorizedRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveRealtimeLogAuthorizedResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveRealtimeLogAuthorized",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveRealtimeLogAuthorizedResponse>(await this.callApi(params, req, runtime), new DescribeLiveRealtimeLogAuthorizedResponse({}));
  }

  async describeLiveRealtimeLogAuthorized(request: DescribeLiveRealtimeLogAuthorizedRequest): Promise<DescribeLiveRealtimeLogAuthorizedResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveRealtimeLogAuthorizedWithOptions(request, runtime);
  }

  async describeLiveRecordConfigWithOptions(request: DescribeLiveRecordConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveRecordConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.order)) {
      query["Order"] = request.order;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveRecordConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveRecordConfigResponse>(await this.callApi(params, req, runtime), new DescribeLiveRecordConfigResponse({}));
  }

  async describeLiveRecordConfig(request: DescribeLiveRecordConfigRequest): Promise<DescribeLiveRecordConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveRecordConfigWithOptions(request, runtime);
  }

  async describeLiveRecordNotifyConfigWithOptions(request: DescribeLiveRecordNotifyConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveRecordNotifyConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveRecordNotifyConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveRecordNotifyConfigResponse>(await this.callApi(params, req, runtime), new DescribeLiveRecordNotifyConfigResponse({}));
  }

  async describeLiveRecordNotifyConfig(request: DescribeLiveRecordNotifyConfigRequest): Promise<DescribeLiveRecordNotifyConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveRecordNotifyConfigWithOptions(request, runtime);
  }

  async describeLiveRecordVodConfigsWithOptions(request: DescribeLiveRecordVodConfigsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveRecordVodConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveRecordVodConfigs",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveRecordVodConfigsResponse>(await this.callApi(params, req, runtime), new DescribeLiveRecordVodConfigsResponse({}));
  }

  async describeLiveRecordVodConfigs(request: DescribeLiveRecordVodConfigsRequest): Promise<DescribeLiveRecordVodConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveRecordVodConfigsWithOptions(request, runtime);
  }

  async describeLiveShiftConfigsWithOptions(request: DescribeLiveShiftConfigsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveShiftConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveShiftConfigs",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveShiftConfigsResponse>(await this.callApi(params, req, runtime), new DescribeLiveShiftConfigsResponse({}));
  }

  async describeLiveShiftConfigs(request: DescribeLiveShiftConfigsRequest): Promise<DescribeLiveShiftConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveShiftConfigsWithOptions(request, runtime);
  }

  async describeLiveSnapshotConfigWithOptions(request: DescribeLiveSnapshotConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveSnapshotConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.order)) {
      query["Order"] = request.order;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveSnapshotConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveSnapshotConfigResponse>(await this.callApi(params, req, runtime), new DescribeLiveSnapshotConfigResponse({}));
  }

  async describeLiveSnapshotConfig(request: DescribeLiveSnapshotConfigRequest): Promise<DescribeLiveSnapshotConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveSnapshotConfigWithOptions(request, runtime);
  }

  async describeLiveSnapshotDetectPornConfigWithOptions(request: DescribeLiveSnapshotDetectPornConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveSnapshotDetectPornConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.order)) {
      query["Order"] = request.order;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveSnapshotDetectPornConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveSnapshotDetectPornConfigResponse>(await this.callApi(params, req, runtime), new DescribeLiveSnapshotDetectPornConfigResponse({}));
  }

  async describeLiveSnapshotDetectPornConfig(request: DescribeLiveSnapshotDetectPornConfigRequest): Promise<DescribeLiveSnapshotDetectPornConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveSnapshotDetectPornConfigWithOptions(request, runtime);
  }

  async describeLiveSnapshotNotifyConfigWithOptions(request: DescribeLiveSnapshotNotifyConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveSnapshotNotifyConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveSnapshotNotifyConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveSnapshotNotifyConfigResponse>(await this.callApi(params, req, runtime), new DescribeLiveSnapshotNotifyConfigResponse({}));
  }

  async describeLiveSnapshotNotifyConfig(request: DescribeLiveSnapshotNotifyConfigRequest): Promise<DescribeLiveSnapshotNotifyConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveSnapshotNotifyConfigWithOptions(request, runtime);
  }

  async describeLiveStreamAuthCheckingWithOptions(request: DescribeLiveStreamAuthCheckingRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamAuthCheckingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.url)) {
      query["Url"] = request.url;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamAuthChecking",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamAuthCheckingResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamAuthCheckingResponse({}));
  }

  async describeLiveStreamAuthChecking(request: DescribeLiveStreamAuthCheckingRequest): Promise<DescribeLiveStreamAuthCheckingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamAuthCheckingWithOptions(request, runtime);
  }

  async describeLiveStreamBitRateDataWithOptions(request: DescribeLiveStreamBitRateDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamBitRateDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamBitRateData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamBitRateDataResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamBitRateDataResponse({}));
  }

  async describeLiveStreamBitRateData(request: DescribeLiveStreamBitRateDataRequest): Promise<DescribeLiveStreamBitRateDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamBitRateDataWithOptions(request, runtime);
  }

  async describeLiveStreamCountWithOptions(request: DescribeLiveStreamCountRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamCountResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamCount",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamCountResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamCountResponse({}));
  }

  async describeLiveStreamCount(request: DescribeLiveStreamCountRequest): Promise<DescribeLiveStreamCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamCountWithOptions(request, runtime);
  }

  async describeLiveStreamDelayConfigWithOptions(request: DescribeLiveStreamDelayConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamDelayConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamDelayConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamDelayConfigResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamDelayConfigResponse({}));
  }

  async describeLiveStreamDelayConfig(request: DescribeLiveStreamDelayConfigRequest): Promise<DescribeLiveStreamDelayConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamDelayConfigWithOptions(request, runtime);
  }

  async describeLiveStreamHistoryUserNumWithOptions(request: DescribeLiveStreamHistoryUserNumRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamHistoryUserNumResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamHistoryUserNum",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamHistoryUserNumResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamHistoryUserNumResponse({}));
  }

  async describeLiveStreamHistoryUserNum(request: DescribeLiveStreamHistoryUserNumRequest): Promise<DescribeLiveStreamHistoryUserNumResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamHistoryUserNumWithOptions(request, runtime);
  }

  async describeLiveStreamMetricDetailDataWithOptions(request: DescribeLiveStreamMetricDetailDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamMetricDetailDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.nextPageToken)) {
      query["NextPageToken"] = request.nextPageToken;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.protocol)) {
      query["Protocol"] = request.protocol;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamMetricDetailData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamMetricDetailDataResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamMetricDetailDataResponse({}));
  }

  async describeLiveStreamMetricDetailData(request: DescribeLiveStreamMetricDetailDataRequest): Promise<DescribeLiveStreamMetricDetailDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamMetricDetailDataWithOptions(request, runtime);
  }

  async describeLiveStreamMonitorListWithOptions(request: DescribeLiveStreamMonitorListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamMonitorListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.monitorId)) {
      query["MonitorId"] = request.monitorId;
    }

    if (!Util.isUnset(request.orderRule)) {
      query["OrderRule"] = request.orderRule;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamMonitorList",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamMonitorListResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamMonitorListResponse({}));
  }

  async describeLiveStreamMonitorList(request: DescribeLiveStreamMonitorListRequest): Promise<DescribeLiveStreamMonitorListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamMonitorListWithOptions(request, runtime);
  }

  async describeLiveStreamOptimizedFeatureConfigWithOptions(request: DescribeLiveStreamOptimizedFeatureConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamOptimizedFeatureConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.configName)) {
      query["ConfigName"] = request.configName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamOptimizedFeatureConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamOptimizedFeatureConfigResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamOptimizedFeatureConfigResponse({}));
  }

  async describeLiveStreamOptimizedFeatureConfig(request: DescribeLiveStreamOptimizedFeatureConfigRequest): Promise<DescribeLiveStreamOptimizedFeatureConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamOptimizedFeatureConfigWithOptions(request, runtime);
  }

  async describeLiveStreamRecordContentWithOptions(request: DescribeLiveStreamRecordContentRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamRecordContentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamRecordContent",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamRecordContentResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamRecordContentResponse({}));
  }

  async describeLiveStreamRecordContent(request: DescribeLiveStreamRecordContentRequest): Promise<DescribeLiveStreamRecordContentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamRecordContentWithOptions(request, runtime);
  }

  async describeLiveStreamRecordIndexFileWithOptions(request: DescribeLiveStreamRecordIndexFileRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamRecordIndexFileResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.recordId)) {
      query["RecordId"] = request.recordId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamRecordIndexFile",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamRecordIndexFileResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamRecordIndexFileResponse({}));
  }

  async describeLiveStreamRecordIndexFile(request: DescribeLiveStreamRecordIndexFileRequest): Promise<DescribeLiveStreamRecordIndexFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamRecordIndexFileWithOptions(request, runtime);
  }

  async describeLiveStreamRecordIndexFilesWithOptions(request: DescribeLiveStreamRecordIndexFilesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamRecordIndexFilesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.order)) {
      query["Order"] = request.order;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamRecordIndexFiles",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamRecordIndexFilesResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamRecordIndexFilesResponse({}));
  }

  async describeLiveStreamRecordIndexFiles(request: DescribeLiveStreamRecordIndexFilesRequest): Promise<DescribeLiveStreamRecordIndexFilesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamRecordIndexFilesWithOptions(request, runtime);
  }

  async describeLiveStreamSnapshotInfoWithOptions(request: DescribeLiveStreamSnapshotInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamSnapshotInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.limit)) {
      query["Limit"] = request.limit;
    }

    if (!Util.isUnset(request.order)) {
      query["Order"] = request.order;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamSnapshotInfo",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamSnapshotInfoResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamSnapshotInfoResponse({}));
  }

  async describeLiveStreamSnapshotInfo(request: DescribeLiveStreamSnapshotInfoRequest): Promise<DescribeLiveStreamSnapshotInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamSnapshotInfoWithOptions(request, runtime);
  }

  async describeLiveStreamStateWithOptions(request: DescribeLiveStreamStateRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamStateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamState",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamStateResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamStateResponse({}));
  }

  async describeLiveStreamState(request: DescribeLiveStreamStateRequest): Promise<DescribeLiveStreamStateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamStateWithOptions(request, runtime);
  }

  async describeLiveStreamTranscodeInfoWithOptions(request: DescribeLiveStreamTranscodeInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamTranscodeInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainTranscodeName)) {
      query["DomainTranscodeName"] = request.domainTranscodeName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamTranscodeInfo",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamTranscodeInfoResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamTranscodeInfoResponse({}));
  }

  async describeLiveStreamTranscodeInfo(request: DescribeLiveStreamTranscodeInfoRequest): Promise<DescribeLiveStreamTranscodeInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamTranscodeInfoWithOptions(request, runtime);
  }

  async describeLiveStreamTranscodeStreamNumWithOptions(request: DescribeLiveStreamTranscodeStreamNumRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamTranscodeStreamNumResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamTranscodeStreamNum",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamTranscodeStreamNumResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamTranscodeStreamNumResponse({}));
  }

  async describeLiveStreamTranscodeStreamNum(request: DescribeLiveStreamTranscodeStreamNumRequest): Promise<DescribeLiveStreamTranscodeStreamNumResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamTranscodeStreamNumWithOptions(request, runtime);
  }

  async describeLiveStreamWatermarkRulesWithOptions(request: DescribeLiveStreamWatermarkRulesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamWatermarkRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamWatermarkRules",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamWatermarkRulesResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamWatermarkRulesResponse({}));
  }

  async describeLiveStreamWatermarkRules(request: DescribeLiveStreamWatermarkRulesRequest): Promise<DescribeLiveStreamWatermarkRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamWatermarkRulesWithOptions(request, runtime);
  }

  async describeLiveStreamWatermarksWithOptions(request: DescribeLiveStreamWatermarksRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamWatermarksResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamWatermarks",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamWatermarksResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamWatermarksResponse({}));
  }

  async describeLiveStreamWatermarks(request: DescribeLiveStreamWatermarksRequest): Promise<DescribeLiveStreamWatermarksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamWatermarksWithOptions(request, runtime);
  }

  async describeLiveStreamsBlockListWithOptions(request: DescribeLiveStreamsBlockListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamsBlockListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamsBlockList",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamsBlockListResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamsBlockListResponse({}));
  }

  async describeLiveStreamsBlockList(request: DescribeLiveStreamsBlockListRequest): Promise<DescribeLiveStreamsBlockListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamsBlockListWithOptions(request, runtime);
  }

  async describeLiveStreamsControlHistoryWithOptions(request: DescribeLiveStreamsControlHistoryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamsControlHistoryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamsControlHistory",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamsControlHistoryResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamsControlHistoryResponse({}));
  }

  async describeLiveStreamsControlHistory(request: DescribeLiveStreamsControlHistoryRequest): Promise<DescribeLiveStreamsControlHistoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamsControlHistoryWithOptions(request, runtime);
  }

  async describeLiveStreamsNotifyRecordsWithOptions(request: DescribeLiveStreamsNotifyRecordsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamsNotifyRecordsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamsNotifyRecords",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamsNotifyRecordsResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamsNotifyRecordsResponse({}));
  }

  async describeLiveStreamsNotifyRecords(request: DescribeLiveStreamsNotifyRecordsRequest): Promise<DescribeLiveStreamsNotifyRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamsNotifyRecordsWithOptions(request, runtime);
  }

  async describeLiveStreamsNotifyUrlConfigWithOptions(request: DescribeLiveStreamsNotifyUrlConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamsNotifyUrlConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamsNotifyUrlConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamsNotifyUrlConfigResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamsNotifyUrlConfigResponse({}));
  }

  async describeLiveStreamsNotifyUrlConfig(request: DescribeLiveStreamsNotifyUrlConfigRequest): Promise<DescribeLiveStreamsNotifyUrlConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamsNotifyUrlConfigWithOptions(request, runtime);
  }

  async describeLiveStreamsOnlineListWithOptions(request: DescribeLiveStreamsOnlineListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamsOnlineListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.onlyStream)) {
      query["OnlyStream"] = request.onlyStream;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.queryType)) {
      query["QueryType"] = request.queryType;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    if (!Util.isUnset(request.streamType)) {
      query["StreamType"] = request.streamType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamsOnlineList",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamsOnlineListResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamsOnlineListResponse({}));
  }

  async describeLiveStreamsOnlineList(request: DescribeLiveStreamsOnlineListRequest): Promise<DescribeLiveStreamsOnlineListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamsOnlineListWithOptions(request, runtime);
  }

  async describeLiveStreamsPublishListWithOptions(request: DescribeLiveStreamsPublishListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveStreamsPublishListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.queryType)) {
      query["QueryType"] = request.queryType;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    if (!Util.isUnset(request.streamType)) {
      query["StreamType"] = request.streamType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveStreamsPublishList",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveStreamsPublishListResponse>(await this.callApi(params, req, runtime), new DescribeLiveStreamsPublishListResponse({}));
  }

  async describeLiveStreamsPublishList(request: DescribeLiveStreamsPublishListRequest): Promise<DescribeLiveStreamsPublishListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveStreamsPublishListWithOptions(request, runtime);
  }

  async describeLiveTagResourcesWithOptions(request: DescribeLiveTagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveTagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveTagResources",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveTagResourcesResponse>(await this.callApi(params, req, runtime), new DescribeLiveTagResourcesResponse({}));
  }

  async describeLiveTagResources(request: DescribeLiveTagResourcesRequest): Promise<DescribeLiveTagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveTagResourcesWithOptions(request, runtime);
  }

  async describeLiveTopDomainsByFlowWithOptions(request: DescribeLiveTopDomainsByFlowRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveTopDomainsByFlowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.limit)) {
      query["Limit"] = request.limit;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveTopDomainsByFlow",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveTopDomainsByFlowResponse>(await this.callApi(params, req, runtime), new DescribeLiveTopDomainsByFlowResponse({}));
  }

  async describeLiveTopDomainsByFlow(request: DescribeLiveTopDomainsByFlowRequest): Promise<DescribeLiveTopDomainsByFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveTopDomainsByFlowWithOptions(request, runtime);
  }

  async describeLiveUserBillPredictionWithOptions(request: DescribeLiveUserBillPredictionRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveUserBillPredictionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.area)) {
      query["Area"] = request.area;
    }

    if (!Util.isUnset(request.dimension)) {
      query["Dimension"] = request.dimension;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveUserBillPrediction",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveUserBillPredictionResponse>(await this.callApi(params, req, runtime), new DescribeLiveUserBillPredictionResponse({}));
  }

  async describeLiveUserBillPrediction(request: DescribeLiveUserBillPredictionRequest): Promise<DescribeLiveUserBillPredictionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveUserBillPredictionWithOptions(request, runtime);
  }

  async describeLiveUserDomainsWithOptions(request: DescribeLiveUserDomainsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveUserDomainsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.domainSearchType)) {
      query["DomainSearchType"] = request.domainSearchType;
    }

    if (!Util.isUnset(request.domainStatus)) {
      query["DomainStatus"] = request.domainStatus;
    }

    if (!Util.isUnset(request.liveDomainType)) {
      query["LiveDomainType"] = request.liveDomainType;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionName)) {
      query["RegionName"] = request.regionName;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveUserDomains",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveUserDomainsResponse>(await this.callApi(params, req, runtime), new DescribeLiveUserDomainsResponse({}));
  }

  async describeLiveUserDomains(request: DescribeLiveUserDomainsRequest): Promise<DescribeLiveUserDomainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveUserDomainsWithOptions(request, runtime);
  }

  async describeLiveUserTagsWithOptions(request: DescribeLiveUserTagsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLiveUserTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLiveUserTags",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLiveUserTagsResponse>(await this.callApi(params, req, runtime), new DescribeLiveUserTagsResponse({}));
  }

  async describeLiveUserTags(request: DescribeLiveUserTagsRequest): Promise<DescribeLiveUserTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLiveUserTagsWithOptions(request, runtime);
  }

  async describeMeterLiveRtcDurationWithOptions(request: DescribeMeterLiveRtcDurationRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMeterLiveRtcDurationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.serviceArea)) {
      query["ServiceArea"] = request.serviceArea;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.appId)) {
      query["appId"] = request.appId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMeterLiveRtcDuration",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMeterLiveRtcDurationResponse>(await this.callApi(params, req, runtime), new DescribeMeterLiveRtcDurationResponse({}));
  }

  async describeMeterLiveRtcDuration(request: DescribeMeterLiveRtcDurationRequest): Promise<DescribeMeterLiveRtcDurationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMeterLiveRtcDurationWithOptions(request, runtime);
  }

  async describeMixStreamListWithOptions(request: DescribeMixStreamListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMixStreamListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.mixStreamId)) {
      query["MixStreamId"] = request.mixStreamId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNo)) {
      query["PageNo"] = request.pageNo;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMixStreamList",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMixStreamListResponse>(await this.callApi(params, req, runtime), new DescribeMixStreamListResponse({}));
  }

  async describeMixStreamList(request: DescribeMixStreamListRequest): Promise<DescribeMixStreamListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMixStreamListWithOptions(request, runtime);
  }

  async describeRTSNativeSDKFirstFrameCostWithOptions(tmpReq: DescribeRTSNativeSDKFirstFrameCostRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRTSNativeSDKFirstFrameCostResponse> {
    Util.validateModel(tmpReq);
    let request = new DescribeRTSNativeSDKFirstFrameCostShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.domainNameList)) {
      request.domainNameListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.domainNameList, "DomainNameList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.dataInterval)) {
      query["DataInterval"] = request.dataInterval;
    }

    if (!Util.isUnset(request.domainNameListShrink)) {
      query["DomainNameList"] = request.domainNameListShrink;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRTSNativeSDKFirstFrameCost",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRTSNativeSDKFirstFrameCostResponse>(await this.callApi(params, req, runtime), new DescribeRTSNativeSDKFirstFrameCostResponse({}));
  }

  async describeRTSNativeSDKFirstFrameCost(request: DescribeRTSNativeSDKFirstFrameCostRequest): Promise<DescribeRTSNativeSDKFirstFrameCostResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRTSNativeSDKFirstFrameCostWithOptions(request, runtime);
  }

  async describeRTSNativeSDKFirstFrameDelayWithOptions(tmpReq: DescribeRTSNativeSDKFirstFrameDelayRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRTSNativeSDKFirstFrameDelayResponse> {
    Util.validateModel(tmpReq);
    let request = new DescribeRTSNativeSDKFirstFrameDelayShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.domainNameList)) {
      request.domainNameListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.domainNameList, "DomainNameList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.dataInterval)) {
      query["DataInterval"] = request.dataInterval;
    }

    if (!Util.isUnset(request.domainNameListShrink)) {
      query["DomainNameList"] = request.domainNameListShrink;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRTSNativeSDKFirstFrameDelay",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRTSNativeSDKFirstFrameDelayResponse>(await this.callApi(params, req, runtime), new DescribeRTSNativeSDKFirstFrameDelayResponse({}));
  }

  async describeRTSNativeSDKFirstFrameDelay(request: DescribeRTSNativeSDKFirstFrameDelayRequest): Promise<DescribeRTSNativeSDKFirstFrameDelayResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRTSNativeSDKFirstFrameDelayWithOptions(request, runtime);
  }

  async describeRTSNativeSDKPlayFailStatusWithOptions(tmpReq: DescribeRTSNativeSDKPlayFailStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRTSNativeSDKPlayFailStatusResponse> {
    Util.validateModel(tmpReq);
    let request = new DescribeRTSNativeSDKPlayFailStatusShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.domainNameList)) {
      request.domainNameListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.domainNameList, "DomainNameList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.dataInterval)) {
      query["DataInterval"] = request.dataInterval;
    }

    if (!Util.isUnset(request.domainNameListShrink)) {
      query["DomainNameList"] = request.domainNameListShrink;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRTSNativeSDKPlayFailStatus",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRTSNativeSDKPlayFailStatusResponse>(await this.callApi(params, req, runtime), new DescribeRTSNativeSDKPlayFailStatusResponse({}));
  }

  async describeRTSNativeSDKPlayFailStatus(request: DescribeRTSNativeSDKPlayFailStatusRequest): Promise<DescribeRTSNativeSDKPlayFailStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRTSNativeSDKPlayFailStatusWithOptions(request, runtime);
  }

  async describeRTSNativeSDKPlayTimeWithOptions(tmpReq: DescribeRTSNativeSDKPlayTimeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRTSNativeSDKPlayTimeResponse> {
    Util.validateModel(tmpReq);
    let request = new DescribeRTSNativeSDKPlayTimeShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.domainNameList)) {
      request.domainNameListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.domainNameList, "DomainNameList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.dataInterval)) {
      query["DataInterval"] = request.dataInterval;
    }

    if (!Util.isUnset(request.domainNameListShrink)) {
      query["DomainNameList"] = request.domainNameListShrink;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRTSNativeSDKPlayTime",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRTSNativeSDKPlayTimeResponse>(await this.callApi(params, req, runtime), new DescribeRTSNativeSDKPlayTimeResponse({}));
  }

  async describeRTSNativeSDKPlayTime(request: DescribeRTSNativeSDKPlayTimeRequest): Promise<DescribeRTSNativeSDKPlayTimeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRTSNativeSDKPlayTimeWithOptions(request, runtime);
  }

  async describeRTSNativeSDKVvDataWithOptions(tmpReq: DescribeRTSNativeSDKVvDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRTSNativeSDKVvDataResponse> {
    Util.validateModel(tmpReq);
    let request = new DescribeRTSNativeSDKVvDataShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.domainNameList)) {
      request.domainNameListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.domainNameList, "DomainNameList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.dataInterval)) {
      query["DataInterval"] = request.dataInterval;
    }

    if (!Util.isUnset(request.domainNameListShrink)) {
      query["DomainNameList"] = request.domainNameListShrink;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRTSNativeSDKVvData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRTSNativeSDKVvDataResponse>(await this.callApi(params, req, runtime), new DescribeRTSNativeSDKVvDataResponse({}));
  }

  async describeRTSNativeSDKVvData(request: DescribeRTSNativeSDKVvDataRequest): Promise<DescribeRTSNativeSDKVvDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRTSNativeSDKVvDataWithOptions(request, runtime);
  }

  async describeRoomKickoutUserListWithOptions(request: DescribeRoomKickoutUserListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRoomKickoutUserListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.order)) {
      query["Order"] = request.order;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.roomId)) {
      query["RoomId"] = request.roomId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRoomKickoutUserList",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRoomKickoutUserListResponse>(await this.callApi(params, req, runtime), new DescribeRoomKickoutUserListResponse({}));
  }

  async describeRoomKickoutUserList(request: DescribeRoomKickoutUserListRequest): Promise<DescribeRoomKickoutUserListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRoomKickoutUserListWithOptions(request, runtime);
  }

  async describeRoomListWithOptions(request: DescribeRoomListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRoomListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.anchorId)) {
      query["AnchorId"] = request.anchorId;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.order)) {
      query["Order"] = request.order;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.roomId)) {
      query["RoomId"] = request.roomId;
    }

    if (!Util.isUnset(request.roomStatus)) {
      query["RoomStatus"] = request.roomStatus;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRoomList",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRoomListResponse>(await this.callApi(params, req, runtime), new DescribeRoomListResponse({}));
  }

  async describeRoomList(request: DescribeRoomListRequest): Promise<DescribeRoomListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRoomListWithOptions(request, runtime);
  }

  async describeRoomStatusWithOptions(request: DescribeRoomStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRoomStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.roomId)) {
      query["RoomId"] = request.roomId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRoomStatus",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRoomStatusResponse>(await this.callApi(params, req, runtime), new DescribeRoomStatusResponse({}));
  }

  async describeRoomStatus(request: DescribeRoomStatusRequest): Promise<DescribeRoomStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRoomStatusWithOptions(request, runtime);
  }

  async describeShowListWithOptions(request: DescribeShowListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeShowListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeShowList",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeShowListResponse>(await this.callApi(params, req, runtime), new DescribeShowListResponse({}));
  }

  async describeShowList(request: DescribeShowListRequest): Promise<DescribeShowListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeShowListWithOptions(request, runtime);
  }

  async describeStudioLayoutsWithOptions(request: DescribeStudioLayoutsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeStudioLayoutsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.layoutId)) {
      query["LayoutId"] = request.layoutId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeStudioLayouts",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeStudioLayoutsResponse>(await this.callApi(params, req, runtime), new DescribeStudioLayoutsResponse({}));
  }

  async describeStudioLayouts(request: DescribeStudioLayoutsRequest): Promise<DescribeStudioLayoutsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeStudioLayoutsWithOptions(request, runtime);
  }

  async describeToutiaoLivePlayWithOptions(request: DescribeToutiaoLivePlayRequest, runtime: $Util.RuntimeOptions): Promise<DescribeToutiaoLivePlayResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.app)) {
      query["App"] = request.app;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.stream)) {
      query["Stream"] = request.stream;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeToutiaoLivePlay",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeToutiaoLivePlayResponse>(await this.callApi(params, req, runtime), new DescribeToutiaoLivePlayResponse({}));
  }

  async describeToutiaoLivePlay(request: DescribeToutiaoLivePlayRequest): Promise<DescribeToutiaoLivePlayResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeToutiaoLivePlayWithOptions(request, runtime);
  }

  async describeToutiaoLivePublishWithOptions(request: DescribeToutiaoLivePublishRequest, runtime: $Util.RuntimeOptions): Promise<DescribeToutiaoLivePublishResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.app)) {
      query["App"] = request.app;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.stream)) {
      query["Stream"] = request.stream;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeToutiaoLivePublish",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeToutiaoLivePublishResponse>(await this.callApi(params, req, runtime), new DescribeToutiaoLivePublishResponse({}));
  }

  async describeToutiaoLivePublish(request: DescribeToutiaoLivePublishRequest): Promise<DescribeToutiaoLivePublishResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeToutiaoLivePublishWithOptions(request, runtime);
  }

  async describeUpBpsPeakDataWithOptions(request: DescribeUpBpsPeakDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUpBpsPeakDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.domainSwitch)) {
      query["DomainSwitch"] = request.domainSwitch;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUpBpsPeakData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUpBpsPeakDataResponse>(await this.callApi(params, req, runtime), new DescribeUpBpsPeakDataResponse({}));
  }

  async describeUpBpsPeakData(request: DescribeUpBpsPeakDataRequest): Promise<DescribeUpBpsPeakDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUpBpsPeakDataWithOptions(request, runtime);
  }

  async describeUpBpsPeakOfLineWithOptions(request: DescribeUpBpsPeakOfLineRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUpBpsPeakOfLineResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.domainSwitch)) {
      query["DomainSwitch"] = request.domainSwitch;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.line)) {
      query["Line"] = request.line;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUpBpsPeakOfLine",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUpBpsPeakOfLineResponse>(await this.callApi(params, req, runtime), new DescribeUpBpsPeakOfLineResponse({}));
  }

  async describeUpBpsPeakOfLine(request: DescribeUpBpsPeakOfLineRequest): Promise<DescribeUpBpsPeakOfLineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUpBpsPeakOfLineWithOptions(request, runtime);
  }

  async describeUpPeakPublishStreamDataWithOptions(request: DescribeUpPeakPublishStreamDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUpPeakPublishStreamDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.domainSwitch)) {
      query["DomainSwitch"] = request.domainSwitch;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUpPeakPublishStreamData",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUpPeakPublishStreamDataResponse>(await this.callApi(params, req, runtime), new DescribeUpPeakPublishStreamDataResponse({}));
  }

  async describeUpPeakPublishStreamData(request: DescribeUpPeakPublishStreamDataRequest): Promise<DescribeUpPeakPublishStreamDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUpPeakPublishStreamDataWithOptions(request, runtime);
  }

  async disableLiveRealtimeLogDeliveryWithOptions(request: DisableLiveRealtimeLogDeliveryRequest, runtime: $Util.RuntimeOptions): Promise<DisableLiveRealtimeLogDeliveryResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableLiveRealtimeLogDelivery",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableLiveRealtimeLogDeliveryResponse>(await this.callApi(params, req, runtime), new DisableLiveRealtimeLogDeliveryResponse({}));
  }

  async disableLiveRealtimeLogDelivery(request: DisableLiveRealtimeLogDeliveryRequest): Promise<DisableLiveRealtimeLogDeliveryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableLiveRealtimeLogDeliveryWithOptions(request, runtime);
  }

  async dynamicUpdateWaterMarkStreamRuleWithOptions(request: DynamicUpdateWaterMarkStreamRuleRequest, runtime: $Util.RuntimeOptions): Promise<DynamicUpdateWaterMarkStreamRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.app)) {
      query["App"] = request.app;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.stream)) {
      query["Stream"] = request.stream;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DynamicUpdateWaterMarkStreamRule",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DynamicUpdateWaterMarkStreamRuleResponse>(await this.callApi(params, req, runtime), new DynamicUpdateWaterMarkStreamRuleResponse({}));
  }

  async dynamicUpdateWaterMarkStreamRule(request: DynamicUpdateWaterMarkStreamRuleRequest): Promise<DynamicUpdateWaterMarkStreamRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dynamicUpdateWaterMarkStreamRuleWithOptions(request, runtime);
  }

  async editPlaylistWithOptions(request: EditPlaylistRequest, runtime: $Util.RuntimeOptions): Promise<EditPlaylistResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.programConfig)) {
      query["ProgramConfig"] = request.programConfig;
    }

    if (!Util.isUnset(request.programId)) {
      query["ProgramId"] = request.programId;
    }

    if (!Util.isUnset(request.programItems)) {
      query["ProgramItems"] = request.programItems;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EditPlaylist",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EditPlaylistResponse>(await this.callApi(params, req, runtime), new EditPlaylistResponse({}));
  }

  async editPlaylist(request: EditPlaylistRequest): Promise<EditPlaylistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.editPlaylistWithOptions(request, runtime);
  }

  async editShowAndReplaceWithOptions(request: EditShowAndReplaceRequest, runtime: $Util.RuntimeOptions): Promise<EditShowAndReplaceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.showId)) {
      query["ShowId"] = request.showId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.storageInfo)) {
      query["StorageInfo"] = request.storageInfo;
    }

    if (!Util.isUnset(request.userData)) {
      query["UserData"] = request.userData;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EditShowAndReplace",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EditShowAndReplaceResponse>(await this.callApi(params, req, runtime), new EditShowAndReplaceResponse({}));
  }

  async editShowAndReplace(request: EditShowAndReplaceRequest): Promise<EditShowAndReplaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.editShowAndReplaceWithOptions(request, runtime);
  }

  async effectCasterUrgentWithOptions(request: EffectCasterUrgentRequest, runtime: $Util.RuntimeOptions): Promise<EffectCasterUrgentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.sceneId)) {
      query["SceneId"] = request.sceneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EffectCasterUrgent",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EffectCasterUrgentResponse>(await this.callApi(params, req, runtime), new EffectCasterUrgentResponse({}));
  }

  async effectCasterUrgent(request: EffectCasterUrgentRequest): Promise<EffectCasterUrgentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.effectCasterUrgentWithOptions(request, runtime);
  }

  async effectCasterVideoResourceWithOptions(request: EffectCasterVideoResourceRequest, runtime: $Util.RuntimeOptions): Promise<EffectCasterVideoResourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.sceneId)) {
      query["SceneId"] = request.sceneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EffectCasterVideoResource",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EffectCasterVideoResourceResponse>(await this.callApi(params, req, runtime), new EffectCasterVideoResourceResponse({}));
  }

  async effectCasterVideoResource(request: EffectCasterVideoResourceRequest): Promise<EffectCasterVideoResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.effectCasterVideoResourceWithOptions(request, runtime);
  }

  async enableLiveRealtimeLogDeliveryWithOptions(request: EnableLiveRealtimeLogDeliveryRequest, runtime: $Util.RuntimeOptions): Promise<EnableLiveRealtimeLogDeliveryResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableLiveRealtimeLogDelivery",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableLiveRealtimeLogDeliveryResponse>(await this.callApi(params, req, runtime), new EnableLiveRealtimeLogDeliveryResponse({}));
  }

  async enableLiveRealtimeLogDelivery(request: EnableLiveRealtimeLogDeliveryRequest): Promise<EnableLiveRealtimeLogDeliveryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableLiveRealtimeLogDeliveryWithOptions(request, runtime);
  }

  async forbidLiveStreamWithOptions(request: ForbidLiveStreamRequest, runtime: $Util.RuntimeOptions): Promise<ForbidLiveStreamResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.liveStreamType)) {
      query["LiveStreamType"] = request.liveStreamType;
    }

    if (!Util.isUnset(request.oneshot)) {
      query["Oneshot"] = request.oneshot;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.resumeTime)) {
      query["ResumeTime"] = request.resumeTime;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ForbidLiveStream",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ForbidLiveStreamResponse>(await this.callApi(params, req, runtime), new ForbidLiveStreamResponse({}));
  }

  async forbidLiveStream(request: ForbidLiveStreamRequest): Promise<ForbidLiveStreamResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.forbidLiveStreamWithOptions(request, runtime);
  }

  async forbidPushStreamWithOptions(request: ForbidPushStreamRequest, runtime: $Util.RuntimeOptions): Promise<ForbidPushStreamResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.roomId)) {
      query["RoomId"] = request.roomId;
    }

    if (!Util.isUnset(request.userData)) {
      query["UserData"] = request.userData;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ForbidPushStream",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ForbidPushStreamResponse>(await this.callApi(params, req, runtime), new ForbidPushStreamResponse({}));
  }

  async forbidPushStream(request: ForbidPushStreamRequest): Promise<ForbidPushStreamResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.forbidPushStreamWithOptions(request, runtime);
  }

  async getAllCustomTemplatesWithOptions(request: GetAllCustomTemplatesRequest, runtime: $Util.RuntimeOptions): Promise<GetAllCustomTemplatesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.userId)) {
      query["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetAllCustomTemplates",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetAllCustomTemplatesResponse>(await this.callApi(params, req, runtime), new GetAllCustomTemplatesResponse({}));
  }

  async getAllCustomTemplates(request: GetAllCustomTemplatesRequest): Promise<GetAllCustomTemplatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAllCustomTemplatesWithOptions(request, runtime);
  }

  async getCustomTemplateWithOptions(request: GetCustomTemplateRequest, runtime: $Util.RuntimeOptions): Promise<GetCustomTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.template)) {
      query["Template"] = request.template;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetCustomTemplate",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetCustomTemplateResponse>(await this.callApi(params, req, runtime), new GetCustomTemplateResponse({}));
  }

  async getCustomTemplate(request: GetCustomTemplateRequest): Promise<GetCustomTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getCustomTemplateWithOptions(request, runtime);
  }

  async getEditingJobInfoWithOptions(request: GetEditingJobInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetEditingJobInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.showId)) {
      query["ShowId"] = request.showId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetEditingJobInfo",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetEditingJobInfoResponse>(await this.callApi(params, req, runtime), new GetEditingJobInfoResponse({}));
  }

  async getEditingJobInfo(request: GetEditingJobInfoRequest): Promise<GetEditingJobInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getEditingJobInfoWithOptions(request, runtime);
  }

  async getMessageAppWithOptions(request: GetMessageAppRequest, runtime: $Util.RuntimeOptions): Promise<GetMessageAppResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetMessageApp",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMessageAppResponse>(await this.callApi(params, req, runtime), new GetMessageAppResponse({}));
  }

  async getMessageApp(request: GetMessageAppRequest): Promise<GetMessageAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMessageAppWithOptions(request, runtime);
  }

  async getMessageGroupWithOptions(request: GetMessageGroupRequest, runtime: $Util.RuntimeOptions): Promise<GetMessageGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.groupId)) {
      body["GroupId"] = request.groupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetMessageGroup",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMessageGroupResponse>(await this.callApi(params, req, runtime), new GetMessageGroupResponse({}));
  }

  async getMessageGroup(request: GetMessageGroupRequest): Promise<GetMessageGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMessageGroupWithOptions(request, runtime);
  }

  async getMessageTokenWithOptions(request: GetMessageTokenRequest, runtime: $Util.RuntimeOptions): Promise<GetMessageTokenResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.deviceId)) {
      body["DeviceId"] = request.deviceId;
    }

    if (!Util.isUnset(request.deviceType)) {
      body["DeviceType"] = request.deviceType;
    }

    if (!Util.isUnset(request.userId)) {
      body["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetMessageToken",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMessageTokenResponse>(await this.callApi(params, req, runtime), new GetMessageTokenResponse({}));
  }

  async getMessageToken(request: GetMessageTokenRequest): Promise<GetMessageTokenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMessageTokenWithOptions(request, runtime);
  }

  async getMultiRateConfigWithOptions(request: GetMultiRateConfigRequest, runtime: $Util.RuntimeOptions): Promise<GetMultiRateConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.app)) {
      query["App"] = request.app;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMultiRateConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMultiRateConfigResponse>(await this.callApi(params, req, runtime), new GetMultiRateConfigResponse({}));
  }

  async getMultiRateConfig(request: GetMultiRateConfigRequest): Promise<GetMultiRateConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMultiRateConfigWithOptions(request, runtime);
  }

  async getMultiRateConfigListWithOptions(request: GetMultiRateConfigListRequest, runtime: $Util.RuntimeOptions): Promise<GetMultiRateConfigListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMultiRateConfigList",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMultiRateConfigListResponse>(await this.callApi(params, req, runtime), new GetMultiRateConfigListResponse({}));
  }

  async getMultiRateConfigList(request: GetMultiRateConfigListRequest): Promise<GetMultiRateConfigListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMultiRateConfigListWithOptions(request, runtime);
  }

  async hotLiveRtcStreamWithOptions(request: HotLiveRtcStreamRequest, runtime: $Util.RuntimeOptions): Promise<HotLiveRtcStreamResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.audioMsid)) {
      query["AudioMsid"] = request.audioMsid;
    }

    if (!Util.isUnset(request.connectionTimeout)) {
      query["ConnectionTimeout"] = request.connectionTimeout;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.mediaTimeout)) {
      query["MediaTimeout"] = request.mediaTimeout;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.regionCode)) {
      query["RegionCode"] = request.regionCode;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    if (!Util.isUnset(request.videoMsid)) {
      query["VideoMsid"] = request.videoMsid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "HotLiveRtcStream",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<HotLiveRtcStreamResponse>(await this.callApi(params, req, runtime), new HotLiveRtcStreamResponse({}));
  }

  async hotLiveRtcStream(request: HotLiveRtcStreamRequest): Promise<HotLiveRtcStreamResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.hotLiveRtcStreamWithOptions(request, runtime);
  }

  async initializeAutoShowListTaskWithOptions(request: InitializeAutoShowListTaskRequest, runtime: $Util.RuntimeOptions): Promise<InitializeAutoShowListTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.callBackUrl)) {
      query["CallBackUrl"] = request.callBackUrl;
    }

    if (!Util.isUnset(request.casterConfig)) {
      query["CasterConfig"] = request.casterConfig;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.resourceIds)) {
      query["ResourceIds"] = request.resourceIds;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "InitializeAutoShowListTask",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InitializeAutoShowListTaskResponse>(await this.callApi(params, req, runtime), new InitializeAutoShowListTaskResponse({}));
  }

  async initializeAutoShowListTask(request: InitializeAutoShowListTaskRequest): Promise<InitializeAutoShowListTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.initializeAutoShowListTaskWithOptions(request, runtime);
  }

  async joinMessageGroupWithOptions(request: JoinMessageGroupRequest, runtime: $Util.RuntimeOptions): Promise<JoinMessageGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.broadCastStatistics)) {
      body["BroadCastStatistics"] = request.broadCastStatistics;
    }

    if (!Util.isUnset(request.broadCastType)) {
      body["BroadCastType"] = request.broadCastType;
    }

    if (!Util.isUnset(request.groupId)) {
      body["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.userId)) {
      body["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "JoinMessageGroup",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<JoinMessageGroupResponse>(await this.callApi(params, req, runtime), new JoinMessageGroupResponse({}));
  }

  async joinMessageGroup(request: JoinMessageGroupRequest): Promise<JoinMessageGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.joinMessageGroupWithOptions(request, runtime);
  }

  async leaveMessageGroupWithOptions(request: LeaveMessageGroupRequest, runtime: $Util.RuntimeOptions): Promise<LeaveMessageGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.broadCastStatistics)) {
      body["BroadCastStatistics"] = request.broadCastStatistics;
    }

    if (!Util.isUnset(request.broadCastType)) {
      body["BroadCastType"] = request.broadCastType;
    }

    if (!Util.isUnset(request.groupId)) {
      body["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.userId)) {
      body["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "LeaveMessageGroup",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<LeaveMessageGroupResponse>(await this.callApi(params, req, runtime), new LeaveMessageGroupResponse({}));
  }

  async leaveMessageGroup(request: LeaveMessageGroupRequest): Promise<LeaveMessageGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.leaveMessageGroupWithOptions(request, runtime);
  }

  async listLiveRealtimeLogDeliveryWithOptions(request: ListLiveRealtimeLogDeliveryRequest, runtime: $Util.RuntimeOptions): Promise<ListLiveRealtimeLogDeliveryResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListLiveRealtimeLogDelivery",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListLiveRealtimeLogDeliveryResponse>(await this.callApi(params, req, runtime), new ListLiveRealtimeLogDeliveryResponse({}));
  }

  async listLiveRealtimeLogDelivery(request: ListLiveRealtimeLogDeliveryRequest): Promise<ListLiveRealtimeLogDeliveryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listLiveRealtimeLogDeliveryWithOptions(request, runtime);
  }

  async listLiveRealtimeLogDeliveryDomainsWithOptions(request: ListLiveRealtimeLogDeliveryDomainsRequest, runtime: $Util.RuntimeOptions): Promise<ListLiveRealtimeLogDeliveryDomainsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListLiveRealtimeLogDeliveryDomains",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListLiveRealtimeLogDeliveryDomainsResponse>(await this.callApi(params, req, runtime), new ListLiveRealtimeLogDeliveryDomainsResponse({}));
  }

  async listLiveRealtimeLogDeliveryDomains(request: ListLiveRealtimeLogDeliveryDomainsRequest): Promise<ListLiveRealtimeLogDeliveryDomainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listLiveRealtimeLogDeliveryDomainsWithOptions(request, runtime);
  }

  async listLiveRealtimeLogDeliveryInfosWithOptions(request: ListLiveRealtimeLogDeliveryInfosRequest, runtime: $Util.RuntimeOptions): Promise<ListLiveRealtimeLogDeliveryInfosResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListLiveRealtimeLogDeliveryInfos",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListLiveRealtimeLogDeliveryInfosResponse>(await this.callApi(params, req, runtime), new ListLiveRealtimeLogDeliveryInfosResponse({}));
  }

  async listLiveRealtimeLogDeliveryInfos(request: ListLiveRealtimeLogDeliveryInfosRequest): Promise<ListLiveRealtimeLogDeliveryInfosResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listLiveRealtimeLogDeliveryInfosWithOptions(request, runtime);
  }

  async listMessageWithOptions(request: ListMessageRequest, runtime: $Util.RuntimeOptions): Promise<ListMessageResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.groupId)) {
      body["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.pageNum)) {
      body["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.sortType)) {
      body["SortType"] = request.sortType;
    }

    if (!Util.isUnset(request.type)) {
      body["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListMessage",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListMessageResponse>(await this.callApi(params, req, runtime), new ListMessageResponse({}));
  }

  async listMessage(request: ListMessageRequest): Promise<ListMessageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listMessageWithOptions(request, runtime);
  }

  async listMessageAppWithOptions(request: ListMessageAppRequest, runtime: $Util.RuntimeOptions): Promise<ListMessageAppResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.pageNum)) {
      body["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.sortType)) {
      body["SortType"] = request.sortType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListMessageApp",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListMessageAppResponse>(await this.callApi(params, req, runtime), new ListMessageAppResponse({}));
  }

  async listMessageApp(request: ListMessageAppRequest): Promise<ListMessageAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listMessageAppWithOptions(request, runtime);
  }

  async listMessageGroupWithOptions(request: ListMessageGroupRequest, runtime: $Util.RuntimeOptions): Promise<ListMessageGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.pageNum)) {
      body["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.sortType)) {
      body["SortType"] = request.sortType;
    }

    if (!Util.isUnset(request.userId)) {
      body["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListMessageGroup",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListMessageGroupResponse>(await this.callApi(params, req, runtime), new ListMessageGroupResponse({}));
  }

  async listMessageGroup(request: ListMessageGroupRequest): Promise<ListMessageGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listMessageGroupWithOptions(request, runtime);
  }

  async listMessageGroupUserWithOptions(request: ListMessageGroupUserRequest, runtime: $Util.RuntimeOptions): Promise<ListMessageGroupUserResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.groupId)) {
      body["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.pageNum)) {
      body["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.sortType)) {
      body["SortType"] = request.sortType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListMessageGroupUser",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListMessageGroupUserResponse>(await this.callApi(params, req, runtime), new ListMessageGroupUserResponse({}));
  }

  async listMessageGroupUser(request: ListMessageGroupUserRequest): Promise<ListMessageGroupUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listMessageGroupUserWithOptions(request, runtime);
  }

  async listMessageGroupUserByIdWithOptions(tmpReq: ListMessageGroupUserByIdRequest, runtime: $Util.RuntimeOptions): Promise<ListMessageGroupUserByIdResponse> {
    Util.validateModel(tmpReq);
    let request = new ListMessageGroupUserByIdShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.userIdList)) {
      request.userIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userIdList, "UserIdList", "simple");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.groupId)) {
      body["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.userIdListShrink)) {
      body["UserIdList"] = request.userIdListShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListMessageGroupUserById",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListMessageGroupUserByIdResponse>(await this.callApi(params, req, runtime), new ListMessageGroupUserByIdResponse({}));
  }

  async listMessageGroupUserById(request: ListMessageGroupUserByIdRequest): Promise<ListMessageGroupUserByIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listMessageGroupUserByIdWithOptions(request, runtime);
  }

  async listPlaylistWithOptions(request: ListPlaylistRequest, runtime: $Util.RuntimeOptions): Promise<ListPlaylistResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.page)) {
      query["Page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.programId)) {
      query["ProgramId"] = request.programId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPlaylist",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListPlaylistResponse>(await this.callApi(params, req, runtime), new ListPlaylistResponse({}));
  }

  async listPlaylist(request: ListPlaylistRequest): Promise<ListPlaylistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listPlaylistWithOptions(request, runtime);
  }

  async listPlaylistItemsWithOptions(request: ListPlaylistItemsRequest, runtime: $Util.RuntimeOptions): Promise<ListPlaylistItemsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.programId)) {
      query["ProgramId"] = request.programId;
    }

    if (!Util.isUnset(request.programItemIds)) {
      query["ProgramItemIds"] = request.programItemIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPlaylistItems",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListPlaylistItemsResponse>(await this.callApi(params, req, runtime), new ListPlaylistItemsResponse({}));
  }

  async listPlaylistItems(request: ListPlaylistItemsRequest): Promise<ListPlaylistItemsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listPlaylistItemsWithOptions(request, runtime);
  }

  async modifyCasterComponentWithOptions(request: ModifyCasterComponentRequest, runtime: $Util.RuntimeOptions): Promise<ModifyCasterComponentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.captionLayerContent)) {
      query["CaptionLayerContent"] = request.captionLayerContent;
    }

    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.componentId)) {
      query["ComponentId"] = request.componentId;
    }

    if (!Util.isUnset(request.componentLayer)) {
      query["ComponentLayer"] = request.componentLayer;
    }

    if (!Util.isUnset(request.componentName)) {
      query["ComponentName"] = request.componentName;
    }

    if (!Util.isUnset(request.componentType)) {
      query["ComponentType"] = request.componentType;
    }

    if (!Util.isUnset(request.effect)) {
      query["Effect"] = request.effect;
    }

    if (!Util.isUnset(request.imageLayerContent)) {
      query["ImageLayerContent"] = request.imageLayerContent;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.textLayerContent)) {
      query["TextLayerContent"] = request.textLayerContent;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyCasterComponent",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyCasterComponentResponse>(await this.callApi(params, req, runtime), new ModifyCasterComponentResponse({}));
  }

  async modifyCasterComponent(request: ModifyCasterComponentRequest): Promise<ModifyCasterComponentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyCasterComponentWithOptions(request, runtime);
  }

  async modifyCasterEpisodeWithOptions(request: ModifyCasterEpisodeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyCasterEpisodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.componentId)) {
      query["ComponentId"] = request.componentId;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.episodeId)) {
      query["EpisodeId"] = request.episodeId;
    }

    if (!Util.isUnset(request.episodeName)) {
      query["EpisodeName"] = request.episodeName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.switchType)) {
      query["SwitchType"] = request.switchType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyCasterEpisode",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyCasterEpisodeResponse>(await this.callApi(params, req, runtime), new ModifyCasterEpisodeResponse({}));
  }

  async modifyCasterEpisode(request: ModifyCasterEpisodeRequest): Promise<ModifyCasterEpisodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyCasterEpisodeWithOptions(request, runtime);
  }

  async modifyCasterLayoutWithOptions(request: ModifyCasterLayoutRequest, runtime: $Util.RuntimeOptions): Promise<ModifyCasterLayoutResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.audioLayer)) {
      query["AudioLayer"] = request.audioLayer;
    }

    if (!Util.isUnset(request.blendList)) {
      query["BlendList"] = request.blendList;
    }

    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.layoutId)) {
      query["LayoutId"] = request.layoutId;
    }

    if (!Util.isUnset(request.mixList)) {
      query["MixList"] = request.mixList;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.videoLayer)) {
      query["VideoLayer"] = request.videoLayer;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyCasterLayout",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyCasterLayoutResponse>(await this.callApi(params, req, runtime), new ModifyCasterLayoutResponse({}));
  }

  async modifyCasterLayout(request: ModifyCasterLayoutRequest): Promise<ModifyCasterLayoutResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyCasterLayoutWithOptions(request, runtime);
  }

  async modifyCasterProgramWithOptions(request: ModifyCasterProgramRequest, runtime: $Util.RuntimeOptions): Promise<ModifyCasterProgramResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.episode)) {
      query["Episode"] = request.episode;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyCasterProgram",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyCasterProgramResponse>(await this.callApi(params, req, runtime), new ModifyCasterProgramResponse({}));
  }

  async modifyCasterProgram(request: ModifyCasterProgramRequest): Promise<ModifyCasterProgramResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyCasterProgramWithOptions(request, runtime);
  }

  async modifyCasterVideoResourceWithOptions(request: ModifyCasterVideoResourceRequest, runtime: $Util.RuntimeOptions): Promise<ModifyCasterVideoResourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.beginOffset)) {
      query["BeginOffset"] = request.beginOffset;
    }

    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.endOffset)) {
      query["EndOffset"] = request.endOffset;
    }

    if (!Util.isUnset(request.liveStreamUrl)) {
      query["LiveStreamUrl"] = request.liveStreamUrl;
    }

    if (!Util.isUnset(request.materialId)) {
      query["MaterialId"] = request.materialId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.ptsCallbackInterval)) {
      query["PtsCallbackInterval"] = request.ptsCallbackInterval;
    }

    if (!Util.isUnset(request.repeatNum)) {
      query["RepeatNum"] = request.repeatNum;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceName)) {
      query["ResourceName"] = request.resourceName;
    }

    if (!Util.isUnset(request.vodUrl)) {
      query["VodUrl"] = request.vodUrl;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyCasterVideoResource",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyCasterVideoResourceResponse>(await this.callApi(params, req, runtime), new ModifyCasterVideoResourceResponse({}));
  }

  async modifyCasterVideoResource(request: ModifyCasterVideoResourceRequest): Promise<ModifyCasterVideoResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyCasterVideoResourceWithOptions(request, runtime);
  }

  async modifyLiveDomainSchdmByPropertyWithOptions(request: ModifyLiveDomainSchdmByPropertyRequest, runtime: $Util.RuntimeOptions): Promise<ModifyLiveDomainSchdmByPropertyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.property)) {
      query["Property"] = request.property;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyLiveDomainSchdmByProperty",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyLiveDomainSchdmByPropertyResponse>(await this.callApi(params, req, runtime), new ModifyLiveDomainSchdmByPropertyResponse({}));
  }

  async modifyLiveDomainSchdmByProperty(request: ModifyLiveDomainSchdmByPropertyRequest): Promise<ModifyLiveDomainSchdmByPropertyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyLiveDomainSchdmByPropertyWithOptions(request, runtime);
  }

  async modifyLiveRealtimeLogDeliveryWithOptions(request: ModifyLiveRealtimeLogDeliveryRequest, runtime: $Util.RuntimeOptions): Promise<ModifyLiveRealtimeLogDeliveryResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyLiveRealtimeLogDelivery",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyLiveRealtimeLogDeliveryResponse>(await this.callApi(params, req, runtime), new ModifyLiveRealtimeLogDeliveryResponse({}));
  }

  async modifyLiveRealtimeLogDelivery(request: ModifyLiveRealtimeLogDeliveryRequest): Promise<ModifyLiveRealtimeLogDeliveryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyLiveRealtimeLogDeliveryWithOptions(request, runtime);
  }

  async modifyShowListWithOptions(request: ModifyShowListRequest, runtime: $Util.RuntimeOptions): Promise<ModifyShowListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.highPriorityShowId)) {
      query["HighPriorityShowId"] = request.highPriorityShowId;
    }

    if (!Util.isUnset(request.highPriorityShowStartTime)) {
      query["HighPriorityShowStartTime"] = request.highPriorityShowStartTime;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.repeatTimes)) {
      query["RepeatTimes"] = request.repeatTimes;
    }

    if (!Util.isUnset(request.showId)) {
      query["ShowId"] = request.showId;
    }

    if (!Util.isUnset(request.spot)) {
      query["Spot"] = request.spot;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyShowList",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyShowListResponse>(await this.callApi(params, req, runtime), new ModifyShowListResponse({}));
  }

  async modifyShowList(request: ModifyShowListRequest): Promise<ModifyShowListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyShowListWithOptions(request, runtime);
  }

  async modifyStudioLayoutWithOptions(request: ModifyStudioLayoutRequest, runtime: $Util.RuntimeOptions): Promise<ModifyStudioLayoutResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bgImageConfig)) {
      query["BgImageConfig"] = request.bgImageConfig;
    }

    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.commonConfig)) {
      query["CommonConfig"] = request.commonConfig;
    }

    if (!Util.isUnset(request.layerOrderConfigList)) {
      query["LayerOrderConfigList"] = request.layerOrderConfigList;
    }

    if (!Util.isUnset(request.layoutId)) {
      query["LayoutId"] = request.layoutId;
    }

    if (!Util.isUnset(request.layoutName)) {
      query["LayoutName"] = request.layoutName;
    }

    if (!Util.isUnset(request.mediaInputConfigList)) {
      query["MediaInputConfigList"] = request.mediaInputConfigList;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.screenInputConfigList)) {
      query["ScreenInputConfigList"] = request.screenInputConfigList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyStudioLayout",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyStudioLayoutResponse>(await this.callApi(params, req, runtime), new ModifyStudioLayoutResponse({}));
  }

  async modifyStudioLayout(request: ModifyStudioLayoutRequest): Promise<ModifyStudioLayoutResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyStudioLayoutWithOptions(request, runtime);
  }

  async openLiveShiftWithOptions(request: OpenLiveShiftRequest, runtime: $Util.RuntimeOptions): Promise<OpenLiveShiftResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.duration)) {
      query["Duration"] = request.duration;
    }

    if (!Util.isUnset(request.ignoreTranscode)) {
      query["IgnoreTranscode"] = request.ignoreTranscode;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    if (!Util.isUnset(request.vision)) {
      query["Vision"] = request.vision;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OpenLiveShift",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OpenLiveShiftResponse>(await this.callApi(params, req, runtime), new OpenLiveShiftResponse({}));
  }

  async openLiveShift(request: OpenLiveShiftRequest): Promise<OpenLiveShiftResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.openLiveShiftWithOptions(request, runtime);
  }

  async playChoosenShowWithOptions(request: PlayChoosenShowRequest, runtime: $Util.RuntimeOptions): Promise<PlayChoosenShowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.showId)) {
      query["ShowId"] = request.showId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PlayChoosenShow",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PlayChoosenShowResponse>(await this.callApi(params, req, runtime), new PlayChoosenShowResponse({}));
  }

  async playChoosenShow(request: PlayChoosenShowRequest): Promise<PlayChoosenShowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.playChoosenShowWithOptions(request, runtime);
  }

  async publishLiveStagingConfigToProductionWithOptions(request: PublishLiveStagingConfigToProductionRequest, runtime: $Util.RuntimeOptions): Promise<PublishLiveStagingConfigToProductionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.functionName)) {
      query["FunctionName"] = request.functionName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PublishLiveStagingConfigToProduction",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PublishLiveStagingConfigToProductionResponse>(await this.callApi(params, req, runtime), new PublishLiveStagingConfigToProductionResponse({}));
  }

  async publishLiveStagingConfigToProduction(request: PublishLiveStagingConfigToProductionRequest): Promise<PublishLiveStagingConfigToProductionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.publishLiveStagingConfigToProductionWithOptions(request, runtime);
  }

  async queryMessageAppWithOptions(request: QueryMessageAppRequest, runtime: $Util.RuntimeOptions): Promise<QueryMessageAppResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      body["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.pageNum)) {
      body["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.sortType)) {
      body["SortType"] = request.sortType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryMessageApp",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryMessageAppResponse>(await this.callApi(params, req, runtime), new QueryMessageAppResponse({}));
  }

  async queryMessageApp(request: QueryMessageAppRequest): Promise<QueryMessageAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryMessageAppWithOptions(request, runtime);
  }

  async querySnapshotCallbackAuthWithOptions(request: QuerySnapshotCallbackAuthRequest, runtime: $Util.RuntimeOptions): Promise<QuerySnapshotCallbackAuthResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QuerySnapshotCallbackAuth",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySnapshotCallbackAuthResponse>(await this.callApi(params, req, runtime), new QuerySnapshotCallbackAuthResponse({}));
  }

  async querySnapshotCallbackAuth(request: QuerySnapshotCallbackAuthRequest): Promise<QuerySnapshotCallbackAuthResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySnapshotCallbackAuthWithOptions(request, runtime);
  }

  async realTimeRecordCommandWithOptions(request: RealTimeRecordCommandRequest, runtime: $Util.RuntimeOptions): Promise<RealTimeRecordCommandResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.command)) {
      query["Command"] = request.command;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RealTimeRecordCommand",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RealTimeRecordCommandResponse>(await this.callApi(params, req, runtime), new RealTimeRecordCommandResponse({}));
  }

  async realTimeRecordCommand(request: RealTimeRecordCommandRequest): Promise<RealTimeRecordCommandResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.realTimeRecordCommandWithOptions(request, runtime);
  }

  async realTimeSnapshotCommandWithOptions(request: RealTimeSnapshotCommandRequest, runtime: $Util.RuntimeOptions): Promise<RealTimeSnapshotCommandResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.command)) {
      query["Command"] = request.command;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.mode)) {
      query["Mode"] = request.mode;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RealTimeSnapshotCommand",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RealTimeSnapshotCommandResponse>(await this.callApi(params, req, runtime), new RealTimeSnapshotCommandResponse({}));
  }

  async realTimeSnapshotCommand(request: RealTimeSnapshotCommandRequest): Promise<RealTimeSnapshotCommandResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.realTimeSnapshotCommandWithOptions(request, runtime);
  }

  async removeShowFromShowListWithOptions(request: RemoveShowFromShowListRequest, runtime: $Util.RuntimeOptions): Promise<RemoveShowFromShowListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.showId)) {
      query["ShowId"] = request.showId;
    }

    if (!Util.isUnset(request.isBatchMode)) {
      query["isBatchMode"] = request.isBatchMode;
    }

    if (!Util.isUnset(request.showIdList)) {
      query["showIdList"] = request.showIdList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveShowFromShowList",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveShowFromShowListResponse>(await this.callApi(params, req, runtime), new RemoveShowFromShowListResponse({}));
  }

  async removeShowFromShowList(request: RemoveShowFromShowListRequest): Promise<RemoveShowFromShowListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeShowFromShowListWithOptions(request, runtime);
  }

  async restartCasterWithOptions(request: RestartCasterRequest, runtime: $Util.RuntimeOptions): Promise<RestartCasterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RestartCaster",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RestartCasterResponse>(await this.callApi(params, req, runtime), new RestartCasterResponse({}));
  }

  async restartCaster(request: RestartCasterRequest): Promise<RestartCasterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.restartCasterWithOptions(request, runtime);
  }

  async resumeLiveStreamWithOptions(request: ResumeLiveStreamRequest, runtime: $Util.RuntimeOptions): Promise<ResumeLiveStreamResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.liveStreamType)) {
      query["LiveStreamType"] = request.liveStreamType;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ResumeLiveStream",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ResumeLiveStreamResponse>(await this.callApi(params, req, runtime), new ResumeLiveStreamResponse({}));
  }

  async resumeLiveStream(request: ResumeLiveStreamRequest): Promise<ResumeLiveStreamResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resumeLiveStreamWithOptions(request, runtime);
  }

  async rollbackLiveStagingConfigWithOptions(request: RollbackLiveStagingConfigRequest, runtime: $Util.RuntimeOptions): Promise<RollbackLiveStagingConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.functionName)) {
      query["FunctionName"] = request.functionName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RollbackLiveStagingConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RollbackLiveStagingConfigResponse>(await this.callApi(params, req, runtime), new RollbackLiveStagingConfigResponse({}));
  }

  async rollbackLiveStagingConfig(request: RollbackLiveStagingConfigRequest): Promise<RollbackLiveStagingConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.rollbackLiveStagingConfigWithOptions(request, runtime);
  }

  async sendLikeWithOptions(request: SendLikeRequest, runtime: $Util.RuntimeOptions): Promise<SendLikeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.broadCastType)) {
      body["BroadCastType"] = request.broadCastType;
    }

    if (!Util.isUnset(request.count)) {
      body["Count"] = request.count;
    }

    if (!Util.isUnset(request.groupId)) {
      body["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.operatorUserId)) {
      body["OperatorUserId"] = request.operatorUserId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SendLike",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SendLikeResponse>(await this.callApi(params, req, runtime), new SendLikeResponse({}));
  }

  async sendLike(request: SendLikeRequest): Promise<SendLikeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.sendLikeWithOptions(request, runtime);
  }

  async sendMessageToGroupWithOptions(request: SendMessageToGroupRequest, runtime: $Util.RuntimeOptions): Promise<SendMessageToGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.data)) {
      body["Data"] = request.data;
    }

    if (!Util.isUnset(request.groupId)) {
      body["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.operatorUserId)) {
      body["OperatorUserId"] = request.operatorUserId;
    }

    if (!Util.isUnset(request.type)) {
      body["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SendMessageToGroup",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SendMessageToGroupResponse>(await this.callApi(params, req, runtime), new SendMessageToGroupResponse({}));
  }

  async sendMessageToGroup(request: SendMessageToGroupRequest): Promise<SendMessageToGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.sendMessageToGroupWithOptions(request, runtime);
  }

  async sendMessageToGroupUsersWithOptions(tmpReq: SendMessageToGroupUsersRequest, runtime: $Util.RuntimeOptions): Promise<SendMessageToGroupUsersResponse> {
    Util.validateModel(tmpReq);
    let request = new SendMessageToGroupUsersShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.receiverIdList)) {
      request.receiverIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.receiverIdList, "ReceiverIdList", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.data)) {
      body["Data"] = request.data;
    }

    if (!Util.isUnset(request.groupId)) {
      body["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.operatorUserId)) {
      body["OperatorUserId"] = request.operatorUserId;
    }

    if (!Util.isUnset(request.receiverIdListShrink)) {
      body["ReceiverIdList"] = request.receiverIdListShrink;
    }

    if (!Util.isUnset(request.type)) {
      body["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SendMessageToGroupUsers",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SendMessageToGroupUsersResponse>(await this.callApi(params, req, runtime), new SendMessageToGroupUsersResponse({}));
  }

  async sendMessageToGroupUsers(request: SendMessageToGroupUsersRequest): Promise<SendMessageToGroupUsersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.sendMessageToGroupUsersWithOptions(request, runtime);
  }

  async sendRoomNotificationWithOptions(request: SendRoomNotificationRequest, runtime: $Util.RuntimeOptions): Promise<SendRoomNotificationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appUid)) {
      query["AppUid"] = request.appUid;
    }

    if (!Util.isUnset(request.data)) {
      query["Data"] = request.data;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.priority)) {
      query["Priority"] = request.priority;
    }

    if (!Util.isUnset(request.roomId)) {
      query["RoomId"] = request.roomId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SendRoomNotification",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SendRoomNotificationResponse>(await this.callApi(params, req, runtime), new SendRoomNotificationResponse({}));
  }

  async sendRoomNotification(request: SendRoomNotificationRequest): Promise<SendRoomNotificationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.sendRoomNotificationWithOptions(request, runtime);
  }

  async sendRoomUserNotificationWithOptions(request: SendRoomUserNotificationRequest, runtime: $Util.RuntimeOptions): Promise<SendRoomUserNotificationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appUid)) {
      query["AppUid"] = request.appUid;
    }

    if (!Util.isUnset(request.data)) {
      query["Data"] = request.data;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.priority)) {
      query["Priority"] = request.priority;
    }

    if (!Util.isUnset(request.roomId)) {
      query["RoomId"] = request.roomId;
    }

    if (!Util.isUnset(request.toAppUid)) {
      query["ToAppUid"] = request.toAppUid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SendRoomUserNotification",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SendRoomUserNotificationResponse>(await this.callApi(params, req, runtime), new SendRoomUserNotificationResponse({}));
  }

  async sendRoomUserNotification(request: SendRoomUserNotificationRequest): Promise<SendRoomUserNotificationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.sendRoomUserNotificationWithOptions(request, runtime);
  }

  async setCasterChannelWithOptions(request: SetCasterChannelRequest, runtime: $Util.RuntimeOptions): Promise<SetCasterChannelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.channelId)) {
      query["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.faceBeauty)) {
      query["FaceBeauty"] = request.faceBeauty;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.playStatus)) {
      query["PlayStatus"] = request.playStatus;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.seekOffset)) {
      query["SeekOffset"] = request.seekOffset;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetCasterChannel",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetCasterChannelResponse>(await this.callApi(params, req, runtime), new SetCasterChannelResponse({}));
  }

  async setCasterChannel(request: SetCasterChannelRequest): Promise<SetCasterChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setCasterChannelWithOptions(request, runtime);
  }

  async setCasterConfigWithOptions(request: SetCasterConfigRequest, runtime: $Util.RuntimeOptions): Promise<SetCasterConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.callbackUrl)) {
      query["CallbackUrl"] = request.callbackUrl;
    }

    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.casterName)) {
      query["CasterName"] = request.casterName;
    }

    if (!Util.isUnset(request.channelEnable)) {
      query["ChannelEnable"] = request.channelEnable;
    }

    if (!Util.isUnset(request.delay)) {
      query["Delay"] = request.delay;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.programEffect)) {
      query["ProgramEffect"] = request.programEffect;
    }

    if (!Util.isUnset(request.programName)) {
      query["ProgramName"] = request.programName;
    }

    if (!Util.isUnset(request.recordConfig)) {
      query["RecordConfig"] = request.recordConfig;
    }

    if (!Util.isUnset(request.sideOutputUrl)) {
      query["SideOutputUrl"] = request.sideOutputUrl;
    }

    if (!Util.isUnset(request.sideOutputUrlList)) {
      query["SideOutputUrlList"] = request.sideOutputUrlList;
    }

    if (!Util.isUnset(request.syncGroupsConfig)) {
      query["SyncGroupsConfig"] = request.syncGroupsConfig;
    }

    if (!Util.isUnset(request.transcodeConfig)) {
      query["TranscodeConfig"] = request.transcodeConfig;
    }

    if (!Util.isUnset(request.urgentLiveStreamUrl)) {
      query["UrgentLiveStreamUrl"] = request.urgentLiveStreamUrl;
    }

    if (!Util.isUnset(request.urgentMaterialId)) {
      query["UrgentMaterialId"] = request.urgentMaterialId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetCasterConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetCasterConfigResponse>(await this.callApi(params, req, runtime), new SetCasterConfigResponse({}));
  }

  async setCasterConfig(request: SetCasterConfigRequest): Promise<SetCasterConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setCasterConfigWithOptions(request, runtime);
  }

  async setCasterSceneConfigWithOptions(request: SetCasterSceneConfigRequest, runtime: $Util.RuntimeOptions): Promise<SetCasterSceneConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.componentId)) {
      query["ComponentId"] = request.componentId;
    }

    if (!Util.isUnset(request.layoutId)) {
      query["LayoutId"] = request.layoutId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.sceneId)) {
      query["SceneId"] = request.sceneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetCasterSceneConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetCasterSceneConfigResponse>(await this.callApi(params, req, runtime), new SetCasterSceneConfigResponse({}));
  }

  async setCasterSceneConfig(request: SetCasterSceneConfigRequest): Promise<SetCasterSceneConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setCasterSceneConfigWithOptions(request, runtime);
  }

  async setCasterSyncGroupWithOptions(request: SetCasterSyncGroupRequest, runtime: $Util.RuntimeOptions): Promise<SetCasterSyncGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.syncGroup)) {
      query["SyncGroup"] = request.syncGroup;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetCasterSyncGroup",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetCasterSyncGroupResponse>(await this.callApi(params, req, runtime), new SetCasterSyncGroupResponse({}));
  }

  async setCasterSyncGroup(request: SetCasterSyncGroupRequest): Promise<SetCasterSyncGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setCasterSyncGroupWithOptions(request, runtime);
  }

  async setCasterTimedEventWithOptions(request: SetCasterTimedEventRequest, runtime: $Util.RuntimeOptions): Promise<SetCasterTimedEventResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.eventName)) {
      query["EventName"] = request.eventName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.startTimeUTC)) {
      query["StartTimeUTC"] = request.startTimeUTC;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetCasterTimedEvent",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetCasterTimedEventResponse>(await this.callApi(params, req, runtime), new SetCasterTimedEventResponse({}));
  }

  async setCasterTimedEvent(request: SetCasterTimedEventRequest): Promise<SetCasterTimedEventResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setCasterTimedEventWithOptions(request, runtime);
  }

  async setLiveDomainCertificateWithOptions(request: SetLiveDomainCertificateRequest, runtime: $Util.RuntimeOptions): Promise<SetLiveDomainCertificateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.certName)) {
      query["CertName"] = request.certName;
    }

    if (!Util.isUnset(request.certType)) {
      query["CertType"] = request.certType;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.forceSet)) {
      query["ForceSet"] = request.forceSet;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.SSLPri)) {
      query["SSLPri"] = request.SSLPri;
    }

    if (!Util.isUnset(request.SSLProtocol)) {
      query["SSLProtocol"] = request.SSLProtocol;
    }

    if (!Util.isUnset(request.SSLPub)) {
      query["SSLPub"] = request.SSLPub;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetLiveDomainCertificate",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetLiveDomainCertificateResponse>(await this.callApi(params, req, runtime), new SetLiveDomainCertificateResponse({}));
  }

  async setLiveDomainCertificate(request: SetLiveDomainCertificateRequest): Promise<SetLiveDomainCertificateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setLiveDomainCertificateWithOptions(request, runtime);
  }

  async setLiveDomainStagingConfigWithOptions(request: SetLiveDomainStagingConfigRequest, runtime: $Util.RuntimeOptions): Promise<SetLiveDomainStagingConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.functions)) {
      query["Functions"] = request.functions;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetLiveDomainStagingConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetLiveDomainStagingConfigResponse>(await this.callApi(params, req, runtime), new SetLiveDomainStagingConfigResponse({}));
  }

  async setLiveDomainStagingConfig(request: SetLiveDomainStagingConfigRequest): Promise<SetLiveDomainStagingConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setLiveDomainStagingConfigWithOptions(request, runtime);
  }

  async setLiveEdgeTransferWithOptions(request: SetLiveEdgeTransferRequest, runtime: $Util.RuntimeOptions): Promise<SetLiveEdgeTransferResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.httpDns)) {
      query["HttpDns"] = request.httpDns;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    if (!Util.isUnset(request.targetDomainList)) {
      query["TargetDomainList"] = request.targetDomainList;
    }

    if (!Util.isUnset(request.transferArgs)) {
      query["TransferArgs"] = request.transferArgs;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetLiveEdgeTransfer",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetLiveEdgeTransferResponse>(await this.callApi(params, req, runtime), new SetLiveEdgeTransferResponse({}));
  }

  async setLiveEdgeTransfer(request: SetLiveEdgeTransferRequest): Promise<SetLiveEdgeTransferResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setLiveEdgeTransferWithOptions(request, runtime);
  }

  async setLiveLazyPullStreamInfoConfigWithOptions(request: SetLiveLazyPullStreamInfoConfigRequest, runtime: $Util.RuntimeOptions): Promise<SetLiveLazyPullStreamInfoConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pullAppName)) {
      query["PullAppName"] = request.pullAppName;
    }

    if (!Util.isUnset(request.pullDomainName)) {
      query["PullDomainName"] = request.pullDomainName;
    }

    if (!Util.isUnset(request.pullProtocol)) {
      query["PullProtocol"] = request.pullProtocol;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetLiveLazyPullStreamInfoConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetLiveLazyPullStreamInfoConfigResponse>(await this.callApi(params, req, runtime), new SetLiveLazyPullStreamInfoConfigResponse({}));
  }

  async setLiveLazyPullStreamInfoConfig(request: SetLiveLazyPullStreamInfoConfigRequest): Promise<SetLiveLazyPullStreamInfoConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setLiveLazyPullStreamInfoConfigWithOptions(request, runtime);
  }

  async setLiveStreamDelayConfigWithOptions(request: SetLiveStreamDelayConfigRequest, runtime: $Util.RuntimeOptions): Promise<SetLiveStreamDelayConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.flvDelay)) {
      query["FlvDelay"] = request.flvDelay;
    }

    if (!Util.isUnset(request.flvLevel)) {
      query["FlvLevel"] = request.flvLevel;
    }

    if (!Util.isUnset(request.hlsDelay)) {
      query["HlsDelay"] = request.hlsDelay;
    }

    if (!Util.isUnset(request.hlsLevel)) {
      query["HlsLevel"] = request.hlsLevel;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.rtmpDelay)) {
      query["RtmpDelay"] = request.rtmpDelay;
    }

    if (!Util.isUnset(request.rtmpLevel)) {
      query["RtmpLevel"] = request.rtmpLevel;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetLiveStreamDelayConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetLiveStreamDelayConfigResponse>(await this.callApi(params, req, runtime), new SetLiveStreamDelayConfigResponse({}));
  }

  async setLiveStreamDelayConfig(request: SetLiveStreamDelayConfigRequest): Promise<SetLiveStreamDelayConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setLiveStreamDelayConfigWithOptions(request, runtime);
  }

  async setLiveStreamOptimizedFeatureConfigWithOptions(request: SetLiveStreamOptimizedFeatureConfigRequest, runtime: $Util.RuntimeOptions): Promise<SetLiveStreamOptimizedFeatureConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.configName)) {
      query["ConfigName"] = request.configName;
    }

    if (!Util.isUnset(request.configStatus)) {
      query["ConfigStatus"] = request.configStatus;
    }

    if (!Util.isUnset(request.configValue)) {
      query["ConfigValue"] = request.configValue;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetLiveStreamOptimizedFeatureConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetLiveStreamOptimizedFeatureConfigResponse>(await this.callApi(params, req, runtime), new SetLiveStreamOptimizedFeatureConfigResponse({}));
  }

  async setLiveStreamOptimizedFeatureConfig(request: SetLiveStreamOptimizedFeatureConfigRequest): Promise<SetLiveStreamOptimizedFeatureConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setLiveStreamOptimizedFeatureConfigWithOptions(request, runtime);
  }

  async setLiveStreamsNotifyUrlConfigWithOptions(request: SetLiveStreamsNotifyUrlConfigRequest, runtime: $Util.RuntimeOptions): Promise<SetLiveStreamsNotifyUrlConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.notifyAuthKey)) {
      query["NotifyAuthKey"] = request.notifyAuthKey;
    }

    if (!Util.isUnset(request.notifyReqAuth)) {
      query["NotifyReqAuth"] = request.notifyReqAuth;
    }

    if (!Util.isUnset(request.notifyUrl)) {
      query["NotifyUrl"] = request.notifyUrl;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetLiveStreamsNotifyUrlConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetLiveStreamsNotifyUrlConfigResponse>(await this.callApi(params, req, runtime), new SetLiveStreamsNotifyUrlConfigResponse({}));
  }

  async setLiveStreamsNotifyUrlConfig(request: SetLiveStreamsNotifyUrlConfigRequest): Promise<SetLiveStreamsNotifyUrlConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setLiveStreamsNotifyUrlConfigWithOptions(request, runtime);
  }

  async setSnapshotCallbackAuthWithOptions(request: SetSnapshotCallbackAuthRequest, runtime: $Util.RuntimeOptions): Promise<SetSnapshotCallbackAuthResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.callbackAuthKey)) {
      query["CallbackAuthKey"] = request.callbackAuthKey;
    }

    if (!Util.isUnset(request.callbackReqAuth)) {
      query["CallbackReqAuth"] = request.callbackReqAuth;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetSnapshotCallbackAuth",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetSnapshotCallbackAuthResponse>(await this.callApi(params, req, runtime), new SetSnapshotCallbackAuthResponse({}));
  }

  async setSnapshotCallbackAuth(request: SetSnapshotCallbackAuthRequest): Promise<SetSnapshotCallbackAuthResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setSnapshotCallbackAuthWithOptions(request, runtime);
  }

  async startCasterWithOptions(request: StartCasterRequest, runtime: $Util.RuntimeOptions): Promise<StartCasterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StartCaster",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartCasterResponse>(await this.callApi(params, req, runtime), new StartCasterResponse({}));
  }

  async startCaster(request: StartCasterRequest): Promise<StartCasterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startCasterWithOptions(request, runtime);
  }

  async startCasterSceneWithOptions(request: StartCasterSceneRequest, runtime: $Util.RuntimeOptions): Promise<StartCasterSceneResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.sceneId)) {
      query["SceneId"] = request.sceneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StartCasterScene",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartCasterSceneResponse>(await this.callApi(params, req, runtime), new StartCasterSceneResponse({}));
  }

  async startCasterScene(request: StartCasterSceneRequest): Promise<StartCasterSceneResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startCasterSceneWithOptions(request, runtime);
  }

  async startLiveDomainWithOptions(request: StartLiveDomainRequest, runtime: $Util.RuntimeOptions): Promise<StartLiveDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StartLiveDomain",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartLiveDomainResponse>(await this.callApi(params, req, runtime), new StartLiveDomainResponse({}));
  }

  async startLiveDomain(request: StartLiveDomainRequest): Promise<StartLiveDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startLiveDomainWithOptions(request, runtime);
  }

  async startLiveStreamMonitorWithOptions(request: StartLiveStreamMonitorRequest, runtime: $Util.RuntimeOptions): Promise<StartLiveStreamMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.monitorId)) {
      query["MonitorId"] = request.monitorId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StartLiveStreamMonitor",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartLiveStreamMonitorResponse>(await this.callApi(params, req, runtime), new StartLiveStreamMonitorResponse({}));
  }

  async startLiveStreamMonitor(request: StartLiveStreamMonitorRequest): Promise<StartLiveStreamMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startLiveStreamMonitorWithOptions(request, runtime);
  }

  async startPlaylistWithOptions(request: StartPlaylistRequest, runtime: $Util.RuntimeOptions): Promise<StartPlaylistResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.offset)) {
      query["Offset"] = request.offset;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.programId)) {
      query["ProgramId"] = request.programId;
    }

    if (!Util.isUnset(request.resumeMode)) {
      query["ResumeMode"] = request.resumeMode;
    }

    if (!Util.isUnset(request.startItemId)) {
      query["StartItemId"] = request.startItemId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StartPlaylist",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartPlaylistResponse>(await this.callApi(params, req, runtime), new StartPlaylistResponse({}));
  }

  async startPlaylist(request: StartPlaylistRequest): Promise<StartPlaylistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startPlaylistWithOptions(request, runtime);
  }

  async stopCasterWithOptions(request: StopCasterRequest, runtime: $Util.RuntimeOptions): Promise<StopCasterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StopCaster",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StopCasterResponse>(await this.callApi(params, req, runtime), new StopCasterResponse({}));
  }

  async stopCaster(request: StopCasterRequest): Promise<StopCasterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopCasterWithOptions(request, runtime);
  }

  async stopCasterSceneWithOptions(request: StopCasterSceneRequest, runtime: $Util.RuntimeOptions): Promise<StopCasterSceneResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.sceneId)) {
      query["SceneId"] = request.sceneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StopCasterScene",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StopCasterSceneResponse>(await this.callApi(params, req, runtime), new StopCasterSceneResponse({}));
  }

  async stopCasterScene(request: StopCasterSceneRequest): Promise<StopCasterSceneResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopCasterSceneWithOptions(request, runtime);
  }

  async stopLiveDomainWithOptions(request: StopLiveDomainRequest, runtime: $Util.RuntimeOptions): Promise<StopLiveDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StopLiveDomain",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StopLiveDomainResponse>(await this.callApi(params, req, runtime), new StopLiveDomainResponse({}));
  }

  async stopLiveDomain(request: StopLiveDomainRequest): Promise<StopLiveDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopLiveDomainWithOptions(request, runtime);
  }

  async stopLiveStreamMonitorWithOptions(request: StopLiveStreamMonitorRequest, runtime: $Util.RuntimeOptions): Promise<StopLiveStreamMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.monitorId)) {
      query["MonitorId"] = request.monitorId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StopLiveStreamMonitor",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StopLiveStreamMonitorResponse>(await this.callApi(params, req, runtime), new StopLiveStreamMonitorResponse({}));
  }

  async stopLiveStreamMonitor(request: StopLiveStreamMonitorRequest): Promise<StopLiveStreamMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopLiveStreamMonitorWithOptions(request, runtime);
  }

  async stopPlaylistWithOptions(request: StopPlaylistRequest, runtime: $Util.RuntimeOptions): Promise<StopPlaylistResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.programId)) {
      query["ProgramId"] = request.programId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StopPlaylist",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StopPlaylistResponse>(await this.callApi(params, req, runtime), new StopPlaylistResponse({}));
  }

  async stopPlaylist(request: StopPlaylistRequest): Promise<StopPlaylistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopPlaylistWithOptions(request, runtime);
  }

  async tagLiveResourcesWithOptions(request: TagLiveResourcesRequest, runtime: $Util.RuntimeOptions): Promise<TagLiveResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "TagLiveResources",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<TagLiveResourcesResponse>(await this.callApi(params, req, runtime), new TagLiveResourcesResponse({}));
  }

  async tagLiveResources(request: TagLiveResourcesRequest): Promise<TagLiveResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.tagLiveResourcesWithOptions(request, runtime);
  }

  async unTagLiveResourcesWithOptions(request: UnTagLiveResourcesRequest, runtime: $Util.RuntimeOptions): Promise<UnTagLiveResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.all)) {
      query["All"] = request.all;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tagKey)) {
      query["TagKey"] = request.tagKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UnTagLiveResources",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UnTagLiveResourcesResponse>(await this.callApi(params, req, runtime), new UnTagLiveResourcesResponse({}));
  }

  async unTagLiveResources(request: UnTagLiveResourcesRequest): Promise<UnTagLiveResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unTagLiveResourcesWithOptions(request, runtime);
  }

  async updateCasterSceneAudioWithOptions(request: UpdateCasterSceneAudioRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCasterSceneAudioResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.audioLayer)) {
      query["AudioLayer"] = request.audioLayer;
    }

    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.followEnable)) {
      query["FollowEnable"] = request.followEnable;
    }

    if (!Util.isUnset(request.mixList)) {
      query["MixList"] = request.mixList;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.sceneId)) {
      query["SceneId"] = request.sceneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCasterSceneAudio",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCasterSceneAudioResponse>(await this.callApi(params, req, runtime), new UpdateCasterSceneAudioResponse({}));
  }

  async updateCasterSceneAudio(request: UpdateCasterSceneAudioRequest): Promise<UpdateCasterSceneAudioResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCasterSceneAudioWithOptions(request, runtime);
  }

  async updateCasterSceneConfigWithOptions(request: UpdateCasterSceneConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCasterSceneConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.casterId)) {
      query["CasterId"] = request.casterId;
    }

    if (!Util.isUnset(request.componentId)) {
      query["ComponentId"] = request.componentId;
    }

    if (!Util.isUnset(request.layoutId)) {
      query["LayoutId"] = request.layoutId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.sceneId)) {
      query["SceneId"] = request.sceneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCasterSceneConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCasterSceneConfigResponse>(await this.callApi(params, req, runtime), new UpdateCasterSceneConfigResponse({}));
  }

  async updateCasterSceneConfig(request: UpdateCasterSceneConfigRequest): Promise<UpdateCasterSceneConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCasterSceneConfigWithOptions(request, runtime);
  }

  async updateLiveAppSnapshotConfigWithOptions(request: UpdateLiveAppSnapshotConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateLiveAppSnapshotConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.callback)) {
      query["Callback"] = request.callback;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ossBucket)) {
      query["OssBucket"] = request.ossBucket;
    }

    if (!Util.isUnset(request.ossEndpoint)) {
      query["OssEndpoint"] = request.ossEndpoint;
    }

    if (!Util.isUnset(request.overwriteOssObject)) {
      query["OverwriteOssObject"] = request.overwriteOssObject;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.sequenceOssObject)) {
      query["SequenceOssObject"] = request.sequenceOssObject;
    }

    if (!Util.isUnset(request.timeInterval)) {
      query["TimeInterval"] = request.timeInterval;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateLiveAppSnapshotConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateLiveAppSnapshotConfigResponse>(await this.callApi(params, req, runtime), new UpdateLiveAppSnapshotConfigResponse({}));
  }

  async updateLiveAppSnapshotConfig(request: UpdateLiveAppSnapshotConfigRequest): Promise<UpdateLiveAppSnapshotConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateLiveAppSnapshotConfigWithOptions(request, runtime);
  }

  async updateLiveAudioAuditConfigWithOptions(request: UpdateLiveAudioAuditConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateLiveAudioAuditConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.bizType)) {
      query["BizType"] = request.bizType;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ossBucket)) {
      query["OssBucket"] = request.ossBucket;
    }

    if (!Util.isUnset(request.ossEndpoint)) {
      query["OssEndpoint"] = request.ossEndpoint;
    }

    if (!Util.isUnset(request.ossObject)) {
      query["OssObject"] = request.ossObject;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.streamName)) {
      query["StreamName"] = request.streamName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateLiveAudioAuditConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateLiveAudioAuditConfigResponse>(await this.callApi(params, req, runtime), new UpdateLiveAudioAuditConfigResponse({}));
  }

  async updateLiveAudioAuditConfig(request: UpdateLiveAudioAuditConfigRequest): Promise<UpdateLiveAudioAuditConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateLiveAudioAuditConfigWithOptions(request, runtime);
  }

  async updateLiveAudioAuditNotifyConfigWithOptions(request: UpdateLiveAudioAuditNotifyConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateLiveAudioAuditNotifyConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.callback)) {
      query["Callback"] = request.callback;
    }

    if (!Util.isUnset(request.callbackTemplate)) {
      query["CallbackTemplate"] = request.callbackTemplate;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateLiveAudioAuditNotifyConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateLiveAudioAuditNotifyConfigResponse>(await this.callApi(params, req, runtime), new UpdateLiveAudioAuditNotifyConfigResponse({}));
  }

  async updateLiveAudioAuditNotifyConfig(request: UpdateLiveAudioAuditNotifyConfigRequest): Promise<UpdateLiveAudioAuditNotifyConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateLiveAudioAuditNotifyConfigWithOptions(request, runtime);
  }

  async updateLiveDetectNotifyConfigWithOptions(request: UpdateLiveDetectNotifyConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateLiveDetectNotifyConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.notifyUrl)) {
      query["NotifyUrl"] = request.notifyUrl;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateLiveDetectNotifyConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateLiveDetectNotifyConfigResponse>(await this.callApi(params, req, runtime), new UpdateLiveDetectNotifyConfigResponse({}));
  }

  async updateLiveDetectNotifyConfig(request: UpdateLiveDetectNotifyConfigRequest): Promise<UpdateLiveDetectNotifyConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateLiveDetectNotifyConfigWithOptions(request, runtime);
  }

  async updateLivePullStreamInfoConfigWithOptions(request: UpdateLivePullStreamInfoConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateLivePullStreamInfoConfigResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateLivePullStreamInfoConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateLivePullStreamInfoConfigResponse>(await this.callApi(params, req, runtime), new UpdateLivePullStreamInfoConfigResponse({}));
  }

  async updateLivePullStreamInfoConfig(request: UpdateLivePullStreamInfoConfigRequest): Promise<UpdateLivePullStreamInfoConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateLivePullStreamInfoConfigWithOptions(request, runtime);
  }

  async updateLiveRecordNotifyConfigWithOptions(request: UpdateLiveRecordNotifyConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateLiveRecordNotifyConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.needStatusNotify)) {
      query["NeedStatusNotify"] = request.needStatusNotify;
    }

    if (!Util.isUnset(request.notifyUrl)) {
      query["NotifyUrl"] = request.notifyUrl;
    }

    if (!Util.isUnset(request.onDemandUrl)) {
      query["OnDemandUrl"] = request.onDemandUrl;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateLiveRecordNotifyConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateLiveRecordNotifyConfigResponse>(await this.callApi(params, req, runtime), new UpdateLiveRecordNotifyConfigResponse({}));
  }

  async updateLiveRecordNotifyConfig(request: UpdateLiveRecordNotifyConfigRequest): Promise<UpdateLiveRecordNotifyConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateLiveRecordNotifyConfigWithOptions(request, runtime);
  }

  async updateLiveSnapshotDetectPornConfigWithOptions(request: UpdateLiveSnapshotDetectPornConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateLiveSnapshotDetectPornConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ossBucket)) {
      query["OssBucket"] = request.ossBucket;
    }

    if (!Util.isUnset(request.ossEndpoint)) {
      query["OssEndpoint"] = request.ossEndpoint;
    }

    if (!Util.isUnset(request.ossObject)) {
      query["OssObject"] = request.ossObject;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.scene)) {
      query["Scene"] = request.scene;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateLiveSnapshotDetectPornConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateLiveSnapshotDetectPornConfigResponse>(await this.callApi(params, req, runtime), new UpdateLiveSnapshotDetectPornConfigResponse({}));
  }

  async updateLiveSnapshotDetectPornConfig(request: UpdateLiveSnapshotDetectPornConfigRequest): Promise<UpdateLiveSnapshotDetectPornConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateLiveSnapshotDetectPornConfigWithOptions(request, runtime);
  }

  async updateLiveSnapshotNotifyConfigWithOptions(request: UpdateLiveSnapshotNotifyConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateLiveSnapshotNotifyConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.notifyAuthKey)) {
      query["NotifyAuthKey"] = request.notifyAuthKey;
    }

    if (!Util.isUnset(request.notifyReqAuth)) {
      query["NotifyReqAuth"] = request.notifyReqAuth;
    }

    if (!Util.isUnset(request.notifyUrl)) {
      query["NotifyUrl"] = request.notifyUrl;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateLiveSnapshotNotifyConfig",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateLiveSnapshotNotifyConfigResponse>(await this.callApi(params, req, runtime), new UpdateLiveSnapshotNotifyConfigResponse({}));
  }

  async updateLiveSnapshotNotifyConfig(request: UpdateLiveSnapshotNotifyConfigRequest): Promise<UpdateLiveSnapshotNotifyConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateLiveSnapshotNotifyConfigWithOptions(request, runtime);
  }

  async updateLiveStreamMonitorWithOptions(request: UpdateLiveStreamMonitorRequest, runtime: $Util.RuntimeOptions): Promise<UpdateLiveStreamMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.app)) {
      query["App"] = request.app;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.inputList)) {
      query["InputList"] = request.inputList;
    }

    if (!Util.isUnset(request.monitorId)) {
      query["MonitorId"] = request.monitorId;
    }

    if (!Util.isUnset(request.monitorName)) {
      query["MonitorName"] = request.monitorName;
    }

    if (!Util.isUnset(request.outputTemplate)) {
      query["OutputTemplate"] = request.outputTemplate;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.stream)) {
      query["Stream"] = request.stream;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateLiveStreamMonitor",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateLiveStreamMonitorResponse>(await this.callApi(params, req, runtime), new UpdateLiveStreamMonitorResponse({}));
  }

  async updateLiveStreamMonitor(request: UpdateLiveStreamMonitorRequest): Promise<UpdateLiveStreamMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateLiveStreamMonitorWithOptions(request, runtime);
  }

  async updateLiveStreamWatermarkWithOptions(request: UpdateLiveStreamWatermarkRequest, runtime: $Util.RuntimeOptions): Promise<UpdateLiveStreamWatermarkResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.height)) {
      query["Height"] = request.height;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.offsetCorner)) {
      query["OffsetCorner"] = request.offsetCorner;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pictureUrl)) {
      query["PictureUrl"] = request.pictureUrl;
    }

    if (!Util.isUnset(request.refHeight)) {
      query["RefHeight"] = request.refHeight;
    }

    if (!Util.isUnset(request.refWidth)) {
      query["RefWidth"] = request.refWidth;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.transparency)) {
      query["Transparency"] = request.transparency;
    }

    if (!Util.isUnset(request.XOffset)) {
      query["XOffset"] = request.XOffset;
    }

    if (!Util.isUnset(request.YOffset)) {
      query["YOffset"] = request.YOffset;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateLiveStreamWatermark",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateLiveStreamWatermarkResponse>(await this.callApi(params, req, runtime), new UpdateLiveStreamWatermarkResponse({}));
  }

  async updateLiveStreamWatermark(request: UpdateLiveStreamWatermarkRequest): Promise<UpdateLiveStreamWatermarkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateLiveStreamWatermarkWithOptions(request, runtime);
  }

  async updateLiveStreamWatermarkRuleWithOptions(request: UpdateLiveStreamWatermarkRuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateLiveStreamWatermarkRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateLiveStreamWatermarkRule",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateLiveStreamWatermarkRuleResponse>(await this.callApi(params, req, runtime), new UpdateLiveStreamWatermarkRuleResponse({}));
  }

  async updateLiveStreamWatermarkRule(request: UpdateLiveStreamWatermarkRuleRequest): Promise<UpdateLiveStreamWatermarkRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateLiveStreamWatermarkRuleWithOptions(request, runtime);
  }

  async updateLiveTopLevelDomainWithOptions(request: UpdateLiveTopLevelDomainRequest, runtime: $Util.RuntimeOptions): Promise<UpdateLiveTopLevelDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.topLevelDomain)) {
      query["TopLevelDomain"] = request.topLevelDomain;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateLiveTopLevelDomain",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateLiveTopLevelDomainResponse>(await this.callApi(params, req, runtime), new UpdateLiveTopLevelDomainResponse({}));
  }

  async updateLiveTopLevelDomain(request: UpdateLiveTopLevelDomainRequest): Promise<UpdateLiveTopLevelDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateLiveTopLevelDomainWithOptions(request, runtime);
  }

  async updateMessageAppWithOptions(tmpReq: UpdateMessageAppRequest, runtime: $Util.RuntimeOptions): Promise<UpdateMessageAppResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateMessageAppShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.appConfig)) {
      request.appConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.appConfig, "AppConfig", "json");
    }

    if (!Util.isUnset(tmpReq.extension)) {
      request.extensionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extension, "Extension", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appConfigShrink)) {
      body["AppConfig"] = request.appConfigShrink;
    }

    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      body["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.extensionShrink)) {
      body["Extension"] = request.extensionShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateMessageApp",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateMessageAppResponse>(await this.callApi(params, req, runtime), new UpdateMessageAppResponse({}));
  }

  async updateMessageApp(request: UpdateMessageAppRequest): Promise<UpdateMessageAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateMessageAppWithOptions(request, runtime);
  }

  async updateMessageGroupWithOptions(tmpReq: UpdateMessageGroupRequest, runtime: $Util.RuntimeOptions): Promise<UpdateMessageGroupResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateMessageGroupShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.extension)) {
      request.extensionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extension, "Extension", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.extensionShrink)) {
      body["Extension"] = request.extensionShrink;
    }

    if (!Util.isUnset(request.groupId)) {
      body["GroupId"] = request.groupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateMessageGroup",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateMessageGroupResponse>(await this.callApi(params, req, runtime), new UpdateMessageGroupResponse({}));
  }

  async updateMessageGroup(request: UpdateMessageGroupRequest): Promise<UpdateMessageGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateMessageGroupWithOptions(request, runtime);
  }

  async updateMixStreamWithOptions(request: UpdateMixStreamRequest, runtime: $Util.RuntimeOptions): Promise<UpdateMixStreamResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.inputStreamList)) {
      query["InputStreamList"] = request.inputStreamList;
    }

    if (!Util.isUnset(request.layoutId)) {
      query["LayoutId"] = request.layoutId;
    }

    if (!Util.isUnset(request.mixStreamId)) {
      query["MixStreamId"] = request.mixStreamId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateMixStream",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateMixStreamResponse>(await this.callApi(params, req, runtime), new UpdateMixStreamResponse({}));
  }

  async updateMixStream(request: UpdateMixStreamRequest): Promise<UpdateMixStreamResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateMixStreamWithOptions(request, runtime);
  }

  async verifyLiveDomainOwnerWithOptions(request: VerifyLiveDomainOwnerRequest, runtime: $Util.RuntimeOptions): Promise<VerifyLiveDomainOwnerResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.verifyType)) {
      query["VerifyType"] = request.verifyType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "VerifyLiveDomainOwner",
      version: "2016-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<VerifyLiveDomainOwnerResponse>(await this.callApi(params, req, runtime), new VerifyLiveDomainOwnerResponse({}));
  }

  async verifyLiveDomainOwner(request: VerifyLiveDomainOwnerRequest): Promise<VerifyLiveDomainOwnerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.verifyLiveDomainOwnerWithOptions(request, runtime);
  }

}
