// This file is auto-generated, don't edit it
/**
 *
 */
import Util, * as $Util from '@alicloud/tea-util';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class AddGroupMemberRequest extends $tea.Model {
  accessToken?: string;
  accessLevel?: number;
  aliyunPks?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      accessLevel: 'accessLevel',
      aliyunPks: 'aliyunPks',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      accessLevel: 'number',
      aliyunPks: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGroupMemberResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: AddGroupMemberResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': AddGroupMemberResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGroupMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddGroupMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddGroupMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPipelineRelationsRequest extends $tea.Model {
  relObjectIds?: string;
  relObjectType?: string;
  static names(): { [key: string]: string } {
    return {
      relObjectIds: 'relObjectIds',
      relObjectType: 'relObjectType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      relObjectIds: 'string',
      relObjectType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPipelineRelationsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPipelineRelationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddPipelineRelationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddPipelineRelationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddRepositoryMemberRequest extends $tea.Model {
  accessToken?: string;
  accessLevel?: number;
  aliyunPks?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      accessLevel: 'accessLevel',
      aliyunPks: 'aliyunPks',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      accessLevel: 'number',
      aliyunPks: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddRepositoryMemberResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: AddRepositoryMemberResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': AddRepositoryMemberResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddRepositoryMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddRepositoryMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddRepositoryMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWebhookRequest extends $tea.Model {
  accessToken?: string;
  description?: string;
  enableSslVerification?: boolean;
  mergeRequestsEvents?: boolean;
  noteEvents?: boolean;
  pushEvents?: boolean;
  secretToken?: string;
  tagPushEvents?: boolean;
  url?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      description: 'description',
      enableSslVerification: 'enableSslVerification',
      mergeRequestsEvents: 'mergeRequestsEvents',
      noteEvents: 'noteEvents',
      pushEvents: 'pushEvents',
      secretToken: 'secretToken',
      tagPushEvents: 'tagPushEvents',
      url: 'url',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      description: 'string',
      enableSslVerification: 'boolean',
      mergeRequestsEvents: 'boolean',
      noteEvents: 'boolean',
      pushEvents: 'boolean',
      secretToken: 'string',
      tagPushEvents: 'boolean',
      url: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWebhookResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: AddWebhookResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: AddWebhookResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWebhookResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddWebhookResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddWebhookResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseMergeRequestRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseMergeRequestResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: CloseMergeRequestResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CloseMergeRequestResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseMergeRequestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CloseMergeRequestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CloseMergeRequestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAppMembersRequest extends $tea.Model {
  playerList?: CreateAppMembersRequestPlayerList[];
  roleNames?: string[];
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      playerList: 'playerList',
      roleNames: 'roleNames',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      playerList: { 'type': 'array', 'itemType': CreateAppMembersRequestPlayerList },
      roleNames: { 'type': 'array', 'itemType': 'string' },
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAppMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: string;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBranchRequest extends $tea.Model {
  accessToken?: string;
  branchName?: string;
  ref?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      branchName: 'branchName',
      ref: 'ref',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      branchName: 'string',
      ref: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBranchResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: CreateBranchResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateBranchResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBranchResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateBranchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateBranchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunRequest extends $tea.Model {
  accessToken?: string;
  annotations?: CreateCheckRunRequestAnnotations[];
  completedAt?: string;
  conclusion?: string;
  detailsUrl?: string;
  externalId?: string;
  headSha?: string;
  name?: string;
  output?: CreateCheckRunRequestOutput;
  startedAt?: string;
  status?: string;
  organizationId?: string;
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      annotations: 'annotations',
      completedAt: 'completedAt',
      conclusion: 'conclusion',
      detailsUrl: 'detailsUrl',
      externalId: 'externalId',
      headSha: 'headSha',
      name: 'name',
      output: 'output',
      startedAt: 'startedAt',
      status: 'status',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      annotations: { 'type': 'array', 'itemType': CreateCheckRunRequestAnnotations },
      completedAt: 'string',
      conclusion: 'string',
      detailsUrl: 'string',
      externalId: 'string',
      headSha: 'string',
      name: 'string',
      output: CreateCheckRunRequestOutput,
      startedAt: 'string',
      status: 'string',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: CreateCheckRunResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateCheckRunResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateCheckRunResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCheckRunResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommentRequest extends $tea.Model {
  accessToken?: string;
  commentType?: string;
  content?: string;
  draft?: boolean;
  filePath?: string;
  lineNumber?: number;
  parentCommentBizId?: string;
  patchSetBizId?: string;
  resolved?: boolean;
  localId?: number;
  organizationId?: string;
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      commentType: 'commentType',
      content: 'content',
      draft: 'draft',
      filePath: 'filePath',
      lineNumber: 'lineNumber',
      parentCommentBizId: 'parentCommentBizId',
      patchSetBizId: 'patchSetBizId',
      resolved: 'resolved',
      localId: 'localId',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      commentType: 'string',
      content: 'string',
      draft: 'boolean',
      filePath: 'string',
      lineNumber: 'number',
      parentCommentBizId: 'string',
      patchSetBizId: 'string',
      resolved: 'boolean',
      localId: 'number',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommentResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: CreateCommentResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateCommentResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateCommentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCommentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitStatusRequest extends $tea.Model {
  accessToken?: string;
  context?: string;
  description?: string;
  state?: string;
  targetUrl?: string;
  organizationId?: string;
  repositoryIdentity?: string;
  sha?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      context: 'context',
      description: 'description',
      state: 'state',
      targetUrl: 'targetUrl',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
      sha: 'sha',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      context: 'string',
      description: 'string',
      state: 'string',
      targetUrl: 'string',
      organizationId: 'string',
      repositoryIdentity: 'string',
      sha: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitStatusResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: CreateCommitStatusResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateCommitStatusResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateCommitStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCommitStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitWithMultipleFilesRequest extends $tea.Model {
  accessToken?: string;
  actions?: CreateCommitWithMultipleFilesRequestActions[];
  branch?: string;
  commitMessage?: string;
  organizationId?: string;
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      actions: 'actions',
      branch: 'branch',
      commitMessage: 'commitMessage',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      actions: { 'type': 'array', 'itemType': CreateCommitWithMultipleFilesRequestActions },
      branch: 'string',
      commitMessage: 'string',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitWithMultipleFilesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  result?: CreateCommitWithMultipleFilesResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      result: CreateCommitWithMultipleFilesResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitWithMultipleFilesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateCommitWithMultipleFilesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCommitWithMultipleFilesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeployKeyRequest extends $tea.Model {
  accessToken?: string;
  key?: string;
  title?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      key: 'key',
      title: 'title',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      key: 'string',
      title: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeployKeyResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: CreateDeployKeyResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateDeployKeyResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeployKeyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDeployKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDeployKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileRequest extends $tea.Model {
  accessToken?: string;
  branchName?: string;
  commitMessage?: string;
  content?: string;
  encoding?: string;
  filePath?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      branchName: 'branchName',
      commitMessage: 'commitMessage',
      content: 'content',
      encoding: 'encoding',
      filePath: 'filePath',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      branchName: 'string',
      commitMessage: 'string',
      content: 'string',
      encoding: 'string',
      filePath: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: CreateFileResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateFileResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowTagRequest extends $tea.Model {
  color?: string;
  flowTagGroupId?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      color: 'color',
      flowTagGroupId: 'flowTagGroupId',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      color: 'string',
      flowTagGroupId: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowTagResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  id?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      id: 'id',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      id: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowTagResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateFlowTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateFlowTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowTagGroupRequest extends $tea.Model {
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowTagGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  id?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      id: 'id',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      id: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowTagGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateFlowTagGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateFlowTagGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHostGroupRequest extends $tea.Model {
  aliyunRegion?: string;
  ecsLabelKey?: string;
  ecsLabelValue?: string;
  ecsType?: string;
  envId?: string;
  machineInfos?: string;
  name?: string;
  serviceConnectionId?: number;
  tagIds?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunRegion: 'aliyunRegion',
      ecsLabelKey: 'ecsLabelKey',
      ecsLabelValue: 'ecsLabelValue',
      ecsType: 'ecsType',
      envId: 'envId',
      machineInfos: 'machineInfos',
      name: 'name',
      serviceConnectionId: 'serviceConnectionId',
      tagIds: 'tagIds',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunRegion: 'string',
      ecsLabelKey: 'string',
      ecsLabelValue: 'string',
      ecsType: 'string',
      envId: 'string',
      machineInfos: 'string',
      name: 'string',
      serviceConnectionId: 'number',
      tagIds: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHostGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  hostGroupId?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      hostGroupId: 'hostGroupId',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      hostGroupId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHostGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateHostGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateHostGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMergeRequestRequest extends $tea.Model {
  accessToken?: string;
  createFrom?: string;
  description?: string;
  reviewerIds?: string[];
  sourceBranch?: string;
  sourceProjectId?: number;
  targetBranch?: string;
  targetProjectId?: number;
  title?: string;
  workItemIds?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      createFrom: 'createFrom',
      description: 'description',
      reviewerIds: 'reviewerIds',
      sourceBranch: 'sourceBranch',
      sourceProjectId: 'sourceProjectId',
      targetBranch: 'targetBranch',
      targetProjectId: 'targetProjectId',
      title: 'title',
      workItemIds: 'workItemIds',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      createFrom: 'string',
      description: 'string',
      reviewerIds: { 'type': 'array', 'itemType': 'string' },
      sourceBranch: 'string',
      sourceProjectId: 'number',
      targetBranch: 'string',
      targetProjectId: 'number',
      title: 'string',
      workItemIds: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMergeRequestResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: CreateMergeRequestResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateMergeRequestResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMergeRequestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateMergeRequestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMergeRequestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOAuthTokenRequest extends $tea.Model {
  clientId?: string;
  clientSecret?: string;
  code?: string;
  grantType?: string;
  login?: string;
  scope?: string;
  static names(): { [key: string]: string } {
    return {
      clientId: 'clientId',
      clientSecret: 'clientSecret',
      code: 'code',
      grantType: 'grantType',
      login: 'login',
      scope: 'scope',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientId: 'string',
      clientSecret: 'string',
      code: 'string',
      grantType: 'string',
      login: 'string',
      scope: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOAuthTokenResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: CreateOAuthTokenResponseBodyResult;
  success?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateOAuthTokenResponseBodyResult,
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOAuthTokenResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOAuthTokenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOAuthTokenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePipelineRequest extends $tea.Model {
  content?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'content',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePipelineResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  pipelinId?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      pipelinId: 'pipelinId',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      pipelinId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePipelineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePipelineGroupRequest extends $tea.Model {
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePipelineGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  pipelineGroup?: CreatePipelineGroupResponseBodyPipelineGroup;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      pipelineGroup: 'pipelineGroup',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      pipelineGroup: CreatePipelineGroupResponseBodyPipelineGroup,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePipelineGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePipelineGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePipelineGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequest extends $tea.Model {
  customCode?: string;
  name?: string;
  scope?: string;
  templateIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      customCode: 'customCode',
      name: 'name',
      scope: 'scope',
      templateIdentifier: 'templateIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customCode: 'string',
      name: 'string',
      scope: 'string',
      templateIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  project?: CreateProjectResponseBodyProject;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      project: 'project',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      project: CreateProjectResponseBodyProject,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectLabelRequest extends $tea.Model {
  accessToken?: string;
  color?: string;
  description?: string;
  name?: string;
  organizationId?: string;
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      color: 'color',
      description: 'description',
      name: 'name',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      color: 'string',
      description: 'string',
      name: 'string',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectLabelResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: CreateProjectLabelResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateProjectLabelResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectLabelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateProjectLabelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProjectLabelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchRequest extends $tea.Model {
  accessToken?: string;
  allowMergeRoles?: number[];
  allowMergeUserIds?: string[];
  allowPushRoles?: number[];
  allowPushUserIds?: string[];
  branch?: string;
  id?: number;
  mergeRequestSetting?: CreateProtectdBranchRequestMergeRequestSetting;
  testSettingDTO?: CreateProtectdBranchRequestTestSettingDTO;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      allowMergeRoles: 'allowMergeRoles',
      allowMergeUserIds: 'allowMergeUserIds',
      allowPushRoles: 'allowPushRoles',
      allowPushUserIds: 'allowPushUserIds',
      branch: 'branch',
      id: 'id',
      mergeRequestSetting: 'mergeRequestSetting',
      testSettingDTO: 'testSettingDTO',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      allowMergeRoles: { 'type': 'array', 'itemType': 'number' },
      allowMergeUserIds: { 'type': 'array', 'itemType': 'string' },
      allowPushRoles: { 'type': 'array', 'itemType': 'number' },
      allowPushUserIds: { 'type': 'array', 'itemType': 'string' },
      branch: 'string',
      id: 'number',
      mergeRequestSetting: CreateProtectdBranchRequestMergeRequestSetting,
      testSettingDTO: CreateProtectdBranchRequestTestSettingDTO,
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: CreateProtectdBranchResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateProtectdBranchResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateProtectdBranchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProtectdBranchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePushRuleRequest extends $tea.Model {
  accessToken?: string;
  ruleInfos?: CreatePushRuleRequestRuleInfos[];
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      ruleInfos: 'ruleInfos',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      ruleInfos: { 'type': 'array', 'itemType': CreatePushRuleRequestRuleInfos },
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePushRuleResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: CreatePushRuleResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreatePushRuleResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePushRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePushRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePushRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRepositoryRequest extends $tea.Model {
  accessToken?: string;
  avatarUrl?: string;
  description?: string;
  gitignoreType?: string;
  importAccount?: string;
  importDemoProject?: boolean;
  importRepoType?: string;
  importToken?: string;
  importTokenEncrypted?: string;
  importUrl?: string;
  initStandardService?: boolean;
  isCryptoEnabled?: boolean;
  localImportUrl?: string;
  name?: string;
  namespaceId?: number;
  path?: string;
  readmeType?: string;
  visibilityLevel?: number;
  createParentPath?: boolean;
  organizationId?: string;
  sync?: boolean;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      avatarUrl: 'avatarUrl',
      description: 'description',
      gitignoreType: 'gitignoreType',
      importAccount: 'importAccount',
      importDemoProject: 'importDemoProject',
      importRepoType: 'importRepoType',
      importToken: 'importToken',
      importTokenEncrypted: 'importTokenEncrypted',
      importUrl: 'importUrl',
      initStandardService: 'initStandardService',
      isCryptoEnabled: 'isCryptoEnabled',
      localImportUrl: 'localImportUrl',
      name: 'name',
      namespaceId: 'namespaceId',
      path: 'path',
      readmeType: 'readmeType',
      visibilityLevel: 'visibilityLevel',
      createParentPath: 'createParentPath',
      organizationId: 'organizationId',
      sync: 'sync',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      avatarUrl: 'string',
      description: 'string',
      gitignoreType: 'string',
      importAccount: 'string',
      importDemoProject: 'boolean',
      importRepoType: 'string',
      importToken: 'string',
      importTokenEncrypted: 'string',
      importUrl: 'string',
      initStandardService: 'boolean',
      isCryptoEnabled: 'boolean',
      localImportUrl: 'string',
      name: 'string',
      namespaceId: 'number',
      path: 'string',
      readmeType: 'string',
      visibilityLevel: 'number',
      createParentPath: 'boolean',
      organizationId: 'string',
      sync: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRepositoryResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: CreateRepositoryResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateRepositoryResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRepositoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateRepositoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRepositoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRepositoryGroupRequest extends $tea.Model {
  accessToken?: string;
  avatarUrl?: string;
  description?: string;
  name?: string;
  parentId?: number;
  path?: string;
  visibilityLevel?: number;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      avatarUrl: 'avatarUrl',
      description: 'description',
      name: 'name',
      parentId: 'parentId',
      path: 'path',
      visibilityLevel: 'visibilityLevel',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      avatarUrl: 'string',
      description: 'string',
      name: 'string',
      parentId: 'number',
      path: 'string',
      visibilityLevel: 'number',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRepositoryGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: CreateRepositoryGroupResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateRepositoryGroupResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRepositoryGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateRepositoryGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRepositoryGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResourceMemberRequest extends $tea.Model {
  accountId?: string;
  roleName?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
      roleName: 'roleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
      roleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResourceMemberResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResourceMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateResourceMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateResourceMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceAuthRequest extends $tea.Model {
  serviceAuthType?: string;
  static names(): { [key: string]: string } {
    return {
      serviceAuthType: 'serviceAuthType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceAuthType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceAuthResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  id?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      id: 'id',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      id: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceAuthResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateServiceAuthResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateServiceAuthResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceConnectionRequest extends $tea.Model {
  authType?: string;
  connectionName?: string;
  connectionType?: string;
  scope?: string;
  serviceAuthId?: number;
  static names(): { [key: string]: string } {
    return {
      authType: 'authType',
      connectionName: 'connectionName',
      connectionType: 'connectionType',
      scope: 'scope',
      serviceAuthId: 'serviceAuthId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authType: 'string',
      connectionName: 'string',
      connectionType: 'string',
      scope: 'string',
      serviceAuthId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceConnectionResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  id?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      id: 'id',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      id: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceConnectionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateServiceConnectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateServiceConnectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceCredentialRequest extends $tea.Model {
  name?: string;
  password?: string;
  scope?: string;
  type?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'name',
      password: 'password',
      scope: 'scope',
      type: 'type',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      password: 'string',
      scope: 'string',
      type: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceCredentialResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  id?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      id: 'id',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      id: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceCredentialResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateServiceCredentialResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateServiceCredentialResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSprintRequest extends $tea.Model {
  endDate?: string;
  name?: string;
  spaceIdentifier?: string;
  staffIds?: string[];
  startDate?: string;
  static names(): { [key: string]: string } {
    return {
      endDate: 'endDate',
      name: 'name',
      spaceIdentifier: 'spaceIdentifier',
      staffIds: 'staffIds',
      startDate: 'startDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endDate: 'string',
      name: 'string',
      spaceIdentifier: 'string',
      staffIds: { 'type': 'array', 'itemType': 'string' },
      startDate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSprintResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  sprint?: CreateSprintResponseBodySprint;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      sprint: 'sprint',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      sprint: CreateSprintResponseBodySprint,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSprintResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSprintResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSprintResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSshKeyResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  sshKey?: CreateSshKeyResponseBodySshKey;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      sshKey: 'sshKey',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      sshKey: CreateSshKeyResponseBodySshKey,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSshKeyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSshKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSshKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagRequest extends $tea.Model {
  accessToken?: string;
  message?: string;
  ref?: string;
  tagName?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      message: 'message',
      ref: 'ref',
      tagName: 'tagName',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      message: 'string',
      ref: 'string',
      tagName: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: CreateTagResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateTagResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseRequest extends $tea.Model {
  assignedTo?: string;
  directoryIdentifier?: string;
  fieldValueList?: CreateTestCaseRequestFieldValueList[];
  priority?: string;
  spaceIdentifier?: string;
  subject?: string;
  tags?: string[];
  testcaseStepContentInfo?: CreateTestCaseRequestTestcaseStepContentInfo;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      directoryIdentifier: 'directoryIdentifier',
      fieldValueList: 'fieldValueList',
      priority: 'priority',
      spaceIdentifier: 'spaceIdentifier',
      subject: 'subject',
      tags: 'tags',
      testcaseStepContentInfo: 'testcaseStepContentInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: 'string',
      directoryIdentifier: 'string',
      fieldValueList: { 'type': 'array', 'itemType': CreateTestCaseRequestFieldValueList },
      priority: 'string',
      spaceIdentifier: 'string',
      subject: 'string',
      tags: { 'type': 'array', 'itemType': 'string' },
      testcaseStepContentInfo: CreateTestCaseRequestTestcaseStepContentInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  success?: boolean;
  testcase?: CreateTestCaseResponseBodyTestcase;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
      testcase: 'testcase',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
      testcase: CreateTestCaseResponseBodyTestcase,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTestCaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTestCaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserKeyRequest extends $tea.Model {
  accessToken?: string;
  expireTime?: string;
  keyScope?: string;
  publicKey?: string;
  title?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      expireTime: 'expireTime',
      keyScope: 'keyScope',
      publicKey: 'publicKey',
      title: 'title',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      expireTime: 'string',
      keyScope: 'string',
      publicKey: 'string',
      title: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserKeyResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: CreateUserKeyResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateUserKeyResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserKeyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateUserKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateUserKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVariableGroupRequest extends $tea.Model {
  description?: string;
  name?: string;
  variables?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'description',
      name: 'name',
      variables: 'variables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      variables: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVariableGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  variableGroupId?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
      variableGroupId: 'variableGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      variableGroupId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVariableGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateVariableGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateVariableGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemRequest extends $tea.Model {
  assignedTo?: string;
  category?: string;
  description?: string;
  descriptionFormat?: string;
  fieldValueList?: CreateWorkitemRequestFieldValueList[];
  parent?: string;
  participant?: string[];
  space?: string;
  spaceIdentifier?: string;
  spaceType?: string;
  sprint?: string[];
  subject?: string;
  tracker?: string[];
  verifier?: string[];
  workitemType?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      category: 'category',
      description: 'description',
      descriptionFormat: 'descriptionFormat',
      fieldValueList: 'fieldValueList',
      parent: 'parent',
      participant: 'participant',
      space: 'space',
      spaceIdentifier: 'spaceIdentifier',
      spaceType: 'spaceType',
      sprint: 'sprint',
      subject: 'subject',
      tracker: 'tracker',
      verifier: 'verifier',
      workitemType: 'workitemType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: 'string',
      category: 'string',
      description: 'string',
      descriptionFormat: 'string',
      fieldValueList: { 'type': 'array', 'itemType': CreateWorkitemRequestFieldValueList },
      parent: 'string',
      participant: { 'type': 'array', 'itemType': 'string' },
      space: 'string',
      spaceIdentifier: 'string',
      spaceType: 'string',
      sprint: { 'type': 'array', 'itemType': 'string' },
      subject: 'string',
      tracker: { 'type': 'array', 'itemType': 'string' },
      verifier: { 'type': 'array', 'itemType': 'string' },
      workitemType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  success?: boolean;
  workitem?: CreateWorkitemResponseBodyWorkitem;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
      workitem: 'workitem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
      workitem: CreateWorkitemResponseBodyWorkitem,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWorkitemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWorkitemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemCommentRequest extends $tea.Model {
  content?: string;
  formatType?: string;
  parentId?: string;
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'content',
      formatType: 'formatType',
      parentId: 'parentId',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      formatType: 'string',
      parentId: 'string',
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemCommentResponseBody extends $tea.Model {
  comment?: CreateWorkitemCommentResponseBodyComment;
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  success?: string;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: CreateWorkitemCommentResponseBodyComment,
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemCommentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWorkitemCommentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWorkitemCommentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemEstimateRequest extends $tea.Model {
  description?: string;
  recordUserIdentifier?: string;
  spentTime?: string;
  type?: string;
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'description',
      recordUserIdentifier: 'recordUserIdentifier',
      spentTime: 'spentTime',
      type: 'type',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      recordUserIdentifier: 'string',
      spentTime: 'string',
      type: 'string',
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemEstimateResponseBody extends $tea.Model {
  workitemTimeEstimate?: CreateWorkitemEstimateResponseBodyWorkitemTimeEstimate;
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      workitemTimeEstimate: 'WorkitemTimeEstimate',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      workitemTimeEstimate: CreateWorkitemEstimateResponseBodyWorkitemTimeEstimate,
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemEstimateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWorkitemEstimateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWorkitemEstimateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemRecordRequest extends $tea.Model {
  actualTime?: string;
  description?: string;
  gmtEnd?: string;
  gmtStart?: string;
  recordUserIdentifier?: string;
  type?: string;
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      actualTime: 'actualTime',
      description: 'description',
      gmtEnd: 'gmtEnd',
      gmtStart: 'gmtStart',
      recordUserIdentifier: 'recordUserIdentifier',
      type: 'type',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualTime: 'string',
      description: 'string',
      gmtEnd: 'string',
      gmtStart: 'string',
      recordUserIdentifier: 'string',
      type: 'string',
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemRecordResponseBody extends $tea.Model {
  workitemTime?: CreateWorkitemRecordResponseBodyWorkitemTime;
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      workitemTime: 'WorkitemTime',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      workitemTime: CreateWorkitemRecordResponseBodyWorkitemTime,
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemRecordResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWorkitemRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWorkitemRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemV2Request extends $tea.Model {
  assignedTo?: string;
  category?: string;
  description?: string;
  fieldValueList?: CreateWorkitemV2RequestFieldValueList[];
  parentIdentifier?: string;
  participants?: string[];
  spaceIdentifier?: string;
  sprintIdentifier?: string;
  subject?: string;
  tags?: string[];
  trackers?: string[];
  verifier?: string;
  versions?: string[];
  workitemTypeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      category: 'category',
      description: 'description',
      fieldValueList: 'fieldValueList',
      parentIdentifier: 'parentIdentifier',
      participants: 'participants',
      spaceIdentifier: 'spaceIdentifier',
      sprintIdentifier: 'sprintIdentifier',
      subject: 'subject',
      tags: 'tags',
      trackers: 'trackers',
      verifier: 'verifier',
      versions: 'versions',
      workitemTypeIdentifier: 'workitemTypeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: 'string',
      category: 'string',
      description: 'string',
      fieldValueList: { 'type': 'array', 'itemType': CreateWorkitemV2RequestFieldValueList },
      parentIdentifier: 'string',
      participants: { 'type': 'array', 'itemType': 'string' },
      spaceIdentifier: 'string',
      sprintIdentifier: 'string',
      subject: 'string',
      tags: { 'type': 'array', 'itemType': 'string' },
      trackers: { 'type': 'array', 'itemType': 'string' },
      verifier: 'string',
      versions: { 'type': 'array', 'itemType': 'string' },
      workitemTypeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemV2ResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: string;
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'string',
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemV2Response extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWorkitemV2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWorkitemV2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceRequest extends $tea.Model {
  codeUrl?: string;
  codeVersion?: string;
  filePath?: string;
  name?: string;
  requestFrom?: string;
  resourceIdentifier?: string;
  reuse?: boolean;
  workspaceTemplate?: string;
  static names(): { [key: string]: string } {
    return {
      codeUrl: 'codeUrl',
      codeVersion: 'codeVersion',
      filePath: 'filePath',
      name: 'name',
      requestFrom: 'requestFrom',
      resourceIdentifier: 'resourceIdentifier',
      reuse: 'reuse',
      workspaceTemplate: 'workspaceTemplate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeUrl: 'string',
      codeVersion: 'string',
      filePath: 'string',
      name: 'string',
      requestFrom: 'string',
      resourceIdentifier: 'string',
      reuse: 'boolean',
      workspaceTemplate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  workspace?: CreateWorkspaceResponseBodyWorkspace;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
      workspace: 'workspace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      workspace: CreateWorkspaceResponseBodyWorkspace,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWorkspaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWorkspaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAppMemberRequest extends $tea.Model {
  organizationId?: string;
  subjectId?: string;
  subjectType?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'organizationId',
      subjectId: 'subjectId',
      subjectType: 'subjectType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
      subjectId: 'string',
      subjectType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAppMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: string;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBranchRequest extends $tea.Model {
  accessToken?: string;
  branchName?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      branchName: 'branchName',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      branchName: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBranchResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: DeleteBranchResponseBodyResult;
  success?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteBranchResponseBodyResult,
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBranchResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteBranchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteBranchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFileRequest extends $tea.Model {
  accessToken?: string;
  branchName?: string;
  commitMessage?: string;
  filePath?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      branchName: 'branchName',
      commitMessage: 'commitMessage',
      filePath: 'filePath',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      branchName: 'string',
      commitMessage: 'string',
      filePath: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFileResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: DeleteFileResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteFileResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowTagResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowTagResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteFlowTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteFlowTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowTagGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowTagGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteFlowTagGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteFlowTagGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGroupMemberRequest extends $tea.Model {
  accessToken?: string;
  aliyunPk?: string;
  memberType?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      aliyunPk: 'aliyunPk',
      memberType: 'memberType',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      aliyunPk: 'string',
      memberType: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGroupMemberResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: DeleteGroupMemberResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteGroupMemberResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGroupMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteGroupMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteGroupMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHostGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHostGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteHostGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteHostGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePipelineResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePipelineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeletePipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeletePipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePipelineGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePipelineGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeletePipelineGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeletePipelineGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePipelineRelationsRequest extends $tea.Model {
  relObjectId?: string;
  relObjectType?: string;
  static names(): { [key: string]: string } {
    return {
      relObjectId: 'relObjectId',
      relObjectType: 'relObjectType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      relObjectId: 'string',
      relObjectType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePipelineRelationsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePipelineRelationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeletePipelineRelationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeletePipelineRelationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectRequest extends $tea.Model {
  identifier?: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'identifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  result?: boolean;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      result: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectLabelRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectLabelResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: DeleteProjectLabelResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteProjectLabelResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectLabelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteProjectLabelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteProjectLabelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProtectedBranchRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProtectedBranchResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: DeleteProtectedBranchResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteProtectedBranchResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProtectedBranchResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteProtectedBranchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteProtectedBranchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePushRuleRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePushRuleResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: DeletePushRuleResponseBodyResult;
  success?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeletePushRuleResponseBodyResult,
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePushRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeletePushRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeletePushRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryRequest extends $tea.Model {
  accessToken?: string;
  reason?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      reason: 'reason',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      reason: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: DeleteRepositoryResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteRepositoryResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRepositoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRepositoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryGroupRequest extends $tea.Model {
  accessToken?: string;
  reason?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      reason: 'reason',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      reason: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: DeleteRepositoryGroupResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteRepositoryGroupResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRepositoryGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRepositoryGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryMemberRequest extends $tea.Model {
  accessToken?: string;
  memberType?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      memberType: 'memberType',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      memberType: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryMemberResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: DeleteRepositoryMemberResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteRepositoryMemberResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRepositoryMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRepositoryMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryWebhookRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryWebhookResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: DeleteRepositoryWebhookResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteRepositoryWebhookResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryWebhookResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRepositoryWebhookResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRepositoryWebhookResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteResourceMemberResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteResourceMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteResourceMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteResourceMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  tagName?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      tagName: 'tagName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      tagName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: DeleteTagResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteTagResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserKeyRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserKeyResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: DeleteUserKeyResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteUserKeyResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserKeyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteUserKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteUserKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteVariableGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteVariableGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteVariableGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteVariableGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkitemRequest extends $tea.Model {
  identifier?: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'identifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkitemResponseBody extends $tea.Model {
  deleteFlag?: boolean;
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      deleteFlag: 'deleteFlag',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deleteFlag: 'boolean',
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkitemResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWorkitemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWorkitemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkitemAllCommentRequest extends $tea.Model {
  identifier?: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'identifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkitemAllCommentResponseBody extends $tea.Model {
  deleteFlag?: boolean;
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  success?: string;
  static names(): { [key: string]: string } {
    return {
      deleteFlag: 'deleteFlag',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deleteFlag: 'boolean',
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkitemAllCommentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWorkitemAllCommentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWorkitemAllCommentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkitemCommentRequest extends $tea.Model {
  commentId?: number;
  identifier?: string;
  static names(): { [key: string]: string } {
    return {
      commentId: 'commentId',
      identifier: 'identifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commentId: 'number',
      identifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkitemCommentResponseBody extends $tea.Model {
  deleteFlag?: boolean;
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  success?: string;
  static names(): { [key: string]: string } {
    return {
      deleteFlag: 'deleteFlag',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deleteFlag: 'boolean',
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkitemCommentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWorkitemCommentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWorkitemCommentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeployKeyRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeployKeyResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: EnableDeployKeyResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: EnableDeployKeyResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeployKeyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EnableDeployKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableDeployKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FrozenWorkspaceResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FrozenWorkspaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: FrozenWorkspaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: FrozenWorkspaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationRequest extends $tea.Model {
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationResponseBody extends $tea.Model {
  creatorAccountId?: string;
  description?: string;
  gmtCreate?: string;
  name?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      creatorAccountId: 'creatorAccountId',
      description: 'description',
      gmtCreate: 'gmtCreate',
      name: 'name',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorAccountId: 'string',
      description: 'string',
      gmtCreate: 'string',
      name: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetApplicationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetApplicationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBranchInfoRequest extends $tea.Model {
  accessToken?: string;
  branchName?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      branchName: 'branchName',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      branchName: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBranchInfoResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: GetBranchInfoResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetBranchInfoResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBranchInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetBranchInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetBranchInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRunRequest extends $tea.Model {
  accessToken?: string;
  checkRunId?: number;
  organizationId?: string;
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      checkRunId: 'checkRunId',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      checkRunId: 'number',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRunResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: GetCheckRunResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetCheckRunResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRunResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetCheckRunResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCheckRunResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCodeupOrganizationRequest extends $tea.Model {
  accessToken?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCodeupOrganizationResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: GetCodeupOrganizationResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetCodeupOrganizationResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCodeupOrganizationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetCodeupOrganizationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCodeupOrganizationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCompareDetailRequest extends $tea.Model {
  from?: string;
  maxDiffByte?: number;
  maxDiffFile?: number;
  mergeBase?: boolean;
  organizationId?: string;
  to?: string;
  static names(): { [key: string]: string } {
    return {
      from: 'from',
      maxDiffByte: 'maxDiffByte',
      maxDiffFile: 'maxDiffFile',
      mergeBase: 'mergeBase',
      organizationId: 'organizationId',
      to: 'to',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
      maxDiffByte: 'number',
      maxDiffFile: 'number',
      mergeBase: 'boolean',
      organizationId: 'string',
      to: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCompareDetailResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: GetCompareDetailResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetCompareDetailResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCompareDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetCompareDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCompareDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCustomFieldOptionRequest extends $tea.Model {
  spaceIdentifier?: string;
  spaceType?: string;
  workitemTypeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      spaceIdentifier: 'spaceIdentifier',
      spaceType: 'spaceType',
      workitemTypeIdentifier: 'workitemTypeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spaceIdentifier: 'string',
      spaceType: 'string',
      workitemTypeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCustomFieldOptionResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  fileds?: GetCustomFieldOptionResponseBodyFileds[];
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      fileds: 'fileds',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      fileds: { 'type': 'array', 'itemType': GetCustomFieldOptionResponseBodyFileds },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCustomFieldOptionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetCustomFieldOptionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCustomFieldOptionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileBlobsRequest extends $tea.Model {
  accessToken?: string;
  filePath?: string;
  from?: number;
  organizationId?: string;
  ref?: string;
  to?: number;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      filePath: 'filePath',
      from: 'from',
      organizationId: 'organizationId',
      ref: 'ref',
      to: 'to',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      filePath: 'string',
      from: 'number',
      organizationId: 'string',
      ref: 'string',
      to: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileBlobsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: GetFileBlobsResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetFileBlobsResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileBlobsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetFileBlobsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFileBlobsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileLastCommitRequest extends $tea.Model {
  accessToken?: string;
  filePath?: string;
  organizationId?: string;
  sha?: string;
  showSignature?: boolean;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      filePath: 'filePath',
      organizationId: 'organizationId',
      sha: 'sha',
      showSignature: 'showSignature',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      filePath: 'string',
      organizationId: 'string',
      sha: 'string',
      showSignature: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileLastCommitResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: GetFileLastCommitResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetFileLastCommitResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileLastCommitResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetFileLastCommitResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFileLastCommitResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFlowTagGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  flowTagGroup?: GetFlowTagGroupResponseBodyFlowTagGroup;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      flowTagGroup: 'flowTagGroup',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      flowTagGroup: GetFlowTagGroupResponseBodyFlowTagGroup,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFlowTagGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetFlowTagGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFlowTagGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGroupByPathRequest extends $tea.Model {
  identity?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      identity: 'identity',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identity: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGroupByPathResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: GetGroupByPathResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetGroupByPathResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGroupByPathResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetGroupByPathResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetGroupByPathResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGroupDetailRequest extends $tea.Model {
  accessToken?: string;
  groupId?: number;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      groupId: 'groupId',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      groupId: 'number',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGroupDetailResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: GetGroupDetailResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetGroupDetailResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGroupDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetGroupDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetGroupDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHostGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  hostGroup?: GetHostGroupResponseBodyHostGroup;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      hostGroup: 'hostGroup',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      hostGroup: GetHostGroupResponseBodyHostGroup,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHostGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetHostGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetHostGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: GetMergeRequestResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetMergeRequestResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMergeRequestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMergeRequestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestChangeTreeRequest extends $tea.Model {
  accessToken?: string;
  fromPatchSetBizId?: string;
  localId?: number;
  organizationId?: string;
  repositoryIdentity?: string;
  toPatchSetBizId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      fromPatchSetBizId: 'fromPatchSetBizId',
      localId: 'localId',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
      toPatchSetBizId: 'toPatchSetBizId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      fromPatchSetBizId: 'string',
      localId: 'number',
      organizationId: 'string',
      repositoryIdentity: 'string',
      toPatchSetBizId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestChangeTreeResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: GetMergeRequestChangeTreeResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetMergeRequestChangeTreeResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestChangeTreeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMergeRequestChangeTreeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMergeRequestChangeTreeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrganizationMemberResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  member?: GetOrganizationMemberResponseBodyMember;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      member: 'member',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      member: GetOrganizationMemberResponseBodyMember,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrganizationMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOrganizationMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOrganizationMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  pipeline?: GetPipelineResponseBodyPipeline;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      pipeline: 'pipeline',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      pipeline: GetPipelineResponseBodyPipeline,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineArtifactUrlRequest extends $tea.Model {
  fileName?: string;
  filePath?: string;
  static names(): { [key: string]: string } {
    return {
      fileName: 'fileName',
      filePath: 'filePath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileName: 'string',
      filePath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineArtifactUrlResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  fileUrl?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      fileUrl: 'fileUrl',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      fileUrl: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineArtifactUrlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPipelineArtifactUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPipelineArtifactUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineEmasArtifactUrlRequest extends $tea.Model {
  serviceConnectionId?: number;
  static names(): { [key: string]: string } {
    return {
      serviceConnectionId: 'serviceConnectionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceConnectionId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineEmasArtifactUrlResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  fileUrl?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      fileUrl: 'fileUrl',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      fileUrl: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineEmasArtifactUrlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPipelineEmasArtifactUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPipelineEmasArtifactUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  pipelineGroup?: GetPipelineGroupResponseBodyPipelineGroup;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      pipelineGroup: 'pipelineGroup',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      pipelineGroup: GetPipelineGroupResponseBodyPipelineGroup,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPipelineGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPipelineGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineRunResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  pipelineRun?: GetPipelineRunResponseBodyPipelineRun;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      pipelineRun: 'pipelineRun',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      pipelineRun: GetPipelineRunResponseBodyPipelineRun,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineRunResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPipelineRunResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPipelineRunResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineScanReportUrlRequest extends $tea.Model {
  reportPath?: string;
  static names(): { [key: string]: string } {
    return {
      reportPath: 'reportPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reportPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineScanReportUrlResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  reportUrl?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      reportUrl: 'reportUrl',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      reportUrl: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineScanReportUrlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPipelineScanReportUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPipelineScanReportUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectInfoResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  project?: GetProjectInfoResponseBodyProject;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      project: 'project',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      project: GetProjectInfoResponseBodyProject,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetProjectInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetProjectInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectMemberRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectMemberResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: GetProjectMemberResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetProjectMemberResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetProjectMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetProjectMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPushRuleRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPushRuleResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: GetPushRuleResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetPushRuleResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPushRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPushRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPushRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryRequest extends $tea.Model {
  accessToken?: string;
  identity?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      identity: 'identity',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      identity: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  repository?: GetRepositoryResponseBodyRepository;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      repository: 'repository',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      repository: GetRepositoryResponseBodyRepository,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRepositoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRepositoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryCommitRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  showSignature?: boolean;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      showSignature: 'showSignature',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      showSignature: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryCommitResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: GetRepositoryCommitResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetRepositoryCommitResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryCommitResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRepositoryCommitResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRepositoryCommitResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryTagRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  tagName?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      tagName: 'tagName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      tagName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryTagResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: GetRepositoryTagResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetRepositoryTagResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryTagResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRepositoryTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRepositoryTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSearchCodePreviewRequest extends $tea.Model {
  docId?: string;
  isDsl?: boolean;
  keyword?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      docId: 'docId',
      isDsl: 'isDsl',
      keyword: 'keyword',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      docId: 'string',
      isDsl: 'boolean',
      keyword: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSearchCodePreviewResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: GetSearchCodePreviewResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetSearchCodePreviewResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSearchCodePreviewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSearchCodePreviewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSearchCodePreviewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSprintInfoResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  sprint?: GetSprintInfoResponseBodySprint;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      sprint: 'sprint',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      sprint: GetSprintInfoResponseBodySprint,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSprintInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSprintInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSprintInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestResultListRequest extends $tea.Model {
  conditions?: string;
  directoryIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      conditions: 'conditions',
      directoryIdentifier: 'directoryIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conditions: 'string',
      directoryIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestResultListResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  success?: boolean;
  testResult?: GetTestResultListResponseBodyTestResult[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
      testResult: 'testResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
      testResult: { 'type': 'array', 'itemType': GetTestResultListResponseBodyTestResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestResultListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTestResultListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTestResultListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestcaseListRequest extends $tea.Model {
  conditions?: string;
  directoryIdentifier?: string;
  maxResult?: string;
  nextToken?: string;
  spaceIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      conditions: 'conditions',
      directoryIdentifier: 'directoryIdentifier',
      maxResult: 'maxResult',
      nextToken: 'nextToken',
      spaceIdentifier: 'spaceIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conditions: 'string',
      directoryIdentifier: 'string',
      maxResult: 'string',
      nextToken: 'string',
      spaceIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestcaseListResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  maxResults?: number;
  nextToken?: string;
  requestId?: string;
  success?: boolean;
  testcase?: GetTestcaseListResponseBodyTestcase[];
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      requestId: 'requestId',
      success: 'success',
      testcase: 'testcase',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      success: 'boolean',
      testcase: { 'type': 'array', 'itemType': GetTestcaseListResponseBodyTestcase },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestcaseListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTestcaseListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTestcaseListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserInfoRequest extends $tea.Model {
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserInfoResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: GetUserInfoResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetUserInfoResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetUserInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetUserInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVMDeployOrderResponseBody extends $tea.Model {
  deployOrder?: GetVMDeployOrderResponseBodyDeployOrder;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      deployOrder: 'deployOrder',
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deployOrder: GetVMDeployOrderResponseBodyDeployOrder,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVMDeployOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetVMDeployOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetVMDeployOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVariableGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  variableGroup?: GetVariableGroupResponseBodyVariableGroup;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
      variableGroup: 'variableGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      variableGroup: GetVariableGroupResponseBodyVariableGroup,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVariableGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetVariableGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetVariableGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemActivityResponseBody extends $tea.Model {
  activities?: GetWorkItemActivityResponseBodyActivities[];
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      activities: 'activities',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activities: { 'type': 'array', 'itemType': GetWorkItemActivityResponseBodyActivities },
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemActivityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWorkItemActivityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWorkItemActivityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemInfoResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  workitem?: GetWorkItemInfoResponseBodyWorkitem;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
      workitem: 'workitem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      workitem: GetWorkItemInfoResponseBodyWorkitem,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWorkItemInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWorkItemInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemWorkFlowInfoRequest extends $tea.Model {
  configurationId?: string;
  static names(): { [key: string]: string } {
    return {
      configurationId: 'configurationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configurationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemWorkFlowInfoResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  workflow?: GetWorkItemWorkFlowInfoResponseBodyWorkflow;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
      workflow: 'workflow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      workflow: GetWorkItemWorkFlowInfoResponseBodyWorkflow,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemWorkFlowInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWorkItemWorkFlowInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWorkItemWorkFlowInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemAttachmentCreatemetaRequest extends $tea.Model {
  fileName?: string;
  static names(): { [key: string]: string } {
    return {
      fileName: 'fileName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemAttachmentCreatemetaResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: string;
  uploadInfo?: GetWorkitemAttachmentCreatemetaResponseBodyUploadInfo;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
      uploadInfo: 'uploadInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'string',
      uploadInfo: GetWorkitemAttachmentCreatemetaResponseBodyUploadInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemAttachmentCreatemetaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWorkitemAttachmentCreatemetaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWorkitemAttachmentCreatemetaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemCommentListResponseBody extends $tea.Model {
  commentList?: GetWorkitemCommentListResponseBodyCommentList[];
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  success?: string;
  static names(): { [key: string]: string } {
    return {
      commentList: 'commentList',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commentList: { 'type': 'array', 'itemType': GetWorkitemCommentListResponseBodyCommentList },
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemCommentListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWorkitemCommentListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWorkitemCommentListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemFileResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  success?: string;
  workitemFile?: GetWorkitemFileResponseBodyWorkitemFile;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
      workitemFile: 'workitemFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'string',
      workitemFile: GetWorkitemFileResponseBodyWorkitemFile,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWorkitemFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWorkitemFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemRelationsRequest extends $tea.Model {
  relationType?: string;
  static names(): { [key: string]: string } {
    return {
      relationType: 'relationType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      relationType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemRelationsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  relationList?: GetWorkitemRelationsResponseBodyRelationList[];
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      relationList: 'relationList',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      relationList: { 'type': 'array', 'itemType': GetWorkitemRelationsResponseBodyRelationList },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemRelationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWorkitemRelationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWorkitemRelationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemTimeTypeListResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  success?: string;
  timeType?: GetWorkitemTimeTypeListResponseBodyTimeType[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
      timeType: 'timeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'string',
      timeType: { 'type': 'array', 'itemType': GetWorkitemTimeTypeListResponseBodyTimeType },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemTimeTypeListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWorkitemTimeTypeListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWorkitemTimeTypeListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspaceResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  workspace?: GetWorkspaceResponseBodyWorkspace;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
      workspace: 'workspace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      workspace: GetWorkspaceResponseBodyWorkspace,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWorkspaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWorkspaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinPipelineGroupRequest extends $tea.Model {
  groupId?: number;
  pipelineIds?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'groupId',
      pipelineIds: 'pipelineIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      pipelineIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinPipelineGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinPipelineGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: JoinPipelineGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: JoinPipelineGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LinkMergeRequestLabelRequest extends $tea.Model {
  accessToken?: string;
  labelIds?: string[];
  localId?: number;
  organizationId?: string;
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      labelIds: 'labelIds',
      localId: 'localId',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      labelIds: { 'type': 'array', 'itemType': 'string' },
      localId: 'number',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LinkMergeRequestLabelResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: LinkMergeRequestLabelResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: LinkMergeRequestLabelResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LinkMergeRequestLabelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: LinkMergeRequestLabelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: LinkMergeRequestLabelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationMembersRequest extends $tea.Model {
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationMembersResponseBody extends $tea.Model {
  current?: number;
  pageSize?: number;
  pages?: number;
  records?: ListApplicationMembersResponseBodyRecords[];
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      current: 'current',
      pageSize: 'pageSize',
      pages: 'pages',
      records: 'records',
      requestId: 'requestId',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      current: 'number',
      pageSize: 'number',
      pages: 'number',
      records: { 'type': 'array', 'itemType': ListApplicationMembersResponseBodyRecords },
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListApplicationMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListApplicationMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsRequest extends $tea.Model {
  nextToken?: string;
  orderBy?: string;
  organizationId?: string;
  pagination?: string;
  perPage?: number;
  sort?: string;
  static names(): { [key: string]: string } {
    return {
      nextToken: 'nextToken',
      orderBy: 'orderBy',
      organizationId: 'organizationId',
      pagination: 'pagination',
      perPage: 'perPage',
      sort: 'sort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      orderBy: 'string',
      organizationId: 'string',
      pagination: 'string',
      perPage: 'number',
      sort: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsResponseBody extends $tea.Model {
  data?: ListApplicationsResponseBodyData[];
  nextToken?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      nextToken: 'nextToken',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListApplicationsResponseBodyData },
      nextToken: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListApplicationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListApplicationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckRunsRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  page?: number;
  pageSize?: number;
  ref?: string;
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      ref: 'ref',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      ref: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckRunsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListCheckRunsResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListCheckRunsResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckRunsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCheckRunsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCheckRunsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCommitStatusesRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  page?: number;
  pageSize?: number;
  repositoryIdentity?: string;
  sha?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      repositoryIdentity: 'repositoryIdentity',
      sha: 'sha',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      repositoryIdentity: 'string',
      sha: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCommitStatusesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListCommitStatusesResponseBodyResult[];
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListCommitStatusesResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCommitStatusesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCommitStatusesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCommitStatusesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowTagGroupsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  flowTagGroups?: ListFlowTagGroupsResponseBodyFlowTagGroups[];
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      flowTagGroups: 'flowTagGroups',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      flowTagGroups: { 'type': 'array', 'itemType': ListFlowTagGroupsResponseBodyFlowTagGroups },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowTagGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListFlowTagGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListFlowTagGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGroupMemberRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGroupMemberResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListGroupMemberResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListGroupMemberResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGroupMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListGroupMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListGroupMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGroupRepositoriesRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  page?: number;
  pageSize?: number;
  search?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      search: 'search',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      search: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGroupRepositoriesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListGroupRepositoriesResponseBodyResult[];
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListGroupRepositoriesResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGroupRepositoriesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListGroupRepositoriesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListGroupRepositoriesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHostGroupsRequest extends $tea.Model {
  createEndTime?: number;
  createStartTime?: number;
  creatorAccountIds?: string;
  ids?: string;
  maxResults?: number;
  name?: string;
  nextToken?: string;
  pageOrder?: string;
  pageSort?: string;
  static names(): { [key: string]: string } {
    return {
      createEndTime: 'createEndTime',
      createStartTime: 'createStartTime',
      creatorAccountIds: 'creatorAccountIds',
      ids: 'ids',
      maxResults: 'maxResults',
      name: 'name',
      nextToken: 'nextToken',
      pageOrder: 'pageOrder',
      pageSort: 'pageSort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createEndTime: 'number',
      createStartTime: 'number',
      creatorAccountIds: 'string',
      ids: 'string',
      maxResults: 'number',
      name: 'string',
      nextToken: 'string',
      pageOrder: 'string',
      pageSort: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHostGroupsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  hostGroups?: ListHostGroupsResponseBodyHostGroups[];
  nextToken?: string;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      hostGroups: 'hostGroups',
      nextToken: 'nextToken',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      hostGroups: { 'type': 'array', 'itemType': ListHostGroupsResponseBodyHostGroups },
      nextToken: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHostGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListHostGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListHostGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJoinedOrganizationsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  organizations?: ListJoinedOrganizationsResponseBodyOrganizations[];
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      organizations: 'organizations',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      organizations: { 'type': 'array', 'itemType': ListJoinedOrganizationsResponseBodyOrganizations },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJoinedOrganizationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListJoinedOrganizationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListJoinedOrganizationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsRequest extends $tea.Model {
  accessToken?: string;
  commentType?: string;
  filePath?: string;
  patchSetBizIds?: string[];
  resolved?: boolean;
  state?: string;
  localId?: number;
  organizationId?: string;
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      commentType: 'commentType',
      filePath: 'filePath',
      patchSetBizIds: 'patchSetBizIds',
      resolved: 'resolved',
      state: 'state',
      localId: 'localId',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      commentType: 'string',
      filePath: 'string',
      patchSetBizIds: { 'type': 'array', 'itemType': 'string' },
      resolved: 'boolean',
      state: 'string',
      localId: 'number',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListMergeRequestCommentsResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListMergeRequestCommentsResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListMergeRequestCommentsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListMergeRequestCommentsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestFilesReadsRequest extends $tea.Model {
  accessToken?: string;
  fromPatchSetBizId?: string;
  localId?: number;
  organizationId?: string;
  repositoryIdentity?: string;
  toPatchSetBizId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      fromPatchSetBizId: 'fromPatchSetBizId',
      localId: 'localId',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
      toPatchSetBizId: 'toPatchSetBizId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      fromPatchSetBizId: 'string',
      localId: 'number',
      organizationId: 'string',
      repositoryIdentity: 'string',
      toPatchSetBizId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestFilesReadsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListMergeRequestFilesReadsResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListMergeRequestFilesReadsResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestFilesReadsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListMergeRequestFilesReadsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListMergeRequestFilesReadsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestLabelsRequest extends $tea.Model {
  accessToken?: string;
  localId?: number;
  organizationId?: string;
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      localId: 'localId',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      localId: 'number',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestLabelsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListMergeRequestLabelsResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListMergeRequestLabelsResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestLabelsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListMergeRequestLabelsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListMergeRequestLabelsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestPatchSetsRequest extends $tea.Model {
  accessToken?: string;
  localId?: number;
  organizationId?: string;
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      localId: 'localId',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      localId: 'number',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestPatchSetsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListMergeRequestPatchSetsResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListMergeRequestPatchSetsResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestPatchSetsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListMergeRequestPatchSetsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListMergeRequestPatchSetsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestsRequest extends $tea.Model {
  accessToken?: string;
  authorIds?: string;
  createdAfter?: string;
  createdBefore?: string;
  filter?: string;
  groupIds?: string;
  labelIds?: string;
  orderBy?: string;
  organizationId?: string;
  page?: number;
  pageSize?: number;
  projectIds?: string;
  reviewerIds?: string;
  search?: string;
  sort?: string;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      authorIds: 'authorIds',
      createdAfter: 'createdAfter',
      createdBefore: 'createdBefore',
      filter: 'filter',
      groupIds: 'groupIds',
      labelIds: 'labelIds',
      orderBy: 'orderBy',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      projectIds: 'projectIds',
      reviewerIds: 'reviewerIds',
      search: 'search',
      sort: 'sort',
      state: 'state',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      authorIds: 'string',
      createdAfter: 'string',
      createdBefore: 'string',
      filter: 'string',
      groupIds: 'string',
      labelIds: 'string',
      orderBy: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      projectIds: 'string',
      reviewerIds: 'string',
      search: 'string',
      sort: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListMergeRequestsResponseBodyResult[];
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListMergeRequestsResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListMergeRequestsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListMergeRequestsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrganizationMembersRequest extends $tea.Model {
  containsExternInfo?: boolean;
  externUid?: string;
  joinTimeFrom?: number;
  joinTimeTo?: number;
  maxResults?: number;
  nextToken?: string;
  organizationMemberName?: string;
  provider?: string;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      containsExternInfo: 'containsExternInfo',
      externUid: 'externUid',
      joinTimeFrom: 'joinTimeFrom',
      joinTimeTo: 'joinTimeTo',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      organizationMemberName: 'organizationMemberName',
      provider: 'provider',
      state: 'state',
    };
  }

  static types(): { [key: string]: any } {
    return {
      containsExternInfo: 'boolean',
      externUid: 'string',
      joinTimeFrom: 'number',
      joinTimeTo: 'number',
      maxResults: 'number',
      nextToken: 'string',
      organizationMemberName: 'string',
      provider: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrganizationMembersResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  members?: ListOrganizationMembersResponseBodyMembers[];
  nextToken?: string;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      members: 'members',
      nextToken: 'nextToken',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      members: { 'type': 'array', 'itemType': ListOrganizationMembersResponseBodyMembers },
      nextToken: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrganizationMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListOrganizationMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListOrganizationMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrganizationsRequest extends $tea.Model {
  accessLevel?: number;
  accessToken?: string;
  minAccessLevel?: number;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      accessToken: 'accessToken',
      minAccessLevel: 'minAccessLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      accessToken: 'string',
      minAccessLevel: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrganizationsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListOrganizationsResponseBodyResult[];
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListOrganizationsResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrganizationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListOrganizationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListOrganizationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineGroupPipelinesRequest extends $tea.Model {
  createEndTime?: number;
  createStartTime?: number;
  executeEndTime?: number;
  executeStartTime?: number;
  maxResults?: number;
  nextToken?: string;
  pipelineName?: string;
  resultStatusList?: string;
  static names(): { [key: string]: string } {
    return {
      createEndTime: 'createEndTime',
      createStartTime: 'createStartTime',
      executeEndTime: 'executeEndTime',
      executeStartTime: 'executeStartTime',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      pipelineName: 'pipelineName',
      resultStatusList: 'resultStatusList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createEndTime: 'number',
      createStartTime: 'number',
      executeEndTime: 'number',
      executeStartTime: 'number',
      maxResults: 'number',
      nextToken: 'string',
      pipelineName: 'string',
      resultStatusList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineGroupPipelinesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  nextToken?: string;
  pipelines?: ListPipelineGroupPipelinesResponseBodyPipelines[];
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      nextToken: 'nextToken',
      pipelines: 'pipelines',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      nextToken: 'string',
      pipelines: { 'type': 'array', 'itemType': ListPipelineGroupPipelinesResponseBodyPipelines },
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineGroupPipelinesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPipelineGroupPipelinesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPipelineGroupPipelinesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineGroupsRequest extends $tea.Model {
  maxResults?: number;
  nextToken?: string;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineGroupsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  nextToken?: string;
  pipelineGroups?: ListPipelineGroupsResponseBodyPipelineGroups[];
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      nextToken: 'nextToken',
      pipelineGroups: 'pipelineGroups',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      nextToken: 'string',
      pipelineGroups: { 'type': 'array', 'itemType': ListPipelineGroupsResponseBodyPipelineGroups },
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPipelineGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPipelineGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineJobHistorysRequest extends $tea.Model {
  category?: string;
  identifier?: string;
  maxResults?: number;
  nextToken?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'category',
      identifier: 'identifier',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      identifier: 'string',
      maxResults: 'number',
      nextToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineJobHistorysResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  jobs?: ListPipelineJobHistorysResponseBodyJobs[];
  nextToken?: string;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      jobs: 'jobs',
      nextToken: 'nextToken',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      jobs: { 'type': 'array', 'itemType': ListPipelineJobHistorysResponseBodyJobs },
      nextToken: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineJobHistorysResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPipelineJobHistorysResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPipelineJobHistorysResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineJobsRequest extends $tea.Model {
  category?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'category',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineJobsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  jobs?: ListPipelineJobsResponseBodyJobs[];
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      jobs: 'jobs',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      jobs: { 'type': 'array', 'itemType': ListPipelineJobsResponseBodyJobs },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineJobsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPipelineJobsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPipelineJobsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineRelationsRequest extends $tea.Model {
  relObjectType?: string;
  static names(): { [key: string]: string } {
    return {
      relObjectType: 'relObjectType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      relObjectType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineRelationsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  pipelineRelations?: ListPipelineRelationsResponseBodyPipelineRelations[];
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      pipelineRelations: 'pipelineRelations',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      pipelineRelations: { 'type': 'array', 'itemType': ListPipelineRelationsResponseBodyPipelineRelations },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineRelationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPipelineRelationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPipelineRelationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineRunsRequest extends $tea.Model {
  endTime?: number;
  maxResults?: number;
  nextToken?: string;
  startTime?: number;
  status?: string;
  triggerMode?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'endTime',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      startTime: 'startTime',
      status: 'status',
      triggerMode: 'triggerMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      maxResults: 'number',
      nextToken: 'string',
      startTime: 'number',
      status: 'string',
      triggerMode: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineRunsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  nextToken?: string;
  pipelineRuns?: ListPipelineRunsResponseBodyPipelineRuns[];
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      nextToken: 'nextToken',
      pipelineRuns: 'pipelineRuns',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      nextToken: 'string',
      pipelineRuns: { 'type': 'array', 'itemType': ListPipelineRunsResponseBodyPipelineRuns },
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineRunsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPipelineRunsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPipelineRunsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelinesRequest extends $tea.Model {
  createEndTime?: number;
  createStartTime?: number;
  creatorAccountIds?: string;
  executeAccountIds?: string;
  executeEndTime?: number;
  executeStartTime?: number;
  maxResults?: number;
  nextToken?: string;
  pipelineName?: string;
  statusList?: string;
  static names(): { [key: string]: string } {
    return {
      createEndTime: 'createEndTime',
      createStartTime: 'createStartTime',
      creatorAccountIds: 'creatorAccountIds',
      executeAccountIds: 'executeAccountIds',
      executeEndTime: 'executeEndTime',
      executeStartTime: 'executeStartTime',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      pipelineName: 'pipelineName',
      statusList: 'statusList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createEndTime: 'number',
      createStartTime: 'number',
      creatorAccountIds: 'string',
      executeAccountIds: 'string',
      executeEndTime: 'number',
      executeStartTime: 'number',
      maxResults: 'number',
      nextToken: 'string',
      pipelineName: 'string',
      statusList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelinesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  nextToken?: string;
  pipelines?: ListPipelinesResponseBodyPipelines[];
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      nextToken: 'nextToken',
      pipelines: 'pipelines',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      nextToken: 'string',
      pipelines: { 'type': 'array', 'itemType': ListPipelinesResponseBodyPipelines },
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelinesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPipelinesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPipelinesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectLabelsRequest extends $tea.Model {
  accessToken?: string;
  orderBy?: string;
  organizationId?: string;
  page?: number;
  pageSize?: number;
  repositoryIdentity?: string;
  search?: string;
  sort?: string;
  withCounts?: boolean;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      orderBy: 'orderBy',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      repositoryIdentity: 'repositoryIdentity',
      search: 'search',
      sort: 'sort',
      withCounts: 'withCounts',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      orderBy: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      repositoryIdentity: 'string',
      search: 'string',
      sort: 'string',
      withCounts: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectLabelsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListProjectLabelsResponseBodyResult[];
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListProjectLabelsResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectLabelsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProjectLabelsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProjectLabelsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectMembersRequest extends $tea.Model {
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      targetType: 'targetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectMembersResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  members?: ListProjectMembersResponseBodyMembers[];
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      members: 'members',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      members: { 'type': 'array', 'itemType': ListProjectMembersResponseBodyMembers },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProjectMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProjectMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectTemplatesRequest extends $tea.Model {
  category?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'category',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectTemplatesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  success?: boolean;
  templates?: ListProjectTemplatesResponseBodyTemplates[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
      templates: 'templates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
      templates: { 'type': 'array', 'itemType': ListProjectTemplatesResponseBodyTemplates },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectTemplatesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProjectTemplatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProjectTemplatesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectWorkitemTypesRequest extends $tea.Model {
  category?: string;
  spaceType?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'category',
      spaceType: 'spaceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      spaceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectWorkitemTypesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  workitemTypes?: ListProjectWorkitemTypesResponseBodyWorkitemTypes[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
      workitemTypes: 'workitemTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      workitemTypes: { 'type': 'array', 'itemType': ListProjectWorkitemTypesResponseBodyWorkitemTypes },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectWorkitemTypesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProjectWorkitemTypesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProjectWorkitemTypesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsRequest extends $tea.Model {
  category?: string;
  conditions?: string;
  extraConditions?: string;
  maxResults?: number;
  nextToken?: string;
  scope?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'category',
      conditions: 'conditions',
      extraConditions: 'extraConditions',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      scope: 'scope',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      conditions: 'string',
      extraConditions: 'string',
      maxResults: 'number',
      nextToken: 'string',
      scope: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  maxResults?: number;
  nextToken?: string;
  projects?: ListProjectsResponseBodyProjects[];
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      projects: 'projects',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      maxResults: 'number',
      nextToken: 'string',
      projects: { 'type': 'array', 'itemType': ListProjectsResponseBodyProjects },
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProjectsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProjectsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListProtectedBranchesResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListProtectedBranchesResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProtectedBranchesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProtectedBranchesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPushRulesRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPushRulesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListPushRulesResponseBodyResult[];
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListPushRulesResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPushRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPushRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPushRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoriesRequest extends $tea.Model {
  accessToken?: string;
  archived?: boolean;
  minAccessLevel?: number;
  orderBy?: string;
  organizationId?: string;
  page?: number;
  perPage?: number;
  search?: string;
  sort?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      archived: 'archived',
      minAccessLevel: 'minAccessLevel',
      orderBy: 'orderBy',
      organizationId: 'organizationId',
      page: 'page',
      perPage: 'perPage',
      search: 'search',
      sort: 'sort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      archived: 'boolean',
      minAccessLevel: 'number',
      orderBy: 'string',
      organizationId: 'string',
      page: 'number',
      perPage: 'number',
      search: 'string',
      sort: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoriesResponseBody extends $tea.Model {
  errorCode?: number;
  errorMessage?: string;
  requestId?: string;
  result?: ListRepositoriesResponseBodyResult[];
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListRepositoriesResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoriesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRepositoriesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRepositoriesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryBranchesRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  page?: number;
  pageSize?: number;
  search?: string;
  sort?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      search: 'search',
      sort: 'sort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      search: 'string',
      sort: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryBranchesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListRepositoryBranchesResponseBodyResult[];
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListRepositoryBranchesResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryBranchesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRepositoryBranchesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRepositoryBranchesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitDiffRequest extends $tea.Model {
  accessToken?: string;
  contextLine?: number;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      contextLine: 'contextLine',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      contextLine: 'number',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitDiffResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListRepositoryCommitDiffResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListRepositoryCommitDiffResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitDiffResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRepositoryCommitDiffResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRepositoryCommitDiffResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitsRequest extends $tea.Model {
  accessToken?: string;
  end?: string;
  organizationId?: string;
  page?: number;
  pageSize?: number;
  path?: string;
  refName?: string;
  search?: string;
  showCommentsCount?: boolean;
  showSignature?: boolean;
  start?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      end: 'end',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      path: 'path',
      refName: 'refName',
      search: 'search',
      showCommentsCount: 'showCommentsCount',
      showSignature: 'showSignature',
      start: 'start',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      end: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      path: 'string',
      refName: 'string',
      search: 'string',
      showCommentsCount: 'boolean',
      showSignature: 'boolean',
      start: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListRepositoryCommitsResponseBodyResult[];
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListRepositoryCommitsResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRepositoryCommitsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRepositoryCommitsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryGroupsRequest extends $tea.Model {
  accessToken?: string;
  includePersonal?: boolean;
  orderBy?: string;
  organizationId?: string;
  page?: number;
  pageSize?: number;
  parentId?: number;
  search?: string;
  sort?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      includePersonal: 'includePersonal',
      orderBy: 'orderBy',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      parentId: 'parentId',
      search: 'search',
      sort: 'sort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      includePersonal: 'boolean',
      orderBy: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      parentId: 'number',
      search: 'string',
      sort: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryGroupsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListRepositoryGroupsResponseBodyResult[];
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListRepositoryGroupsResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRepositoryGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRepositoryGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryMemberWithInheritedRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryMemberWithInheritedResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListRepositoryMemberWithInheritedResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListRepositoryMemberWithInheritedResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryMemberWithInheritedResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRepositoryMemberWithInheritedResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRepositoryMemberWithInheritedResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryTagsRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  page?: number;
  pageSize?: number;
  search?: string;
  sort?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      search: 'search',
      sort: 'sort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      search: 'string',
      sort: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryTagsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListRepositoryTagsResponseBodyResult[];
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListRepositoryTagsResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryTagsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRepositoryTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRepositoryTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryTreeRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  path?: string;
  refName?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      path: 'path',
      refName: 'refName',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      path: 'string',
      refName: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryTreeResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListRepositoryTreeResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListRepositoryTreeResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryTreeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRepositoryTreeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRepositoryTreeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryWebhookRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  page?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryWebhookResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListRepositoryWebhookResponseBodyResult[];
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListRepositoryWebhookResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryWebhookResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRepositoryWebhookResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRepositoryWebhookResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourceMembersResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  resourceMembers?: ListResourceMembersResponseBodyResourceMembers[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      resourceMembers: 'resourceMembers',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      resourceMembers: { 'type': 'array', 'itemType': ListResourceMembersResponseBodyResourceMembers },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourceMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListResourceMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListResourceMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchCommitRequest extends $tea.Model {
  keyword?: string;
  order?: string;
  page?: number;
  pageSize?: number;
  repoPath?: ListSearchCommitRequestRepoPath;
  scope?: string;
  sort?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      keyword: 'keyword',
      order: 'order',
      page: 'page',
      pageSize: 'pageSize',
      repoPath: 'repoPath',
      scope: 'scope',
      sort: 'sort',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyword: 'string',
      order: 'string',
      page: 'number',
      pageSize: 'number',
      repoPath: ListSearchCommitRequestRepoPath,
      scope: 'string',
      sort: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchCommitResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListSearchCommitResponseBodyResult[];
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListSearchCommitResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchCommitResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSearchCommitResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSearchCommitResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchRepositoryRequest extends $tea.Model {
  aliyunPk?: string;
  keyword?: string;
  order?: string;
  page?: number;
  pageSize?: number;
  repoPath?: ListSearchRepositoryRequestRepoPath;
  scope?: string;
  sort?: string;
  visibilityLevel?: number;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      keyword: 'keyword',
      order: 'order',
      page: 'page',
      pageSize: 'pageSize',
      repoPath: 'repoPath',
      scope: 'scope',
      sort: 'sort',
      visibilityLevel: 'visibilityLevel',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      keyword: 'string',
      order: 'string',
      page: 'number',
      pageSize: 'number',
      repoPath: ListSearchRepositoryRequestRepoPath,
      scope: 'string',
      sort: 'string',
      visibilityLevel: 'number',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchRepositoryResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListSearchRepositoryResponseBodyResult[];
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListSearchRepositoryResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchRepositoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSearchRepositoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSearchRepositoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchSourceCodeRequest extends $tea.Model {
  filePath?: ListSearchSourceCodeRequestFilePath;
  isCodeBlock?: boolean;
  keyword?: string;
  language?: string;
  order?: string;
  page?: number;
  pageSize?: number;
  repoPath?: ListSearchSourceCodeRequestRepoPath;
  scope?: string;
  sort?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      filePath: 'filePath',
      isCodeBlock: 'isCodeBlock',
      keyword: 'keyword',
      language: 'language',
      order: 'order',
      page: 'page',
      pageSize: 'pageSize',
      repoPath: 'repoPath',
      scope: 'scope',
      sort: 'sort',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filePath: ListSearchSourceCodeRequestFilePath,
      isCodeBlock: 'boolean',
      keyword: 'string',
      language: 'string',
      order: 'string',
      page: 'number',
      pageSize: 'number',
      repoPath: ListSearchSourceCodeRequestRepoPath,
      scope: 'string',
      sort: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchSourceCodeResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListSearchSourceCodeResponseBodyResult[];
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListSearchSourceCodeResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchSourceCodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSearchSourceCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSearchSourceCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceAuthsRequest extends $tea.Model {
  serviceAuthType?: string;
  static names(): { [key: string]: string } {
    return {
      serviceAuthType: 'serviceAuthType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceAuthType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceAuthsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  serviceAuths?: ListServiceAuthsResponseBodyServiceAuths[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      serviceAuths: 'serviceAuths',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      serviceAuths: { 'type': 'array', 'itemType': ListServiceAuthsResponseBodyServiceAuths },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceAuthsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListServiceAuthsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListServiceAuthsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceConnectionsRequest extends $tea.Model {
  sericeConnectionType?: string;
  static names(): { [key: string]: string } {
    return {
      sericeConnectionType: 'sericeConnectionType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sericeConnectionType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceConnectionsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  serviceConnections?: ListServiceConnectionsResponseBodyServiceConnections[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      serviceConnections: 'serviceConnections',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      serviceConnections: { 'type': 'array', 'itemType': ListServiceConnectionsResponseBodyServiceConnections },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceConnectionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListServiceConnectionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListServiceConnectionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceCredentialsRequest extends $tea.Model {
  serviceCredentialType?: string;
  static names(): { [key: string]: string } {
    return {
      serviceCredentialType: 'serviceCredentialType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceCredentialType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceCredentialsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  serviceCredentials?: ListServiceCredentialsResponseBodyServiceCredentials[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      serviceCredentials: 'serviceCredentials',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      serviceCredentials: { 'type': 'array', 'itemType': ListServiceCredentialsResponseBodyServiceCredentials },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceCredentialsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListServiceCredentialsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListServiceCredentialsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSprintsRequest extends $tea.Model {
  maxResults?: number;
  nextToken?: string;
  spaceIdentifier?: string;
  spaceType?: string;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      spaceIdentifier: 'spaceIdentifier',
      spaceType: 'spaceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      spaceIdentifier: 'string',
      spaceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSprintsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  maxResults?: number;
  nextToken?: string;
  requestId?: string;
  sprints?: ListSprintsResponseBodySprints[];
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      requestId: 'requestId',
      sprints: 'sprints',
      success: 'success',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      sprints: { 'type': 'array', 'itemType': ListSprintsResponseBodySprints },
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSprintsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSprintsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSprintsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTestCaseFieldsRequest extends $tea.Model {
  spaceIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      spaceIdentifier: 'spaceIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spaceIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTestCaseFieldsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  fields?: ListTestCaseFieldsResponseBodyFields[];
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      fields: 'fields',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      fields: { 'type': 'array', 'itemType': ListTestCaseFieldsResponseBodyFields },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTestCaseFieldsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTestCaseFieldsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTestCaseFieldsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserDrawRecordByPkRequest extends $tea.Model {
  aliyunPk?: string;
  drawGroup?: string;
  drawPoolName?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      drawGroup: 'drawGroup',
      drawPoolName: 'drawPoolName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      drawGroup: 'string',
      drawPoolName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserDrawRecordByPkResponseBody extends $tea.Model {
  code?: string;
  data?: ListUserDrawRecordByPkResponseBodyData[];
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'code',
      data: 'data',
      message: 'message',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: { 'type': 'array', 'itemType': ListUserDrawRecordByPkResponseBodyData },
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserDrawRecordByPkResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListUserDrawRecordByPkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListUserDrawRecordByPkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserKeysRequest extends $tea.Model {
  accessToken?: string;
  orderBy?: string;
  organizationId?: string;
  page?: number;
  pageSize?: number;
  sort?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      orderBy: 'orderBy',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      sort: 'sort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      orderBy: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      sort: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserKeysResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListUserKeysResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListUserKeysResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserKeysResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListUserKeysResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListUserKeysResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  page?: number;
  pageSize?: number;
  userIds?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      userIds: 'userIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      userIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListUserResourcesResponseBodyResult[];
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListUserResourcesResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListUserResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListUserResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVariableGroupsRequest extends $tea.Model {
  maxResults?: number;
  nextToken?: string;
  pageOrder?: string;
  pageSort?: string;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      pageOrder: 'pageOrder',
      pageSort: 'pageSort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      pageOrder: 'string',
      pageSort: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVariableGroupsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  nextToken?: string;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  variableGroups?: ListVariableGroupsResponseBodyVariableGroups[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      nextToken: 'nextToken',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
      variableGroups: 'variableGroups',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      nextToken: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
      variableGroups: { 'type': 'array', 'itemType': ListVariableGroupsResponseBodyVariableGroups },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVariableGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListVariableGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListVariableGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkItemAllFieldsRequest extends $tea.Model {
  spaceIdentifier?: string;
  spaceType?: string;
  workitemTypeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      spaceIdentifier: 'spaceIdentifier',
      spaceType: 'spaceType',
      workitemTypeIdentifier: 'workitemTypeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spaceIdentifier: 'string',
      spaceType: 'string',
      workitemTypeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkItemAllFieldsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  fields?: ListWorkItemAllFieldsResponseBodyFields[];
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      fields: 'fields',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      fields: { 'type': 'array', 'itemType': ListWorkItemAllFieldsResponseBodyFields },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkItemAllFieldsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWorkItemAllFieldsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWorkItemAllFieldsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkItemWorkFlowStatusRequest extends $tea.Model {
  spaceIdentifier?: string;
  spaceType?: string;
  workitemCategoryIdentifier?: string;
  workitemTypeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      spaceIdentifier: 'spaceIdentifier',
      spaceType: 'spaceType',
      workitemCategoryIdentifier: 'workitemCategoryIdentifier',
      workitemTypeIdentifier: 'workitemTypeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spaceIdentifier: 'string',
      spaceType: 'string',
      workitemCategoryIdentifier: 'string',
      workitemTypeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkItemWorkFlowStatusResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  statuses?: ListWorkItemWorkFlowStatusResponseBodyStatuses[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      statuses: 'statuses',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      statuses: { 'type': 'array', 'itemType': ListWorkItemWorkFlowStatusResponseBodyStatuses },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkItemWorkFlowStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWorkItemWorkFlowStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWorkItemWorkFlowStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemAttachmentsResponseBody extends $tea.Model {
  attachments?: ListWorkitemAttachmentsResponseBodyAttachments[];
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      attachments: 'attachments',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachments: { 'type': 'array', 'itemType': ListWorkitemAttachmentsResponseBodyAttachments },
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemAttachmentsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWorkitemAttachmentsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWorkitemAttachmentsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemEstimateResponseBody extends $tea.Model {
  code?: number;
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  success?: boolean;
  workitemTimeEstimate?: ListWorkitemEstimateResponseBodyWorkitemTimeEstimate[];
  static names(): { [key: string]: string } {
    return {
      code: 'code',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
      workitemTimeEstimate: 'workitemTimeEstimate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
      workitemTimeEstimate: { 'type': 'array', 'itemType': ListWorkitemEstimateResponseBodyWorkitemTimeEstimate },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemEstimateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWorkitemEstimateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWorkitemEstimateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemTimeResponseBody extends $tea.Model {
  code?: number;
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  success?: boolean;
  workitemTime?: ListWorkitemTimeResponseBodyWorkitemTime[];
  static names(): { [key: string]: string } {
    return {
      code: 'code',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
      workitemTime: 'workitemTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
      workitemTime: { 'type': 'array', 'itemType': ListWorkitemTimeResponseBodyWorkitemTime },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemTimeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWorkitemTimeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWorkitemTimeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemsRequest extends $tea.Model {
  category?: string;
  conditions?: string;
  extraConditions?: string;
  groupCondition?: string;
  maxResults?: string;
  nextToken?: string;
  orderBy?: string;
  searchType?: string;
  spaceIdentifier?: string;
  spaceType?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'category',
      conditions: 'conditions',
      extraConditions: 'extraConditions',
      groupCondition: 'groupCondition',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      orderBy: 'orderBy',
      searchType: 'searchType',
      spaceIdentifier: 'spaceIdentifier',
      spaceType: 'spaceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      conditions: 'string',
      extraConditions: 'string',
      groupCondition: 'string',
      maxResults: 'string',
      nextToken: 'string',
      orderBy: 'string',
      searchType: 'string',
      spaceIdentifier: 'string',
      spaceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  maxResults?: number;
  nextToken?: string;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  workitems?: ListWorkitemsResponseBodyWorkitems[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
      workitems: 'workitems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
      workitems: { 'type': 'array', 'itemType': ListWorkitemsResponseBodyWorkitems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWorkitemsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWorkitemsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkspacesRequest extends $tea.Model {
  maxResults?: number;
  nextToken?: string;
  statusList?: string[];
  workspaceTemplateList?: string[];
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      statusList: 'statusList',
      workspaceTemplateList: 'workspaceTemplateList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      statusList: { 'type': 'array', 'itemType': 'string' },
      workspaceTemplateList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkspacesShrinkRequest extends $tea.Model {
  maxResults?: number;
  nextToken?: string;
  statusListShrink?: string;
  workspaceTemplateListShrink?: string;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      statusListShrink: 'statusList',
      workspaceTemplateListShrink: 'workspaceTemplateList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      statusListShrink: 'string',
      workspaceTemplateListShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkspacesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  maxResults?: number;
  nextToken?: string;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  workspaces?: ListWorkspacesResponseBodyWorkspaces[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
      workspaces: 'workspaces',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
      workspaces: { 'type': 'array', 'itemType': ListWorkspacesResponseBodyWorkspaces },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkspacesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWorkspacesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWorkspacesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LogPipelineJobRunResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  log?: LogPipelineJobRunResponseBodyLog;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      log: 'log',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      log: LogPipelineJobRunResponseBodyLog,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LogPipelineJobRunResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: LogPipelineJobRunResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: LogPipelineJobRunResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LogVMDeployMachineResponseBody extends $tea.Model {
  deployMachineLog?: LogVMDeployMachineResponseBodyDeployMachineLog;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      deployMachineLog: 'deployMachineLog',
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deployMachineLog: LogVMDeployMachineResponseBodyDeployMachineLog,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LogVMDeployMachineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: LogVMDeployMachineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: LogVMDeployMachineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MergeMergeRequestRequest extends $tea.Model {
  accessToken?: string;
  mergeMessage?: string;
  mergeType?: string;
  removeSourceBranch?: boolean;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      mergeMessage: 'mergeMessage',
      mergeType: 'mergeType',
      removeSourceBranch: 'removeSourceBranch',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      mergeMessage: 'string',
      mergeType: 'string',
      removeSourceBranch: 'boolean',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MergeMergeRequestResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: MergeMergeRequestResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: MergeMergeRequestResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MergeMergeRequestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: MergeMergeRequestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: MergeMergeRequestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PassPipelineValidateResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PassPipelineValidateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PassPipelineValidateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PassPipelineValidateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefusePipelineValidateResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefusePipelineValidateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RefusePipelineValidateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RefusePipelineValidateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseWorkspaceResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseWorkspaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ReleaseWorkspaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReleaseWorkspaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReopenMergeRequestRequest extends $tea.Model {
  accessToken?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReopenMergeRequestResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ReopenMergeRequestResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: ReopenMergeRequestResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReopenMergeRequestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ReopenMergeRequestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReopenMergeRequestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetSshKeyResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  sshKey?: ResetSshKeyResponseBodySshKey;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      sshKey: 'sshKey',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      sshKey: ResetSshKeyResponseBodySshKey,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetSshKeyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ResetSshKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResetSshKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeVMDeployOrderResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeVMDeployOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ResumeVMDeployOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResumeVMDeployOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryPipelineJobRunResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryPipelineJobRunResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RetryPipelineJobRunResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RetryPipelineJobRunResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryVMDeployMachineResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryVMDeployMachineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RetryVMDeployMachineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RetryVMDeployMachineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReviewMergeRequestRequest extends $tea.Model {
  accessToken?: string;
  draftCommentIds?: string[];
  reviewComment?: string;
  reviewOpinion?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      draftCommentIds: 'draftCommentIds',
      reviewComment: 'reviewComment',
      reviewOpinion: 'reviewOpinion',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      draftCommentIds: { 'type': 'array', 'itemType': 'string' },
      reviewComment: 'string',
      reviewOpinion: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReviewMergeRequestResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ReviewMergeRequestResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: ReviewMergeRequestResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReviewMergeRequestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ReviewMergeRequestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReviewMergeRequestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SkipPipelineJobRunResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SkipPipelineJobRunResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SkipPipelineJobRunResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SkipPipelineJobRunResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SkipVMDeployMachineResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SkipVMDeployMachineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SkipVMDeployMachineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SkipVMDeployMachineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartPipelineRunRequest extends $tea.Model {
  params?: string;
  static names(): { [key: string]: string } {
    return {
      params: 'params',
    };
  }

  static types(): { [key: string]: any } {
    return {
      params: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartPipelineRunResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  pipelineRunId?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      pipelineRunId: 'pipelineRunId',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      pipelineRunId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartPipelineRunResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StartPipelineRunResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartPipelineRunResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopPipelineJobRunResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopPipelineJobRunResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopPipelineJobRunResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopPipelineJobRunResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopPipelineRunResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopPipelineRunResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopPipelineRunResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopPipelineRunResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopVMDeployOrderResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopVMDeployOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopVMDeployOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopVMDeployOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TransferRepositoryRequest extends $tea.Model {
  accessToken?: string;
  groupId?: string;
  organizationId?: string;
  repositoryId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      groupId: 'groupId',
      organizationId: 'organizationId',
      repositoryId: 'repositoryId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      groupId: 'string',
      organizationId: 'string',
      repositoryId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TransferRepositoryResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: TransferRepositoryResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: TransferRepositoryResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TransferRepositoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: TransferRepositoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TransferRepositoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TriggerRepositoryMirrorSyncRequest extends $tea.Model {
  accessToken?: string;
  account?: string;
  organizationId?: string;
  token?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      account: 'account',
      organizationId: 'organizationId',
      token: 'token',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      account: 'string',
      organizationId: 'string',
      token: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TriggerRepositoryMirrorSyncResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: TriggerRepositoryMirrorSyncResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: TriggerRepositoryMirrorSyncResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TriggerRepositoryMirrorSyncResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: TriggerRepositoryMirrorSyncResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TriggerRepositoryMirrorSyncResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAppMemberRequest extends $tea.Model {
  player?: UpdateAppMemberRequestPlayer;
  roleNames?: string[];
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      player: 'player',
      roleNames: 'roleNames',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      player: UpdateAppMemberRequestPlayer,
      roleNames: { 'type': 'array', 'itemType': 'string' },
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAppMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: string;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateApplicationRequest extends $tea.Model {
  ownerAccountId?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerAccountId: 'ownerAccountId',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerAccountId: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateApplicationResponseBody extends $tea.Model {
  creatorAccountId?: string;
  description?: string;
  gmtCreate?: string;
  name?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      creatorAccountId: 'creatorAccountId',
      description: 'description',
      gmtCreate: 'gmtCreate',
      name: 'name',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorAccountId: 'string',
      description: 'string',
      gmtCreate: 'string',
      name: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateApplicationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateApplicationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateApplicationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunRequest extends $tea.Model {
  accessToken?: string;
  annotations?: UpdateCheckRunRequestAnnotations[];
  completedAt?: string;
  conclusion?: string;
  detailsUrl?: string;
  externalId?: string;
  name?: string;
  output?: UpdateCheckRunRequestOutput;
  startedAt?: string;
  status?: string;
  checkRunId?: number;
  organizationId?: string;
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      annotations: 'annotations',
      completedAt: 'completedAt',
      conclusion: 'conclusion',
      detailsUrl: 'detailsUrl',
      externalId: 'externalId',
      name: 'name',
      output: 'output',
      startedAt: 'startedAt',
      status: 'status',
      checkRunId: 'checkRunId',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      annotations: { 'type': 'array', 'itemType': UpdateCheckRunRequestAnnotations },
      completedAt: 'string',
      conclusion: 'string',
      detailsUrl: 'string',
      externalId: 'string',
      name: 'string',
      output: UpdateCheckRunRequestOutput,
      startedAt: 'string',
      status: 'string',
      checkRunId: 'number',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: UpdateCheckRunResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdateCheckRunResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCheckRunResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCheckRunResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileRequest extends $tea.Model {
  accessToken?: string;
  branchName?: string;
  commitMessage?: string;
  content?: string;
  encoding?: string;
  newPath?: string;
  oldPath?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      branchName: 'branchName',
      commitMessage: 'commitMessage',
      content: 'content',
      encoding: 'encoding',
      newPath: 'newPath',
      oldPath: 'oldPath',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      branchName: 'string',
      commitMessage: 'string',
      content: 'string',
      encoding: 'string',
      newPath: 'string',
      oldPath: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: UpdateFileResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdateFileResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFlowTagRequest extends $tea.Model {
  color?: string;
  flowTagGroupId?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      color: 'color',
      flowTagGroupId: 'flowTagGroupId',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      color: 'string',
      flowTagGroupId: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFlowTagResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFlowTagResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateFlowTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateFlowTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFlowTagGroupRequest extends $tea.Model {
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFlowTagGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFlowTagGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateFlowTagGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateFlowTagGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGroupRequest extends $tea.Model {
  accessToken?: string;
  avatarUrl?: string;
  description?: string;
  name?: string;
  path?: string;
  pathWithNamespace?: string;
  visibilityLevel?: number;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      avatarUrl: 'avatarUrl',
      description: 'description',
      name: 'name',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      visibilityLevel: 'visibilityLevel',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      avatarUrl: 'string',
      description: 'string',
      name: 'string',
      path: 'string',
      pathWithNamespace: 'string',
      visibilityLevel: 'number',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: UpdateGroupResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdateGroupResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGroupMemberRequest extends $tea.Model {
  accessToken?: string;
  aliyunPk?: string;
  accessLevel?: number;
  memberType?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      aliyunPk: 'aliyunPk',
      accessLevel: 'accessLevel',
      memberType: 'memberType',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      aliyunPk: 'string',
      accessLevel: 'number',
      memberType: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGroupMemberResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: UpdateGroupMemberResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdateGroupMemberResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGroupMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGroupMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGroupMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHostGroupRequest extends $tea.Model {
  aliyunRegion?: string;
  ecsLabelKey?: string;
  ecsLabelValue?: string;
  ecsType?: string;
  envId?: string;
  machineInfos?: string;
  name?: string;
  serviceConnectionId?: number;
  tagIds?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunRegion: 'aliyunRegion',
      ecsLabelKey: 'ecsLabelKey',
      ecsLabelValue: 'ecsLabelValue',
      ecsType: 'ecsType',
      envId: 'envId',
      machineInfos: 'machineInfos',
      name: 'name',
      serviceConnectionId: 'serviceConnectionId',
      tagIds: 'tagIds',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunRegion: 'string',
      ecsLabelKey: 'string',
      ecsLabelValue: 'string',
      ecsType: 'string',
      envId: 'string',
      machineInfos: 'string',
      name: 'string',
      serviceConnectionId: 'number',
      tagIds: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHostGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHostGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateHostGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateHostGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMergeRequestRequest extends $tea.Model {
  accessToken?: string;
  description?: string;
  title?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      description: 'description',
      title: 'title',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      description: 'string',
      title: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMergeRequestResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: UpdateMergeRequestResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdateMergeRequestResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMergeRequestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateMergeRequestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateMergeRequestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMergeRequestPersonnelRequest extends $tea.Model {
  accessToken?: string;
  newUserIdList?: string[];
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      newUserIdList: 'newUserIdList',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      newUserIdList: { 'type': 'array', 'itemType': 'string' },
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMergeRequestPersonnelResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: UpdateMergeRequestPersonnelResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdateMergeRequestPersonnelResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMergeRequestPersonnelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateMergeRequestPersonnelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateMergeRequestPersonnelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineRequest extends $tea.Model {
  content?: string;
  name?: string;
  pipelineId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'content',
      name: 'name',
      pipelineId: 'pipelineId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      name: 'string',
      pipelineId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdatePipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdatePipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineBaseInfoRequest extends $tea.Model {
  envId?: number;
  pipelineName?: string;
  tagList?: string;
  static names(): { [key: string]: string } {
    return {
      envId: 'envId',
      pipelineName: 'pipelineName',
      tagList: 'tagList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      envId: 'number',
      pipelineName: 'string',
      tagList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineBaseInfoResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineBaseInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdatePipelineBaseInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdatePipelineBaseInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineGroupRequest extends $tea.Model {
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdatePipelineGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdatePipelineGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectFieldRequest extends $tea.Model {
  statusIdentifier?: string;
  updateBasicFieldRequestList?: UpdateProjectFieldRequestUpdateBasicFieldRequestList[];
  updateForOpenApiList?: UpdateProjectFieldRequestUpdateForOpenApiList[];
  static names(): { [key: string]: string } {
    return {
      statusIdentifier: 'statusIdentifier',
      updateBasicFieldRequestList: 'updateBasicFieldRequestList',
      updateForOpenApiList: 'updateForOpenApiList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      statusIdentifier: 'string',
      updateBasicFieldRequestList: { 'type': 'array', 'itemType': UpdateProjectFieldRequestUpdateBasicFieldRequestList },
      updateForOpenApiList: { 'type': 'array', 'itemType': UpdateProjectFieldRequestUpdateForOpenApiList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectFieldResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  project?: UpdateProjectFieldResponseBodyProject;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      project: 'project',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      project: UpdateProjectFieldResponseBodyProject,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectFieldResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateProjectFieldResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateProjectFieldResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectLabelRequest extends $tea.Model {
  accessToken?: string;
  color?: string;
  description?: string;
  name?: string;
  organizationId?: string;
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      color: 'color',
      description: 'description',
      name: 'name',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      color: 'string',
      description: 'string',
      name: 'string',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectLabelResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: UpdateProjectLabelResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdateProjectLabelResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectLabelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateProjectLabelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateProjectLabelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectMemberRequest extends $tea.Model {
  roleIdentifier?: string;
  targetIdentifier?: string;
  targetType?: string;
  userIdentifier?: string;
  userType?: string;
  static names(): { [key: string]: string } {
    return {
      roleIdentifier: 'roleIdentifier',
      targetIdentifier: 'targetIdentifier',
      targetType: 'targetType',
      userIdentifier: 'userIdentifier',
      userType: 'userType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleIdentifier: 'string',
      targetIdentifier: 'string',
      targetType: 'string',
      userIdentifier: 'string',
      userType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectMemberResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  member?: UpdateProjectMemberResponseBodyMember;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      member: 'member',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      member: UpdateProjectMemberResponseBodyMember,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateProjectMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateProjectMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesRequest extends $tea.Model {
  accessToken?: string;
  allowMergeRoles?: number[];
  allowMergeUserIds?: string[];
  allowPushRoles?: number[];
  allowPushUserIds?: string[];
  branch?: string;
  id?: number;
  mergeRequestSetting?: UpdateProtectedBranchesRequestMergeRequestSetting;
  testSettingDTO?: UpdateProtectedBranchesRequestTestSettingDTO;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      allowMergeRoles: 'allowMergeRoles',
      allowMergeUserIds: 'allowMergeUserIds',
      allowPushRoles: 'allowPushRoles',
      allowPushUserIds: 'allowPushUserIds',
      branch: 'branch',
      id: 'id',
      mergeRequestSetting: 'mergeRequestSetting',
      testSettingDTO: 'testSettingDTO',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      allowMergeRoles: { 'type': 'array', 'itemType': 'number' },
      allowMergeUserIds: { 'type': 'array', 'itemType': 'string' },
      allowPushRoles: { 'type': 'array', 'itemType': 'number' },
      allowPushUserIds: { 'type': 'array', 'itemType': 'string' },
      branch: 'string',
      id: 'number',
      mergeRequestSetting: UpdateProtectedBranchesRequestMergeRequestSetting,
      testSettingDTO: UpdateProtectedBranchesRequestTestSettingDTO,
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: UpdateProtectedBranchesResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdateProtectedBranchesResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateProtectedBranchesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateProtectedBranchesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePushReviewOnOffRequest extends $tea.Model {
  organizationId?: string;
  trunkMode?: boolean;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'organizationId',
      trunkMode: 'trunkMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
      trunkMode: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePushReviewOnOffResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: UpdatePushReviewOnOffResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdatePushReviewOnOffResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePushReviewOnOffResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdatePushReviewOnOffResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdatePushReviewOnOffResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePushRuleRequest extends $tea.Model {
  accessToken?: string;
  ruleInfos?: UpdatePushRuleRequestRuleInfos[];
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      ruleInfos: 'ruleInfos',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      ruleInfos: { 'type': 'array', 'itemType': UpdatePushRuleRequestRuleInfos },
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePushRuleResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: UpdatePushRuleResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdatePushRuleResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePushRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdatePushRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdatePushRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryRequest extends $tea.Model {
  accessToken?: string;
  adminSettingLanguage?: string;
  avatar?: string;
  buildsEnabled?: boolean;
  checkEmail?: boolean;
  defaultBranch?: string;
  description?: string;
  id?: number;
  issuesEnabled?: boolean;
  mergeRequestsEnabled?: boolean;
  name?: string;
  openCloneDownloadControl?: boolean;
  path?: string;
  projectCloneDownloadMethodList?: UpdateRepositoryRequestProjectCloneDownloadMethodList[];
  projectCloneDownloadRoleList?: UpdateRepositoryRequestProjectCloneDownloadRoleList[];
  snippetsEnabled?: boolean;
  visibilityLevel?: number;
  wikiEnabled?: boolean;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      adminSettingLanguage: 'adminSettingLanguage',
      avatar: 'avatar',
      buildsEnabled: 'buildsEnabled',
      checkEmail: 'checkEmail',
      defaultBranch: 'defaultBranch',
      description: 'description',
      id: 'id',
      issuesEnabled: 'issuesEnabled',
      mergeRequestsEnabled: 'mergeRequestsEnabled',
      name: 'name',
      openCloneDownloadControl: 'openCloneDownloadControl',
      path: 'path',
      projectCloneDownloadMethodList: 'projectCloneDownloadMethodList',
      projectCloneDownloadRoleList: 'projectCloneDownloadRoleList',
      snippetsEnabled: 'snippetsEnabled',
      visibilityLevel: 'visibilityLevel',
      wikiEnabled: 'wikiEnabled',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      adminSettingLanguage: 'string',
      avatar: 'string',
      buildsEnabled: 'boolean',
      checkEmail: 'boolean',
      defaultBranch: 'string',
      description: 'string',
      id: 'number',
      issuesEnabled: 'boolean',
      mergeRequestsEnabled: 'boolean',
      name: 'string',
      openCloneDownloadControl: 'boolean',
      path: 'string',
      projectCloneDownloadMethodList: { 'type': 'array', 'itemType': UpdateRepositoryRequestProjectCloneDownloadMethodList },
      projectCloneDownloadRoleList: { 'type': 'array', 'itemType': UpdateRepositoryRequestProjectCloneDownloadRoleList },
      snippetsEnabled: 'boolean',
      visibilityLevel: 'number',
      wikiEnabled: 'boolean',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: UpdateRepositoryResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdateRepositoryResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateRepositoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateRepositoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryMemberRequest extends $tea.Model {
  accessToken?: string;
  accessLevel?: number;
  expireAt?: string;
  memberType?: string;
  relatedId?: string;
  relatedInfos?: UpdateRepositoryMemberRequestRelatedInfos[];
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      accessLevel: 'accessLevel',
      expireAt: 'expireAt',
      memberType: 'memberType',
      relatedId: 'relatedId',
      relatedInfos: 'relatedInfos',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      accessLevel: 'number',
      expireAt: 'string',
      memberType: 'string',
      relatedId: 'string',
      relatedInfos: { 'type': 'array', 'itemType': UpdateRepositoryMemberRequestRelatedInfos },
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryMemberResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: UpdateRepositoryMemberResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdateRepositoryMemberResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateRepositoryMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateRepositoryMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateResourceMemberRequest extends $tea.Model {
  roleName?: string;
  static names(): { [key: string]: string } {
    return {
      roleName: 'roleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateResourceMemberResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateResourceMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateResourceMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateResourceMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseRequest extends $tea.Model {
  updateWorkitemPropertyRequest?: UpdateTestCaseRequestUpdateWorkitemPropertyRequest[];
  static names(): { [key: string]: string } {
    return {
      updateWorkitemPropertyRequest: 'updateWorkitemPropertyRequest',
    };
  }

  static types(): { [key: string]: any } {
    return {
      updateWorkitemPropertyRequest: { 'type': 'array', 'itemType': UpdateTestCaseRequestUpdateWorkitemPropertyRequest },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponseBody extends $tea.Model {
  testcase?: UpdateTestCaseResponseBodyTestcase;
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      testcase: 'Testcase',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      testcase: UpdateTestCaseResponseBodyTestcase,
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTestCaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTestCaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestResultRequest extends $tea.Model {
  executor?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      executor: 'executor',
      status: 'status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      executor: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestResultResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestResultResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTestResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTestResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateVariableGroupRequest extends $tea.Model {
  description?: string;
  name?: string;
  variables?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'description',
      name: 'name',
      variables: 'variables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      variables: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateVariableGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateVariableGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateVariableGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateVariableGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkItemRequest extends $tea.Model {
  fieldType?: string;
  identifier?: string;
  propertyKey?: string;
  propertyValue?: string;
  static names(): { [key: string]: string } {
    return {
      fieldType: 'fieldType',
      identifier: 'identifier',
      propertyKey: 'propertyKey',
      propertyValue: 'propertyValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldType: 'string',
      identifier: 'string',
      propertyKey: 'string',
      propertyValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkItemResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  workitem?: UpdateWorkItemResponseBodyWorkitem;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
      workitem: 'workitem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      workitem: UpdateWorkItemResponseBodyWorkitem,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkItemResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateWorkItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateWorkItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkitemCommentRequest extends $tea.Model {
  commentId?: number;
  content?: string;
  formatType?: string;
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      commentId: 'commentId',
      content: 'content',
      formatType: 'formatType',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commentId: 'number',
      content: 'string',
      formatType: 'string',
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkitemCommentResponseBody extends $tea.Model {
  comment?: UpdateWorkitemCommentResponseBodyComment;
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  success?: string;
  static names(): { [key: string]: string } {
    return {
      comment: 'comment',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: UpdateWorkitemCommentResponseBodyComment,
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkitemCommentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateWorkitemCommentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateWorkitemCommentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkitemFieldRequest extends $tea.Model {
  updateWorkitemPropertyRequest?: UpdateWorkitemFieldRequestUpdateWorkitemPropertyRequest[];
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      updateWorkitemPropertyRequest: 'updateWorkitemPropertyRequest',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      updateWorkitemPropertyRequest: { 'type': 'array', 'itemType': UpdateWorkitemFieldRequestUpdateWorkitemPropertyRequest },
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkitemFieldResponseBody extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  success?: boolean;
  workitem?: UpdateWorkitemFieldResponseBodyWorkitem;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
      workitem: 'workitem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
      workitem: UpdateWorkitemFieldResponseBodyWorkitem,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkitemFieldResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateWorkitemFieldResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateWorkitemFieldResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WorkitemAttachmentCreateRequest extends $tea.Model {
  fileKey?: string;
  originalFilename?: string;
  static names(): { [key: string]: string } {
    return {
      fileKey: 'fileKey',
      originalFilename: 'originalFilename',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileKey: 'string',
      originalFilename: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WorkitemAttachmentCreateResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WorkitemAttachmentCreateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: WorkitemAttachmentCreateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: WorkitemAttachmentCreateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGroupMemberResponseBodyResult extends $tea.Model {
  accessLevel?: number;
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  sourceId?: number;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      sourceId: 'sourceId',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      sourceId: 'number',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddRepositoryMemberResponseBodyResult extends $tea.Model {
  accessLevel?: number;
  avatarUrl?: string;
  email?: string;
  id?: number;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      state: 'state',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWebhookResponseBodyResult extends $tea.Model {
  createdAt?: string;
  description?: string;
  enableSslVerification?: boolean;
  id?: number;
  lastTestResult?: string;
  mergeRequestsEvents?: boolean;
  noteEvents?: boolean;
  pushEvents?: boolean;
  repositoryId?: number;
  secretToken?: string;
  tagPushEvents?: boolean;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      createdAt: 'createdAt',
      description: 'description',
      enableSslVerification: 'enableSslVerification',
      id: 'id',
      lastTestResult: 'lastTestResult',
      mergeRequestsEvents: 'mergeRequestsEvents',
      noteEvents: 'noteEvents',
      pushEvents: 'pushEvents',
      repositoryId: 'repositoryId',
      secretToken: 'secretToken',
      tagPushEvents: 'tagPushEvents',
      url: 'url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdAt: 'string',
      description: 'string',
      enableSslVerification: 'boolean',
      id: 'number',
      lastTestResult: 'string',
      mergeRequestsEvents: 'boolean',
      noteEvents: 'boolean',
      pushEvents: 'boolean',
      repositoryId: 'number',
      secretToken: 'string',
      tagPushEvents: 'boolean',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseMergeRequestResponseBodyResult extends $tea.Model {
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAppMembersRequestPlayerList extends $tea.Model {
  id?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBranchResponseBodyResultCommit extends $tea.Model {
  authorEmail?: string;
  authorName?: string;
  authoredDate?: string;
  committedDate?: string;
  committerEmail?: string;
  committerName?: string;
  createdAt?: string;
  id?: string;
  message?: string;
  parentIds?: string[];
  shortId?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      authoredDate: 'authoredDate',
      committedDate: 'committedDate',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorEmail: 'string',
      authorName: 'string',
      authoredDate: 'string',
      committedDate: 'string',
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBranchResponseBodyResult extends $tea.Model {
  commit?: CreateBranchResponseBodyResultCommit;
  name?: string;
  protected?: boolean;
  static names(): { [key: string]: string } {
    return {
      commit: 'commit',
      name: 'name',
      protected: 'protected',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commit: CreateBranchResponseBodyResultCommit,
      name: 'string',
      protected: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunRequestAnnotations extends $tea.Model {
  annotationLevel?: string;
  endColumn?: number;
  endLine?: number;
  message?: string;
  path?: string;
  rawDetails?: string;
  startColumn?: number;
  startLine?: number;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      annotationLevel: 'annotationLevel',
      endColumn: 'endColumn',
      endLine: 'endLine',
      message: 'message',
      path: 'path',
      rawDetails: 'rawDetails',
      startColumn: 'startColumn',
      startLine: 'startLine',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotationLevel: 'string',
      endColumn: 'number',
      endLine: 'number',
      message: 'string',
      path: 'string',
      rawDetails: 'string',
      startColumn: 'number',
      startLine: 'number',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunRequestOutputImages extends $tea.Model {
  alt?: string;
  caption?: string;
  imageUrl?: string;
  static names(): { [key: string]: string } {
    return {
      alt: 'alt',
      caption: 'caption',
      imageUrl: 'imageUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alt: 'string',
      caption: 'string',
      imageUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunRequestOutput extends $tea.Model {
  images?: CreateCheckRunRequestOutputImages[];
  summary?: string;
  text?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      images: 'images',
      summary: 'summary',
      text: 'text',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      images: { 'type': 'array', 'itemType': CreateCheckRunRequestOutputImages },
      summary: 'string',
      text: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunResponseBodyResultAnnotations extends $tea.Model {
  annotationLevel?: string;
  endColumn?: number;
  endLine?: number;
  id?: number;
  message?: string;
  path?: string;
  rawDetails?: string;
  startColumn?: number;
  startLine?: number;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      annotationLevel: 'annotationLevel',
      endColumn: 'endColumn',
      endLine: 'endLine',
      id: 'id',
      message: 'message',
      path: 'path',
      rawDetails: 'rawDetails',
      startColumn: 'startColumn',
      startLine: 'startLine',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotationLevel: 'string',
      endColumn: 'number',
      endLine: 'number',
      id: 'number',
      message: 'string',
      path: 'string',
      rawDetails: 'string',
      startColumn: 'number',
      startLine: 'number',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunResponseBodyResultCheckSuite extends $tea.Model {
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunResponseBodyResultOutputImages extends $tea.Model {
  alt?: string;
  caption?: string;
  imageUrl?: string;
  static names(): { [key: string]: string } {
    return {
      alt: 'alt',
      caption: 'caption',
      imageUrl: 'imageUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alt: 'string',
      caption: 'string',
      imageUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunResponseBodyResultOutput extends $tea.Model {
  images?: CreateCheckRunResponseBodyResultOutputImages[];
  summary?: string;
  text?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      images: 'images',
      summary: 'summary',
      text: 'text',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      images: { 'type': 'array', 'itemType': CreateCheckRunResponseBodyResultOutputImages },
      summary: 'string',
      text: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunResponseBodyResultWriter extends $tea.Model {
  id?: string;
  logoUrl?: string;
  name?: string;
  slug?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      logoUrl: 'logoUrl',
      name: 'name',
      slug: 'slug',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      logoUrl: 'string',
      name: 'string',
      slug: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunResponseBodyResult extends $tea.Model {
  annotations?: CreateCheckRunResponseBodyResultAnnotations[];
  checkSuite?: CreateCheckRunResponseBodyResultCheckSuite;
  completedAt?: string;
  conclusion?: string;
  createdAt?: string;
  detailsUrl?: string;
  externalId?: string;
  headSha?: string;
  id?: number;
  name?: string;
  output?: CreateCheckRunResponseBodyResultOutput;
  startedAt?: string;
  status?: string;
  updatedAt?: string;
  writer?: CreateCheckRunResponseBodyResultWriter;
  static names(): { [key: string]: string } {
    return {
      annotations: 'annotations',
      checkSuite: 'checkSuite',
      completedAt: 'completedAt',
      conclusion: 'conclusion',
      createdAt: 'createdAt',
      detailsUrl: 'detailsUrl',
      externalId: 'externalId',
      headSha: 'headSha',
      id: 'id',
      name: 'name',
      output: 'output',
      startedAt: 'startedAt',
      status: 'status',
      updatedAt: 'updatedAt',
      writer: 'writer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotations: { 'type': 'array', 'itemType': CreateCheckRunResponseBodyResultAnnotations },
      checkSuite: CreateCheckRunResponseBodyResultCheckSuite,
      completedAt: 'string',
      conclusion: 'string',
      createdAt: 'string',
      detailsUrl: 'string',
      externalId: 'string',
      headSha: 'string',
      id: 'number',
      name: 'string',
      output: CreateCheckRunResponseBodyResultOutput,
      startedAt: 'string',
      status: 'string',
      updatedAt: 'string',
      writer: CreateCheckRunResponseBodyResultWriter,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommentResponseBodyResultAuthor extends $tea.Model {
  aliyunPk?: string;
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommentResponseBodyResultRelatedPatchSet extends $tea.Model {
  commitId?: string;
  createdAt?: string;
  patchSetBizId?: string;
  patchSetName?: string;
  patchSetNo?: string;
  relatedMergeItemType?: string;
  shortId?: string;
  static names(): { [key: string]: string } {
    return {
      commitId: 'commitId',
      createdAt: 'createdAt',
      patchSetBizId: 'patchSetBizId',
      patchSetName: 'patchSetName',
      patchSetNo: 'patchSetNo',
      relatedMergeItemType: 'relatedMergeItemType',
      shortId: 'shortId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commitId: 'string',
      createdAt: 'string',
      patchSetBizId: 'string',
      patchSetName: 'string',
      patchSetNo: 'string',
      relatedMergeItemType: 'string',
      shortId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommentResponseBodyResult extends $tea.Model {
  author?: CreateCommentResponseBodyResultAuthor;
  commentBizId?: string;
  commentTime?: string;
  commentType?: string;
  content?: string;
  deleted?: boolean;
  filePath?: string;
  lastEditTime?: string;
  lineNumber?: string;
  parentCommentBizId?: string;
  relatedPatchSet?: CreateCommentResponseBodyResultRelatedPatchSet;
  resolved?: boolean;
  rootCommentBizId?: string;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      commentBizId: 'commentBizId',
      commentTime: 'commentTime',
      commentType: 'commentType',
      content: 'content',
      deleted: 'deleted',
      filePath: 'filePath',
      lastEditTime: 'lastEditTime',
      lineNumber: 'lineNumber',
      parentCommentBizId: 'parentCommentBizId',
      relatedPatchSet: 'relatedPatchSet',
      resolved: 'resolved',
      rootCommentBizId: 'rootCommentBizId',
      state: 'state',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: CreateCommentResponseBodyResultAuthor,
      commentBizId: 'string',
      commentTime: 'string',
      commentType: 'string',
      content: 'string',
      deleted: 'boolean',
      filePath: 'string',
      lastEditTime: 'string',
      lineNumber: 'string',
      parentCommentBizId: 'string',
      relatedPatchSet: CreateCommentResponseBodyResultRelatedPatchSet,
      resolved: 'boolean',
      rootCommentBizId: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitStatusResponseBodyResultCreator extends $tea.Model {
  aliyunPk?: number;
  avatarUrl?: string;
  login?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      avatarUrl: 'avatarUrl',
      login: 'login',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'number',
      avatarUrl: 'string',
      login: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitStatusResponseBodyResult extends $tea.Model {
  context?: string;
  creator?: CreateCommitStatusResponseBodyResultCreator;
  description?: string;
  id?: number;
  sha?: string;
  state?: string;
  targetUrl?: string;
  static names(): { [key: string]: string } {
    return {
      context: 'context',
      creator: 'creator',
      description: 'description',
      id: 'id',
      sha: 'sha',
      state: 'state',
      targetUrl: 'targetUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      context: 'string',
      creator: CreateCommitStatusResponseBodyResultCreator,
      description: 'string',
      id: 'number',
      sha: 'string',
      state: 'string',
      targetUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitWithMultipleFilesRequestActions extends $tea.Model {
  action?: string;
  content?: string;
  filePath?: string;
  previousPath?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'action',
      content: 'content',
      filePath: 'filePath',
      previousPath: 'previousPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      content: 'string',
      filePath: 'string',
      previousPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitWithMultipleFilesResponseBodyResultAuthor extends $tea.Model {
  aliyunPk?: string;
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  state?: string;
  username?: string;
  websiteUrl?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
      websiteUrl: 'websiteUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
      websiteUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitWithMultipleFilesResponseBodyResultCommitter extends $tea.Model {
  aliyunPk?: string;
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  state?: string;
  username?: string;
  websiteUrl?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
      websiteUrl: 'websiteUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
      websiteUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitWithMultipleFilesResponseBodyResult extends $tea.Model {
  author?: CreateCommitWithMultipleFilesResponseBodyResultAuthor;
  authorEmail?: string;
  authorName?: string;
  authoredDate?: string;
  committedDate?: string;
  committer?: CreateCommitWithMultipleFilesResponseBodyResultCommitter;
  committerEmail?: string;
  committerName?: string;
  createdAt?: string;
  id?: string;
  message?: string;
  parentIds?: string[];
  shortId?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      authoredDate: 'authoredDate',
      committedDate: 'committedDate',
      committer: 'committer',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: CreateCommitWithMultipleFilesResponseBodyResultAuthor,
      authorEmail: 'string',
      authorName: 'string',
      authoredDate: 'string',
      committedDate: 'string',
      committer: CreateCommitWithMultipleFilesResponseBodyResultCommitter,
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeployKeyResponseBodyResult extends $tea.Model {
  createdAt?: string;
  fingerprint?: string;
  id?: number;
  key?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      createdAt: 'createdAt',
      fingerprint: 'fingerprint',
      id: 'id',
      key: 'key',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdAt: 'string',
      fingerprint: 'string',
      id: 'number',
      key: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileResponseBodyResult extends $tea.Model {
  branchName?: string;
  filePath?: string;
  static names(): { [key: string]: string } {
    return {
      branchName: 'branchName',
      filePath: 'filePath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      branchName: 'string',
      filePath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMergeRequestResponseBodyResultAuthor extends $tea.Model {
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMergeRequestResponseBodyResultReviewers extends $tea.Model {
  avatarUrl?: string;
  email?: string;
  hasReviewed?: boolean;
  id?: number;
  name?: string;
  reviewOpinionStatus?: string;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      hasReviewed: 'hasReviewed',
      id: 'id',
      name: 'name',
      reviewOpinionStatus: 'reviewOpinionStatus',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      hasReviewed: 'boolean',
      id: 'number',
      name: 'string',
      reviewOpinionStatus: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMergeRequestResponseBodyResultSubscribers extends $tea.Model {
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMergeRequestResponseBodyResult extends $tea.Model {
  ahead?: number;
  allRequirementsPass?: boolean;
  author?: CreateMergeRequestResponseBodyResultAuthor;
  behind?: number;
  createFrom?: string;
  createTime?: string;
  description?: string;
  detailUrl?: string;
  localId?: number;
  mrBizId?: string;
  mrType?: string;
  projectId?: number;
  reviewers?: CreateMergeRequestResponseBodyResultReviewers[];
  sourceBranch?: string;
  sourceProjectId?: number;
  status?: string;
  subscribers?: CreateMergeRequestResponseBodyResultSubscribers[];
  supportMergeFastForwardOnly?: boolean;
  targetBranch?: string;
  targetProjectId?: number;
  title?: string;
  updateTime?: string;
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      ahead: 'ahead',
      allRequirementsPass: 'allRequirementsPass',
      author: 'author',
      behind: 'behind',
      createFrom: 'createFrom',
      createTime: 'createTime',
      description: 'description',
      detailUrl: 'detailUrl',
      localId: 'localId',
      mrBizId: 'mrBizId',
      mrType: 'mrType',
      projectId: 'projectId',
      reviewers: 'reviewers',
      sourceBranch: 'sourceBranch',
      sourceProjectId: 'sourceProjectId',
      status: 'status',
      subscribers: 'subscribers',
      supportMergeFastForwardOnly: 'supportMergeFastForwardOnly',
      targetBranch: 'targetBranch',
      targetProjectId: 'targetProjectId',
      title: 'title',
      updateTime: 'updateTime',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ahead: 'number',
      allRequirementsPass: 'boolean',
      author: CreateMergeRequestResponseBodyResultAuthor,
      behind: 'number',
      createFrom: 'string',
      createTime: 'string',
      description: 'string',
      detailUrl: 'string',
      localId: 'number',
      mrBizId: 'string',
      mrType: 'string',
      projectId: 'number',
      reviewers: { 'type': 'array', 'itemType': CreateMergeRequestResponseBodyResultReviewers },
      sourceBranch: 'string',
      sourceProjectId: 'number',
      status: 'string',
      subscribers: { 'type': 'array', 'itemType': CreateMergeRequestResponseBodyResultSubscribers },
      supportMergeFastForwardOnly: 'boolean',
      targetBranch: 'string',
      targetProjectId: 'number',
      title: 'string',
      updateTime: 'string',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOAuthTokenResponseBodyResult extends $tea.Model {
  accessToken?: string;
  id?: string;
  scope?: string;
  tokenType?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      id: 'id',
      scope: 'scope',
      tokenType: 'tokenType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      id: 'string',
      scope: 'string',
      tokenType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePipelineGroupResponseBodyPipelineGroup extends $tea.Model {
  id?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectResponseBodyProject extends $tea.Model {
  categoryIdentifier?: string;
  creator?: string;
  customCode?: string;
  description?: string;
  gmtCreate?: number;
  gmtModified?: number;
  icon?: string;
  identifier?: string;
  logicalStatus?: string;
  modifier?: string;
  name?: string;
  organizationIdentifier?: string;
  scope?: string;
  statusIdentifier?: string;
  statusStageIdentifier?: string;
  typeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      customCode: 'customCode',
      description: 'description',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      icon: 'icon',
      identifier: 'identifier',
      logicalStatus: 'logicalStatus',
      modifier: 'modifier',
      name: 'name',
      organizationIdentifier: 'organizationIdentifier',
      scope: 'scope',
      statusIdentifier: 'statusIdentifier',
      statusStageIdentifier: 'statusStageIdentifier',
      typeIdentifier: 'typeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryIdentifier: 'string',
      creator: 'string',
      customCode: 'string',
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      icon: 'string',
      identifier: 'string',
      logicalStatus: 'string',
      modifier: 'string',
      name: 'string',
      organizationIdentifier: 'string',
      scope: 'string',
      statusIdentifier: 'string',
      statusStageIdentifier: 'string',
      typeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectLabelResponseBodyResult extends $tea.Model {
  color?: string;
  description?: string;
  id?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      color: 'color',
      description: 'description',
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      color: 'string',
      description: 'string',
      id: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchRequestMergeRequestSetting extends $tea.Model {
  allowMergeRequestRoles?: number[];
  defaultAssignees?: string[];
  isAllowSelfApproval?: boolean;
  isRequireDiscussionProcessed?: boolean;
  isRequired?: boolean;
  isResetApprovalWhenNewPush?: boolean;
  minimumApproval?: number;
  mrMode?: string;
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      allowMergeRequestRoles: 'allowMergeRequestRoles',
      defaultAssignees: 'defaultAssignees',
      isAllowSelfApproval: 'isAllowSelfApproval',
      isRequireDiscussionProcessed: 'isRequireDiscussionProcessed',
      isRequired: 'isRequired',
      isResetApprovalWhenNewPush: 'isResetApprovalWhenNewPush',
      minimumApproval: 'minimumApproval',
      mrMode: 'mrMode',
      whiteList: 'whiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowMergeRequestRoles: { 'type': 'array', 'itemType': 'number' },
      defaultAssignees: { 'type': 'array', 'itemType': 'string' },
      isAllowSelfApproval: 'boolean',
      isRequireDiscussionProcessed: 'boolean',
      isRequired: 'boolean',
      isResetApprovalWhenNewPush: 'boolean',
      minimumApproval: 'number',
      mrMode: 'string',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchRequestTestSettingDTOCheckConfigCheckItems extends $tea.Model {
  isRequired?: boolean;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      isRequired: 'isRequired',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isRequired: 'boolean',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchRequestTestSettingDTOCheckConfig extends $tea.Model {
  checkItems?: CreateProtectdBranchRequestTestSettingDTOCheckConfigCheckItems[];
  static names(): { [key: string]: string } {
    return {
      checkItems: 'checkItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkItems: { 'type': 'array', 'itemType': CreateProtectdBranchRequestTestSettingDTOCheckConfigCheckItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchRequestTestSettingDTOCheckTaskQualityConfig extends $tea.Model {
  bizNo?: string;
  enabled?: boolean;
  message?: string;
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      bizNo: 'bizNo',
      enabled: 'enabled',
      message: 'message',
      taskName: 'taskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizNo: 'string',
      enabled: 'boolean',
      message: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchRequestTestSettingDTOCodeGuidelinesDetection extends $tea.Model {
  enabled?: boolean;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'enabled',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchRequestTestSettingDTOSensitiveInfoDetection extends $tea.Model {
  enabled?: boolean;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'enabled',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchRequestTestSettingDTO extends $tea.Model {
  checkConfig?: CreateProtectdBranchRequestTestSettingDTOCheckConfig;
  checkTaskQualityConfig?: CreateProtectdBranchRequestTestSettingDTOCheckTaskQualityConfig;
  codeGuidelinesDetection?: CreateProtectdBranchRequestTestSettingDTOCodeGuidelinesDetection;
  isRequired?: boolean;
  sensitiveInfoDetection?: CreateProtectdBranchRequestTestSettingDTOSensitiveInfoDetection;
  static names(): { [key: string]: string } {
    return {
      checkConfig: 'checkConfig',
      checkTaskQualityConfig: 'checkTaskQualityConfig',
      codeGuidelinesDetection: 'codeGuidelinesDetection',
      isRequired: 'isRequired',
      sensitiveInfoDetection: 'sensitiveInfoDetection',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkConfig: CreateProtectdBranchRequestTestSettingDTOCheckConfig,
      checkTaskQualityConfig: CreateProtectdBranchRequestTestSettingDTOCheckTaskQualityConfig,
      codeGuidelinesDetection: CreateProtectdBranchRequestTestSettingDTOCodeGuidelinesDetection,
      isRequired: 'boolean',
      sensitiveInfoDetection: CreateProtectdBranchRequestTestSettingDTOSensitiveInfoDetection,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchResponseBodyResultMergeRequestSetting extends $tea.Model {
  allowMergeRequestRoles?: number[];
  defaultAssignees?: string[];
  isAllowSelfApproval?: boolean;
  isRequireDiscussionProcessed?: boolean;
  isRequired?: boolean;
  isResetApprovalWhenNewPush?: boolean;
  minimumApproval?: number;
  mrMode?: string;
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      allowMergeRequestRoles: 'allowMergeRequestRoles',
      defaultAssignees: 'defaultAssignees',
      isAllowSelfApproval: 'isAllowSelfApproval',
      isRequireDiscussionProcessed: 'isRequireDiscussionProcessed',
      isRequired: 'isRequired',
      isResetApprovalWhenNewPush: 'isResetApprovalWhenNewPush',
      minimumApproval: 'minimumApproval',
      mrMode: 'mrMode',
      whiteList: 'whiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowMergeRequestRoles: { 'type': 'array', 'itemType': 'number' },
      defaultAssignees: { 'type': 'array', 'itemType': 'string' },
      isAllowSelfApproval: 'boolean',
      isRequireDiscussionProcessed: 'boolean',
      isRequired: 'boolean',
      isResetApprovalWhenNewPush: 'boolean',
      minimumApproval: 'number',
      mrMode: 'string',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfigCheckItems extends $tea.Model {
  isRequired?: boolean;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      isRequired: 'isRequired',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isRequired: 'boolean',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfig extends $tea.Model {
  checkItems?: CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfigCheckItems[];
  static names(): { [key: string]: string } {
    return {
      checkItems: 'checkItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkItems: { 'type': 'array', 'itemType': CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfigCheckItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchResponseBodyResultTestSettingDTOCheckTaskQualityConfig extends $tea.Model {
  bizNo?: string;
  enabled?: boolean;
  message?: string;
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      bizNo: 'bizNo',
      enabled: 'enabled',
      message: 'message',
      taskName: 'taskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizNo: 'string',
      enabled: 'boolean',
      message: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchResponseBodyResultTestSettingDTOCodeGuidelinesDetection extends $tea.Model {
  enabled?: boolean;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'enabled',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchResponseBodyResultTestSettingDTOSensitiveInfoDetection extends $tea.Model {
  enabled?: boolean;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'enabled',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchResponseBodyResultTestSettingDTO extends $tea.Model {
  checkConfig?: CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfig;
  checkTaskQualityConfig?: CreateProtectdBranchResponseBodyResultTestSettingDTOCheckTaskQualityConfig;
  codeGuidelinesDetection?: CreateProtectdBranchResponseBodyResultTestSettingDTOCodeGuidelinesDetection;
  isRequired?: boolean;
  sensitiveInfoDetection?: CreateProtectdBranchResponseBodyResultTestSettingDTOSensitiveInfoDetection;
  static names(): { [key: string]: string } {
    return {
      checkConfig: 'checkConfig',
      checkTaskQualityConfig: 'checkTaskQualityConfig',
      codeGuidelinesDetection: 'codeGuidelinesDetection',
      isRequired: 'isRequired',
      sensitiveInfoDetection: 'sensitiveInfoDetection',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkConfig: CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfig,
      checkTaskQualityConfig: CreateProtectdBranchResponseBodyResultTestSettingDTOCheckTaskQualityConfig,
      codeGuidelinesDetection: CreateProtectdBranchResponseBodyResultTestSettingDTOCodeGuidelinesDetection,
      isRequired: 'boolean',
      sensitiveInfoDetection: CreateProtectdBranchResponseBodyResultTestSettingDTOSensitiveInfoDetection,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchResponseBodyResult extends $tea.Model {
  allowMergeRoles?: number[];
  allowMergeUserIds?: number[];
  allowPushRoles?: number[];
  allowPushUserIds?: number[];
  branch?: string;
  id?: number;
  mergeRequestSetting?: CreateProtectdBranchResponseBodyResultMergeRequestSetting;
  testSettingDTO?: CreateProtectdBranchResponseBodyResultTestSettingDTO;
  static names(): { [key: string]: string } {
    return {
      allowMergeRoles: 'allowMergeRoles',
      allowMergeUserIds: 'allowMergeUserIds',
      allowPushRoles: 'allowPushRoles',
      allowPushUserIds: 'allowPushUserIds',
      branch: 'branch',
      id: 'id',
      mergeRequestSetting: 'mergeRequestSetting',
      testSettingDTO: 'testSettingDTO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowMergeRoles: { 'type': 'array', 'itemType': 'number' },
      allowMergeUserIds: { 'type': 'array', 'itemType': 'number' },
      allowPushRoles: { 'type': 'array', 'itemType': 'number' },
      allowPushUserIds: { 'type': 'array', 'itemType': 'number' },
      branch: 'string',
      id: 'number',
      mergeRequestSetting: CreateProtectdBranchResponseBodyResultMergeRequestSetting,
      testSettingDTO: CreateProtectdBranchResponseBodyResultTestSettingDTO,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePushRuleRequestRuleInfos extends $tea.Model {
  checkerName?: string;
  checkerType?: string;
  extraMessage?: string;
  fileRuleRegexes?: string[];
  static names(): { [key: string]: string } {
    return {
      checkerName: 'checkerName',
      checkerType: 'checkerType',
      extraMessage: 'extraMessage',
      fileRuleRegexes: 'fileRuleRegexes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkerName: 'string',
      checkerType: 'string',
      extraMessage: 'string',
      fileRuleRegexes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePushRuleResponseBodyResultRuleInfos extends $tea.Model {
  checkerName?: string;
  checkerType?: string;
  extraMessage?: string;
  fileRuleRegexes?: string[];
  static names(): { [key: string]: string } {
    return {
      checkerName: 'checkerName',
      checkerType: 'checkerType',
      extraMessage: 'extraMessage',
      fileRuleRegexes: 'fileRuleRegexes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkerName: 'string',
      checkerType: 'string',
      extraMessage: 'string',
      fileRuleRegexes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePushRuleResponseBodyResult extends $tea.Model {
  gmtCreate?: string;
  gmtModified?: string;
  id?: number;
  ruleInfos?: CreatePushRuleResponseBodyResultRuleInfos[];
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      id: 'id',
      ruleInfos: 'ruleInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      ruleInfos: { 'type': 'array', 'itemType': CreatePushRuleResponseBodyResultRuleInfos },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRepositoryResponseBodyResultNamespace extends $tea.Model {
  avatar?: string;
  createdAt?: string;
  description?: string;
  id?: number;
  name?: string;
  ownerId?: number;
  path?: string;
  public?: boolean;
  updatedAt?: string;
  visibilityLevel?: string;
  static names(): { [key: string]: string } {
    return {
      avatar: 'avatar',
      createdAt: 'createdAt',
      description: 'description',
      id: 'id',
      name: 'name',
      ownerId: 'ownerId',
      path: 'path',
      public: 'public',
      updatedAt: 'updatedAt',
      visibilityLevel: 'visibilityLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatar: 'string',
      createdAt: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
      ownerId: 'number',
      path: 'string',
      public: 'boolean',
      updatedAt: 'string',
      visibilityLevel: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRepositoryResponseBodyResult extends $tea.Model {
  importFromSvn?: boolean;
  archived?: boolean;
  avatarUrl?: string;
  createdAt?: string;
  creatorId?: number;
  defaultBranch?: string;
  demoProject?: boolean;
  description?: string;
  httpUrlToRepo?: string;
  id?: number;
  lastActivityAt?: string;
  name?: string;
  nameWithNamespace?: string;
  namespace?: CreateRepositoryResponseBodyResultNamespace;
  path?: string;
  pathWithNamespace?: string;
  sshUrlToRepo?: string;
  visibilityLevel?: string;
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      importFromSvn: 'Import_from_svn',
      archived: 'archived',
      avatarUrl: 'avatar_url',
      createdAt: 'createdAt',
      creatorId: 'creatorId',
      defaultBranch: 'defaultBranch',
      demoProject: 'demoProject',
      description: 'description',
      httpUrlToRepo: 'httpUrlToRepo',
      id: 'id',
      lastActivityAt: 'lastActivityAt',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      namespace: 'namespace',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      sshUrlToRepo: 'sshUrlToRepo',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      importFromSvn: 'boolean',
      archived: 'boolean',
      avatarUrl: 'string',
      createdAt: 'string',
      creatorId: 'number',
      defaultBranch: 'string',
      demoProject: 'boolean',
      description: 'string',
      httpUrlToRepo: 'string',
      id: 'number',
      lastActivityAt: 'string',
      name: 'string',
      nameWithNamespace: 'string',
      namespace: CreateRepositoryResponseBodyResultNamespace,
      path: 'string',
      pathWithNamespace: 'string',
      sshUrlToRepo: 'string',
      visibilityLevel: 'string',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRepositoryGroupResponseBodyResult extends $tea.Model {
  avatarUrl?: string;
  description?: string;
  id?: number;
  name?: string;
  nameWithNamespace?: string;
  ownerId?: number;
  parentId?: number;
  path?: string;
  pathWithNamespace?: string;
  type?: string;
  visibilityLevel?: number;
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      description: 'description',
      id: 'id',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      ownerId: 'ownerId',
      parentId: 'parentId',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      type: 'type',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
      nameWithNamespace: 'string',
      ownerId: 'number',
      parentId: 'number',
      path: 'string',
      pathWithNamespace: 'string',
      type: 'string',
      visibilityLevel: 'number',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSprintResponseBodySprint extends $tea.Model {
  creator?: string;
  description?: string;
  endDate?: number;
  gmtCreate?: number;
  gmtModified?: number;
  identifier?: string;
  modifier?: string;
  name?: string;
  scope?: string;
  spaceIdentifier?: string;
  startDate?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      creator: 'creator',
      description: 'description',
      endDate: 'endDate',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      modifier: 'modifier',
      name: 'name',
      scope: 'scope',
      spaceIdentifier: 'spaceIdentifier',
      startDate: 'startDate',
      status: 'status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creator: 'string',
      description: 'string',
      endDate: 'number',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      modifier: 'string',
      name: 'string',
      scope: 'string',
      spaceIdentifier: 'string',
      startDate: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSshKeyResponseBodySshKey extends $tea.Model {
  id?: number;
  publicKey?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      publicKey: 'publicKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      publicKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagResponseBodyResultCommit extends $tea.Model {
  authorEmail?: string;
  authorName?: string;
  authoredDate?: string;
  committedDate?: string;
  committerEmail?: string;
  committerName?: string;
  createdAt?: string;
  id?: string;
  message?: string;
  parentIds?: string[];
  shortId?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      authoredDate: 'authoredDate',
      committedDate: 'committedDate',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorEmail: 'string',
      authorName: 'string',
      authoredDate: 'string',
      committedDate: 'string',
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagResponseBodyResult extends $tea.Model {
  commit?: CreateTagResponseBodyResultCommit;
  id?: string;
  message?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      commit: 'commit',
      id: 'id',
      message: 'message',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commit: CreateTagResponseBodyResultCommit,
      id: 'string',
      message: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseRequestFieldValueList extends $tea.Model {
  fieldIdentifier?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      fieldIdentifier: 'fieldIdentifier',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldIdentifier: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseRequestTestcaseStepContentInfoStepResultList extends $tea.Model {
  expected?: string;
  step?: string;
  static names(): { [key: string]: string } {
    return {
      expected: 'expected',
      step: 'step',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expected: 'string',
      step: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseRequestTestcaseStepContentInfo extends $tea.Model {
  precondition?: string;
  stepResultList?: CreateTestCaseRequestTestcaseStepContentInfoStepResultList[];
  stepType?: string;
  static names(): { [key: string]: string } {
    return {
      precondition: 'precondition',
      stepResultList: 'stepResultList',
      stepType: 'stepType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      precondition: 'string',
      stepResultList: { 'type': 'array', 'itemType': CreateTestCaseRequestTestcaseStepContentInfoStepResultList },
      stepType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponseBodyTestcaseAssignedTo extends $tea.Model {
  assignIdentifier?: string;
  name?: string;
  tbRoleId?: string;
  static names(): { [key: string]: string } {
    return {
      assignIdentifier: 'assignIdentifier',
      name: 'name',
      tbRoleId: 'tbRoleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignIdentifier: 'string',
      name: 'string',
      tbRoleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponseBodyTestcaseCreator extends $tea.Model {
  createIdentifier?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      createIdentifier: 'createIdentifier',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createIdentifier: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponseBodyTestcaseDetailInfoExpectedResult extends $tea.Model {
  expectContent?: string;
  expectContentType?: string;
  expectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      expectContent: 'expectContent',
      expectContentType: 'expectContentType',
      expectIdentifier: 'expectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expectContent: 'string',
      expectContentType: 'string',
      expectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponseBodyTestcaseDetailInfoPrecondition extends $tea.Model {
  preContent?: string;
  preContentType?: string;
  preIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      preContent: 'preContent',
      preContentType: 'preContentType',
      preIdentifier: 'preIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preContent: 'string',
      preContentType: 'string',
      preIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponseBodyTestcaseDetailInfoStepContent extends $tea.Model {
  stepContent?: string;
  stepContentType?: string;
  stepIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      stepContent: 'stepContent',
      stepContentType: 'stepContentType',
      stepIdentifier: 'stepIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      stepContent: 'string',
      stepContentType: 'string',
      stepIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponseBodyTestcaseDetailInfo extends $tea.Model {
  expectedResult?: CreateTestCaseResponseBodyTestcaseDetailInfoExpectedResult;
  precondition?: CreateTestCaseResponseBodyTestcaseDetailInfoPrecondition;
  stepContent?: CreateTestCaseResponseBodyTestcaseDetailInfoStepContent;
  stepType?: string;
  static names(): { [key: string]: string } {
    return {
      expectedResult: 'expectedResult',
      precondition: 'precondition',
      stepContent: 'stepContent',
      stepType: 'stepType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expectedResult: CreateTestCaseResponseBodyTestcaseDetailInfoExpectedResult,
      precondition: CreateTestCaseResponseBodyTestcaseDetailInfoPrecondition,
      stepContent: CreateTestCaseResponseBodyTestcaseDetailInfoStepContent,
      stepType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponseBodyTestcaseDirectory extends $tea.Model {
  childIdentifier?: string;
  directoryIdentifier?: string;
  name?: string;
  pathName?: string[];
  static names(): { [key: string]: string } {
    return {
      childIdentifier: 'childIdentifier',
      directoryIdentifier: 'directoryIdentifier',
      name: 'name',
      pathName: 'pathName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      childIdentifier: 'string',
      directoryIdentifier: 'string',
      name: 'string',
      pathName: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponseBodyTestcaseModifier extends $tea.Model {
  modifyIdentifier?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      modifyIdentifier: 'modifyIdentifier',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      modifyIdentifier: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponseBodyTestcase extends $tea.Model {
  assignedTo?: CreateTestCaseResponseBodyTestcaseAssignedTo;
  categoryIdentifier?: string;
  creator?: CreateTestCaseResponseBodyTestcaseCreator;
  detailInfo?: CreateTestCaseResponseBodyTestcaseDetailInfo;
  directory?: CreateTestCaseResponseBodyTestcaseDirectory;
  identifier?: string;
  modifier?: CreateTestCaseResponseBodyTestcaseModifier;
  spaceIdentifier?: string;
  spaceType?: string;
  subject?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      detailInfo: 'detailInfo',
      directory: 'directory',
      identifier: 'identifier',
      modifier: 'modifier',
      spaceIdentifier: 'spaceIdentifier',
      spaceType: 'spaceType',
      subject: 'subject',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: CreateTestCaseResponseBodyTestcaseAssignedTo,
      categoryIdentifier: 'string',
      creator: CreateTestCaseResponseBodyTestcaseCreator,
      detailInfo: CreateTestCaseResponseBodyTestcaseDetailInfo,
      directory: CreateTestCaseResponseBodyTestcaseDirectory,
      identifier: 'string',
      modifier: CreateTestCaseResponseBodyTestcaseModifier,
      spaceIdentifier: 'string',
      spaceType: 'string',
      subject: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserKeyResponseBodyResult extends $tea.Model {
  createdAt?: string;
  expireTime?: string;
  fingerPrint?: string;
  id?: number;
  keyScope?: string;
  lastUsedTime?: string;
  publicKey?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      createdAt: 'createdAt',
      expireTime: 'expireTime',
      fingerPrint: 'fingerPrint',
      id: 'id',
      keyScope: 'keyScope',
      lastUsedTime: 'lastUsedTime',
      publicKey: 'publicKey',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdAt: 'string',
      expireTime: 'string',
      fingerPrint: 'string',
      id: 'number',
      keyScope: 'string',
      lastUsedTime: 'string',
      publicKey: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemRequestFieldValueList extends $tea.Model {
  fieldIdentifier?: string;
  value?: string;
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      fieldIdentifier: 'fieldIdentifier',
      value: 'value',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldIdentifier: 'string',
      value: 'string',
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemResponseBodyWorkitem extends $tea.Model {
  assignedTo?: string;
  categoryIdentifier?: string;
  creator?: string;
  document?: string;
  gmtCreate?: number;
  gmtModified?: number;
  identifier?: string;
  logicalStatus?: string;
  modifier?: string;
  parentIdentifier?: string;
  serialNumber?: string;
  spaceIdentifier?: string;
  spaceName?: string;
  spaceType?: string;
  sprintIdentifier?: string;
  status?: string;
  statusIdentifier?: string;
  statusStageIdentifier?: string;
  subject?: string;
  updateStatusAt?: number;
  workitemTypeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      document: 'document',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      logicalStatus: 'logicalStatus',
      modifier: 'modifier',
      parentIdentifier: 'parentIdentifier',
      serialNumber: 'serialNumber',
      spaceIdentifier: 'spaceIdentifier',
      spaceName: 'spaceName',
      spaceType: 'spaceType',
      sprintIdentifier: 'sprintIdentifier',
      status: 'status',
      statusIdentifier: 'statusIdentifier',
      statusStageIdentifier: 'statusStageIdentifier',
      subject: 'subject',
      updateStatusAt: 'updateStatusAt',
      workitemTypeIdentifier: 'workitemTypeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: 'string',
      categoryIdentifier: 'string',
      creator: 'string',
      document: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      logicalStatus: 'string',
      modifier: 'string',
      parentIdentifier: 'string',
      serialNumber: 'string',
      spaceIdentifier: 'string',
      spaceName: 'string',
      spaceType: 'string',
      sprintIdentifier: 'string',
      status: 'string',
      statusIdentifier: 'string',
      statusStageIdentifier: 'string',
      subject: 'string',
      updateStatusAt: 'number',
      workitemTypeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemCommentResponseBodyCommentUser extends $tea.Model {
  account?: string;
  avatar?: string;
  displayName?: string;
  identifier?: string;
  nickName?: string;
  realName?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'account',
      avatar: 'avatar',
      displayName: 'displayName',
      identifier: 'identifier',
      nickName: 'nickName',
      realName: 'realName',
      targetType: 'targetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      avatar: 'string',
      displayName: 'string',
      identifier: 'string',
      nickName: 'string',
      realName: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemCommentResponseBodyComment extends $tea.Model {
  id?: number;
  content?: string;
  createTime?: number;
  formatType?: string;
  isTop?: boolean;
  modifiedTime?: number;
  parentId?: number;
  targetIdentifier?: string;
  targetType?: string;
  topTime?: number;
  user?: CreateWorkitemCommentResponseBodyCommentUser;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      content: 'content',
      createTime: 'createTime',
      formatType: 'formatType',
      isTop: 'isTop',
      modifiedTime: 'modifiedTime',
      parentId: 'parentId',
      targetIdentifier: 'targetIdentifier',
      targetType: 'targetType',
      topTime: 'topTime',
      user: 'user',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      content: 'string',
      createTime: 'number',
      formatType: 'string',
      isTop: 'boolean',
      modifiedTime: 'number',
      parentId: 'number',
      targetIdentifier: 'string',
      targetType: 'string',
      topTime: 'number',
      user: CreateWorkitemCommentResponseBodyCommentUser,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser extends $tea.Model {
  account?: string;
  avatar?: string;
  dingTalkId?: string;
  displayName?: string;
  displayNickName?: string;
  displayRealName?: string;
  email?: string;
  gender?: string;
  identifier?: string;
  isDisabled?: boolean;
  mobile?: string;
  nameEn?: string;
  nickName?: string;
  nickNamePinyin?: string;
  realName?: string;
  realNamePinyin?: string;
  stamp?: string;
  tbRoleId?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'account',
      avatar: 'avatar',
      dingTalkId: 'dingTalkId',
      displayName: 'displayName',
      displayNickName: 'displayNickName',
      displayRealName: 'displayRealName',
      email: 'email',
      gender: 'gender',
      identifier: 'identifier',
      isDisabled: 'isDisabled',
      mobile: 'mobile',
      nameEn: 'nameEn',
      nickName: 'nickName',
      nickNamePinyin: 'nickNamePinyin',
      realName: 'realName',
      realNamePinyin: 'realNamePinyin',
      stamp: 'stamp',
      tbRoleId: 'tbRoleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      avatar: 'string',
      dingTalkId: 'string',
      displayName: 'string',
      displayNickName: 'string',
      displayRealName: 'string',
      email: 'string',
      gender: 'string',
      identifier: 'string',
      isDisabled: 'boolean',
      mobile: 'string',
      nameEn: 'string',
      nickName: 'string',
      nickNamePinyin: 'string',
      realName: 'string',
      realNamePinyin: 'string',
      stamp: 'string',
      tbRoleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemEstimateResponseBodyWorkitemTimeEstimate extends $tea.Model {
  description?: string;
  identifier?: string;
  recordUser?: CreateWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser;
  spentTime?: number;
  type?: string;
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'description',
      identifier: 'identifier',
      recordUser: 'recordUser',
      spentTime: 'spentTime',
      type: 'type',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      identifier: 'string',
      recordUser: CreateWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser,
      spentTime: 'number',
      type: 'string',
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemRecordResponseBodyWorkitemTimeRecordUser extends $tea.Model {
  account?: string;
  avatar?: string;
  dingTalkId?: string;
  displayName?: string;
  displayNickName?: string;
  displayRealName?: string;
  email?: string;
  gender?: string;
  identifier?: string;
  isDisabled?: boolean;
  mobile?: string;
  nameEn?: string;
  nickName?: string;
  nickNamePinyin?: string;
  realName?: string;
  realNamePinyin?: string;
  stamp?: string;
  tbRoleId?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'account',
      avatar: 'avatar',
      dingTalkId: 'dingTalkId',
      displayName: 'displayName',
      displayNickName: 'displayNickName',
      displayRealName: 'displayRealName',
      email: 'email',
      gender: 'gender',
      identifier: 'identifier',
      isDisabled: 'isDisabled',
      mobile: 'mobile',
      nameEn: 'nameEn',
      nickName: 'nickName',
      nickNamePinyin: 'nickNamePinyin',
      realName: 'realName',
      realNamePinyin: 'realNamePinyin',
      stamp: 'stamp',
      tbRoleId: 'tbRoleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      avatar: 'string',
      dingTalkId: 'string',
      displayName: 'string',
      displayNickName: 'string',
      displayRealName: 'string',
      email: 'string',
      gender: 'string',
      identifier: 'string',
      isDisabled: 'boolean',
      mobile: 'string',
      nameEn: 'string',
      nickName: 'string',
      nickNamePinyin: 'string',
      realName: 'string',
      realNamePinyin: 'string',
      stamp: 'string',
      tbRoleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemRecordResponseBodyWorkitemTime extends $tea.Model {
  actualTime?: number;
  description?: string;
  gmtEnd?: number;
  gmtStart?: number;
  identifier?: string;
  recordUser?: CreateWorkitemRecordResponseBodyWorkitemTimeRecordUser;
  type?: string;
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      actualTime: 'actualTime',
      description: 'description',
      gmtEnd: 'gmtEnd',
      gmtStart: 'gmtStart',
      identifier: 'identifier',
      recordUser: 'recordUser',
      type: 'type',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualTime: 'number',
      description: 'string',
      gmtEnd: 'number',
      gmtStart: 'number',
      identifier: 'string',
      recordUser: CreateWorkitemRecordResponseBodyWorkitemTimeRecordUser,
      type: 'string',
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemV2RequestFieldValueList extends $tea.Model {
  fieldIdentifier?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      fieldIdentifier: 'fieldIdentifier',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldIdentifier: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceResponseBodyWorkspace extends $tea.Model {
  createTime?: string;
  creator?: string;
  id?: string;
  name?: string;
  status?: string;
  template?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'createTime',
      creator: 'creator',
      id: 'id',
      name: 'name',
      status: 'status',
      template: 'template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      creator: 'string',
      id: 'string',
      name: 'string',
      status: 'string',
      template: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBranchResponseBodyResult extends $tea.Model {
  branchName?: string;
  static names(): { [key: string]: string } {
    return {
      branchName: 'branchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      branchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFileResponseBodyResult extends $tea.Model {
  branchName?: string;
  filePath?: string;
  static names(): { [key: string]: string } {
    return {
      branchName: 'branchName',
      filePath: 'filePath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      branchName: 'string',
      filePath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGroupMemberResponseBodyResult extends $tea.Model {
  accessLevel?: number;
  avatarUrl?: string;
  id?: number;
  memberType?: string;
  name?: string;
  sourceId?: number;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      avatarUrl: 'avatarUrl',
      id: 'id',
      memberType: 'memberType',
      name: 'name',
      sourceId: 'sourceId',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      avatarUrl: 'string',
      id: 'number',
      memberType: 'string',
      name: 'string',
      sourceId: 'number',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectLabelResponseBodyResult extends $tea.Model {
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProtectedBranchResponseBodyResult extends $tea.Model {
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePushRuleResponseBodyResult extends $tea.Model {
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryResponseBodyResult extends $tea.Model {
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryGroupResponseBodyResult extends $tea.Model {
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryMemberResponseBodyResult extends $tea.Model {
  accessLevel?: number;
  createAt?: string;
  id?: number;
  sourceId?: number;
  sourceType?: string;
  updateAt?: string;
  userId?: number;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      createAt: 'createAt',
      id: 'id',
      sourceId: 'sourceId',
      sourceType: 'sourceType',
      updateAt: 'updateAt',
      userId: 'userId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      createAt: 'string',
      id: 'number',
      sourceId: 'number',
      sourceType: 'string',
      updateAt: 'string',
      userId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryWebhookResponseBodyResult extends $tea.Model {
  buildEvents?: boolean;
  createdAt?: string;
  description?: string;
  enableSslVerification?: boolean;
  id?: number;
  issuesEvents?: boolean;
  lastTestResult?: string;
  mergeRequestsEvents?: boolean;
  noteEvents?: boolean;
  projectId?: number;
  pushEvents?: boolean;
  secretToken?: string;
  tagPushEvents?: boolean;
  type?: string;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      buildEvents: 'buildEvents',
      createdAt: 'createdAt',
      description: 'description',
      enableSslVerification: 'enableSslVerification',
      id: 'id',
      issuesEvents: 'issuesEvents',
      lastTestResult: 'lastTestResult',
      mergeRequestsEvents: 'mergeRequestsEvents',
      noteEvents: 'noteEvents',
      projectId: 'projectId',
      pushEvents: 'pushEvents',
      secretToken: 'secretToken',
      tagPushEvents: 'tagPushEvents',
      type: 'type',
      url: 'url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      buildEvents: 'boolean',
      createdAt: 'string',
      description: 'string',
      enableSslVerification: 'boolean',
      id: 'number',
      issuesEvents: 'boolean',
      lastTestResult: 'string',
      mergeRequestsEvents: 'boolean',
      noteEvents: 'boolean',
      projectId: 'number',
      pushEvents: 'boolean',
      secretToken: 'string',
      tagPushEvents: 'boolean',
      type: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagResponseBodyResult extends $tea.Model {
  tagName?: string;
  static names(): { [key: string]: string } {
    return {
      tagName: 'tagName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserKeyResponseBodyResult extends $tea.Model {
  context?: string;
  createdAt?: string;
  expireTime?: string;
  fingerPrint?: string;
  id?: number;
  keyScope?: string;
  lastUsedTime?: string;
  publicKey?: string;
  shaContext?: string;
  title?: string;
  updatedAt?: string;
  static names(): { [key: string]: string } {
    return {
      context: 'context',
      createdAt: 'createdAt',
      expireTime: 'expireTime',
      fingerPrint: 'fingerPrint',
      id: 'id',
      keyScope: 'keyScope',
      lastUsedTime: 'lastUsedTime',
      publicKey: 'publicKey',
      shaContext: 'shaContext',
      title: 'title',
      updatedAt: 'updatedAt',
    };
  }

  static types(): { [key: string]: any } {
    return {
      context: 'string',
      createdAt: 'string',
      expireTime: 'string',
      fingerPrint: 'string',
      id: 'number',
      keyScope: 'string',
      lastUsedTime: 'string',
      publicKey: 'string',
      shaContext: 'string',
      title: 'string',
      updatedAt: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeployKeyResponseBodyResult extends $tea.Model {
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBranchInfoResponseBodyResultCommitAuthor extends $tea.Model {
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBranchInfoResponseBodyResultCommitCommitter extends $tea.Model {
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBranchInfoResponseBodyResultCommitSignature extends $tea.Model {
  gpgKeyId?: string;
  verificationStatus?: string;
  static names(): { [key: string]: string } {
    return {
      gpgKeyId: 'gpgKeyId',
      verificationStatus: 'verificationStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gpgKeyId: 'string',
      verificationStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBranchInfoResponseBodyResultCommit extends $tea.Model {
  author?: GetBranchInfoResponseBodyResultCommitAuthor;
  authorEmail?: string;
  authorName?: string;
  authoredDate?: string;
  commentsCount?: number;
  committedDate?: string;
  committer?: GetBranchInfoResponseBodyResultCommitCommitter;
  committerEmail?: string;
  committerName?: string;
  createdAt?: string;
  id?: string;
  message?: string;
  parentIds?: string[];
  shortId?: string;
  signature?: GetBranchInfoResponseBodyResultCommitSignature;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      authoredDate: 'authoredDate',
      commentsCount: 'commentsCount',
      committedDate: 'committedDate',
      committer: 'committer',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      signature: 'signature',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: GetBranchInfoResponseBodyResultCommitAuthor,
      authorEmail: 'string',
      authorName: 'string',
      authoredDate: 'string',
      commentsCount: 'number',
      committedDate: 'string',
      committer: GetBranchInfoResponseBodyResultCommitCommitter,
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      signature: GetBranchInfoResponseBodyResultCommitSignature,
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBranchInfoResponseBodyResult extends $tea.Model {
  commit?: GetBranchInfoResponseBodyResultCommit;
  name?: string;
  protected?: string;
  static names(): { [key: string]: string } {
    return {
      commit: 'commit',
      name: 'name',
      protected: 'protected',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commit: GetBranchInfoResponseBodyResultCommit,
      name: 'string',
      protected: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRunResponseBodyResultAnnotations extends $tea.Model {
  annotationLevel?: string;
  endColumn?: number;
  endLine?: number;
  id?: number;
  message?: string;
  path?: string;
  rawDetails?: string;
  startColumn?: number;
  startLine?: number;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      annotationLevel: 'annotationLevel',
      endColumn: 'endColumn',
      endLine: 'endLine',
      id: 'id',
      message: 'message',
      path: 'path',
      rawDetails: 'rawDetails',
      startColumn: 'startColumn',
      startLine: 'startLine',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotationLevel: 'string',
      endColumn: 'number',
      endLine: 'number',
      id: 'number',
      message: 'string',
      path: 'string',
      rawDetails: 'string',
      startColumn: 'number',
      startLine: 'number',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRunResponseBodyResultCheckSuite extends $tea.Model {
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRunResponseBodyResultOutputImages extends $tea.Model {
  alt?: string;
  caption?: string;
  imageUrl?: string;
  static names(): { [key: string]: string } {
    return {
      alt: 'alt',
      caption: 'caption',
      imageUrl: 'imageUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alt: 'string',
      caption: 'string',
      imageUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRunResponseBodyResultOutput extends $tea.Model {
  images?: GetCheckRunResponseBodyResultOutputImages[];
  summary?: string;
  text?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      images: 'images',
      summary: 'summary',
      text: 'text',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      images: { 'type': 'array', 'itemType': GetCheckRunResponseBodyResultOutputImages },
      summary: 'string',
      text: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRunResponseBodyResultWriter extends $tea.Model {
  id?: string;
  logoUrl?: string;
  name?: string;
  slug?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      logoUrl: 'logoUrl',
      name: 'name',
      slug: 'slug',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      logoUrl: 'string',
      name: 'string',
      slug: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRunResponseBodyResult extends $tea.Model {
  annotations?: GetCheckRunResponseBodyResultAnnotations[];
  checkSuite?: GetCheckRunResponseBodyResultCheckSuite;
  completedAt?: string;
  conclusion?: string;
  createdAt?: string;
  detailsUrl?: string;
  externalId?: string;
  headSha?: string;
  id?: number;
  name?: string;
  output?: GetCheckRunResponseBodyResultOutput;
  startedAt?: string;
  status?: string;
  updatedAt?: string;
  writer?: GetCheckRunResponseBodyResultWriter;
  static names(): { [key: string]: string } {
    return {
      annotations: 'annotations',
      checkSuite: 'checkSuite',
      completedAt: 'completedAt',
      conclusion: 'conclusion',
      createdAt: 'createdAt',
      detailsUrl: 'detailsUrl',
      externalId: 'externalId',
      headSha: 'headSha',
      id: 'id',
      name: 'name',
      output: 'output',
      startedAt: 'startedAt',
      status: 'status',
      updatedAt: 'updatedAt',
      writer: 'writer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotations: { 'type': 'array', 'itemType': GetCheckRunResponseBodyResultAnnotations },
      checkSuite: GetCheckRunResponseBodyResultCheckSuite,
      completedAt: 'string',
      conclusion: 'string',
      createdAt: 'string',
      detailsUrl: 'string',
      externalId: 'string',
      headSha: 'string',
      id: 'number',
      name: 'string',
      output: GetCheckRunResponseBodyResultOutput,
      startedAt: 'string',
      status: 'string',
      updatedAt: 'string',
      writer: GetCheckRunResponseBodyResultWriter,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCodeupOrganizationResponseBodyResult extends $tea.Model {
  createdAt?: string;
  id?: number;
  namespaceId?: number;
  organizationId?: string;
  path?: string;
  updatedAt?: string;
  userRole?: string;
  static names(): { [key: string]: string } {
    return {
      createdAt: 'createdAt',
      id: 'id',
      namespaceId: 'namespaceId',
      organizationId: 'organizationId',
      path: 'path',
      updatedAt: 'updatedAt',
      userRole: 'userRole',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdAt: 'string',
      id: 'number',
      namespaceId: 'number',
      organizationId: 'string',
      path: 'string',
      updatedAt: 'string',
      userRole: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCompareDetailResponseBodyResultCommitsAuthor extends $tea.Model {
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCompareDetailResponseBodyResultCommitsCommitter extends $tea.Model {
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCompareDetailResponseBodyResultCommits extends $tea.Model {
  author?: GetCompareDetailResponseBodyResultCommitsAuthor;
  authorEmail?: string;
  authorName?: string;
  authoredDate?: string;
  commentsCount?: number;
  committedDate?: string;
  committer?: GetCompareDetailResponseBodyResultCommitsCommitter;
  committerEmail?: string;
  committerName?: string;
  createdAt?: string;
  id?: string;
  message?: string;
  parentIds?: string[];
  shortId?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      authoredDate: 'authoredDate',
      commentsCount: 'commentsCount',
      committedDate: 'committedDate',
      committer: 'committer',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: GetCompareDetailResponseBodyResultCommitsAuthor,
      authorEmail: 'string',
      authorName: 'string',
      authoredDate: 'string',
      commentsCount: 'number',
      committedDate: 'string',
      committer: GetCompareDetailResponseBodyResultCommitsCommitter,
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCompareDetailResponseBodyResultDiffs extends $tea.Model {
  aMode?: string;
  bMode?: string;
  deletedFile?: boolean;
  diff?: string;
  isBinary?: boolean;
  isNewLfs?: boolean;
  isOldLfs?: boolean;
  newFile?: boolean;
  newId?: string;
  newPath?: string;
  oldId?: string;
  oldPath?: string;
  renamedFile?: boolean;
  static names(): { [key: string]: string } {
    return {
      aMode: 'aMode',
      bMode: 'bMode',
      deletedFile: 'deletedFile',
      diff: 'diff',
      isBinary: 'isBinary',
      isNewLfs: 'isNewLfs',
      isOldLfs: 'isOldLfs',
      newFile: 'newFile',
      newId: 'newId',
      newPath: 'newPath',
      oldId: 'oldId',
      oldPath: 'oldPath',
      renamedFile: 'renamedFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aMode: 'string',
      bMode: 'string',
      deletedFile: 'boolean',
      diff: 'string',
      isBinary: 'boolean',
      isNewLfs: 'boolean',
      isOldLfs: 'boolean',
      newFile: 'boolean',
      newId: 'string',
      newPath: 'string',
      oldId: 'string',
      oldPath: 'string',
      renamedFile: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCompareDetailResponseBodyResult extends $tea.Model {
  commits?: GetCompareDetailResponseBodyResultCommits[];
  diffs?: GetCompareDetailResponseBodyResultDiffs[];
  messages?: string[];
  static names(): { [key: string]: string } {
    return {
      commits: 'commits',
      diffs: 'diffs',
      messages: 'messages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commits: { 'type': 'array', 'itemType': GetCompareDetailResponseBodyResultCommits },
      diffs: { 'type': 'array', 'itemType': GetCompareDetailResponseBodyResultDiffs },
      messages: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCustomFieldOptionResponseBodyFileds extends $tea.Model {
  displayValue?: string;
  fieldIdentifier?: string;
  identifier?: string;
  level?: number;
  position?: number;
  value?: string;
  valueEn?: string;
  static names(): { [key: string]: string } {
    return {
      displayValue: 'displayValue',
      fieldIdentifier: 'fieldIdentifier',
      identifier: 'identifier',
      level: 'level',
      position: 'position',
      value: 'value',
      valueEn: 'valueEn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayValue: 'string',
      fieldIdentifier: 'string',
      identifier: 'string',
      level: 'number',
      position: 'number',
      value: 'string',
      valueEn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileBlobsResponseBodyResult extends $tea.Model {
  content?: string;
  size?: number;
  totalLines?: number;
  static names(): { [key: string]: string } {
    return {
      content: 'content',
      size: 'size',
      totalLines: 'totalLines',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      size: 'number',
      totalLines: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileLastCommitResponseBodyResultSignature extends $tea.Model {
  gpgKeyId?: string;
  verificationStatus?: string;
  static names(): { [key: string]: string } {
    return {
      gpgKeyId: 'gpgKeyId',
      verificationStatus: 'verificationStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gpgKeyId: 'string',
      verificationStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileLastCommitResponseBodyResult extends $tea.Model {
  authorDate?: string;
  authorEmail?: string;
  authorName?: string;
  committedDate?: string;
  committerEmail?: string;
  committerName?: string;
  createdAt?: string;
  id?: string;
  message?: string;
  parentIds?: string[];
  shortId?: string;
  signature?: GetFileLastCommitResponseBodyResultSignature;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      authorDate: 'authorDate',
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      committedDate: 'committedDate',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      signature: 'signature',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorDate: 'string',
      authorEmail: 'string',
      authorName: 'string',
      committedDate: 'string',
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      signature: GetFileLastCommitResponseBodyResultSignature,
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFlowTagGroupResponseBodyFlowTagGroupFlowTagList extends $tea.Model {
  color?: string;
  creatorAccountId?: string;
  id?: number;
  modiferAccountId?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      color: 'color',
      creatorAccountId: 'creatorAccountId',
      id: 'id',
      modiferAccountId: 'modiferAccountId',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      color: 'string',
      creatorAccountId: 'string',
      id: 'number',
      modiferAccountId: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFlowTagGroupResponseBodyFlowTagGroup extends $tea.Model {
  creatorAccountId?: string;
  flowTagList?: GetFlowTagGroupResponseBodyFlowTagGroupFlowTagList[];
  id?: number;
  modiferAccountId?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      creatorAccountId: 'creatorAccountId',
      flowTagList: 'flowTagList',
      id: 'id',
      modiferAccountId: 'modiferAccountId',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorAccountId: 'string',
      flowTagList: { 'type': 'array', 'itemType': GetFlowTagGroupResponseBodyFlowTagGroupFlowTagList },
      id: 'number',
      modiferAccountId: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGroupByPathResponseBodyResult extends $tea.Model {
  avatarUrl?: string;
  description?: string;
  id?: number;
  name?: string;
  nameWithNamespace?: string;
  ownerId?: string;
  parentId?: string;
  path?: string;
  pathWithNamespace?: string;
  visibilityLevel?: number;
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      description: 'description',
      id: 'id',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      ownerId: 'ownerId',
      parentId: 'parentId',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
      nameWithNamespace: 'string',
      ownerId: 'string',
      parentId: 'string',
      path: 'string',
      pathWithNamespace: 'string',
      visibilityLevel: 'number',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGroupDetailResponseBodyResult extends $tea.Model {
  avatarUrl?: string;
  description?: string;
  id?: number;
  name?: string;
  nameWithNamespace?: string;
  ownerId?: number;
  parentId?: number;
  path?: string;
  pathWithNamespace?: string;
  type?: string;
  visibilityLevel?: number;
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      description: 'description',
      id: 'id',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      ownerId: 'ownerId',
      parentId: 'parentId',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      type: 'type',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
      nameWithNamespace: 'string',
      ownerId: 'number',
      parentId: 'number',
      path: 'string',
      pathWithNamespace: 'string',
      type: 'string',
      visibilityLevel: 'number',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHostGroupResponseBodyHostGroupHostInfos extends $tea.Model {
  aliyunRegionId?: string;
  createTime?: number;
  creatorAccountId?: string;
  instanceName?: string;
  ip?: string;
  machineSn?: string;
  modifierAccountId?: string;
  objectType?: string;
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      aliyunRegionId: 'aliyunRegionId',
      createTime: 'createTime',
      creatorAccountId: 'creatorAccountId',
      instanceName: 'instanceName',
      ip: 'ip',
      machineSn: 'machineSn',
      modifierAccountId: 'modifierAccountId',
      objectType: 'objectType',
      updateTime: 'updateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunRegionId: 'string',
      createTime: 'number',
      creatorAccountId: 'string',
      instanceName: 'string',
      ip: 'string',
      machineSn: 'string',
      modifierAccountId: 'string',
      objectType: 'string',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHostGroupResponseBodyHostGroup extends $tea.Model {
  aliyunRegion?: string;
  createTime?: number;
  creatorAccountId?: string;
  description?: string;
  ecsLabelKey?: string;
  ecsLabelValue?: string;
  ecsType?: string;
  hostInfos?: GetHostGroupResponseBodyHostGroupHostInfos[];
  hostNum?: number;
  id?: number;
  modifierAccountId?: string;
  name?: string;
  serviceConnectionId?: number;
  type?: string;
  upateTIme?: number;
  static names(): { [key: string]: string } {
    return {
      aliyunRegion: 'aliyunRegion',
      createTime: 'createTime',
      creatorAccountId: 'creatorAccountId',
      description: 'description',
      ecsLabelKey: 'ecsLabelKey',
      ecsLabelValue: 'ecsLabelValue',
      ecsType: 'ecsType',
      hostInfos: 'hostInfos',
      hostNum: 'hostNum',
      id: 'id',
      modifierAccountId: 'modifierAccountId',
      name: 'name',
      serviceConnectionId: 'serviceConnectionId',
      type: 'type',
      upateTIme: 'upateTIme',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunRegion: 'string',
      createTime: 'number',
      creatorAccountId: 'string',
      description: 'string',
      ecsLabelKey: 'string',
      ecsLabelValue: 'string',
      ecsType: 'string',
      hostInfos: { 'type': 'array', 'itemType': GetHostGroupResponseBodyHostGroupHostInfos },
      hostNum: 'number',
      id: 'number',
      modifierAccountId: 'string',
      name: 'string',
      serviceConnectionId: 'number',
      type: 'string',
      upateTIme: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestResponseBodyResultAuthor extends $tea.Model {
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestResponseBodyResultReviewers extends $tea.Model {
  avatarUrl?: string;
  email?: string;
  hasCommented?: boolean;
  hasReviewed?: boolean;
  id?: number;
  name?: string;
  reviewOpinionStatus?: string;
  reviewTime?: string;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      hasCommented: 'hasCommented',
      hasReviewed: 'hasReviewed',
      id: 'id',
      name: 'name',
      reviewOpinionStatus: 'reviewOpinionStatus',
      reviewTime: 'reviewTime',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      hasCommented: 'boolean',
      hasReviewed: 'boolean',
      id: 'number',
      name: 'string',
      reviewOpinionStatus: 'string',
      reviewTime: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestResponseBodyResultSubscribers extends $tea.Model {
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestResponseBodyResultTodoListRequirementCheckItems extends $tea.Model {
  itemType?: string;
  pass?: boolean;
  static names(): { [key: string]: string } {
    return {
      itemType: 'itemType',
      pass: 'pass',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemType: 'string',
      pass: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestResponseBodyResultTodoList extends $tea.Model {
  requirementCheckItems?: GetMergeRequestResponseBodyResultTodoListRequirementCheckItems[];
  static names(): { [key: string]: string } {
    return {
      requirementCheckItems: 'requirementCheckItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requirementCheckItems: { 'type': 'array', 'itemType': GetMergeRequestResponseBodyResultTodoListRequirementCheckItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestResponseBodyResult extends $tea.Model {
  ahead?: number;
  allRequirementsPass?: boolean;
  author?: GetMergeRequestResponseBodyResultAuthor;
  behind?: number;
  createFrom?: string;
  createTime?: string;
  description?: string;
  detailUrl?: string;
  localId?: number;
  mergedRevision?: string;
  mrBizId?: string;
  mrType?: string;
  projectId?: number;
  reviewers?: GetMergeRequestResponseBodyResultReviewers[];
  sourceBranch?: string;
  sourceProjectId?: number;
  status?: string;
  subscribers?: GetMergeRequestResponseBodyResultSubscribers[];
  supportMergeFastForwardOnly?: boolean;
  targetBranch?: string;
  targetProjectId?: number;
  targetProjectNameWithNamespace?: string;
  targetProjectPathWithNamespace?: string;
  title?: string;
  todoList?: GetMergeRequestResponseBodyResultTodoList;
  updateTime?: string;
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      ahead: 'ahead',
      allRequirementsPass: 'allRequirementsPass',
      author: 'author',
      behind: 'behind',
      createFrom: 'createFrom',
      createTime: 'createTime',
      description: 'description',
      detailUrl: 'detailUrl',
      localId: 'localId',
      mergedRevision: 'mergedRevision',
      mrBizId: 'mrBizId',
      mrType: 'mrType',
      projectId: 'projectId',
      reviewers: 'reviewers',
      sourceBranch: 'sourceBranch',
      sourceProjectId: 'sourceProjectId',
      status: 'status',
      subscribers: 'subscribers',
      supportMergeFastForwardOnly: 'supportMergeFastForwardOnly',
      targetBranch: 'targetBranch',
      targetProjectId: 'targetProjectId',
      targetProjectNameWithNamespace: 'targetProjectNameWithNamespace',
      targetProjectPathWithNamespace: 'targetProjectPathWithNamespace',
      title: 'title',
      todoList: 'todoList',
      updateTime: 'updateTime',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ahead: 'number',
      allRequirementsPass: 'boolean',
      author: GetMergeRequestResponseBodyResultAuthor,
      behind: 'number',
      createFrom: 'string',
      createTime: 'string',
      description: 'string',
      detailUrl: 'string',
      localId: 'number',
      mergedRevision: 'string',
      mrBizId: 'string',
      mrType: 'string',
      projectId: 'number',
      reviewers: { 'type': 'array', 'itemType': GetMergeRequestResponseBodyResultReviewers },
      sourceBranch: 'string',
      sourceProjectId: 'number',
      status: 'string',
      subscribers: { 'type': 'array', 'itemType': GetMergeRequestResponseBodyResultSubscribers },
      supportMergeFastForwardOnly: 'boolean',
      targetBranch: 'string',
      targetProjectId: 'number',
      targetProjectNameWithNamespace: 'string',
      targetProjectPathWithNamespace: 'string',
      title: 'string',
      todoList: GetMergeRequestResponseBodyResultTodoList,
      updateTime: 'string',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestChangeTreeResponseBodyResultChangedFilesInfos extends $tea.Model {
  addLines?: number;
  binaryFile?: boolean;
  delLines?: number;
  deletedFile?: boolean;
  newFile?: boolean;
  newPath?: string;
  oldPath?: string;
  renamedFile?: boolean;
  static names(): { [key: string]: string } {
    return {
      addLines: 'addLines',
      binaryFile: 'binaryFile',
      delLines: 'delLines',
      deletedFile: 'deletedFile',
      newFile: 'newFile',
      newPath: 'newPath',
      oldPath: 'oldPath',
      renamedFile: 'renamedFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addLines: 'number',
      binaryFile: 'boolean',
      delLines: 'number',
      deletedFile: 'boolean',
      newFile: 'boolean',
      newPath: 'string',
      oldPath: 'string',
      renamedFile: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestChangeTreeResponseBodyResult extends $tea.Model {
  changedFilesCount?: number;
  changedFilesInfos?: GetMergeRequestChangeTreeResponseBodyResultChangedFilesInfos[];
  totalAddLines?: number;
  totalDelLines?: number;
  static names(): { [key: string]: string } {
    return {
      changedFilesCount: 'changedFilesCount',
      changedFilesInfos: 'changedFilesInfos',
      totalAddLines: 'totalAddLines',
      totalDelLines: 'totalDelLines',
    };
  }

  static types(): { [key: string]: any } {
    return {
      changedFilesCount: 'number',
      changedFilesInfos: { 'type': 'array', 'itemType': GetMergeRequestChangeTreeResponseBodyResultChangedFilesInfos },
      totalAddLines: 'number',
      totalDelLines: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrganizationMemberResponseBodyMemberIdentities extends $tea.Model {
  externUid?: string;
  provider?: string;
  static names(): { [key: string]: string } {
    return {
      externUid: 'externUid',
      provider: 'provider',
    };
  }

  static types(): { [key: string]: any } {
    return {
      externUid: 'string',
      provider: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrganizationMemberResponseBodyMember extends $tea.Model {
  accountId?: string;
  birthday?: number;
  deptLists?: string[];
  email?: string;
  hiredDate?: number;
  identities?: GetOrganizationMemberResponseBodyMemberIdentities;
  jobNumber?: string;
  joinTime?: number;
  lastVisitTime?: number;
  mobile?: string;
  organizationMemberName?: string;
  organizationRoleId?: string;
  organizationRoleName?: string;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
      birthday: 'birthday',
      deptLists: 'deptLists',
      email: 'email',
      hiredDate: 'hiredDate',
      identities: 'identities',
      jobNumber: 'jobNumber',
      joinTime: 'joinTime',
      lastVisitTime: 'lastVisitTime',
      mobile: 'mobile',
      organizationMemberName: 'organizationMemberName',
      organizationRoleId: 'organizationRoleId',
      organizationRoleName: 'organizationRoleName',
      state: 'state',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
      birthday: 'number',
      deptLists: { 'type': 'array', 'itemType': 'string' },
      email: 'string',
      hiredDate: 'number',
      identities: GetOrganizationMemberResponseBodyMemberIdentities,
      jobNumber: 'string',
      joinTime: 'number',
      lastVisitTime: 'number',
      mobile: 'string',
      organizationMemberName: 'string',
      organizationRoleId: 'string',
      organizationRoleName: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineResponseBodyPipelinePipelineConfigSourcesData extends $tea.Model {
  branch?: string;
  cloneDepth?: number;
  credentialId?: number;
  credentialLabel?: string;
  credentialType?: string;
  events?: string[];
  isBranchMode?: boolean;
  isCloneDepth?: boolean;
  isSubmodule?: boolean;
  isTrigger?: boolean;
  label?: string;
  namespace?: string;
  repo?: string;
  serviceConnectionId?: number;
  triggerFilter?: string;
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      branch: 'branch',
      cloneDepth: 'cloneDepth',
      credentialId: 'credentialId',
      credentialLabel: 'credentialLabel',
      credentialType: 'credentialType',
      events: 'events',
      isBranchMode: 'isBranchMode',
      isCloneDepth: 'isCloneDepth',
      isSubmodule: 'isSubmodule',
      isTrigger: 'isTrigger',
      label: 'label',
      namespace: 'namespace',
      repo: 'repo',
      serviceConnectionId: 'serviceConnectionId',
      triggerFilter: 'triggerFilter',
      webhook: 'webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      branch: 'string',
      cloneDepth: 'number',
      credentialId: 'number',
      credentialLabel: 'string',
      credentialType: 'string',
      events: { 'type': 'array', 'itemType': 'string' },
      isBranchMode: 'boolean',
      isCloneDepth: 'boolean',
      isSubmodule: 'boolean',
      isTrigger: 'boolean',
      label: 'string',
      namespace: 'string',
      repo: 'string',
      serviceConnectionId: 'number',
      triggerFilter: 'string',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineResponseBodyPipelinePipelineConfigSources extends $tea.Model {
  data?: GetPipelineResponseBodyPipelinePipelineConfigSourcesData;
  sign?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      sign: 'sign',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetPipelineResponseBodyPipelinePipelineConfigSourcesData,
      sign: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineResponseBodyPipelinePipelineConfig extends $tea.Model {
  flow?: string;
  settings?: string;
  sources?: GetPipelineResponseBodyPipelinePipelineConfigSources[];
  static names(): { [key: string]: string } {
    return {
      flow: 'flow',
      settings: 'settings',
      sources: 'sources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flow: 'string',
      settings: 'string',
      sources: { 'type': 'array', 'itemType': GetPipelineResponseBodyPipelinePipelineConfigSources },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineResponseBodyPipelineTagList extends $tea.Model {
  id?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineResponseBodyPipeline extends $tea.Model {
  createTime?: number;
  creatorAccountId?: string;
  envId?: number;
  envName?: string;
  groupId?: number;
  modifierAccountId?: string;
  name?: string;
  pipelineConfig?: GetPipelineResponseBodyPipelinePipelineConfig;
  tagList?: GetPipelineResponseBodyPipelineTagList[];
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'createTime',
      creatorAccountId: 'creatorAccountId',
      envId: 'envId',
      envName: 'envName',
      groupId: 'groupId',
      modifierAccountId: 'modifierAccountId',
      name: 'name',
      pipelineConfig: 'pipelineConfig',
      tagList: 'tagList',
      updateTime: 'updateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      creatorAccountId: 'string',
      envId: 'number',
      envName: 'string',
      groupId: 'number',
      modifierAccountId: 'string',
      name: 'string',
      pipelineConfig: GetPipelineResponseBodyPipelinePipelineConfig,
      tagList: { 'type': 'array', 'itemType': GetPipelineResponseBodyPipelineTagList },
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineGroupResponseBodyPipelineGroup extends $tea.Model {
  createTime?: number;
  id?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'createTime',
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineRunResponseBodyPipelineRunSourcesData extends $tea.Model {
  branch?: string;
  commint?: string;
  repo?: string;
  static names(): { [key: string]: string } {
    return {
      branch: 'branch',
      commint: 'commint',
      repo: 'repo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      branch: 'string',
      commint: 'string',
      repo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineRunResponseBodyPipelineRunSources extends $tea.Model {
  data?: GetPipelineRunResponseBodyPipelineRunSourcesData;
  sign?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      sign: 'sign',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetPipelineRunResponseBodyPipelineRunSourcesData,
      sign: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions extends $tea.Model {
  disable?: boolean;
  params?: { [key: string]: any };
  type?: string;
  static names(): { [key: string]: string } {
    return {
      disable: 'disable',
      params: 'params',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      disable: 'boolean',
      params: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobs extends $tea.Model {
  actions?: GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions[];
  endTime?: number;
  id?: number;
  name?: string;
  params?: string;
  startTime?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      actions: 'actions',
      endTime: 'endTime',
      id: 'id',
      name: 'name',
      params: 'params',
      startTime: 'startTime',
      status: 'status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actions: { 'type': 'array', 'itemType': GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions },
      endTime: 'number',
      id: 'number',
      name: 'string',
      params: 'string',
      startTime: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineRunResponseBodyPipelineRunStagesStageInfo extends $tea.Model {
  endTime?: number;
  jobs?: GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobs[];
  name?: string;
  startTime?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'endTime',
      jobs: 'jobs',
      name: 'name',
      startTime: 'startTime',
      status: 'status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      jobs: { 'type': 'array', 'itemType': GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobs },
      name: 'string',
      startTime: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineRunResponseBodyPipelineRunStages extends $tea.Model {
  name?: string;
  stageInfo?: GetPipelineRunResponseBodyPipelineRunStagesStageInfo;
  static names(): { [key: string]: string } {
    return {
      name: 'name',
      stageInfo: 'stageInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      stageInfo: GetPipelineRunResponseBodyPipelineRunStagesStageInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineRunResponseBodyPipelineRun extends $tea.Model {
  createTime?: number;
  creatorAccountId?: string;
  modifierAccountId?: string;
  pipelineId?: number;
  pipelineRunId?: number;
  sources?: GetPipelineRunResponseBodyPipelineRunSources[];
  stageGroup?: string[][];
  stages?: GetPipelineRunResponseBodyPipelineRunStages[];
  status?: string;
  triggerMode?: number;
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'createTime',
      creatorAccountId: 'creatorAccountId',
      modifierAccountId: 'modifierAccountId',
      pipelineId: 'pipelineId',
      pipelineRunId: 'pipelineRunId',
      sources: 'sources',
      stageGroup: 'stageGroup',
      stages: 'stages',
      status: 'status',
      triggerMode: 'triggerMode',
      updateTime: 'updateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      creatorAccountId: 'string',
      modifierAccountId: 'string',
      pipelineId: 'number',
      pipelineRunId: 'number',
      sources: { 'type': 'array', 'itemType': GetPipelineRunResponseBodyPipelineRunSources },
      stageGroup: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'string' } },
      stages: { 'type': 'array', 'itemType': GetPipelineRunResponseBodyPipelineRunStages },
      status: 'string',
      triggerMode: 'number',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectInfoResponseBodyProject extends $tea.Model {
  category?: string;
  categoryIdentifier?: string;
  creator?: string;
  customCode?: string;
  description?: string;
  gmtCreate?: number;
  gmtModified?: number;
  icon?: string;
  iconBig?: string;
  iconGroup?: string;
  iconSmall?: string;
  id?: string;
  identifier?: string;
  identifierPath?: string;
  logicalStatus?: string;
  modifier?: string;
  name?: string;
  organizationIdentifier?: string;
  parentIdentifier?: string;
  scope?: string;
  statusIdentifier?: string;
  statusStageIdentifier?: string;
  subType?: string;
  typeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'category',
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      customCode: 'customCode',
      description: 'description',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      icon: 'icon',
      iconBig: 'iconBig',
      iconGroup: 'iconGroup',
      iconSmall: 'iconSmall',
      id: 'id',
      identifier: 'identifier',
      identifierPath: 'identifierPath',
      logicalStatus: 'logicalStatus',
      modifier: 'modifier',
      name: 'name',
      organizationIdentifier: 'organizationIdentifier',
      parentIdentifier: 'parentIdentifier',
      scope: 'scope',
      statusIdentifier: 'statusIdentifier',
      statusStageIdentifier: 'statusStageIdentifier',
      subType: 'subType',
      typeIdentifier: 'typeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      categoryIdentifier: 'string',
      creator: 'string',
      customCode: 'string',
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      icon: 'string',
      iconBig: 'string',
      iconGroup: 'string',
      iconSmall: 'string',
      id: 'string',
      identifier: 'string',
      identifierPath: 'string',
      logicalStatus: 'string',
      modifier: 'string',
      name: 'string',
      organizationIdentifier: 'string',
      parentIdentifier: 'string',
      scope: 'string',
      statusIdentifier: 'string',
      statusStageIdentifier: 'string',
      subType: 'string',
      typeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectMemberResponseBodyResult extends $tea.Model {
  accessLevel?: number;
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPushRuleResponseBodyResultRuleInfos extends $tea.Model {
  checkerName?: string;
  checkerType?: string;
  extraMessage?: string;
  fileRuleRegexes?: string[];
  static names(): { [key: string]: string } {
    return {
      checkerName: 'checkerName',
      checkerType: 'checkerType',
      extraMessage: 'extraMessage',
      fileRuleRegexes: 'fileRuleRegexes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkerName: 'string',
      checkerType: 'string',
      extraMessage: 'string',
      fileRuleRegexes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPushRuleResponseBodyResult extends $tea.Model {
  gmtCreate?: string;
  gmtModified?: string;
  id?: number;
  ruleInfos?: GetPushRuleResponseBodyResultRuleInfos[];
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      id: 'id',
      ruleInfos: 'ruleInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      ruleInfos: { 'type': 'array', 'itemType': GetPushRuleResponseBodyResultRuleInfos },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryResponseBodyRepositoryNamespace extends $tea.Model {
  avatar?: string;
  createdAt?: string;
  description?: string;
  id?: number;
  name?: string;
  ownerId?: number;
  path?: string;
  updatedAt?: string;
  visibilityLevel?: number;
  static names(): { [key: string]: string } {
    return {
      avatar: 'avatar',
      createdAt: 'createdAt',
      description: 'description',
      id: 'id',
      name: 'name',
      ownerId: 'ownerId',
      path: 'path',
      updatedAt: 'updatedAt',
      visibilityLevel: 'visibilityLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatar: 'string',
      createdAt: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
      ownerId: 'number',
      path: 'string',
      updatedAt: 'string',
      visibilityLevel: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryResponseBodyRepository extends $tea.Model {
  archive?: boolean;
  avatarUrl?: string;
  createdAt?: string;
  creatorId?: number;
  defaultBranch?: string;
  demoProjectStatus?: boolean;
  description?: string;
  httpUrlToRepository?: string;
  id?: number;
  lastActivityAt?: string;
  name?: string;
  nameWithNamespace?: string;
  namespace?: GetRepositoryResponseBodyRepositoryNamespace;
  path?: string;
  pathWithNamespace?: string;
  sshUrlToRepository?: string;
  visibilityLevel?: number;
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      archive: 'archive',
      avatarUrl: 'avatarUrl',
      createdAt: 'createdAt',
      creatorId: 'creatorId',
      defaultBranch: 'defaultBranch',
      demoProjectStatus: 'demoProjectStatus',
      description: 'description',
      httpUrlToRepository: 'httpUrlToRepository',
      id: 'id',
      lastActivityAt: 'lastActivityAt',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      namespace: 'namespace',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      sshUrlToRepository: 'sshUrlToRepository',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      archive: 'boolean',
      avatarUrl: 'string',
      createdAt: 'string',
      creatorId: 'number',
      defaultBranch: 'string',
      demoProjectStatus: 'boolean',
      description: 'string',
      httpUrlToRepository: 'string',
      id: 'number',
      lastActivityAt: 'string',
      name: 'string',
      nameWithNamespace: 'string',
      namespace: GetRepositoryResponseBodyRepositoryNamespace,
      path: 'string',
      pathWithNamespace: 'string',
      sshUrlToRepository: 'string',
      visibilityLevel: 'number',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryCommitResponseBodyResultAuthor extends $tea.Model {
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  state?: string;
  username?: string;
  websiteUrl?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
      websiteUrl: 'websiteUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
      websiteUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryCommitResponseBodyResultCommitter extends $tea.Model {
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  state?: string;
  username?: string;
  websiteUrl?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
      websiteUrl: 'websiteUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
      websiteUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryCommitResponseBodyResultSignature extends $tea.Model {
  gpgKeyId?: string;
  verificationStatus?: string;
  static names(): { [key: string]: string } {
    return {
      gpgKeyId: 'gpgKeyId',
      verificationStatus: 'verificationStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gpgKeyId: 'string',
      verificationStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryCommitResponseBodyResult extends $tea.Model {
  author?: GetRepositoryCommitResponseBodyResultAuthor;
  authorEmail?: string;
  authorName?: string;
  authoredDate?: string;
  commentsCount?: number;
  committedDate?: string;
  committer?: GetRepositoryCommitResponseBodyResultCommitter;
  committerEmail?: string;
  committerName?: string;
  createdAt?: string;
  id?: string;
  message?: string;
  parentIds?: string[];
  shortId?: string;
  signature?: GetRepositoryCommitResponseBodyResultSignature;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      authoredDate: 'authoredDate',
      commentsCount: 'commentsCount',
      committedDate: 'committedDate',
      committer: 'committer',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      signature: 'signature',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: GetRepositoryCommitResponseBodyResultAuthor,
      authorEmail: 'string',
      authorName: 'string',
      authoredDate: 'string',
      commentsCount: 'number',
      committedDate: 'string',
      committer: GetRepositoryCommitResponseBodyResultCommitter,
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      signature: GetRepositoryCommitResponseBodyResultSignature,
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryTagResponseBodyResultCommitSignature extends $tea.Model {
  gpgKeyId?: string;
  verificationStatus?: string;
  static names(): { [key: string]: string } {
    return {
      gpgKeyId: 'gpgKeyId',
      verificationStatus: 'verificationStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gpgKeyId: 'string',
      verificationStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryTagResponseBodyResultCommit extends $tea.Model {
  authorEmail?: string;
  authorName?: string;
  authoredDate?: string;
  committedDate?: string;
  committerEmail?: string;
  committerName?: string;
  createdAt?: string;
  id?: string;
  message?: string;
  parentIds?: string[];
  shortId?: string;
  signature?: GetRepositoryTagResponseBodyResultCommitSignature;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      authoredDate: 'authoredDate',
      committedDate: 'committedDate',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      signature: 'signature',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorEmail: 'string',
      authorName: 'string',
      authoredDate: 'string',
      committedDate: 'string',
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      signature: GetRepositoryTagResponseBodyResultCommitSignature,
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryTagResponseBodyResult extends $tea.Model {
  commit?: GetRepositoryTagResponseBodyResultCommit;
  id?: string;
  message?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      commit: 'commit',
      id: 'id',
      message: 'message',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commit: GetRepositoryTagResponseBodyResultCommit,
      id: 'string',
      message: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSearchCodePreviewResponseBodyResultHighlightTextMap extends $tea.Model {
  clob?: string;
  fileName?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      clob: 'clob',
      fileName: 'fileName',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clob: 'string',
      fileName: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSearchCodePreviewResponseBodyResultSource extends $tea.Model {
  branch?: string;
  checkinDate?: string;
  fileName?: string;
  filePath?: string;
  language?: string;
  organizationId?: string;
  repoPath?: string;
  static names(): { [key: string]: string } {
    return {
      branch: 'branch',
      checkinDate: 'checkinDate',
      fileName: 'fileName',
      filePath: 'filePath',
      language: 'language',
      organizationId: 'organizationId',
      repoPath: 'repoPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      branch: 'string',
      checkinDate: 'string',
      fileName: 'string',
      filePath: 'string',
      language: 'string',
      organizationId: 'string',
      repoPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSearchCodePreviewResponseBodyResult extends $tea.Model {
  docId?: string;
  highlightTextMap?: GetSearchCodePreviewResponseBodyResultHighlightTextMap;
  source?: GetSearchCodePreviewResponseBodyResultSource;
  static names(): { [key: string]: string } {
    return {
      docId: 'docId',
      highlightTextMap: 'highlightTextMap',
      source: 'source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      docId: 'string',
      highlightTextMap: GetSearchCodePreviewResponseBodyResultHighlightTextMap,
      source: GetSearchCodePreviewResponseBodyResultSource,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSprintInfoResponseBodySprint extends $tea.Model {
  creator?: string;
  description?: string;
  endDate?: number;
  gmtCreate?: number;
  gmtModified?: number;
  identifier?: string;
  modifier?: string;
  name?: string;
  owners?: string[];
  scope?: string;
  spaceIdentifier?: string;
  startDate?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      creator: 'creator',
      description: 'description',
      endDate: 'endDate',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      modifier: 'modifier',
      name: 'name',
      owners: 'owners',
      scope: 'scope',
      spaceIdentifier: 'spaceIdentifier',
      startDate: 'startDate',
      status: 'status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creator: 'string',
      description: 'string',
      endDate: 'number',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      modifier: 'string',
      name: 'string',
      owners: { 'type': 'array', 'itemType': 'string' },
      scope: 'string',
      spaceIdentifier: 'string',
      startDate: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestResultListResponseBodyTestResultAssignedTo extends $tea.Model {
  assignedToIdenttifier?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      assignedToIdenttifier: 'assignedToIdenttifier',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedToIdenttifier: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestResultListResponseBodyTestResultCustomFields extends $tea.Model {
  fieldClassName?: string;
  fieldFormat?: string;
  fieldIdentifier?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      fieldClassName: 'fieldClassName',
      fieldFormat: 'fieldFormat',
      fieldIdentifier: 'fieldIdentifier',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldClassName: 'string',
      fieldFormat: 'string',
      fieldIdentifier: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestResultListResponseBodyTestResultTestResultExecutor extends $tea.Model {
  executorIdentifier?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      executorIdentifier: 'executorIdentifier',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      executorIdentifier: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestResultListResponseBodyTestResult extends $tea.Model {
  assignedTo?: GetTestResultListResponseBodyTestResultAssignedTo;
  bugCount?: number;
  categoryIdentifier?: string;
  customFields?: GetTestResultListResponseBodyTestResultCustomFields[];
  gmtCreate?: number;
  spaceIdentifier?: string;
  subject?: string;
  testResultExecutor?: GetTestResultListResponseBodyTestResultTestResultExecutor;
  testResultGmtCreate?: number;
  testResultIdentifier?: string;
  testResultStatus?: string;
  testcaseIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      bugCount: 'bugCount',
      categoryIdentifier: 'categoryIdentifier',
      customFields: 'customFields',
      gmtCreate: 'gmtCreate',
      spaceIdentifier: 'spaceIdentifier',
      subject: 'subject',
      testResultExecutor: 'testResultExecutor',
      testResultGmtCreate: 'testResultGmtCreate',
      testResultIdentifier: 'testResultIdentifier',
      testResultStatus: 'testResultStatus',
      testcaseIdentifier: 'testcaseIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: GetTestResultListResponseBodyTestResultAssignedTo,
      bugCount: 'number',
      categoryIdentifier: 'string',
      customFields: { 'type': 'array', 'itemType': GetTestResultListResponseBodyTestResultCustomFields },
      gmtCreate: 'number',
      spaceIdentifier: 'string',
      subject: 'string',
      testResultExecutor: GetTestResultListResponseBodyTestResultTestResultExecutor,
      testResultGmtCreate: 'number',
      testResultIdentifier: 'string',
      testResultStatus: 'string',
      testcaseIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestcaseListResponseBodyTestcaseAssignedTo extends $tea.Model {
  assignedToIdenttifier?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      assignedToIdenttifier: 'assignedToIdenttifier',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedToIdenttifier: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestcaseListResponseBodyTestcaseCustomFields extends $tea.Model {
  fieldClassName?: string;
  fieldFormat?: string;
  fieldIdentifier?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      fieldClassName: 'fieldClassName',
      fieldFormat: 'fieldFormat',
      fieldIdentifier: 'fieldIdentifier',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldClassName: 'string',
      fieldFormat: 'string',
      fieldIdentifier: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestcaseListResponseBodyTestcaseSpace extends $tea.Model {
  spaceIdentifier?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      spaceIdentifier: 'spaceIdentifier',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spaceIdentifier: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestcaseListResponseBodyTestcaseTags extends $tea.Model {
  name?: string;
  tagIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'name',
      tagIdentifier: 'tagIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      tagIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestcaseListResponseBodyTestcase extends $tea.Model {
  assignedTo?: GetTestcaseListResponseBodyTestcaseAssignedTo;
  categoryIdentifier?: string;
  customFields?: GetTestcaseListResponseBodyTestcaseCustomFields[];
  gmtCreate?: number;
  identifier?: string;
  space?: GetTestcaseListResponseBodyTestcaseSpace;
  subject?: string;
  tags?: GetTestcaseListResponseBodyTestcaseTags[];
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      categoryIdentifier: 'categoryIdentifier',
      customFields: 'customFields',
      gmtCreate: 'gmtCreate',
      identifier: 'identifier',
      space: 'space',
      subject: 'subject',
      tags: 'tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: GetTestcaseListResponseBodyTestcaseAssignedTo,
      categoryIdentifier: 'string',
      customFields: { 'type': 'array', 'itemType': GetTestcaseListResponseBodyTestcaseCustomFields },
      gmtCreate: 'number',
      identifier: 'string',
      space: GetTestcaseListResponseBodyTestcaseSpace,
      subject: 'string',
      tags: { 'type': 'array', 'itemType': GetTestcaseListResponseBodyTestcaseTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserInfoResponseBodyResult extends $tea.Model {
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVMDeployOrderResponseBodyDeployOrderActions extends $tea.Model {
  disable?: boolean;
  params?: any;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      disable: 'disable',
      params: 'params',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      disable: 'boolean',
      params: 'any',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachinesActions extends $tea.Model {
  disable?: boolean;
  params?: any;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      disable: 'disable',
      params: 'params',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      disable: 'boolean',
      params: 'any',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachines extends $tea.Model {
  actions?: GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachinesActions[];
  batchNum?: number;
  clientStatus?: string;
  createTime?: number;
  ip?: string;
  machineSn?: string;
  status?: string;
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      actions: 'actions',
      batchNum: 'batchNum',
      clientStatus: 'clientStatus',
      createTime: 'createTime',
      ip: 'ip',
      machineSn: 'machineSn',
      status: 'status',
      updateTime: 'updateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actions: { 'type': 'array', 'itemType': GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachinesActions },
      batchNum: 'number',
      clientStatus: 'string',
      createTime: 'number',
      ip: 'string',
      machineSn: 'string',
      status: 'string',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfo extends $tea.Model {
  batchNum?: number;
  deployMachines?: GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachines[];
  hostGroupId?: number;
  static names(): { [key: string]: string } {
    return {
      batchNum: 'batchNum',
      deployMachines: 'deployMachines',
      hostGroupId: 'hostGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchNum: 'number',
      deployMachines: { 'type': 'array', 'itemType': GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachines },
      hostGroupId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVMDeployOrderResponseBodyDeployOrder extends $tea.Model {
  actions?: GetVMDeployOrderResponseBodyDeployOrderActions[];
  createTime?: number;
  creator?: string;
  currentBatch?: number;
  deployMachineInfo?: GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfo;
  deployOrderId?: string;
  exceptionCode?: string;
  status?: string;
  totalBatch?: number;
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      actions: 'actions',
      createTime: 'createTime',
      creator: 'creator',
      currentBatch: 'currentBatch',
      deployMachineInfo: 'deployMachineInfo',
      deployOrderId: 'deployOrderId',
      exceptionCode: 'exceptionCode',
      status: 'status',
      totalBatch: 'totalBatch',
      updateTime: 'updateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actions: { 'type': 'array', 'itemType': GetVMDeployOrderResponseBodyDeployOrderActions },
      createTime: 'number',
      creator: 'string',
      currentBatch: 'number',
      deployMachineInfo: GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfo,
      deployOrderId: 'string',
      exceptionCode: 'string',
      status: 'string',
      totalBatch: 'number',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVariableGroupResponseBodyVariableGroupRelatedPipelines extends $tea.Model {
  id?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVariableGroupResponseBodyVariableGroupVariables extends $tea.Model {
  isEncrypted?: boolean;
  name?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      isEncrypted: 'isEncrypted',
      name: 'name',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isEncrypted: 'boolean',
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVariableGroupResponseBodyVariableGroup extends $tea.Model {
  ccreatorAccountId?: string;
  createTime?: number;
  description?: string;
  id?: number;
  modifierAccountId?: string;
  name?: string;
  relatedPipelines?: GetVariableGroupResponseBodyVariableGroupRelatedPipelines[];
  updateTime?: number;
  variables?: GetVariableGroupResponseBodyVariableGroupVariables[];
  static names(): { [key: string]: string } {
    return {
      ccreatorAccountId: 'ccreatorAccountId',
      createTime: 'createTime',
      description: 'description',
      id: 'id',
      modifierAccountId: 'modifierAccountId',
      name: 'name',
      relatedPipelines: 'relatedPipelines',
      updateTime: 'updateTime',
      variables: 'variables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ccreatorAccountId: 'string',
      createTime: 'number',
      description: 'string',
      id: 'number',
      modifierAccountId: 'string',
      name: 'string',
      relatedPipelines: { 'type': 'array', 'itemType': GetVariableGroupResponseBodyVariableGroupRelatedPipelines },
      updateTime: 'number',
      variables: { 'type': 'array', 'itemType': GetVariableGroupResponseBodyVariableGroupVariables },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemActivityResponseBodyActivitiesNewValue extends $tea.Model {
  displayValue?: string;
  plainValue?: string;
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      displayValue: 'displayValue',
      plainValue: 'plainValue',
      resourceType: 'resourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayValue: 'string',
      plainValue: 'string',
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemActivityResponseBodyActivitiesOldValue extends $tea.Model {
  displayValue?: string;
  plainValue?: string;
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      displayValue: 'displayValue',
      plainValue: 'plainValue',
      resourceType: 'resourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayValue: 'string',
      plainValue: 'string',
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemActivityResponseBodyActivitiesProperty extends $tea.Model {
  displayName?: string;
  propertyIdentifier?: string;
  propertyName?: string;
  propertyType?: string;
  static names(): { [key: string]: string } {
    return {
      displayName: 'displayName',
      propertyIdentifier: 'propertyIdentifier',
      propertyName: 'propertyName',
      propertyType: 'propertyType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      propertyIdentifier: 'string',
      propertyName: 'string',
      propertyType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemActivityResponseBodyActivities extends $tea.Model {
  actionType?: string;
  eventId?: number;
  eventTime?: number;
  eventType?: string;
  newValue?: GetWorkItemActivityResponseBodyActivitiesNewValue[];
  oldValue?: GetWorkItemActivityResponseBodyActivitiesOldValue[];
  operator?: string;
  parentEventId?: number;
  property?: GetWorkItemActivityResponseBodyActivitiesProperty;
  resourceIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      actionType: 'actionType',
      eventId: 'eventId',
      eventTime: 'eventTime',
      eventType: 'eventType',
      newValue: 'newValue',
      oldValue: 'oldValue',
      operator: 'operator',
      parentEventId: 'parentEventId',
      property: 'property',
      resourceIdentifier: 'resourceIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionType: 'string',
      eventId: 'number',
      eventTime: 'number',
      eventType: 'string',
      newValue: { 'type': 'array', 'itemType': GetWorkItemActivityResponseBodyActivitiesNewValue },
      oldValue: { 'type': 'array', 'itemType': GetWorkItemActivityResponseBodyActivitiesOldValue },
      operator: 'string',
      parentEventId: 'number',
      property: GetWorkItemActivityResponseBodyActivitiesProperty,
      resourceIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemInfoResponseBodyWorkitemCustomFieldsValueList extends $tea.Model {
  displayValue?: string;
  identifier?: string;
  level?: number;
  value?: string;
  valueEn?: string;
  static names(): { [key: string]: string } {
    return {
      displayValue: 'displayValue',
      identifier: 'identifier',
      level: 'level',
      value: 'value',
      valueEn: 'valueEn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayValue: 'string',
      identifier: 'string',
      level: 'number',
      value: 'string',
      valueEn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemInfoResponseBodyWorkitemCustomFields extends $tea.Model {
  fieldClassName?: string;
  fieldFormat?: string;
  fieldIdentifier?: string;
  level?: number;
  objectValue?: string;
  position?: number;
  value?: string;
  valueList?: GetWorkItemInfoResponseBodyWorkitemCustomFieldsValueList[];
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      fieldClassName: 'fieldClassName',
      fieldFormat: 'fieldFormat',
      fieldIdentifier: 'fieldIdentifier',
      level: 'level',
      objectValue: 'objectValue',
      position: 'position',
      value: 'value',
      valueList: 'valueList',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldClassName: 'string',
      fieldFormat: 'string',
      fieldIdentifier: 'string',
      level: 'number',
      objectValue: 'string',
      position: 'number',
      value: 'string',
      valueList: { 'type': 'array', 'itemType': GetWorkItemInfoResponseBodyWorkitemCustomFieldsValueList },
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemInfoResponseBodyWorkitemTagDetails extends $tea.Model {
  color?: string;
  identifier?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      color: 'color',
      identifier: 'identifier',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      color: 'string',
      identifier: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemInfoResponseBodyWorkitem extends $tea.Model {
  assignedTo?: string;
  categoryIdentifier?: string;
  creator?: string;
  customFields?: GetWorkItemInfoResponseBodyWorkitemCustomFields[];
  document?: string;
  finishTime?: number;
  gmtCreate?: number;
  gmtModified?: number;
  identifier?: string;
  logicalStatus?: string;
  modifier?: string;
  parentIdentifier?: string;
  participant?: string[];
  serialNumber?: string;
  spaceIdentifier?: string;
  spaceName?: string;
  spaceType?: string;
  sprint?: string[];
  status?: string;
  statusIdentifier?: string;
  statusStageIdentifier?: string;
  subject?: string;
  tag?: string[];
  tagDetails?: GetWorkItemInfoResponseBodyWorkitemTagDetails[];
  tracker?: string[];
  updateStatusAt?: number;
  verifier?: string[];
  workitemTypeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      customFields: 'customFields',
      document: 'document',
      finishTime: 'finishTime',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      logicalStatus: 'logicalStatus',
      modifier: 'modifier',
      parentIdentifier: 'parentIdentifier',
      participant: 'participant',
      serialNumber: 'serialNumber',
      spaceIdentifier: 'spaceIdentifier',
      spaceName: 'spaceName',
      spaceType: 'spaceType',
      sprint: 'sprint',
      status: 'status',
      statusIdentifier: 'statusIdentifier',
      statusStageIdentifier: 'statusStageIdentifier',
      subject: 'subject',
      tag: 'tag',
      tagDetails: 'tagDetails',
      tracker: 'tracker',
      updateStatusAt: 'updateStatusAt',
      verifier: 'verifier',
      workitemTypeIdentifier: 'workitemTypeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: 'string',
      categoryIdentifier: 'string',
      creator: 'string',
      customFields: { 'type': 'array', 'itemType': GetWorkItemInfoResponseBodyWorkitemCustomFields },
      document: 'string',
      finishTime: 'number',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      logicalStatus: 'string',
      modifier: 'string',
      parentIdentifier: 'string',
      participant: { 'type': 'array', 'itemType': 'string' },
      serialNumber: 'string',
      spaceIdentifier: 'string',
      spaceName: 'string',
      spaceType: 'string',
      sprint: { 'type': 'array', 'itemType': 'string' },
      status: 'string',
      statusIdentifier: 'string',
      statusStageIdentifier: 'string',
      subject: 'string',
      tag: { 'type': 'array', 'itemType': 'string' },
      tagDetails: { 'type': 'array', 'itemType': GetWorkItemInfoResponseBodyWorkitemTagDetails },
      tracker: { 'type': 'array', 'itemType': 'string' },
      updateStatusAt: 'number',
      verifier: { 'type': 'array', 'itemType': 'string' },
      workitemTypeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemWorkFlowInfoResponseBodyWorkflowStatuses extends $tea.Model {
  creator?: string;
  description?: string;
  gmtCreate?: number;
  gmtModified?: number;
  identifier?: string;
  modifier?: string;
  name?: string;
  resourceType?: string;
  source?: string;
  workflowStageIdentifier?: string;
  workflowStageName?: string;
  static names(): { [key: string]: string } {
    return {
      creator: 'creator',
      description: 'description',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      modifier: 'modifier',
      name: 'name',
      resourceType: 'resourceType',
      source: 'source',
      workflowStageIdentifier: 'workflowStageIdentifier',
      workflowStageName: 'workflowStageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creator: 'string',
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      modifier: 'string',
      name: 'string',
      resourceType: 'string',
      source: 'string',
      workflowStageIdentifier: 'string',
      workflowStageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemWorkFlowInfoResponseBodyWorkflowWorkflowActions extends $tea.Model {
  id?: number;
  name?: string;
  nextWorkflowStatusIdentifier?: string;
  workflowIdentifier?: string;
  workflowStatusIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      name: 'name',
      nextWorkflowStatusIdentifier: 'nextWorkflowStatusIdentifier',
      workflowIdentifier: 'workflowIdentifier',
      workflowStatusIdentifier: 'workflowStatusIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
      nextWorkflowStatusIdentifier: 'string',
      workflowIdentifier: 'string',
      workflowStatusIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemWorkFlowInfoResponseBodyWorkflow extends $tea.Model {
  creator?: string;
  defaultStatusIdentifier?: string;
  description?: string;
  gmtCreate?: number;
  gmtModified?: number;
  identifier?: string;
  modifier?: string;
  name?: string;
  ownerSpaceIdentifier?: string;
  ownerSpaceType?: string;
  resourceType?: string;
  source?: string;
  statusOrder?: string;
  statuses?: GetWorkItemWorkFlowInfoResponseBodyWorkflowStatuses[];
  workflowActions?: GetWorkItemWorkFlowInfoResponseBodyWorkflowWorkflowActions[];
  static names(): { [key: string]: string } {
    return {
      creator: 'creator',
      defaultStatusIdentifier: 'defaultStatusIdentifier',
      description: 'description',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      modifier: 'modifier',
      name: 'name',
      ownerSpaceIdentifier: 'ownerSpaceIdentifier',
      ownerSpaceType: 'ownerSpaceType',
      resourceType: 'resourceType',
      source: 'source',
      statusOrder: 'statusOrder',
      statuses: 'statuses',
      workflowActions: 'workflowActions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creator: 'string',
      defaultStatusIdentifier: 'string',
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      modifier: 'string',
      name: 'string',
      ownerSpaceIdentifier: 'string',
      ownerSpaceType: 'string',
      resourceType: 'string',
      source: 'string',
      statusOrder: 'string',
      statuses: { 'type': 'array', 'itemType': GetWorkItemWorkFlowInfoResponseBodyWorkflowStatuses },
      workflowActions: { 'type': 'array', 'itemType': GetWorkItemWorkFlowInfoResponseBodyWorkflowWorkflowActions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemAttachmentCreatemetaResponseBodyUploadInfo extends $tea.Model {
  accessid?: string;
  dir?: string;
  host?: string;
  policy?: string;
  signature?: string;
  static names(): { [key: string]: string } {
    return {
      accessid: 'accessid',
      dir: 'dir',
      host: 'host',
      policy: 'policy',
      signature: 'signature',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessid: 'string',
      dir: 'string',
      host: 'string',
      policy: 'string',
      signature: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemCommentListResponseBodyCommentListUser extends $tea.Model {
  account?: string;
  avatar?: string;
  identifier?: string;
  nickName?: string;
  realName?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'account',
      avatar: 'avatar',
      identifier: 'identifier',
      nickName: 'nickName',
      realName: 'realName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      avatar: 'string',
      identifier: 'string',
      nickName: 'string',
      realName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemCommentListResponseBodyCommentList extends $tea.Model {
  content?: string;
  createTime?: number;
  formatType?: string;
  id?: number;
  isTop?: boolean;
  modifiedTime?: number;
  parentId?: number;
  targetIdentifier?: string;
  targetType?: string;
  topTime?: number;
  user?: GetWorkitemCommentListResponseBodyCommentListUser;
  static names(): { [key: string]: string } {
    return {
      content: 'content',
      createTime: 'createTime',
      formatType: 'formatType',
      id: 'id',
      isTop: 'isTop',
      modifiedTime: 'modifiedTime',
      parentId: 'parentId',
      targetIdentifier: 'targetIdentifier',
      targetType: 'targetType',
      topTime: 'topTime',
      user: 'user',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      createTime: 'number',
      formatType: 'string',
      id: 'number',
      isTop: 'boolean',
      modifiedTime: 'number',
      parentId: 'number',
      targetIdentifier: 'string',
      targetType: 'string',
      topTime: 'number',
      user: GetWorkitemCommentListResponseBodyCommentListUser,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemFileResponseBodyWorkitemFile extends $tea.Model {
  id?: string;
  name?: string;
  size?: number;
  suffix?: string;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      name: 'name',
      size: 'size',
      suffix: 'suffix',
      url: 'url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      name: 'string',
      size: 'number',
      suffix: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemRelationsResponseBodyRelationList extends $tea.Model {
  assignedTo?: string;
  categoryIdentifier?: string;
  gmtCreate?: string;
  gmtModified?: string;
  identifier?: string;
  spaceIdentifier?: string;
  subject?: string;
  workitemTypeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      categoryIdentifier: 'categoryIdentifier',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      spaceIdentifier: 'spaceIdentifier',
      subject: 'subject',
      workitemTypeIdentifier: 'workitemTypeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: 'string',
      categoryIdentifier: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      identifier: 'string',
      spaceIdentifier: 'string',
      subject: 'string',
      workitemTypeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemTimeTypeListResponseBodyTimeType extends $tea.Model {
  description?: string;
  displayName?: string;
  identifier?: string;
  name?: string;
  position?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'description',
      displayName: 'displayName',
      identifier: 'identifier',
      name: 'name',
      position: 'position',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      displayName: 'string',
      identifier: 'string',
      name: 'string',
      position: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspaceResponseBodyWorkspace extends $tea.Model {
  codeUrl?: string;
  codeVersion?: string;
  createTime?: string;
  id?: string;
  name?: string;
  spec?: string;
  status?: string;
  template?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      codeUrl: 'codeUrl',
      codeVersion: 'codeVersion',
      createTime: 'createTime',
      id: 'id',
      name: 'name',
      spec: 'spec',
      status: 'status',
      template: 'template',
      userId: 'userId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeUrl: 'string',
      codeVersion: 'string',
      createTime: 'string',
      id: 'string',
      name: 'string',
      spec: 'string',
      status: 'string',
      template: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LinkMergeRequestLabelResponseBodyResult extends $tea.Model {
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationMembersResponseBodyRecordsRoleList extends $tea.Model {
  displayName?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      displayName: 'displayName',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationMembersResponseBodyRecords extends $tea.Model {
  avatar?: string;
  description?: string;
  displayName?: string;
  id?: string;
  roleList?: ListApplicationMembersResponseBodyRecordsRoleList[];
  type?: string;
  static names(): { [key: string]: string } {
    return {
      avatar: 'avatar',
      description: 'description',
      displayName: 'displayName',
      id: 'id',
      roleList: 'roleList',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatar: 'string',
      description: 'string',
      displayName: 'string',
      id: 'string',
      roleList: { 'type': 'array', 'itemType': ListApplicationMembersResponseBodyRecordsRoleList },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsResponseBodyData extends $tea.Model {
  creatorAccountId?: string;
  description?: string;
  gmtCreate?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      creatorAccountId: 'creatorAccountId',
      description: 'description',
      gmtCreate: 'gmtCreate',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorAccountId: 'string',
      description: 'string',
      gmtCreate: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckRunsResponseBodyResultAnnotations extends $tea.Model {
  annotationLevel?: string;
  endColumn?: number;
  endLine?: number;
  id?: number;
  message?: string;
  path?: string;
  rawDetails?: string;
  startColumn?: number;
  startLine?: number;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      annotationLevel: 'annotationLevel',
      endColumn: 'endColumn',
      endLine: 'endLine',
      id: 'id',
      message: 'message',
      path: 'path',
      rawDetails: 'rawDetails',
      startColumn: 'startColumn',
      startLine: 'startLine',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotationLevel: 'string',
      endColumn: 'number',
      endLine: 'number',
      id: 'number',
      message: 'string',
      path: 'string',
      rawDetails: 'string',
      startColumn: 'number',
      startLine: 'number',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckRunsResponseBodyResultCheckSuite extends $tea.Model {
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckRunsResponseBodyResultOutputImages extends $tea.Model {
  alt?: string;
  caption?: string;
  imageUrl?: string;
  static names(): { [key: string]: string } {
    return {
      alt: 'alt',
      caption: 'caption',
      imageUrl: 'imageUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alt: 'string',
      caption: 'string',
      imageUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckRunsResponseBodyResultOutput extends $tea.Model {
  images?: ListCheckRunsResponseBodyResultOutputImages[];
  summary?: string;
  text?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      images: 'images',
      summary: 'summary',
      text: 'text',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      images: { 'type': 'array', 'itemType': ListCheckRunsResponseBodyResultOutputImages },
      summary: 'string',
      text: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckRunsResponseBodyResultWriter extends $tea.Model {
  id?: string;
  logoUrl?: string;
  name?: string;
  slug?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      logoUrl: 'logoUrl',
      name: 'name',
      slug: 'slug',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      logoUrl: 'string',
      name: 'string',
      slug: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckRunsResponseBodyResult extends $tea.Model {
  annotations?: ListCheckRunsResponseBodyResultAnnotations[];
  checkSuite?: ListCheckRunsResponseBodyResultCheckSuite;
  completedAt?: string;
  conclusion?: string;
  createdAt?: string;
  detailsUrl?: string;
  externalId?: string;
  headSha?: string;
  id?: number;
  name?: string;
  output?: ListCheckRunsResponseBodyResultOutput;
  startedAt?: string;
  status?: string;
  updatedAt?: string;
  writer?: ListCheckRunsResponseBodyResultWriter;
  static names(): { [key: string]: string } {
    return {
      annotations: 'annotations',
      checkSuite: 'checkSuite',
      completedAt: 'completedAt',
      conclusion: 'conclusion',
      createdAt: 'createdAt',
      detailsUrl: 'detailsUrl',
      externalId: 'externalId',
      headSha: 'headSha',
      id: 'id',
      name: 'name',
      output: 'output',
      startedAt: 'startedAt',
      status: 'status',
      updatedAt: 'updatedAt',
      writer: 'writer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotations: { 'type': 'array', 'itemType': ListCheckRunsResponseBodyResultAnnotations },
      checkSuite: ListCheckRunsResponseBodyResultCheckSuite,
      completedAt: 'string',
      conclusion: 'string',
      createdAt: 'string',
      detailsUrl: 'string',
      externalId: 'string',
      headSha: 'string',
      id: 'number',
      name: 'string',
      output: ListCheckRunsResponseBodyResultOutput,
      startedAt: 'string',
      status: 'string',
      updatedAt: 'string',
      writer: ListCheckRunsResponseBodyResultWriter,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCommitStatusesResponseBodyResultCreator extends $tea.Model {
  aliyunPk?: string;
  avatarUrl?: string;
  login?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      avatarUrl: 'avatarUrl',
      login: 'login',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      avatarUrl: 'string',
      login: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCommitStatusesResponseBodyResult extends $tea.Model {
  context?: string;
  creator?: ListCommitStatusesResponseBodyResultCreator;
  description?: string;
  id?: number;
  sha?: string;
  state?: string;
  targetUrl?: string;
  static names(): { [key: string]: string } {
    return {
      context: 'context',
      creator: 'creator',
      description: 'description',
      id: 'id',
      sha: 'sha',
      state: 'state',
      targetUrl: 'targetUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      context: 'string',
      creator: ListCommitStatusesResponseBodyResultCreator,
      description: 'string',
      id: 'number',
      sha: 'string',
      state: 'string',
      targetUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowTagGroupsResponseBodyFlowTagGroups extends $tea.Model {
  creatorAccountId?: string;
  id?: number;
  modiferAccountId?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      creatorAccountId: 'creatorAccountId',
      id: 'id',
      modiferAccountId: 'modiferAccountId',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorAccountId: 'string',
      id: 'number',
      modiferAccountId: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGroupMemberResponseBodyResult extends $tea.Model {
  accessLevel?: number;
  avatarUrl?: string;
  email?: string;
  id?: number;
  memberType?: string;
  name?: string;
  sourceId?: number;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      memberType: 'memberType',
      name: 'name',
      sourceId: 'sourceId',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      memberType: 'string',
      name: 'string',
      sourceId: 'number',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGroupRepositoriesResponseBodyResult extends $tea.Model {
  archived?: boolean;
  commitCount?: number;
  createdAt?: string;
  creatorId?: number;
  description?: string;
  httpUrl?: string;
  id?: number;
  importUrl?: string;
  isStared?: boolean;
  issuesEnabled?: boolean;
  lastActivityAt?: string;
  mergeRequestsEnabled?: boolean;
  name?: string;
  nameWithNamespace?: string;
  namespaceId?: boolean;
  path?: string;
  pathWithNamespace?: string;
  privateFlag?: boolean;
  snippetsEnabled?: boolean;
  sshUrl?: string;
  starCount?: number;
  updatedAt?: string;
  visibilityLevel?: number;
  webUrl?: string;
  wikiEnabled?: boolean;
  static names(): { [key: string]: string } {
    return {
      archived: 'archived',
      commitCount: 'commitCount',
      createdAt: 'createdAt',
      creatorId: 'creatorId',
      description: 'description',
      httpUrl: 'httpUrl',
      id: 'id',
      importUrl: 'importUrl',
      isStared: 'isStared',
      issuesEnabled: 'issuesEnabled',
      lastActivityAt: 'lastActivityAt',
      mergeRequestsEnabled: 'mergeRequestsEnabled',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      namespaceId: 'namespaceId',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      privateFlag: 'privateFlag',
      snippetsEnabled: 'snippetsEnabled',
      sshUrl: 'sshUrl',
      starCount: 'starCount',
      updatedAt: 'updatedAt',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
      wikiEnabled: 'wikiEnabled',
    };
  }

  static types(): { [key: string]: any } {
    return {
      archived: 'boolean',
      commitCount: 'number',
      createdAt: 'string',
      creatorId: 'number',
      description: 'string',
      httpUrl: 'string',
      id: 'number',
      importUrl: 'string',
      isStared: 'boolean',
      issuesEnabled: 'boolean',
      lastActivityAt: 'string',
      mergeRequestsEnabled: 'boolean',
      name: 'string',
      nameWithNamespace: 'string',
      namespaceId: 'boolean',
      path: 'string',
      pathWithNamespace: 'string',
      privateFlag: 'boolean',
      snippetsEnabled: 'boolean',
      sshUrl: 'string',
      starCount: 'number',
      updatedAt: 'string',
      visibilityLevel: 'number',
      webUrl: 'string',
      wikiEnabled: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHostGroupsResponseBodyHostGroups extends $tea.Model {
  aliyunRegion?: string;
  createTime?: number;
  creatorAccountId?: string;
  description?: string;
  ecsLabelKey?: string;
  ecsLabelValue?: string;
  ecsType?: string;
  hostNum?: number;
  id?: number;
  modifierAccountId?: string;
  name?: string;
  serviceConnectionId?: number;
  type?: string;
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      aliyunRegion: 'aliyunRegion',
      createTime: 'createTime',
      creatorAccountId: 'creatorAccountId',
      description: 'description',
      ecsLabelKey: 'ecsLabelKey',
      ecsLabelValue: 'ecsLabelValue',
      ecsType: 'ecsType',
      hostNum: 'hostNum',
      id: 'id',
      modifierAccountId: 'modifierAccountId',
      name: 'name',
      serviceConnectionId: 'serviceConnectionId',
      type: 'type',
      updateTime: 'updateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunRegion: 'string',
      createTime: 'number',
      creatorAccountId: 'string',
      description: 'string',
      ecsLabelKey: 'string',
      ecsLabelValue: 'string',
      ecsType: 'string',
      hostNum: 'number',
      id: 'number',
      modifierAccountId: 'string',
      name: 'string',
      serviceConnectionId: 'number',
      type: 'string',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJoinedOrganizationsResponseBodyOrganizations extends $tea.Model {
  id?: string;
  isOrgAdmin?: boolean;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      isOrgAdmin: 'isOrgAdmin',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      isOrgAdmin: 'boolean',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponseBodyResultAuthor extends $tea.Model {
  aliyunPk?: string;
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponseBodyResultChildCommentsAuthor extends $tea.Model {
  aliyunPk?: string;
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsAuthor extends $tea.Model {
  aliyunPk?: string;
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsRelatedPatchSet extends $tea.Model {
  commitId?: string;
  createdAt?: string;
  patchSetBizId?: string;
  patchSetName?: string;
  patchSetNo?: string;
  relatedMergeItemType?: string;
  shortId?: string;
  static names(): { [key: string]: string } {
    return {
      commitId: 'commitId',
      createdAt: 'createdAt',
      patchSetBizId: 'patchSetBizId',
      patchSetName: 'patchSetName',
      patchSetNo: 'patchSetNo',
      relatedMergeItemType: 'relatedMergeItemType',
      shortId: 'shortId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commitId: 'string',
      createdAt: 'string',
      patchSetBizId: 'string',
      patchSetName: 'string',
      patchSetNo: 'string',
      relatedMergeItemType: 'string',
      shortId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildComments extends $tea.Model {
  author?: ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsAuthor;
  commentBizId?: string;
  commentTime?: string;
  commentType?: string;
  content?: string;
  deleted?: boolean;
  filePath?: string;
  lastEditTime?: string;
  lineNumber?: string;
  parentCommentBizId?: string;
  relatedPatchSet?: ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsRelatedPatchSet;
  resolved?: boolean;
  rootCommentBizId?: string;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      commentBizId: 'commentBizId',
      commentTime: 'commentTime',
      commentType: 'commentType',
      content: 'content',
      deleted: 'deleted',
      filePath: 'filePath',
      lastEditTime: 'lastEditTime',
      lineNumber: 'lineNumber',
      parentCommentBizId: 'parentCommentBizId',
      relatedPatchSet: 'relatedPatchSet',
      resolved: 'resolved',
      rootCommentBizId: 'rootCommentBizId',
      state: 'state',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsAuthor,
      commentBizId: 'string',
      commentTime: 'string',
      commentType: 'string',
      content: 'string',
      deleted: 'boolean',
      filePath: 'string',
      lastEditTime: 'string',
      lineNumber: 'string',
      parentCommentBizId: 'string',
      relatedPatchSet: ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsRelatedPatchSet,
      resolved: 'boolean',
      rootCommentBizId: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponseBodyResultChildCommentsRelatedPatchSet extends $tea.Model {
  commitId?: string;
  createdAt?: string;
  patchSetBizId?: string;
  patchSetName?: string;
  patchSetNo?: string;
  relatedMergeItemType?: string;
  shortId?: string;
  static names(): { [key: string]: string } {
    return {
      commitId: 'commitId',
      createdAt: 'createdAt',
      patchSetBizId: 'patchSetBizId',
      patchSetName: 'patchSetName',
      patchSetNo: 'patchSetNo',
      relatedMergeItemType: 'relatedMergeItemType',
      shortId: 'shortId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commitId: 'string',
      createdAt: 'string',
      patchSetBizId: 'string',
      patchSetName: 'string',
      patchSetNo: 'string',
      relatedMergeItemType: 'string',
      shortId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponseBodyResultChildComments extends $tea.Model {
  author?: ListMergeRequestCommentsResponseBodyResultChildCommentsAuthor;
  commentBizId?: string;
  commentTime?: string;
  commentType?: string;
  content?: string;
  deleted?: boolean;
  filePath?: string;
  finalChildComments?: ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildComments[];
  lastEditTime?: string;
  lineNumber?: string;
  parentCommentBizId?: string;
  relatedPatchSet?: ListMergeRequestCommentsResponseBodyResultChildCommentsRelatedPatchSet;
  resolved?: boolean;
  rootCommentBizId?: string;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      commentBizId: 'commentBizId',
      commentTime: 'commentTime',
      commentType: 'commentType',
      content: 'content',
      deleted: 'deleted',
      filePath: 'filePath',
      finalChildComments: 'finalChildComments',
      lastEditTime: 'lastEditTime',
      lineNumber: 'lineNumber',
      parentCommentBizId: 'parentCommentBizId',
      relatedPatchSet: 'relatedPatchSet',
      resolved: 'resolved',
      rootCommentBizId: 'rootCommentBizId',
      state: 'state',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: ListMergeRequestCommentsResponseBodyResultChildCommentsAuthor,
      commentBizId: 'string',
      commentTime: 'string',
      commentType: 'string',
      content: 'string',
      deleted: 'boolean',
      filePath: 'string',
      finalChildComments: { 'type': 'array', 'itemType': ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildComments },
      lastEditTime: 'string',
      lineNumber: 'string',
      parentCommentBizId: 'string',
      relatedPatchSet: ListMergeRequestCommentsResponseBodyResultChildCommentsRelatedPatchSet,
      resolved: 'boolean',
      rootCommentBizId: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponseBodyResultRelatedPatchSet extends $tea.Model {
  commitId?: string;
  createdAt?: string;
  patchSetBizId?: string;
  patchSetName?: string;
  patchSetNo?: string;
  relatedMergeItemType?: string;
  shortId?: string;
  static names(): { [key: string]: string } {
    return {
      commitId: 'commitId',
      createdAt: 'createdAt',
      patchSetBizId: 'patchSetBizId',
      patchSetName: 'patchSetName',
      patchSetNo: 'patchSetNo',
      relatedMergeItemType: 'relatedMergeItemType',
      shortId: 'shortId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commitId: 'string',
      createdAt: 'string',
      patchSetBizId: 'string',
      patchSetName: 'string',
      patchSetNo: 'string',
      relatedMergeItemType: 'string',
      shortId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponseBodyResult extends $tea.Model {
  author?: ListMergeRequestCommentsResponseBodyResultAuthor;
  childComments?: ListMergeRequestCommentsResponseBodyResultChildComments[];
  commentBizId?: string;
  commentTime?: string;
  commentType?: string;
  content?: string;
  deleted?: boolean;
  filePath?: string;
  lastEditTime?: string;
  lineNumber?: string;
  parentCommentBizId?: string;
  relatedPatchSet?: ListMergeRequestCommentsResponseBodyResultRelatedPatchSet;
  resolved?: boolean;
  rootCommentBizId?: string;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      childComments: 'childComments',
      commentBizId: 'commentBizId',
      commentTime: 'commentTime',
      commentType: 'commentType',
      content: 'content',
      deleted: 'deleted',
      filePath: 'filePath',
      lastEditTime: 'lastEditTime',
      lineNumber: 'lineNumber',
      parentCommentBizId: 'parentCommentBizId',
      relatedPatchSet: 'relatedPatchSet',
      resolved: 'resolved',
      rootCommentBizId: 'rootCommentBizId',
      state: 'state',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: ListMergeRequestCommentsResponseBodyResultAuthor,
      childComments: { 'type': 'array', 'itemType': ListMergeRequestCommentsResponseBodyResultChildComments },
      commentBizId: 'string',
      commentTime: 'string',
      commentType: 'string',
      content: 'string',
      deleted: 'boolean',
      filePath: 'string',
      lastEditTime: 'string',
      lineNumber: 'string',
      parentCommentBizId: 'string',
      relatedPatchSet: ListMergeRequestCommentsResponseBodyResultRelatedPatchSet,
      resolved: 'boolean',
      rootCommentBizId: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestFilesReadsResponseBodyResultReadUsers extends $tea.Model {
  aliyunPk?: string;
  avatarUrl?: string;
  email?: string;
  name?: string;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      avatarUrl: 'avatarUrl',
      email: 'email',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      avatarUrl: 'string',
      email: 'string',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestFilesReadsResponseBodyResult extends $tea.Model {
  deletedFile?: string;
  newFile?: boolean;
  newFilePath?: string;
  oldFilePath?: string;
  readUsers?: ListMergeRequestFilesReadsResponseBodyResultReadUsers[];
  renamedFile?: string;
  static names(): { [key: string]: string } {
    return {
      deletedFile: 'deletedFile',
      newFile: 'newFile',
      newFilePath: 'newFilePath',
      oldFilePath: 'oldFilePath',
      readUsers: 'readUsers',
      renamedFile: 'renamedFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deletedFile: 'string',
      newFile: 'boolean',
      newFilePath: 'string',
      oldFilePath: 'string',
      readUsers: { 'type': 'array', 'itemType': ListMergeRequestFilesReadsResponseBodyResultReadUsers },
      renamedFile: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestLabelsResponseBodyResult extends $tea.Model {
  color?: string;
  description?: string;
  id?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      color: 'color',
      description: 'description',
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      color: 'string',
      description: 'string',
      id: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestPatchSetsResponseBodyResult extends $tea.Model {
  commitId?: string;
  createdAt?: string;
  patchSetBizId?: string;
  patchSetName?: string;
  patchSetNo?: number;
  relatedMergeItemType?: string;
  shortCommitId?: string;
  static names(): { [key: string]: string } {
    return {
      commitId: 'commitId',
      createdAt: 'createdAt',
      patchSetBizId: 'patchSetBizId',
      patchSetName: 'patchSetName',
      patchSetNo: 'patchSetNo',
      relatedMergeItemType: 'relatedMergeItemType',
      shortCommitId: 'shortCommitId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commitId: 'string',
      createdAt: 'string',
      patchSetBizId: 'string',
      patchSetName: 'string',
      patchSetNo: 'number',
      relatedMergeItemType: 'string',
      shortCommitId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestsResponseBodyResultAuthor extends $tea.Model {
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestsResponseBodyResultLabels extends $tea.Model {
  color?: string;
  description?: string;
  id?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      color: 'color',
      description: 'description',
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      color: 'string',
      description: 'string',
      id: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestsResponseBodyResultReviewers extends $tea.Model {
  avatarUrl?: string;
  email?: string;
  hasCommented?: boolean;
  hasReviewed?: boolean;
  id?: number;
  name?: string;
  reviewOpinionStatus?: string;
  reviewTime?: string;
  state?: string;
  status?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      hasCommented: 'hasCommented',
      hasReviewed: 'hasReviewed',
      id: 'id',
      name: 'name',
      reviewOpinionStatus: 'reviewOpinionStatus',
      reviewTime: 'reviewTime',
      state: 'state',
      status: 'status',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      hasCommented: 'boolean',
      hasReviewed: 'boolean',
      id: 'number',
      name: 'string',
      reviewOpinionStatus: 'string',
      reviewTime: 'string',
      state: 'string',
      status: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestsResponseBodyResultSubscribers extends $tea.Model {
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestsResponseBodyResult extends $tea.Model {
  author?: ListMergeRequestsResponseBodyResultAuthor;
  createdAt?: string;
  creationMethod?: string;
  description?: string;
  detailUrl?: string;
  id?: number;
  iid?: number;
  labels?: ListMergeRequestsResponseBodyResultLabels[];
  localId?: number;
  mergedRevision?: string;
  mrBizId?: string;
  nameWithNamespace?: string;
  newMergeRequestIdentifier?: boolean;
  newVersionState?: string;
  projectId?: number;
  reviewers?: ListMergeRequestsResponseBodyResultReviewers[];
  sourceBranch?: string;
  sourceProjectId?: number;
  sourceType?: string;
  sshUrl?: string;
  state?: string;
  subscribers?: ListMergeRequestsResponseBodyResultSubscribers[];
  supportMergeFFOnly?: boolean;
  targetBranch?: string;
  targetProjectId?: number;
  targetType?: string;
  title?: string;
  updatedAt?: string;
  webUrl?: string;
  workInProgress?: boolean;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      createdAt: 'createdAt',
      creationMethod: 'creationMethod',
      description: 'description',
      detailUrl: 'detailUrl',
      id: 'id',
      iid: 'iid',
      labels: 'labels',
      localId: 'localId',
      mergedRevision: 'mergedRevision',
      mrBizId: 'mrBizId',
      nameWithNamespace: 'nameWithNamespace',
      newMergeRequestIdentifier: 'newMergeRequestIdentifier',
      newVersionState: 'newVersionState',
      projectId: 'projectId',
      reviewers: 'reviewers',
      sourceBranch: 'sourceBranch',
      sourceProjectId: 'sourceProjectId',
      sourceType: 'sourceType',
      sshUrl: 'sshUrl',
      state: 'state',
      subscribers: 'subscribers',
      supportMergeFFOnly: 'supportMergeFFOnly',
      targetBranch: 'targetBranch',
      targetProjectId: 'targetProjectId',
      targetType: 'targetType',
      title: 'title',
      updatedAt: 'updatedAt',
      webUrl: 'webUrl',
      workInProgress: 'workInProgress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: ListMergeRequestsResponseBodyResultAuthor,
      createdAt: 'string',
      creationMethod: 'string',
      description: 'string',
      detailUrl: 'string',
      id: 'number',
      iid: 'number',
      labels: { 'type': 'array', 'itemType': ListMergeRequestsResponseBodyResultLabels },
      localId: 'number',
      mergedRevision: 'string',
      mrBizId: 'string',
      nameWithNamespace: 'string',
      newMergeRequestIdentifier: 'boolean',
      newVersionState: 'string',
      projectId: 'number',
      reviewers: { 'type': 'array', 'itemType': ListMergeRequestsResponseBodyResultReviewers },
      sourceBranch: 'string',
      sourceProjectId: 'number',
      sourceType: 'string',
      sshUrl: 'string',
      state: 'string',
      subscribers: { 'type': 'array', 'itemType': ListMergeRequestsResponseBodyResultSubscribers },
      supportMergeFFOnly: 'boolean',
      targetBranch: 'string',
      targetProjectId: 'number',
      targetType: 'string',
      title: 'string',
      updatedAt: 'string',
      webUrl: 'string',
      workInProgress: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrganizationMembersResponseBodyMembersIdentities extends $tea.Model {
  externUid?: string;
  provider?: string;
  static names(): { [key: string]: string } {
    return {
      externUid: 'externUid',
      provider: 'provider',
    };
  }

  static types(): { [key: string]: any } {
    return {
      externUid: 'string',
      provider: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrganizationMembersResponseBodyMembers extends $tea.Model {
  accountId?: string;
  birthday?: number;
  deptLists?: string[];
  email?: string;
  hiredDate?: number;
  identities?: ListOrganizationMembersResponseBodyMembersIdentities;
  jobNumber?: string;
  joinTime?: number;
  lastVisitTime?: number;
  mobile?: string;
  organizationMemberName?: string;
  organizationRoleId?: string;
  organizationRoleName?: string;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
      birthday: 'birthday',
      deptLists: 'deptLists',
      email: 'email',
      hiredDate: 'hiredDate',
      identities: 'identities',
      jobNumber: 'jobNumber',
      joinTime: 'joinTime',
      lastVisitTime: 'lastVisitTime',
      mobile: 'mobile',
      organizationMemberName: 'organizationMemberName',
      organizationRoleId: 'organizationRoleId',
      organizationRoleName: 'organizationRoleName',
      state: 'state',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
      birthday: 'number',
      deptLists: { 'type': 'array', 'itemType': 'string' },
      email: 'string',
      hiredDate: 'number',
      identities: ListOrganizationMembersResponseBodyMembersIdentities,
      jobNumber: 'string',
      joinTime: 'number',
      lastVisitTime: 'number',
      mobile: 'string',
      organizationMemberName: 'string',
      organizationRoleId: 'string',
      organizationRoleName: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrganizationsResponseBodyResult extends $tea.Model {
  accessLevel?: number;
  id?: number;
  namespaceId?: string;
  organizationAlias?: string;
  organizationId?: string;
  organizationName?: string;
  organizationRole?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      id: 'id',
      namespaceId: 'namespaceId',
      organizationAlias: 'organizationAlias',
      organizationId: 'organizationId',
      organizationName: 'organizationName',
      organizationRole: 'organizationRole',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      id: 'number',
      namespaceId: 'string',
      organizationAlias: 'string',
      organizationId: 'string',
      organizationName: 'string',
      organizationRole: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineGroupPipelinesResponseBodyPipelines extends $tea.Model {
  createTime?: number;
  pipelineId?: number;
  pipelineName?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'createTime',
      pipelineId: 'pipelineId',
      pipelineName: 'pipelineName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      pipelineId: 'number',
      pipelineName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineGroupsResponseBodyPipelineGroups extends $tea.Model {
  createTime?: number;
  id?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'createTime',
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineJobHistorysResponseBodyJobs extends $tea.Model {
  executeNumber?: number;
  identifier?: string;
  jobId?: number;
  jobName?: string;
  operatorAccountId?: string;
  pipelineId?: number;
  pipelineRunId?: number;
  sources?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      executeNumber: 'executeNumber',
      identifier: 'identifier',
      jobId: 'jobId',
      jobName: 'jobName',
      operatorAccountId: 'operatorAccountId',
      pipelineId: 'pipelineId',
      pipelineRunId: 'pipelineRunId',
      sources: 'sources',
      status: 'status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      executeNumber: 'number',
      identifier: 'string',
      jobId: 'number',
      jobName: 'string',
      operatorAccountId: 'string',
      pipelineId: 'number',
      pipelineRunId: 'number',
      sources: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineJobsResponseBodyJobs extends $tea.Model {
  identifier?: string;
  jobName?: string;
  lastJobId?: number;
  lastJobParams?: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'identifier',
      jobName: 'jobName',
      lastJobId: 'lastJobId',
      lastJobParams: 'lastJobParams',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
      jobName: 'string',
      lastJobId: 'number',
      lastJobParams: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineRelationsResponseBodyPipelineRelations extends $tea.Model {
  refObjectId?: number;
  static names(): { [key: string]: string } {
    return {
      refObjectId: 'refObjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      refObjectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineRunsResponseBodyPipelineRuns extends $tea.Model {
  creatorAccountId?: string;
  endTime?: number;
  pipelineId?: number;
  pipelineRunId?: number;
  startTime?: number;
  status?: string;
  triggerMode?: number;
  static names(): { [key: string]: string } {
    return {
      creatorAccountId: 'creatorAccountId',
      endTime: 'endTime',
      pipelineId: 'pipelineId',
      pipelineRunId: 'pipelineRunId',
      startTime: 'startTime',
      status: 'status',
      triggerMode: 'triggerMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorAccountId: 'string',
      endTime: 'number',
      pipelineId: 'number',
      pipelineRunId: 'number',
      startTime: 'number',
      status: 'string',
      triggerMode: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelinesResponseBodyPipelines extends $tea.Model {
  createTime?: number;
  creatorAccountId?: string;
  groupId?: number;
  pipelineId?: number;
  pipelineName?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'createTime',
      creatorAccountId: 'creatorAccountId',
      groupId: 'groupId',
      pipelineId: 'pipelineId',
      pipelineName: 'pipelineName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      creatorAccountId: 'string',
      groupId: 'number',
      pipelineId: 'number',
      pipelineName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectLabelsResponseBodyResult extends $tea.Model {
  color?: string;
  description?: string;
  id?: string;
  name?: string;
  openMergeRequestsCount?: number;
  static names(): { [key: string]: string } {
    return {
      color: 'color',
      description: 'description',
      id: 'id',
      name: 'name',
      openMergeRequestsCount: 'openMergeRequestsCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      color: 'string',
      description: 'string',
      id: 'string',
      name: 'string',
      openMergeRequestsCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectMembersResponseBodyMembersDivision extends $tea.Model {
  identifier?: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'identifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectMembersResponseBodyMembersOrganizationUserInfo extends $tea.Model {
  organizationIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      organizationIdentifier: 'organizationIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectMembersResponseBodyMembers extends $tea.Model {
  account?: string;
  avatar?: string;
  dingTalkId?: string;
  displayName?: string;
  displayNickName?: string;
  displayRealName?: string;
  division?: ListProjectMembersResponseBodyMembersDivision;
  email?: string;
  gender?: string;
  identifier?: string;
  mobile?: string;
  nameEn?: string;
  nickName?: string;
  nickNamePinyin?: string;
  organizationUserInfo?: ListProjectMembersResponseBodyMembersOrganizationUserInfo;
  realName?: string;
  realNamePinyin?: string;
  roleName?: string;
  stamp?: string;
  tbRoleId?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'account',
      avatar: 'avatar',
      dingTalkId: 'dingTalkId',
      displayName: 'displayName',
      displayNickName: 'displayNickName',
      displayRealName: 'displayRealName',
      division: 'division',
      email: 'email',
      gender: 'gender',
      identifier: 'identifier',
      mobile: 'mobile',
      nameEn: 'nameEn',
      nickName: 'nickName',
      nickNamePinyin: 'nickNamePinyin',
      organizationUserInfo: 'organizationUserInfo',
      realName: 'realName',
      realNamePinyin: 'realNamePinyin',
      roleName: 'roleName',
      stamp: 'stamp',
      tbRoleId: 'tbRoleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      avatar: 'string',
      dingTalkId: 'string',
      displayName: 'string',
      displayNickName: 'string',
      displayRealName: 'string',
      division: ListProjectMembersResponseBodyMembersDivision,
      email: 'string',
      gender: 'string',
      identifier: 'string',
      mobile: 'string',
      nameEn: 'string',
      nickName: 'string',
      nickNamePinyin: 'string',
      organizationUserInfo: ListProjectMembersResponseBodyMembersOrganizationUserInfo,
      realName: 'string',
      realNamePinyin: 'string',
      roleName: 'string',
      stamp: 'string',
      tbRoleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectTemplatesResponseBodyTemplates extends $tea.Model {
  copyFrom?: string;
  creator?: string;
  description?: string;
  gmtCreate?: number;
  gmtModified?: number;
  icon?: string;
  identifier?: string;
  modifier?: string;
  name?: string;
  nameEn?: string;
  resourceCategory?: string;
  resourceType?: string;
  spaceIdentifier?: string;
  spaceType?: string;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      copyFrom: 'copyFrom',
      creator: 'creator',
      description: 'description',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      icon: 'icon',
      identifier: 'identifier',
      modifier: 'modifier',
      name: 'name',
      nameEn: 'nameEn',
      resourceCategory: 'resourceCategory',
      resourceType: 'resourceType',
      spaceIdentifier: 'spaceIdentifier',
      spaceType: 'spaceType',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      copyFrom: 'string',
      creator: 'string',
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      icon: 'string',
      identifier: 'string',
      modifier: 'string',
      name: 'string',
      nameEn: 'string',
      resourceCategory: 'string',
      resourceType: 'string',
      spaceIdentifier: 'string',
      spaceType: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectWorkitemTypesResponseBodyWorkitemTypes extends $tea.Model {
  addUser?: string;
  categoryIdentifier?: string;
  creator?: string;
  defaultType?: boolean;
  description?: string;
  enable?: boolean;
  gmtAdd?: number;
  gmtCreate?: number;
  identifier?: string;
  name?: string;
  nameEn?: string;
  systemDefault?: boolean;
  static names(): { [key: string]: string } {
    return {
      addUser: 'addUser',
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      defaultType: 'defaultType',
      description: 'description',
      enable: 'enable',
      gmtAdd: 'gmtAdd',
      gmtCreate: 'gmtCreate',
      identifier: 'identifier',
      name: 'name',
      nameEn: 'nameEn',
      systemDefault: 'systemDefault',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addUser: 'string',
      categoryIdentifier: 'string',
      creator: 'string',
      defaultType: 'boolean',
      description: 'string',
      enable: 'boolean',
      gmtAdd: 'number',
      gmtCreate: 'number',
      identifier: 'string',
      name: 'string',
      nameEn: 'string',
      systemDefault: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyProjects extends $tea.Model {
  categoryIdentifier?: string;
  creator?: string;
  customCode?: string;
  deleteTime?: number;
  description?: string;
  gmtCreate?: number;
  icon?: string;
  identifier?: string;
  logicalStatus?: string;
  name?: string;
  scope?: string;
  statusStageIdentifier?: string;
  typeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      customCode: 'customCode',
      deleteTime: 'deleteTime',
      description: 'description',
      gmtCreate: 'gmtCreate',
      icon: 'icon',
      identifier: 'identifier',
      logicalStatus: 'logicalStatus',
      name: 'name',
      scope: 'scope',
      statusStageIdentifier: 'statusStageIdentifier',
      typeIdentifier: 'typeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryIdentifier: 'string',
      creator: 'string',
      customCode: 'string',
      deleteTime: 'number',
      description: 'string',
      gmtCreate: 'number',
      icon: 'string',
      identifier: 'string',
      logicalStatus: 'string',
      name: 'string',
      scope: 'string',
      statusStageIdentifier: 'string',
      typeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResultAllowMergeUsers extends $tea.Model {
  avatar?: string;
  email?: string;
  id?: number;
  name?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatar: 'avatar',
      email: 'email',
      id: 'id',
      name: 'name',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatar: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResultAllowPushUsers extends $tea.Model {
  avatar?: string;
  email?: string;
  id?: number;
  name?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatar: 'avatar',
      email: 'email',
      id: 'id',
      name: 'name',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatar: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResultMergeRequestSettingDefaultAssignees extends $tea.Model {
  avatar?: string;
  email?: string;
  id?: number;
  name?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatar: 'avatar',
      email: 'email',
      id: 'id',
      name: 'name',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatar: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResultMergeRequestSetting extends $tea.Model {
  allowMergeRequestRoles?: number[];
  defaultAssignees?: ListProtectedBranchesResponseBodyResultMergeRequestSettingDefaultAssignees[];
  isAllowSelfApproval?: boolean;
  isRequireDiscussionProcessed?: boolean;
  isRequired?: boolean;
  isResetApprovalWhenNewPush?: boolean;
  minimumApproval?: number;
  mrMode?: string;
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      allowMergeRequestRoles: 'allowMergeRequestRoles',
      defaultAssignees: 'defaultAssignees',
      isAllowSelfApproval: 'isAllowSelfApproval',
      isRequireDiscussionProcessed: 'isRequireDiscussionProcessed',
      isRequired: 'isRequired',
      isResetApprovalWhenNewPush: 'isResetApprovalWhenNewPush',
      minimumApproval: 'minimumApproval',
      mrMode: 'mrMode',
      whiteList: 'whiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowMergeRequestRoles: { 'type': 'array', 'itemType': 'number' },
      defaultAssignees: { 'type': 'array', 'itemType': ListProtectedBranchesResponseBodyResultMergeRequestSettingDefaultAssignees },
      isAllowSelfApproval: 'boolean',
      isRequireDiscussionProcessed: 'boolean',
      isRequired: 'boolean',
      isResetApprovalWhenNewPush: 'boolean',
      minimumApproval: 'number',
      mrMode: 'string',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems extends $tea.Model {
  isRequired?: boolean;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      isRequired: 'isRequired',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isRequired: 'boolean',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig extends $tea.Model {
  checkItems?: ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems[];
  static names(): { [key: string]: string } {
    return {
      checkItems: 'checkItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkItems: { 'type': 'array', 'itemType': ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig extends $tea.Model {
  bizNo?: string;
  enabled?: boolean;
  message?: string;
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      bizNo: 'bizNo',
      enabled: 'enabled',
      message: 'message',
      taskName: 'taskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizNo: 'string',
      enabled: 'boolean',
      message: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection extends $tea.Model {
  enabled?: boolean;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'enabled',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection extends $tea.Model {
  enabled?: boolean;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'enabled',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResultTestSettingDTO extends $tea.Model {
  checkConfig?: ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig;
  checkTaskQualityConfig?: ListProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig;
  codeGuidelinesDetection?: ListProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection;
  isRequired?: boolean;
  sensitiveInfoDetection?: ListProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection;
  static names(): { [key: string]: string } {
    return {
      checkConfig: 'checkConfig',
      checkTaskQualityConfig: 'checkTaskQualityConfig',
      codeGuidelinesDetection: 'codeGuidelinesDetection',
      isRequired: 'isRequired',
      sensitiveInfoDetection: 'sensitiveInfoDetection',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkConfig: ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig,
      checkTaskQualityConfig: ListProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig,
      codeGuidelinesDetection: ListProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection,
      isRequired: 'boolean',
      sensitiveInfoDetection: ListProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResult extends $tea.Model {
  allowMergeRoles?: number[];
  allowMergeUserIds?: number[];
  allowMergeUsers?: ListProtectedBranchesResponseBodyResultAllowMergeUsers[];
  allowPushRoles?: number[];
  allowPushUserIds?: number[];
  allowPushUsers?: ListProtectedBranchesResponseBodyResultAllowPushUsers[];
  branch?: string;
  createdAt?: string;
  id?: number;
  matches?: string[];
  mergeRequestSetting?: ListProtectedBranchesResponseBodyResultMergeRequestSetting;
  testSettingDTO?: ListProtectedBranchesResponseBodyResultTestSettingDTO;
  updatedAt?: string;
  static names(): { [key: string]: string } {
    return {
      allowMergeRoles: 'allowMergeRoles',
      allowMergeUserIds: 'allowMergeUserIds',
      allowMergeUsers: 'allowMergeUsers',
      allowPushRoles: 'allowPushRoles',
      allowPushUserIds: 'allowPushUserIds',
      allowPushUsers: 'allowPushUsers',
      branch: 'branch',
      createdAt: 'createdAt',
      id: 'id',
      matches: 'matches',
      mergeRequestSetting: 'mergeRequestSetting',
      testSettingDTO: 'testSettingDTO',
      updatedAt: 'updatedAt',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowMergeRoles: { 'type': 'array', 'itemType': 'number' },
      allowMergeUserIds: { 'type': 'array', 'itemType': 'number' },
      allowMergeUsers: { 'type': 'array', 'itemType': ListProtectedBranchesResponseBodyResultAllowMergeUsers },
      allowPushRoles: { 'type': 'array', 'itemType': 'number' },
      allowPushUserIds: { 'type': 'array', 'itemType': 'number' },
      allowPushUsers: { 'type': 'array', 'itemType': ListProtectedBranchesResponseBodyResultAllowPushUsers },
      branch: 'string',
      createdAt: 'string',
      id: 'number',
      matches: { 'type': 'array', 'itemType': 'string' },
      mergeRequestSetting: ListProtectedBranchesResponseBodyResultMergeRequestSetting,
      testSettingDTO: ListProtectedBranchesResponseBodyResultTestSettingDTO,
      updatedAt: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPushRulesResponseBodyResultRuleInfos extends $tea.Model {
  checkerName?: string;
  checkerType?: string;
  extraMessage?: string;
  fileRuleRegexes?: string[];
  static names(): { [key: string]: string } {
    return {
      checkerName: 'checkerName',
      checkerType: 'checkerType',
      extraMessage: 'extraMessage',
      fileRuleRegexes: 'fileRuleRegexes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkerName: 'string',
      checkerType: 'string',
      extraMessage: 'string',
      fileRuleRegexes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPushRulesResponseBodyResult extends $tea.Model {
  gmtCreate?: string;
  gmtModified?: string;
  id?: number;
  ruleInfos?: ListPushRulesResponseBodyResultRuleInfos[];
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      id: 'id',
      ruleInfos: 'ruleInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      ruleInfos: { 'type': 'array', 'itemType': ListPushRulesResponseBodyResultRuleInfos },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoriesResponseBodyResult extends $tea.Model {
  id?: number;
  accessLevel?: number;
  archive?: boolean;
  avatarUrl?: string;
  createdAt?: string;
  description?: string;
  importStatus?: string;
  lastActivityAt?: string;
  name?: string;
  nameWithNamespace?: string;
  namespaceId?: number;
  path?: string;
  pathWithNamespace?: string;
  star?: boolean;
  starCount?: number;
  updatedAt?: string;
  visibilityLevel?: string;
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      accessLevel: 'accessLevel',
      archive: 'archive',
      avatarUrl: 'avatarUrl',
      createdAt: 'createdAt',
      description: 'description',
      importStatus: 'importStatus',
      lastActivityAt: 'lastActivityAt',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      namespaceId: 'namespaceId',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      star: 'star',
      starCount: 'starCount',
      updatedAt: 'updatedAt',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      accessLevel: 'number',
      archive: 'boolean',
      avatarUrl: 'string',
      createdAt: 'string',
      description: 'string',
      importStatus: 'string',
      lastActivityAt: 'string',
      name: 'string',
      nameWithNamespace: 'string',
      namespaceId: 'number',
      path: 'string',
      pathWithNamespace: 'string',
      star: 'boolean',
      starCount: 'number',
      updatedAt: 'string',
      visibilityLevel: 'string',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryBranchesResponseBodyResultCommit extends $tea.Model {
  authorEmail?: string;
  authorName?: string;
  authoredDate?: string;
  committedDate?: string;
  committerEmail?: string;
  committerName?: string;
  createdAt?: string;
  id?: string;
  message?: string;
  parentIds?: string[];
  shortId?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      authoredDate: 'authoredDate',
      committedDate: 'committedDate',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorEmail: 'string',
      authorName: 'string',
      authoredDate: 'string',
      committedDate: 'string',
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryBranchesResponseBodyResult extends $tea.Model {
  commit?: ListRepositoryBranchesResponseBodyResultCommit;
  name?: string;
  protected?: string;
  static names(): { [key: string]: string } {
    return {
      commit: 'commit',
      name: 'name',
      protected: 'protected',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commit: ListRepositoryBranchesResponseBodyResultCommit,
      name: 'string',
      protected: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitDiffResponseBodyResult extends $tea.Model {
  aMode?: string;
  bMode?: string;
  deletedFile?: boolean;
  diff?: string;
  isBinary?: boolean;
  isNewLfs?: boolean;
  isOldLfs?: boolean;
  newFile?: boolean;
  newId?: string;
  newPath?: string;
  oldId?: string;
  oldPath?: string;
  renamedFile?: boolean;
  static names(): { [key: string]: string } {
    return {
      aMode: 'aMode',
      bMode: 'bMode',
      deletedFile: 'deletedFile',
      diff: 'diff',
      isBinary: 'isBinary',
      isNewLfs: 'isNewLfs',
      isOldLfs: 'isOldLfs',
      newFile: 'newFile',
      newId: 'newId',
      newPath: 'newPath',
      oldId: 'oldId',
      oldPath: 'oldPath',
      renamedFile: 'renamedFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aMode: 'string',
      bMode: 'string',
      deletedFile: 'boolean',
      diff: 'string',
      isBinary: 'boolean',
      isNewLfs: 'boolean',
      isOldLfs: 'boolean',
      newFile: 'boolean',
      newId: 'string',
      newPath: 'string',
      oldId: 'string',
      oldPath: 'string',
      renamedFile: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitsResponseBodyResultAuthor extends $tea.Model {
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  state?: string;
  username?: string;
  websiteUrl?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
      websiteUrl: 'websiteUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
      websiteUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitsResponseBodyResultCommitter extends $tea.Model {
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  state?: string;
  username?: string;
  websiteUrl?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
      websiteUrl: 'websiteUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
      websiteUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitsResponseBodyResultSignature extends $tea.Model {
  gpgKeyId?: string;
  verificationStatus?: string;
  static names(): { [key: string]: string } {
    return {
      gpgKeyId: 'gpgKeyId',
      verificationStatus: 'verificationStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gpgKeyId: 'string',
      verificationStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitsResponseBodyResult extends $tea.Model {
  author?: ListRepositoryCommitsResponseBodyResultAuthor;
  authorEmail?: string;
  authorName?: string;
  authoredDate?: string;
  commentsCount?: number;
  committedDate?: string;
  committer?: ListRepositoryCommitsResponseBodyResultCommitter;
  committerEmail?: string;
  committerName?: string;
  createdAt?: string;
  id?: string;
  message?: string;
  parentIds?: string[];
  shortId?: string;
  signature?: ListRepositoryCommitsResponseBodyResultSignature;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      authoredDate: 'authoredDate',
      commentsCount: 'commentsCount',
      committedDate: 'committedDate',
      committer: 'committer',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      signature: 'signature',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: ListRepositoryCommitsResponseBodyResultAuthor,
      authorEmail: 'string',
      authorName: 'string',
      authoredDate: 'string',
      commentsCount: 'number',
      committedDate: 'string',
      committer: ListRepositoryCommitsResponseBodyResultCommitter,
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      signature: ListRepositoryCommitsResponseBodyResultSignature,
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryGroupsResponseBodyResult extends $tea.Model {
  accessLevel?: number;
  avatarUrl?: string;
  createdAt?: string;
  description?: string;
  groupCount?: number;
  id?: number;
  name?: string;
  nameWithNamespace?: string;
  ownerId?: number;
  parentId?: number;
  path?: string;
  pathWithNamespace?: string;
  projectCount?: number;
  type?: string;
  updatedAt?: string;
  visibilityLevel?: number;
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      avatarUrl: 'avatarUrl',
      createdAt: 'createdAt',
      description: 'description',
      groupCount: 'groupCount',
      id: 'id',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      ownerId: 'ownerId',
      parentId: 'parentId',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      projectCount: 'projectCount',
      type: 'type',
      updatedAt: 'updatedAt',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      avatarUrl: 'string',
      createdAt: 'string',
      description: 'string',
      groupCount: 'number',
      id: 'number',
      name: 'string',
      nameWithNamespace: 'string',
      ownerId: 'number',
      parentId: 'number',
      path: 'string',
      pathWithNamespace: 'string',
      projectCount: 'number',
      type: 'string',
      updatedAt: 'string',
      visibilityLevel: 'number',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryMemberWithInheritedResponseBodyResultInherited extends $tea.Model {
  id?: number;
  name?: string;
  nameWithNamespace?: string;
  path?: string;
  pathWithNamespace?: string;
  type?: string;
  visibilityLevel?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      type: 'type',
      visibilityLevel: 'visibilityLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
      nameWithNamespace: 'string',
      path: 'string',
      pathWithNamespace: 'string',
      type: 'string',
      visibilityLevel: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryMemberWithInheritedResponseBodyResult extends $tea.Model {
  accessLevel?: number;
  avatarUrl?: string;
  email?: string;
  id?: number;
  inherited?: ListRepositoryMemberWithInheritedResponseBodyResultInherited;
  name?: string;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      inherited: 'inherited',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      inherited: ListRepositoryMemberWithInheritedResponseBodyResultInherited,
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryTagsResponseBodyResultCommitSignature extends $tea.Model {
  gpgKeyId?: string;
  verificationStatus?: string;
  static names(): { [key: string]: string } {
    return {
      gpgKeyId: 'gpgKeyId',
      verificationStatus: 'verificationStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gpgKeyId: 'string',
      verificationStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryTagsResponseBodyResultCommit extends $tea.Model {
  authorEmail?: string;
  authorName?: string;
  authoredDate?: string;
  committedDate?: string;
  committerEmail?: string;
  committerName?: string;
  createdAt?: string;
  id?: string;
  message?: string;
  parentIds?: string[];
  shortId?: string;
  signature?: ListRepositoryTagsResponseBodyResultCommitSignature;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      authoredDate: 'authoredDate',
      committedDate: 'committedDate',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      signature: 'signature',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorEmail: 'string',
      authorName: 'string',
      authoredDate: 'string',
      committedDate: 'string',
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      signature: ListRepositoryTagsResponseBodyResultCommitSignature,
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryTagsResponseBodyResult extends $tea.Model {
  commit?: ListRepositoryTagsResponseBodyResultCommit;
  id?: string;
  message?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      commit: 'commit',
      id: 'id',
      message: 'message',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commit: ListRepositoryTagsResponseBodyResultCommit,
      id: 'string',
      message: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryTreeResponseBodyResult extends $tea.Model {
  id?: string;
  isLFS?: boolean;
  mode?: string;
  name?: string;
  path?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      isLFS: 'isLFS',
      mode: 'mode',
      name: 'name',
      path: 'path',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      isLFS: 'boolean',
      mode: 'string',
      name: 'string',
      path: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryWebhookResponseBodyResult extends $tea.Model {
  createdAt?: string;
  description?: string;
  enableSslVerification?: boolean;
  id?: number;
  lastTestResult?: string;
  mergeRequestsEvents?: boolean;
  noteEvents?: boolean;
  projectId?: number;
  pushEvents?: boolean;
  secretToken?: string;
  tagPushEvents?: boolean;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      createdAt: 'createdAt',
      description: 'description',
      enableSslVerification: 'enableSslVerification',
      id: 'id',
      lastTestResult: 'lastTestResult',
      mergeRequestsEvents: 'mergeRequestsEvents',
      noteEvents: 'noteEvents',
      projectId: 'projectId',
      pushEvents: 'pushEvents',
      secretToken: 'secretToken',
      tagPushEvents: 'tagPushEvents',
      url: 'url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdAt: 'string',
      description: 'string',
      enableSslVerification: 'boolean',
      id: 'number',
      lastTestResult: 'string',
      mergeRequestsEvents: 'boolean',
      noteEvents: 'boolean',
      projectId: 'number',
      pushEvents: 'boolean',
      secretToken: 'string',
      tagPushEvents: 'boolean',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourceMembersResponseBodyResourceMembers extends $tea.Model {
  accountId?: string;
  roleName?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
      roleName: 'roleName',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
      roleName: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchCommitRequestRepoPath extends $tea.Model {
  matchType?: string;
  operatorType?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      matchType: 'matchType',
      operatorType: 'operatorType',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchType: 'string',
      operatorType: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchCommitResponseBodyResultHighlightTextMap extends $tea.Model {
  commitId?: string;
  commitMessage?: string;
  organizationId?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      commitId: 'commitId',
      commitMessage: 'commitMessage',
      organizationId: 'organizationId',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commitId: 'string',
      commitMessage: 'string',
      organizationId: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchCommitResponseBodyResultSourceAuthor extends $tea.Model {
  email?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      email: 'email',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      email: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchCommitResponseBodyResultSource extends $tea.Model {
  author?: ListSearchCommitResponseBodyResultSourceAuthor;
  authorTime?: string;
  commitId?: string;
  commitMessage?: string;
  organizationId?: string;
  repoPath?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      authorTime: 'authorTime',
      commitId: 'commitId',
      commitMessage: 'commitMessage',
      organizationId: 'organizationId',
      repoPath: 'repoPath',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: ListSearchCommitResponseBodyResultSourceAuthor,
      authorTime: 'string',
      commitId: 'string',
      commitMessage: 'string',
      organizationId: 'string',
      repoPath: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchCommitResponseBodyResult extends $tea.Model {
  docId?: string;
  highlightTextMap?: ListSearchCommitResponseBodyResultHighlightTextMap;
  source?: ListSearchCommitResponseBodyResultSource;
  static names(): { [key: string]: string } {
    return {
      docId: 'docId',
      highlightTextMap: 'highlightTextMap',
      source: 'source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      docId: 'string',
      highlightTextMap: ListSearchCommitResponseBodyResultHighlightTextMap,
      source: ListSearchCommitResponseBodyResultSource,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchRepositoryRequestRepoPath extends $tea.Model {
  matchType?: string;
  operatorType?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      matchType: 'matchType',
      operatorType: 'operatorType',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchType: 'string',
      operatorType: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchRepositoryResponseBodyResultHighlightTextMap extends $tea.Model {
  creatorUserId?: string;
  description?: string;
  organizationId?: string;
  readMe?: string;
  repoNameWithNamespace?: string;
  repoPath?: string;
  static names(): { [key: string]: string } {
    return {
      creatorUserId: 'creatorUserId',
      description: 'description',
      organizationId: 'organizationId',
      readMe: 'readMe',
      repoNameWithNamespace: 'repoNameWithNamespace',
      repoPath: 'repoPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorUserId: 'string',
      description: 'string',
      organizationId: 'string',
      readMe: 'string',
      repoNameWithNamespace: 'string',
      repoPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchRepositoryResponseBodyResultSource extends $tea.Model {
  createTime?: string;
  description?: string;
  lastActivityTime?: string;
  organizationId?: string;
  readMe?: string;
  repoName?: string;
  repoPath?: string;
  visibilityLevel?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'createTime',
      description: 'description',
      lastActivityTime: 'lastActivityTime',
      organizationId: 'organizationId',
      readMe: 'readMe',
      repoName: 'repoName',
      repoPath: 'repoPath',
      visibilityLevel: 'visibilityLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      description: 'string',
      lastActivityTime: 'string',
      organizationId: 'string',
      readMe: 'string',
      repoName: 'string',
      repoPath: 'string',
      visibilityLevel: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchRepositoryResponseBodyResult extends $tea.Model {
  docId?: string;
  highlightTextMap?: ListSearchRepositoryResponseBodyResultHighlightTextMap;
  source?: ListSearchRepositoryResponseBodyResultSource;
  static names(): { [key: string]: string } {
    return {
      docId: 'docId',
      highlightTextMap: 'highlightTextMap',
      source: 'source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      docId: 'string',
      highlightTextMap: ListSearchRepositoryResponseBodyResultHighlightTextMap,
      source: ListSearchRepositoryResponseBodyResultSource,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchSourceCodeRequestFilePath extends $tea.Model {
  matchType?: string;
  operatorType?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      matchType: 'matchType',
      operatorType: 'operatorType',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchType: 'string',
      operatorType: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchSourceCodeRequestRepoPath extends $tea.Model {
  matchType?: string;
  operatorType?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      matchType: 'matchType',
      operatorType: 'operatorType',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchType: 'string',
      operatorType: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchSourceCodeResponseBodyResultHighlightTextMap extends $tea.Model {
  clob?: string;
  fileName?: string;
  language?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      clob: 'clob',
      fileName: 'fileName',
      language: 'language',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clob: 'string',
      fileName: 'string',
      language: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchSourceCodeResponseBodyResultSource extends $tea.Model {
  branch?: string;
  checkinDate?: string;
  fileName?: string;
  filePath?: string;
  language?: string;
  organizationId?: string;
  repoPath?: string;
  static names(): { [key: string]: string } {
    return {
      branch: 'branch',
      checkinDate: 'checkinDate',
      fileName: 'fileName',
      filePath: 'filePath',
      language: 'language',
      organizationId: 'organizationId',
      repoPath: 'repoPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      branch: 'string',
      checkinDate: 'string',
      fileName: 'string',
      filePath: 'string',
      language: 'string',
      organizationId: 'string',
      repoPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchSourceCodeResponseBodyResult extends $tea.Model {
  docId?: string;
  highlightTextMap?: ListSearchSourceCodeResponseBodyResultHighlightTextMap;
  source?: ListSearchSourceCodeResponseBodyResultSource;
  static names(): { [key: string]: string } {
    return {
      docId: 'docId',
      highlightTextMap: 'highlightTextMap',
      source: 'source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      docId: 'string',
      highlightTextMap: ListSearchSourceCodeResponseBodyResultHighlightTextMap,
      source: ListSearchSourceCodeResponseBodyResultSource,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceAuthsResponseBodyServiceAuths extends $tea.Model {
  id?: number;
  ownerName?: string;
  ownerStaffId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      ownerName: 'ownerName',
      ownerStaffId: 'ownerStaffId',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      ownerName: 'string',
      ownerStaffId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceConnectionsResponseBodyServiceConnections extends $tea.Model {
  createTime?: number;
  id?: number;
  name?: string;
  ownerAccountId?: number;
  type?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'createTime',
      id: 'id',
      name: 'name',
      ownerAccountId: 'ownerAccountId',
      type: 'type',
      uuid: 'uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      id: 'number',
      name: 'string',
      ownerAccountId: 'number',
      type: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceCredentialsResponseBodyServiceCredentials extends $tea.Model {
  id?: number;
  ownerName?: string;
  ownerStaffId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      ownerName: 'ownerName',
      ownerStaffId: 'ownerStaffId',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      ownerName: 'string',
      ownerStaffId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSprintsResponseBodySprints extends $tea.Model {
  creator?: string;
  description?: string;
  endDate?: number;
  gmtCreate?: number;
  gmtModified?: number;
  identifier?: string;
  modifier?: string;
  name?: string;
  scope?: string;
  spaceIdentifier?: string;
  startDate?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      creator: 'creator',
      description: 'description',
      endDate: 'endDate',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      modifier: 'modifier',
      name: 'name',
      scope: 'scope',
      spaceIdentifier: 'spaceIdentifier',
      startDate: 'startDate',
      status: 'status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creator: 'string',
      description: 'string',
      endDate: 'number',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      modifier: 'string',
      name: 'string',
      scope: 'string',
      spaceIdentifier: 'string',
      startDate: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTestCaseFieldsResponseBodyFieldsOptions extends $tea.Model {
  displayValue?: string;
  fieldIdentifier?: string;
  identifier?: string;
  level?: number;
  position?: number;
  value?: string;
  valueEn?: string;
  static names(): { [key: string]: string } {
    return {
      displayValue: 'displayValue',
      fieldIdentifier: 'fieldIdentifier',
      identifier: 'identifier',
      level: 'level',
      position: 'position',
      value: 'value',
      valueEn: 'valueEn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayValue: 'string',
      fieldIdentifier: 'string',
      identifier: 'string',
      level: 'number',
      position: 'number',
      value: 'string',
      valueEn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTestCaseFieldsResponseBodyFields extends $tea.Model {
  className?: string;
  creator?: string;
  defaultValue?: string;
  description?: string;
  format?: string;
  gmtCreate?: number;
  gmtModified?: number;
  identifier?: string;
  isRequired?: boolean;
  isShowWhenCreate?: boolean;
  isSystemRequired?: boolean;
  linkWithService?: string;
  modifier?: string;
  name?: string;
  options?: ListTestCaseFieldsResponseBodyFieldsOptions[];
  resourceType?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      className: 'className',
      creator: 'creator',
      defaultValue: 'defaultValue',
      description: 'description',
      format: 'format',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      isRequired: 'isRequired',
      isShowWhenCreate: 'isShowWhenCreate',
      isSystemRequired: 'isSystemRequired',
      linkWithService: 'linkWithService',
      modifier: 'modifier',
      name: 'name',
      options: 'options',
      resourceType: 'resourceType',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      className: 'string',
      creator: 'string',
      defaultValue: 'string',
      description: 'string',
      format: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      isRequired: 'boolean',
      isShowWhenCreate: 'boolean',
      isSystemRequired: 'boolean',
      linkWithService: 'string',
      modifier: 'string',
      name: 'string',
      options: { 'type': 'array', 'itemType': ListTestCaseFieldsResponseBodyFieldsOptions },
      resourceType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserDrawRecordByPkResponseBodyData extends $tea.Model {
  aliyunPk?: string;
  drawGroup?: string;
  drawPoolName?: string;
  drawResult?: string;
  gmtCreate?: string;
  taskGroupId?: string;
  uccId?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      drawGroup: 'drawGroup',
      drawPoolName: 'drawPoolName',
      drawResult: 'drawResult',
      gmtCreate: 'gmtCreate',
      taskGroupId: 'taskGroupId',
      uccId: 'uccId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      drawGroup: 'string',
      drawPoolName: 'string',
      drawResult: 'string',
      gmtCreate: 'string',
      taskGroupId: 'string',
      uccId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserKeysResponseBodyResult extends $tea.Model {
  createdAt?: string;
  expireTime?: string;
  fingerPrint?: string;
  id?: number;
  keyScope?: string;
  lastUsedTime?: string;
  publicKey?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      createdAt: 'createdAt',
      expireTime: 'expireTime',
      fingerPrint: 'fingerPrint',
      id: 'id',
      keyScope: 'keyScope',
      lastUsedTime: 'lastUsedTime',
      publicKey: 'publicKey',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdAt: 'string',
      expireTime: 'string',
      fingerPrint: 'string',
      id: 'number',
      keyScope: 'string',
      lastUsedTime: 'string',
      publicKey: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesResponseBodyResultGroupInfosGroupInfo extends $tea.Model {
  createdAt?: string;
  description?: string;
  id?: number;
  name?: string;
  nameWithNamespace?: string;
  ownerId?: number;
  parentId?: number;
  path?: string;
  pathWithNamespace?: string;
  updatedAt?: string;
  visibilityLevel?: number;
  static names(): { [key: string]: string } {
    return {
      createdAt: 'createdAt',
      description: 'description',
      id: 'id',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      ownerId: 'ownerId',
      parentId: 'parentId',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      updatedAt: 'updatedAt',
      visibilityLevel: 'visibilityLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdAt: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
      nameWithNamespace: 'string',
      ownerId: 'number',
      parentId: 'number',
      path: 'string',
      pathWithNamespace: 'string',
      updatedAt: 'string',
      visibilityLevel: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesResponseBodyResultGroupInfosGroupRole extends $tea.Model {
  accessLevel?: number;
  cnRoleName?: string;
  enRoleName?: string;
  sourceId?: number;
  sourceType?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      cnRoleName: 'cnRoleName',
      enRoleName: 'enRoleName',
      sourceId: 'sourceId',
      sourceType: 'sourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      cnRoleName: 'string',
      enRoleName: 'string',
      sourceId: 'number',
      sourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesResponseBodyResultGroupInfos extends $tea.Model {
  groupInfo?: ListUserResourcesResponseBodyResultGroupInfosGroupInfo;
  groupRole?: ListUserResourcesResponseBodyResultGroupInfosGroupRole;
  static names(): { [key: string]: string } {
    return {
      groupInfo: 'groupInfo',
      groupRole: 'groupRole',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupInfo: ListUserResourcesResponseBodyResultGroupInfosGroupInfo,
      groupRole: ListUserResourcesResponseBodyResultGroupInfosGroupRole,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesResponseBodyResultRepositoryInfosRepositoryInfo extends $tea.Model {
  accessLevel?: number;
  archived?: boolean;
  createdAt?: string;
  creatorId?: number;
  description?: string;
  encrypted?: boolean;
  id?: number;
  lastActivityAt?: string;
  name?: string;
  nameWithNamespace?: string;
  namespaceId?: number;
  path?: string;
  pathWithNamespace?: string;
  updatedAt?: string;
  visibilityLevel?: number;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      archived: 'archived',
      createdAt: 'createdAt',
      creatorId: 'creatorId',
      description: 'description',
      encrypted: 'encrypted',
      id: 'id',
      lastActivityAt: 'lastActivityAt',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      namespaceId: 'namespaceId',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      updatedAt: 'updatedAt',
      visibilityLevel: 'visibilityLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      archived: 'boolean',
      createdAt: 'string',
      creatorId: 'number',
      description: 'string',
      encrypted: 'boolean',
      id: 'number',
      lastActivityAt: 'string',
      name: 'string',
      nameWithNamespace: 'string',
      namespaceId: 'number',
      path: 'string',
      pathWithNamespace: 'string',
      updatedAt: 'string',
      visibilityLevel: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesResponseBodyResultRepositoryInfosRepositoryRole extends $tea.Model {
  accessLevel?: number;
  cnRoleName?: string;
  enRoleName?: string;
  sourceId?: number;
  sourceType?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      cnRoleName: 'cnRoleName',
      enRoleName: 'enRoleName',
      sourceId: 'sourceId',
      sourceType: 'sourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      cnRoleName: 'string',
      enRoleName: 'string',
      sourceId: 'number',
      sourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesResponseBodyResultRepositoryInfos extends $tea.Model {
  repositoryInfo?: ListUserResourcesResponseBodyResultRepositoryInfosRepositoryInfo;
  repositoryRole?: ListUserResourcesResponseBodyResultRepositoryInfosRepositoryRole;
  static names(): { [key: string]: string } {
    return {
      repositoryInfo: 'repositoryInfo',
      repositoryRole: 'repositoryRole',
    };
  }

  static types(): { [key: string]: any } {
    return {
      repositoryInfo: ListUserResourcesResponseBodyResultRepositoryInfosRepositoryInfo,
      repositoryRole: ListUserResourcesResponseBodyResultRepositoryInfosRepositoryRole,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesResponseBodyResultUserInfo extends $tea.Model {
  avatarUrl?: string;
  email?: string;
  id?: number;
  name?: string;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesResponseBodyResult extends $tea.Model {
  groupInfos?: ListUserResourcesResponseBodyResultGroupInfos[];
  repositoryInfos?: ListUserResourcesResponseBodyResultRepositoryInfos[];
  userInfo?: ListUserResourcesResponseBodyResultUserInfo;
  static names(): { [key: string]: string } {
    return {
      groupInfos: 'groupInfos',
      repositoryInfos: 'repositoryInfos',
      userInfo: 'userInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupInfos: { 'type': 'array', 'itemType': ListUserResourcesResponseBodyResultGroupInfos },
      repositoryInfos: { 'type': 'array', 'itemType': ListUserResourcesResponseBodyResultRepositoryInfos },
      userInfo: ListUserResourcesResponseBodyResultUserInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVariableGroupsResponseBodyVariableGroupsRelatedPipelines extends $tea.Model {
  id?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVariableGroupsResponseBodyVariableGroupsVariables extends $tea.Model {
  isEncrypted?: boolean;
  name?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      isEncrypted: 'isEncrypted',
      name: 'name',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isEncrypted: 'boolean',
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVariableGroupsResponseBodyVariableGroups extends $tea.Model {
  createTime?: number;
  creatorAccountId?: string;
  description?: string;
  id?: number;
  modifierAccountId?: string;
  name?: string;
  relatedPipelines?: ListVariableGroupsResponseBodyVariableGroupsRelatedPipelines[];
  updateTime?: number;
  variables?: ListVariableGroupsResponseBodyVariableGroupsVariables[];
  static names(): { [key: string]: string } {
    return {
      createTime: 'createTime',
      creatorAccountId: 'creatorAccountId',
      description: 'description',
      id: 'id',
      modifierAccountId: 'modifierAccountId',
      name: 'name',
      relatedPipelines: 'relatedPipelines',
      updateTime: 'updateTime',
      variables: 'variables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      creatorAccountId: 'string',
      description: 'string',
      id: 'number',
      modifierAccountId: 'string',
      name: 'string',
      relatedPipelines: { 'type': 'array', 'itemType': ListVariableGroupsResponseBodyVariableGroupsRelatedPipelines },
      updateTime: 'number',
      variables: { 'type': 'array', 'itemType': ListVariableGroupsResponseBodyVariableGroupsVariables },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkItemAllFieldsResponseBodyFieldsOptions extends $tea.Model {
  displayValue?: string;
  fieldIdentifier?: string;
  identifier?: string;
  level?: number;
  position?: number;
  value?: string;
  valueEn?: string;
  static names(): { [key: string]: string } {
    return {
      displayValue: 'displayValue',
      fieldIdentifier: 'fieldIdentifier',
      identifier: 'identifier',
      level: 'level',
      position: 'position',
      value: 'value',
      valueEn: 'valueEn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayValue: 'string',
      fieldIdentifier: 'string',
      identifier: 'string',
      level: 'number',
      position: 'number',
      value: 'string',
      valueEn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkItemAllFieldsResponseBodyFields extends $tea.Model {
  className?: string;
  creator?: string;
  defaultValue?: string;
  description?: string;
  format?: string;
  gmtCreate?: number;
  gmtModified?: number;
  identifier?: string;
  isRequired?: boolean;
  isShowWhenCreate?: boolean;
  isSystemRequired?: boolean;
  linkWithService?: string;
  modifier?: string;
  name?: string;
  options?: ListWorkItemAllFieldsResponseBodyFieldsOptions[];
  resourceType?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      className: 'className',
      creator: 'creator',
      defaultValue: 'defaultValue',
      description: 'description',
      format: 'format',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      isRequired: 'isRequired',
      isShowWhenCreate: 'isShowWhenCreate',
      isSystemRequired: 'isSystemRequired',
      linkWithService: 'linkWithService',
      modifier: 'modifier',
      name: 'name',
      options: 'options',
      resourceType: 'resourceType',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      className: 'string',
      creator: 'string',
      defaultValue: 'string',
      description: 'string',
      format: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      isRequired: 'boolean',
      isShowWhenCreate: 'boolean',
      isSystemRequired: 'boolean',
      linkWithService: 'string',
      modifier: 'string',
      name: 'string',
      options: { 'type': 'array', 'itemType': ListWorkItemAllFieldsResponseBodyFieldsOptions },
      resourceType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkItemWorkFlowStatusResponseBodyStatuses extends $tea.Model {
  creator?: string;
  description?: string;
  gmtCreate?: number;
  gmtModified?: number;
  identifier?: string;
  modifier?: string;
  name?: string;
  resourceType?: string;
  source?: string;
  workflowStageIdentifier?: string;
  workflowStageName?: string;
  static names(): { [key: string]: string } {
    return {
      creator: 'creator',
      description: 'description',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      modifier: 'modifier',
      name: 'name',
      resourceType: 'resourceType',
      source: 'source',
      workflowStageIdentifier: 'workflowStageIdentifier',
      workflowStageName: 'workflowStageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creator: 'string',
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      modifier: 'string',
      name: 'string',
      resourceType: 'string',
      source: 'string',
      workflowStageIdentifier: 'string',
      workflowStageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemAttachmentsResponseBodyAttachments extends $tea.Model {
  creator?: string;
  fileIdentifier?: string;
  fileName?: string;
  fileSuffix?: string;
  gmtCreate?: number;
  size?: string;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      creator: 'creator',
      fileIdentifier: 'fileIdentifier',
      fileName: 'fileName',
      fileSuffix: 'fileSuffix',
      gmtCreate: 'gmtCreate',
      size: 'size',
      url: 'url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creator: 'string',
      fileIdentifier: 'string',
      fileName: 'string',
      fileSuffix: 'string',
      gmtCreate: 'number',
      size: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser extends $tea.Model {
  identifier?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'identifier',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemEstimateResponseBodyWorkitemTimeEstimate extends $tea.Model {
  description?: string;
  gmtCreate?: number;
  gmtEnd?: number;
  gmtModified?: number;
  gmtStart?: number;
  identifier?: string;
  recordUser?: ListWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser;
  spentTime?: number;
  type?: string;
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'description',
      gmtCreate: 'gmtCreate',
      gmtEnd: 'gmtEnd',
      gmtModified: 'gmtModified',
      gmtStart: 'gmtStart',
      identifier: 'identifier',
      recordUser: 'recordUser',
      spentTime: 'spentTime',
      type: 'type',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      gmtCreate: 'number',
      gmtEnd: 'number',
      gmtModified: 'number',
      gmtStart: 'number',
      identifier: 'string',
      recordUser: ListWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser,
      spentTime: 'number',
      type: 'string',
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemTimeResponseBodyWorkitemTime extends $tea.Model {
  actualTime?: number;
  description?: string;
  gmtCreate?: number;
  gmtEnd?: number;
  gmtModified?: number;
  gmtStart?: number;
  identifier?: string;
  recordUser?: string;
  type?: string;
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      actualTime: 'actualTime',
      description: 'description',
      gmtCreate: 'gmtCreate',
      gmtEnd: 'gmtEnd',
      gmtModified: 'gmtModified',
      gmtStart: 'gmtStart',
      identifier: 'identifier',
      recordUser: 'recordUser',
      type: 'type',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualTime: 'number',
      description: 'string',
      gmtCreate: 'number',
      gmtEnd: 'number',
      gmtModified: 'number',
      gmtStart: 'number',
      identifier: 'string',
      recordUser: 'string',
      type: 'string',
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemsResponseBodyWorkitems extends $tea.Model {
  assignedTo?: string;
  categoryIdentifier?: string;
  creator?: string;
  document?: string;
  finishTime?: number;
  gmtCreate?: number;
  gmtModified?: number;
  identifier?: string;
  logicalStatus?: string;
  modifier?: string;
  parentIdentifier?: string;
  serialNumber?: string;
  spaceIdentifier?: string;
  spaceName?: string;
  spaceType?: string;
  sprintIdentifier?: string;
  status?: string;
  statusIdentifier?: string;
  statusStageIdentifier?: string;
  subject?: string;
  updateStatusAt?: number;
  workitemTypeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      document: 'document',
      finishTime: 'finishTime',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      logicalStatus: 'logicalStatus',
      modifier: 'modifier',
      parentIdentifier: 'parentIdentifier',
      serialNumber: 'serialNumber',
      spaceIdentifier: 'spaceIdentifier',
      spaceName: 'spaceName',
      spaceType: 'spaceType',
      sprintIdentifier: 'sprintIdentifier',
      status: 'status',
      statusIdentifier: 'statusIdentifier',
      statusStageIdentifier: 'statusStageIdentifier',
      subject: 'subject',
      updateStatusAt: 'updateStatusAt',
      workitemTypeIdentifier: 'workitemTypeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: 'string',
      categoryIdentifier: 'string',
      creator: 'string',
      document: 'string',
      finishTime: 'number',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      logicalStatus: 'string',
      modifier: 'string',
      parentIdentifier: 'string',
      serialNumber: 'string',
      spaceIdentifier: 'string',
      spaceName: 'string',
      spaceType: 'string',
      sprintIdentifier: 'string',
      status: 'string',
      statusIdentifier: 'string',
      statusStageIdentifier: 'string',
      subject: 'string',
      updateStatusAt: 'number',
      workitemTypeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkspacesResponseBodyWorkspaces extends $tea.Model {
  codeUrl?: string;
  codeVersion?: string;
  createTime?: string;
  id?: string;
  name?: string;
  spec?: string;
  status?: string;
  template?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      codeUrl: 'codeUrl',
      codeVersion: 'codeVersion',
      createTime: 'createTime',
      id: 'id',
      name: 'name',
      spec: 'spec',
      status: 'status',
      template: 'template',
      userId: 'userId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeUrl: 'string',
      codeVersion: 'string',
      createTime: 'string',
      id: 'string',
      name: 'string',
      spec: 'string',
      status: 'string',
      template: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LogPipelineJobRunResponseBodyLog extends $tea.Model {
  content?: string;
  more?: boolean;
  static names(): { [key: string]: string } {
    return {
      content: 'content',
      more: 'more',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      more: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LogVMDeployMachineResponseBodyDeployMachineLog extends $tea.Model {
  aliyunRegion?: string;
  deployBeginTime?: number;
  deployEndTime?: number;
  deployLog?: string;
  deployLogPath?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunRegion: 'aliyunRegion',
      deployBeginTime: 'deployBeginTime',
      deployEndTime: 'deployEndTime',
      deployLog: 'deployLog',
      deployLogPath: 'deployLogPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunRegion: 'string',
      deployBeginTime: 'number',
      deployEndTime: 'number',
      deployLog: 'string',
      deployLogPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MergeMergeRequestResponseBodyResult extends $tea.Model {
  bizId?: string;
  localId?: number;
  mergedRevision?: string;
  projectId?: number;
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      bizId: 'bizId',
      localId: 'localId',
      mergedRevision: 'mergedRevision',
      projectId: 'projectId',
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizId: 'string',
      localId: 'number',
      mergedRevision: 'string',
      projectId: 'number',
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReopenMergeRequestResponseBodyResult extends $tea.Model {
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetSshKeyResponseBodySshKey extends $tea.Model {
  id?: number;
  publicKey?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      publicKey: 'publicKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      publicKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReviewMergeRequestResponseBodyResult extends $tea.Model {
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TransferRepositoryResponseBodyResult extends $tea.Model {
  accessLevel?: number;
  archived?: boolean;
  createdAt?: string;
  creatorId?: number;
  demoProject?: boolean;
  description?: string;
  encrypted?: boolean;
  id?: number;
  lastActivityAt?: string;
  name?: string;
  nameWithNamespace?: string;
  namespaceId?: number;
  path?: string;
  pathWithNamespace?: string;
  starCount?: number;
  starred?: boolean;
  updatedAt?: string;
  visibilityLevel?: number;
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      archived: 'archived',
      createdAt: 'createdAt',
      creatorId: 'creatorId',
      demoProject: 'demoProject',
      description: 'description',
      encrypted: 'encrypted',
      id: 'id',
      lastActivityAt: 'lastActivityAt',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      namespaceId: 'namespaceId',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      starCount: 'starCount',
      starred: 'starred',
      updatedAt: 'updatedAt',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      archived: 'boolean',
      createdAt: 'string',
      creatorId: 'number',
      demoProject: 'boolean',
      description: 'string',
      encrypted: 'boolean',
      id: 'number',
      lastActivityAt: 'string',
      name: 'string',
      nameWithNamespace: 'string',
      namespaceId: 'number',
      path: 'string',
      pathWithNamespace: 'string',
      starCount: 'number',
      starred: 'boolean',
      updatedAt: 'string',
      visibilityLevel: 'number',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TriggerRepositoryMirrorSyncResponseBodyResult extends $tea.Model {
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAppMemberRequestPlayer extends $tea.Model {
  id?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunRequestAnnotations extends $tea.Model {
  annotationLevel?: string;
  endColumn?: number;
  endLine?: number;
  message?: string;
  path?: string;
  rawDetails?: string;
  startColumn?: number;
  startLine?: number;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      annotationLevel: 'annotationLevel',
      endColumn: 'endColumn',
      endLine: 'endLine',
      message: 'message',
      path: 'path',
      rawDetails: 'rawDetails',
      startColumn: 'startColumn',
      startLine: 'startLine',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotationLevel: 'string',
      endColumn: 'number',
      endLine: 'number',
      message: 'string',
      path: 'string',
      rawDetails: 'string',
      startColumn: 'number',
      startLine: 'number',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunRequestOutputImages extends $tea.Model {
  alt?: string;
  caption?: string;
  imageUrl?: string;
  static names(): { [key: string]: string } {
    return {
      alt: 'alt',
      caption: 'caption',
      imageUrl: 'imageUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alt: 'string',
      caption: 'string',
      imageUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunRequestOutput extends $tea.Model {
  images?: UpdateCheckRunRequestOutputImages[];
  summary?: string;
  text?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      images: 'images',
      summary: 'summary',
      text: 'text',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      images: { 'type': 'array', 'itemType': UpdateCheckRunRequestOutputImages },
      summary: 'string',
      text: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunResponseBodyResultAnnotations extends $tea.Model {
  annotationLevel?: string;
  endColumn?: number;
  endLine?: number;
  id?: number;
  message?: string;
  path?: string;
  rawDetails?: string;
  startColumn?: number;
  startLine?: number;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      annotationLevel: 'annotationLevel',
      endColumn: 'endColumn',
      endLine: 'endLine',
      id: 'id',
      message: 'message',
      path: 'path',
      rawDetails: 'rawDetails',
      startColumn: 'startColumn',
      startLine: 'startLine',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotationLevel: 'string',
      endColumn: 'number',
      endLine: 'number',
      id: 'number',
      message: 'string',
      path: 'string',
      rawDetails: 'string',
      startColumn: 'number',
      startLine: 'number',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunResponseBodyResultCheckSuite extends $tea.Model {
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunResponseBodyResultOutputImages extends $tea.Model {
  alt?: string;
  caption?: string;
  imageUrl?: string;
  static names(): { [key: string]: string } {
    return {
      alt: 'alt',
      caption: 'caption',
      imageUrl: 'imageUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alt: 'string',
      caption: 'string',
      imageUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunResponseBodyResultOutput extends $tea.Model {
  images?: UpdateCheckRunResponseBodyResultOutputImages[];
  summary?: string;
  text?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      images: 'images',
      summary: 'summary',
      text: 'text',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      images: { 'type': 'array', 'itemType': UpdateCheckRunResponseBodyResultOutputImages },
      summary: 'string',
      text: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunResponseBodyResultWriter extends $tea.Model {
  id?: string;
  logoUrl?: string;
  name?: string;
  slug?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      logoUrl: 'logoUrl',
      name: 'name',
      slug: 'slug',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      logoUrl: 'string',
      name: 'string',
      slug: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunResponseBodyResult extends $tea.Model {
  annotations?: UpdateCheckRunResponseBodyResultAnnotations[];
  checkSuite?: UpdateCheckRunResponseBodyResultCheckSuite;
  completedAt?: string;
  conclusion?: string;
  createdAt?: string;
  detailsUrl?: string;
  externalId?: string;
  headSha?: string;
  id?: number;
  name?: string;
  output?: UpdateCheckRunResponseBodyResultOutput;
  startedAt?: string;
  status?: string;
  updatedAt?: string;
  writer?: UpdateCheckRunResponseBodyResultWriter;
  static names(): { [key: string]: string } {
    return {
      annotations: 'annotations',
      checkSuite: 'checkSuite',
      completedAt: 'completedAt',
      conclusion: 'conclusion',
      createdAt: 'createdAt',
      detailsUrl: 'detailsUrl',
      externalId: 'externalId',
      headSha: 'headSha',
      id: 'id',
      name: 'name',
      output: 'output',
      startedAt: 'startedAt',
      status: 'status',
      updatedAt: 'updatedAt',
      writer: 'writer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotations: { 'type': 'array', 'itemType': UpdateCheckRunResponseBodyResultAnnotations },
      checkSuite: UpdateCheckRunResponseBodyResultCheckSuite,
      completedAt: 'string',
      conclusion: 'string',
      createdAt: 'string',
      detailsUrl: 'string',
      externalId: 'string',
      headSha: 'string',
      id: 'number',
      name: 'string',
      output: UpdateCheckRunResponseBodyResultOutput,
      startedAt: 'string',
      status: 'string',
      updatedAt: 'string',
      writer: UpdateCheckRunResponseBodyResultWriter,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileResponseBodyResult extends $tea.Model {
  branchName?: string;
  filePath?: string;
  static names(): { [key: string]: string } {
    return {
      branchName: 'branchName',
      filePath: 'filePath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      branchName: 'string',
      filePath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGroupResponseBodyResult extends $tea.Model {
  avatarUrl?: string;
  description?: string;
  id?: number;
  name?: string;
  nameWithNamespace?: string;
  ownerId?: number;
  parentId?: number;
  path?: string;
  pathWithNamespace?: string;
  type?: string;
  visibilityLevel?: number;
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      description: 'description',
      id: 'id',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      ownerId: 'ownerId',
      parentId: 'parentId',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      type: 'type',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
      nameWithNamespace: 'string',
      ownerId: 'number',
      parentId: 'number',
      path: 'string',
      pathWithNamespace: 'string',
      type: 'string',
      visibilityLevel: 'number',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGroupMemberResponseBodyResult extends $tea.Model {
  accessLevel?: number;
  avatarUrl?: string;
  email?: string;
  id?: number;
  memberType?: string;
  name?: string;
  sourceId?: number;
  state?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      memberType: 'memberType',
      name: 'name',
      sourceId: 'sourceId',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      memberType: 'string',
      name: 'string',
      sourceId: 'number',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMergeRequestResponseBodyResult extends $tea.Model {
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMergeRequestPersonnelResponseBodyResult extends $tea.Model {
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectFieldRequestUpdateBasicFieldRequestList extends $tea.Model {
  propertyKey?: string;
  propertyValue?: string;
  static names(): { [key: string]: string } {
    return {
      propertyKey: 'propertyKey',
      propertyValue: 'propertyValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyKey: 'string',
      propertyValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectFieldRequestUpdateForOpenApiList extends $tea.Model {
  fieldIdentifier?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      fieldIdentifier: 'fieldIdentifier',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldIdentifier: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectFieldResponseBodyProjectFieldList extends $tea.Model {
  displayName?: string;
  identifier?: string;
  value?: string;
  valueType?: string;
  static names(): { [key: string]: string } {
    return {
      displayName: 'displayName',
      identifier: 'identifier',
      value: 'value',
      valueType: 'valueType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      identifier: 'string',
      value: 'string',
      valueType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectFieldResponseBodyProject extends $tea.Model {
  category?: string;
  categoryIdentifier?: string;
  creator?: string;
  customCode?: string;
  description?: string;
  fieldList?: UpdateProjectFieldResponseBodyProjectFieldList[];
  gmtCreate?: number;
  gmtModified?: number;
  icon?: string;
  iconBig?: string;
  iconGroup?: string;
  iconSmall?: string;
  id?: string;
  identifier?: string;
  identifierPath?: string;
  logicalStatus?: string;
  modifier?: string;
  name?: string;
  organizationIdentifier?: string;
  parentIdentifier?: string;
  scope?: string;
  statusIdentifier?: string;
  statusName?: string;
  statusStageIdentifier?: string;
  subType?: string;
  typeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'category',
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      customCode: 'customCode',
      description: 'description',
      fieldList: 'fieldList',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      icon: 'icon',
      iconBig: 'iconBig',
      iconGroup: 'iconGroup',
      iconSmall: 'iconSmall',
      id: 'id',
      identifier: 'identifier',
      identifierPath: 'identifierPath',
      logicalStatus: 'logicalStatus',
      modifier: 'modifier',
      name: 'name',
      organizationIdentifier: 'organizationIdentifier',
      parentIdentifier: 'parentIdentifier',
      scope: 'scope',
      statusIdentifier: 'statusIdentifier',
      statusName: 'statusName',
      statusStageIdentifier: 'statusStageIdentifier',
      subType: 'subType',
      typeIdentifier: 'typeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      categoryIdentifier: 'string',
      creator: 'string',
      customCode: 'string',
      description: 'string',
      fieldList: { 'type': 'array', 'itemType': UpdateProjectFieldResponseBodyProjectFieldList },
      gmtCreate: 'number',
      gmtModified: 'number',
      icon: 'string',
      iconBig: 'string',
      iconGroup: 'string',
      iconSmall: 'string',
      id: 'string',
      identifier: 'string',
      identifierPath: 'string',
      logicalStatus: 'string',
      modifier: 'string',
      name: 'string',
      organizationIdentifier: 'string',
      parentIdentifier: 'string',
      scope: 'string',
      statusIdentifier: 'string',
      statusName: 'string',
      statusStageIdentifier: 'string',
      subType: 'string',
      typeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectLabelResponseBodyResult extends $tea.Model {
  color?: string;
  description?: string;
  id?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      color: 'color',
      description: 'description',
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      color: 'string',
      description: 'string',
      id: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectMemberResponseBodyMember extends $tea.Model {
  gmtCreate?: number;
  gmtModified?: number;
  id?: string;
  roleIdentifier?: string;
  targetIdentifier?: string;
  targetType?: string;
  userIdentifier?: string;
  userType?: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      id: 'id',
      roleIdentifier: 'roleIdentifier',
      targetIdentifier: 'targetIdentifier',
      targetType: 'targetType',
      userIdentifier: 'userIdentifier',
      userType: 'userType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      gmtModified: 'number',
      id: 'string',
      roleIdentifier: 'string',
      targetIdentifier: 'string',
      targetType: 'string',
      userIdentifier: 'string',
      userType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesRequestMergeRequestSetting extends $tea.Model {
  allowMergeRequestRoles?: number[];
  defaultAssignees?: string[];
  isAllowSelfApproval?: boolean;
  isRequireDiscussionProcessed?: boolean;
  isRequired?: boolean;
  isResetApprovalWhenNewPush?: boolean;
  minimumApproval?: number;
  mrMode?: string;
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      allowMergeRequestRoles: 'allowMergeRequestRoles',
      defaultAssignees: 'defaultAssignees',
      isAllowSelfApproval: 'isAllowSelfApproval',
      isRequireDiscussionProcessed: 'isRequireDiscussionProcessed',
      isRequired: 'isRequired',
      isResetApprovalWhenNewPush: 'isResetApprovalWhenNewPush',
      minimumApproval: 'minimumApproval',
      mrMode: 'mrMode',
      whiteList: 'whiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowMergeRequestRoles: { 'type': 'array', 'itemType': 'number' },
      defaultAssignees: { 'type': 'array', 'itemType': 'string' },
      isAllowSelfApproval: 'boolean',
      isRequireDiscussionProcessed: 'boolean',
      isRequired: 'boolean',
      isResetApprovalWhenNewPush: 'boolean',
      minimumApproval: 'number',
      mrMode: 'string',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesRequestTestSettingDTOCheckConfigCheckItems extends $tea.Model {
  isRequired?: boolean;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      isRequired: 'isRequired',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isRequired: 'boolean',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesRequestTestSettingDTOCheckConfig extends $tea.Model {
  checkItems?: UpdateProtectedBranchesRequestTestSettingDTOCheckConfigCheckItems[];
  static names(): { [key: string]: string } {
    return {
      checkItems: 'checkItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkItems: { 'type': 'array', 'itemType': UpdateProtectedBranchesRequestTestSettingDTOCheckConfigCheckItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesRequestTestSettingDTOCheckTaskQualityConfig extends $tea.Model {
  bizNo?: string;
  enabled?: boolean;
  message?: string;
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      bizNo: 'bizNo',
      enabled: 'enabled',
      message: 'message',
      taskName: 'taskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizNo: 'string',
      enabled: 'boolean',
      message: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesRequestTestSettingDTOCodeGuidelinesDetection extends $tea.Model {
  enabled?: boolean;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'enabled',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesRequestTestSettingDTOSensitiveInfoDetection extends $tea.Model {
  enabled?: boolean;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'enabled',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesRequestTestSettingDTO extends $tea.Model {
  checkConfig?: UpdateProtectedBranchesRequestTestSettingDTOCheckConfig;
  checkTaskQualityConfig?: UpdateProtectedBranchesRequestTestSettingDTOCheckTaskQualityConfig;
  codeGuidelinesDetection?: UpdateProtectedBranchesRequestTestSettingDTOCodeGuidelinesDetection;
  isRequired?: boolean;
  sensitiveInfoDetection?: UpdateProtectedBranchesRequestTestSettingDTOSensitiveInfoDetection;
  static names(): { [key: string]: string } {
    return {
      checkConfig: 'checkConfig',
      checkTaskQualityConfig: 'checkTaskQualityConfig',
      codeGuidelinesDetection: 'codeGuidelinesDetection',
      isRequired: 'isRequired',
      sensitiveInfoDetection: 'sensitiveInfoDetection',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkConfig: UpdateProtectedBranchesRequestTestSettingDTOCheckConfig,
      checkTaskQualityConfig: UpdateProtectedBranchesRequestTestSettingDTOCheckTaskQualityConfig,
      codeGuidelinesDetection: UpdateProtectedBranchesRequestTestSettingDTOCodeGuidelinesDetection,
      isRequired: 'boolean',
      sensitiveInfoDetection: UpdateProtectedBranchesRequestTestSettingDTOSensitiveInfoDetection,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesResponseBodyResultMergeRequestSetting extends $tea.Model {
  allowMergeRequestRoles?: number[];
  defaultAssignees?: string[];
  isAllowSelfApproval?: boolean;
  isRequireDiscussionProcessed?: boolean;
  isRequired?: boolean;
  isResetApprovalWhenNewPush?: boolean;
  minimumApproval?: number;
  mrMode?: string;
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      allowMergeRequestRoles: 'allowMergeRequestRoles',
      defaultAssignees: 'defaultAssignees',
      isAllowSelfApproval: 'isAllowSelfApproval',
      isRequireDiscussionProcessed: 'isRequireDiscussionProcessed',
      isRequired: 'isRequired',
      isResetApprovalWhenNewPush: 'isResetApprovalWhenNewPush',
      minimumApproval: 'minimumApproval',
      mrMode: 'mrMode',
      whiteList: 'whiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowMergeRequestRoles: { 'type': 'array', 'itemType': 'number' },
      defaultAssignees: { 'type': 'array', 'itemType': 'string' },
      isAllowSelfApproval: 'boolean',
      isRequireDiscussionProcessed: 'boolean',
      isRequired: 'boolean',
      isResetApprovalWhenNewPush: 'boolean',
      minimumApproval: 'number',
      mrMode: 'string',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems extends $tea.Model {
  isRequired?: boolean;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      isRequired: 'isRequired',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isRequired: 'boolean',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig extends $tea.Model {
  checkItems?: UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems[];
  static names(): { [key: string]: string } {
    return {
      checkItems: 'checkItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkItems: { 'type': 'array', 'itemType': UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig extends $tea.Model {
  bizNo?: string;
  enabled?: boolean;
  message?: string;
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      bizNo: 'bizNo',
      enabled: 'enabled',
      message: 'message',
      taskName: 'taskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizNo: 'string',
      enabled: 'boolean',
      message: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection extends $tea.Model {
  enabled?: boolean;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'enabled',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection extends $tea.Model {
  enabled?: boolean;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'enabled',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesResponseBodyResultTestSettingDTO extends $tea.Model {
  checkConfig?: UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig;
  checkTaskQualityConfig?: UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig;
  codeGuidelinesDetection?: UpdateProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection;
  isRequired?: boolean;
  sensitiveInfoDetection?: UpdateProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection;
  static names(): { [key: string]: string } {
    return {
      checkConfig: 'checkConfig',
      checkTaskQualityConfig: 'checkTaskQualityConfig',
      codeGuidelinesDetection: 'codeGuidelinesDetection',
      isRequired: 'isRequired',
      sensitiveInfoDetection: 'sensitiveInfoDetection',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkConfig: UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig,
      checkTaskQualityConfig: UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig,
      codeGuidelinesDetection: UpdateProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection,
      isRequired: 'boolean',
      sensitiveInfoDetection: UpdateProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesResponseBodyResult extends $tea.Model {
  allowMergeRoles?: number[];
  allowMergeUserIds?: number[];
  allowPushRoles?: number[];
  allowPushUserIds?: number[];
  branch?: string;
  id?: number;
  mergeRequestSetting?: UpdateProtectedBranchesResponseBodyResultMergeRequestSetting;
  testSettingDTO?: UpdateProtectedBranchesResponseBodyResultTestSettingDTO;
  static names(): { [key: string]: string } {
    return {
      allowMergeRoles: 'allowMergeRoles',
      allowMergeUserIds: 'allowMergeUserIds',
      allowPushRoles: 'allowPushRoles',
      allowPushUserIds: 'allowPushUserIds',
      branch: 'branch',
      id: 'id',
      mergeRequestSetting: 'mergeRequestSetting',
      testSettingDTO: 'testSettingDTO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowMergeRoles: { 'type': 'array', 'itemType': 'number' },
      allowMergeUserIds: { 'type': 'array', 'itemType': 'number' },
      allowPushRoles: { 'type': 'array', 'itemType': 'number' },
      allowPushUserIds: { 'type': 'array', 'itemType': 'number' },
      branch: 'string',
      id: 'number',
      mergeRequestSetting: UpdateProtectedBranchesResponseBodyResultMergeRequestSetting,
      testSettingDTO: UpdateProtectedBranchesResponseBodyResultTestSettingDTO,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePushReviewOnOffResponseBodyResult extends $tea.Model {
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePushRuleRequestRuleInfos extends $tea.Model {
  checkerName?: string;
  checkerType?: string;
  extraMessage?: string;
  fileRuleRegexes?: string[];
  static names(): { [key: string]: string } {
    return {
      checkerName: 'checkerName',
      checkerType: 'checkerType',
      extraMessage: 'extraMessage',
      fileRuleRegexes: 'fileRuleRegexes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkerName: 'string',
      checkerType: 'string',
      extraMessage: 'string',
      fileRuleRegexes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePushRuleResponseBodyResultRuleInfos extends $tea.Model {
  checkerName?: string;
  checkerType?: string;
  extraMessage?: string;
  fileRuleRegexes?: string[];
  static names(): { [key: string]: string } {
    return {
      checkerName: 'checkerName',
      checkerType: 'checkerType',
      extraMessage: 'extraMessage',
      fileRuleRegexes: 'fileRuleRegexes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkerName: 'string',
      checkerType: 'string',
      extraMessage: 'string',
      fileRuleRegexes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePushRuleResponseBodyResult extends $tea.Model {
  gmtCreate?: string;
  gmtModified?: string;
  id?: number;
  ruleInfos?: UpdatePushRuleResponseBodyResultRuleInfos[];
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      id: 'id',
      ruleInfos: 'ruleInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      ruleInfos: { 'type': 'array', 'itemType': UpdatePushRuleResponseBodyResultRuleInfos },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryRequestProjectCloneDownloadMethodList extends $tea.Model {
  allowed?: boolean;
  permissionCode?: string;
  static names(): { [key: string]: string } {
    return {
      allowed: 'allowed',
      permissionCode: 'permissionCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowed: 'boolean',
      permissionCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryRequestProjectCloneDownloadRoleList extends $tea.Model {
  allowed?: boolean;
  roleCode?: number;
  static names(): { [key: string]: string } {
    return {
      allowed: 'allowed',
      roleCode: 'roleCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowed: 'boolean',
      roleCode: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryResponseBodyResultNamespace extends $tea.Model {
  avatar?: string;
  createdAt?: string;
  description?: string;
  id?: number;
  name?: string;
  ownerId?: number;
  path?: string;
  updatedAt?: string;
  visibilityLevel?: number;
  static names(): { [key: string]: string } {
    return {
      avatar: 'avatar',
      createdAt: 'createdAt',
      description: 'description',
      id: 'id',
      name: 'name',
      ownerId: 'ownerId',
      path: 'path',
      updatedAt: 'updatedAt',
      visibilityLevel: 'visibilityLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatar: 'string',
      createdAt: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
      ownerId: 'number',
      path: 'string',
      updatedAt: 'string',
      visibilityLevel: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryResponseBodyResult extends $tea.Model {
  archived?: boolean;
  avatarUrl?: string;
  buildsEnabled?: boolean;
  createdAt?: string;
  creatorId?: number;
  defaultBranch?: string;
  description?: string;
  httpUrlToRepo?: string;
  id?: number;
  issuesEnabled?: boolean;
  lastActivityAt?: string;
  mergeRequestsEnabled?: boolean;
  name?: string;
  nameWithNamespace?: string;
  namespace?: UpdateRepositoryResponseBodyResultNamespace;
  path?: string;
  pathWithNamespace?: string;
  snippetsEnabled?: boolean;
  sshUrlToRepo?: string;
  visibilityLevel?: number;
  webUrl?: string;
  wikiEnabled?: boolean;
  static names(): { [key: string]: string } {
    return {
      archived: 'archived',
      avatarUrl: 'avatarUrl',
      buildsEnabled: 'buildsEnabled',
      createdAt: 'createdAt',
      creatorId: 'creatorId',
      defaultBranch: 'defaultBranch',
      description: 'description',
      httpUrlToRepo: 'httpUrlToRepo',
      id: 'id',
      issuesEnabled: 'issuesEnabled',
      lastActivityAt: 'lastActivityAt',
      mergeRequestsEnabled: 'mergeRequestsEnabled',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      namespace: 'namespace',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      snippetsEnabled: 'snippetsEnabled',
      sshUrlToRepo: 'sshUrlToRepo',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
      wikiEnabled: 'wikiEnabled',
    };
  }

  static types(): { [key: string]: any } {
    return {
      archived: 'boolean',
      avatarUrl: 'string',
      buildsEnabled: 'boolean',
      createdAt: 'string',
      creatorId: 'number',
      defaultBranch: 'string',
      description: 'string',
      httpUrlToRepo: 'string',
      id: 'number',
      issuesEnabled: 'boolean',
      lastActivityAt: 'string',
      mergeRequestsEnabled: 'boolean',
      name: 'string',
      nameWithNamespace: 'string',
      namespace: UpdateRepositoryResponseBodyResultNamespace,
      path: 'string',
      pathWithNamespace: 'string',
      snippetsEnabled: 'boolean',
      sshUrlToRepo: 'string',
      visibilityLevel: 'number',
      webUrl: 'string',
      wikiEnabled: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryMemberRequestRelatedInfos extends $tea.Model {
  relatedId?: string;
  sourceId?: number;
  sourceType?: string;
  static names(): { [key: string]: string } {
    return {
      relatedId: 'relatedId',
      sourceId: 'sourceId',
      sourceType: 'sourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      relatedId: 'string',
      sourceId: 'number',
      sourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryMemberResponseBodyResult extends $tea.Model {
  accessLevel?: number;
  avatarUrl?: string;
  email?: string;
  expireAt?: string;
  id?: number;
  memberName?: string;
  memberType?: string;
  name?: string;
  sourceId?: number;
  sourceType?: string;
  state?: string;
  username?: string;
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      avatarUrl: 'avatarUrl',
      email: 'email',
      expireAt: 'expireAt',
      id: 'id',
      memberName: 'memberName',
      memberType: 'memberType',
      name: 'name',
      sourceId: 'sourceId',
      sourceType: 'sourceType',
      state: 'state',
      username: 'username',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      avatarUrl: 'string',
      email: 'string',
      expireAt: 'string',
      id: 'number',
      memberName: 'string',
      memberType: 'string',
      name: 'string',
      sourceId: 'number',
      sourceType: 'string',
      state: 'string',
      username: 'string',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseRequestUpdateWorkitemPropertyRequest extends $tea.Model {
  fieldIdentifier?: string;
  fieldValue?: string;
  static names(): { [key: string]: string } {
    return {
      fieldIdentifier: 'fieldIdentifier',
      fieldValue: 'fieldValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldIdentifier: 'string',
      fieldValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponseBodyTestcaseAssignedTo extends $tea.Model {
  assignIdentifier?: string;
  name?: string;
  tbRoleId?: string;
  static names(): { [key: string]: string } {
    return {
      assignIdentifier: 'assignIdentifier',
      name: 'name',
      tbRoleId: 'tbRoleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignIdentifier: 'string',
      name: 'string',
      tbRoleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponseBodyTestcaseCreator extends $tea.Model {
  createIdentifier?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      createIdentifier: 'createIdentifier',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createIdentifier: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponseBodyTestcaseDetailInfoExpectedResult extends $tea.Model {
  expectContent?: string;
  expectContentType?: string;
  expectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      expectContent: 'expectContent',
      expectContentType: 'expectContentType',
      expectIdentifier: 'expectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expectContent: 'string',
      expectContentType: 'string',
      expectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponseBodyTestcaseDetailInfoPrecondition extends $tea.Model {
  preContent?: string;
  preContentType?: string;
  preIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      preContent: 'preContent',
      preContentType: 'preContentType',
      preIdentifier: 'preIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preContent: 'string',
      preContentType: 'string',
      preIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponseBodyTestcaseDetailInfoStepContent extends $tea.Model {
  stepContent?: string;
  stepContentType?: string;
  stepIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      stepContent: 'stepContent',
      stepContentType: 'stepContentType',
      stepIdentifier: 'stepIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      stepContent: 'string',
      stepContentType: 'string',
      stepIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponseBodyTestcaseDetailInfo extends $tea.Model {
  expectedResult?: UpdateTestCaseResponseBodyTestcaseDetailInfoExpectedResult;
  precondition?: UpdateTestCaseResponseBodyTestcaseDetailInfoPrecondition;
  stepContent?: UpdateTestCaseResponseBodyTestcaseDetailInfoStepContent;
  stepType?: string;
  static names(): { [key: string]: string } {
    return {
      expectedResult: 'expectedResult',
      precondition: 'precondition',
      stepContent: 'stepContent',
      stepType: 'stepType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expectedResult: UpdateTestCaseResponseBodyTestcaseDetailInfoExpectedResult,
      precondition: UpdateTestCaseResponseBodyTestcaseDetailInfoPrecondition,
      stepContent: UpdateTestCaseResponseBodyTestcaseDetailInfoStepContent,
      stepType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponseBodyTestcaseDirectory extends $tea.Model {
  childIdentifier?: string;
  directoryIdentifier?: string;
  name?: string;
  pathName?: string[];
  static names(): { [key: string]: string } {
    return {
      childIdentifier: 'childIdentifier',
      directoryIdentifier: 'directoryIdentifier',
      name: 'name',
      pathName: 'pathName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      childIdentifier: 'string',
      directoryIdentifier: 'string',
      name: 'string',
      pathName: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponseBodyTestcaseModifier extends $tea.Model {
  modifyIdentifier?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      modifyIdentifier: 'modifyIdentifier',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      modifyIdentifier: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponseBodyTestcase extends $tea.Model {
  assignedTo?: UpdateTestCaseResponseBodyTestcaseAssignedTo;
  categoryIdentifier?: string;
  creator?: UpdateTestCaseResponseBodyTestcaseCreator;
  detailInfo?: UpdateTestCaseResponseBodyTestcaseDetailInfo;
  directory?: UpdateTestCaseResponseBodyTestcaseDirectory;
  identifier?: string;
  modifier?: UpdateTestCaseResponseBodyTestcaseModifier;
  spaceIdentifier?: string;
  spaceType?: string;
  subject?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      detailInfo: 'detailInfo',
      directory: 'directory',
      identifier: 'identifier',
      modifier: 'modifier',
      spaceIdentifier: 'spaceIdentifier',
      spaceType: 'spaceType',
      subject: 'subject',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: UpdateTestCaseResponseBodyTestcaseAssignedTo,
      categoryIdentifier: 'string',
      creator: UpdateTestCaseResponseBodyTestcaseCreator,
      detailInfo: UpdateTestCaseResponseBodyTestcaseDetailInfo,
      directory: UpdateTestCaseResponseBodyTestcaseDirectory,
      identifier: 'string',
      modifier: UpdateTestCaseResponseBodyTestcaseModifier,
      spaceIdentifier: 'string',
      spaceType: 'string',
      subject: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkItemResponseBodyWorkitem extends $tea.Model {
  assignedTo?: string;
  categoryIdentifier?: string;
  creator?: string;
  document?: string;
  gmtCreate?: number;
  gmtModified?: number;
  identifier?: string;
  logicalStatus?: string;
  modifier?: string;
  parentIdentifier?: string;
  serialNumber?: string;
  spaceIdentifier?: string;
  spaceName?: string;
  spaceType?: string;
  sprintIdentifier?: string;
  status?: string;
  statusIdentifier?: string;
  statusStageIdentifier?: string;
  subject?: string;
  updateStatusAt?: number;
  workitemTypeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      document: 'document',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      logicalStatus: 'logicalStatus',
      modifier: 'modifier',
      parentIdentifier: 'parentIdentifier',
      serialNumber: 'serialNumber',
      spaceIdentifier: 'spaceIdentifier',
      spaceName: 'spaceName',
      spaceType: 'spaceType',
      sprintIdentifier: 'sprintIdentifier',
      status: 'status',
      statusIdentifier: 'statusIdentifier',
      statusStageIdentifier: 'statusStageIdentifier',
      subject: 'subject',
      updateStatusAt: 'updateStatusAt',
      workitemTypeIdentifier: 'workitemTypeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: 'string',
      categoryIdentifier: 'string',
      creator: 'string',
      document: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      logicalStatus: 'string',
      modifier: 'string',
      parentIdentifier: 'string',
      serialNumber: 'string',
      spaceIdentifier: 'string',
      spaceName: 'string',
      spaceType: 'string',
      sprintIdentifier: 'string',
      status: 'string',
      statusIdentifier: 'string',
      statusStageIdentifier: 'string',
      subject: 'string',
      updateStatusAt: 'number',
      workitemTypeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkitemCommentResponseBodyCommentUser extends $tea.Model {
  account?: string;
  avatar?: string;
  displayName?: string;
  identifier?: string;
  nickName?: string;
  realName?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'account',
      avatar: 'avatar',
      displayName: 'displayName',
      identifier: 'identifier',
      nickName: 'nickName',
      realName: 'realName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      avatar: 'string',
      displayName: 'string',
      identifier: 'string',
      nickName: 'string',
      realName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkitemCommentResponseBodyComment extends $tea.Model {
  content?: string;
  createTime?: number;
  formatType?: string;
  id?: string;
  isTop?: boolean;
  modifiedTime?: number;
  parentId?: number;
  targetIdentifier?: string;
  targetType?: string;
  topTime?: number;
  user?: UpdateWorkitemCommentResponseBodyCommentUser;
  static names(): { [key: string]: string } {
    return {
      content: 'content',
      createTime: 'createTime',
      formatType: 'formatType',
      id: 'id',
      isTop: 'isTop',
      modifiedTime: 'modifiedTime',
      parentId: 'parentId',
      targetIdentifier: 'targetIdentifier',
      targetType: 'targetType',
      topTime: 'topTime',
      user: 'user',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      createTime: 'number',
      formatType: 'string',
      id: 'string',
      isTop: 'boolean',
      modifiedTime: 'number',
      parentId: 'number',
      targetIdentifier: 'string',
      targetType: 'string',
      topTime: 'number',
      user: UpdateWorkitemCommentResponseBodyCommentUser,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkitemFieldRequestUpdateWorkitemPropertyRequest extends $tea.Model {
  fieldIdentifier?: string;
  fieldValue?: string;
  static names(): { [key: string]: string } {
    return {
      fieldIdentifier: 'fieldIdentifier',
      fieldValue: 'fieldValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldIdentifier: 'string',
      fieldValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkitemFieldResponseBodyWorkitem extends $tea.Model {
  assignedTo?: string;
  categoryIdentifier?: string;
  creator?: string;
  document?: string;
  gmtCreate?: number;
  gmtModified?: number;
  identifier?: string;
  logicalStatus?: string;
  modifier?: string;
  parentIdentifier?: string;
  serialNumber?: string;
  spaceIdentifier?: string;
  spaceName?: string;
  spaceType?: string;
  sprintIdentifier?: string;
  status?: string;
  statusIdentifier?: string;
  statusStageIdentifier?: string;
  subject?: string;
  updateStatusAt?: number;
  workitemTypeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      document: 'document',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      logicalStatus: 'logicalStatus',
      modifier: 'modifier',
      parentIdentifier: 'parentIdentifier',
      serialNumber: 'serialNumber',
      spaceIdentifier: 'spaceIdentifier',
      spaceName: 'spaceName',
      spaceType: 'spaceType',
      sprintIdentifier: 'sprintIdentifier',
      status: 'status',
      statusIdentifier: 'statusIdentifier',
      statusStageIdentifier: 'statusStageIdentifier',
      subject: 'subject',
      updateStatusAt: 'updateStatusAt',
      workitemTypeIdentifier: 'workitemTypeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: 'string',
      categoryIdentifier: 'string',
      creator: 'string',
      document: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      logicalStatus: 'string',
      modifier: 'string',
      parentIdentifier: 'string',
      serialNumber: 'string',
      spaceIdentifier: 'string',
      spaceName: 'string',
      spaceType: 'string',
      sprintIdentifier: 'string',
      status: 'string',
      statusIdentifier: 'string',
      statusStageIdentifier: 'string',
      subject: 'string',
      updateStatusAt: 'number',
      workitemTypeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "";
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("devops", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  async addGroupMemberWithOptions(groupId: string, request: AddGroupMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<AddGroupMemberResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessLevel)) {
      body["accessLevel"] = request.accessLevel;
    }

    if (!Util.isUnset(request.aliyunPks)) {
      body["aliyunPks"] = request.aliyunPks;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AddGroupMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/groups/${OpenApiUtil.getEncodeParam(groupId)}/members/create`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<AddGroupMemberResponse>(await this.callApi(params, req, runtime), new AddGroupMemberResponse({}));
  }

  async addGroupMember(groupId: string, request: AddGroupMemberRequest): Promise<AddGroupMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.addGroupMemberWithOptions(groupId, request, headers, runtime);
  }

  async addPipelineRelationsWithOptions(organizationId: string, pipelineId: string, request: AddPipelineRelationsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<AddPipelineRelationsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.relObjectIds)) {
      query["relObjectIds"] = request.relObjectIds;
    }

    if (!Util.isUnset(request.relObjectType)) {
      query["relObjectType"] = request.relObjectType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddPipelineRelations",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRelations`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<AddPipelineRelationsResponse>(await this.callApi(params, req, runtime), new AddPipelineRelationsResponse({}));
  }

  async addPipelineRelations(organizationId: string, pipelineId: string, request: AddPipelineRelationsRequest): Promise<AddPipelineRelationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.addPipelineRelationsWithOptions(organizationId, pipelineId, request, headers, runtime);
  }

  async addRepositoryMemberWithOptions(repositoryId: string, request: AddRepositoryMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<AddRepositoryMemberResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessLevel)) {
      body["accessLevel"] = request.accessLevel;
    }

    if (!Util.isUnset(request.aliyunPks)) {
      body["aliyunPks"] = request.aliyunPks;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AddRepositoryMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/members`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<AddRepositoryMemberResponse>(await this.callApi(params, req, runtime), new AddRepositoryMemberResponse({}));
  }

  async addRepositoryMember(repositoryId: string, request: AddRepositoryMemberRequest): Promise<AddRepositoryMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.addRepositoryMemberWithOptions(repositoryId, request, headers, runtime);
  }

  async addWebhookWithOptions(repositoryId: string, request: AddWebhookRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<AddWebhookResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.enableSslVerification)) {
      body["enableSslVerification"] = request.enableSslVerification;
    }

    if (!Util.isUnset(request.mergeRequestsEvents)) {
      body["mergeRequestsEvents"] = request.mergeRequestsEvents;
    }

    if (!Util.isUnset(request.noteEvents)) {
      body["noteEvents"] = request.noteEvents;
    }

    if (!Util.isUnset(request.pushEvents)) {
      body["pushEvents"] = request.pushEvents;
    }

    if (!Util.isUnset(request.secretToken)) {
      body["secretToken"] = request.secretToken;
    }

    if (!Util.isUnset(request.tagPushEvents)) {
      body["tagPushEvents"] = request.tagPushEvents;
    }

    if (!Util.isUnset(request.url)) {
      body["url"] = request.url;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AddWebhook",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/webhooks/create`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<AddWebhookResponse>(await this.callApi(params, req, runtime), new AddWebhookResponse({}));
  }

  async addWebhook(repositoryId: string, request: AddWebhookRequest): Promise<AddWebhookResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.addWebhookWithOptions(repositoryId, request, headers, runtime);
  }

  async closeMergeRequestWithOptions(repositoryId: string, localId: string, request: CloseMergeRequestRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CloseMergeRequestResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CloseMergeRequest",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/merge_requests/${OpenApiUtil.getEncodeParam(localId)}/close`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CloseMergeRequestResponse>(await this.callApi(params, req, runtime), new CloseMergeRequestResponse({}));
  }

  async closeMergeRequest(repositoryId: string, localId: string, request: CloseMergeRequestRequest): Promise<CloseMergeRequestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.closeMergeRequestWithOptions(repositoryId, localId, request, headers, runtime);
  }

  async createAppMembersWithOptions(appName: string, request: CreateAppMembersRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateAppMembersResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.playerList)) {
      body["playerList"] = request.playerList;
    }

    if (!Util.isUnset(request.roleNames)) {
      body["roleNames"] = request.roleNames;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateAppMembers",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}/members`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "string",
    });
    return $tea.cast<CreateAppMembersResponse>(await this.callApi(params, req, runtime), new CreateAppMembersResponse({}));
  }

  async createAppMembers(appName: string, request: CreateAppMembersRequest): Promise<CreateAppMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createAppMembersWithOptions(appName, request, headers, runtime);
  }

  async createBranchWithOptions(repositoryId: string, request: CreateBranchRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateBranchResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.branchName)) {
      body["branchName"] = request.branchName;
    }

    if (!Util.isUnset(request.ref)) {
      body["ref"] = request.ref;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateBranch",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/branches`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateBranchResponse>(await this.callApi(params, req, runtime), new CreateBranchResponse({}));
  }

  async createBranch(repositoryId: string, request: CreateBranchRequest): Promise<CreateBranchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createBranchWithOptions(repositoryId, request, headers, runtime);
  }

  async createCheckRunWithOptions(request: CreateCheckRunRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateCheckRunResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.annotations)) {
      body["annotations"] = request.annotations;
    }

    if (!Util.isUnset(request.completedAt)) {
      body["completedAt"] = request.completedAt;
    }

    if (!Util.isUnset(request.conclusion)) {
      body["conclusion"] = request.conclusion;
    }

    if (!Util.isUnset(request.detailsUrl)) {
      body["detailsUrl"] = request.detailsUrl;
    }

    if (!Util.isUnset(request.externalId)) {
      body["externalId"] = request.externalId;
    }

    if (!Util.isUnset(request.headSha)) {
      body["headSha"] = request.headSha;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.output)) {
      body["output"] = request.output;
    }

    if (!Util.isUnset(request.startedAt)) {
      body["startedAt"] = request.startedAt;
    }

    if (!Util.isUnset(request.status)) {
      body["status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateCheckRun",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/check_runs/create_check_run`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateCheckRunResponse>(await this.callApi(params, req, runtime), new CreateCheckRunResponse({}));
  }

  async createCheckRun(request: CreateCheckRunRequest): Promise<CreateCheckRunResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createCheckRunWithOptions(request, headers, runtime);
  }

  async createCommentWithOptions(request: CreateCommentRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateCommentResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.localId)) {
      query["localId"] = request.localId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.commentType)) {
      body["commentType"] = request.commentType;
    }

    if (!Util.isUnset(request.content)) {
      body["content"] = request.content;
    }

    if (!Util.isUnset(request.draft)) {
      body["draft"] = request.draft;
    }

    if (!Util.isUnset(request.filePath)) {
      body["filePath"] = request.filePath;
    }

    if (!Util.isUnset(request.lineNumber)) {
      body["lineNumber"] = request.lineNumber;
    }

    if (!Util.isUnset(request.parentCommentBizId)) {
      body["parentCommentBizId"] = request.parentCommentBizId;
    }

    if (!Util.isUnset(request.patchSetBizId)) {
      body["patchSetBizId"] = request.patchSetBizId;
    }

    if (!Util.isUnset(request.resolved)) {
      body["resolved"] = request.resolved;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateComment",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/code_reviews/comments/create_comment`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateCommentResponse>(await this.callApi(params, req, runtime), new CreateCommentResponse({}));
  }

  async createComment(request: CreateCommentRequest): Promise<CreateCommentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createCommentWithOptions(request, headers, runtime);
  }

  async createCommitStatusWithOptions(request: CreateCommitStatusRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateCommitStatusResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    if (!Util.isUnset(request.sha)) {
      query["sha"] = request.sha;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.context)) {
      body["context"] = request.context;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.state)) {
      body["state"] = request.state;
    }

    if (!Util.isUnset(request.targetUrl)) {
      body["targetUrl"] = request.targetUrl;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateCommitStatus",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/repository/commit_statuses/create_commit_status`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateCommitStatusResponse>(await this.callApi(params, req, runtime), new CreateCommitStatusResponse({}));
  }

  async createCommitStatus(request: CreateCommitStatusRequest): Promise<CreateCommitStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createCommitStatusWithOptions(request, headers, runtime);
  }

  async createCommitWithMultipleFilesWithOptions(request: CreateCommitWithMultipleFilesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateCommitWithMultipleFilesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.actions)) {
      body["actions"] = request.actions;
    }

    if (!Util.isUnset(request.branch)) {
      body["branch"] = request.branch;
    }

    if (!Util.isUnset(request.commitMessage)) {
      body["commitMessage"] = request.commitMessage;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateCommitWithMultipleFiles",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/repository/commits/files`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateCommitWithMultipleFilesResponse>(await this.callApi(params, req, runtime), new CreateCommitWithMultipleFilesResponse({}));
  }

  async createCommitWithMultipleFiles(request: CreateCommitWithMultipleFilesRequest): Promise<CreateCommitWithMultipleFilesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createCommitWithMultipleFilesWithOptions(request, headers, runtime);
  }

  async createDeployKeyWithOptions(repositoryId: string, request: CreateDeployKeyRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateDeployKeyResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.key)) {
      body["key"] = request.key;
    }

    if (!Util.isUnset(request.title)) {
      body["title"] = request.title;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateDeployKey",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/keys/create`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateDeployKeyResponse>(await this.callApi(params, req, runtime), new CreateDeployKeyResponse({}));
  }

  async createDeployKey(repositoryId: string, request: CreateDeployKeyRequest): Promise<CreateDeployKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createDeployKeyWithOptions(repositoryId, request, headers, runtime);
  }

  async createFileWithOptions(repositoryId: string, request: CreateFileRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateFileResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.branchName)) {
      body["branchName"] = request.branchName;
    }

    if (!Util.isUnset(request.commitMessage)) {
      body["commitMessage"] = request.commitMessage;
    }

    if (!Util.isUnset(request.content)) {
      body["content"] = request.content;
    }

    if (!Util.isUnset(request.encoding)) {
      body["encoding"] = request.encoding;
    }

    if (!Util.isUnset(request.filePath)) {
      body["filePath"] = request.filePath;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateFile",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/files`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateFileResponse>(await this.callApi(params, req, runtime), new CreateFileResponse({}));
  }

  async createFile(repositoryId: string, request: CreateFileRequest): Promise<CreateFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createFileWithOptions(repositoryId, request, headers, runtime);
  }

  async createFlowTagWithOptions(organizationId: string, request: CreateFlowTagRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateFlowTagResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.color)) {
      query["color"] = request.color;
    }

    if (!Util.isUnset(request.flowTagGroupId)) {
      query["flowTagGroupId"] = request.flowTagGroupId;
    }

    if (!Util.isUnset(request.name)) {
      query["name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateFlowTag",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/flow/tags`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateFlowTagResponse>(await this.callApi(params, req, runtime), new CreateFlowTagResponse({}));
  }

  async createFlowTag(organizationId: string, request: CreateFlowTagRequest): Promise<CreateFlowTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createFlowTagWithOptions(organizationId, request, headers, runtime);
  }

  async createFlowTagGroupWithOptions(organizationId: string, request: CreateFlowTagGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateFlowTagGroupResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      query["name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateFlowTagGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/flow/tagGroups`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateFlowTagGroupResponse>(await this.callApi(params, req, runtime), new CreateFlowTagGroupResponse({}));
  }

  async createFlowTagGroup(organizationId: string, request: CreateFlowTagGroupRequest): Promise<CreateFlowTagGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createFlowTagGroupWithOptions(organizationId, request, headers, runtime);
  }

  async createHostGroupWithOptions(organizationId: string, request: CreateHostGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateHostGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.aliyunRegion)) {
      body["aliyunRegion"] = request.aliyunRegion;
    }

    if (!Util.isUnset(request.ecsLabelKey)) {
      body["ecsLabelKey"] = request.ecsLabelKey;
    }

    if (!Util.isUnset(request.ecsLabelValue)) {
      body["ecsLabelValue"] = request.ecsLabelValue;
    }

    if (!Util.isUnset(request.ecsType)) {
      body["ecsType"] = request.ecsType;
    }

    if (!Util.isUnset(request.envId)) {
      body["envId"] = request.envId;
    }

    if (!Util.isUnset(request.machineInfos)) {
      body["machineInfos"] = request.machineInfos;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.serviceConnectionId)) {
      body["serviceConnectionId"] = request.serviceConnectionId;
    }

    if (!Util.isUnset(request.tagIds)) {
      body["tagIds"] = request.tagIds;
    }

    if (!Util.isUnset(request.type)) {
      body["type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateHostGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/hostGroups`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateHostGroupResponse>(await this.callApi(params, req, runtime), new CreateHostGroupResponse({}));
  }

  async createHostGroup(organizationId: string, request: CreateHostGroupRequest): Promise<CreateHostGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createHostGroupWithOptions(organizationId, request, headers, runtime);
  }

  async createMergeRequestWithOptions(repositoryId: string, request: CreateMergeRequestRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateMergeRequestResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.createFrom)) {
      body["createFrom"] = request.createFrom;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.reviewerIds)) {
      body["reviewerIds"] = request.reviewerIds;
    }

    if (!Util.isUnset(request.sourceBranch)) {
      body["sourceBranch"] = request.sourceBranch;
    }

    if (!Util.isUnset(request.sourceProjectId)) {
      body["sourceProjectId"] = request.sourceProjectId;
    }

    if (!Util.isUnset(request.targetBranch)) {
      body["targetBranch"] = request.targetBranch;
    }

    if (!Util.isUnset(request.targetProjectId)) {
      body["targetProjectId"] = request.targetProjectId;
    }

    if (!Util.isUnset(request.title)) {
      body["title"] = request.title;
    }

    if (!Util.isUnset(request.workItemIds)) {
      body["workItemIds"] = request.workItemIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateMergeRequest",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/merge_requests`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateMergeRequestResponse>(await this.callApi(params, req, runtime), new CreateMergeRequestResponse({}));
  }

  async createMergeRequest(repositoryId: string, request: CreateMergeRequestRequest): Promise<CreateMergeRequestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createMergeRequestWithOptions(repositoryId, request, headers, runtime);
  }

  async createOAuthTokenWithOptions(request: CreateOAuthTokenRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateOAuthTokenResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.clientId)) {
      body["clientId"] = request.clientId;
    }

    if (!Util.isUnset(request.clientSecret)) {
      body["clientSecret"] = request.clientSecret;
    }

    if (!Util.isUnset(request.code)) {
      body["code"] = request.code;
    }

    if (!Util.isUnset(request.grantType)) {
      body["grantType"] = request.grantType;
    }

    if (!Util.isUnset(request.login)) {
      body["login"] = request.login;
    }

    if (!Util.isUnset(request.scope)) {
      body["scope"] = request.scope;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateOAuthToken",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/login/oauth/create`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateOAuthTokenResponse>(await this.callApi(params, req, runtime), new CreateOAuthTokenResponse({}));
  }

  async createOAuthToken(request: CreateOAuthTokenRequest): Promise<CreateOAuthTokenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createOAuthTokenWithOptions(request, headers, runtime);
  }

  async createPipelineWithOptions(organizationId: string, request: CreatePipelineRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreatePipelineResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.content)) {
      body["content"] = request.content;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreatePipeline",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreatePipelineResponse>(await this.callApi(params, req, runtime), new CreatePipelineResponse({}));
  }

  async createPipeline(organizationId: string, request: CreatePipelineRequest): Promise<CreatePipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createPipelineWithOptions(organizationId, request, headers, runtime);
  }

  async createPipelineGroupWithOptions(organizationId: string, request: CreatePipelineGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreatePipelineGroupResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      query["name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreatePipelineGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelineGroups`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreatePipelineGroupResponse>(await this.callApi(params, req, runtime), new CreatePipelineGroupResponse({}));
  }

  async createPipelineGroup(organizationId: string, request: CreatePipelineGroupRequest): Promise<CreatePipelineGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createPipelineGroupWithOptions(organizationId, request, headers, runtime);
  }

  async createProjectWithOptions(organizationId: string, request: CreateProjectRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateProjectResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.customCode)) {
      body["customCode"] = request.customCode;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.scope)) {
      body["scope"] = request.scope;
    }

    if (!Util.isUnset(request.templateIdentifier)) {
      body["templateIdentifier"] = request.templateIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateProject",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/projects/createProject`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateProjectResponse>(await this.callApi(params, req, runtime), new CreateProjectResponse({}));
  }

  async createProject(organizationId: string, request: CreateProjectRequest): Promise<CreateProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createProjectWithOptions(organizationId, request, headers, runtime);
  }

  async createProjectLabelWithOptions(request: CreateProjectLabelRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateProjectLabelResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.color)) {
      body["color"] = request.color;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateProjectLabel",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/labels`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateProjectLabelResponse>(await this.callApi(params, req, runtime), new CreateProjectLabelResponse({}));
  }

  async createProjectLabel(request: CreateProjectLabelRequest): Promise<CreateProjectLabelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createProjectLabelWithOptions(request, headers, runtime);
  }

  async createProtectdBranchWithOptions(repositoryId: string, request: CreateProtectdBranchRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateProtectdBranchResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.allowMergeRoles)) {
      body["allowMergeRoles"] = request.allowMergeRoles;
    }

    if (!Util.isUnset(request.allowMergeUserIds)) {
      body["allowMergeUserIds"] = request.allowMergeUserIds;
    }

    if (!Util.isUnset(request.allowPushRoles)) {
      body["allowPushRoles"] = request.allowPushRoles;
    }

    if (!Util.isUnset(request.allowPushUserIds)) {
      body["allowPushUserIds"] = request.allowPushUserIds;
    }

    if (!Util.isUnset(request.branch)) {
      body["branch"] = request.branch;
    }

    if (!Util.isUnset(request.id)) {
      body["id"] = request.id;
    }

    if (!Util.isUnset(request.mergeRequestSetting)) {
      body["mergeRequestSetting"] = request.mergeRequestSetting;
    }

    if (!Util.isUnset(request.testSettingDTO)) {
      body["testSettingDTO"] = request.testSettingDTO;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateProtectdBranch",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/protect_branches`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateProtectdBranchResponse>(await this.callApi(params, req, runtime), new CreateProtectdBranchResponse({}));
  }

  async createProtectdBranch(repositoryId: string, request: CreateProtectdBranchRequest): Promise<CreateProtectdBranchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createProtectdBranchWithOptions(repositoryId, request, headers, runtime);
  }

  async createPushRuleWithOptions(repositoryId: string, request: CreatePushRuleRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreatePushRuleResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.ruleInfos)) {
      body["ruleInfos"] = request.ruleInfos;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreatePushRule",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/push_rule`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreatePushRuleResponse>(await this.callApi(params, req, runtime), new CreatePushRuleResponse({}));
  }

  async createPushRule(repositoryId: string, request: CreatePushRuleRequest): Promise<CreatePushRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createPushRuleWithOptions(repositoryId, request, headers, runtime);
  }

  async createRepositoryWithOptions(request: CreateRepositoryRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateRepositoryResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.createParentPath)) {
      query["createParentPath"] = request.createParentPath;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.sync)) {
      query["sync"] = request.sync;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.avatarUrl)) {
      body["avatarUrl"] = request.avatarUrl;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.gitignoreType)) {
      body["gitignoreType"] = request.gitignoreType;
    }

    if (!Util.isUnset(request.importAccount)) {
      body["importAccount"] = request.importAccount;
    }

    if (!Util.isUnset(request.importDemoProject)) {
      body["importDemoProject"] = request.importDemoProject;
    }

    if (!Util.isUnset(request.importRepoType)) {
      body["importRepoType"] = request.importRepoType;
    }

    if (!Util.isUnset(request.importToken)) {
      body["importToken"] = request.importToken;
    }

    if (!Util.isUnset(request.importTokenEncrypted)) {
      body["importTokenEncrypted"] = request.importTokenEncrypted;
    }

    if (!Util.isUnset(request.importUrl)) {
      body["importUrl"] = request.importUrl;
    }

    if (!Util.isUnset(request.initStandardService)) {
      body["initStandardService"] = request.initStandardService;
    }

    if (!Util.isUnset(request.isCryptoEnabled)) {
      body["isCryptoEnabled"] = request.isCryptoEnabled;
    }

    if (!Util.isUnset(request.localImportUrl)) {
      body["localImportUrl"] = request.localImportUrl;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.namespaceId)) {
      body["namespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.path)) {
      body["path"] = request.path;
    }

    if (!Util.isUnset(request.readmeType)) {
      body["readmeType"] = request.readmeType;
    }

    if (!Util.isUnset(request.visibilityLevel)) {
      body["visibilityLevel"] = request.visibilityLevel;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateRepository",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/create`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateRepositoryResponse>(await this.callApi(params, req, runtime), new CreateRepositoryResponse({}));
  }

  async createRepository(request: CreateRepositoryRequest): Promise<CreateRepositoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createRepositoryWithOptions(request, headers, runtime);
  }

  async createRepositoryGroupWithOptions(request: CreateRepositoryGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateRepositoryGroupResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.avatarUrl)) {
      body["avatarUrl"] = request.avatarUrl;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.parentId)) {
      body["parentId"] = request.parentId;
    }

    if (!Util.isUnset(request.path)) {
      body["path"] = request.path;
    }

    if (!Util.isUnset(request.visibilityLevel)) {
      body["visibilityLevel"] = request.visibilityLevel;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateRepositoryGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/groups/create`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateRepositoryGroupResponse>(await this.callApi(params, req, runtime), new CreateRepositoryGroupResponse({}));
  }

  async createRepositoryGroup(request: CreateRepositoryGroupRequest): Promise<CreateRepositoryGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createRepositoryGroupWithOptions(request, headers, runtime);
  }

  async createResourceMemberWithOptions(organizationId: string, resourceType: string, resourceId: string, request: CreateResourceMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateResourceMemberResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accountId)) {
      body["accountId"] = request.accountId;
    }

    if (!Util.isUnset(request.roleName)) {
      body["roleName"] = request.roleName;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateResourceMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/${OpenApiUtil.getEncodeParam(resourceType)}/${OpenApiUtil.getEncodeParam(resourceId)}/members`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateResourceMemberResponse>(await this.callApi(params, req, runtime), new CreateResourceMemberResponse({}));
  }

  async createResourceMember(organizationId: string, resourceType: string, resourceId: string, request: CreateResourceMemberRequest): Promise<CreateResourceMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createResourceMemberWithOptions(organizationId, resourceType, resourceId, request, headers, runtime);
  }

  async createServiceAuthWithOptions(organizationId: string, request: CreateServiceAuthRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateServiceAuthResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.serviceAuthType)) {
      query["serviceAuthType"] = request.serviceAuthType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateServiceAuth",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/serviceAuths`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateServiceAuthResponse>(await this.callApi(params, req, runtime), new CreateServiceAuthResponse({}));
  }

  async createServiceAuth(organizationId: string, request: CreateServiceAuthRequest): Promise<CreateServiceAuthResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createServiceAuthWithOptions(organizationId, request, headers, runtime);
  }

  async createServiceConnectionWithOptions(organizationId: string, request: CreateServiceConnectionRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateServiceConnectionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.authType)) {
      body["authType"] = request.authType;
    }

    if (!Util.isUnset(request.connectionName)) {
      body["connectionName"] = request.connectionName;
    }

    if (!Util.isUnset(request.connectionType)) {
      body["connectionType"] = request.connectionType;
    }

    if (!Util.isUnset(request.scope)) {
      body["scope"] = request.scope;
    }

    if (!Util.isUnset(request.serviceAuthId)) {
      body["serviceAuthId"] = request.serviceAuthId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateServiceConnection",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/createServiceConnection`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateServiceConnectionResponse>(await this.callApi(params, req, runtime), new CreateServiceConnectionResponse({}));
  }

  async createServiceConnection(organizationId: string, request: CreateServiceConnectionRequest): Promise<CreateServiceConnectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createServiceConnectionWithOptions(organizationId, request, headers, runtime);
  }

  async createServiceCredentialWithOptions(organizationId: string, request: CreateServiceCredentialRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateServiceCredentialResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.password)) {
      body["password"] = request.password;
    }

    if (!Util.isUnset(request.scope)) {
      body["scope"] = request.scope;
    }

    if (!Util.isUnset(request.type)) {
      body["type"] = request.type;
    }

    if (!Util.isUnset(request.username)) {
      body["username"] = request.username;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateServiceCredential",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/serviceCredentials`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateServiceCredentialResponse>(await this.callApi(params, req, runtime), new CreateServiceCredentialResponse({}));
  }

  async createServiceCredential(organizationId: string, request: CreateServiceCredentialRequest): Promise<CreateServiceCredentialResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createServiceCredentialWithOptions(organizationId, request, headers, runtime);
  }

  async createSprintWithOptions(organizationId: string, request: CreateSprintRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateSprintResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endDate)) {
      body["endDate"] = request.endDate;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.spaceIdentifier)) {
      body["spaceIdentifier"] = request.spaceIdentifier;
    }

    if (!Util.isUnset(request.staffIds)) {
      body["staffIds"] = request.staffIds;
    }

    if (!Util.isUnset(request.startDate)) {
      body["startDate"] = request.startDate;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateSprint",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/sprints/create`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateSprintResponse>(await this.callApi(params, req, runtime), new CreateSprintResponse({}));
  }

  async createSprint(organizationId: string, request: CreateSprintRequest): Promise<CreateSprintResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createSprintWithOptions(organizationId, request, headers, runtime);
  }

  async createSshKeyWithOptions(organizationId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateSshKeyResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "CreateSshKey",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/sshKey`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateSshKeyResponse>(await this.callApi(params, req, runtime), new CreateSshKeyResponse({}));
  }

  async createSshKey(organizationId: string): Promise<CreateSshKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createSshKeyWithOptions(organizationId, headers, runtime);
  }

  async createTagWithOptions(repositoryId: string, request: CreateTagRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateTagResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.message)) {
      body["message"] = request.message;
    }

    if (!Util.isUnset(request.ref)) {
      body["ref"] = request.ref;
    }

    if (!Util.isUnset(request.tagName)) {
      body["tagName"] = request.tagName;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateTag",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/tags/create`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateTagResponse>(await this.callApi(params, req, runtime), new CreateTagResponse({}));
  }

  async createTag(repositoryId: string, request: CreateTagRequest): Promise<CreateTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createTagWithOptions(repositoryId, request, headers, runtime);
  }

  async createTestCaseWithOptions(organizationId: string, request: CreateTestCaseRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateTestCaseResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.assignedTo)) {
      body["assignedTo"] = request.assignedTo;
    }

    if (!Util.isUnset(request.directoryIdentifier)) {
      body["directoryIdentifier"] = request.directoryIdentifier;
    }

    if (!Util.isUnset(request.fieldValueList)) {
      body["fieldValueList"] = request.fieldValueList;
    }

    if (!Util.isUnset(request.priority)) {
      body["priority"] = request.priority;
    }

    if (!Util.isUnset(request.spaceIdentifier)) {
      body["spaceIdentifier"] = request.spaceIdentifier;
    }

    if (!Util.isUnset(request.subject)) {
      body["subject"] = request.subject;
    }

    if (!Util.isUnset(request.tags)) {
      body["tags"] = request.tags;
    }

    if (!Util.isUnset(request.testcaseStepContentInfo)) {
      body["testcaseStepContentInfo"] = request.testcaseStepContentInfo;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateTestCase",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/testhub/testcase`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateTestCaseResponse>(await this.callApi(params, req, runtime), new CreateTestCaseResponse({}));
  }

  async createTestCase(organizationId: string, request: CreateTestCaseRequest): Promise<CreateTestCaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createTestCaseWithOptions(organizationId, request, headers, runtime);
  }

  async createUserKeyWithOptions(request: CreateUserKeyRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateUserKeyResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.expireTime)) {
      body["expireTime"] = request.expireTime;
    }

    if (!Util.isUnset(request.keyScope)) {
      body["keyScope"] = request.keyScope;
    }

    if (!Util.isUnset(request.publicKey)) {
      body["publicKey"] = request.publicKey;
    }

    if (!Util.isUnset(request.title)) {
      body["title"] = request.title;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateUserKey",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v3/user/keys/create`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateUserKeyResponse>(await this.callApi(params, req, runtime), new CreateUserKeyResponse({}));
  }

  async createUserKey(request: CreateUserKeyRequest): Promise<CreateUserKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createUserKeyWithOptions(request, headers, runtime);
  }

  async createVariableGroupWithOptions(organizationId: string, request: CreateVariableGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateVariableGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.variables)) {
      body["variables"] = request.variables;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateVariableGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/variableGroups`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateVariableGroupResponse>(await this.callApi(params, req, runtime), new CreateVariableGroupResponse({}));
  }

  async createVariableGroup(organizationId: string, request: CreateVariableGroupRequest): Promise<CreateVariableGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createVariableGroupWithOptions(organizationId, request, headers, runtime);
  }

  async createWorkitemWithOptions(organizationId: string, request: CreateWorkitemRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateWorkitemResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.assignedTo)) {
      body["assignedTo"] = request.assignedTo;
    }

    if (!Util.isUnset(request.category)) {
      body["category"] = request.category;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.descriptionFormat)) {
      body["descriptionFormat"] = request.descriptionFormat;
    }

    if (!Util.isUnset(request.fieldValueList)) {
      body["fieldValueList"] = request.fieldValueList;
    }

    if (!Util.isUnset(request.parent)) {
      body["parent"] = request.parent;
    }

    if (!Util.isUnset(request.participant)) {
      body["participant"] = request.participant;
    }

    if (!Util.isUnset(request.space)) {
      body["space"] = request.space;
    }

    if (!Util.isUnset(request.spaceIdentifier)) {
      body["spaceIdentifier"] = request.spaceIdentifier;
    }

    if (!Util.isUnset(request.spaceType)) {
      body["spaceType"] = request.spaceType;
    }

    if (!Util.isUnset(request.sprint)) {
      body["sprint"] = request.sprint;
    }

    if (!Util.isUnset(request.subject)) {
      body["subject"] = request.subject;
    }

    if (!Util.isUnset(request.tracker)) {
      body["tracker"] = request.tracker;
    }

    if (!Util.isUnset(request.verifier)) {
      body["verifier"] = request.verifier;
    }

    if (!Util.isUnset(request.workitemType)) {
      body["workitemType"] = request.workitemType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateWorkitem",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/create`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateWorkitemResponse>(await this.callApi(params, req, runtime), new CreateWorkitemResponse({}));
  }

  async createWorkitem(organizationId: string, request: CreateWorkitemRequest): Promise<CreateWorkitemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createWorkitemWithOptions(organizationId, request, headers, runtime);
  }

  async createWorkitemCommentWithOptions(organizationId: string, request: CreateWorkitemCommentRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateWorkitemCommentResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.content)) {
      body["content"] = request.content;
    }

    if (!Util.isUnset(request.formatType)) {
      body["formatType"] = request.formatType;
    }

    if (!Util.isUnset(request.parentId)) {
      body["parentId"] = request.parentId;
    }

    if (!Util.isUnset(request.workitemIdentifier)) {
      body["workitemIdentifier"] = request.workitemIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateWorkitemComment",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/comment`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateWorkitemCommentResponse>(await this.callApi(params, req, runtime), new CreateWorkitemCommentResponse({}));
  }

  async createWorkitemComment(organizationId: string, request: CreateWorkitemCommentRequest): Promise<CreateWorkitemCommentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createWorkitemCommentWithOptions(organizationId, request, headers, runtime);
  }

  async createWorkitemEstimateWithOptions(organizationId: string, request: CreateWorkitemEstimateRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateWorkitemEstimateResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.recordUserIdentifier)) {
      body["recordUserIdentifier"] = request.recordUserIdentifier;
    }

    if (!Util.isUnset(request.spentTime)) {
      body["spentTime"] = request.spentTime;
    }

    if (!Util.isUnset(request.type)) {
      body["type"] = request.type;
    }

    if (!Util.isUnset(request.workitemIdentifier)) {
      body["workitemIdentifier"] = request.workitemIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateWorkitemEstimate",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/estimate`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateWorkitemEstimateResponse>(await this.callApi(params, req, runtime), new CreateWorkitemEstimateResponse({}));
  }

  async createWorkitemEstimate(organizationId: string, request: CreateWorkitemEstimateRequest): Promise<CreateWorkitemEstimateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createWorkitemEstimateWithOptions(organizationId, request, headers, runtime);
  }

  async createWorkitemRecordWithOptions(organizationId: string, request: CreateWorkitemRecordRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateWorkitemRecordResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.actualTime)) {
      body["actualTime"] = request.actualTime;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.gmtEnd)) {
      body["gmtEnd"] = request.gmtEnd;
    }

    if (!Util.isUnset(request.gmtStart)) {
      body["gmtStart"] = request.gmtStart;
    }

    if (!Util.isUnset(request.recordUserIdentifier)) {
      body["recordUserIdentifier"] = request.recordUserIdentifier;
    }

    if (!Util.isUnset(request.type)) {
      body["type"] = request.type;
    }

    if (!Util.isUnset(request.workitemIdentifier)) {
      body["workitemIdentifier"] = request.workitemIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateWorkitemRecord",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/record`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateWorkitemRecordResponse>(await this.callApi(params, req, runtime), new CreateWorkitemRecordResponse({}));
  }

  async createWorkitemRecord(organizationId: string, request: CreateWorkitemRecordRequest): Promise<CreateWorkitemRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createWorkitemRecordWithOptions(organizationId, request, headers, runtime);
  }

  async createWorkitemV2WithOptions(organizationId: string, request: CreateWorkitemV2Request, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateWorkitemV2Response> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.assignedTo)) {
      body["assignedTo"] = request.assignedTo;
    }

    if (!Util.isUnset(request.category)) {
      body["category"] = request.category;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.fieldValueList)) {
      body["fieldValueList"] = request.fieldValueList;
    }

    if (!Util.isUnset(request.parentIdentifier)) {
      body["parentIdentifier"] = request.parentIdentifier;
    }

    if (!Util.isUnset(request.participants)) {
      body["participants"] = request.participants;
    }

    if (!Util.isUnset(request.spaceIdentifier)) {
      body["spaceIdentifier"] = request.spaceIdentifier;
    }

    if (!Util.isUnset(request.sprintIdentifier)) {
      body["sprintIdentifier"] = request.sprintIdentifier;
    }

    if (!Util.isUnset(request.subject)) {
      body["subject"] = request.subject;
    }

    if (!Util.isUnset(request.tags)) {
      body["tags"] = request.tags;
    }

    if (!Util.isUnset(request.trackers)) {
      body["trackers"] = request.trackers;
    }

    if (!Util.isUnset(request.verifier)) {
      body["verifier"] = request.verifier;
    }

    if (!Util.isUnset(request.versions)) {
      body["versions"] = request.versions;
    }

    if (!Util.isUnset(request.workitemTypeIdentifier)) {
      body["workitemTypeIdentifier"] = request.workitemTypeIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateWorkitemV2",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitem`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateWorkitemV2Response>(await this.callApi(params, req, runtime), new CreateWorkitemV2Response({}));
  }

  async createWorkitemV2(organizationId: string, request: CreateWorkitemV2Request): Promise<CreateWorkitemV2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createWorkitemV2WithOptions(organizationId, request, headers, runtime);
  }

  async createWorkspaceWithOptions(request: CreateWorkspaceRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateWorkspaceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.codeUrl)) {
      body["codeUrl"] = request.codeUrl;
    }

    if (!Util.isUnset(request.codeVersion)) {
      body["codeVersion"] = request.codeVersion;
    }

    if (!Util.isUnset(request.filePath)) {
      body["filePath"] = request.filePath;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.requestFrom)) {
      body["requestFrom"] = request.requestFrom;
    }

    if (!Util.isUnset(request.resourceIdentifier)) {
      body["resourceIdentifier"] = request.resourceIdentifier;
    }

    if (!Util.isUnset(request.reuse)) {
      body["reuse"] = request.reuse;
    }

    if (!Util.isUnset(request.workspaceTemplate)) {
      body["workspaceTemplate"] = request.workspaceTemplate;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateWorkspace",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/workspaces`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateWorkspaceResponse>(await this.callApi(params, req, runtime), new CreateWorkspaceResponse({}));
  }

  async createWorkspace(request: CreateWorkspaceRequest): Promise<CreateWorkspaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createWorkspaceWithOptions(request, headers, runtime);
  }

  async deleteAppMemberWithOptions(appName: string, request: DeleteAppMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteAppMemberResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.subjectId)) {
      query["subjectId"] = request.subjectId;
    }

    if (!Util.isUnset(request.subjectType)) {
      query["subjectType"] = request.subjectType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAppMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}/members`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "string",
    });
    return $tea.cast<DeleteAppMemberResponse>(await this.callApi(params, req, runtime), new DeleteAppMemberResponse({}));
  }

  async deleteAppMember(appName: string, request: DeleteAppMemberRequest): Promise<DeleteAppMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteAppMemberWithOptions(appName, request, headers, runtime);
  }

  async deleteBranchWithOptions(repositoryId: string, request: DeleteBranchRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteBranchResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.branchName)) {
      query["branchName"] = request.branchName;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteBranch",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/branches/delete`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteBranchResponse>(await this.callApi(params, req, runtime), new DeleteBranchResponse({}));
  }

  async deleteBranch(repositoryId: string, request: DeleteBranchRequest): Promise<DeleteBranchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteBranchWithOptions(repositoryId, request, headers, runtime);
  }

  async deleteFileWithOptions(repositoryId: string, request: DeleteFileRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteFileResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.branchName)) {
      query["branchName"] = request.branchName;
    }

    if (!Util.isUnset(request.commitMessage)) {
      query["commitMessage"] = request.commitMessage;
    }

    if (!Util.isUnset(request.filePath)) {
      query["filePath"] = request.filePath;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteFile",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/files/delete`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteFileResponse>(await this.callApi(params, req, runtime), new DeleteFileResponse({}));
  }

  async deleteFile(repositoryId: string, request: DeleteFileRequest): Promise<DeleteFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteFileWithOptions(repositoryId, request, headers, runtime);
  }

  async deleteFlowTagWithOptions(organizationId: string, id: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteFlowTagResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "DeleteFlowTag",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/flow/tags/${OpenApiUtil.getEncodeParam(id)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteFlowTagResponse>(await this.callApi(params, req, runtime), new DeleteFlowTagResponse({}));
  }

  async deleteFlowTag(organizationId: string, id: string): Promise<DeleteFlowTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteFlowTagWithOptions(organizationId, id, headers, runtime);
  }

  async deleteFlowTagGroupWithOptions(organizationId: string, id: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteFlowTagGroupResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "DeleteFlowTagGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/flow/tagGroups/${OpenApiUtil.getEncodeParam(id)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteFlowTagGroupResponse>(await this.callApi(params, req, runtime), new DeleteFlowTagGroupResponse({}));
  }

  async deleteFlowTagGroup(organizationId: string, id: string): Promise<DeleteFlowTagGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteFlowTagGroupWithOptions(organizationId, id, headers, runtime);
  }

  async deleteGroupMemberWithOptions(groupId: string, request: DeleteGroupMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteGroupMemberResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.aliyunPk)) {
      query["aliyunPk"] = request.aliyunPk;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.memberType)) {
      body["memberType"] = request.memberType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteGroupMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/groups/${OpenApiUtil.getEncodeParam(groupId)}/members/remove/aliyun_pk`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteGroupMemberResponse>(await this.callApi(params, req, runtime), new DeleteGroupMemberResponse({}));
  }

  async deleteGroupMember(groupId: string, request: DeleteGroupMemberRequest): Promise<DeleteGroupMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteGroupMemberWithOptions(groupId, request, headers, runtime);
  }

  async deleteHostGroupWithOptions(organizationId: string, id: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteHostGroupResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "DeleteHostGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/hostGroups/${OpenApiUtil.getEncodeParam(id)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteHostGroupResponse>(await this.callApi(params, req, runtime), new DeleteHostGroupResponse({}));
  }

  async deleteHostGroup(organizationId: string, id: string): Promise<DeleteHostGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteHostGroupWithOptions(organizationId, id, headers, runtime);
  }

  async deletePipelineWithOptions(organizationId: string, pipelineId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeletePipelineResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "DeletePipeline",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeletePipelineResponse>(await this.callApi(params, req, runtime), new DeletePipelineResponse({}));
  }

  async deletePipeline(organizationId: string, pipelineId: string): Promise<DeletePipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deletePipelineWithOptions(organizationId, pipelineId, headers, runtime);
  }

  async deletePipelineGroupWithOptions(organizationId: string, groupId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeletePipelineGroupResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "DeletePipelineGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelineGroups/${OpenApiUtil.getEncodeParam(groupId)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeletePipelineGroupResponse>(await this.callApi(params, req, runtime), new DeletePipelineGroupResponse({}));
  }

  async deletePipelineGroup(organizationId: string, groupId: string): Promise<DeletePipelineGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deletePipelineGroupWithOptions(organizationId, groupId, headers, runtime);
  }

  async deletePipelineRelationsWithOptions(organizationId: string, pipelineId: string, request: DeletePipelineRelationsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeletePipelineRelationsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.relObjectId)) {
      query["relObjectId"] = request.relObjectId;
    }

    if (!Util.isUnset(request.relObjectType)) {
      query["relObjectType"] = request.relObjectType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeletePipelineRelations",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRelations`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeletePipelineRelationsResponse>(await this.callApi(params, req, runtime), new DeletePipelineRelationsResponse({}));
  }

  async deletePipelineRelations(organizationId: string, pipelineId: string, request: DeletePipelineRelationsRequest): Promise<DeletePipelineRelationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deletePipelineRelationsWithOptions(organizationId, pipelineId, request, headers, runtime);
  }

  async deleteProjectWithOptions(organizationId: string, request: DeleteProjectRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteProjectResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.identifier)) {
      query["identifier"] = request.identifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteProject",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/projects/delete`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteProjectResponse>(await this.callApi(params, req, runtime), new DeleteProjectResponse({}));
  }

  async deleteProject(organizationId: string, request: DeleteProjectRequest): Promise<DeleteProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteProjectWithOptions(organizationId, request, headers, runtime);
  }

  async deleteProjectLabelWithOptions(labelId: string, request: DeleteProjectLabelRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteProjectLabelResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteProjectLabel",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/labels/${OpenApiUtil.getEncodeParam(labelId)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteProjectLabelResponse>(await this.callApi(params, req, runtime), new DeleteProjectLabelResponse({}));
  }

  async deleteProjectLabel(labelId: string, request: DeleteProjectLabelRequest): Promise<DeleteProjectLabelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteProjectLabelWithOptions(labelId, request, headers, runtime);
  }

  async deleteProtectedBranchWithOptions(repositoryId: string, protectedBranchId: string, request: DeleteProtectedBranchRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteProtectedBranchResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteProtectedBranch",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/protect_branches/${OpenApiUtil.getEncodeParam(protectedBranchId)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteProtectedBranchResponse>(await this.callApi(params, req, runtime), new DeleteProtectedBranchResponse({}));
  }

  async deleteProtectedBranch(repositoryId: string, protectedBranchId: string, request: DeleteProtectedBranchRequest): Promise<DeleteProtectedBranchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteProtectedBranchWithOptions(repositoryId, protectedBranchId, request, headers, runtime);
  }

  async deletePushRuleWithOptions(repositoryId: string, pushRuleId: string, request: DeletePushRuleRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeletePushRuleResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeletePushRule",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/push_rule/${OpenApiUtil.getEncodeParam(pushRuleId)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeletePushRuleResponse>(await this.callApi(params, req, runtime), new DeletePushRuleResponse({}));
  }

  async deletePushRule(repositoryId: string, pushRuleId: string, request: DeletePushRuleRequest): Promise<DeletePushRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deletePushRuleWithOptions(repositoryId, pushRuleId, request, headers, runtime);
  }

  async deleteRepositoryWithOptions(repositoryId: string, request: DeleteRepositoryRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteRepositoryResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.reason)) {
      body["reason"] = request.reason;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRepository",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/remove`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteRepositoryResponse>(await this.callApi(params, req, runtime), new DeleteRepositoryResponse({}));
  }

  async deleteRepository(repositoryId: string, request: DeleteRepositoryRequest): Promise<DeleteRepositoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteRepositoryWithOptions(repositoryId, request, headers, runtime);
  }

  async deleteRepositoryGroupWithOptions(groupId: string, request: DeleteRepositoryGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteRepositoryGroupResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.reason)) {
      body["reason"] = request.reason;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRepositoryGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/groups/${OpenApiUtil.getEncodeParam(groupId)}/remove`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteRepositoryGroupResponse>(await this.callApi(params, req, runtime), new DeleteRepositoryGroupResponse({}));
  }

  async deleteRepositoryGroup(groupId: string, request: DeleteRepositoryGroupRequest): Promise<DeleteRepositoryGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteRepositoryGroupWithOptions(groupId, request, headers, runtime);
  }

  async deleteRepositoryMemberWithOptions(repositoryId: string, aliyunPk: string, request: DeleteRepositoryMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteRepositoryMemberResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.memberType)) {
      body["memberType"] = request.memberType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRepositoryMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/members/delete/${OpenApiUtil.getEncodeParam(aliyunPk)}`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteRepositoryMemberResponse>(await this.callApi(params, req, runtime), new DeleteRepositoryMemberResponse({}));
  }

  async deleteRepositoryMember(repositoryId: string, aliyunPk: string, request: DeleteRepositoryMemberRequest): Promise<DeleteRepositoryMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteRepositoryMemberWithOptions(repositoryId, aliyunPk, request, headers, runtime);
  }

  async deleteRepositoryWebhookWithOptions(repositoryId: string, hookId: string, request: DeleteRepositoryWebhookRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteRepositoryWebhookResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRepositoryWebhook",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/hooks/${OpenApiUtil.getEncodeParam(hookId)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteRepositoryWebhookResponse>(await this.callApi(params, req, runtime), new DeleteRepositoryWebhookResponse({}));
  }

  async deleteRepositoryWebhook(repositoryId: string, hookId: string, request: DeleteRepositoryWebhookRequest): Promise<DeleteRepositoryWebhookResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteRepositoryWebhookWithOptions(repositoryId, hookId, request, headers, runtime);
  }

  async deleteResourceMemberWithOptions(organizationId: string, resourceType: string, resourceId: string, accountId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteResourceMemberResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "DeleteResourceMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/${OpenApiUtil.getEncodeParam(resourceType)}/${OpenApiUtil.getEncodeParam(resourceId)}/members/${OpenApiUtil.getEncodeParam(accountId)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteResourceMemberResponse>(await this.callApi(params, req, runtime), new DeleteResourceMemberResponse({}));
  }

  async deleteResourceMember(organizationId: string, resourceType: string, resourceId: string, accountId: string): Promise<DeleteResourceMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteResourceMemberWithOptions(organizationId, resourceType, resourceId, accountId, headers, runtime);
  }

  async deleteTagWithOptions(repositoryId: string, request: DeleteTagRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteTagResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.tagName)) {
      query["tagName"] = request.tagName;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTag",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/tags/delete`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteTagResponse>(await this.callApi(params, req, runtime), new DeleteTagResponse({}));
  }

  async deleteTag(repositoryId: string, request: DeleteTagRequest): Promise<DeleteTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteTagWithOptions(repositoryId, request, headers, runtime);
  }

  async deleteUserKeyWithOptions(keyId: string, request: DeleteUserKeyRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteUserKeyResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteUserKey",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v3/user/keys/${OpenApiUtil.getEncodeParam(keyId)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteUserKeyResponse>(await this.callApi(params, req, runtime), new DeleteUserKeyResponse({}));
  }

  async deleteUserKey(keyId: string, request: DeleteUserKeyRequest): Promise<DeleteUserKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteUserKeyWithOptions(keyId, request, headers, runtime);
  }

  async deleteVariableGroupWithOptions(organizationId: string, id: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteVariableGroupResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "DeleteVariableGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/variableGroups/${OpenApiUtil.getEncodeParam(id)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteVariableGroupResponse>(await this.callApi(params, req, runtime), new DeleteVariableGroupResponse({}));
  }

  async deleteVariableGroup(organizationId: string, id: string): Promise<DeleteVariableGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteVariableGroupWithOptions(organizationId, id, headers, runtime);
  }

  async deleteWorkitemWithOptions(organizationId: string, request: DeleteWorkitemRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteWorkitemResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.identifier)) {
      query["identifier"] = request.identifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteWorkitem",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitem/delete`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteWorkitemResponse>(await this.callApi(params, req, runtime), new DeleteWorkitemResponse({}));
  }

  async deleteWorkitem(organizationId: string, request: DeleteWorkitemRequest): Promise<DeleteWorkitemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteWorkitemWithOptions(organizationId, request, headers, runtime);
  }

  async deleteWorkitemAllCommentWithOptions(organizationId: string, request: DeleteWorkitemAllCommentRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteWorkitemAllCommentResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.identifier)) {
      query["identifier"] = request.identifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteWorkitemAllComment",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/deleteAllComment`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteWorkitemAllCommentResponse>(await this.callApi(params, req, runtime), new DeleteWorkitemAllCommentResponse({}));
  }

  async deleteWorkitemAllComment(organizationId: string, request: DeleteWorkitemAllCommentRequest): Promise<DeleteWorkitemAllCommentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteWorkitemAllCommentWithOptions(organizationId, request, headers, runtime);
  }

  async deleteWorkitemCommentWithOptions(organizationId: string, request: DeleteWorkitemCommentRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteWorkitemCommentResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.commentId)) {
      body["commentId"] = request.commentId;
    }

    if (!Util.isUnset(request.identifier)) {
      body["identifier"] = request.identifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteWorkitemComment",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/deleteComent`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteWorkitemCommentResponse>(await this.callApi(params, req, runtime), new DeleteWorkitemCommentResponse({}));
  }

  async deleteWorkitemComment(organizationId: string, request: DeleteWorkitemCommentRequest): Promise<DeleteWorkitemCommentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteWorkitemCommentWithOptions(organizationId, request, headers, runtime);
  }

  async enableDeployKeyWithOptions(repositoryId: string, keyId: string, request: EnableDeployKeyRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<EnableDeployKeyResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableDeployKey",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/keys/${OpenApiUtil.getEncodeParam(keyId)}/enable`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<EnableDeployKeyResponse>(await this.callApi(params, req, runtime), new EnableDeployKeyResponse({}));
  }

  async enableDeployKey(repositoryId: string, keyId: string, request: EnableDeployKeyRequest): Promise<EnableDeployKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.enableDeployKeyWithOptions(repositoryId, keyId, request, headers, runtime);
  }

  async frozenWorkspaceWithOptions(workspaceId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<FrozenWorkspaceResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "FrozenWorkspace",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/workspaces/${OpenApiUtil.getEncodeParam(workspaceId)}/frozen`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<FrozenWorkspaceResponse>(await this.callApi(params, req, runtime), new FrozenWorkspaceResponse({}));
  }

  async frozenWorkspace(workspaceId: string): Promise<FrozenWorkspaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.frozenWorkspaceWithOptions(workspaceId, headers, runtime);
  }

  async getApplicationWithOptions(appName: string, request: GetApplicationRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetApplicationResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetApplication",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetApplicationResponse>(await this.callApi(params, req, runtime), new GetApplicationResponse({}));
  }

  async getApplication(appName: string, request: GetApplicationRequest): Promise<GetApplicationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getApplicationWithOptions(appName, request, headers, runtime);
  }

  async getBranchInfoWithOptions(repositoryId: string, request: GetBranchInfoRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetBranchInfoResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.branchName)) {
      query["branchName"] = request.branchName;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetBranchInfo",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/branches/detail`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetBranchInfoResponse>(await this.callApi(params, req, runtime), new GetBranchInfoResponse({}));
  }

  async getBranchInfo(repositoryId: string, request: GetBranchInfoRequest): Promise<GetBranchInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getBranchInfoWithOptions(repositoryId, request, headers, runtime);
  }

  async getCheckRunWithOptions(request: GetCheckRunRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetCheckRunResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.checkRunId)) {
      query["checkRunId"] = request.checkRunId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetCheckRun",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/check_runs/get_check_run`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetCheckRunResponse>(await this.callApi(params, req, runtime), new GetCheckRunResponse({}));
  }

  async getCheckRun(request: GetCheckRunRequest): Promise<GetCheckRunResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getCheckRunWithOptions(request, headers, runtime);
  }

  async getCodeupOrganizationWithOptions(identity: string, request: GetCodeupOrganizationRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetCodeupOrganizationResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetCodeupOrganization",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/organization/${OpenApiUtil.getEncodeParam(identity)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetCodeupOrganizationResponse>(await this.callApi(params, req, runtime), new GetCodeupOrganizationResponse({}));
  }

  async getCodeupOrganization(identity: string, request: GetCodeupOrganizationRequest): Promise<GetCodeupOrganizationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getCodeupOrganizationWithOptions(identity, request, headers, runtime);
  }

  async getCompareDetailWithOptions(repositoryId: string, request: GetCompareDetailRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetCompareDetailResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.from)) {
      query["from"] = request.from;
    }

    if (!Util.isUnset(request.maxDiffByte)) {
      query["maxDiffByte"] = request.maxDiffByte;
    }

    if (!Util.isUnset(request.maxDiffFile)) {
      query["maxDiffFile"] = request.maxDiffFile;
    }

    if (!Util.isUnset(request.mergeBase)) {
      query["mergeBase"] = request.mergeBase;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.to)) {
      query["to"] = request.to;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetCompareDetail",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/commits/compare/detail`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetCompareDetailResponse>(await this.callApi(params, req, runtime), new GetCompareDetailResponse({}));
  }

  async getCompareDetail(repositoryId: string, request: GetCompareDetailRequest): Promise<GetCompareDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getCompareDetailWithOptions(repositoryId, request, headers, runtime);
  }

  async getCustomFieldOptionWithOptions(organizationId: string, fieldId: string, request: GetCustomFieldOptionRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetCustomFieldOptionResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.spaceIdentifier)) {
      query["spaceIdentifier"] = request.spaceIdentifier;
    }

    if (!Util.isUnset(request.spaceType)) {
      query["spaceType"] = request.spaceType;
    }

    if (!Util.isUnset(request.workitemTypeIdentifier)) {
      query["workitemTypeIdentifier"] = request.workitemTypeIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetCustomFieldOption",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/fields/${OpenApiUtil.getEncodeParam(fieldId)}/getCustomOption`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetCustomFieldOptionResponse>(await this.callApi(params, req, runtime), new GetCustomFieldOptionResponse({}));
  }

  async getCustomFieldOption(organizationId: string, fieldId: string, request: GetCustomFieldOptionRequest): Promise<GetCustomFieldOptionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getCustomFieldOptionWithOptions(organizationId, fieldId, request, headers, runtime);
  }

  async getFileBlobsWithOptions(repositoryId: string, request: GetFileBlobsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetFileBlobsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.filePath)) {
      query["filePath"] = request.filePath;
    }

    if (!Util.isUnset(request.from)) {
      query["from"] = request.from;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.ref)) {
      query["ref"] = request.ref;
    }

    if (!Util.isUnset(request.to)) {
      query["to"] = request.to;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetFileBlobs",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/files/blobs`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetFileBlobsResponse>(await this.callApi(params, req, runtime), new GetFileBlobsResponse({}));
  }

  async getFileBlobs(repositoryId: string, request: GetFileBlobsRequest): Promise<GetFileBlobsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getFileBlobsWithOptions(repositoryId, request, headers, runtime);
  }

  async getFileLastCommitWithOptions(repositoryId: string, request: GetFileLastCommitRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetFileLastCommitResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.filePath)) {
      query["filePath"] = request.filePath;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.sha)) {
      query["sha"] = request.sha;
    }

    if (!Util.isUnset(request.showSignature)) {
      query["showSignature"] = request.showSignature;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetFileLastCommit",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/files/lastCommit`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetFileLastCommitResponse>(await this.callApi(params, req, runtime), new GetFileLastCommitResponse({}));
  }

  async getFileLastCommit(repositoryId: string, request: GetFileLastCommitRequest): Promise<GetFileLastCommitResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getFileLastCommitWithOptions(repositoryId, request, headers, runtime);
  }

  async getFlowTagGroupWithOptions(organizationId: string, id: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetFlowTagGroupResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetFlowTagGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/flow/tagGroups/${OpenApiUtil.getEncodeParam(id)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetFlowTagGroupResponse>(await this.callApi(params, req, runtime), new GetFlowTagGroupResponse({}));
  }

  async getFlowTagGroup(organizationId: string, id: string): Promise<GetFlowTagGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getFlowTagGroupWithOptions(organizationId, id, headers, runtime);
  }

  async getGroupByPathWithOptions(request: GetGroupByPathRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetGroupByPathResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.identity)) {
      query["identity"] = request.identity;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetGroupByPath",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/4/groups/find_by_path`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetGroupByPathResponse>(await this.callApi(params, req, runtime), new GetGroupByPathResponse({}));
  }

  async getGroupByPath(request: GetGroupByPathRequest): Promise<GetGroupByPathResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getGroupByPathWithOptions(request, headers, runtime);
  }

  async getGroupDetailWithOptions(request: GetGroupDetailRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetGroupDetailResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.groupId)) {
      query["groupId"] = request.groupId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetGroupDetail",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/groups/get_detail`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetGroupDetailResponse>(await this.callApi(params, req, runtime), new GetGroupDetailResponse({}));
  }

  async getGroupDetail(request: GetGroupDetailRequest): Promise<GetGroupDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getGroupDetailWithOptions(request, headers, runtime);
  }

  async getHostGroupWithOptions(organizationId: string, id: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetHostGroupResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetHostGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/hostGroups/${OpenApiUtil.getEncodeParam(id)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetHostGroupResponse>(await this.callApi(params, req, runtime), new GetHostGroupResponse({}));
  }

  async getHostGroup(organizationId: string, id: string): Promise<GetHostGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getHostGroupWithOptions(organizationId, id, headers, runtime);
  }

  async getMergeRequestWithOptions(repositoryId: string, localId: string, request: GetMergeRequestRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetMergeRequestResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMergeRequest",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/merge_requests/${OpenApiUtil.getEncodeParam(localId)}/detail`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetMergeRequestResponse>(await this.callApi(params, req, runtime), new GetMergeRequestResponse({}));
  }

  async getMergeRequest(repositoryId: string, localId: string, request: GetMergeRequestRequest): Promise<GetMergeRequestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getMergeRequestWithOptions(repositoryId, localId, request, headers, runtime);
  }

  async getMergeRequestChangeTreeWithOptions(request: GetMergeRequestChangeTreeRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetMergeRequestChangeTreeResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.fromPatchSetBizId)) {
      query["fromPatchSetBizId"] = request.fromPatchSetBizId;
    }

    if (!Util.isUnset(request.localId)) {
      query["localId"] = request.localId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    if (!Util.isUnset(request.toPatchSetBizId)) {
      query["toPatchSetBizId"] = request.toPatchSetBizId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMergeRequestChangeTree",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/merge_requests/diffs/change_tree`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetMergeRequestChangeTreeResponse>(await this.callApi(params, req, runtime), new GetMergeRequestChangeTreeResponse({}));
  }

  async getMergeRequestChangeTree(request: GetMergeRequestChangeTreeRequest): Promise<GetMergeRequestChangeTreeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getMergeRequestChangeTreeWithOptions(request, headers, runtime);
  }

  async getOrganizationMemberWithOptions(organizationId: string, accountId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetOrganizationMemberResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetOrganizationMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/members/${OpenApiUtil.getEncodeParam(accountId)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetOrganizationMemberResponse>(await this.callApi(params, req, runtime), new GetOrganizationMemberResponse({}));
  }

  async getOrganizationMember(organizationId: string, accountId: string): Promise<GetOrganizationMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getOrganizationMemberWithOptions(organizationId, accountId, headers, runtime);
  }

  async getPipelineWithOptions(organizationId: string, pipelineId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetPipelineResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetPipeline",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetPipelineResponse>(await this.callApi(params, req, runtime), new GetPipelineResponse({}));
  }

  async getPipeline(organizationId: string, pipelineId: string): Promise<GetPipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getPipelineWithOptions(organizationId, pipelineId, headers, runtime);
  }

  async getPipelineArtifactUrlWithOptions(organizationId: string, request: GetPipelineArtifactUrlRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetPipelineArtifactUrlResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.fileName)) {
      query["fileName"] = request.fileName;
    }

    if (!Util.isUnset(request.filePath)) {
      query["filePath"] = request.filePath;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPipelineArtifactUrl",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipeline/getArtifactDownloadUrl`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetPipelineArtifactUrlResponse>(await this.callApi(params, req, runtime), new GetPipelineArtifactUrlResponse({}));
  }

  async getPipelineArtifactUrl(organizationId: string, request: GetPipelineArtifactUrlRequest): Promise<GetPipelineArtifactUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getPipelineArtifactUrlWithOptions(organizationId, request, headers, runtime);
  }

  async getPipelineEmasArtifactUrlWithOptions(organizationId: string, emasJobInstanceId: string, md5: string, pipelineId: string, pipelineRunId: string, request: GetPipelineEmasArtifactUrlRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetPipelineEmasArtifactUrlResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.serviceConnectionId)) {
      query["serviceConnectionId"] = request.serviceConnectionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPipelineEmasArtifactUrl",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipeline/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRun/${OpenApiUtil.getEncodeParam(pipelineRunId)}/emas/artifact/${OpenApiUtil.getEncodeParam(emasJobInstanceId)}/${OpenApiUtil.getEncodeParam(md5)}`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetPipelineEmasArtifactUrlResponse>(await this.callApi(params, req, runtime), new GetPipelineEmasArtifactUrlResponse({}));
  }

  async getPipelineEmasArtifactUrl(organizationId: string, emasJobInstanceId: string, md5: string, pipelineId: string, pipelineRunId: string, request: GetPipelineEmasArtifactUrlRequest): Promise<GetPipelineEmasArtifactUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getPipelineEmasArtifactUrlWithOptions(organizationId, emasJobInstanceId, md5, pipelineId, pipelineRunId, request, headers, runtime);
  }

  async getPipelineGroupWithOptions(organizationId: string, groupId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetPipelineGroupResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetPipelineGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelineGroups/${OpenApiUtil.getEncodeParam(groupId)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetPipelineGroupResponse>(await this.callApi(params, req, runtime), new GetPipelineGroupResponse({}));
  }

  async getPipelineGroup(organizationId: string, groupId: string): Promise<GetPipelineGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getPipelineGroupWithOptions(organizationId, groupId, headers, runtime);
  }

  async getPipelineRunWithOptions(organizationId: string, pipelineId: string, pipelineRunId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetPipelineRunResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetPipelineRun",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRuns/${OpenApiUtil.getEncodeParam(pipelineRunId)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetPipelineRunResponse>(await this.callApi(params, req, runtime), new GetPipelineRunResponse({}));
  }

  async getPipelineRun(organizationId: string, pipelineId: string, pipelineRunId: string): Promise<GetPipelineRunResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getPipelineRunWithOptions(organizationId, pipelineId, pipelineRunId, headers, runtime);
  }

  async getPipelineScanReportUrlWithOptions(organizationId: string, request: GetPipelineScanReportUrlRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetPipelineScanReportUrlResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.reportPath)) {
      body["reportPath"] = request.reportPath;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetPipelineScanReportUrl",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipeline/getPipelineScanReportUrl`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetPipelineScanReportUrlResponse>(await this.callApi(params, req, runtime), new GetPipelineScanReportUrlResponse({}));
  }

  async getPipelineScanReportUrl(organizationId: string, request: GetPipelineScanReportUrlRequest): Promise<GetPipelineScanReportUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getPipelineScanReportUrlWithOptions(organizationId, request, headers, runtime);
  }

  async getProjectInfoWithOptions(organizationId: string, projectId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetProjectInfoResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetProjectInfo",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/project/${OpenApiUtil.getEncodeParam(projectId)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetProjectInfoResponse>(await this.callApi(params, req, runtime), new GetProjectInfoResponse({}));
  }

  async getProjectInfo(organizationId: string, projectId: string): Promise<GetProjectInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getProjectInfoWithOptions(organizationId, projectId, headers, runtime);
  }

  async getProjectMemberWithOptions(repositoryId: string, aliyunPk: string, request: GetProjectMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetProjectMemberResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetProjectMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/members/get/${OpenApiUtil.getEncodeParam(aliyunPk)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetProjectMemberResponse>(await this.callApi(params, req, runtime), new GetProjectMemberResponse({}));
  }

  async getProjectMember(repositoryId: string, aliyunPk: string, request: GetProjectMemberRequest): Promise<GetProjectMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getProjectMemberWithOptions(repositoryId, aliyunPk, request, headers, runtime);
  }

  async getPushRuleWithOptions(repositoryId: string, pushRuleId: string, request: GetPushRuleRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetPushRuleResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPushRule",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/push_rule/${OpenApiUtil.getEncodeParam(pushRuleId)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetPushRuleResponse>(await this.callApi(params, req, runtime), new GetPushRuleResponse({}));
  }

  async getPushRule(repositoryId: string, pushRuleId: string, request: GetPushRuleRequest): Promise<GetPushRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getPushRuleWithOptions(repositoryId, pushRuleId, request, headers, runtime);
  }

  async getRepositoryWithOptions(request: GetRepositoryRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetRepositoryResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.identity)) {
      query["identity"] = request.identity;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRepository",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/get`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetRepositoryResponse>(await this.callApi(params, req, runtime), new GetRepositoryResponse({}));
  }

  async getRepository(request: GetRepositoryRequest): Promise<GetRepositoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getRepositoryWithOptions(request, headers, runtime);
  }

  async getRepositoryCommitWithOptions(repositoryId: string, sha: string, request: GetRepositoryCommitRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetRepositoryCommitResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.showSignature)) {
      query["showSignature"] = request.showSignature;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRepositoryCommit",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/commits/${OpenApiUtil.getEncodeParam(sha)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetRepositoryCommitResponse>(await this.callApi(params, req, runtime), new GetRepositoryCommitResponse({}));
  }

  async getRepositoryCommit(repositoryId: string, sha: string, request: GetRepositoryCommitRequest): Promise<GetRepositoryCommitResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getRepositoryCommitWithOptions(repositoryId, sha, request, headers, runtime);
  }

  async getRepositoryTagWithOptions(repositoryId: string, request: GetRepositoryTagRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetRepositoryTagResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.tagName)) {
      query["tagName"] = request.tagName;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRepositoryTag",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/tag/info`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetRepositoryTagResponse>(await this.callApi(params, req, runtime), new GetRepositoryTagResponse({}));
  }

  async getRepositoryTag(repositoryId: string, request: GetRepositoryTagRequest): Promise<GetRepositoryTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getRepositoryTagWithOptions(repositoryId, request, headers, runtime);
  }

  async getSearchCodePreviewWithOptions(request: GetSearchCodePreviewRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetSearchCodePreviewResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.docId)) {
      query["docId"] = request.docId;
    }

    if (!Util.isUnset(request.isDsl)) {
      query["isDsl"] = request.isDsl;
    }

    if (!Util.isUnset(request.keyword)) {
      query["keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSearchCodePreview",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/search/code_preview`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetSearchCodePreviewResponse>(await this.callApi(params, req, runtime), new GetSearchCodePreviewResponse({}));
  }

  async getSearchCodePreview(request: GetSearchCodePreviewRequest): Promise<GetSearchCodePreviewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getSearchCodePreviewWithOptions(request, headers, runtime);
  }

  async getSprintInfoWithOptions(organizationId: string, sprintId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetSprintInfoResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetSprintInfo",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/sprints/${OpenApiUtil.getEncodeParam(sprintId)}/getSprintinfo`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetSprintInfoResponse>(await this.callApi(params, req, runtime), new GetSprintInfoResponse({}));
  }

  async getSprintInfo(organizationId: string, sprintId: string): Promise<GetSprintInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getSprintInfoWithOptions(organizationId, sprintId, headers, runtime);
  }

  async getTestResultListWithOptions(organizationId: string, testPlanIdentifier: string, request: GetTestResultListRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetTestResultListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.conditions)) {
      body["conditions"] = request.conditions;
    }

    if (!Util.isUnset(request.directoryIdentifier)) {
      body["directoryIdentifier"] = request.directoryIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetTestResultList",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/testhub/testplan/${OpenApiUtil.getEncodeParam(testPlanIdentifier)}/testresults`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetTestResultListResponse>(await this.callApi(params, req, runtime), new GetTestResultListResponse({}));
  }

  async getTestResultList(organizationId: string, testPlanIdentifier: string, request: GetTestResultListRequest): Promise<GetTestResultListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getTestResultListWithOptions(organizationId, testPlanIdentifier, request, headers, runtime);
  }

  async getTestcaseListWithOptions(organizationId: string, request: GetTestcaseListRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetTestcaseListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.conditions)) {
      body["conditions"] = request.conditions;
    }

    if (!Util.isUnset(request.directoryIdentifier)) {
      body["directoryIdentifier"] = request.directoryIdentifier;
    }

    if (!Util.isUnset(request.maxResult)) {
      body["maxResult"] = request.maxResult;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.spaceIdentifier)) {
      body["spaceIdentifier"] = request.spaceIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetTestcaseList",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/testhub/testcases`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetTestcaseListResponse>(await this.callApi(params, req, runtime), new GetTestcaseListResponse({}));
  }

  async getTestcaseList(organizationId: string, request: GetTestcaseListRequest): Promise<GetTestcaseListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getTestcaseListWithOptions(organizationId, request, headers, runtime);
  }

  async getUserInfoWithOptions(request: GetUserInfoRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetUserInfoResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetUserInfo",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/users/current`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetUserInfoResponse>(await this.callApi(params, req, runtime), new GetUserInfoResponse({}));
  }

  async getUserInfo(request: GetUserInfoRequest): Promise<GetUserInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getUserInfoWithOptions(request, headers, runtime);
  }

  async getVMDeployOrderWithOptions(organizationId: string, pipelineId: string, deployOrderId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetVMDeployOrderResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetVMDeployOrder",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/deploy/${OpenApiUtil.getEncodeParam(deployOrderId)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetVMDeployOrderResponse>(await this.callApi(params, req, runtime), new GetVMDeployOrderResponse({}));
  }

  async getVMDeployOrder(organizationId: string, pipelineId: string, deployOrderId: string): Promise<GetVMDeployOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getVMDeployOrderWithOptions(organizationId, pipelineId, deployOrderId, headers, runtime);
  }

  async getVariableGroupWithOptions(organizationId: string, id: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetVariableGroupResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetVariableGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/variableGroups/${OpenApiUtil.getEncodeParam(id)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetVariableGroupResponse>(await this.callApi(params, req, runtime), new GetVariableGroupResponse({}));
  }

  async getVariableGroup(organizationId: string, id: string): Promise<GetVariableGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getVariableGroupWithOptions(organizationId, id, headers, runtime);
  }

  async getWorkItemActivityWithOptions(organizationId: string, workitemId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetWorkItemActivityResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetWorkItemActivity",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/${OpenApiUtil.getEncodeParam(workitemId)}/getActivity`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetWorkItemActivityResponse>(await this.callApi(params, req, runtime), new GetWorkItemActivityResponse({}));
  }

  async getWorkItemActivity(organizationId: string, workitemId: string): Promise<GetWorkItemActivityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getWorkItemActivityWithOptions(organizationId, workitemId, headers, runtime);
  }

  async getWorkItemInfoWithOptions(organizationId: string, workitemId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetWorkItemInfoResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetWorkItemInfo",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/${OpenApiUtil.getEncodeParam(workitemId)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetWorkItemInfoResponse>(await this.callApi(params, req, runtime), new GetWorkItemInfoResponse({}));
  }

  async getWorkItemInfo(organizationId: string, workitemId: string): Promise<GetWorkItemInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getWorkItemInfoWithOptions(organizationId, workitemId, headers, runtime);
  }

  async getWorkItemWorkFlowInfoWithOptions(organizationId: string, workitemId: string, request: GetWorkItemWorkFlowInfoRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetWorkItemWorkFlowInfoResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.configurationId)) {
      query["configurationId"] = request.configurationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetWorkItemWorkFlowInfo",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/${OpenApiUtil.getEncodeParam(workitemId)}/getWorkflowInfo`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetWorkItemWorkFlowInfoResponse>(await this.callApi(params, req, runtime), new GetWorkItemWorkFlowInfoResponse({}));
  }

  async getWorkItemWorkFlowInfo(organizationId: string, workitemId: string, request: GetWorkItemWorkFlowInfoRequest): Promise<GetWorkItemWorkFlowInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getWorkItemWorkFlowInfoWithOptions(organizationId, workitemId, request, headers, runtime);
  }

  async getWorkitemAttachmentCreatemetaWithOptions(organizationId: string, workitemIdentifier: string, request: GetWorkitemAttachmentCreatemetaRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetWorkitemAttachmentCreatemetaResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.fileName)) {
      query["fileName"] = request.fileName;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetWorkitemAttachmentCreatemeta",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitem/${OpenApiUtil.getEncodeParam(workitemIdentifier)}/attachment/createmeta`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetWorkitemAttachmentCreatemetaResponse>(await this.callApi(params, req, runtime), new GetWorkitemAttachmentCreatemetaResponse({}));
  }

  async getWorkitemAttachmentCreatemeta(organizationId: string, workitemIdentifier: string, request: GetWorkitemAttachmentCreatemetaRequest): Promise<GetWorkitemAttachmentCreatemetaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getWorkitemAttachmentCreatemetaWithOptions(organizationId, workitemIdentifier, request, headers, runtime);
  }

  async getWorkitemCommentListWithOptions(organizationId: string, workitemId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetWorkitemCommentListResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetWorkitemCommentList",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/${OpenApiUtil.getEncodeParam(workitemId)}/commentList`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetWorkitemCommentListResponse>(await this.callApi(params, req, runtime), new GetWorkitemCommentListResponse({}));
  }

  async getWorkitemCommentList(organizationId: string, workitemId: string): Promise<GetWorkitemCommentListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getWorkitemCommentListWithOptions(organizationId, workitemId, headers, runtime);
  }

  async getWorkitemFileWithOptions(organizationId: string, workitemIdentifier: string, fileIdentifier: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetWorkitemFileResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetWorkitemFile",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitem/${OpenApiUtil.getEncodeParam(workitemIdentifier)}/files/${OpenApiUtil.getEncodeParam(fileIdentifier)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetWorkitemFileResponse>(await this.callApi(params, req, runtime), new GetWorkitemFileResponse({}));
  }

  async getWorkitemFile(organizationId: string, workitemIdentifier: string, fileIdentifier: string): Promise<GetWorkitemFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getWorkitemFileWithOptions(organizationId, workitemIdentifier, fileIdentifier, headers, runtime);
  }

  async getWorkitemRelationsWithOptions(organizationId: string, workitemId: string, request: GetWorkitemRelationsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetWorkitemRelationsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.relationType)) {
      query["relationType"] = request.relationType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetWorkitemRelations",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/${OpenApiUtil.getEncodeParam(workitemId)}/getRelations`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetWorkitemRelationsResponse>(await this.callApi(params, req, runtime), new GetWorkitemRelationsResponse({}));
  }

  async getWorkitemRelations(organizationId: string, workitemId: string, request: GetWorkitemRelationsRequest): Promise<GetWorkitemRelationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getWorkitemRelationsWithOptions(organizationId, workitemId, request, headers, runtime);
  }

  async getWorkitemTimeTypeListWithOptions(organizationId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetWorkitemTimeTypeListResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetWorkitemTimeTypeList",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/type/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetWorkitemTimeTypeListResponse>(await this.callApi(params, req, runtime), new GetWorkitemTimeTypeListResponse({}));
  }

  async getWorkitemTimeTypeList(organizationId: string): Promise<GetWorkitemTimeTypeListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getWorkitemTimeTypeListWithOptions(organizationId, headers, runtime);
  }

  async getWorkspaceWithOptions(workspaceId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetWorkspaceResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetWorkspace",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/workspaces/${OpenApiUtil.getEncodeParam(workspaceId)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetWorkspaceResponse>(await this.callApi(params, req, runtime), new GetWorkspaceResponse({}));
  }

  async getWorkspace(workspaceId: string): Promise<GetWorkspaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getWorkspaceWithOptions(workspaceId, headers, runtime);
  }

  async joinPipelineGroupWithOptions(organizationId: string, request: JoinPipelineGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<JoinPipelineGroupResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.groupId)) {
      query["groupId"] = request.groupId;
    }

    if (!Util.isUnset(request.pipelineIds)) {
      query["pipelineIds"] = request.pipelineIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "JoinPipelineGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelineGroups/join`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<JoinPipelineGroupResponse>(await this.callApi(params, req, runtime), new JoinPipelineGroupResponse({}));
  }

  async joinPipelineGroup(organizationId: string, request: JoinPipelineGroupRequest): Promise<JoinPipelineGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.joinPipelineGroupWithOptions(organizationId, request, headers, runtime);
  }

  async linkMergeRequestLabelWithOptions(request: LinkMergeRequestLabelRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<LinkMergeRequestLabelResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.localId)) {
      query["localId"] = request.localId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.labelIds)) {
      body["labelIds"] = request.labelIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "LinkMergeRequestLabel",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/merge_requests/link_labels`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<LinkMergeRequestLabelResponse>(await this.callApi(params, req, runtime), new LinkMergeRequestLabelResponse({}));
  }

  async linkMergeRequestLabel(request: LinkMergeRequestLabelRequest): Promise<LinkMergeRequestLabelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.linkMergeRequestLabelWithOptions(request, headers, runtime);
  }

  async listApplicationMembersWithOptions(appName: string, request: ListApplicationMembersRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListApplicationMembersResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListApplicationMembers",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}/members`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListApplicationMembersResponse>(await this.callApi(params, req, runtime), new ListApplicationMembersResponse({}));
  }

  async listApplicationMembers(appName: string, request: ListApplicationMembersRequest): Promise<ListApplicationMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listApplicationMembersWithOptions(appName, request, headers, runtime);
  }

  async listApplicationsWithOptions(request: ListApplicationsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListApplicationsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["orderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.pagination)) {
      query["pagination"] = request.pagination;
    }

    if (!Util.isUnset(request.perPage)) {
      query["perPage"] = request.perPage;
    }

    if (!Util.isUnset(request.sort)) {
      query["sort"] = request.sort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListApplications",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps%3Asearch`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListApplicationsResponse>(await this.callApi(params, req, runtime), new ListApplicationsResponse({}));
  }

  async listApplications(request: ListApplicationsRequest): Promise<ListApplicationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listApplicationsWithOptions(request, headers, runtime);
  }

  async listCheckRunsWithOptions(request: ListCheckRunsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListCheckRunsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.ref)) {
      query["ref"] = request.ref;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCheckRuns",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/check_runs/list_check_runs`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListCheckRunsResponse>(await this.callApi(params, req, runtime), new ListCheckRunsResponse({}));
  }

  async listCheckRuns(request: ListCheckRunsRequest): Promise<ListCheckRunsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listCheckRunsWithOptions(request, headers, runtime);
  }

  async listCommitStatusesWithOptions(request: ListCommitStatusesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListCommitStatusesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    if (!Util.isUnset(request.sha)) {
      query["sha"] = request.sha;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCommitStatuses",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/repository/commit_statuses/list_commit_statuses`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListCommitStatusesResponse>(await this.callApi(params, req, runtime), new ListCommitStatusesResponse({}));
  }

  async listCommitStatuses(request: ListCommitStatusesRequest): Promise<ListCommitStatusesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listCommitStatusesWithOptions(request, headers, runtime);
  }

  async listFlowTagGroupsWithOptions(organizationId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListFlowTagGroupsResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "ListFlowTagGroups",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/flow/tagGroups`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListFlowTagGroupsResponse>(await this.callApi(params, req, runtime), new ListFlowTagGroupsResponse({}));
  }

  async listFlowTagGroups(organizationId: string): Promise<ListFlowTagGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listFlowTagGroupsWithOptions(organizationId, headers, runtime);
  }

  async listGroupMemberWithOptions(groupId: string, request: ListGroupMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListGroupMemberResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListGroupMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/groups/${OpenApiUtil.getEncodeParam(groupId)}/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListGroupMemberResponse>(await this.callApi(params, req, runtime), new ListGroupMemberResponse({}));
  }

  async listGroupMember(groupId: string, request: ListGroupMemberRequest): Promise<ListGroupMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listGroupMemberWithOptions(groupId, request, headers, runtime);
  }

  async listGroupRepositoriesWithOptions(groupId: string, request: ListGroupRepositoriesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListGroupRepositoriesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.search)) {
      query["search"] = request.search;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListGroupRepositories",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/groups/${OpenApiUtil.getEncodeParam(groupId)}/projects`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListGroupRepositoriesResponse>(await this.callApi(params, req, runtime), new ListGroupRepositoriesResponse({}));
  }

  async listGroupRepositories(groupId: string, request: ListGroupRepositoriesRequest): Promise<ListGroupRepositoriesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listGroupRepositoriesWithOptions(groupId, request, headers, runtime);
  }

  async listHostGroupsWithOptions(organizationId: string, request: ListHostGroupsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListHostGroupsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.createEndTime)) {
      query["createEndTime"] = request.createEndTime;
    }

    if (!Util.isUnset(request.createStartTime)) {
      query["createStartTime"] = request.createStartTime;
    }

    if (!Util.isUnset(request.creatorAccountIds)) {
      query["creatorAccountIds"] = request.creatorAccountIds;
    }

    if (!Util.isUnset(request.ids)) {
      query["ids"] = request.ids;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.name)) {
      query["name"] = request.name;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.pageOrder)) {
      query["pageOrder"] = request.pageOrder;
    }

    if (!Util.isUnset(request.pageSort)) {
      query["pageSort"] = request.pageSort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListHostGroups",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/hostGroups`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListHostGroupsResponse>(await this.callApi(params, req, runtime), new ListHostGroupsResponse({}));
  }

  async listHostGroups(organizationId: string, request: ListHostGroupsRequest): Promise<ListHostGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listHostGroupsWithOptions(organizationId, request, headers, runtime);
  }

  async listJoinedOrganizationsWithOptions(headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListJoinedOrganizationsResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "ListJoinedOrganizations",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/users/joinedOrgs`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListJoinedOrganizationsResponse>(await this.callApi(params, req, runtime), new ListJoinedOrganizationsResponse({}));
  }

  async listJoinedOrganizations(): Promise<ListJoinedOrganizationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listJoinedOrganizationsWithOptions(headers, runtime);
  }

  async listMergeRequestCommentsWithOptions(request: ListMergeRequestCommentsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListMergeRequestCommentsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.localId)) {
      query["localId"] = request.localId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.commentType)) {
      body["commentType"] = request.commentType;
    }

    if (!Util.isUnset(request.filePath)) {
      body["filePath"] = request.filePath;
    }

    if (!Util.isUnset(request.patchSetBizIds)) {
      body["patchSetBizIds"] = request.patchSetBizIds;
    }

    if (!Util.isUnset(request.resolved)) {
      body["resolved"] = request.resolved;
    }

    if (!Util.isUnset(request.state)) {
      body["state"] = request.state;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListMergeRequestComments",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/merge_requests/comments/list_comments`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListMergeRequestCommentsResponse>(await this.callApi(params, req, runtime), new ListMergeRequestCommentsResponse({}));
  }

  async listMergeRequestComments(request: ListMergeRequestCommentsRequest): Promise<ListMergeRequestCommentsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listMergeRequestCommentsWithOptions(request, headers, runtime);
  }

  async listMergeRequestFilesReadsWithOptions(request: ListMergeRequestFilesReadsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListMergeRequestFilesReadsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.fromPatchSetBizId)) {
      query["fromPatchSetBizId"] = request.fromPatchSetBizId;
    }

    if (!Util.isUnset(request.localId)) {
      query["localId"] = request.localId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    if (!Util.isUnset(request.toPatchSetBizId)) {
      query["toPatchSetBizId"] = request.toPatchSetBizId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListMergeRequestFilesReads",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/merge_requests/diffs/files_read_infos`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListMergeRequestFilesReadsResponse>(await this.callApi(params, req, runtime), new ListMergeRequestFilesReadsResponse({}));
  }

  async listMergeRequestFilesReads(request: ListMergeRequestFilesReadsRequest): Promise<ListMergeRequestFilesReadsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listMergeRequestFilesReadsWithOptions(request, headers, runtime);
  }

  async listMergeRequestLabelsWithOptions(request: ListMergeRequestLabelsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListMergeRequestLabelsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.localId)) {
      query["localId"] = request.localId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListMergeRequestLabels",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/merge_requests/labels`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListMergeRequestLabelsResponse>(await this.callApi(params, req, runtime), new ListMergeRequestLabelsResponse({}));
  }

  async listMergeRequestLabels(request: ListMergeRequestLabelsRequest): Promise<ListMergeRequestLabelsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listMergeRequestLabelsWithOptions(request, headers, runtime);
  }

  async listMergeRequestPatchSetsWithOptions(request: ListMergeRequestPatchSetsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListMergeRequestPatchSetsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.localId)) {
      query["localId"] = request.localId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListMergeRequestPatchSets",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/merge_requests/diffs/list_patchsets`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListMergeRequestPatchSetsResponse>(await this.callApi(params, req, runtime), new ListMergeRequestPatchSetsResponse({}));
  }

  async listMergeRequestPatchSets(request: ListMergeRequestPatchSetsRequest): Promise<ListMergeRequestPatchSetsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listMergeRequestPatchSetsWithOptions(request, headers, runtime);
  }

  async listMergeRequestsWithOptions(request: ListMergeRequestsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListMergeRequestsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.authorIds)) {
      query["authorIds"] = request.authorIds;
    }

    if (!Util.isUnset(request.createdAfter)) {
      query["createdAfter"] = request.createdAfter;
    }

    if (!Util.isUnset(request.createdBefore)) {
      query["createdBefore"] = request.createdBefore;
    }

    if (!Util.isUnset(request.filter)) {
      query["filter"] = request.filter;
    }

    if (!Util.isUnset(request.groupIds)) {
      query["groupIds"] = request.groupIds;
    }

    if (!Util.isUnset(request.labelIds)) {
      query["labelIds"] = request.labelIds;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["orderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectIds)) {
      query["projectIds"] = request.projectIds;
    }

    if (!Util.isUnset(request.reviewerIds)) {
      query["reviewerIds"] = request.reviewerIds;
    }

    if (!Util.isUnset(request.search)) {
      query["search"] = request.search;
    }

    if (!Util.isUnset(request.sort)) {
      query["sort"] = request.sort;
    }

    if (!Util.isUnset(request.state)) {
      query["state"] = request.state;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListMergeRequests",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/merge_requests/advanced_search`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListMergeRequestsResponse>(await this.callApi(params, req, runtime), new ListMergeRequestsResponse({}));
  }

  async listMergeRequests(request: ListMergeRequestsRequest): Promise<ListMergeRequestsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listMergeRequestsWithOptions(request, headers, runtime);
  }

  async listOrganizationMembersWithOptions(organizationId: string, request: ListOrganizationMembersRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListOrganizationMembersResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.containsExternInfo)) {
      query["containsExternInfo"] = request.containsExternInfo;
    }

    if (!Util.isUnset(request.externUid)) {
      query["externUid"] = request.externUid;
    }

    if (!Util.isUnset(request.joinTimeFrom)) {
      query["joinTimeFrom"] = request.joinTimeFrom;
    }

    if (!Util.isUnset(request.joinTimeTo)) {
      query["joinTimeTo"] = request.joinTimeTo;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.organizationMemberName)) {
      query["organizationMemberName"] = request.organizationMemberName;
    }

    if (!Util.isUnset(request.provider)) {
      query["provider"] = request.provider;
    }

    if (!Util.isUnset(request.state)) {
      query["state"] = request.state;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOrganizationMembers",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/members`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListOrganizationMembersResponse>(await this.callApi(params, req, runtime), new ListOrganizationMembersResponse({}));
  }

  async listOrganizationMembers(organizationId: string, request: ListOrganizationMembersRequest): Promise<ListOrganizationMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listOrganizationMembersWithOptions(organizationId, request, headers, runtime);
  }

  async listOrganizationsWithOptions(request: ListOrganizationsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListOrganizationsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessLevel)) {
      query["accessLevel"] = request.accessLevel;
    }

    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.minAccessLevel)) {
      query["minAccessLevel"] = request.minAccessLevel;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOrganizations",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organizations/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListOrganizationsResponse>(await this.callApi(params, req, runtime), new ListOrganizationsResponse({}));
  }

  async listOrganizations(request: ListOrganizationsRequest): Promise<ListOrganizationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listOrganizationsWithOptions(request, headers, runtime);
  }

  async listPipelineGroupPipelinesWithOptions(organizationId: string, groupId: string, request: ListPipelineGroupPipelinesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListPipelineGroupPipelinesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.createEndTime)) {
      query["createEndTime"] = request.createEndTime;
    }

    if (!Util.isUnset(request.createStartTime)) {
      query["createStartTime"] = request.createStartTime;
    }

    if (!Util.isUnset(request.executeEndTime)) {
      query["executeEndTime"] = request.executeEndTime;
    }

    if (!Util.isUnset(request.executeStartTime)) {
      query["executeStartTime"] = request.executeStartTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.pipelineName)) {
      query["pipelineName"] = request.pipelineName;
    }

    if (!Util.isUnset(request.resultStatusList)) {
      query["resultStatusList"] = request.resultStatusList;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPipelineGroupPipelines",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelineGroups/${OpenApiUtil.getEncodeParam(groupId)}/pipelines`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListPipelineGroupPipelinesResponse>(await this.callApi(params, req, runtime), new ListPipelineGroupPipelinesResponse({}));
  }

  async listPipelineGroupPipelines(organizationId: string, groupId: string, request: ListPipelineGroupPipelinesRequest): Promise<ListPipelineGroupPipelinesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listPipelineGroupPipelinesWithOptions(organizationId, groupId, request, headers, runtime);
  }

  async listPipelineGroupsWithOptions(organizationId: string, request: ListPipelineGroupsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListPipelineGroupsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPipelineGroups",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelineGroups`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListPipelineGroupsResponse>(await this.callApi(params, req, runtime), new ListPipelineGroupsResponse({}));
  }

  async listPipelineGroups(organizationId: string, request: ListPipelineGroupsRequest): Promise<ListPipelineGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listPipelineGroupsWithOptions(organizationId, request, headers, runtime);
  }

  async listPipelineJobHistorysWithOptions(organizationId: string, pipelineId: string, request: ListPipelineJobHistorysRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListPipelineJobHistorysResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.category)) {
      query["category"] = request.category;
    }

    if (!Util.isUnset(request.identifier)) {
      query["identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPipelineJobHistorys",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipeline/${OpenApiUtil.getEncodeParam(pipelineId)}/job/historys`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListPipelineJobHistorysResponse>(await this.callApi(params, req, runtime), new ListPipelineJobHistorysResponse({}));
  }

  async listPipelineJobHistorys(organizationId: string, pipelineId: string, request: ListPipelineJobHistorysRequest): Promise<ListPipelineJobHistorysResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listPipelineJobHistorysWithOptions(organizationId, pipelineId, request, headers, runtime);
  }

  async listPipelineJobsWithOptions(organizationId: string, pipelineId: string, request: ListPipelineJobsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListPipelineJobsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.category)) {
      query["category"] = request.category;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPipelineJobs",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipeline/${OpenApiUtil.getEncodeParam(pipelineId)}/jobs`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListPipelineJobsResponse>(await this.callApi(params, req, runtime), new ListPipelineJobsResponse({}));
  }

  async listPipelineJobs(organizationId: string, pipelineId: string, request: ListPipelineJobsRequest): Promise<ListPipelineJobsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listPipelineJobsWithOptions(organizationId, pipelineId, request, headers, runtime);
  }

  async listPipelineRelationsWithOptions(organizationId: string, pipelineId: string, request: ListPipelineRelationsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListPipelineRelationsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.relObjectType)) {
      query["relObjectType"] = request.relObjectType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPipelineRelations",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRelations`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListPipelineRelationsResponse>(await this.callApi(params, req, runtime), new ListPipelineRelationsResponse({}));
  }

  async listPipelineRelations(organizationId: string, pipelineId: string, request: ListPipelineRelationsRequest): Promise<ListPipelineRelationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listPipelineRelationsWithOptions(organizationId, pipelineId, request, headers, runtime);
  }

  async listPipelineRunsWithOptions(organizationId: string, pipelineId: string, request: ListPipelineRunsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListPipelineRunsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      query["endTime"] = request.endTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.startTime)) {
      query["startTime"] = request.startTime;
    }

    if (!Util.isUnset(request.status)) {
      query["status"] = request.status;
    }

    if (!Util.isUnset(request.triggerMode)) {
      query["triggerMode"] = request.triggerMode;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPipelineRuns",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRuns`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListPipelineRunsResponse>(await this.callApi(params, req, runtime), new ListPipelineRunsResponse({}));
  }

  async listPipelineRuns(organizationId: string, pipelineId: string, request: ListPipelineRunsRequest): Promise<ListPipelineRunsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listPipelineRunsWithOptions(organizationId, pipelineId, request, headers, runtime);
  }

  async listPipelinesWithOptions(organizationId: string, request: ListPipelinesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListPipelinesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.createEndTime)) {
      query["createEndTime"] = request.createEndTime;
    }

    if (!Util.isUnset(request.createStartTime)) {
      query["createStartTime"] = request.createStartTime;
    }

    if (!Util.isUnset(request.creatorAccountIds)) {
      query["creatorAccountIds"] = request.creatorAccountIds;
    }

    if (!Util.isUnset(request.executeAccountIds)) {
      query["executeAccountIds"] = request.executeAccountIds;
    }

    if (!Util.isUnset(request.executeEndTime)) {
      query["executeEndTime"] = request.executeEndTime;
    }

    if (!Util.isUnset(request.executeStartTime)) {
      query["executeStartTime"] = request.executeStartTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.pipelineName)) {
      query["pipelineName"] = request.pipelineName;
    }

    if (!Util.isUnset(request.statusList)) {
      query["statusList"] = request.statusList;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPipelines",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListPipelinesResponse>(await this.callApi(params, req, runtime), new ListPipelinesResponse({}));
  }

  async listPipelines(organizationId: string, request: ListPipelinesRequest): Promise<ListPipelinesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listPipelinesWithOptions(organizationId, request, headers, runtime);
  }

  async listProjectLabelsWithOptions(request: ListProjectLabelsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListProjectLabelsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["orderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    if (!Util.isUnset(request.search)) {
      query["search"] = request.search;
    }

    if (!Util.isUnset(request.sort)) {
      query["sort"] = request.sort;
    }

    if (!Util.isUnset(request.withCounts)) {
      query["withCounts"] = request.withCounts;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProjectLabels",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/labels`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListProjectLabelsResponse>(await this.callApi(params, req, runtime), new ListProjectLabelsResponse({}));
  }

  async listProjectLabels(request: ListProjectLabelsRequest): Promise<ListProjectLabelsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listProjectLabelsWithOptions(request, headers, runtime);
  }

  async listProjectMembersWithOptions(organizationId: string, projectId: string, request: ListProjectMembersRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListProjectMembersResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.targetType)) {
      query["targetType"] = request.targetType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProjectMembers",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/projects/${OpenApiUtil.getEncodeParam(projectId)}/listMembers`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListProjectMembersResponse>(await this.callApi(params, req, runtime), new ListProjectMembersResponse({}));
  }

  async listProjectMembers(organizationId: string, projectId: string, request: ListProjectMembersRequest): Promise<ListProjectMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listProjectMembersWithOptions(organizationId, projectId, request, headers, runtime);
  }

  async listProjectTemplatesWithOptions(organizationId: string, request: ListProjectTemplatesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListProjectTemplatesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.category)) {
      query["category"] = request.category;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProjectTemplates",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/projects/listTemplates`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListProjectTemplatesResponse>(await this.callApi(params, req, runtime), new ListProjectTemplatesResponse({}));
  }

  async listProjectTemplates(organizationId: string, request: ListProjectTemplatesRequest): Promise<ListProjectTemplatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listProjectTemplatesWithOptions(organizationId, request, headers, runtime);
  }

  async listProjectWorkitemTypesWithOptions(organizationId: string, projectId: string, request: ListProjectWorkitemTypesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListProjectWorkitemTypesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.category)) {
      query["category"] = request.category;
    }

    if (!Util.isUnset(request.spaceType)) {
      query["spaceType"] = request.spaceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProjectWorkitemTypes",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/projects/${OpenApiUtil.getEncodeParam(projectId)}/getWorkitemType`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListProjectWorkitemTypesResponse>(await this.callApi(params, req, runtime), new ListProjectWorkitemTypesResponse({}));
  }

  async listProjectWorkitemTypes(organizationId: string, projectId: string, request: ListProjectWorkitemTypesRequest): Promise<ListProjectWorkitemTypesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listProjectWorkitemTypesWithOptions(organizationId, projectId, request, headers, runtime);
  }

  async listProjectsWithOptions(organizationId: string, request: ListProjectsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListProjectsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.category)) {
      query["category"] = request.category;
    }

    if (!Util.isUnset(request.conditions)) {
      query["conditions"] = request.conditions;
    }

    if (!Util.isUnset(request.extraConditions)) {
      query["extraConditions"] = request.extraConditions;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.scope)) {
      query["scope"] = request.scope;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProjects",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/listProjects`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListProjectsResponse>(await this.callApi(params, req, runtime), new ListProjectsResponse({}));
  }

  async listProjects(organizationId: string, request: ListProjectsRequest): Promise<ListProjectsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listProjectsWithOptions(organizationId, request, headers, runtime);
  }

  async listProtectedBranchesWithOptions(repositoryId: string, request: ListProtectedBranchesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListProtectedBranchesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProtectedBranches",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/protect_branches`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListProtectedBranchesResponse>(await this.callApi(params, req, runtime), new ListProtectedBranchesResponse({}));
  }

  async listProtectedBranches(repositoryId: string, request: ListProtectedBranchesRequest): Promise<ListProtectedBranchesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listProtectedBranchesWithOptions(repositoryId, request, headers, runtime);
  }

  async listPushRulesWithOptions(repositoryId: string, request: ListPushRulesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListPushRulesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPushRules",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/push_rule/push_rules/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListPushRulesResponse>(await this.callApi(params, req, runtime), new ListPushRulesResponse({}));
  }

  async listPushRules(repositoryId: string, request: ListPushRulesRequest): Promise<ListPushRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listPushRulesWithOptions(repositoryId, request, headers, runtime);
  }

  async listRepositoriesWithOptions(request: ListRepositoriesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListRepositoriesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.archived)) {
      query["archived"] = request.archived;
    }

    if (!Util.isUnset(request.minAccessLevel)) {
      query["minAccessLevel"] = request.minAccessLevel;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["orderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.perPage)) {
      query["perPage"] = request.perPage;
    }

    if (!Util.isUnset(request.search)) {
      query["search"] = request.search;
    }

    if (!Util.isUnset(request.sort)) {
      query["sort"] = request.sort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRepositories",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListRepositoriesResponse>(await this.callApi(params, req, runtime), new ListRepositoriesResponse({}));
  }

  async listRepositories(request: ListRepositoriesRequest): Promise<ListRepositoriesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listRepositoriesWithOptions(request, headers, runtime);
  }

  async listRepositoryBranchesWithOptions(repositoryId: string, request: ListRepositoryBranchesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListRepositoryBranchesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.search)) {
      query["search"] = request.search;
    }

    if (!Util.isUnset(request.sort)) {
      query["sort"] = request.sort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRepositoryBranches",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/branches`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListRepositoryBranchesResponse>(await this.callApi(params, req, runtime), new ListRepositoryBranchesResponse({}));
  }

  async listRepositoryBranches(repositoryId: string, request: ListRepositoryBranchesRequest): Promise<ListRepositoryBranchesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listRepositoryBranchesWithOptions(repositoryId, request, headers, runtime);
  }

  async listRepositoryCommitDiffWithOptions(repositoryId: string, sha: string, request: ListRepositoryCommitDiffRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListRepositoryCommitDiffResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.contextLine)) {
      query["contextLine"] = request.contextLine;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRepositoryCommitDiff",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/commits/${OpenApiUtil.getEncodeParam(sha)}/diff`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListRepositoryCommitDiffResponse>(await this.callApi(params, req, runtime), new ListRepositoryCommitDiffResponse({}));
  }

  async listRepositoryCommitDiff(repositoryId: string, sha: string, request: ListRepositoryCommitDiffRequest): Promise<ListRepositoryCommitDiffResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listRepositoryCommitDiffWithOptions(repositoryId, sha, request, headers, runtime);
  }

  async listRepositoryCommitsWithOptions(repositoryId: string, request: ListRepositoryCommitsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListRepositoryCommitsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.end)) {
      query["end"] = request.end;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.path)) {
      query["path"] = request.path;
    }

    if (!Util.isUnset(request.refName)) {
      query["refName"] = request.refName;
    }

    if (!Util.isUnset(request.search)) {
      query["search"] = request.search;
    }

    if (!Util.isUnset(request.showCommentsCount)) {
      query["showCommentsCount"] = request.showCommentsCount;
    }

    if (!Util.isUnset(request.showSignature)) {
      query["showSignature"] = request.showSignature;
    }

    if (!Util.isUnset(request.start)) {
      query["start"] = request.start;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRepositoryCommits",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/commits`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListRepositoryCommitsResponse>(await this.callApi(params, req, runtime), new ListRepositoryCommitsResponse({}));
  }

  async listRepositoryCommits(repositoryId: string, request: ListRepositoryCommitsRequest): Promise<ListRepositoryCommitsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listRepositoryCommitsWithOptions(repositoryId, request, headers, runtime);
  }

  async listRepositoryGroupsWithOptions(request: ListRepositoryGroupsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListRepositoryGroupsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.includePersonal)) {
      query["includePersonal"] = request.includePersonal;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["orderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.parentId)) {
      query["parentId"] = request.parentId;
    }

    if (!Util.isUnset(request.search)) {
      query["search"] = request.search;
    }

    if (!Util.isUnset(request.sort)) {
      query["sort"] = request.sort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRepositoryGroups",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/groups/get/all`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListRepositoryGroupsResponse>(await this.callApi(params, req, runtime), new ListRepositoryGroupsResponse({}));
  }

  async listRepositoryGroups(request: ListRepositoryGroupsRequest): Promise<ListRepositoryGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listRepositoryGroupsWithOptions(request, headers, runtime);
  }

  async listRepositoryMemberWithInheritedWithOptions(repositoryId: string, request: ListRepositoryMemberWithInheritedRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListRepositoryMemberWithInheritedResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRepositoryMemberWithInherited",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/members/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListRepositoryMemberWithInheritedResponse>(await this.callApi(params, req, runtime), new ListRepositoryMemberWithInheritedResponse({}));
  }

  async listRepositoryMemberWithInherited(repositoryId: string, request: ListRepositoryMemberWithInheritedRequest): Promise<ListRepositoryMemberWithInheritedResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listRepositoryMemberWithInheritedWithOptions(repositoryId, request, headers, runtime);
  }

  async listRepositoryTagsWithOptions(repositoryId: string, request: ListRepositoryTagsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListRepositoryTagsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.search)) {
      query["search"] = request.search;
    }

    if (!Util.isUnset(request.sort)) {
      query["sort"] = request.sort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRepositoryTags",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/tag/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListRepositoryTagsResponse>(await this.callApi(params, req, runtime), new ListRepositoryTagsResponse({}));
  }

  async listRepositoryTags(repositoryId: string, request: ListRepositoryTagsRequest): Promise<ListRepositoryTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listRepositoryTagsWithOptions(repositoryId, request, headers, runtime);
  }

  async listRepositoryTreeWithOptions(repositoryId: string, request: ListRepositoryTreeRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListRepositoryTreeResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.path)) {
      query["path"] = request.path;
    }

    if (!Util.isUnset(request.refName)) {
      query["refName"] = request.refName;
    }

    if (!Util.isUnset(request.type)) {
      query["type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRepositoryTree",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/files/tree`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListRepositoryTreeResponse>(await this.callApi(params, req, runtime), new ListRepositoryTreeResponse({}));
  }

  async listRepositoryTree(repositoryId: string, request: ListRepositoryTreeRequest): Promise<ListRepositoryTreeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listRepositoryTreeWithOptions(repositoryId, request, headers, runtime);
  }

  async listRepositoryWebhookWithOptions(repositoryId: string, request: ListRepositoryWebhookRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListRepositoryWebhookResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRepositoryWebhook",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/webhooks/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListRepositoryWebhookResponse>(await this.callApi(params, req, runtime), new ListRepositoryWebhookResponse({}));
  }

  async listRepositoryWebhook(repositoryId: string, request: ListRepositoryWebhookRequest): Promise<ListRepositoryWebhookResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listRepositoryWebhookWithOptions(repositoryId, request, headers, runtime);
  }

  async listResourceMembersWithOptions(organizationId: string, resourceType: string, resourceId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListResourceMembersResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "ListResourceMembers",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/${OpenApiUtil.getEncodeParam(resourceType)}/${OpenApiUtil.getEncodeParam(resourceId)}/members`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListResourceMembersResponse>(await this.callApi(params, req, runtime), new ListResourceMembersResponse({}));
  }

  async listResourceMembers(organizationId: string, resourceType: string, resourceId: string): Promise<ListResourceMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listResourceMembersWithOptions(organizationId, resourceType, resourceId, headers, runtime);
  }

  async listSearchCommitWithOptions(request: ListSearchCommitRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListSearchCommitResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.keyword)) {
      body["keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.order)) {
      body["order"] = request.order;
    }

    if (!Util.isUnset(request.page)) {
      body["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.repoPath)) {
      body["repoPath"] = request.repoPath;
    }

    if (!Util.isUnset(request.scope)) {
      body["scope"] = request.scope;
    }

    if (!Util.isUnset(request.sort)) {
      body["sort"] = request.sort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListSearchCommit",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/search/commit`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListSearchCommitResponse>(await this.callApi(params, req, runtime), new ListSearchCommitResponse({}));
  }

  async listSearchCommit(request: ListSearchCommitRequest): Promise<ListSearchCommitResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listSearchCommitWithOptions(request, headers, runtime);
  }

  async listSearchRepositoryWithOptions(request: ListSearchRepositoryRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListSearchRepositoryResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.aliyunPk)) {
      body["aliyunPk"] = request.aliyunPk;
    }

    if (!Util.isUnset(request.keyword)) {
      body["keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.order)) {
      body["order"] = request.order;
    }

    if (!Util.isUnset(request.page)) {
      body["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.repoPath)) {
      body["repoPath"] = request.repoPath;
    }

    if (!Util.isUnset(request.scope)) {
      body["scope"] = request.scope;
    }

    if (!Util.isUnset(request.sort)) {
      body["sort"] = request.sort;
    }

    if (!Util.isUnset(request.visibilityLevel)) {
      body["visibilityLevel"] = request.visibilityLevel;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListSearchRepository",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/search/repo`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListSearchRepositoryResponse>(await this.callApi(params, req, runtime), new ListSearchRepositoryResponse({}));
  }

  async listSearchRepository(request: ListSearchRepositoryRequest): Promise<ListSearchRepositoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listSearchRepositoryWithOptions(request, headers, runtime);
  }

  async listSearchSourceCodeWithOptions(request: ListSearchSourceCodeRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListSearchSourceCodeResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.filePath)) {
      body["filePath"] = request.filePath;
    }

    if (!Util.isUnset(request.isCodeBlock)) {
      body["isCodeBlock"] = request.isCodeBlock;
    }

    if (!Util.isUnset(request.keyword)) {
      body["keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.language)) {
      body["language"] = request.language;
    }

    if (!Util.isUnset(request.order)) {
      body["order"] = request.order;
    }

    if (!Util.isUnset(request.page)) {
      body["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.repoPath)) {
      body["repoPath"] = request.repoPath;
    }

    if (!Util.isUnset(request.scope)) {
      body["scope"] = request.scope;
    }

    if (!Util.isUnset(request.sort)) {
      body["sort"] = request.sort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListSearchSourceCode",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/search/code`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListSearchSourceCodeResponse>(await this.callApi(params, req, runtime), new ListSearchSourceCodeResponse({}));
  }

  async listSearchSourceCode(request: ListSearchSourceCodeRequest): Promise<ListSearchSourceCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listSearchSourceCodeWithOptions(request, headers, runtime);
  }

  async listServiceAuthsWithOptions(organizationId: string, request: ListServiceAuthsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListServiceAuthsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.serviceAuthType)) {
      query["serviceAuthType"] = request.serviceAuthType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListServiceAuths",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/serviceAuths`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListServiceAuthsResponse>(await this.callApi(params, req, runtime), new ListServiceAuthsResponse({}));
  }

  async listServiceAuths(organizationId: string, request: ListServiceAuthsRequest): Promise<ListServiceAuthsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listServiceAuthsWithOptions(organizationId, request, headers, runtime);
  }

  async listServiceConnectionsWithOptions(organizationId: string, request: ListServiceConnectionsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListServiceConnectionsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.sericeConnectionType)) {
      query["sericeConnectionType"] = request.sericeConnectionType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListServiceConnections",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/serviceConnections`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListServiceConnectionsResponse>(await this.callApi(params, req, runtime), new ListServiceConnectionsResponse({}));
  }

  async listServiceConnections(organizationId: string, request: ListServiceConnectionsRequest): Promise<ListServiceConnectionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listServiceConnectionsWithOptions(organizationId, request, headers, runtime);
  }

  async listServiceCredentialsWithOptions(organizationId: string, request: ListServiceCredentialsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListServiceCredentialsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.serviceCredentialType)) {
      query["serviceCredentialType"] = request.serviceCredentialType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListServiceCredentials",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/serviceCredentials`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListServiceCredentialsResponse>(await this.callApi(params, req, runtime), new ListServiceCredentialsResponse({}));
  }

  async listServiceCredentials(organizationId: string, request: ListServiceCredentialsRequest): Promise<ListServiceCredentialsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listServiceCredentialsWithOptions(organizationId, request, headers, runtime);
  }

  async listSprintsWithOptions(organizationId: string, request: ListSprintsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListSprintsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.spaceIdentifier)) {
      query["spaceIdentifier"] = request.spaceIdentifier;
    }

    if (!Util.isUnset(request.spaceType)) {
      query["spaceType"] = request.spaceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSprints",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/sprints/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListSprintsResponse>(await this.callApi(params, req, runtime), new ListSprintsResponse({}));
  }

  async listSprints(organizationId: string, request: ListSprintsRequest): Promise<ListSprintsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listSprintsWithOptions(organizationId, request, headers, runtime);
  }

  async listTestCaseFieldsWithOptions(organizationId: string, request: ListTestCaseFieldsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListTestCaseFieldsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.spaceIdentifier)) {
      query["spaceIdentifier"] = request.spaceIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTestCaseFields",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/testhub/testcase/fields`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListTestCaseFieldsResponse>(await this.callApi(params, req, runtime), new ListTestCaseFieldsResponse({}));
  }

  async listTestCaseFields(organizationId: string, request: ListTestCaseFieldsRequest): Promise<ListTestCaseFieldsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listTestCaseFieldsWithOptions(organizationId, request, headers, runtime);
  }

  async listUserDrawRecordByPkWithOptions(request: ListUserDrawRecordByPkRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListUserDrawRecordByPkResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.aliyunPk)) {
      query["aliyunPk"] = request.aliyunPk;
    }

    if (!Util.isUnset(request.drawGroup)) {
      query["drawGroup"] = request.drawGroup;
    }

    if (!Util.isUnset(request.drawPoolName)) {
      query["drawPoolName"] = request.drawPoolName;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListUserDrawRecordByPk",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/listUserDrawRecords`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListUserDrawRecordByPkResponse>(await this.callApi(params, req, runtime), new ListUserDrawRecordByPkResponse({}));
  }

  async listUserDrawRecordByPk(request: ListUserDrawRecordByPkRequest): Promise<ListUserDrawRecordByPkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listUserDrawRecordByPkWithOptions(request, headers, runtime);
  }

  async listUserKeysWithOptions(request: ListUserKeysRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListUserKeysResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["orderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.sort)) {
      query["sort"] = request.sort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListUserKeys",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v3/user/keys`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListUserKeysResponse>(await this.callApi(params, req, runtime), new ListUserKeysResponse({}));
  }

  async listUserKeys(request: ListUserKeysRequest): Promise<ListUserKeysResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listUserKeysWithOptions(request, headers, runtime);
  }

  async listUserResourcesWithOptions(request: ListUserResourcesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListUserResourcesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.userIds)) {
      query["userIds"] = request.userIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListUserResources",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/user/vision/user_resources`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListUserResourcesResponse>(await this.callApi(params, req, runtime), new ListUserResourcesResponse({}));
  }

  async listUserResources(request: ListUserResourcesRequest): Promise<ListUserResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listUserResourcesWithOptions(request, headers, runtime);
  }

  async listVariableGroupsWithOptions(organizationId: string, request: ListVariableGroupsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListVariableGroupsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.pageOrder)) {
      query["pageOrder"] = request.pageOrder;
    }

    if (!Util.isUnset(request.pageSort)) {
      query["pageSort"] = request.pageSort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListVariableGroups",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/variableGroups`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListVariableGroupsResponse>(await this.callApi(params, req, runtime), new ListVariableGroupsResponse({}));
  }

  async listVariableGroups(organizationId: string, request: ListVariableGroupsRequest): Promise<ListVariableGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listVariableGroupsWithOptions(organizationId, request, headers, runtime);
  }

  async listWorkItemAllFieldsWithOptions(organizationId: string, request: ListWorkItemAllFieldsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListWorkItemAllFieldsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.spaceIdentifier)) {
      query["spaceIdentifier"] = request.spaceIdentifier;
    }

    if (!Util.isUnset(request.spaceType)) {
      query["spaceType"] = request.spaceType;
    }

    if (!Util.isUnset(request.workitemTypeIdentifier)) {
      query["workitemTypeIdentifier"] = request.workitemTypeIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListWorkItemAllFields",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/fields/listAll`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListWorkItemAllFieldsResponse>(await this.callApi(params, req, runtime), new ListWorkItemAllFieldsResponse({}));
  }

  async listWorkItemAllFields(organizationId: string, request: ListWorkItemAllFieldsRequest): Promise<ListWorkItemAllFieldsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listWorkItemAllFieldsWithOptions(organizationId, request, headers, runtime);
  }

  async listWorkItemWorkFlowStatusWithOptions(organizationId: string, request: ListWorkItemWorkFlowStatusRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListWorkItemWorkFlowStatusResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.spaceIdentifier)) {
      query["spaceIdentifier"] = request.spaceIdentifier;
    }

    if (!Util.isUnset(request.spaceType)) {
      query["spaceType"] = request.spaceType;
    }

    if (!Util.isUnset(request.workitemCategoryIdentifier)) {
      query["workitemCategoryIdentifier"] = request.workitemCategoryIdentifier;
    }

    if (!Util.isUnset(request.workitemTypeIdentifier)) {
      query["workitemTypeIdentifier"] = request.workitemTypeIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListWorkItemWorkFlowStatus",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/workflow/listWorkflowStatus`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListWorkItemWorkFlowStatusResponse>(await this.callApi(params, req, runtime), new ListWorkItemWorkFlowStatusResponse({}));
  }

  async listWorkItemWorkFlowStatus(organizationId: string, request: ListWorkItemWorkFlowStatusRequest): Promise<ListWorkItemWorkFlowStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listWorkItemWorkFlowStatusWithOptions(organizationId, request, headers, runtime);
  }

  async listWorkitemAttachmentsWithOptions(organizationId: string, workitemIdentifier: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListWorkitemAttachmentsResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "ListWorkitemAttachments",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitem/${OpenApiUtil.getEncodeParam(workitemIdentifier)}/attachments`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListWorkitemAttachmentsResponse>(await this.callApi(params, req, runtime), new ListWorkitemAttachmentsResponse({}));
  }

  async listWorkitemAttachments(organizationId: string, workitemIdentifier: string): Promise<ListWorkitemAttachmentsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listWorkitemAttachmentsWithOptions(organizationId, workitemIdentifier, headers, runtime);
  }

  async listWorkitemEstimateWithOptions(organizationId: string, workitemId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListWorkitemEstimateResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "ListWorkitemEstimate",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/${OpenApiUtil.getEncodeParam(workitemId)}/estimate/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListWorkitemEstimateResponse>(await this.callApi(params, req, runtime), new ListWorkitemEstimateResponse({}));
  }

  async listWorkitemEstimate(organizationId: string, workitemId: string): Promise<ListWorkitemEstimateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listWorkitemEstimateWithOptions(organizationId, workitemId, headers, runtime);
  }

  async listWorkitemTimeWithOptions(organizationId: string, workitemId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListWorkitemTimeResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "ListWorkitemTime",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/${OpenApiUtil.getEncodeParam(workitemId)}/time/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListWorkitemTimeResponse>(await this.callApi(params, req, runtime), new ListWorkitemTimeResponse({}));
  }

  async listWorkitemTime(organizationId: string, workitemId: string): Promise<ListWorkitemTimeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listWorkitemTimeWithOptions(organizationId, workitemId, headers, runtime);
  }

  async listWorkitemsWithOptions(organizationId: string, request: ListWorkitemsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListWorkitemsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.category)) {
      query["category"] = request.category;
    }

    if (!Util.isUnset(request.conditions)) {
      query["conditions"] = request.conditions;
    }

    if (!Util.isUnset(request.extraConditions)) {
      query["extraConditions"] = request.extraConditions;
    }

    if (!Util.isUnset(request.groupCondition)) {
      query["groupCondition"] = request.groupCondition;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["orderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.searchType)) {
      query["searchType"] = request.searchType;
    }

    if (!Util.isUnset(request.spaceIdentifier)) {
      query["spaceIdentifier"] = request.spaceIdentifier;
    }

    if (!Util.isUnset(request.spaceType)) {
      query["spaceType"] = request.spaceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListWorkitems",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/listWorkitems`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListWorkitemsResponse>(await this.callApi(params, req, runtime), new ListWorkitemsResponse({}));
  }

  async listWorkitems(organizationId: string, request: ListWorkitemsRequest): Promise<ListWorkitemsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listWorkitemsWithOptions(organizationId, request, headers, runtime);
  }

  async listWorkspacesWithOptions(tmpReq: ListWorkspacesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListWorkspacesResponse> {
    Util.validateModel(tmpReq);
    let request = new ListWorkspacesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.statusList)) {
      request.statusListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.statusList, "statusList", "simple");
    }

    if (!Util.isUnset(tmpReq.workspaceTemplateList)) {
      request.workspaceTemplateListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.workspaceTemplateList, "workspaceTemplateList", "simple");
    }

    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.statusListShrink)) {
      query["statusList"] = request.statusListShrink;
    }

    if (!Util.isUnset(request.workspaceTemplateListShrink)) {
      query["workspaceTemplateList"] = request.workspaceTemplateListShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListWorkspaces",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/workspaces`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListWorkspacesResponse>(await this.callApi(params, req, runtime), new ListWorkspacesResponse({}));
  }

  async listWorkspaces(request: ListWorkspacesRequest): Promise<ListWorkspacesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listWorkspacesWithOptions(request, headers, runtime);
  }

  async logPipelineJobRunWithOptions(organizationId: string, pipelineId: string, jobId: string, pipelineRunId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<LogPipelineJobRunResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "LogPipelineJobRun",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipeline/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRun/${OpenApiUtil.getEncodeParam(pipelineRunId)}/job/${OpenApiUtil.getEncodeParam(jobId)}/logs`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<LogPipelineJobRunResponse>(await this.callApi(params, req, runtime), new LogPipelineJobRunResponse({}));
  }

  async logPipelineJobRun(organizationId: string, pipelineId: string, jobId: string, pipelineRunId: string): Promise<LogPipelineJobRunResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.logPipelineJobRunWithOptions(organizationId, pipelineId, jobId, pipelineRunId, headers, runtime);
  }

  async logVMDeployMachineWithOptions(organizationId: string, pipelineId: string, deployOrderId: string, machineSn: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<LogVMDeployMachineResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "LogVMDeployMachine",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/deploy/${OpenApiUtil.getEncodeParam(deployOrderId)}/machine/${OpenApiUtil.getEncodeParam(machineSn)}/log`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<LogVMDeployMachineResponse>(await this.callApi(params, req, runtime), new LogVMDeployMachineResponse({}));
  }

  async logVMDeployMachine(organizationId: string, pipelineId: string, deployOrderId: string, machineSn: string): Promise<LogVMDeployMachineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.logVMDeployMachineWithOptions(organizationId, pipelineId, deployOrderId, machineSn, headers, runtime);
  }

  async mergeMergeRequestWithOptions(repositoryId: string, localId: string, request: MergeMergeRequestRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<MergeMergeRequestResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.mergeMessage)) {
      body["mergeMessage"] = request.mergeMessage;
    }

    if (!Util.isUnset(request.mergeType)) {
      body["mergeType"] = request.mergeType;
    }

    if (!Util.isUnset(request.removeSourceBranch)) {
      body["removeSourceBranch"] = request.removeSourceBranch;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "MergeMergeRequest",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/merge_requests/${OpenApiUtil.getEncodeParam(localId)}/merge`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<MergeMergeRequestResponse>(await this.callApi(params, req, runtime), new MergeMergeRequestResponse({}));
  }

  async mergeMergeRequest(repositoryId: string, localId: string, request: MergeMergeRequestRequest): Promise<MergeMergeRequestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.mergeMergeRequestWithOptions(repositoryId, localId, request, headers, runtime);
  }

  async passPipelineValidateWithOptions(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<PassPipelineValidateResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "PassPipelineValidate",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRuns/${OpenApiUtil.getEncodeParam(pipelineRunId)}/jobs/${OpenApiUtil.getEncodeParam(jobId)}/pass`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<PassPipelineValidateResponse>(await this.callApi(params, req, runtime), new PassPipelineValidateResponse({}));
  }

  async passPipelineValidate(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string): Promise<PassPipelineValidateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.passPipelineValidateWithOptions(organizationId, pipelineId, pipelineRunId, jobId, headers, runtime);
  }

  async refusePipelineValidateWithOptions(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<RefusePipelineValidateResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "RefusePipelineValidate",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRuns/${OpenApiUtil.getEncodeParam(pipelineRunId)}/jobs/${OpenApiUtil.getEncodeParam(jobId)}/refuse`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<RefusePipelineValidateResponse>(await this.callApi(params, req, runtime), new RefusePipelineValidateResponse({}));
  }

  async refusePipelineValidate(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string): Promise<RefusePipelineValidateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.refusePipelineValidateWithOptions(organizationId, pipelineId, pipelineRunId, jobId, headers, runtime);
  }

  async releaseWorkspaceWithOptions(workspaceId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ReleaseWorkspaceResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "ReleaseWorkspace",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/workspaces/${OpenApiUtil.getEncodeParam(workspaceId)}/release`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ReleaseWorkspaceResponse>(await this.callApi(params, req, runtime), new ReleaseWorkspaceResponse({}));
  }

  async releaseWorkspace(workspaceId: string): Promise<ReleaseWorkspaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.releaseWorkspaceWithOptions(workspaceId, headers, runtime);
  }

  async reopenMergeRequestWithOptions(repositoryId: string, localId: string, request: ReopenMergeRequestRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ReopenMergeRequestResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ReopenMergeRequest",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/merge_requests/${OpenApiUtil.getEncodeParam(localId)}/reopen`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ReopenMergeRequestResponse>(await this.callApi(params, req, runtime), new ReopenMergeRequestResponse({}));
  }

  async reopenMergeRequest(repositoryId: string, localId: string, request: ReopenMergeRequestRequest): Promise<ReopenMergeRequestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.reopenMergeRequestWithOptions(repositoryId, localId, request, headers, runtime);
  }

  async resetSshKeyWithOptions(organizationId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ResetSshKeyResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "ResetSshKey",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/sshKey`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ResetSshKeyResponse>(await this.callApi(params, req, runtime), new ResetSshKeyResponse({}));
  }

  async resetSshKey(organizationId: string): Promise<ResetSshKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.resetSshKeyWithOptions(organizationId, headers, runtime);
  }

  async resumeVMDeployOrderWithOptions(organizationId: string, pipelineId: string, deployOrderId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ResumeVMDeployOrderResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "ResumeVMDeployOrder",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/deploy/${OpenApiUtil.getEncodeParam(deployOrderId)}/resume`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ResumeVMDeployOrderResponse>(await this.callApi(params, req, runtime), new ResumeVMDeployOrderResponse({}));
  }

  async resumeVMDeployOrder(organizationId: string, pipelineId: string, deployOrderId: string): Promise<ResumeVMDeployOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.resumeVMDeployOrderWithOptions(organizationId, pipelineId, deployOrderId, headers, runtime);
  }

  async retryPipelineJobRunWithOptions(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<RetryPipelineJobRunResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "RetryPipelineJobRun",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRuns/${OpenApiUtil.getEncodeParam(pipelineRunId)}/jobs/${OpenApiUtil.getEncodeParam(jobId)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<RetryPipelineJobRunResponse>(await this.callApi(params, req, runtime), new RetryPipelineJobRunResponse({}));
  }

  async retryPipelineJobRun(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string): Promise<RetryPipelineJobRunResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.retryPipelineJobRunWithOptions(organizationId, pipelineId, pipelineRunId, jobId, headers, runtime);
  }

  async retryVMDeployMachineWithOptions(organizationId: string, pipelineId: string, deployOrderId: string, machineSn: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<RetryVMDeployMachineResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "RetryVMDeployMachine",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/deploy/${OpenApiUtil.getEncodeParam(deployOrderId)}/machine/${OpenApiUtil.getEncodeParam(machineSn)}/retry`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<RetryVMDeployMachineResponse>(await this.callApi(params, req, runtime), new RetryVMDeployMachineResponse({}));
  }

  async retryVMDeployMachine(organizationId: string, pipelineId: string, deployOrderId: string, machineSn: string): Promise<RetryVMDeployMachineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.retryVMDeployMachineWithOptions(organizationId, pipelineId, deployOrderId, machineSn, headers, runtime);
  }

  async reviewMergeRequestWithOptions(repositoryId: string, localId: string, request: ReviewMergeRequestRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ReviewMergeRequestResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.draftCommentIds)) {
      body["draftCommentIds"] = request.draftCommentIds;
    }

    if (!Util.isUnset(request.reviewComment)) {
      body["reviewComment"] = request.reviewComment;
    }

    if (!Util.isUnset(request.reviewOpinion)) {
      body["reviewOpinion"] = request.reviewOpinion;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ReviewMergeRequest",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/merge_requests/${OpenApiUtil.getEncodeParam(localId)}/submit_review_opinion`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ReviewMergeRequestResponse>(await this.callApi(params, req, runtime), new ReviewMergeRequestResponse({}));
  }

  async reviewMergeRequest(repositoryId: string, localId: string, request: ReviewMergeRequestRequest): Promise<ReviewMergeRequestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.reviewMergeRequestWithOptions(repositoryId, localId, request, headers, runtime);
  }

  async skipPipelineJobRunWithOptions(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<SkipPipelineJobRunResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "SkipPipelineJobRun",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRuns/${OpenApiUtil.getEncodeParam(pipelineRunId)}/jobs/${OpenApiUtil.getEncodeParam(jobId)}/skip`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<SkipPipelineJobRunResponse>(await this.callApi(params, req, runtime), new SkipPipelineJobRunResponse({}));
  }

  async skipPipelineJobRun(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string): Promise<SkipPipelineJobRunResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.skipPipelineJobRunWithOptions(organizationId, pipelineId, pipelineRunId, jobId, headers, runtime);
  }

  async skipVMDeployMachineWithOptions(organizationId: string, pipelineId: string, deployOrderId: string, machineSn: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<SkipVMDeployMachineResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "SkipVMDeployMachine",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/deploy/${OpenApiUtil.getEncodeParam(deployOrderId)}/machine/${OpenApiUtil.getEncodeParam(machineSn)}/skip`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<SkipVMDeployMachineResponse>(await this.callApi(params, req, runtime), new SkipVMDeployMachineResponse({}));
  }

  async skipVMDeployMachine(organizationId: string, pipelineId: string, deployOrderId: string, machineSn: string): Promise<SkipVMDeployMachineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.skipVMDeployMachineWithOptions(organizationId, pipelineId, deployOrderId, machineSn, headers, runtime);
  }

  async startPipelineRunWithOptions(organizationId: string, pipelineId: string, request: StartPipelineRunRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<StartPipelineRunResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.params)) {
      body["params"] = request.params;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "StartPipelineRun",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organizations/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/run`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartPipelineRunResponse>(await this.callApi(params, req, runtime), new StartPipelineRunResponse({}));
  }

  async startPipelineRun(organizationId: string, pipelineId: string, request: StartPipelineRunRequest): Promise<StartPipelineRunResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.startPipelineRunWithOptions(organizationId, pipelineId, request, headers, runtime);
  }

  async stopPipelineJobRunWithOptions(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<StopPipelineJobRunResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "StopPipelineJobRun",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRuns/${OpenApiUtil.getEncodeParam(pipelineRunId)}/jobs/${OpenApiUtil.getEncodeParam(jobId)}/stop`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<StopPipelineJobRunResponse>(await this.callApi(params, req, runtime), new StopPipelineJobRunResponse({}));
  }

  async stopPipelineJobRun(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string): Promise<StopPipelineJobRunResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.stopPipelineJobRunWithOptions(organizationId, pipelineId, pipelineRunId, jobId, headers, runtime);
  }

  async stopPipelineRunWithOptions(organizationId: string, pipelineId: string, pipelineRunId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<StopPipelineRunResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "StopPipelineRun",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRuns/${OpenApiUtil.getEncodeParam(pipelineRunId)}/stop`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<StopPipelineRunResponse>(await this.callApi(params, req, runtime), new StopPipelineRunResponse({}));
  }

  async stopPipelineRun(organizationId: string, pipelineId: string, pipelineRunId: string): Promise<StopPipelineRunResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.stopPipelineRunWithOptions(organizationId, pipelineId, pipelineRunId, headers, runtime);
  }

  async stopVMDeployOrderWithOptions(organizationId: string, pipelineId: string, deployOrderId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<StopVMDeployOrderResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "StopVMDeployOrder",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/deploy/${OpenApiUtil.getEncodeParam(deployOrderId)}/stop`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<StopVMDeployOrderResponse>(await this.callApi(params, req, runtime), new StopVMDeployOrderResponse({}));
  }

  async stopVMDeployOrder(organizationId: string, pipelineId: string, deployOrderId: string): Promise<StopVMDeployOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.stopVMDeployOrderWithOptions(organizationId, pipelineId, deployOrderId, headers, runtime);
  }

  async transferRepositoryWithOptions(request: TransferRepositoryRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<TransferRepositoryResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.groupId)) {
      query["groupId"] = request.groupId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryId)) {
      query["repositoryId"] = request.repositoryId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "TransferRepository",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/repository/transfer`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<TransferRepositoryResponse>(await this.callApi(params, req, runtime), new TransferRepositoryResponse({}));
  }

  async transferRepository(request: TransferRepositoryRequest): Promise<TransferRepositoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.transferRepositoryWithOptions(request, headers, runtime);
  }

  async triggerRepositoryMirrorSyncWithOptions(repositoryId: string, request: TriggerRepositoryMirrorSyncRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<TriggerRepositoryMirrorSyncResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.account)) {
      query["account"] = request.account;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.token)) {
      query["token"] = request.token;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "TriggerRepositoryMirrorSync",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/mirror`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<TriggerRepositoryMirrorSyncResponse>(await this.callApi(params, req, runtime), new TriggerRepositoryMirrorSyncResponse({}));
  }

  async triggerRepositoryMirrorSync(repositoryId: string, request: TriggerRepositoryMirrorSyncRequest): Promise<TriggerRepositoryMirrorSyncResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.triggerRepositoryMirrorSyncWithOptions(repositoryId, request, headers, runtime);
  }

  async updateAppMemberWithOptions(appName: string, request: UpdateAppMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateAppMemberResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.player)) {
      body["player"] = request.player;
    }

    if (!Util.isUnset(request.roleNames)) {
      body["roleNames"] = request.roleNames;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateAppMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}/members`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "string",
    });
    return $tea.cast<UpdateAppMemberResponse>(await this.callApi(params, req, runtime), new UpdateAppMemberResponse({}));
  }

  async updateAppMember(appName: string, request: UpdateAppMemberRequest): Promise<UpdateAppMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateAppMemberWithOptions(appName, request, headers, runtime);
  }

  async updateApplicationWithOptions(appName: string, request: UpdateApplicationRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateApplicationResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.ownerAccountId)) {
      body["ownerAccountId"] = request.ownerAccountId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateApplication",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateApplicationResponse>(await this.callApi(params, req, runtime), new UpdateApplicationResponse({}));
  }

  async updateApplication(appName: string, request: UpdateApplicationRequest): Promise<UpdateApplicationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateApplicationWithOptions(appName, request, headers, runtime);
  }

  async updateCheckRunWithOptions(request: UpdateCheckRunRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateCheckRunResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.checkRunId)) {
      query["checkRunId"] = request.checkRunId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.annotations)) {
      body["annotations"] = request.annotations;
    }

    if (!Util.isUnset(request.completedAt)) {
      body["completedAt"] = request.completedAt;
    }

    if (!Util.isUnset(request.conclusion)) {
      body["conclusion"] = request.conclusion;
    }

    if (!Util.isUnset(request.detailsUrl)) {
      body["detailsUrl"] = request.detailsUrl;
    }

    if (!Util.isUnset(request.externalId)) {
      body["externalId"] = request.externalId;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.output)) {
      body["output"] = request.output;
    }

    if (!Util.isUnset(request.startedAt)) {
      body["startedAt"] = request.startedAt;
    }

    if (!Util.isUnset(request.status)) {
      body["status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCheckRun",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/check_runs/update_check_run`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateCheckRunResponse>(await this.callApi(params, req, runtime), new UpdateCheckRunResponse({}));
  }

  async updateCheckRun(request: UpdateCheckRunRequest): Promise<UpdateCheckRunResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateCheckRunWithOptions(request, headers, runtime);
  }

  async updateFileWithOptions(repositoryId: string, request: UpdateFileRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateFileResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.branchName)) {
      body["branchName"] = request.branchName;
    }

    if (!Util.isUnset(request.commitMessage)) {
      body["commitMessage"] = request.commitMessage;
    }

    if (!Util.isUnset(request.content)) {
      body["content"] = request.content;
    }

    if (!Util.isUnset(request.encoding)) {
      body["encoding"] = request.encoding;
    }

    if (!Util.isUnset(request.newPath)) {
      body["newPath"] = request.newPath;
    }

    if (!Util.isUnset(request.oldPath)) {
      body["oldPath"] = request.oldPath;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateFile",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/files/update`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateFileResponse>(await this.callApi(params, req, runtime), new UpdateFileResponse({}));
  }

  async updateFile(repositoryId: string, request: UpdateFileRequest): Promise<UpdateFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateFileWithOptions(repositoryId, request, headers, runtime);
  }

  async updateFlowTagWithOptions(organizationId: string, id: string, request: UpdateFlowTagRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateFlowTagResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.color)) {
      query["color"] = request.color;
    }

    if (!Util.isUnset(request.flowTagGroupId)) {
      query["flowTagGroupId"] = request.flowTagGroupId;
    }

    if (!Util.isUnset(request.name)) {
      query["name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateFlowTag",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/flow/tags/${OpenApiUtil.getEncodeParam(id)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateFlowTagResponse>(await this.callApi(params, req, runtime), new UpdateFlowTagResponse({}));
  }

  async updateFlowTag(organizationId: string, id: string, request: UpdateFlowTagRequest): Promise<UpdateFlowTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateFlowTagWithOptions(organizationId, id, request, headers, runtime);
  }

  async updateFlowTagGroupWithOptions(organizationId: string, id: string, request: UpdateFlowTagGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateFlowTagGroupResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      query["name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateFlowTagGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/flow/tagGroups/${OpenApiUtil.getEncodeParam(id)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateFlowTagGroupResponse>(await this.callApi(params, req, runtime), new UpdateFlowTagGroupResponse({}));
  }

  async updateFlowTagGroup(organizationId: string, id: string, request: UpdateFlowTagGroupRequest): Promise<UpdateFlowTagGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateFlowTagGroupWithOptions(organizationId, id, request, headers, runtime);
  }

  async updateGroupWithOptions(request: UpdateGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateGroupResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.avatarUrl)) {
      body["avatarUrl"] = request.avatarUrl;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.path)) {
      body["path"] = request.path;
    }

    if (!Util.isUnset(request.pathWithNamespace)) {
      body["pathWithNamespace"] = request.pathWithNamespace;
    }

    if (!Util.isUnset(request.visibilityLevel)) {
      body["visibilityLevel"] = request.visibilityLevel;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/groups/modify`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateGroupResponse>(await this.callApi(params, req, runtime), new UpdateGroupResponse({}));
  }

  async updateGroup(request: UpdateGroupRequest): Promise<UpdateGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateGroupWithOptions(request, headers, runtime);
  }

  async updateGroupMemberWithOptions(groupId: string, request: UpdateGroupMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateGroupMemberResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.aliyunPk)) {
      query["aliyunPk"] = request.aliyunPk;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessLevel)) {
      body["accessLevel"] = request.accessLevel;
    }

    if (!Util.isUnset(request.memberType)) {
      body["memberType"] = request.memberType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGroupMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/groups/${OpenApiUtil.getEncodeParam(groupId)}/members/update/aliyun_pk`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateGroupMemberResponse>(await this.callApi(params, req, runtime), new UpdateGroupMemberResponse({}));
  }

  async updateGroupMember(groupId: string, request: UpdateGroupMemberRequest): Promise<UpdateGroupMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateGroupMemberWithOptions(groupId, request, headers, runtime);
  }

  async updateHostGroupWithOptions(organizationId: string, id: string, request: UpdateHostGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateHostGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.aliyunRegion)) {
      body["aliyunRegion"] = request.aliyunRegion;
    }

    if (!Util.isUnset(request.ecsLabelKey)) {
      body["ecsLabelKey"] = request.ecsLabelKey;
    }

    if (!Util.isUnset(request.ecsLabelValue)) {
      body["ecsLabelValue"] = request.ecsLabelValue;
    }

    if (!Util.isUnset(request.ecsType)) {
      body["ecsType"] = request.ecsType;
    }

    if (!Util.isUnset(request.envId)) {
      body["envId"] = request.envId;
    }

    if (!Util.isUnset(request.machineInfos)) {
      body["machineInfos"] = request.machineInfos;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.serviceConnectionId)) {
      body["serviceConnectionId"] = request.serviceConnectionId;
    }

    if (!Util.isUnset(request.tagIds)) {
      body["tagIds"] = request.tagIds;
    }

    if (!Util.isUnset(request.type)) {
      body["type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateHostGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/hostGroups/${OpenApiUtil.getEncodeParam(id)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateHostGroupResponse>(await this.callApi(params, req, runtime), new UpdateHostGroupResponse({}));
  }

  async updateHostGroup(organizationId: string, id: string, request: UpdateHostGroupRequest): Promise<UpdateHostGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateHostGroupWithOptions(organizationId, id, request, headers, runtime);
  }

  async updateMergeRequestWithOptions(repositoryId: string, localId: string, request: UpdateMergeRequestRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateMergeRequestResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.title)) {
      body["title"] = request.title;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateMergeRequest",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/merge_requests/${OpenApiUtil.getEncodeParam(localId)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateMergeRequestResponse>(await this.callApi(params, req, runtime), new UpdateMergeRequestResponse({}));
  }

  async updateMergeRequest(repositoryId: string, localId: string, request: UpdateMergeRequestRequest): Promise<UpdateMergeRequestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateMergeRequestWithOptions(repositoryId, localId, request, headers, runtime);
  }

  async updateMergeRequestPersonnelWithOptions(repositoryId: string, localId: string, personType: string, request: UpdateMergeRequestPersonnelRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateMergeRequestPersonnelResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.newUserIdList)) {
      body["newUserIdList"] = request.newUserIdList;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateMergeRequestPersonnel",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/merge_requests/${OpenApiUtil.getEncodeParam(localId)}/person/${OpenApiUtil.getEncodeParam(personType)}`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateMergeRequestPersonnelResponse>(await this.callApi(params, req, runtime), new UpdateMergeRequestPersonnelResponse({}));
  }

  async updateMergeRequestPersonnel(repositoryId: string, localId: string, personType: string, request: UpdateMergeRequestPersonnelRequest): Promise<UpdateMergeRequestPersonnelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateMergeRequestPersonnelWithOptions(repositoryId, localId, personType, request, headers, runtime);
  }

  async updatePipelineWithOptions(organizationId: string, request: UpdatePipelineRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdatePipelineResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.content)) {
      body["content"] = request.content;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.pipelineId)) {
      body["pipelineId"] = request.pipelineId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdatePipeline",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/update`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdatePipelineResponse>(await this.callApi(params, req, runtime), new UpdatePipelineResponse({}));
  }

  async updatePipeline(organizationId: string, request: UpdatePipelineRequest): Promise<UpdatePipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updatePipelineWithOptions(organizationId, request, headers, runtime);
  }

  async updatePipelineBaseInfoWithOptions(organizationId: string, pipelineId: string, request: UpdatePipelineBaseInfoRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdatePipelineBaseInfoResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.envId)) {
      query["envId"] = request.envId;
    }

    if (!Util.isUnset(request.pipelineName)) {
      query["pipelineName"] = request.pipelineName;
    }

    if (!Util.isUnset(request.tagList)) {
      query["tagList"] = request.tagList;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdatePipelineBaseInfo",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/baseInfo`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdatePipelineBaseInfoResponse>(await this.callApi(params, req, runtime), new UpdatePipelineBaseInfoResponse({}));
  }

  async updatePipelineBaseInfo(organizationId: string, pipelineId: string, request: UpdatePipelineBaseInfoRequest): Promise<UpdatePipelineBaseInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updatePipelineBaseInfoWithOptions(organizationId, pipelineId, request, headers, runtime);
  }

  async updatePipelineGroupWithOptions(organizationId: string, groupId: string, request: UpdatePipelineGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdatePipelineGroupResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      query["name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdatePipelineGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelineGroups/${OpenApiUtil.getEncodeParam(groupId)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdatePipelineGroupResponse>(await this.callApi(params, req, runtime), new UpdatePipelineGroupResponse({}));
  }

  async updatePipelineGroup(organizationId: string, groupId: string, request: UpdatePipelineGroupRequest): Promise<UpdatePipelineGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updatePipelineGroupWithOptions(organizationId, groupId, request, headers, runtime);
  }

  async updateProjectFieldWithOptions(organizationId: string, identifier: string, request: UpdateProjectFieldRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateProjectFieldResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.statusIdentifier)) {
      body["statusIdentifier"] = request.statusIdentifier;
    }

    if (!Util.isUnset(request.updateBasicFieldRequestList)) {
      body["updateBasicFieldRequestList"] = request.updateBasicFieldRequestList;
    }

    if (!Util.isUnset(request.updateForOpenApiList)) {
      body["updateForOpenApiList"] = request.updateForOpenApiList;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateProjectField",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/project/${OpenApiUtil.getEncodeParam(identifier)}`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateProjectFieldResponse>(await this.callApi(params, req, runtime), new UpdateProjectFieldResponse({}));
  }

  async updateProjectField(organizationId: string, identifier: string, request: UpdateProjectFieldRequest): Promise<UpdateProjectFieldResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateProjectFieldWithOptions(organizationId, identifier, request, headers, runtime);
  }

  async updateProjectLabelWithOptions(labelId: string, request: UpdateProjectLabelRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateProjectLabelResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.color)) {
      body["color"] = request.color;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateProjectLabel",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/labels/${OpenApiUtil.getEncodeParam(labelId)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateProjectLabelResponse>(await this.callApi(params, req, runtime), new UpdateProjectLabelResponse({}));
  }

  async updateProjectLabel(labelId: string, request: UpdateProjectLabelRequest): Promise<UpdateProjectLabelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateProjectLabelWithOptions(labelId, request, headers, runtime);
  }

  async updateProjectMemberWithOptions(organizationId: string, projectId: string, request: UpdateProjectMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateProjectMemberResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.roleIdentifier)) {
      body["roleIdentifier"] = request.roleIdentifier;
    }

    if (!Util.isUnset(request.targetIdentifier)) {
      body["targetIdentifier"] = request.targetIdentifier;
    }

    if (!Util.isUnset(request.targetType)) {
      body["targetType"] = request.targetType;
    }

    if (!Util.isUnset(request.userIdentifier)) {
      body["userIdentifier"] = request.userIdentifier;
    }

    if (!Util.isUnset(request.userType)) {
      body["userType"] = request.userType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateProjectMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/projects/${OpenApiUtil.getEncodeParam(projectId)}/updateMember`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateProjectMemberResponse>(await this.callApi(params, req, runtime), new UpdateProjectMemberResponse({}));
  }

  async updateProjectMember(organizationId: string, projectId: string, request: UpdateProjectMemberRequest): Promise<UpdateProjectMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateProjectMemberWithOptions(organizationId, projectId, request, headers, runtime);
  }

  async updateProtectedBranchesWithOptions(repositoryId: string, id: string, request: UpdateProtectedBranchesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateProtectedBranchesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.allowMergeRoles)) {
      body["allowMergeRoles"] = request.allowMergeRoles;
    }

    if (!Util.isUnset(request.allowMergeUserIds)) {
      body["allowMergeUserIds"] = request.allowMergeUserIds;
    }

    if (!Util.isUnset(request.allowPushRoles)) {
      body["allowPushRoles"] = request.allowPushRoles;
    }

    if (!Util.isUnset(request.allowPushUserIds)) {
      body["allowPushUserIds"] = request.allowPushUserIds;
    }

    if (!Util.isUnset(request.branch)) {
      body["branch"] = request.branch;
    }

    if (!Util.isUnset(request.id)) {
      body["id"] = request.id;
    }

    if (!Util.isUnset(request.mergeRequestSetting)) {
      body["mergeRequestSetting"] = request.mergeRequestSetting;
    }

    if (!Util.isUnset(request.testSettingDTO)) {
      body["testSettingDTO"] = request.testSettingDTO;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateProtectedBranches",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/${OpenApiUtil.getEncodeParam(repositoryId)}/protect_branches/${OpenApiUtil.getEncodeParam(id)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateProtectedBranchesResponse>(await this.callApi(params, req, runtime), new UpdateProtectedBranchesResponse({}));
  }

  async updateProtectedBranches(repositoryId: string, id: string, request: UpdateProtectedBranchesRequest): Promise<UpdateProtectedBranchesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateProtectedBranchesWithOptions(repositoryId, id, request, headers, runtime);
  }

  async updatePushReviewOnOffWithOptions(repositoryId: string, request: UpdatePushReviewOnOffRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdatePushReviewOnOffResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.trunkMode)) {
      query["trunkMode"] = request.trunkMode;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdatePushReviewOnOff",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/settings/trunk_mode`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdatePushReviewOnOffResponse>(await this.callApi(params, req, runtime), new UpdatePushReviewOnOffResponse({}));
  }

  async updatePushReviewOnOff(repositoryId: string, request: UpdatePushReviewOnOffRequest): Promise<UpdatePushReviewOnOffResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updatePushReviewOnOffWithOptions(repositoryId, request, headers, runtime);
  }

  async updatePushRuleWithOptions(repositoryId: string, pushRuleId: string, request: UpdatePushRuleRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdatePushRuleResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.ruleInfos)) {
      body["ruleInfos"] = request.ruleInfos;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdatePushRule",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/push_rule/${OpenApiUtil.getEncodeParam(pushRuleId)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdatePushRuleResponse>(await this.callApi(params, req, runtime), new UpdatePushRuleResponse({}));
  }

  async updatePushRule(repositoryId: string, pushRuleId: string, request: UpdatePushRuleRequest): Promise<UpdatePushRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updatePushRuleWithOptions(repositoryId, pushRuleId, request, headers, runtime);
  }

  async updateRepositoryWithOptions(repositoryId: string, request: UpdateRepositoryRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateRepositoryResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.adminSettingLanguage)) {
      body["adminSettingLanguage"] = request.adminSettingLanguage;
    }

    if (!Util.isUnset(request.avatar)) {
      body["avatar"] = request.avatar;
    }

    if (!Util.isUnset(request.buildsEnabled)) {
      body["buildsEnabled"] = request.buildsEnabled;
    }

    if (!Util.isUnset(request.checkEmail)) {
      body["checkEmail"] = request.checkEmail;
    }

    if (!Util.isUnset(request.defaultBranch)) {
      body["defaultBranch"] = request.defaultBranch;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.id)) {
      body["id"] = request.id;
    }

    if (!Util.isUnset(request.issuesEnabled)) {
      body["issuesEnabled"] = request.issuesEnabled;
    }

    if (!Util.isUnset(request.mergeRequestsEnabled)) {
      body["mergeRequestsEnabled"] = request.mergeRequestsEnabled;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.openCloneDownloadControl)) {
      body["openCloneDownloadControl"] = request.openCloneDownloadControl;
    }

    if (!Util.isUnset(request.path)) {
      body["path"] = request.path;
    }

    if (!Util.isUnset(request.projectCloneDownloadMethodList)) {
      body["projectCloneDownloadMethodList"] = request.projectCloneDownloadMethodList;
    }

    if (!Util.isUnset(request.projectCloneDownloadRoleList)) {
      body["projectCloneDownloadRoleList"] = request.projectCloneDownloadRoleList;
    }

    if (!Util.isUnset(request.snippetsEnabled)) {
      body["snippetsEnabled"] = request.snippetsEnabled;
    }

    if (!Util.isUnset(request.visibilityLevel)) {
      body["visibilityLevel"] = request.visibilityLevel;
    }

    if (!Util.isUnset(request.wikiEnabled)) {
      body["wikiEnabled"] = request.wikiEnabled;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateRepository",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateRepositoryResponse>(await this.callApi(params, req, runtime), new UpdateRepositoryResponse({}));
  }

  async updateRepository(repositoryId: string, request: UpdateRepositoryRequest): Promise<UpdateRepositoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateRepositoryWithOptions(repositoryId, request, headers, runtime);
  }

  async updateRepositoryMemberWithOptions(repositoryId: string, aliyunPk: string, request: UpdateRepositoryMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateRepositoryMemberResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessLevel)) {
      body["accessLevel"] = request.accessLevel;
    }

    if (!Util.isUnset(request.expireAt)) {
      body["expireAt"] = request.expireAt;
    }

    if (!Util.isUnset(request.memberType)) {
      body["memberType"] = request.memberType;
    }

    if (!Util.isUnset(request.relatedId)) {
      body["relatedId"] = request.relatedId;
    }

    if (!Util.isUnset(request.relatedInfos)) {
      body["relatedInfos"] = request.relatedInfos;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateRepositoryMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/members/${OpenApiUtil.getEncodeParam(aliyunPk)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateRepositoryMemberResponse>(await this.callApi(params, req, runtime), new UpdateRepositoryMemberResponse({}));
  }

  async updateRepositoryMember(repositoryId: string, aliyunPk: string, request: UpdateRepositoryMemberRequest): Promise<UpdateRepositoryMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateRepositoryMemberWithOptions(repositoryId, aliyunPk, request, headers, runtime);
  }

  async updateResourceMemberWithOptions(organizationId: string, resourceType: string, resourceId: string, accountId: string, request: UpdateResourceMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateResourceMemberResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.roleName)) {
      body["roleName"] = request.roleName;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateResourceMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/${OpenApiUtil.getEncodeParam(resourceType)}/${OpenApiUtil.getEncodeParam(resourceId)}/members/${OpenApiUtil.getEncodeParam(accountId)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateResourceMemberResponse>(await this.callApi(params, req, runtime), new UpdateResourceMemberResponse({}));
  }

  async updateResourceMember(organizationId: string, resourceType: string, resourceId: string, accountId: string, request: UpdateResourceMemberRequest): Promise<UpdateResourceMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateResourceMemberWithOptions(organizationId, resourceType, resourceId, accountId, request, headers, runtime);
  }

  async updateTestCaseWithOptions(organizationId: string, testcaseIdentifier: string, request: UpdateTestCaseRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateTestCaseResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.updateWorkitemPropertyRequest)) {
      body["updateWorkitemPropertyRequest"] = request.updateWorkitemPropertyRequest;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTestCase",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/testhub/testcase/${OpenApiUtil.getEncodeParam(testcaseIdentifier)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateTestCaseResponse>(await this.callApi(params, req, runtime), new UpdateTestCaseResponse({}));
  }

  async updateTestCase(organizationId: string, testcaseIdentifier: string, request: UpdateTestCaseRequest): Promise<UpdateTestCaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateTestCaseWithOptions(organizationId, testcaseIdentifier, request, headers, runtime);
  }

  async updateTestResultWithOptions(organizationId: string, testPlanIdentifier: string, testcaseIdentifier: string, request: UpdateTestResultRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateTestResultResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.executor)) {
      body["executor"] = request.executor;
    }

    if (!Util.isUnset(request.status)) {
      body["status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTestResult",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/testhub/testplan/${OpenApiUtil.getEncodeParam(testPlanIdentifier)}/testresult/${OpenApiUtil.getEncodeParam(testcaseIdentifier)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateTestResultResponse>(await this.callApi(params, req, runtime), new UpdateTestResultResponse({}));
  }

  async updateTestResult(organizationId: string, testPlanIdentifier: string, testcaseIdentifier: string, request: UpdateTestResultRequest): Promise<UpdateTestResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateTestResultWithOptions(organizationId, testPlanIdentifier, testcaseIdentifier, request, headers, runtime);
  }

  async updateVariableGroupWithOptions(organizationId: string, id: string, request: UpdateVariableGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateVariableGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.variables)) {
      body["variables"] = request.variables;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateVariableGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/variableGroups/${OpenApiUtil.getEncodeParam(id)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateVariableGroupResponse>(await this.callApi(params, req, runtime), new UpdateVariableGroupResponse({}));
  }

  async updateVariableGroup(organizationId: string, id: string, request: UpdateVariableGroupRequest): Promise<UpdateVariableGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateVariableGroupWithOptions(organizationId, id, request, headers, runtime);
  }

  async updateWorkItemWithOptions(organizationId: string, request: UpdateWorkItemRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateWorkItemResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.fieldType)) {
      body["fieldType"] = request.fieldType;
    }

    if (!Util.isUnset(request.identifier)) {
      body["identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.propertyKey)) {
      body["propertyKey"] = request.propertyKey;
    }

    if (!Util.isUnset(request.propertyValue)) {
      body["propertyValue"] = request.propertyValue;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateWorkItem",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/update`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateWorkItemResponse>(await this.callApi(params, req, runtime), new UpdateWorkItemResponse({}));
  }

  async updateWorkItem(organizationId: string, request: UpdateWorkItemRequest): Promise<UpdateWorkItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateWorkItemWithOptions(organizationId, request, headers, runtime);
  }

  async updateWorkitemCommentWithOptions(organizationId: string, request: UpdateWorkitemCommentRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateWorkitemCommentResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.commentId)) {
      body["commentId"] = request.commentId;
    }

    if (!Util.isUnset(request.content)) {
      body["content"] = request.content;
    }

    if (!Util.isUnset(request.formatType)) {
      body["formatType"] = request.formatType;
    }

    if (!Util.isUnset(request.workitemIdentifier)) {
      body["workitemIdentifier"] = request.workitemIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateWorkitemComment",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/commentUpdate`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateWorkitemCommentResponse>(await this.callApi(params, req, runtime), new UpdateWorkitemCommentResponse({}));
  }

  async updateWorkitemComment(organizationId: string, request: UpdateWorkitemCommentRequest): Promise<UpdateWorkitemCommentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateWorkitemCommentWithOptions(organizationId, request, headers, runtime);
  }

  async updateWorkitemFieldWithOptions(organizationId: string, request: UpdateWorkitemFieldRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateWorkitemFieldResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.updateWorkitemPropertyRequest)) {
      body["updateWorkitemPropertyRequest"] = request.updateWorkitemPropertyRequest;
    }

    if (!Util.isUnset(request.workitemIdentifier)) {
      body["workitemIdentifier"] = request.workitemIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateWorkitemField",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/updateWorkitemField`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateWorkitemFieldResponse>(await this.callApi(params, req, runtime), new UpdateWorkitemFieldResponse({}));
  }

  async updateWorkitemField(organizationId: string, request: UpdateWorkitemFieldRequest): Promise<UpdateWorkitemFieldResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateWorkitemFieldWithOptions(organizationId, request, headers, runtime);
  }

  async workitemAttachmentCreateWithOptions(organizationId: string, workitemIdentifier: string, request: WorkitemAttachmentCreateRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<WorkitemAttachmentCreateResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.fileKey)) {
      body["fileKey"] = request.fileKey;
    }

    if (!Util.isUnset(request.originalFilename)) {
      body["originalFilename"] = request.originalFilename;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "WorkitemAttachmentCreate",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitem/${OpenApiUtil.getEncodeParam(workitemIdentifier)}/attachment`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<WorkitemAttachmentCreateResponse>(await this.callApi(params, req, runtime), new WorkitemAttachmentCreateResponse({}));
  }

  async workitemAttachmentCreate(organizationId: string, workitemIdentifier: string, request: WorkitemAttachmentCreateRequest): Promise<WorkitemAttachmentCreateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.workitemAttachmentCreateWithOptions(organizationId, workitemIdentifier, request, headers, runtime);
  }

}
