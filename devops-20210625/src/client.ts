// This file is auto-generated, don't edit it
/**
 */
import Util, * as $Util from '@alicloud/tea-util';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class AddGroupMemberRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 30
   */
  accessLevel?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 18745637472884
   */
  aliyunPks?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      accessLevel: 'accessLevel',
      aliyunPks: 'aliyunPks',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      accessLevel: 'number',
      aliyunPks: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGroupMemberResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: AddGroupMemberResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': AddGroupMemberResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGroupMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddGroupMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddGroupMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPipelineRelationsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 11,22
   */
  relObjectIds?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * VARIABLE_GROUP
   */
  relObjectType?: string;
  static names(): { [key: string]: string } {
    return {
      relObjectIds: 'relObjectIds',
      relObjectType: 'relObjectType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      relObjectIds: 'string',
      relObjectType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPipelineRelationsResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPipelineRelationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddPipelineRelationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddPipelineRelationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddRepositoryMemberRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 30
   */
  accessLevel?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 18745637472884
   */
  aliyunPks?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      accessLevel: 'accessLevel',
      aliyunPks: 'aliyunPks',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      accessLevel: 'number',
      aliyunPks: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddRepositoryMemberResponseBody extends $tea.Model {
  /**
   * @example
   * Invalid.IdNotFound
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 4D6AF7CC-B43B-5454-86AB-023D25E44868
   */
  requestId?: string;
  result?: AddRepositoryMemberResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': AddRepositoryMemberResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddRepositoryMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddRepositoryMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddRepositoryMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWebhookRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  description?: string;
  /**
   * @example
   * false
   */
  enableSslVerification?: boolean;
  /**
   * @example
   * true
   */
  mergeRequestsEvents?: boolean;
  /**
   * @example
   * false
   */
  noteEvents?: boolean;
  /**
   * @example
   * true
   */
  pushEvents?: boolean;
  /**
   * @example
   * xxxx
   */
  secretToken?: string;
  /**
   * @example
   * false
   */
  tagPushEvents?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * https://xxxxx
   */
  url?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      description: 'description',
      enableSslVerification: 'enableSslVerification',
      mergeRequestsEvents: 'mergeRequestsEvents',
      noteEvents: 'noteEvents',
      pushEvents: 'pushEvents',
      secretToken: 'secretToken',
      tagPushEvents: 'tagPushEvents',
      url: 'url',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      description: 'string',
      enableSslVerification: 'boolean',
      mergeRequestsEvents: 'boolean',
      noteEvents: 'boolean',
      pushEvents: 'boolean',
      secretToken: 'string',
      tagPushEvents: 'boolean',
      url: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWebhookResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_NOT_FOUND_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * “”
   */
  errorMessage?: string;
  /**
   * @example
   * 6177543A-8D54-5736-A93B-E0195A1512CB
   */
  requestId?: string;
  result?: AddWebhookResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: AddWebhookResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWebhookResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddWebhookResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddWebhookResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelExecutionReleaseStageRequest extends $tea.Model {
  /**
   * @example
   * 66c0c9fffeb86b450c19****
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelExecutionReleaseStageResponseBody extends $tea.Model {
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelExecutionReleaseStageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CancelExecutionReleaseStageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CancelExecutionReleaseStageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseMergeRequestRequest extends $tea.Model {
  /**
   * @example
   * 0cf2c8458ac44d9481aab2dd6ec10596v3
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseMergeRequestResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * InvalidParam.NoPermission
   */
  errorMessage?: string;
  /**
   * @example
   * HC93CE1A-8D7A-13A9-8306-7465DE2E5C0F
   */
  requestId?: string;
  result?: CloseMergeRequestResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CloseMergeRequestResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseMergeRequestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CloseMergeRequestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CloseMergeRequestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAppMembersRequest extends $tea.Model {
  playerList?: CreateAppMembersRequestPlayerList[];
  roleNames?: string[];
  /**
   * @example
   * 66c0c9fffeb86b450c199fcd
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      playerList: 'playerList',
      roleNames: 'roleNames',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      playerList: { 'type': 'array', 'itemType': CreateAppMembersRequestPlayerList },
      roleNames: { 'type': 'array', 'itemType': 'string' },
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAppMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: string;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBranchRequest extends $tea.Model {
  /**
   * @example
   * 0cf2c8458ac44d9481aab2dd6ec10596v3
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * createBranch
   */
  branchName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * master
   */
  ref?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      branchName: 'branchName',
      ref: 'ref',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      branchName: 'string',
      ref: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBranchResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  result?: CreateBranchResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateBranchResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBranchResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateBranchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateBranchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateChangeRequestRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * sn123
   */
  appCodeRepoSn?: string;
  /**
   * @example
   * false
   */
  autoDeleteBranchWhenEnd?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * hotfix/20240524
   */
  branchName?: string;
  /**
   * @example
   * false
   */
  createBranch?: boolean;
  /**
   * @example
   * 1332695887xxxxxx
   */
  ownerAccountId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  ownerId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  title?: string;
  /**
   * @example
   * 66c0c9fffeb86b450c199fcd
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      appCodeRepoSn: 'appCodeRepoSn',
      autoDeleteBranchWhenEnd: 'autoDeleteBranchWhenEnd',
      branchName: 'branchName',
      createBranch: 'createBranch',
      ownerAccountId: 'ownerAccountId',
      ownerId: 'ownerId',
      title: 'title',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appCodeRepoSn: 'string',
      autoDeleteBranchWhenEnd: 'boolean',
      branchName: 'string',
      createBranch: 'boolean',
      ownerAccountId: 'string',
      ownerId: 'string',
      title: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateChangeRequestResponseBody extends $tea.Model {
  /**
   * @example
   * sn123
   */
  appCodeRepoSn?: string;
  /**
   * @example
   * app-name
   */
  appName?: string;
  /**
   * @example
   * false
   */
  autoDeleteBranchWhenEnd?: boolean;
  /**
   * @example
   * hotfix/20240524
   */
  branch?: string;
  /**
   * @example
   * create-account-123
   */
  creatorAccountId?: string;
  /**
   * @example
   * create-id-123
   */
  creatorId?: string;
  /**
   * @example
   * 2024-01-01 00:00:00
   */
  gmtCreate?: string;
  /**
   * @example
   * 2024-01-01 00:00:00
   */
  gmtModified?: string;
  name?: string;
  /**
   * @example
   * master
   */
  originBranch?: string;
  /**
   * @example
   * revision-123
   */
  originBranchRevisionSha?: string;
  /**
   * @example
   * account-id-123
   */
  ownerAccountId?: string;
  /**
   * @example
   * owner-id-123
   */
  ownerId?: string;
  /**
   * @example
   * ce51b31b996246ecaf874736838360b2
   */
  sn?: string;
  /**
   * @example
   * DEVELOPING
   */
  state?: string;
  /**
   * @example
   * APP
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      appCodeRepoSn: 'appCodeRepoSn',
      appName: 'appName',
      autoDeleteBranchWhenEnd: 'autoDeleteBranchWhenEnd',
      branch: 'branch',
      creatorAccountId: 'creatorAccountId',
      creatorId: 'creatorId',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      name: 'name',
      originBranch: 'originBranch',
      originBranchRevisionSha: 'originBranchRevisionSha',
      ownerAccountId: 'ownerAccountId',
      ownerId: 'ownerId',
      sn: 'sn',
      state: 'state',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appCodeRepoSn: 'string',
      appName: 'string',
      autoDeleteBranchWhenEnd: 'boolean',
      branch: 'string',
      creatorAccountId: 'string',
      creatorId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      name: 'string',
      originBranch: 'string',
      originBranchRevisionSha: 'string',
      ownerAccountId: 'string',
      ownerId: 'string',
      sn: 'string',
      state: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateChangeRequestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateChangeRequestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateChangeRequestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  annotations?: CreateCheckRunRequestAnnotations[];
  /**
   * @example
   * 2023-03-15T08:00:00Z
   */
  completedAt?: string;
  /**
   * @example
   * success
   */
  conclusion?: string;
  /**
   * @example
   * xxx
   */
  detailsUrl?: string;
  /**
   * @example
   * 42
   */
  externalId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 40f4ccfe019cdd4a62d4acb0c57130106fc7e1be
   */
  headSha?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * my-check-ci
   */
  name?: string;
  output?: CreateCheckRunRequestOutput;
  /**
   * @example
   * 2023-03-15T08:00:00Z
   */
  startedAt?: string;
  /**
   * @example
   * completed
   */
  status?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      annotations: 'annotations',
      completedAt: 'completedAt',
      conclusion: 'conclusion',
      detailsUrl: 'detailsUrl',
      externalId: 'externalId',
      headSha: 'headSha',
      name: 'name',
      output: 'output',
      startedAt: 'startedAt',
      status: 'status',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      annotations: { 'type': 'array', 'itemType': CreateCheckRunRequestAnnotations },
      completedAt: 'string',
      conclusion: 'string',
      detailsUrl: 'string',
      externalId: 'string',
      headSha: 'string',
      name: 'string',
      output: CreateCheckRunRequestOutput,
      startedAt: 'string',
      status: 'string',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: CreateCheckRunResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateCheckRunResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateCheckRunResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCheckRunResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommentRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * GLOBAL_COMMENT
   */
  commentType?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  content?: string;
  /**
   * @example
   * false
   */
  draft?: boolean;
  /**
   * @example
   * /src/main/test.java
   */
  filePath?: string;
  /**
   * @example
   * 1
   */
  lineNumber?: number;
  /**
   * @example
   * 2666ac1ac53841b0ba1b042e383279cc
   */
  parentCommentBizId?: string;
  /**
   * @example
   * b7d8386be17c4ca68a07140db4836257
   */
  patchSetBizId?: string;
  /**
   * @example
   * false
   */
  resolved?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1
   */
  localId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      commentType: 'commentType',
      content: 'content',
      draft: 'draft',
      filePath: 'filePath',
      lineNumber: 'lineNumber',
      parentCommentBizId: 'parentCommentBizId',
      patchSetBizId: 'patchSetBizId',
      resolved: 'resolved',
      localId: 'localId',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      commentType: 'string',
      content: 'string',
      draft: 'boolean',
      filePath: 'string',
      lineNumber: 'number',
      parentCommentBizId: 'string',
      patchSetBizId: 'string',
      resolved: 'boolean',
      localId: 'number',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommentResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: CreateCommentResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateCommentResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateCommentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCommentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitStatusRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @example
   * default
   */
  context?: string;
  description?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * success
   */
  state?: string;
  /**
   * @example
   * xxx
   */
  targetUrl?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2080972
   */
  repositoryIdentity?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * e0c1a1299a2656bfc155650bbd2df5e628fa1f4c
   */
  sha?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      context: 'context',
      description: 'description',
      state: 'state',
      targetUrl: 'targetUrl',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
      sha: 'sha',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      context: 'string',
      description: 'string',
      state: 'string',
      targetUrl: 'string',
      organizationId: 'string',
      repositoryIdentity: 'string',
      sha: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitStatusResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 020F71F3-F063-5B8B-8978-2B01833216BB
   */
  requestId?: string;
  result?: CreateCommitStatusResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateCommitStatusResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateCommitStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCommitStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitWithMultipleFilesRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  actions?: CreateCommitWithMultipleFilesRequestActions[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * master
   */
  branch?: string;
  /**
   * @example
   * auto
   */
  commitMessage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      actions: 'actions',
      branch: 'branch',
      commitMessage: 'commitMessage',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      actions: { 'type': 'array', 'itemType': CreateCommitWithMultipleFilesRequestActions },
      branch: 'string',
      commitMessage: 'string',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitWithMultipleFilesResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @example
   * A7586FEB-E48D-5579-983F-74981FBFF627
   */
  requestId?: string;
  result?: CreateCommitWithMultipleFilesResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      result: CreateCommitWithMultipleFilesResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitWithMultipleFilesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateCommitWithMultipleFilesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCommitWithMultipleFilesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeployKeyRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ""
   */
  key?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  title?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      key: 'key',
      title: 'title',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      key: 'string',
      title: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeployKeyResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: CreateDeployKeyResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateDeployKeyResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeployKeyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDeployKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDeployKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * master
   */
  branchName?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  commitMessage?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  content?: string;
  /**
   * @example
   * text
   */
  encoding?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * /src/main/test.java
   */
  filePath?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      branchName: 'branchName',
      commitMessage: 'commitMessage',
      content: 'content',
      encoding: 'encoding',
      filePath: 'filePath',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      branchName: 'string',
      commitMessage: 'string',
      content: 'string',
      encoding: 'string',
      filePath: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * F8053E32-9623-511F-8B46-F0E5FD206524
   */
  requestId?: string;
  result?: CreateFileResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateFileResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowTagRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * #1F9AEF
   */
  color?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 111
   */
  flowTagGroupId?: number;
  /**
   * @remarks
   * This parameter is required.
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      color: 'color',
      flowTagGroupId: 'flowTagGroupId',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      color: 'string',
      flowTagGroupId: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowTagResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * 111
   */
  id?: number;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true 接口调用成功，false 接口调用失败
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      id: 'id',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      id: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowTagResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateFlowTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateFlowTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowTagGroupRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowTagGroupResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * 1223
   */
  id?: number;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true 接口调用成功，false 接口调用失败
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      id: 'id',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      id: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowTagGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateFlowTagGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateFlowTagGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHostGroupRequest extends $tea.Model {
  /**
   * @example
   * cn-beijing
   */
  aliyunRegion?: string;
  /**
   * @example
   * ecs
   */
  ecsLabelKey?: string;
  /**
   * @example
   * ecs
   */
  ecsLabelValue?: string;
  /**
   * @example
   * ECS_ALIYUN
   */
  ecsType?: string;
  /**
   * @example
   * 0
   */
  envId?: string;
  /**
   * @example
   * [{"aliyunRegionId":"cn-beijing","machineSn":"i-sssssss","instanceName":"ceshi","ip":"120.0.0.0"}]
   */
  machineInfos?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123
   */
  serviceConnectionId?: number;
  /**
   * @example
   * 12,234
   */
  tagIds?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ECS
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunRegion: 'aliyunRegion',
      ecsLabelKey: 'ecsLabelKey',
      ecsLabelValue: 'ecsLabelValue',
      ecsType: 'ecsType',
      envId: 'envId',
      machineInfos: 'machineInfos',
      name: 'name',
      serviceConnectionId: 'serviceConnectionId',
      tagIds: 'tagIds',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunRegion: 'string',
      ecsLabelKey: 'string',
      ecsLabelValue: 'string',
      ecsType: 'string',
      envId: 'string',
      machineInfos: 'string',
      name: 'string',
      serviceConnectionId: 'number',
      tagIds: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHostGroupResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 123
   */
  hostGroupId?: number;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      hostGroupId: 'hostGroupId',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      hostGroupId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHostGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateHostGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateHostGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMergeRequestRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * WEB
   */
  createFrom?: string;
  description?: string;
  reviewerIds?: string[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * sourceBranch
   */
  sourceBranch?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2369234
   */
  sourceProjectId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * targetBranch
   */
  targetBranch?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2369234
   */
  targetProjectId?: number;
  /**
   * @remarks
   * This parameter is required.
   */
  title?: string;
  /**
   * @example
   * 722200214032b6b31e6f1434ab
   */
  workItemIds?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 6270e731cfea268afc21ccac
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      createFrom: 'createFrom',
      description: 'description',
      reviewerIds: 'reviewerIds',
      sourceBranch: 'sourceBranch',
      sourceProjectId: 'sourceProjectId',
      targetBranch: 'targetBranch',
      targetProjectId: 'targetProjectId',
      title: 'title',
      workItemIds: 'workItemIds',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      createFrom: 'string',
      description: 'string',
      reviewerIds: { 'type': 'array', 'itemType': 'string' },
      sourceBranch: 'string',
      sourceProjectId: 'number',
      targetBranch: 'string',
      targetProjectId: 'number',
      title: 'string',
      workItemIds: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMergeRequestResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  result?: CreateMergeRequestResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateMergeRequestResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMergeRequestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateMergeRequestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMergeRequestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOAuthTokenRequest extends $tea.Model {
  /**
   * @remarks
   * clientId
   * 
   * This parameter is required.
   * 
   * @example
   * dc7e0b3c00a3e58f46
   */
  clientId?: string;
  /**
   * @remarks
   * client_secret
   * 
   * This parameter is required.
   * 
   * @example
   * a433294edea39cae7e7870
   */
  clientSecret?: string;
  /**
   * @example
   * 86df532f74454e189740d100ac97f4b9
   */
  code?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * code
   */
  grantType?: string;
  /**
   * @example
   * username
   */
  login?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * read:repo
   */
  scope?: string;
  static names(): { [key: string]: string } {
    return {
      clientId: 'clientId',
      clientSecret: 'clientSecret',
      code: 'code',
      grantType: 'grantType',
      login: 'login',
      scope: 'scope',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientId: 'string',
      clientSecret: 'string',
      code: 'string',
      grantType: 'string',
      login: 'string',
      scope: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOAuthTokenResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * C2F153F6-BB43-50C4-9F4F-40593203E19A
   */
  requestId?: string;
  result?: CreateOAuthTokenResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateOAuthTokenResponseBodyResult,
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOAuthTokenResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOAuthTokenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOAuthTokenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePipelineRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  content?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'content',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePipelineResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 11XXX
   */
  pipelinId?: number;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      pipelinId: 'pipelinId',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      pipelinId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePipelineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePipelineGroupRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePipelineGroupResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  pipelineGroup?: CreatePipelineGroupResponseBodyPipelineGroup;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      pipelineGroup: 'pipelineGroup',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      pipelineGroup: CreatePipelineGroupResponseBodyPipelineGroup,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePipelineGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePipelineGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePipelineGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ABCD
   */
  customCode?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * name
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * public
   */
  scope?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 704eaxxxx5efede61xxx5
   */
  templateIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      customCode: 'customCode',
      name: 'name',
      scope: 'scope',
      templateIdentifier: 'templateIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customCode: 'string',
      name: 'string',
      scope: 'string',
      templateIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  project?: CreateProjectResponseBodyProject;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      project: 'project',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      project: CreateProjectResponseBodyProject,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectLabelRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * #006AD4
   */
  color?: string;
  description?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      color: 'color',
      description: 'description',
      name: 'name',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      color: 'string',
      description: 'string',
      name: 'string',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectLabelResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * A7586FEB-E48D-5579-983F-74981FBFF627
   */
  requestId?: string;
  result?: CreateProjectLabelResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateProjectLabelResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectLabelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateProjectLabelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProjectLabelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  allowMergeRoles?: number[];
  allowMergeUserIds?: string[];
  allowPushRoles?: number[];
  allowPushUserIds?: string[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * protectBranch
   */
  branch?: string;
  /**
   * @example
   * --
   */
  id?: number;
  mergeRequestSetting?: CreateProtectdBranchRequestMergeRequestSetting;
  testSettingDTO?: CreateProtectdBranchRequestTestSettingDTO;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      allowMergeRoles: 'allowMergeRoles',
      allowMergeUserIds: 'allowMergeUserIds',
      allowPushRoles: 'allowPushRoles',
      allowPushUserIds: 'allowPushUserIds',
      branch: 'branch',
      id: 'id',
      mergeRequestSetting: 'mergeRequestSetting',
      testSettingDTO: 'testSettingDTO',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      allowMergeRoles: { 'type': 'array', 'itemType': 'number' },
      allowMergeUserIds: { 'type': 'array', 'itemType': 'string' },
      allowPushRoles: { 'type': 'array', 'itemType': 'number' },
      allowPushUserIds: { 'type': 'array', 'itemType': 'string' },
      branch: 'string',
      id: 'number',
      mergeRequestSetting: CreateProtectdBranchRequestMergeRequestSetting,
      testSettingDTO: CreateProtectdBranchRequestTestSettingDTO,
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * C2F153F6-BB43-50C4-9F4F-40593203E19A
   */
  requestId?: string;
  result?: CreateProtectdBranchResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateProtectdBranchResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateProtectdBranchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProtectdBranchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePushRuleRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  ruleInfos?: CreatePushRuleRequestRuleInfos[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      ruleInfos: 'ruleInfos',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      ruleInfos: { 'type': 'array', 'itemType': CreatePushRuleRequestRuleInfos },
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePushRuleResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: CreatePushRuleResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreatePushRuleResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePushRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePushRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePushRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRepositoryRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  description?: string;
  /**
   * @example
   * Java
   */
  gitignoreType?: string;
  /**
   * @example
   * codeup-test
   */
  importAccount?: string;
  /**
   * @example
   * true
   */
  importDemoProject?: boolean;
  /**
   * @example
   * GIT
   */
  importRepoType?: string;
  /**
   * @example
   * xxxxx
   */
  importToken?: string;
  /**
   * @example
   * text
   */
  importTokenEncrypted?: string;
  /**
   * @example
   * https://github.com/a/b.git
   */
  importUrl?: string;
  /**
   * @example
   * true
   */
  initStandardService?: boolean;
  /**
   * @example
   * false
   */
  isCryptoEnabled?: boolean;
  /**
   * @example
   * ""
   */
  localImportUrl?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  name?: string;
  namespaceId?: number;
  path?: string;
  /**
   * @example
   * USER_GUIDE
   */
  readmeType?: string;
  /**
   * @example
   * 0
   */
  visibilityLevel?: number;
  /**
   * @example
   * true
   */
  createParentPath?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  /**
   * @example
   * false
   */
  sync?: boolean;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      avatarUrl: 'avatarUrl',
      description: 'description',
      gitignoreType: 'gitignoreType',
      importAccount: 'importAccount',
      importDemoProject: 'importDemoProject',
      importRepoType: 'importRepoType',
      importToken: 'importToken',
      importTokenEncrypted: 'importTokenEncrypted',
      importUrl: 'importUrl',
      initStandardService: 'initStandardService',
      isCryptoEnabled: 'isCryptoEnabled',
      localImportUrl: 'localImportUrl',
      name: 'name',
      namespaceId: 'namespaceId',
      path: 'path',
      readmeType: 'readmeType',
      visibilityLevel: 'visibilityLevel',
      createParentPath: 'createParentPath',
      organizationId: 'organizationId',
      sync: 'sync',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      avatarUrl: 'string',
      description: 'string',
      gitignoreType: 'string',
      importAccount: 'string',
      importDemoProject: 'boolean',
      importRepoType: 'string',
      importToken: 'string',
      importTokenEncrypted: 'string',
      importUrl: 'string',
      initStandardService: 'boolean',
      isCryptoEnabled: 'boolean',
      localImportUrl: 'string',
      name: 'string',
      namespaceId: 'number',
      path: 'string',
      readmeType: 'string',
      visibilityLevel: 'number',
      createParentPath: 'boolean',
      organizationId: 'string',
      sync: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRepositoryResponseBody extends $tea.Model {
  /**
   * @example
   * 401
   */
  errorCode?: string;
  /**
   * @example
   * SYSTEM_UNAUTHORIZED_ERROR
   */
  errorMessage?: string;
  /**
   * @example
   * F590C9D8-E908-5B6C-95AC-56B7E8011FFA
   */
  requestId?: string;
  result?: CreateRepositoryResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateRepositoryResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRepositoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateRepositoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRepositoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRepositoryGroupRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  description?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test-create-group
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 26842
   */
  parentId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test-create-group
   */
  path?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 10
   */
  visibilityLevel?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      avatarUrl: 'avatarUrl',
      description: 'description',
      name: 'name',
      parentId: 'parentId',
      path: 'path',
      visibilityLevel: 'visibilityLevel',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      avatarUrl: 'string',
      description: 'string',
      name: 'string',
      parentId: 'number',
      path: 'string',
      visibilityLevel: 'number',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRepositoryGroupResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  result?: CreateRepositoryGroupResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateRepositoryGroupResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRepositoryGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateRepositoryGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRepositoryGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResourceMemberRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1111111111111
   */
  accountId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * admin
   */
  roleName?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
      roleName: 'roleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
      roleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResourceMemberResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResourceMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateResourceMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateResourceMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceAuthRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * RAM
   */
  serviceAuthType?: string;
  static names(): { [key: string]: string } {
    return {
      serviceAuthType: 'serviceAuthType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceAuthType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceAuthResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 1223
   */
  id?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      id: 'id',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      id: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceAuthResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateServiceAuthResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateServiceAuthResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceConnectionRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * CREDENTIAL
   */
  authType?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  connectionName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ecs
   */
  connectionType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * PERSON
   */
  scope?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 111
   */
  serviceAuthId?: number;
  static names(): { [key: string]: string } {
    return {
      authType: 'authType',
      connectionName: 'connectionName',
      connectionType: 'connectionType',
      scope: 'scope',
      serviceAuthId: 'serviceAuthId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authType: 'string',
      connectionName: 'string',
      connectionType: 'string',
      scope: 'string',
      serviceAuthId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceConnectionResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 19224
   */
  id?: number;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      id: 'id',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      id: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceConnectionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateServiceConnectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateServiceConnectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceCredentialRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 张三的Git证书
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * zhangsan
   */
  password?: string;
  /**
   * @example
   * PERSON
   */
  scope?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * USERNAME_PASSWORD
   */
  type?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * zhangsan
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'name',
      password: 'password',
      scope: 'scope',
      type: 'type',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      password: 'string',
      scope: 'string',
      type: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceCredentialResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 11222
   */
  id?: number;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      id: 'id',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      id: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceCredentialResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateServiceCredentialResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateServiceCredentialResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSprintRequest extends $tea.Model {
  /**
   * @example
   * 2021-12-02
   */
  endDate?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * xxx
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * asd345xxxxx9q9845xxxxx34
   */
  spaceIdentifier?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  staffIds?: string[];
  /**
   * @example
   * 2021-12-01
   */
  startDate?: string;
  static names(): { [key: string]: string } {
    return {
      endDate: 'endDate',
      name: 'name',
      spaceIdentifier: 'spaceIdentifier',
      staffIds: 'staffIds',
      startDate: 'startDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endDate: 'string',
      name: 'string',
      spaceIdentifier: 'string',
      staffIds: { 'type': 'array', 'itemType': 'string' },
      startDate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSprintResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  sprint?: CreateSprintResponseBodySprint;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      sprint: 'sprint',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      sprint: CreateSprintResponseBodySprint,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSprintResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSprintResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSprintResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSshKeyResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  sshKey?: CreateSshKeyResponseBodySshKey;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      sshKey: 'sshKey',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      sshKey: CreateSshKeyResponseBodySshKey,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSshKeyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSshKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSshKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  message?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * master
   */
  ref?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * v1.0
   */
  tagName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      message: 'message',
      ref: 'ref',
      tagName: 'tagName',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      message: 'string',
      ref: 'string',
      tagName: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  result?: CreateTagResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateTagResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 19xxxx31947xxxx
   */
  assignedTo?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * fdd395xxxxx9q9845xxxxx23
   */
  directoryIdentifier?: string;
  fieldValueList?: CreateTestCaseRequestFieldValueList[];
  /**
   * @example
   * ik3dexxxxxfdfds1xxxxx23
   */
  priority?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * asd345xxxxx9q9845xxxxx34
   */
  spaceIdentifier?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  subject?: string;
  tags?: string[];
  testcaseStepContentInfo?: CreateTestCaseRequestTestcaseStepContentInfo;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      directoryIdentifier: 'directoryIdentifier',
      fieldValueList: 'fieldValueList',
      priority: 'priority',
      spaceIdentifier: 'spaceIdentifier',
      subject: 'subject',
      tags: 'tags',
      testcaseStepContentInfo: 'testcaseStepContentInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: 'string',
      directoryIdentifier: 'string',
      fieldValueList: { 'type': 'array', 'itemType': CreateTestCaseRequestFieldValueList },
      priority: 'string',
      spaceIdentifier: 'string',
      subject: 'string',
      tags: { 'type': 'array', 'itemType': 'string' },
      testcaseStepContentInfo: CreateTestCaseRequestTestcaseStepContentInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 18E50717-93A4-53BC-A30D-963F742A1CE6
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  testcase?: CreateTestCaseResponseBodyTestcase;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
      testcase: 'testcase',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
      testcase: CreateTestCaseResponseBodyTestcase,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTestCaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTestCaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserKeyRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @example
   * 2022-03-12 12:00:00
   */
  expireTime?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ALL
   */
  keyScope?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * xxx
   */
  publicKey?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * SSH Title
   */
  title?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      expireTime: 'expireTime',
      keyScope: 'keyScope',
      publicKey: 'publicKey',
      title: 'title',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      expireTime: 'string',
      keyScope: 'string',
      publicKey: 'string',
      title: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserKeyResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: CreateUserKeyResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateUserKeyResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserKeyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateUserKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateUserKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVariableGroupRequest extends $tea.Model {
  /**
   * @example
   * 变量组
   */
  description?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 变量组
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * [{"isEncrypted":true,"name":"name1","value":"vaue1"}]
   */
  variables?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'description',
      name: 'name',
      variables: 'variables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      variables: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVariableGroupResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 1234
   */
  variableGroupId?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
      variableGroupId: 'variableGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      variableGroupId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVariableGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateVariableGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateVariableGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 19xxxx31947xxxx
   */
  assignedTo?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Req
   */
  category?: string;
  /**
   * @example
   * 测试内容
   */
  description?: string;
  /**
   * @example
   * RICHTEXT
   */
  descriptionFormat?: string;
  fieldValueList?: CreateWorkitemRequestFieldValueList[];
  /**
   * @example
   * 3a0c9cdd24ae1e1995b8...
   */
  parent?: string;
  participant?: string[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * asd345xxxxx9q9845xxxxx34
   */
  space?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * asd345xxxxx9q9845xxxxx34
   */
  spaceIdentifier?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Project
   */
  spaceType?: string;
  sprint?: string[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 测试工作项
   */
  subject?: string;
  tracker?: string[];
  verifier?: string[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 9uyxxxxxre573f561dxxn40
   */
  workitemType?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      category: 'category',
      description: 'description',
      descriptionFormat: 'descriptionFormat',
      fieldValueList: 'fieldValueList',
      parent: 'parent',
      participant: 'participant',
      space: 'space',
      spaceIdentifier: 'spaceIdentifier',
      spaceType: 'spaceType',
      sprint: 'sprint',
      subject: 'subject',
      tracker: 'tracker',
      verifier: 'verifier',
      workitemType: 'workitemType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: 'string',
      category: 'string',
      description: 'string',
      descriptionFormat: 'string',
      fieldValueList: { 'type': 'array', 'itemType': CreateWorkitemRequestFieldValueList },
      parent: 'string',
      participant: { 'type': 'array', 'itemType': 'string' },
      space: 'string',
      spaceIdentifier: 'string',
      spaceType: 'string',
      sprint: { 'type': 'array', 'itemType': 'string' },
      subject: 'string',
      tracker: { 'type': 'array', 'itemType': 'string' },
      verifier: { 'type': 'array', 'itemType': 'string' },
      workitemType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  workitem?: CreateWorkitemResponseBodyWorkitem;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
      workitem: 'workitem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
      workitem: CreateWorkitemResponseBodyWorkitem,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWorkitemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWorkitemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemCommentRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  content?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * RICHTEXT/MARKDOWN
   */
  formatType?: string;
  /**
   * @example
   * 26842
   */
  parentId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1e9903d8b3f12xxxxxf9286ef5
   */
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'content',
      formatType: 'formatType',
      parentId: 'parentId',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      formatType: 'string',
      parentId: 'string',
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemCommentResponseBody extends $tea.Model {
  comment?: CreateWorkitemCommentResponseBodyComment;
  /**
   * @example
   * success
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  success?: string;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: CreateWorkitemCommentResponseBodyComment,
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemCommentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWorkitemCommentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWorkitemCommentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemEstimateRequest extends $tea.Model {
  description?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1316458xxxxx41068
   */
  recordUserIdentifier?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 21
   */
  spentTime?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 9144ef6b72d8exxxxx9e61a4d0
   */
  type?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1e9903d8b3f1xxxxxf9286ef5
   */
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'description',
      recordUserIdentifier: 'recordUserIdentifier',
      spentTime: 'spentTime',
      type: 'type',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      recordUserIdentifier: 'string',
      spentTime: 'string',
      type: 'string',
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemEstimateResponseBody extends $tea.Model {
  workitemTimeEstimate?: CreateWorkitemEstimateResponseBodyWorkitemTimeEstimate;
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      workitemTimeEstimate: 'WorkitemTimeEstimate',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      workitemTimeEstimate: CreateWorkitemEstimateResponseBodyWorkitemTimeEstimate,
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemEstimateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWorkitemEstimateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWorkitemEstimateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemRecordRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 12
   */
  actualTime?: string;
  description?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1646323200000
   */
  gmtEnd?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1667205617061
   */
  gmtStart?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1316458xxxxx41068
   */
  recordUserIdentifier?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * deafe5f33xxxxx6a259d8dafd
   */
  type?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 9144ef6b72d8exxxxx9e61a4d0
   */
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      actualTime: 'actualTime',
      description: 'description',
      gmtEnd: 'gmtEnd',
      gmtStart: 'gmtStart',
      recordUserIdentifier: 'recordUserIdentifier',
      type: 'type',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualTime: 'string',
      description: 'string',
      gmtEnd: 'string',
      gmtStart: 'string',
      recordUserIdentifier: 'string',
      type: 'string',
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemRecordResponseBody extends $tea.Model {
  workitemTime?: CreateWorkitemRecordResponseBodyWorkitemTime;
  /**
   * @example
   * success
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      workitemTime: 'WorkitemTime',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      workitemTime: CreateWorkitemRecordResponseBodyWorkitemTime,
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemRecordResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWorkitemRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWorkitemRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemV2Request extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 19xxxx31947xxxx
   */
  assignedTo?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Req
   */
  category?: string;
  description?: string;
  fieldValueList?: CreateWorkitemV2RequestFieldValueList[];
  /**
   * @example
   * 11223331122
   */
  parentIdentifier?: string;
  participants?: string[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * asd345xxxxx9q9845xxxxx34
   */
  spaceIdentifier?: string;
  /**
   * @example
   * 455532323455
   */
  sprintIdentifier?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  subject?: string;
  tags?: string[];
  trackers?: string[];
  /**
   * @example
   * 1561159309......
   */
  verifier?: string;
  versions?: string[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 9uy29901re573f561d69jn40
   */
  workitemTypeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      category: 'category',
      description: 'description',
      fieldValueList: 'fieldValueList',
      parentIdentifier: 'parentIdentifier',
      participants: 'participants',
      spaceIdentifier: 'spaceIdentifier',
      sprintIdentifier: 'sprintIdentifier',
      subject: 'subject',
      tags: 'tags',
      trackers: 'trackers',
      verifier: 'verifier',
      versions: 'versions',
      workitemTypeIdentifier: 'workitemTypeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: 'string',
      category: 'string',
      description: 'string',
      fieldValueList: { 'type': 'array', 'itemType': CreateWorkitemV2RequestFieldValueList },
      parentIdentifier: 'string',
      participants: { 'type': 'array', 'itemType': 'string' },
      spaceIdentifier: 'string',
      sprintIdentifier: 'string',
      subject: 'string',
      tags: { 'type': 'array', 'itemType': 'string' },
      trackers: { 'type': 'array', 'itemType': 'string' },
      verifier: 'string',
      versions: { 'type': 'array', 'itemType': 'string' },
      workitemTypeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemV2ResponseBody extends $tea.Model {
  /**
   * @example
   * InvalidTagGroup.IdNotFound
   */
  errorCode?: string;
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorMessage?: string;
  /**
   * @example
   * EAE03103-5497-58D1-9169-E524DDE8604C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: string;
  /**
   * @example
   * 11234455454355
   */
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'string',
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemV2Response extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWorkitemV2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWorkitemV2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * git@codeup.aliyun.com:demo/Codeup-Demo.git
   */
  codeUrl?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * master
   */
  codeVersion?: string;
  /**
   * @example
   * src/Test.java
   */
  filePath?: string;
  /**
   * @example
   * Demo
   */
  name?: string;
  /**
   * @example
   * fc
   */
  requestFrom?: string;
  /**
   * @example
   * acs:fc:cn-shenzhen:XXX:services/demo.LATEST/functions/demo
   */
  resourceIdentifier?: string;
  /**
   * @example
   * false
   */
  reuse?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * all-in-one
   */
  workspaceTemplate?: string;
  static names(): { [key: string]: string } {
    return {
      codeUrl: 'codeUrl',
      codeVersion: 'codeVersion',
      filePath: 'filePath',
      name: 'name',
      requestFrom: 'requestFrom',
      resourceIdentifier: 'resourceIdentifier',
      reuse: 'reuse',
      workspaceTemplate: 'workspaceTemplate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeUrl: 'string',
      codeVersion: 'string',
      filePath: 'string',
      name: 'string',
      requestFrom: 'string',
      resourceIdentifier: 'string',
      reuse: 'boolean',
      workspaceTemplate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceResponseBody extends $tea.Model {
  /**
   * @example
   * WorkspaceQuotaExceeded
   */
  errorCode?: string;
  /**
   * @example
   * The maximum number of workspace per user is exceeded.
   */
  errorMessage?: string;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  workspace?: CreateWorkspaceResponseBodyWorkspace;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
      workspace: 'workspace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      workspace: CreateWorkspaceResponseBodyWorkspace,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWorkspaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWorkspaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAppMemberRequest extends $tea.Model {
  /**
   * @example
   * 66c0c9fffeb86b450c199fcd
   */
  organizationId?: string;
  /**
   * @example
   * 1332695887xxxxxx
   */
  subjectId?: string;
  /**
   * @example
   * User
   */
  subjectType?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'organizationId',
      subjectId: 'subjectId',
      subjectType: 'subjectType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
      subjectId: 'string',
      subjectType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAppMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: string;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBranchRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * deleteBranch
   */
  branchName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 619b80042f595dbd1b9b0de2
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      branchName: 'branchName',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      branchName: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBranchResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 6177543A-8D54-5736-A93B-E0195A1512CB
   */
  requestId?: string;
  result?: DeleteBranchResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteBranchResponseBodyResult,
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBranchResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteBranchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteBranchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFileRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * master
   */
  branchName?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  commitMessage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * src/main/test.java
   */
  filePath?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      branchName: 'branchName',
      commitMessage: 'commitMessage',
      filePath: 'filePath',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      branchName: 'string',
      commitMessage: 'string',
      filePath: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFileResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 7EFAD5FB-2296-5D52-BC60-FCC992A40767
   */
  requestId?: string;
  result?: DeleteFileResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteFileResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowTagResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true 接口调用成功，false 接口调用失败
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowTagResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteFlowTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteFlowTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowTagGroupResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true 接口调用成功，false 接口调用失败
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowTagGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteFlowTagGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteFlowTagGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGroupMemberRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1789095186553536
   */
  aliyunPk?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * USERS
   */
  memberType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 6082a9b0c7972588ac363793
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      aliyunPk: 'aliyunPk',
      memberType: 'memberType',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      aliyunPk: 'string',
      memberType: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGroupMemberResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorMessage?: string;
  /**
   * @example
   * 4D6AF7CC-B43B-5454-86AB-023D25E44868
   */
  requestId?: string;
  result?: DeleteGroupMemberResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteGroupMemberResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGroupMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteGroupMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteGroupMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHostGroupResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHostGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteHostGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteHostGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePipelineResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePipelineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeletePipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeletePipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePipelineGroupResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePipelineGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeletePipelineGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeletePipelineGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePipelineRelationsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 11
   */
  relObjectId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * VARIABLE_GROUP
   */
  relObjectType?: string;
  static names(): { [key: string]: string } {
    return {
      relObjectId: 'relObjectId',
      relObjectType: 'relObjectType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      relObjectId: 'string',
      relObjectType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePipelineRelationsResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePipelineRelationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeletePipelineRelationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeletePipelineRelationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 7fb72727f32143574f7a...
   */
  identifier?: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'identifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  result?: boolean;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      result: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectLabelRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectLabelResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: DeleteProjectLabelResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteProjectLabelResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectLabelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteProjectLabelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteProjectLabelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProtectedBranchRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 611b75680fc7bf0dbe1dce55
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProtectedBranchResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * 1F4F342D-493A-5B2C-B133-BA78B30FF834
   */
  requestId?: string;
  result?: DeleteProtectedBranchResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteProtectedBranchResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProtectedBranchResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteProtectedBranchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteProtectedBranchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePushRuleRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60d54f3daccf2bbd6659f3ad
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePushRuleResponseBody extends $tea.Model {
  /**
   * @example
   * InvalidParam.NotFound
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: DeletePushRuleResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeletePushRuleResponseBodyResult,
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePushRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeletePushRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeletePushRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  reason?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 6082a9b0c7972588ac363793
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      reason: 'reason',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      reason: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * A7586FEB-E48D-5579-983F-74981FBFF627
   */
  requestId?: string;
  result?: DeleteRepositoryResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteRepositoryResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRepositoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRepositoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryGroupRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  reason?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 624666bd54d036291ae13a36
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      reason: 'reason',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      reason: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryGroupResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 30F2DA15-2877-5FC9-BC71-F7F394717907
   */
  requestId?: string;
  result?: DeleteRepositoryGroupResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteRepositoryGroupResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRepositoryGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRepositoryGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryMemberRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @example
   * USERS
   */
  memberType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 632bbfdf419338aaa2b1360a
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      memberType: 'memberType',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      memberType: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryMemberResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 0E1BCF81-51E6-59D4-8D55-FF945111127A
   */
  requestId?: string;
  result?: DeleteRepositoryMemberResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteRepositoryMemberResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRepositoryMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRepositoryMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryWebhookRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryWebhookResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  result?: DeleteRepositoryWebhookResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteRepositoryWebhookResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryWebhookResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRepositoryWebhookResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRepositoryWebhookResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteResourceMemberResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteResourceMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteResourceMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteResourceMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 609633ffd40eb063bac8165a
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * v1.0
   */
  tagName?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      tagName: 'tagName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      tagName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 60945D4F-CF6D-5CFF-89ED-1D1F6657032C
   */
  requestId?: string;
  result?: DeleteTagResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteTagResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserKeyRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserKeyResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: DeleteUserKeyResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: DeleteUserKeyResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserKeyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteUserKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteUserKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteVariableGroupResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteVariableGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteVariableGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteVariableGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkitemRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 3ef2ef6018d254d660e65f87a6
   */
  identifier?: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'identifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkitemResponseBody extends $tea.Model {
  /**
   * @example
   * true/false
   */
  deleteFlag?: boolean;
  /**
   * @example
   * InvalidTagGroup.IdNotFound
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @remarks
   * true/false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      deleteFlag: 'deleteFlag',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deleteFlag: 'boolean',
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkitemResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWorkitemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWorkitemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkitemAllCommentRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * deafe5f33xxxxx6a259d8dafd
   */
  identifier?: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'identifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkitemAllCommentResponseBody extends $tea.Model {
  /**
   * @example
   * true/false
   */
  deleteFlag?: boolean;
  /**
   * @example
   * success
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * A7586FEB-E48D-5579-983F-74981FBFF627
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      deleteFlag: 'deleteFlag',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deleteFlag: 'boolean',
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkitemAllCommentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWorkitemAllCommentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWorkitemAllCommentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkitemCommentRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 12xx34
   */
  commentId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * e8b2xxxxxx2abdxxxxxxxx23
   */
  identifier?: string;
  static names(): { [key: string]: string } {
    return {
      commentId: 'commentId',
      identifier: 'identifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commentId: 'number',
      identifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkitemCommentResponseBody extends $tea.Model {
  /**
   * @example
   * true/false
   */
  deleteFlag?: boolean;
  /**
   * @example
   * success
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      deleteFlag: 'deleteFlag',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deleteFlag: 'boolean',
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkitemCommentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWorkitemCommentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWorkitemCommentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeployKeyRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeployKeyResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: EnableDeployKeyResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: EnableDeployKeyResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeployKeyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EnableDeployKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableDeployKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteChangeRequestReleaseStageRequest extends $tea.Model {
  params?: { [key: string]: any };
  /**
   * @example
   * 66c0c9fffeb86b450c199fcd
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      params: 'params',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      params: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteChangeRequestReleaseStageResponseBody extends $tea.Model {
  /**
   * @example
   * 1
   */
  object?: number;
  /**
   * @example
   * 3259***
   */
  pipelineId?: number;
  /**
   * @example
   * 1
   */
  pipelineRunId?: number;
  static names(): { [key: string]: string } {
    return {
      object: 'object',
      pipelineId: 'pipelineId',
      pipelineRunId: 'pipelineRunId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'number',
      pipelineId: 'number',
      pipelineRunId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteChangeRequestReleaseStageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExecuteChangeRequestReleaseStageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExecuteChangeRequestReleaseStageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightCustomValueRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-06-01 00:00:00
   */
  endTime?: string;
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 1
   */
  nextToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-05-01 00:00:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'endTime',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      startTime: 'startTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      maxResults: 'number',
      nextToken: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightCustomValueResponseBody extends $tea.Model {
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 2
   */
  nextToken?: string;
  result?: ExportInsightCustomValueResponseBodyResult[];
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      result: 'result',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      result: { 'type': 'array', 'itemType': ExportInsightCustomValueResponseBodyResult },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightCustomValueResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExportInsightCustomValueResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportInsightCustomValueResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightExpectedWorkTimeRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-06-01 00:00:00
   */
  endTime?: string;
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 1
   */
  nextToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-05-01 00:00:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'endTime',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      startTime: 'startTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      maxResults: 'number',
      nextToken: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightExpectedWorkTimeResponseBody extends $tea.Model {
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 2
   */
  nextToken?: string;
  result?: ExportInsightExpectedWorkTimeResponseBodyResult[];
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      result: 'result',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      result: { 'type': 'array', 'itemType': ExportInsightExpectedWorkTimeResponseBodyResult },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightExpectedWorkTimeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExportInsightExpectedWorkTimeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportInsightExpectedWorkTimeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightFieldRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-06-01 00:00:00
   */
  endTime?: string;
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 1
   */
  nextToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-05-01 00:00:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'endTime',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      startTime: 'startTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      maxResults: 'number',
      nextToken: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightFieldResponseBody extends $tea.Model {
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 2
   */
  nextToken?: string;
  result?: ExportInsightFieldResponseBodyResult[];
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      result: 'result',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      result: { 'type': 'array', 'itemType': ExportInsightFieldResponseBodyResult },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightFieldResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExportInsightFieldResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportInsightFieldResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightSpaceRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-06-01 00:00:00
   */
  endTime?: string;
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 1
   */
  nextToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-05-01 00:00:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'endTime',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      startTime: 'startTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      maxResults: 'number',
      nextToken: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightSpaceResponseBody extends $tea.Model {
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 2
   */
  nextToken?: string;
  result?: ExportInsightSpaceResponseBodyResult[];
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      result: 'result',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      result: { 'type': 'array', 'itemType': ExportInsightSpaceResponseBodyResult },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightSpaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExportInsightSpaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportInsightSpaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightSpaceRefRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-06-01 00:00:00
   */
  endTime?: string;
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 1
   */
  nextToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-05-01 00:00:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'endTime',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      startTime: 'startTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      maxResults: 'number',
      nextToken: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightSpaceRefResponseBody extends $tea.Model {
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 2
   */
  nextToken?: string;
  result?: ExportInsightSpaceRefResponseBodyResult[];
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      result: 'result',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      result: { 'type': 'array', 'itemType': ExportInsightSpaceRefResponseBodyResult },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightSpaceRefResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExportInsightSpaceRefResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportInsightSpaceRefResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightSprintRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-06-01 00:00:00
   */
  endTime?: string;
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 1
   */
  nextToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-05-01 00:00:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'endTime',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      startTime: 'startTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      maxResults: 'number',
      nextToken: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightSprintResponseBody extends $tea.Model {
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 2
   */
  nextToken?: string;
  result?: ExportInsightSprintResponseBodyResult[];
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      result: 'result',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      result: { 'type': 'array', 'itemType': ExportInsightSprintResponseBodyResult },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightSprintResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExportInsightSprintResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportInsightSprintResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightTagRefRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-06-01 00:00:00
   */
  endTime?: string;
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 1
   */
  nextToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-05-01 00:00:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'endTime',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      startTime: 'startTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      maxResults: 'number',
      nextToken: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightTagRefResponseBody extends $tea.Model {
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 2
   */
  nextToken?: string;
  result?: ExportInsightTagRefResponseBodyResult[];
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      result: 'result',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      result: { 'type': 'array', 'itemType': ExportInsightTagRefResponseBodyResult },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightTagRefResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExportInsightTagRefResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportInsightTagRefResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightWorkTimeRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-06-01 00:00:00
   */
  endTime?: string;
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 1
   */
  nextToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-05-01 00:00:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'endTime',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      startTime: 'startTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      maxResults: 'number',
      nextToken: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightWorkTimeResponseBody extends $tea.Model {
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 2
   */
  nextToken?: string;
  result?: ExportInsightWorkTimeResponseBodyResult[];
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      result: 'result',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      result: { 'type': 'array', 'itemType': ExportInsightWorkTimeResponseBodyResult },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightWorkTimeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExportInsightWorkTimeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportInsightWorkTimeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightWorkitemStatusRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-06-01 00:00:00
   */
  endTime?: string;
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 1
   */
  nextToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-05-01 00:00:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'endTime',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      startTime: 'startTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      maxResults: 'number',
      nextToken: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightWorkitemStatusResponseBody extends $tea.Model {
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 2
   */
  nextToken?: string;
  result?: ExportInsightWorkitemStatusResponseBodyResult[];
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      result: 'result',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      result: { 'type': 'array', 'itemType': ExportInsightWorkitemStatusResponseBodyResult },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightWorkitemStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExportInsightWorkitemStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportInsightWorkitemStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightWorkitemStatusJoinWorkitemDefectExtraRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-06-01 00:00:00
   */
  endTime?: string;
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 1
   */
  nextToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-05-01 00:00:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'endTime',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      startTime: 'startTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      maxResults: 'number',
      nextToken: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody extends $tea.Model {
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 2
   */
  nextToken?: string;
  result?: ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBodyResult[];
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      result: 'result',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      result: { 'type': 'array', 'itemType': ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBodyResult },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightWorkitemVersionRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-06-01 00:00:00
   */
  endTime?: string;
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 1
   */
  nextToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-05-01 00:00:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'endTime',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      startTime: 'startTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      maxResults: 'number',
      nextToken: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightWorkitemVersionResponseBody extends $tea.Model {
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 2
   */
  nextToken?: string;
  result?: ExportInsightWorkitemVersionResponseBodyResult[];
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      result: 'result',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      result: { 'type': 'array', 'itemType': ExportInsightWorkitemVersionResponseBodyResult },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightWorkitemVersionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExportInsightWorkitemVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportInsightWorkitemVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportWorkitemActivityRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-06-01 00:00:00
   */
  endTime?: string;
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 1
   */
  nextToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2024-05-01 00:00:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'endTime',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      startTime: 'startTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      maxResults: 'number',
      nextToken: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportWorkitemActivityResponseBody extends $tea.Model {
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * 2
   */
  nextToken?: string;
  result?: ExportWorkitemActivityResponseBodyResult[];
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      result: 'result',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      result: { 'type': 'array', 'itemType': ExportWorkitemActivityResponseBodyResult },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportWorkitemActivityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExportWorkitemActivityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportWorkitemActivityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FrozenWorkspaceResponseBody extends $tea.Model {
  /**
   * @example
   * InvalidWorkspace.NotFound
   */
  errorCode?: string;
  /**
   * @example
   * The workspace is not found.
   */
  errorMessage?: string;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FrozenWorkspaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: FrozenWorkspaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: FrozenWorkspaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationRequest extends $tea.Model {
  /**
   * @example
   * 66c0c9fffeb86b450c199fcd
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationResponseBody extends $tea.Model {
  /**
   * @example
   * 应用模版展示名称A
   */
  appTemplateDisplayName?: string;
  /**
   * @example
   * 应用模版名称A
   */
  appTemplateName?: string;
  /**
   * @example
   * 1332695887xxxxxx
   */
  creatorAccountId?: string;
  /**
   * @example
   * 应用描述
   */
  description?: string;
  /**
   * @example
   * 2024-01-01T00:00:00.000+00:00
   */
  gmtCreate?: string;
  /**
   * @example
   * testApp
   */
  name?: string;
  /**
   * @example
   * FC93CE1A-8D7A-13A9-8306-7465DE2E5C0F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      appTemplateDisplayName: 'appTemplateDisplayName',
      appTemplateName: 'appTemplateName',
      creatorAccountId: 'creatorAccountId',
      description: 'description',
      gmtCreate: 'gmtCreate',
      name: 'name',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appTemplateDisplayName: 'string',
      appTemplateName: 'string',
      creatorAccountId: 'string',
      description: 'string',
      gmtCreate: 'string',
      name: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetApplicationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetApplicationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBranchInfoRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * master
   */
  branchName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5fbe3118672533690be72b12
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      branchName: 'branchName',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      branchName: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBranchInfoResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 6177543A-8D54-5736-A93B-E0195A1512CB
   */
  requestId?: string;
  result?: GetBranchInfoResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetBranchInfoResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBranchInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetBranchInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetBranchInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRunRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1
   */
  checkRunId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      checkRunId: 'checkRunId',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      checkRunId: 'number',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRunResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: GetCheckRunResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetCheckRunResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRunResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetCheckRunResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCheckRunResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCodeupOrganizationRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCodeupOrganizationResponseBody extends $tea.Model {
  /**
   * @example
   * InvalidTagGroup.IdNotFound
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: GetCodeupOrganizationResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetCodeupOrganizationResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCodeupOrganizationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetCodeupOrganizationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCodeupOrganizationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCompareDetailRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * c9fb781f3d66ef6ee60bdd5c414f5106454b1426
   */
  from?: string;
  /**
   * @example
   * 24 * 1024 * 1024
   */
  maxDiffByte?: number;
  /**
   * @example
   * 5000
   */
  maxDiffFile?: number;
  /**
   * @example
   * false
   */
  mergeBase?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * b8f6f28520b1936aafe2e638373e19ccafa42b02
   */
  to?: string;
  static names(): { [key: string]: string } {
    return {
      from: 'from',
      maxDiffByte: 'maxDiffByte',
      maxDiffFile: 'maxDiffFile',
      mergeBase: 'mergeBase',
      organizationId: 'organizationId',
      to: 'to',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
      maxDiffByte: 'number',
      maxDiffFile: 'number',
      mergeBase: 'boolean',
      organizationId: 'string',
      to: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCompareDetailResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: GetCompareDetailResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetCompareDetailResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCompareDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetCompareDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCompareDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCustomFieldOptionRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  spaceIdentifier?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Project
   */
  spaceType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 9uyxxxx1re573f561dxxxxx
   */
  workitemTypeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      spaceIdentifier: 'spaceIdentifier',
      spaceType: 'spaceType',
      workitemTypeIdentifier: 'workitemTypeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spaceIdentifier: 'string',
      spaceType: 'string',
      workitemTypeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCustomFieldOptionResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  fileds?: GetCustomFieldOptionResponseBodyFileds[];
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      fileds: 'fileds',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      fileds: { 'type': 'array', 'itemType': GetCustomFieldOptionResponseBodyFileds },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCustomFieldOptionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetCustomFieldOptionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCustomFieldOptionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileBlobsRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * src/Test.java
   */
  filePath?: string;
  /**
   * @example
   * 10
   */
  from?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * master  / tag1.0 /  ecykhdd
   */
  ref?: string;
  /**
   * @example
   * 10
   */
  to?: number;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      filePath: 'filePath',
      from: 'from',
      organizationId: 'organizationId',
      ref: 'ref',
      to: 'to',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      filePath: 'string',
      from: 'number',
      organizationId: 'string',
      ref: 'string',
      to: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileBlobsResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * F590C9D8-E908-5B6C-95AC-56B7E8011FFA
   */
  requestId?: string;
  result?: GetFileBlobsResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetFileBlobsResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileBlobsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetFileBlobsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFileBlobsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileLastCommitRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * src/main/test.java
   */
  filePath?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * master
   */
  sha?: string;
  /**
   * @example
   * false
   */
  showSignature?: boolean;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      filePath: 'filePath',
      organizationId: 'organizationId',
      sha: 'sha',
      showSignature: 'showSignature',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      filePath: 'string',
      organizationId: 'string',
      sha: 'string',
      showSignature: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileLastCommitResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  result?: GetFileLastCommitResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetFileLastCommitResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileLastCommitResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetFileLastCommitResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFileLastCommitResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFlowTagGroupResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  flowTagGroup?: GetFlowTagGroupResponseBodyFlowTagGroup;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true 接口调用成功，false 接口调用失败
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      flowTagGroup: 'flowTagGroup',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      flowTagGroup: GetFlowTagGroupResponseBodyFlowTagGroup,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFlowTagGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetFlowTagGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFlowTagGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGroupByPathRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957/test-group
   */
  identity?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      identity: 'identity',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identity: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGroupByPathResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 6177543A-8D54-5736-A93B-E0195A1512CB
   */
  requestId?: string;
  result?: GetGroupByPathResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetGroupByPathResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGroupByPathResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetGroupByPathResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetGroupByPathResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGroupDetailRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 36612
   */
  groupId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 6218766746d4d2ca636d0497
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      groupId: 'groupId',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      groupId: 'number',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGroupDetailResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 4CA06B0B-5867-5DE6-A0FA-9F39C97B524C
   */
  requestId?: string;
  result?: GetGroupDetailResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetGroupDetailResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGroupDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetGroupDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetGroupDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHostGroupResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  hostGroup?: GetHostGroupResponseBodyHostGroup;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      hostGroup: 'hostGroup',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      hostGroup: GetHostGroupResponseBodyHostGroup,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHostGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetHostGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetHostGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  result?: GetMergeRequestResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetMergeRequestResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMergeRequestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMergeRequestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestChangeTreeRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5e733626d53f4b04a6aa0e23d4ff72b8
   */
  fromPatchSetBizId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 7
   */
  localId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  repositoryIdentity?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 513fcfd81a9142d2bb0db4f72c0aa15b
   */
  toPatchSetBizId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      fromPatchSetBizId: 'fromPatchSetBizId',
      localId: 'localId',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
      toPatchSetBizId: 'toPatchSetBizId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      fromPatchSetBizId: 'string',
      localId: 'number',
      organizationId: 'string',
      repositoryIdentity: 'string',
      toPatchSetBizId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestChangeTreeResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * HC93CE1A-8D7A-13A9-8306-7465DE2E5C0F
   */
  requestId?: string;
  result?: GetMergeRequestChangeTreeResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetMergeRequestChangeTreeResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestChangeTreeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMergeRequestChangeTreeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMergeRequestChangeTreeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrganizationMemberResponseBody extends $tea.Model {
  /**
   * @example
   * null
   */
  errorCode?: string;
  /**
   * @example
   * error info
   */
  errorMessage?: string;
  member?: GetOrganizationMemberResponseBodyMember;
  /**
   * @example
   * HC93CE1A-8D7A-13A9-8306-7465DE2E5C0F
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      member: 'member',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      member: GetOrganizationMemberResponseBodyMember,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrganizationMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOrganizationMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOrganizationMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  pipeline?: GetPipelineResponseBodyPipeline;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      pipeline: 'pipeline',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      pipeline: GetPipelineResponseBodyPipeline,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineArtifactUrlRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test.tgz
   */
  fileName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * /test/test/test.tgz
   */
  filePath?: string;
  static names(): { [key: string]: string } {
    return {
      fileName: 'fileName',
      filePath: 'filePath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileName: 'string',
      filePath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineArtifactUrlResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * http://aliyun.com/
   */
  fileUrl?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true 接口调用成功，false 接口调用失败
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      fileUrl: 'fileUrl',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      fileUrl: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineArtifactUrlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPipelineArtifactUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPipelineArtifactUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineEmasArtifactUrlRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 122
   */
  serviceConnectionId?: number;
  static names(): { [key: string]: string } {
    return {
      serviceConnectionId: 'serviceConnectionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceConnectionId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineEmasArtifactUrlResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * http://aliyun.com
   */
  fileUrl?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true 接口调用成功，false 接口调用失败
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      fileUrl: 'fileUrl',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      fileUrl: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineEmasArtifactUrlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPipelineEmasArtifactUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPipelineEmasArtifactUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineGroupResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  pipelineGroup?: GetPipelineGroupResponseBodyPipelineGroup;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      pipelineGroup: 'pipelineGroup',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      pipelineGroup: GetPipelineGroupResponseBodyPipelineGroup,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPipelineGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPipelineGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineRunResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  pipelineRun?: GetPipelineRunResponseBodyPipelineRun;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      pipelineRun: 'pipelineRun',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      pipelineRun: GetPipelineRunResponseBodyPipelineRun,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineRunResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPipelineRunResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPipelineRunResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineScanReportUrlRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * /test/test/test.html
   */
  reportPath?: string;
  static names(): { [key: string]: string } {
    return {
      reportPath: 'reportPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reportPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineScanReportUrlResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * http://aliyun.com
   */
  reportUrl?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true 接口调用成功，false 接口调用失败
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      reportUrl: 'reportUrl',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      reportUrl: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineScanReportUrlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPipelineScanReportUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPipelineScanReportUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectInfoResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMessage?: string;
  project?: GetProjectInfoResponseBodyProject;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      project: 'project',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      project: GetProjectInfoResponseBodyProject,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetProjectInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetProjectInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectMemberRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5eb53bb338076f00011bcfd5
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectMemberResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 30C99C69-A340-5E2E-ACE4-8888FF50CF52
   */
  requestId?: string;
  result?: GetProjectMemberResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetProjectMemberResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetProjectMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetProjectMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPushRuleRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPushRuleResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  result?: GetPushRuleResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetPushRuleResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPushRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPushRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPushRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReleaseStagePipelineRunRequest extends $tea.Model {
  /**
   * @example
   * 66c0c9fffeb86b450c199fcd
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReleaseStagePipelineRunResponseBody extends $tea.Model {
  pipelineRun?: GetReleaseStagePipelineRunResponseBodyPipelineRun;
  static names(): { [key: string]: string } {
    return {
      pipelineRun: 'pipelineRun',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pipelineRun: GetReleaseStagePipelineRunResponseBodyPipelineRun,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReleaseStagePipelineRunResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetReleaseStagePipelineRunResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetReleaseStagePipelineRunResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 100
   */
  identity?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      identity: 'identity',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      identity: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  repository?: GetRepositoryResponseBodyRepository;
  /**
   * @example
   * 37294673-00CA-5B8B-914F-A8B35511E90A
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      repository: 'repository',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      repository: GetRepositoryResponseBodyRepository,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRepositoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRepositoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryCommitRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  /**
   * @example
   * false
   */
  showSignature?: boolean;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      showSignature: 'showSignature',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      showSignature: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryCommitResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * A7586FEB-E48D-5579-983F-74981FBFF627
   */
  requestId?: string;
  result?: GetRepositoryCommitResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetRepositoryCommitResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryCommitResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRepositoryCommitResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRepositoryCommitResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryTagRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * tag v1.0
   */
  tagName?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      tagName: 'tagName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      tagName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryTagResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * CE7353E3-F989-56A9-B97C-897ABBDB9A01
   */
  requestId?: string;
  result?: GetRepositoryTagResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetRepositoryTagResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryTagResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRepositoryTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRepositoryTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSearchCodePreviewRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60d54f3daccf2bbd6659f3ad/gitlabhq/master/config/environments/test.rb
   */
  docId?: string;
  /**
   * @example
   * false
   */
  isDsl?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test
   */
  keyword?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 627475075b46541dd2ff01bc
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      docId: 'docId',
      isDsl: 'isDsl',
      keyword: 'keyword',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      docId: 'string',
      isDsl: 'boolean',
      keyword: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSearchCodePreviewResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * A7586FEB-E48D-5579-983F-74981FBFF627
   */
  requestId?: string;
  result?: GetSearchCodePreviewResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetSearchCodePreviewResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSearchCodePreviewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSearchCodePreviewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSearchCodePreviewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSprintInfoResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  sprint?: GetSprintInfoResponseBodySprint;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      sprint: 'sprint',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      sprint: GetSprintInfoResponseBodySprint,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSprintInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSprintInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSprintInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestResultListRequest extends $tea.Model {
  /**
   * @example
   * {\\"conditionGroups\\": [[{\\"fieldIdentifier\\": \\"gmtModified\\", \\"operator\\": \\"MORE_THAN_AND_EQUAL\\", \\"value\\": [\\"2023-04-20 18:03:12.442140\\"], \\"className\\": \\"dateTime\\", \\"format\\": \\"input\\"}]]}
   */
  conditions?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * e27b8eace6501ce51cf5d56784
   */
  directoryIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      conditions: 'conditions',
      directoryIdentifier: 'directoryIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conditions: 'string',
      directoryIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestResultListResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  testResult?: GetTestResultListResponseBodyTestResult[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
      testResult: 'testResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
      testResult: { 'type': 'array', 'itemType': GetTestResultListResponseBodyTestResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestResultListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTestResultListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTestResultListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestcaseListRequest extends $tea.Model {
  /**
   * @example
   * {\\"conditionGroups\\":[[{\\"fieldIdentifier\\":\\"status\\",\\"operator\\":\\"CONTAINS\\",\\"value\\":[\\"cc961a18adf770c6e423ccc5\\"],\\"toValue\\":null,,\\"className\\":\\"status\\",\\"format\\":\\"list\\"}]]}
   */
  conditions?: string;
  /**
   * @example
   * e27b8eace6501ce51cf5d56784
   */
  directoryIdentifier?: string;
  /**
   * @example
   * 20
   */
  maxResult?: string;
  /**
   * @example
   * 2591861102250c4522380b33a6
   */
  nextToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 6d5984c7d92b23fa53d4743c37
   */
  spaceIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      conditions: 'conditions',
      directoryIdentifier: 'directoryIdentifier',
      maxResult: 'maxResult',
      nextToken: 'nextToken',
      spaceIdentifier: 'spaceIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conditions: 'string',
      directoryIdentifier: 'string',
      maxResult: 'string',
      nextToken: 'string',
      spaceIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestcaseListResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @example
   * ""
   */
  nextToken?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  testcase?: GetTestcaseListResponseBodyTestcase[];
  /**
   * @example
   * 10
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      requestId: 'requestId',
      success: 'success',
      testcase: 'testcase',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      success: 'boolean',
      testcase: { 'type': 'array', 'itemType': GetTestcaseListResponseBodyTestcase },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestcaseListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTestcaseListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTestcaseListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserInfoRequest extends $tea.Model {
  /**
   * @example
   * 61e54b0e0bb300d827e1ae27
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserInfoResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  result?: GetUserInfoResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: GetUserInfoResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetUserInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetUserInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVMDeployOrderResponseBody extends $tea.Model {
  deployOrder?: GetVMDeployOrderResponseBodyDeployOrder;
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true 接口调用成功，false 接口调用失败
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      deployOrder: 'deployOrder',
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deployOrder: GetVMDeployOrderResponseBodyDeployOrder,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVMDeployOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetVMDeployOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetVMDeployOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVariableGroupResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  variableGroup?: GetVariableGroupResponseBodyVariableGroup;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
      variableGroup: 'variableGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      variableGroup: GetVariableGroupResponseBodyVariableGroup,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVariableGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetVariableGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetVariableGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemActivityResponseBody extends $tea.Model {
  activities?: GetWorkItemActivityResponseBodyActivities[];
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      activities: 'activities',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activities: { 'type': 'array', 'itemType': GetWorkItemActivityResponseBodyActivities },
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemActivityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWorkItemActivityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWorkItemActivityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemInfoResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  workitem?: GetWorkItemInfoResponseBodyWorkitem;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
      workitem: 'workitem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      workitem: GetWorkItemInfoResponseBodyWorkitem,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWorkItemInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWorkItemInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemWorkFlowInfoRequest extends $tea.Model {
  /**
   * @example
   * 711d33c738b9171c45fa......
   */
  configurationId?: string;
  static names(): { [key: string]: string } {
    return {
      configurationId: 'configurationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configurationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemWorkFlowInfoResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  workflow?: GetWorkItemWorkFlowInfoResponseBodyWorkflow;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
      workflow: 'workflow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      workflow: GetWorkItemWorkFlowInfoResponseBodyWorkflow,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemWorkFlowInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWorkItemWorkFlowInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWorkItemWorkFlowInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemAttachmentCreatemetaRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * application.jar
   */
  fileName?: string;
  static names(): { [key: string]: string } {
    return {
      fileName: 'fileName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemAttachmentCreatemetaResponseBody extends $tea.Model {
  /**
   * @example
   * Invalid.IdNotFound
   */
  errorCode?: string;
  /**
   * @example
   * Forbidden.UserNotInCurrentOrganization
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: string;
  uploadInfo?: GetWorkitemAttachmentCreatemetaResponseBodyUploadInfo;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
      uploadInfo: 'uploadInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'string',
      uploadInfo: GetWorkitemAttachmentCreatemetaResponseBodyUploadInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemAttachmentCreatemetaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWorkitemAttachmentCreatemetaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWorkitemAttachmentCreatemetaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemCommentListResponseBody extends $tea.Model {
  commentList?: GetWorkitemCommentListResponseBodyCommentList[];
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  success?: string;
  static names(): { [key: string]: string } {
    return {
      commentList: 'commentList',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commentList: { 'type': 'array', 'itemType': GetWorkitemCommentListResponseBodyCommentList },
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemCommentListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWorkitemCommentListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWorkitemCommentListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemFileResponseBody extends $tea.Model {
  /**
   * @example
   * success
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: string;
  workitemFile?: GetWorkitemFileResponseBodyWorkitemFile;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
      workitemFile: 'workitemFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'string',
      workitemFile: GetWorkitemFileResponseBodyWorkitemFile,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWorkitemFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWorkitemFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemRelationsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  relationType?: string;
  static names(): { [key: string]: string } {
    return {
      relationType: 'relationType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      relationType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemRelationsResponseBody extends $tea.Model {
  /**
   * @example
   * InvalidGroup.IdNotFound
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  relationList?: GetWorkitemRelationsResponseBodyRelationList[];
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      relationList: 'relationList',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      relationList: { 'type': 'array', 'itemType': GetWorkitemRelationsResponseBodyRelationList },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemRelationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWorkitemRelationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWorkitemRelationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemTimeTypeListResponseBody extends $tea.Model {
  /**
   * @example
   * Invalid.IdNotFound
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * HC93CE1A-8D7A-13A9-8306-7465DE2E5C0F
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: string;
  timeType?: GetWorkitemTimeTypeListResponseBodyTimeType[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
      timeType: 'timeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'string',
      timeType: { 'type': 'array', 'itemType': GetWorkitemTimeTypeListResponseBodyTimeType },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemTimeTypeListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWorkitemTimeTypeListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWorkitemTimeTypeListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspaceResponseBody extends $tea.Model {
  /**
   * @example
   * InvalidWorkspace.NotFound
   */
  errorCode?: string;
  /**
   * @example
   * The workspace is not found.
   */
  errorMessage?: string;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  workspace?: GetWorkspaceResponseBodyWorkspace;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
      workspace: 'workspace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      workspace: GetWorkspaceResponseBodyWorkspace,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWorkspaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWorkspaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinPipelineGroupRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 11
   */
  groupId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 122,122
   */
  pipelineIds?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'groupId',
      pipelineIds: 'pipelineIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      pipelineIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinPipelineGroupResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinPipelineGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: JoinPipelineGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: JoinPipelineGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LinkMergeRequestLabelRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  labelIds?: string[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1
   */
  localId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      labelIds: 'labelIds',
      localId: 'localId',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      labelIds: { 'type': 'array', 'itemType': 'string' },
      localId: 'number',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LinkMergeRequestLabelResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: LinkMergeRequestLabelResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: LinkMergeRequestLabelResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LinkMergeRequestLabelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: LinkMergeRequestLabelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: LinkMergeRequestLabelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllReleaseWorkflowsRequest extends $tea.Model {
  /**
   * @example
   * 66c0c9fffeb86b450c199fcd
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllReleaseWorkflowsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListAllReleaseWorkflowsResponseBody[];
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: { 'type': 'array', 'itemType': ListAllReleaseWorkflowsResponseBody },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAppReleaseStageExecutionIntegratedMetadataRequest extends $tea.Model {
  /**
   * @example
   * 66c0c9fffeb86b450c199fcd
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAppReleaseStageExecutionIntegratedMetadataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListAppReleaseStageExecutionIntegratedMetadataResponseBody[];
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: { 'type': 'array', 'itemType': ListAppReleaseStageExecutionIntegratedMetadataResponseBody },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAppReleaseStageExecutionsRequest extends $tea.Model {
  /**
   * @example
   * ""
   */
  nextToken?: string;
  /**
   * @example
   * gmtCreate
   */
  orderBy?: string;
  /**
   * @example
   * 66c0c9fffeb86b450c199fcd
   */
  organizationId?: string;
  /**
   * @example
   * 1
   */
  page?: number;
  /**
   * @example
   * keyset
   */
  pagination?: string;
  /**
   * @example
   * 20
   */
  perPage?: number;
  /**
   * @example
   * desc
   */
  sort?: string;
  static names(): { [key: string]: string } {
    return {
      nextToken: 'nextToken',
      orderBy: 'orderBy',
      organizationId: 'organizationId',
      page: 'page',
      pagination: 'pagination',
      perPage: 'perPage',
      sort: 'sort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      orderBy: 'string',
      organizationId: 'string',
      page: 'number',
      pagination: 'string',
      perPage: 'number',
      sort: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAppReleaseStageExecutionsResponseBody extends $tea.Model {
  /**
   * @example
   * 1
   */
  current?: number;
  data?: ListAppReleaseStageExecutionsResponseBodyData[];
  /**
   * @example
   * vxc2341gfssad12
   */
  nextToken?: string;
  /**
   * @example
   * 1
   */
  pages?: number;
  /**
   * @example
   * 20
   */
  perPage?: number;
  /**
   * @example
   * 2
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      current: 'current',
      data: 'data',
      nextToken: 'nextToken',
      pages: 'pages',
      perPage: 'perPage',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      current: 'number',
      data: { 'type': 'array', 'itemType': ListAppReleaseStageExecutionsResponseBodyData },
      nextToken: 'string',
      pages: 'number',
      perPage: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAppReleaseStageExecutionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListAppReleaseStageExecutionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAppReleaseStageExecutionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationMembersRequest extends $tea.Model {
  /**
   * @example
   * 66c0c9fffeb86b450c199fcd
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationMembersResponseBody extends $tea.Model {
  /**
   * @example
   * 1
   */
  current?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * 10
   */
  pages?: number;
  records?: ListApplicationMembersResponseBodyRecords[];
  /**
   * @example
   * FC93CE1A-8D7A-13A9-8306-7465DE2E5C0F
   */
  requestId?: string;
  /**
   * @example
   * 100
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      current: 'current',
      pageSize: 'pageSize',
      pages: 'pages',
      records: 'records',
      requestId: 'requestId',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      current: 'number',
      pageSize: 'number',
      pages: 'number',
      records: { 'type': 'array', 'itemType': ListApplicationMembersResponseBodyRecords },
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListApplicationMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListApplicationMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsRequest extends $tea.Model {
  /**
   * @example
   * vxc2341gfssad12
   */
  nextToken?: string;
  /**
   * @example
   * asc
   */
  orderBy?: string;
  /**
   * @example
   * 66c0c9fffeb86b450c199fcd
   */
  organizationId?: string;
  /**
   * @example
   * keyset
   */
  pagination?: string;
  /**
   * @example
   * 20
   */
  perPage?: number;
  /**
   * @example
   * id
   */
  sort?: string;
  static names(): { [key: string]: string } {
    return {
      nextToken: 'nextToken',
      orderBy: 'orderBy',
      organizationId: 'organizationId',
      pagination: 'pagination',
      perPage: 'perPage',
      sort: 'sort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      orderBy: 'string',
      organizationId: 'string',
      pagination: 'string',
      perPage: 'number',
      sort: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsResponseBody extends $tea.Model {
  data?: ListApplicationsResponseBodyData[];
  /**
   * @example
   * vxc2341gfssad12
   */
  nextToken?: string;
  /**
   * @example
   * FC93CE1A-8D7A-13A9-8306-7465DE2E5C0F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      nextToken: 'nextToken',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListApplicationsResponseBodyData },
      nextToken: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListApplicationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListApplicationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListChangeRequestWorkflowExecutionsRequest extends $tea.Model {
  /**
   * @example
   * id
   */
  orderBy?: string;
  /**
   * @example
   * 66c0c9fffeb86b450c199fcd
   */
  organizationId?: string;
  /**
   * @example
   * 1
   */
  page?: number;
  /**
   * @example
   * 20
   */
  perPage?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * e173f3c11db5445eb426ca33c92207c8
   */
  releaseStageSn?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ce51b31b996246ecaf874736838360b2
   */
  releaseWorkflowSn?: string;
  /**
   * @example
   * desc
   */
  sort?: string;
  static names(): { [key: string]: string } {
    return {
      orderBy: 'orderBy',
      organizationId: 'organizationId',
      page: 'page',
      perPage: 'perPage',
      releaseStageSn: 'releaseStageSn',
      releaseWorkflowSn: 'releaseWorkflowSn',
      sort: 'sort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderBy: 'string',
      organizationId: 'string',
      page: 'number',
      perPage: 'number',
      releaseStageSn: 'string',
      releaseWorkflowSn: 'string',
      sort: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListChangeRequestWorkflowExecutionsResponseBody extends $tea.Model {
  /**
   * @example
   * 1
   */
  current?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * 10
   */
  pages?: number;
  records?: any[];
  /**
   * @example
   * 200
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      current: 'current',
      pageSize: 'pageSize',
      pages: 'pages',
      records: 'records',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      current: 'number',
      pageSize: 'number',
      pages: 'number',
      records: { 'type': 'array', 'itemType': 'any' },
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListChangeRequestWorkflowExecutionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListChangeRequestWorkflowExecutionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListChangeRequestWorkflowExecutionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListChangeRequestsRequest extends $tea.Model {
  appNameList?: string[];
  /**
   * @example
   * change1
   */
  displayNameKeyword?: string;
  /**
   * @example
   * 4dc150725770510122396e2476
   */
  nextToken?: string;
  /**
   * @example
   * id
   */
  orderBy?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 66c0c9fffeb86b450c199fcd
   */
  organizationId?: string;
  ownerIdList?: string[];
  /**
   * @example
   * 1
   */
  page?: number;
  /**
   * @example
   * keyset
   */
  pagination?: string;
  /**
   * @example
   * 20
   */
  perPage?: number;
  /**
   * @example
   * desc
   */
  sort?: string;
  stateList?: string[];
  static names(): { [key: string]: string } {
    return {
      appNameList: 'appNameList',
      displayNameKeyword: 'displayNameKeyword',
      nextToken: 'nextToken',
      orderBy: 'orderBy',
      organizationId: 'organizationId',
      ownerIdList: 'ownerIdList',
      page: 'page',
      pagination: 'pagination',
      perPage: 'perPage',
      sort: 'sort',
      stateList: 'stateList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appNameList: { 'type': 'array', 'itemType': 'string' },
      displayNameKeyword: 'string',
      nextToken: 'string',
      orderBy: 'string',
      organizationId: 'string',
      ownerIdList: { 'type': 'array', 'itemType': 'string' },
      page: 'number',
      pagination: 'string',
      perPage: 'number',
      sort: 'string',
      stateList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListChangeRequestsShrinkRequest extends $tea.Model {
  appNameListShrink?: string;
  /**
   * @example
   * change1
   */
  displayNameKeyword?: string;
  /**
   * @example
   * 4dc150725770510122396e2476
   */
  nextToken?: string;
  /**
   * @example
   * id
   */
  orderBy?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 66c0c9fffeb86b450c199fcd
   */
  organizationId?: string;
  ownerIdListShrink?: string;
  /**
   * @example
   * 1
   */
  page?: number;
  /**
   * @example
   * keyset
   */
  pagination?: string;
  /**
   * @example
   * 20
   */
  perPage?: number;
  /**
   * @example
   * desc
   */
  sort?: string;
  stateListShrink?: string;
  static names(): { [key: string]: string } {
    return {
      appNameListShrink: 'appNameList',
      displayNameKeyword: 'displayNameKeyword',
      nextToken: 'nextToken',
      orderBy: 'orderBy',
      organizationId: 'organizationId',
      ownerIdListShrink: 'ownerIdList',
      page: 'page',
      pagination: 'pagination',
      perPage: 'perPage',
      sort: 'sort',
      stateListShrink: 'stateList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appNameListShrink: 'string',
      displayNameKeyword: 'string',
      nextToken: 'string',
      orderBy: 'string',
      organizationId: 'string',
      ownerIdListShrink: 'string',
      page: 'number',
      pagination: 'string',
      perPage: 'number',
      sort: 'string',
      stateListShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListChangeRequestsResponseBody extends $tea.Model {
  /**
   * @example
   * 1
   */
  current?: number;
  data?: any[];
  /**
   * @example
   * eb13ac6049d3d78159d60f84af
   */
  nextToken?: string;
  /**
   * @example
   * 5
   */
  pages?: number;
  /**
   * @example
   * 20
   */
  perPage?: number;
  /**
   * @example
   * 100
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      current: 'current',
      data: 'data',
      nextToken: 'nextToken',
      pages: 'pages',
      perPage: 'perPage',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      current: 'number',
      data: { 'type': 'array', 'itemType': 'any' },
      nextToken: 'string',
      pages: 'number',
      perPage: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListChangeRequestsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListChangeRequestsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListChangeRequestsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckRunsRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  /**
   * @example
   * 1
   */
  page?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 40f4ccfe019cdd4a62d4acb0c57130106fc7e1be
   */
  ref?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      ref: 'ref',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      ref: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckRunsResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: ListCheckRunsResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListCheckRunsResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckRunsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCheckRunsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCheckRunsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCommitStatusesRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  /**
   * @example
   * 1
   */
  page?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * This parameter is required.
   */
  repositoryIdentity?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 61cc69557962d29f737a91730b3e86f497f083a3
   */
  sha?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      repositoryIdentity: 'repositoryIdentity',
      sha: 'sha',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      repositoryIdentity: 'string',
      sha: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCommitStatusesResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: ListCommitStatusesResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 28
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListCommitStatusesResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCommitStatusesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCommitStatusesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCommitStatusesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowTagGroupsResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  flowTagGroups?: ListFlowTagGroupsResponseBodyFlowTagGroups[];
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true 接口调用成功，false 接口调用失败
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      flowTagGroups: 'flowTagGroups',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      flowTagGroups: { 'type': 'array', 'itemType': ListFlowTagGroupsResponseBodyFlowTagGroups },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowTagGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListFlowTagGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListFlowTagGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGroupMemberRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 632bbfdf419338aaa2b1360a
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGroupMemberResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * C8F8B434-B006-59FB-8B9C-0382CF3D5680
   */
  requestId?: string;
  result?: ListGroupMemberResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListGroupMemberResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGroupMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListGroupMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListGroupMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGroupRepositoriesRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60ee8a814690c27532d412f8
   */
  organizationId?: string;
  /**
   * @example
   * 1
   */
  page?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * Demo
   */
  search?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      search: 'search',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      search: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGroupRepositoriesResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 9293CBDA-B5BC-5AD6-A8F4-C7873AC7A3DF
   */
  requestId?: string;
  result?: ListGroupRepositoriesResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 2
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListGroupRepositoriesResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGroupRepositoriesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListGroupRepositoriesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListGroupRepositoriesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHostGroupsRequest extends $tea.Model {
  /**
   * @example
   * 1586863220000
   */
  createEndTime?: number;
  /**
   * @example
   * 1586863220000
   */
  createStartTime?: number;
  /**
   * @example
   * 1112122121,3223332
   */
  creatorAccountIds?: string;
  /**
   * @example
   * 121,1212121232
   */
  ids?: string;
  /**
   * @example
   * 30
   */
  maxResults?: number;
  /**
   * @example
   * 主机组
   */
  name?: string;
  /**
   * @example
   * 221212221
   */
  nextToken?: string;
  /**
   * @example
   * DESC
   */
  pageOrder?: string;
  /**
   * @example
   * ID
   */
  pageSort?: string;
  static names(): { [key: string]: string } {
    return {
      createEndTime: 'createEndTime',
      createStartTime: 'createStartTime',
      creatorAccountIds: 'creatorAccountIds',
      ids: 'ids',
      maxResults: 'maxResults',
      name: 'name',
      nextToken: 'nextToken',
      pageOrder: 'pageOrder',
      pageSort: 'pageSort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createEndTime: 'number',
      createStartTime: 'number',
      creatorAccountIds: 'string',
      ids: 'string',
      maxResults: 'number',
      name: 'string',
      nextToken: 'string',
      pageOrder: 'string',
      pageSort: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHostGroupsResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  hostGroups?: ListHostGroupsResponseBodyHostGroups[];
  /**
   * @example
   * asassasassa
   */
  nextToken?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 50
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      hostGroups: 'hostGroups',
      nextToken: 'nextToken',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      hostGroups: { 'type': 'array', 'itemType': ListHostGroupsResponseBodyHostGroups },
      nextToken: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHostGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListHostGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListHostGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJoinedOrganizationsResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  organizations?: ListJoinedOrganizationsResponseBodyOrganizations[];
  /**
   * @example
   * 11D0EE6E-5803-5D4C-A652-E672BE1F3D8E
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      organizations: 'organizations',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      organizations: { 'type': 'array', 'itemType': ListJoinedOrganizationsResponseBodyOrganizations },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJoinedOrganizationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListJoinedOrganizationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListJoinedOrganizationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @example
   * GLOBAL_COMMENT
   */
  commentType?: string;
  /**
   * @example
   * /src/main/test.java
   */
  filePath?: string;
  patchSetBizIds?: string[];
  /**
   * @example
   * false
   */
  resolved?: boolean;
  /**
   * @example
   * OPENED
   */
  state?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 10
   */
  localId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      commentType: 'commentType',
      filePath: 'filePath',
      patchSetBizIds: 'patchSetBizIds',
      resolved: 'resolved',
      state: 'state',
      localId: 'localId',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      commentType: 'string',
      filePath: 'string',
      patchSetBizIds: { 'type': 'array', 'itemType': 'string' },
      resolved: 'boolean',
      state: 'string',
      localId: 'number',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 56C33A95-C04F-59F0-B3CD-E2A2EB9FADBB
   */
  requestId?: string;
  result?: ListMergeRequestCommentsResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListMergeRequestCommentsResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListMergeRequestCommentsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListMergeRequestCommentsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestFilesReadsRequest extends $tea.Model {
  /**
   * @example
   * agp_4d57a6796b3626f52064ab1fba5384a5
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5e733626d53f4b04a6aa0e23d4ff72b8
   */
  fromPatchSetBizId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5
   */
  localId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  repositoryIdentity?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 513fcfd81a9142d2bb0db4f72c0aa15b
   */
  toPatchSetBizId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      fromPatchSetBizId: 'fromPatchSetBizId',
      localId: 'localId',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
      toPatchSetBizId: 'toPatchSetBizId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      fromPatchSetBizId: 'string',
      localId: 'number',
      organizationId: 'string',
      repositoryIdentity: 'string',
      toPatchSetBizId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestFilesReadsResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: ListMergeRequestFilesReadsResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListMergeRequestFilesReadsResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestFilesReadsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListMergeRequestFilesReadsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListMergeRequestFilesReadsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestLabelsRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1
   */
  localId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      localId: 'localId',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      localId: 'number',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestLabelsResponseBody extends $tea.Model {
  /**
   * @example
   * Invalid.IdNotFound
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 4D6AF7CC-B43B-5454-86AB-023D25E44868
   */
  requestId?: string;
  result?: ListMergeRequestLabelsResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListMergeRequestLabelsResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestLabelsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListMergeRequestLabelsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListMergeRequestLabelsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestPatchSetsRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 4
   */
  localId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      localId: 'localId',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      localId: 'number',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestPatchSetsResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  result?: ListMergeRequestPatchSetsResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListMergeRequestPatchSetsResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestPatchSetsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListMergeRequestPatchSetsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListMergeRequestPatchSetsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestsRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @example
   * 1234567890
   */
  authorIds?: string;
  createdAfter?: string;
  createdBefore?: string;
  /**
   * @example
   * new
   */
  filter?: string;
  /**
   * @example
   * 889910, 889911
   */
  groupIds?: string;
  labelIds?: string;
  /**
   * @example
   * updated_at
   */
  orderBy?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  /**
   * @example
   * 1
   */
  page?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * 2308912, 2308913
   */
  projectIds?: string;
  /**
   * @example
   * 1234567890123
   */
  reviewerIds?: string;
  /**
   * @example
   * test-search
   */
  search?: string;
  /**
   * @example
   * desc
   */
  sort?: string;
  /**
   * @example
   * opened
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      authorIds: 'authorIds',
      createdAfter: 'createdAfter',
      createdBefore: 'createdBefore',
      filter: 'filter',
      groupIds: 'groupIds',
      labelIds: 'labelIds',
      orderBy: 'orderBy',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      projectIds: 'projectIds',
      reviewerIds: 'reviewerIds',
      search: 'search',
      sort: 'sort',
      state: 'state',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      authorIds: 'string',
      createdAfter: 'string',
      createdBefore: 'string',
      filter: 'string',
      groupIds: 'string',
      labelIds: 'string',
      orderBy: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      projectIds: 'string',
      reviewerIds: 'string',
      search: 'string',
      sort: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestsResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: ListMergeRequestsResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 30
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListMergeRequestsResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListMergeRequestsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListMergeRequestsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrganizationMembersRequest extends $tea.Model {
  /**
   * @remarks
   * 返回信息中是否包含第三方信息，默认不包含。
   */
  containsExternInfo?: boolean;
  /**
   * @example
   * 1236666
   */
  externUid?: string;
  /**
   * @example
   * 1631845101798
   */
  joinTimeFrom?: number;
  /**
   * @example
   * 1631845101798
   */
  joinTimeTo?: number;
  /**
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @example
   * ""
   */
  nextToken?: string;
  organizationMemberName?: string;
  /**
   * @example
   * Dingtalk
   */
  provider?: string;
  /**
   * @example
   * normal
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      containsExternInfo: 'containsExternInfo',
      externUid: 'externUid',
      joinTimeFrom: 'joinTimeFrom',
      joinTimeTo: 'joinTimeTo',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      organizationMemberName: 'organizationMemberName',
      provider: 'provider',
      state: 'state',
    };
  }

  static types(): { [key: string]: any } {
    return {
      containsExternInfo: 'boolean',
      externUid: 'string',
      joinTimeFrom: 'number',
      joinTimeTo: 'number',
      maxResults: 'number',
      nextToken: 'string',
      organizationMemberName: 'string',
      provider: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrganizationMembersResponseBody extends $tea.Model {
  /**
   * @example
   * null
   */
  errorCode?: string;
  /**
   * @example
   * error info
   */
  errorMessage?: string;
  members?: ListOrganizationMembersResponseBodyMembers[];
  /**
   * @example
   * ""
   */
  nextToken?: string;
  /**
   * @example
   * FC93CE1A-8D7A-13A9-8306-7465DE2E5C0F
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 15
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      members: 'members',
      nextToken: 'nextToken',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      members: { 'type': 'array', 'itemType': ListOrganizationMembersResponseBodyMembers },
      nextToken: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrganizationMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListOrganizationMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListOrganizationMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrganizationsRequest extends $tea.Model {
  /**
   * @example
   * 5
   */
  accessLevel?: number;
  accessToken?: string;
  /**
   * @example
   * 60
   */
  minAccessLevel?: number;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      accessToken: 'accessToken',
      minAccessLevel: 'minAccessLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      accessToken: 'string',
      minAccessLevel: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrganizationsResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 95FE5953-FF5B-5F80-94AD-FFF97D990FE0
   */
  requestId?: string;
  result?: ListOrganizationsResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 2
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListOrganizationsResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrganizationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListOrganizationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListOrganizationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineGroupPipelinesRequest extends $tea.Model {
  /**
   * @example
   * 1586863220000
   */
  createEndTime?: number;
  /**
   * @example
   * 1586863220000
   */
  createStartTime?: number;
  /**
   * @example
   * 1586863220000
   */
  executeEndTime?: number;
  /**
   * @example
   * 1586863220000
   */
  executeStartTime?: number;
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * aaaa
   */
  nextToken?: string;
  pipelineName?: string;
  /**
   * @example
   * RUNNING,SUCCESS
   */
  resultStatusList?: string;
  static names(): { [key: string]: string } {
    return {
      createEndTime: 'createEndTime',
      createStartTime: 'createStartTime',
      executeEndTime: 'executeEndTime',
      executeStartTime: 'executeStartTime',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      pipelineName: 'pipelineName',
      resultStatusList: 'resultStatusList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createEndTime: 'number',
      createStartTime: 'number',
      executeEndTime: 'number',
      executeStartTime: 'number',
      maxResults: 'number',
      nextToken: 'string',
      pipelineName: 'string',
      resultStatusList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineGroupPipelinesResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * aaaa
   */
  nextToken?: string;
  pipelines?: ListPipelineGroupPipelinesResponseBodyPipelines[];
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      nextToken: 'nextToken',
      pipelines: 'pipelines',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      nextToken: 'string',
      pipelines: { 'type': 'array', 'itemType': ListPipelineGroupPipelinesResponseBodyPipelines },
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineGroupPipelinesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPipelineGroupPipelinesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPipelineGroupPipelinesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineGroupsRequest extends $tea.Model {
  /**
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @example
   * aaaaaaaaaa
   */
  nextToken?: string;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineGroupsResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ssaassasass
   */
  nextToken?: string;
  pipelineGroups?: ListPipelineGroupsResponseBodyPipelineGroups[];
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 50
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      nextToken: 'nextToken',
      pipelineGroups: 'pipelineGroups',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      nextToken: 'string',
      pipelineGroups: { 'type': 'array', 'itemType': ListPipelineGroupsResponseBodyPipelineGroups },
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPipelineGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPipelineGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineJobHistorysRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * DEPLOY
   */
  category?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 10_ssasasa
   */
  identifier?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * xsaxsa
   */
  nextToken?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'category',
      identifier: 'identifier',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      identifier: 'string',
      maxResults: 'number',
      nextToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineJobHistorysResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  jobs?: ListPipelineJobHistorysResponseBodyJobs[];
  /**
   * @example
   * xsxxs
   */
  nextToken?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true 接口调用成功，false 接口调用失败
   */
  success?: boolean;
  /**
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      jobs: 'jobs',
      nextToken: 'nextToken',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      jobs: { 'type': 'array', 'itemType': ListPipelineJobHistorysResponseBodyJobs },
      nextToken: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineJobHistorysResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPipelineJobHistorysResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPipelineJobHistorysResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineJobsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * DEPLOY
   */
  category?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'category',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineJobsResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  jobs?: ListPipelineJobsResponseBodyJobs[];
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true 接口调用成功，false 接口调用失败
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      jobs: 'jobs',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      jobs: { 'type': 'array', 'itemType': ListPipelineJobsResponseBodyJobs },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineJobsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPipelineJobsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPipelineJobsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineRelationsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * VARIABLE_GROUP
   */
  relObjectType?: string;
  static names(): { [key: string]: string } {
    return {
      relObjectType: 'relObjectType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      relObjectType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineRelationsResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  pipelineRelations?: ListPipelineRelationsResponseBodyPipelineRelations[];
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      pipelineRelations: 'pipelineRelations',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      pipelineRelations: { 'type': 'array', 'itemType': ListPipelineRelationsResponseBodyPipelineRelations },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineRelationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPipelineRelationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPipelineRelationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineRunsRequest extends $tea.Model {
  /**
   * @example
   * 1586863220000
   */
  endTime?: number;
  /**
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @example
   * aaaaaa
   */
  nextToken?: string;
  /**
   * @example
   * 1586863220000
   */
  startTime?: number;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  /**
   * @example
   * 1
   */
  triggerMode?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'endTime',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      startTime: 'startTime',
      status: 'status',
      triggerMode: 'triggerMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      maxResults: 'number',
      nextToken: 'string',
      startTime: 'number',
      status: 'string',
      triggerMode: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineRunsResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * xzxsasasaas
   */
  nextToken?: string;
  pipelineRuns?: ListPipelineRunsResponseBodyPipelineRuns[];
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 50
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      nextToken: 'nextToken',
      pipelineRuns: 'pipelineRuns',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      nextToken: 'string',
      pipelineRuns: { 'type': 'array', 'itemType': ListPipelineRunsResponseBodyPipelineRuns },
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineRunsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPipelineRunsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPipelineRunsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelinesRequest extends $tea.Model {
  /**
   * @example
   * 1586863220000
   */
  createEndTime?: number;
  /**
   * @example
   * 1586863220000
   */
  createStartTime?: number;
  /**
   * @example
   * 112122121
   */
  creatorAccountIds?: string;
  /**
   * @example
   * 1111111
   */
  executeAccountIds?: string;
  /**
   * @example
   * 1586863220000
   */
  executeEndTime?: number;
  /**
   * @example
   * 1586863220000
   */
  executeStartTime?: number;
  /**
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @example
   * aaaaaaaaaa
   */
  nextToken?: string;
  /**
   * @example
   * 流水线
   */
  pipelineName?: string;
  /**
   * @example
   * RUNNING,SUCCESS
   */
  statusList?: string;
  static names(): { [key: string]: string } {
    return {
      createEndTime: 'createEndTime',
      createStartTime: 'createStartTime',
      creatorAccountIds: 'creatorAccountIds',
      executeAccountIds: 'executeAccountIds',
      executeEndTime: 'executeEndTime',
      executeStartTime: 'executeStartTime',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      pipelineName: 'pipelineName',
      statusList: 'statusList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createEndTime: 'number',
      createStartTime: 'number',
      creatorAccountIds: 'string',
      executeAccountIds: 'string',
      executeEndTime: 'number',
      executeStartTime: 'number',
      maxResults: 'number',
      nextToken: 'string',
      pipelineName: 'string',
      statusList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelinesResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ssaassasass
   */
  nextToken?: string;
  pipelines?: ListPipelinesResponseBodyPipelines[];
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 50
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      nextToken: 'nextToken',
      pipelines: 'pipelines',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      nextToken: 'string',
      pipelines: { 'type': 'array', 'itemType': ListPipelinesResponseBodyPipelines },
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelinesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPipelinesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPipelinesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectLabelsRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @example
   * label_name
   */
  orderBy?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  /**
   * @example
   * 1
   */
  page?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * This parameter is required.
   */
  repositoryIdentity?: string;
  /**
   * @example
   * TEST
   */
  search?: string;
  /**
   * @example
   * desc
   */
  sort?: string;
  /**
   * @example
   * false
   */
  withCounts?: boolean;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      orderBy: 'orderBy',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      repositoryIdentity: 'repositoryIdentity',
      search: 'search',
      sort: 'sort',
      withCounts: 'withCounts',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      orderBy: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      repositoryIdentity: 'string',
      search: 'string',
      sort: 'string',
      withCounts: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectLabelsResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: ListProjectLabelsResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 30
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListProjectLabelsResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectLabelsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProjectLabelsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProjectLabelsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectMembersRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Space
   */
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      targetType: 'targetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectMembersResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  members?: ListProjectMembersResponseBodyMembers[];
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      members: 'members',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      members: { 'type': 'array', 'itemType': ListProjectMembersResponseBodyMembers },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProjectMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProjectMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectTemplatesRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Project
   */
  category?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'category',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectTemplatesResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  templates?: ListProjectTemplatesResponseBodyTemplates[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
      templates: 'templates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
      templates: { 'type': 'array', 'itemType': ListProjectTemplatesResponseBodyTemplates },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectTemplatesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProjectTemplatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProjectTemplatesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectWorkitemTypesRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Req
   */
  category?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Project
   */
  spaceType?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'category',
      spaceType: 'spaceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      spaceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectWorkitemTypesResponseBody extends $tea.Model {
  /**
   * @example
   * 例：Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * errormessage
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true或者false
   */
  success?: boolean;
  workitemTypes?: ListProjectWorkitemTypesResponseBodyWorkitemTypes[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
      workitemTypes: 'workitemTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      workitemTypes: { 'type': 'array', 'itemType': ListProjectWorkitemTypesResponseBodyWorkitemTypes },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectWorkitemTypesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProjectWorkitemTypesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProjectWorkitemTypesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Project
   */
  category?: string;
  /**
   * @remarks
   * {"conditionGroups":[[]]}
   */
  conditions?: string;
  extraConditions?: string;
  /**
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @example
   * ""
   */
  nextToken?: string;
  /**
   * @example
   * public
   */
  scope?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'category',
      conditions: 'conditions',
      extraConditions: 'extraConditions',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      scope: 'scope',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      conditions: 'string',
      extraConditions: 'string',
      maxResults: 'number',
      nextToken: 'string',
      scope: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @example
   * ""
   */
  nextToken?: string;
  projects?: ListProjectsResponseBodyProjects[];
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 10
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      projects: 'projects',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      maxResults: 'number',
      nextToken: 'string',
      projects: { 'type': 'array', 'itemType': ListProjectsResponseBodyProjects },
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProjectsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProjectsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 313A1BF6-63B7-52D4-A098-952221A65254
   */
  requestId?: string;
  result?: ListProtectedBranchesResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListProtectedBranchesResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProtectedBranchesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProtectedBranchesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPushRulesRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60d54f3daccf2bbd6659f3ad
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPushRulesResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: ListPushRulesResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 2
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListPushRulesResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPushRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPushRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPushRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoriesRequest extends $tea.Model {
  accessToken?: string;
  /**
   * @example
   * false
   */
  archived?: boolean;
  minAccessLevel?: number;
  /**
   * @example
   * created_at
   */
  orderBy?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  organizationId?: string;
  /**
   * @example
   * 2
   */
  page?: number;
  /**
   * @example
   * 20
   */
  perPage?: number;
  /**
   * @example
   * Demo
   */
  search?: string;
  /**
   * @example
   * desc
   */
  sort?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      archived: 'archived',
      minAccessLevel: 'minAccessLevel',
      orderBy: 'orderBy',
      organizationId: 'organizationId',
      page: 'page',
      perPage: 'perPage',
      search: 'search',
      sort: 'sort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      archived: 'boolean',
      minAccessLevel: 'number',
      orderBy: 'string',
      organizationId: 'string',
      page: 'number',
      perPage: 'number',
      search: 'string',
      sort: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoriesResponseBody extends $tea.Model {
  errorCode?: number;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 4D6AF7CC-B43B-5454-86AB-023D25E44868
   */
  requestId?: string;
  result?: ListRepositoriesResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 149
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListRepositoriesResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoriesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRepositoriesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRepositoriesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryBranchesRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  /**
   * @example
   * 1
   */
  page?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * Demo
   */
  search?: string;
  /**
   * @example
   * desc
   */
  sort?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      search: 'search',
      sort: 'sort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      search: 'string',
      sort: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryBranchesResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 1F4F342D-493A-5B2C-B133-BA78B30FF834
   */
  requestId?: string;
  result?: ListRepositoryBranchesResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListRepositoryBranchesResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryBranchesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRepositoryBranchesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRepositoryBranchesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitDiffRequest extends $tea.Model {
  /**
   * @remarks
   * accessToken
   * 
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @example
   * 3
   */
  contextLine?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      contextLine: 'contextLine',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      contextLine: 'number',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitDiffResponseBody extends $tea.Model {
  /**
   * @example
   * success
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 0EE38A4E-8991-532A-8E8B-5C22B5D2E058
   */
  requestId?: string;
  result?: ListRepositoryCommitDiffResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListRepositoryCommitDiffResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitDiffResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRepositoryCommitDiffResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRepositoryCommitDiffResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitsRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @example
   * 2022-08-18 08:00:00
   */
  end?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  /**
   * @example
   * 1
   */
  page?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * src/cpp/main.cpp
   */
  path?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  refName?: string;
  /**
   * @example
   * search
   */
  search?: string;
  /**
   * @example
   * false
   */
  showCommentsCount?: boolean;
  /**
   * @example
   * false
   */
  showSignature?: boolean;
  /**
   * @example
   * 2022-03-18 08:00:00
   */
  start?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      end: 'end',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      path: 'path',
      refName: 'refName',
      search: 'search',
      showCommentsCount: 'showCommentsCount',
      showSignature: 'showSignature',
      start: 'start',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      end: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      path: 'string',
      refName: 'string',
      search: 'string',
      showCommentsCount: 'boolean',
      showSignature: 'boolean',
      start: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitsResponseBody extends $tea.Model {
  /**
   * @example
   * OpenApi.error
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * F1138237-CF7F-56BF-95D4-9AA937CCE8E5
   */
  requestId?: string;
  result?: ListRepositoryCommitsResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 145
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListRepositoryCommitsResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRepositoryCommitsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRepositoryCommitsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryGroupsRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @example
   * false
   */
  includePersonal?: boolean;
  /**
   * @example
   * updated_at
   */
  orderBy?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  /**
   * @example
   * 1
   */
  page?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 26842
   */
  parentId?: number;
  /**
   * @example
   * Demo
   */
  search?: string;
  /**
   * @example
   * desc
   */
  sort?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      includePersonal: 'includePersonal',
      orderBy: 'orderBy',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      parentId: 'parentId',
      search: 'search',
      sort: 'sort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      includePersonal: 'boolean',
      orderBy: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      parentId: 'number',
      search: 'string',
      sort: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryGroupsResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  result?: ListRepositoryGroupsResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListRepositoryGroupsResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRepositoryGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRepositoryGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryMemberWithInheritedRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryMemberWithInheritedResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: ListRepositoryMemberWithInheritedResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListRepositoryMemberWithInheritedResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryMemberWithInheritedResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRepositoryMemberWithInheritedResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRepositoryMemberWithInheritedResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryTagsRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 611b75680fc7bf0dbe1dce55
   */
  organizationId?: string;
  /**
   * @example
   * 2
   */
  page?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * Demo
   */
  search?: string;
  /**
   * @example
   * updated_desc
   */
  sort?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      search: 'search',
      sort: 'sort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      search: 'string',
      sort: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryTagsResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: ListRepositoryTagsResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 30
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListRepositoryTagsResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryTagsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRepositoryTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRepositoryTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryTreeRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 624666bd54d036291ae13a36
   */
  organizationId?: string;
  /**
   * @example
   * module
   */
  path?: string;
  /**
   * @example
   * master / tag1.0 / sjjfssa
   */
  refName?: string;
  /**
   * @example
   * RECURSIVE
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      path: 'path',
      refName: 'refName',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      path: 'string',
      refName: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryTreeResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 6557983C-FB08-51A9-AC5A-A7A0D0950A07
   */
  requestId?: string;
  result?: ListRepositoryTreeResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListRepositoryTreeResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryTreeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRepositoryTreeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRepositoryTreeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryWebhookRequest extends $tea.Model {
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  organizationId?: string;
  /**
   * @example
   * 1
   */
  page?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryWebhookResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  /**
   * @example
   * HC93CE1A-8D7A-13A9-8306-7465DE2E5C0F
   */
  requestId?: string;
  result?: ListRepositoryWebhookResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListRepositoryWebhookResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryWebhookResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRepositoryWebhookResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRepositoryWebhookResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourceMembersResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  resourceMembers?: ListResourceMembersResponseBodyResourceMembers[];
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      resourceMembers: 'resourceMembers',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      resourceMembers: { 'type': 'array', 'itemType': ListResourceMembersResponseBodyResourceMembers },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourceMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListResourceMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListResourceMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchCommitRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test
   */
  keyword?: string;
  /**
   * @example
   * default
   */
  order?: string;
  /**
   * @example
   * 1
   */
  page?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  repoPath?: ListSearchCommitRequestRepoPath;
  /**
   * @example
   * all
   */
  scope?: string;
  /**
   * @example
   * desc
   */
  sort?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60d54f3daccf2bbd6659f3ad
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      keyword: 'keyword',
      order: 'order',
      page: 'page',
      pageSize: 'pageSize',
      repoPath: 'repoPath',
      scope: 'scope',
      sort: 'sort',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyword: 'string',
      order: 'string',
      page: 'number',
      pageSize: 'number',
      repoPath: ListSearchCommitRequestRepoPath,
      scope: 'string',
      sort: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchCommitResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  result?: ListSearchCommitResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 10
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListSearchCommitResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchCommitResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSearchCommitResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSearchCommitResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchRepositoryRequest extends $tea.Model {
  /**
   * @example
   * 1840004904455497
   */
  aliyunPk?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test
   */
  keyword?: string;
  /**
   * @example
   * default
   */
  order?: string;
  /**
   * @example
   * 1
   */
  page?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  repoPath?: ListSearchRepositoryRequestRepoPath;
  /**
   * @example
   * all
   */
  scope?: string;
  /**
   * @example
   * desc
   */
  sort?: string;
  /**
   * @example
   * 0
   */
  visibilityLevel?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 61e54b0e0bb300d827e1ae27
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      keyword: 'keyword',
      order: 'order',
      page: 'page',
      pageSize: 'pageSize',
      repoPath: 'repoPath',
      scope: 'scope',
      sort: 'sort',
      visibilityLevel: 'visibilityLevel',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      keyword: 'string',
      order: 'string',
      page: 'number',
      pageSize: 'number',
      repoPath: ListSearchRepositoryRequestRepoPath,
      scope: 'string',
      sort: 'string',
      visibilityLevel: 'number',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchRepositoryResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  result?: ListSearchRepositoryResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 30
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListSearchRepositoryResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchRepositoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSearchRepositoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSearchRepositoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchSourceCodeRequest extends $tea.Model {
  filePath?: ListSearchSourceCodeRequestFilePath;
  /**
   * @example
   * false
   */
  isCodeBlock?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test
   */
  keyword?: string;
  /**
   * @example
   * Java
   */
  language?: string;
  /**
   * @example
   * default
   */
  order?: string;
  /**
   * @example
   * 1
   */
  page?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  repoPath?: ListSearchSourceCodeRequestRepoPath;
  /**
   * @example
   * all
   */
  scope?: string;
  /**
   * @example
   * desc
   */
  sort?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 66c0c9fffeb86b450c199fcd
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      filePath: 'filePath',
      isCodeBlock: 'isCodeBlock',
      keyword: 'keyword',
      language: 'language',
      order: 'order',
      page: 'page',
      pageSize: 'pageSize',
      repoPath: 'repoPath',
      scope: 'scope',
      sort: 'sort',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filePath: ListSearchSourceCodeRequestFilePath,
      isCodeBlock: 'boolean',
      keyword: 'string',
      language: 'string',
      order: 'string',
      page: 'number',
      pageSize: 'number',
      repoPath: ListSearchSourceCodeRequestRepoPath,
      scope: 'string',
      sort: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchSourceCodeResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: ListSearchSourceCodeResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 2
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListSearchSourceCodeResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchSourceCodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSearchSourceCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSearchSourceCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceAuthsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * RAM
   */
  serviceAuthType?: string;
  static names(): { [key: string]: string } {
    return {
      serviceAuthType: 'serviceAuthType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceAuthType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceAuthsResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  serviceAuths?: ListServiceAuthsResponseBodyServiceAuths[];
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      serviceAuths: 'serviceAuths',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      serviceAuths: { 'type': 'array', 'itemType': ListServiceAuthsResponseBodyServiceAuths },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceAuthsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListServiceAuthsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListServiceAuthsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceConnectionsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * codeup
   */
  sericeConnectionType?: string;
  static names(): { [key: string]: string } {
    return {
      sericeConnectionType: 'sericeConnectionType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sericeConnectionType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceConnectionsResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  serviceConnections?: ListServiceConnectionsResponseBodyServiceConnections[];
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      serviceConnections: 'serviceConnections',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      serviceConnections: { 'type': 'array', 'itemType': ListServiceConnectionsResponseBodyServiceConnections },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceConnectionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListServiceConnectionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListServiceConnectionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceCredentialsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * username_password
   */
  serviceCredentialType?: string;
  static names(): { [key: string]: string } {
    return {
      serviceCredentialType: 'serviceCredentialType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceCredentialType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceCredentialsResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  serviceCredentials?: ListServiceCredentialsResponseBodyServiceCredentials[];
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      serviceCredentials: 'serviceCredentials',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      serviceCredentials: { 'type': 'array', 'itemType': ListServiceCredentialsResponseBodyServiceCredentials },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceCredentialsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListServiceCredentialsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListServiceCredentialsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSprintsRequest extends $tea.Model {
  /**
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @example
   * ""
   */
  nextToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  spaceIdentifier?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Project
   */
  spaceType?: string;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      spaceIdentifier: 'spaceIdentifier',
      spaceType: 'spaceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      spaceIdentifier: 'string',
      spaceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSprintsResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @example
   * ""
   */
  nextToken?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  sprints?: ListSprintsResponseBodySprints[];
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 10
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      requestId: 'requestId',
      sprints: 'sprints',
      success: 'success',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      sprints: { 'type': 'array', 'itemType': ListSprintsResponseBodySprints },
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSprintsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSprintsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSprintsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTestCaseFieldsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  spaceIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      spaceIdentifier: 'spaceIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spaceIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTestCaseFieldsResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  fields?: ListTestCaseFieldsResponseBodyFields[];
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      fields: 'fields',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      fields: { 'type': 'array', 'itemType': ListTestCaseFieldsResponseBodyFields },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTestCaseFieldsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTestCaseFieldsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTestCaseFieldsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserDrawRecordByPkRequest extends $tea.Model {
  /**
   * @example
   * 1789095186553536
   */
  aliyunPk?: string;
  /**
   * @example
   * task_group_0000
   */
  drawGroup?: string;
  /**
   * @example
   * developer-award-draw-pool_123
   */
  drawPoolName?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      drawGroup: 'drawGroup',
      drawPoolName: 'drawPoolName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      drawGroup: 'string',
      drawPoolName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserDrawRecordByPkResponseBody extends $tea.Model {
  /**
   * @example
   * 200
   */
  code?: string;
  data?: ListUserDrawRecordByPkResponseBodyData[];
  /**
   * @example
   * None
   */
  message?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'code',
      data: 'data',
      message: 'message',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: { 'type': 'array', 'itemType': ListUserDrawRecordByPkResponseBodyData },
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserDrawRecordByPkResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListUserDrawRecordByPkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListUserDrawRecordByPkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserKeysRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @example
   * created_at
   */
  orderBy?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  /**
   * @example
   * 1
   */
  page?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * desc
   */
  sort?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      orderBy: 'orderBy',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      sort: 'sort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      orderBy: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      sort: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserKeysResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * Openapi.RequestError
   */
  errorMessage?: string;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  result?: ListUserKeysResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListUserKeysResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserKeysResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListUserKeysResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListUserKeysResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  /**
   * @example
   * 1
   */
  page?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * 1,2,3
   */
  userIds?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
      page: 'page',
      pageSize: 'pageSize',
      userIds: 'userIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
      page: 'number',
      pageSize: 'number',
      userIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesResponseBody extends $tea.Model {
  /**
   * @example
   * success
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * A35869D5-BB29-5F84-A4DD-B09985EA2AFA
   */
  requestId?: string;
  result?: ListUserResourcesResponseBodyResult[];
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 2
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      total: 'total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListUserResourcesResponseBodyResult },
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListUserResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListUserResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVariableGroupsRequest extends $tea.Model {
  /**
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @example
   * aaaaaa
   */
  nextToken?: string;
  /**
   * @example
   * DESC
   */
  pageOrder?: string;
  /**
   * @example
   * ID
   */
  pageSort?: string;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      pageOrder: 'pageOrder',
      pageSort: 'pageSort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      pageOrder: 'string',
      pageSort: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVariableGroupsResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * assassa
   */
  nextToken?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 30
   */
  totalCount?: number;
  variableGroups?: ListVariableGroupsResponseBodyVariableGroups[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      nextToken: 'nextToken',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
      variableGroups: 'variableGroups',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      nextToken: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
      variableGroups: { 'type': 'array', 'itemType': ListVariableGroupsResponseBodyVariableGroups },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVariableGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListVariableGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListVariableGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkItemAllFieldsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  spaceIdentifier?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Project
   */
  spaceType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * dfexxxxxf4fee18xxxxx36
   */
  workitemTypeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      spaceIdentifier: 'spaceIdentifier',
      spaceType: 'spaceType',
      workitemTypeIdentifier: 'workitemTypeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spaceIdentifier: 'string',
      spaceType: 'string',
      workitemTypeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkItemAllFieldsResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  fields?: ListWorkItemAllFieldsResponseBodyFields[];
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      fields: 'fields',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      fields: { 'type': 'array', 'itemType': ListWorkItemAllFieldsResponseBodyFields },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkItemAllFieldsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWorkItemAllFieldsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWorkItemAllFieldsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkItemWorkFlowStatusRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 例：5e70xxxxxxcd000xxxxe96
   */
  spaceIdentifier?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Project
   */
  spaceType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Req
   */
  workitemCategoryIdentifier?: string;
  /**
   * @example
   * 例：5e7xxxxb3cd3711dd6xxx2c
   */
  workitemTypeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      spaceIdentifier: 'spaceIdentifier',
      spaceType: 'spaceType',
      workitemCategoryIdentifier: 'workitemCategoryIdentifier',
      workitemTypeIdentifier: 'workitemTypeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spaceIdentifier: 'string',
      spaceType: 'string',
      workitemCategoryIdentifier: 'string',
      workitemTypeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkItemWorkFlowStatusResponseBody extends $tea.Model {
  /**
   * @example
   * 例：Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * errormessage
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  statuses?: ListWorkItemWorkFlowStatusResponseBodyStatuses[];
  /**
   * @example
   * true或者false
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      statuses: 'statuses',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      statuses: { 'type': 'array', 'itemType': ListWorkItemWorkFlowStatusResponseBodyStatuses },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkItemWorkFlowStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWorkItemWorkFlowStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWorkItemWorkFlowStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemAttachmentsResponseBody extends $tea.Model {
  attachments?: ListWorkitemAttachmentsResponseBodyAttachments[];
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      attachments: 'attachments',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachments: { 'type': 'array', 'itemType': ListWorkitemAttachmentsResponseBodyAttachments },
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemAttachmentsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWorkitemAttachmentsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWorkitemAttachmentsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemEstimateResponseBody extends $tea.Model {
  /**
   * @example
   * 200
   */
  code?: number;
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  workitemTimeEstimate?: ListWorkitemEstimateResponseBodyWorkitemTimeEstimate[];
  static names(): { [key: string]: string } {
    return {
      code: 'code',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
      workitemTimeEstimate: 'workitemTimeEstimate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
      workitemTimeEstimate: { 'type': 'array', 'itemType': ListWorkitemEstimateResponseBodyWorkitemTimeEstimate },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemEstimateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWorkitemEstimateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWorkitemEstimateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemTimeResponseBody extends $tea.Model {
  /**
   * @example
   * 200
   */
  code?: number;
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  workitemTime?: ListWorkitemTimeResponseBodyWorkitemTime[];
  static names(): { [key: string]: string } {
    return {
      code: 'code',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
      workitemTime: 'workitemTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
      workitemTime: { 'type': 'array', 'itemType': ListWorkitemTimeResponseBodyWorkitemTime },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemTimeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWorkitemTimeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWorkitemTimeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Req
   */
  category?: string;
  /**
   * @example
   * {"conditionGroups":[]}
   */
  conditions?: string;
  /**
   * @example
   * {"conditionGroups":[]}
   */
  extraConditions?: string;
  /**
   * @example
   * {"fieldIdentifier":"tag","className":"tag","format":"multiList","value":["c76e0e4bf64801cfad73......"],"operator":"EQUALS"}
   */
  groupCondition?: string;
  /**
   * @example
   * 20
   */
  maxResults?: string;
  /**
   * @example
   * ""
   */
  nextToken?: string;
  /**
   * @example
   * {"fieldIdentifier":"status","format":"list","order":"desc","className":"status"}
   */
  orderBy?: string;
  /**
   * @example
   * LIST
   */
  searchType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 8fb83debd69a6c7c6626......
   */
  spaceIdentifier?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Project
   */
  spaceType?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'category',
      conditions: 'conditions',
      extraConditions: 'extraConditions',
      groupCondition: 'groupCondition',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      orderBy: 'orderBy',
      searchType: 'searchType',
      spaceIdentifier: 'spaceIdentifier',
      spaceType: 'spaceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      conditions: 'string',
      extraConditions: 'string',
      groupCondition: 'string',
      maxResults: 'string',
      nextToken: 'string',
      orderBy: 'string',
      searchType: 'string',
      spaceIdentifier: 'string',
      spaceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemsResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @example
   * ""
   */
  nextToken?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 10
   */
  totalCount?: number;
  workitems?: ListWorkitemsResponseBodyWorkitems[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
      workitems: 'workitems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
      workitems: { 'type': 'array', 'itemType': ListWorkitemsResponseBodyWorkitems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWorkitemsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWorkitemsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkspacesRequest extends $tea.Model {
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * beb1eff55bf03a13cf321a395dxxxxxx
   */
  nextToken?: string;
  statusList?: string[];
  workspaceTemplateList?: string[];
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      statusList: 'statusList',
      workspaceTemplateList: 'workspaceTemplateList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      statusList: { 'type': 'array', 'itemType': 'string' },
      workspaceTemplateList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkspacesShrinkRequest extends $tea.Model {
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @example
   * beb1eff55bf03a13cf321a395dxxxxxx
   */
  nextToken?: string;
  statusListShrink?: string;
  workspaceTemplateListShrink?: string;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      statusListShrink: 'statusList',
      workspaceTemplateListShrink: 'workspaceTemplateList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      statusListShrink: 'string',
      workspaceTemplateListShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkspacesResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * beb1eff55bf03a13cf321a395dxxxxxx
   */
  nextToken?: string;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  workspaces?: ListWorkspacesResponseBodyWorkspaces[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
      workspaces: 'workspaces',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
      workspaces: { 'type': 'array', 'itemType': ListWorkspacesResponseBodyWorkspaces },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkspacesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWorkspacesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWorkspacesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LogPipelineJobRunResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  log?: LogPipelineJobRunResponseBodyLog;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      log: 'log',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      log: LogPipelineJobRunResponseBodyLog,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LogPipelineJobRunResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: LogPipelineJobRunResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: LogPipelineJobRunResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LogVMDeployMachineResponseBody extends $tea.Model {
  deployMachineLog?: LogVMDeployMachineResponseBodyDeployMachineLog;
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true 接口调用成功，false 接口调用失败
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      deployMachineLog: 'deployMachineLog',
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deployMachineLog: LogVMDeployMachineResponseBodyDeployMachineLog,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LogVMDeployMachineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: LogVMDeployMachineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: LogVMDeployMachineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MergeMergeRequestRequest extends $tea.Model {
  /**
   * @example
   * 0cf2c8458ac44d9481aab2dd6ec10596v3
   */
  accessToken?: string;
  /**
   * @example
   * ""
   */
  mergeMessage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * no-fast-forward
   */
  mergeType?: string;
  /**
   * @example
   * true
   */
  removeSourceBranch?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      mergeMessage: 'mergeMessage',
      mergeType: 'mergeType',
      removeSourceBranch: 'removeSourceBranch',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      mergeMessage: 'string',
      mergeType: 'string',
      removeSourceBranch: 'boolean',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MergeMergeRequestResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 9ED5E382-3A58-51E4-8A81-CE25D1756025
   */
  requestId?: string;
  result?: MergeMergeRequestResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: MergeMergeRequestResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MergeMergeRequestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: MergeMergeRequestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: MergeMergeRequestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PassPipelineValidateResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PassPipelineValidateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PassPipelineValidateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PassPipelineValidateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PassReleaseStagePipelineValidateRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 226241***
   */
  jobId?: string;
  /**
   * @example
   * 66c0c9fffeb86b450c199***
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'jobId',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PassReleaseStagePipelineValidateResponseBody extends $tea.Model {
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PassReleaseStagePipelineValidateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PassReleaseStagePipelineValidateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PassReleaseStagePipelineValidateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefusePipelineValidateResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefusePipelineValidateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RefusePipelineValidateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RefusePipelineValidateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefuseReleaseStagePipelineValidateRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 226241***
   */
  jobId?: string;
  /**
   * @example
   * 66c0c9fffeb86b450c19****
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'jobId',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefuseReleaseStagePipelineValidateResponseBody extends $tea.Model {
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefuseReleaseStagePipelineValidateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RefuseReleaseStagePipelineValidateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RefuseReleaseStagePipelineValidateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseWorkspaceResponseBody extends $tea.Model {
  /**
   * @example
   * Forbidden.AccessDenied
   */
  errorCode?: string;
  /**
   * @example
   * The user is not authorized to perform the operation.
   */
  errorMessage?: string;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseWorkspaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ReleaseWorkspaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReleaseWorkspaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReopenMergeRequestRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReopenMergeRequestResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 313A1BF6-63B7-52D4-A098-952221A65254
   */
  requestId?: string;
  result?: ReopenMergeRequestResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: ReopenMergeRequestResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReopenMergeRequestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ReopenMergeRequestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReopenMergeRequestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetSshKeyResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  sshKey?: ResetSshKeyResponseBodySshKey;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      sshKey: 'sshKey',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      sshKey: ResetSshKeyResponseBodySshKey,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetSshKeyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ResetSshKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResetSshKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeVMDeployOrderResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true 接口调用成功，false 接口调用失败
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeVMDeployOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ResumeVMDeployOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResumeVMDeployOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryPipelineJobRunResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryPipelineJobRunResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RetryPipelineJobRunResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RetryPipelineJobRunResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryVMDeployMachineResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true 接口调用成功，false 接口调用失败
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryVMDeployMachineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RetryVMDeployMachineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RetryVMDeployMachineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReviewMergeRequestRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  draftCommentIds?: string[];
  reviewComment?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * PASS
   */
  reviewOpinion?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      draftCommentIds: 'draftCommentIds',
      reviewComment: 'reviewComment',
      reviewOpinion: 'reviewOpinion',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      draftCommentIds: { 'type': 'array', 'itemType': 'string' },
      reviewComment: 'string',
      reviewOpinion: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReviewMergeRequestResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: ReviewMergeRequestResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: ReviewMergeRequestResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReviewMergeRequestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ReviewMergeRequestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReviewMergeRequestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SkipPipelineJobRunResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SkipPipelineJobRunResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SkipPipelineJobRunResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SkipPipelineJobRunResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SkipVMDeployMachineResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true 接口调用成功，false 接口调用失败
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SkipVMDeployMachineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SkipVMDeployMachineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SkipVMDeployMachineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartPipelineRunRequest extends $tea.Model {
  /**
   * @example
   * {     "branchModeBranchs":[         "branch1",         "branch2"     ],     "envs":{         "k1":"v1",         "k2":"v2",         "k3":"v3"     },     "runningBranchs":{         "https://codeup.aliyun.com/60c1abb32c5969c370c5fcd0/Codeup-Demo.git":"master1"     },     "runningTags":{         "https://codeup.aliyun.com/60c1abb32c5969c370c5fcd0/Codeup-Demo.git":"1.0"     } }
   */
  params?: string;
  static names(): { [key: string]: string } {
    return {
      params: 'params',
    };
  }

  static types(): { [key: string]: any } {
    return {
      params: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartPipelineRunResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 1
   */
  pipelineRunId?: number;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      pipelineRunId: 'pipelineRunId',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      pipelineRunId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartPipelineRunResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StartPipelineRunResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartPipelineRunResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopPipelineJobRunResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * "\\"
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopPipelineJobRunResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopPipelineJobRunResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopPipelineJobRunResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopPipelineRunResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopPipelineRunResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopPipelineRunResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopPipelineRunResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopVMDeployOrderResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true 接口调用成功，false 接口调用失败
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopVMDeployOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopVMDeployOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopVMDeployOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TransferRepositoryRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  groupId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  repositoryId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      groupId: 'groupId',
      organizationId: 'organizationId',
      repositoryId: 'repositoryId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      groupId: 'string',
      organizationId: 'string',
      repositoryId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TransferRepositoryResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: TransferRepositoryResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: TransferRepositoryResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TransferRepositoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: TransferRepositoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TransferRepositoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TriggerRepositoryMirrorSyncRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @example
   * test-account
   */
  account?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  /**
   * @example
   * asd12e44827fe2444f952e931e51xxxx
   */
  token?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      account: 'account',
      organizationId: 'organizationId',
      token: 'token',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      account: 'string',
      organizationId: 'string',
      token: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TriggerRepositoryMirrorSyncResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_ILLEGAL_ARGUMENT_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * 企业不存在
   */
  errorMessage?: string;
  /**
   * @example
   * 37294673-00CA-5B8B-914F-A8B35511E90A
   */
  requestId?: string;
  result?: TriggerRepositoryMirrorSyncResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: TriggerRepositoryMirrorSyncResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TriggerRepositoryMirrorSyncResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: TriggerRepositoryMirrorSyncResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TriggerRepositoryMirrorSyncResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAppMemberRequest extends $tea.Model {
  player?: UpdateAppMemberRequestPlayer;
  roleNames?: string[];
  /**
   * @example
   * 66c0c9fffeb86b450c199fcd
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      player: 'player',
      roleNames: 'roleNames',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      player: UpdateAppMemberRequestPlayer,
      roleNames: { 'type': 'array', 'itemType': 'string' },
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAppMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: string;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateApplicationRequest extends $tea.Model {
  /**
   * @example
   * 1332695887xxxxxx
   */
  ownerAccountId?: string;
  /**
   * @example
   * 66c0c9fffeb86b450c199fcd
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerAccountId: 'ownerAccountId',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerAccountId: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateApplicationResponseBody extends $tea.Model {
  /**
   * @example
   * 1332695887xxxxxx
   */
  creatorAccountId?: string;
  /**
   * @example
   * 应用描述
   */
  description?: string;
  /**
   * @example
   * 2024-01-01T00:00:00.000+00:00
   */
  gmtCreate?: string;
  /**
   * @example
   * testApp
   */
  name?: string;
  /**
   * @example
   * FC93CE1A-8D7A-13A9-8306-7465DE2E5C0F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      creatorAccountId: 'creatorAccountId',
      description: 'description',
      gmtCreate: 'gmtCreate',
      name: 'name',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorAccountId: 'string',
      description: 'string',
      gmtCreate: 'string',
      name: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateApplicationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateApplicationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateApplicationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  annotations?: UpdateCheckRunRequestAnnotations[];
  /**
   * @example
   * 2023-03-15T08:00:00Z
   */
  completedAt?: string;
  /**
   * @example
   * success
   */
  conclusion?: string;
  /**
   * @example
   * xx
   */
  detailsUrl?: string;
  /**
   * @example
   * 42
   */
  externalId?: string;
  /**
   * @example
   * my-check-ci
   */
  name?: string;
  output?: UpdateCheckRunRequestOutput;
  /**
   * @example
   * 2023-03-15T08:00:00Z
   */
  startedAt?: string;
  /**
   * @example
   * completed
   */
  status?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2
   */
  checkRunId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      annotations: 'annotations',
      completedAt: 'completedAt',
      conclusion: 'conclusion',
      detailsUrl: 'detailsUrl',
      externalId: 'externalId',
      name: 'name',
      output: 'output',
      startedAt: 'startedAt',
      status: 'status',
      checkRunId: 'checkRunId',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      annotations: { 'type': 'array', 'itemType': UpdateCheckRunRequestAnnotations },
      completedAt: 'string',
      conclusion: 'string',
      detailsUrl: 'string',
      externalId: 'string',
      name: 'string',
      output: UpdateCheckRunRequestOutput,
      startedAt: 'string',
      status: 'string',
      checkRunId: 'number',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: UpdateCheckRunResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdateCheckRunResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCheckRunResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCheckRunResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileRequest extends $tea.Model {
  /**
   * @example
   * 0cf2c8458ac44d9481aab2dd6ec10596v3
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * master
   */
  branchName?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  commitMessage?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  content?: string;
  /**
   * @example
   * text
   */
  encoding?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * src/main/update.txt
   */
  newPath?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * src/main/update.txt
   */
  oldPath?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      branchName: 'branchName',
      commitMessage: 'commitMessage',
      content: 'content',
      encoding: 'encoding',
      newPath: 'newPath',
      oldPath: 'oldPath',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      branchName: 'string',
      commitMessage: 'string',
      content: 'string',
      encoding: 'string',
      newPath: 'string',
      oldPath: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * C2F153F6-BB43-50C4-9F4F-40593203E19A
   */
  requestId?: string;
  result?: UpdateFileResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdateFileResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFlowTagRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * #1F9AEF
   */
  color?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 11
   */
  flowTagGroupId?: number;
  /**
   * @remarks
   * This parameter is required.
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      color: 'color',
      flowTagGroupId: 'flowTagGroupId',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      color: 'string',
      flowTagGroupId: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFlowTagResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true 接口调用成功，false 接口调用失败
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFlowTagResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateFlowTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateFlowTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFlowTagGroupRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFlowTagGroupResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true 接口调用成功，false 接口调用失败
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFlowTagGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateFlowTagGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateFlowTagGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGroupRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61dxxxxxxx975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  description?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * codeup_group
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * codeup_group
   */
  path?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * org/group/subgroup/here
   */
  pathWithNamespace?: string;
  /**
   * @example
   * 10
   */
  visibilityLevel?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1e9903d8b3f1xxxxxf9286ef5
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      avatarUrl: 'avatarUrl',
      description: 'description',
      name: 'name',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      visibilityLevel: 'visibilityLevel',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      avatarUrl: 'string',
      description: 'string',
      name: 'string',
      path: 'string',
      pathWithNamespace: 'string',
      visibilityLevel: 'number',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGroupResponseBody extends $tea.Model {
  /**
   * @example
   * success
   */
  errorCode?: string;
  /**
   * @example
   * InvalidParam.NoPermission
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: UpdateGroupResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdateGroupResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGroupMemberRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1789095186553536
   */
  aliyunPk?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 30
   */
  accessLevel?: number;
  /**
   * @example
   * USERS
   */
  memberType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 632bbfdf419338aaa2b1360a
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      aliyunPk: 'aliyunPk',
      accessLevel: 'accessLevel',
      memberType: 'memberType',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      aliyunPk: 'string',
      accessLevel: 'number',
      memberType: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGroupMemberResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: UpdateGroupMemberResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdateGroupMemberResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGroupMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGroupMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGroupMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHostGroupRequest extends $tea.Model {
  /**
   * @example
   * cn-hangzhou
   */
  aliyunRegion?: string;
  /**
   * @example
   * ecs
   */
  ecsLabelKey?: string;
  /**
   * @example
   * ecs
   */
  ecsLabelValue?: string;
  /**
   * @example
   * ECS_ALIYUN
   */
  ecsType?: string;
  /**
   * @example
   * 0
   */
  envId?: string;
  /**
   * @example
   * [{"aliyunRegionId":"cn-beijing","machineSn":"i-sssssss","instanceName":"ceshi","ip":"120.0.0.0"}]
   */
  machineInfos?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123
   */
  serviceConnectionId?: number;
  /**
   * @example
   * 12,23
   */
  tagIds?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ECS
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunRegion: 'aliyunRegion',
      ecsLabelKey: 'ecsLabelKey',
      ecsLabelValue: 'ecsLabelValue',
      ecsType: 'ecsType',
      envId: 'envId',
      machineInfos: 'machineInfos',
      name: 'name',
      serviceConnectionId: 'serviceConnectionId',
      tagIds: 'tagIds',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunRegion: 'string',
      ecsLabelKey: 'string',
      ecsLabelValue: 'string',
      ecsType: 'string',
      envId: 'string',
      machineInfos: 'string',
      name: 'string',
      serviceConnectionId: 'number',
      tagIds: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHostGroupResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHostGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateHostGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateHostGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMergeRequestRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  description?: string;
  title?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      description: 'description',
      title: 'title',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      description: 'string',
      title: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMergeRequestResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  result?: UpdateMergeRequestResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdateMergeRequestResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMergeRequestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateMergeRequestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateMergeRequestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMergeRequestPersonnelRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  newUserIdList?: string[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      newUserIdList: 'newUserIdList',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      newUserIdList: { 'type': 'array', 'itemType': 'string' },
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMergeRequestPersonnelResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 4D6AF7CC-B43B-5454-86AB-023D25E44868
   */
  requestId?: string;
  result?: UpdateMergeRequestPersonnelResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdateMergeRequestPersonnelResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMergeRequestPersonnelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateMergeRequestPersonnelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateMergeRequestPersonnelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOrganizationMemberRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  organizationMemberName?: string;
  static names(): { [key: string]: string } {
    return {
      organizationMemberName: 'organizationMemberName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationMemberName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOrganizationMemberResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  member?: UpdateOrganizationMemberResponseBodyMember;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      member: 'member',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      member: UpdateOrganizationMemberResponseBodyMember,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOrganizationMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateOrganizationMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateOrganizationMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  content?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 111xxx
   */
  pipelineId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'content',
      name: 'name',
      pipelineId: 'pipelineId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      name: 'string',
      pipelineId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdatePipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdatePipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineBaseInfoRequest extends $tea.Model {
  /**
   * @example
   * 0
   */
  envId?: number;
  /**
   * @remarks
   * This parameter is required.
   */
  pipelineName?: string;
  /**
   * @example
   * "11,222,33"
   */
  tagList?: string;
  static names(): { [key: string]: string } {
    return {
      envId: 'envId',
      pipelineName: 'pipelineName',
      tagList: 'tagList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      envId: 'number',
      pipelineName: 'string',
      tagList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineBaseInfoResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true 接口调用成功，false 接口调用失败
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineBaseInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdatePipelineBaseInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdatePipelineBaseInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineGroupRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineGroupResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdatePipelineGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdatePipelineGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectFieldRequest extends $tea.Model {
  /**
   * @example
   * fdsaadsfasxxxxdddd
   */
  statusIdentifier?: string;
  updateBasicFieldRequestList?: UpdateProjectFieldRequestUpdateBasicFieldRequestList[];
  updateForOpenApiList?: UpdateProjectFieldRequestUpdateForOpenApiList[];
  static names(): { [key: string]: string } {
    return {
      statusIdentifier: 'statusIdentifier',
      updateBasicFieldRequestList: 'updateBasicFieldRequestList',
      updateForOpenApiList: 'updateForOpenApiList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      statusIdentifier: 'string',
      updateBasicFieldRequestList: { 'type': 'array', 'itemType': UpdateProjectFieldRequestUpdateBasicFieldRequestList },
      updateForOpenApiList: { 'type': 'array', 'itemType': UpdateProjectFieldRequestUpdateForOpenApiList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectFieldResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * errormessage
   */
  errorMessage?: string;
  project?: UpdateProjectFieldResponseBodyProject;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @remarks
   * true/false
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      project: 'project',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      project: UpdateProjectFieldResponseBodyProject,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectFieldResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateProjectFieldResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateProjectFieldResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectLabelRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @example
   * #EF433B
   */
  color?: string;
  description?: string;
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  repositoryIdentity?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      color: 'color',
      description: 'description',
      name: 'name',
      organizationId: 'organizationId',
      repositoryIdentity: 'repositoryIdentity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      color: 'string',
      description: 'string',
      name: 'string',
      organizationId: 'string',
      repositoryIdentity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectLabelResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  result?: UpdateProjectLabelResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdateProjectLabelResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectLabelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateProjectLabelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateProjectLabelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectMemberRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * project.admin
   */
  roleIdentifier?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5e70xxxxxxcd000xxxxe96
   */
  targetIdentifier?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Space
   */
  targetType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 19xx7043xxxxxxx914
   */
  userIdentifier?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * user
   */
  userType?: string;
  static names(): { [key: string]: string } {
    return {
      roleIdentifier: 'roleIdentifier',
      targetIdentifier: 'targetIdentifier',
      targetType: 'targetType',
      userIdentifier: 'userIdentifier',
      userType: 'userType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleIdentifier: 'string',
      targetIdentifier: 'string',
      targetType: 'string',
      userIdentifier: 'string',
      userType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectMemberResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  member?: UpdateProjectMemberResponseBodyMember;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      member: 'member',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      member: UpdateProjectMemberResponseBodyMember,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateProjectMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateProjectMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  allowMergeRoles?: number[];
  allowMergeUserIds?: string[];
  allowPushRoles?: number[];
  allowPushUserIds?: string[];
  /**
   * @example
   * master
   */
  branch?: string;
  /**
   * @example
   * 19224
   */
  id?: number;
  mergeRequestSetting?: UpdateProtectedBranchesRequestMergeRequestSetting;
  testSettingDTO?: UpdateProtectedBranchesRequestTestSettingDTO;
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      allowMergeRoles: 'allowMergeRoles',
      allowMergeUserIds: 'allowMergeUserIds',
      allowPushRoles: 'allowPushRoles',
      allowPushUserIds: 'allowPushUserIds',
      branch: 'branch',
      id: 'id',
      mergeRequestSetting: 'mergeRequestSetting',
      testSettingDTO: 'testSettingDTO',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      allowMergeRoles: { 'type': 'array', 'itemType': 'number' },
      allowMergeUserIds: { 'type': 'array', 'itemType': 'string' },
      allowPushRoles: { 'type': 'array', 'itemType': 'number' },
      allowPushUserIds: { 'type': 'array', 'itemType': 'string' },
      branch: 'string',
      id: 'number',
      mergeRequestSetting: UpdateProtectedBranchesRequestMergeRequestSetting,
      testSettingDTO: UpdateProtectedBranchesRequestTestSettingDTO,
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * A35869D5-BB29-5F84-A4DD-B09985EA2AFA
   */
  requestId?: string;
  result?: UpdateProtectedBranchesResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdateProtectedBranchesResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateProtectedBranchesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateProtectedBranchesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePushReviewOnOffRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * true
   */
  trunkMode?: boolean;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'organizationId',
      trunkMode: 'trunkMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
      trunkMode: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePushReviewOnOffResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * 6177543A-8D54-5736-A93B-E0195A1512CB
   */
  requestId?: string;
  result?: UpdatePushReviewOnOffResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdatePushReviewOnOffResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePushReviewOnOffResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdatePushReviewOnOffResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdatePushReviewOnOffResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePushRuleRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  ruleInfos?: UpdatePushRuleRequestRuleInfos[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5ebbc0228123212b59xxxxx
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      ruleInfos: 'ruleInfos',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      ruleInfos: { 'type': 'array', 'itemType': UpdatePushRuleRequestRuleInfos },
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePushRuleResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  result?: UpdatePushRuleResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdatePushRuleResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePushRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdatePushRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdatePushRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryRequest extends $tea.Model {
  /**
   * @example
   * c3c09f1230187a879678da43c973d069
   */
  accessToken?: string;
  /**
   * @example
   * Java
   */
  adminSettingLanguage?: string;
  /**
   * @example
   * https://xxxx
   */
  avatar?: string;
  /**
   * @example
   * true
   */
  buildsEnabled?: boolean;
  /**
   * @example
   * true
   */
  checkEmail?: boolean;
  /**
   * @example
   * master
   */
  defaultBranch?: string;
  description?: string;
  /**
   * @example
   * 2080398
   */
  id?: number;
  /**
   * @example
   * true
   */
  issuesEnabled?: boolean;
  /**
   * @example
   * true
   */
  mergeRequestsEnabled?: boolean;
  /**
   * @example
   * codeup
   */
  name?: string;
  /**
   * @example
   * false
   */
  openCloneDownloadControl?: boolean;
  path?: string;
  projectCloneDownloadMethodList?: UpdateRepositoryRequestProjectCloneDownloadMethodList[];
  projectCloneDownloadRoleList?: UpdateRepositoryRequestProjectCloneDownloadRoleList[];
  /**
   * @example
   * false
   */
  snippetsEnabled?: boolean;
  /**
   * @example
   * 0
   */
  visibilityLevel?: number;
  /**
   * @example
   * true
   */
  wikiEnabled?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      adminSettingLanguage: 'adminSettingLanguage',
      avatar: 'avatar',
      buildsEnabled: 'buildsEnabled',
      checkEmail: 'checkEmail',
      defaultBranch: 'defaultBranch',
      description: 'description',
      id: 'id',
      issuesEnabled: 'issuesEnabled',
      mergeRequestsEnabled: 'mergeRequestsEnabled',
      name: 'name',
      openCloneDownloadControl: 'openCloneDownloadControl',
      path: 'path',
      projectCloneDownloadMethodList: 'projectCloneDownloadMethodList',
      projectCloneDownloadRoleList: 'projectCloneDownloadRoleList',
      snippetsEnabled: 'snippetsEnabled',
      visibilityLevel: 'visibilityLevel',
      wikiEnabled: 'wikiEnabled',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      adminSettingLanguage: 'string',
      avatar: 'string',
      buildsEnabled: 'boolean',
      checkEmail: 'boolean',
      defaultBranch: 'string',
      description: 'string',
      id: 'number',
      issuesEnabled: 'boolean',
      mergeRequestsEnabled: 'boolean',
      name: 'string',
      openCloneDownloadControl: 'boolean',
      path: 'string',
      projectCloneDownloadMethodList: { 'type': 'array', 'itemType': UpdateRepositoryRequestProjectCloneDownloadMethodList },
      projectCloneDownloadRoleList: { 'type': 'array', 'itemType': UpdateRepositoryRequestProjectCloneDownloadRoleList },
      snippetsEnabled: 'boolean',
      visibilityLevel: 'number',
      wikiEnabled: 'boolean',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * “”
   */
  errorMessage?: string;
  /**
   * @example
   * EAE03103-5497-58D1-9169-E524DDE8604C
   */
  requestId?: string;
  result?: UpdateRepositoryResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdateRepositoryResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateRepositoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateRepositoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryMemberRequest extends $tea.Model {
  /**
   * @example
   * f0b1e61db5961df5975a93f9129d2513
   */
  accessToken?: string;
  /**
   * @example
   * 30
   */
  accessLevel?: number;
  /**
   * @example
   * 2020-08-08 08:08:08
   */
  expireAt?: string;
  /**
   * @example
   * USERS
   */
  memberType?: string;
  /**
   * @example
   * 10010
   */
  relatedId?: string;
  relatedInfos?: UpdateRepositoryMemberRequestRelatedInfos[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      accessLevel: 'accessLevel',
      expireAt: 'expireAt',
      memberType: 'memberType',
      relatedId: 'relatedId',
      relatedInfos: 'relatedInfos',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      accessLevel: 'number',
      expireAt: 'string',
      memberType: 'string',
      relatedId: 'string',
      relatedInfos: { 'type': 'array', 'itemType': UpdateRepositoryMemberRequestRelatedInfos },
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryMemberResponseBody extends $tea.Model {
  /**
   * @example
   * success
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * F590C9D8-E908-5B6C-95AC-56B7E8011FFA
   */
  requestId?: string;
  result?: UpdateRepositoryMemberResponseBodyResult;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      result: 'result',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: UpdateRepositoryMemberResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateRepositoryMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateRepositoryMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateResourceMemberRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * admin
   */
  roleName?: string;
  static names(): { [key: string]: string } {
    return {
      roleName: 'roleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateResourceMemberResponseBody extends $tea.Model {
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * ""
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateResourceMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateResourceMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateResourceMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  updateWorkitemPropertyRequest?: UpdateTestCaseRequestUpdateWorkitemPropertyRequest[];
  static names(): { [key: string]: string } {
    return {
      updateWorkitemPropertyRequest: 'updateWorkitemPropertyRequest',
    };
  }

  static types(): { [key: string]: any } {
    return {
      updateWorkitemPropertyRequest: { 'type': 'array', 'itemType': UpdateTestCaseRequestUpdateWorkitemPropertyRequest },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponseBody extends $tea.Model {
  testcase?: UpdateTestCaseResponseBodyTestcase;
  /**
   * @example
   * ""
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      testcase: 'Testcase',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      testcase: UpdateTestCaseResponseBodyTestcase,
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTestCaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTestCaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestResultRequest extends $tea.Model {
  /**
   * @example
   * 131xxx38624xxxx68
   */
  executor?: string;
  /**
   * @example
   * TO DO
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      executor: 'executor',
      status: 'status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      executor: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestResultResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestResultResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTestResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTestResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateVariableGroupRequest extends $tea.Model {
  /**
   * @example
   * 变量组
   */
  description?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 变量组
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * [{"isEncrypted":true,"name":"name1","value":"vaue1"}]
   */
  variables?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'description',
      name: 'name',
      variables: 'variables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      variables: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateVariableGroupResponseBody extends $tea.Model {
  /**
   * @example
   * ”“
   */
  errorCode?: string;
  /**
   * @example
   * ”“
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateVariableGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateVariableGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateVariableGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkItemRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * subject
   */
  fieldType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * e8b2xxxxxx2abdxxxxxxxx23
   */
  identifier?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * subject
   */
  propertyKey?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * newValue
   */
  propertyValue?: string;
  static names(): { [key: string]: string } {
    return {
      fieldType: 'fieldType',
      identifier: 'identifier',
      propertyKey: 'propertyKey',
      propertyValue: 'propertyValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldType: 'string',
      identifier: 'string',
      propertyKey: 'string',
      propertyValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkItemResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMessage?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  workitem?: UpdateWorkItemResponseBodyWorkitem;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
      workitem: 'workitem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      workitem: UpdateWorkItemResponseBodyWorkitem,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkItemResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateWorkItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateWorkItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkitemCommentRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1964584
   */
  commentId?: number;
  /**
   * @remarks
   * This parameter is required.
   */
  content?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * MARKDOWN/RICHTEXT
   */
  formatType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 9144ef6b72d8exxxxx9e61a4d0
   */
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      commentId: 'commentId',
      content: 'content',
      formatType: 'formatType',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commentId: 'number',
      content: 'string',
      formatType: 'string',
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkitemCommentResponseBody extends $tea.Model {
  comment?: UpdateWorkitemCommentResponseBodyComment;
  /**
   * @example
   * InvalidParam.NotFound
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * F7B85D1B-D1C2-140F-A039-341859F130B9
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      comment: 'comment',
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: UpdateWorkitemCommentResponseBodyComment,
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkitemCommentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateWorkitemCommentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateWorkitemCommentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkitemFieldRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  updateWorkitemPropertyRequest?: UpdateWorkitemFieldRequestUpdateWorkitemPropertyRequest[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 9144ef6b72d8exxxxx9e61a4d0
   */
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      updateWorkitemPropertyRequest: 'updateWorkitemPropertyRequest',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      updateWorkitemPropertyRequest: { 'type': 'array', 'itemType': UpdateWorkitemFieldRequestUpdateWorkitemPropertyRequest },
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkitemFieldResponseBody extends $tea.Model {
  /**
   * @example
   * Openapi.RequestError
   */
  errorCode?: string;
  /**
   * @example
   * error
   */
  errorMsg?: string;
  /**
   * @example
   * ASSDS-ASSASX-XSAXSA-XSAXSAXS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  workitem?: UpdateWorkitemFieldResponseBodyWorkitem;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMsg: 'errorMsg',
      requestId: 'requestId',
      success: 'success',
      workitem: 'workitem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
      success: 'boolean',
      workitem: UpdateWorkitemFieldResponseBodyWorkitem,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkitemFieldResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateWorkitemFieldResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateWorkitemFieldResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WorkitemAttachmentCreateRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1106473328927498/1106473328927498/5ec071g0e5ij85fche8cddchje.xlsx
   */
  fileKey?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * xxx.tgz
   */
  originalFilename?: string;
  static names(): { [key: string]: string } {
    return {
      fileKey: 'fileKey',
      originalFilename: 'originalFilename',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileKey: 'string',
      originalFilename: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WorkitemAttachmentCreateResponseBody extends $tea.Model {
  /**
   * @example
   * SYSTEM_UNKNOWN_ERROR
   */
  errorCode?: string;
  /**
   * @example
   * InvalidTagGroup.IdNotFoundntraceId: 2137844496.4337.16624448853053831
   */
  errorMessage?: string;
  /**
   * @example
   * F590C9D8-E908-5B6C-95AC-56B7E8011FFA
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'errorCode',
      errorMessage: 'errorMessage',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WorkitemAttachmentCreateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: WorkitemAttachmentCreateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: WorkitemAttachmentCreateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGroupMemberResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 30
   */
  accessLevel?: number;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 123456
   */
  id?: number;
  /**
   * @example
   * codeup
   */
  name?: string;
  /**
   * @example
   * 223241
   */
  sourceId?: number;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * test-codeup
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      sourceId: 'sourceId',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      sourceId: 'number',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddRepositoryMemberResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 40
   */
  accessLevel?: number;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 123456
   */
  id?: number;
  /**
   * @example
   * active
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      state: 'state',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWebhookResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 2022-03-12 12:00:00
   */
  createdAt?: string;
  description?: string;
  /**
   * @example
   * false
   */
  enableSslVerification?: boolean;
  /**
   * @example
   * 30815
   */
  id?: number;
  /**
   * @example
   * ok
   */
  lastTestResult?: string;
  /**
   * @example
   * true
   */
  mergeRequestsEvents?: boolean;
  /**
   * @example
   * false
   */
  noteEvents?: boolean;
  /**
   * @example
   * true
   */
  pushEvents?: boolean;
  /**
   * @example
   * 2835387
   */
  repositoryId?: number;
  /**
   * @example
   * xxxx
   */
  secretToken?: string;
  /**
   * @example
   * true
   */
  tagPushEvents?: boolean;
  /**
   * @example
   * https://xxxxx
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      createdAt: 'createdAt',
      description: 'description',
      enableSslVerification: 'enableSslVerification',
      id: 'id',
      lastTestResult: 'lastTestResult',
      mergeRequestsEvents: 'mergeRequestsEvents',
      noteEvents: 'noteEvents',
      pushEvents: 'pushEvents',
      repositoryId: 'repositoryId',
      secretToken: 'secretToken',
      tagPushEvents: 'tagPushEvents',
      url: 'url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdAt: 'string',
      description: 'string',
      enableSslVerification: 'boolean',
      id: 'number',
      lastTestResult: 'string',
      mergeRequestsEvents: 'boolean',
      noteEvents: 'boolean',
      pushEvents: 'boolean',
      repositoryId: 'number',
      secretToken: 'string',
      tagPushEvents: 'boolean',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseMergeRequestResponseBodyResult extends $tea.Model {
  /**
   * @example
   * true
   */
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAppMembersRequestPlayerList extends $tea.Model {
  /**
   * @example
   * 1332695887xxxxxx
   */
  id?: string;
  /**
   * @example
   * User
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBranchResponseBodyResultCommit extends $tea.Model {
  /**
   * @example
   * username@example.com
   */
  authorEmail?: string;
  authorName?: string;
  /**
   * @example
   * 2022-03-18 09:00:00
   */
  authoredDate?: string;
  /**
   * @example
   * 2022-03-18 10:00:00
   */
  committedDate?: string;
  /**
   * @example
   * username@example.com
   */
  committerEmail?: string;
  committerName?: string;
  /**
   * @example
   * 2022-03-18 10:00:00
   */
  createdAt?: string;
  /**
   * @example
   * ff4fb5ac6d1f44f452654336d2dba468ae6c8d04
   */
  id?: string;
  /**
   * @example
   * create branch
   */
  message?: string;
  parentIds?: string[];
  /**
   * @example
   * ff4fb5ac
   */
  shortId?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      authoredDate: 'authoredDate',
      committedDate: 'committedDate',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorEmail: 'string',
      authorName: 'string',
      authoredDate: 'string',
      committedDate: 'string',
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBranchResponseBodyResult extends $tea.Model {
  commit?: CreateBranchResponseBodyResultCommit;
  /**
   * @example
   * createBranch
   */
  name?: string;
  /**
   * @example
   * false
   */
  protected?: boolean;
  static names(): { [key: string]: string } {
    return {
      commit: 'commit',
      name: 'name',
      protected: 'protected',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commit: CreateBranchResponseBodyResultCommit,
      name: 'string',
      protected: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunRequestAnnotations extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * notice
   */
  annotationLevel?: string;
  /**
   * @example
   * 5
   */
  endColumn?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2
   */
  endLine?: number;
  /**
   * @remarks
   * This parameter is required.
   */
  message?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * demo/test.txt
   */
  path?: string;
  rawDetails?: string;
  /**
   * @example
   * 3
   */
  startColumn?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1
   */
  startLine?: number;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      annotationLevel: 'annotationLevel',
      endColumn: 'endColumn',
      endLine: 'endLine',
      message: 'message',
      path: 'path',
      rawDetails: 'rawDetails',
      startColumn: 'startColumn',
      startLine: 'startLine',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotationLevel: 'string',
      endColumn: 'number',
      endLine: 'number',
      message: 'string',
      path: 'string',
      rawDetails: 'string',
      startColumn: 'number',
      startLine: 'number',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunRequestOutputImages extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test-image-alt
   */
  alt?: string;
  /**
   * @example
   * test
   */
  caption?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * xxx
   */
  imageUrl?: string;
  static names(): { [key: string]: string } {
    return {
      alt: 'alt',
      caption: 'caption',
      imageUrl: 'imageUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alt: 'string',
      caption: 'string',
      imageUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunRequestOutput extends $tea.Model {
  images?: CreateCheckRunRequestOutputImages[];
  /**
   * @remarks
   * This parameter is required.
   */
  summary?: string;
  text?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Mighty Readme report
   */
  title?: string;
  static names(): { [key: string]: string } {
    return {
      images: 'images',
      summary: 'summary',
      text: 'text',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      images: { 'type': 'array', 'itemType': CreateCheckRunRequestOutputImages },
      summary: 'string',
      text: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunResponseBodyResultAnnotations extends $tea.Model {
  /**
   * @example
   * notice
   */
  annotationLevel?: string;
  /**
   * @example
   * 5
   */
  endColumn?: number;
  /**
   * @example
   * 2
   */
  endLine?: number;
  /**
   * @example
   * 2
   */
  id?: number;
  message?: string;
  /**
   * @example
   * demo/test.txt
   */
  path?: string;
  rawDetails?: string;
  /**
   * @example
   * 3
   */
  startColumn?: number;
  /**
   * @example
   * 1
   */
  startLine?: number;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      annotationLevel: 'annotationLevel',
      endColumn: 'endColumn',
      endLine: 'endLine',
      id: 'id',
      message: 'message',
      path: 'path',
      rawDetails: 'rawDetails',
      startColumn: 'startColumn',
      startLine: 'startLine',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotationLevel: 'string',
      endColumn: 'number',
      endLine: 'number',
      id: 'number',
      message: 'string',
      path: 'string',
      rawDetails: 'string',
      startColumn: 'number',
      startLine: 'number',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunResponseBodyResultCheckSuite extends $tea.Model {
  /**
   * @example
   * 1
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunResponseBodyResultOutputImages extends $tea.Model {
  /**
   * @example
   * test-image-alt
   */
  alt?: string;
  /**
   * @example
   * test
   */
  caption?: string;
  /**
   * @example
   * xxx
   */
  imageUrl?: string;
  static names(): { [key: string]: string } {
    return {
      alt: 'alt',
      caption: 'caption',
      imageUrl: 'imageUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alt: 'string',
      caption: 'string',
      imageUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunResponseBodyResultOutput extends $tea.Model {
  images?: CreateCheckRunResponseBodyResultOutputImages[];
  summary?: string;
  text?: string;
  /**
   * @example
   * Mighty Readme report
   */
  title?: string;
  static names(): { [key: string]: string } {
    return {
      images: 'images',
      summary: 'summary',
      text: 'text',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      images: { 'type': 'array', 'itemType': CreateCheckRunResponseBodyResultOutputImages },
      summary: 'string',
      text: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunResponseBodyResultWriter extends $tea.Model {
  /**
   * @example
   * xxx
   */
  id?: string;
  /**
   * @example
   * xxx
   */
  logoUrl?: string;
  /**
   * @example
   * test-codeup
   */
  name?: string;
  /**
   * @example
   * test-codeup
   */
  slug?: string;
  /**
   * @example
   * User
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      logoUrl: 'logoUrl',
      name: 'name',
      slug: 'slug',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      logoUrl: 'string',
      name: 'string',
      slug: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCheckRunResponseBodyResult extends $tea.Model {
  annotations?: CreateCheckRunResponseBodyResultAnnotations[];
  checkSuite?: CreateCheckRunResponseBodyResultCheckSuite;
  /**
   * @example
   * 2023-03-15T08:00:00Z
   */
  completedAt?: string;
  /**
   * @example
   * success
   */
  conclusion?: string;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  createdAt?: string;
  /**
   * @example
   * xxx
   */
  detailsUrl?: string;
  /**
   * @example
   * 42
   */
  externalId?: string;
  /**
   * @example
   * 40f4ccfe019cdd4a62d4acb0c57130106fc7e1be
   */
  headSha?: string;
  /**
   * @example
   * 524836
   */
  id?: number;
  /**
   * @example
   * my-check-ci
   */
  name?: string;
  output?: CreateCheckRunResponseBodyResultOutput;
  /**
   * @example
   * 2023-03-15T08:00:00Z
   */
  startedAt?: string;
  /**
   * @example
   * completed
   */
  status?: string;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  updatedAt?: string;
  writer?: CreateCheckRunResponseBodyResultWriter;
  static names(): { [key: string]: string } {
    return {
      annotations: 'annotations',
      checkSuite: 'checkSuite',
      completedAt: 'completedAt',
      conclusion: 'conclusion',
      createdAt: 'createdAt',
      detailsUrl: 'detailsUrl',
      externalId: 'externalId',
      headSha: 'headSha',
      id: 'id',
      name: 'name',
      output: 'output',
      startedAt: 'startedAt',
      status: 'status',
      updatedAt: 'updatedAt',
      writer: 'writer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotations: { 'type': 'array', 'itemType': CreateCheckRunResponseBodyResultAnnotations },
      checkSuite: CreateCheckRunResponseBodyResultCheckSuite,
      completedAt: 'string',
      conclusion: 'string',
      createdAt: 'string',
      detailsUrl: 'string',
      externalId: 'string',
      headSha: 'string',
      id: 'number',
      name: 'string',
      output: CreateCheckRunResponseBodyResultOutput,
      startedAt: 'string',
      status: 'string',
      updatedAt: 'string',
      writer: CreateCheckRunResponseBodyResultWriter,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommentResponseBodyResultAuthor extends $tea.Model {
  /**
   * @example
   * 284692704493684695
   */
  aliyunPk?: string;
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 19927
   */
  id?: number;
  /**
   * @example
   * test-codeup
   */
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * test-codeup
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommentResponseBodyResultRelatedPatchSet extends $tea.Model {
  /**
   * @example
   * 1a072f5367c21f9de3464b8c0ee8546e47764d2d
   */
  commitId?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  createdAt?: string;
  /**
   * @example
   * 513fcfd81a9142d2bb0db4f72c0aa15b
   */
  patchSetBizId?: string;
  patchSetName?: string;
  /**
   * @example
   * 1
   */
  patchSetNo?: string;
  /**
   * @example
   * MERGE_SOURCE
   */
  relatedMergeItemType?: string;
  /**
   * @example
   * 1a072f53
   */
  shortId?: string;
  static names(): { [key: string]: string } {
    return {
      commitId: 'commitId',
      createdAt: 'createdAt',
      patchSetBizId: 'patchSetBizId',
      patchSetName: 'patchSetName',
      patchSetNo: 'patchSetNo',
      relatedMergeItemType: 'relatedMergeItemType',
      shortId: 'shortId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commitId: 'string',
      createdAt: 'string',
      patchSetBizId: 'string',
      patchSetName: 'string',
      patchSetNo: 'string',
      relatedMergeItemType: 'string',
      shortId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommentResponseBodyResult extends $tea.Model {
  author?: CreateCommentResponseBodyResultAuthor;
  /**
   * @example
   * 5c399e3685e542a28db16d93e9f82abb
   */
  commentBizId?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  commentTime?: string;
  /**
   * @example
   * GLOBAL_COMMENT
   */
  commentType?: string;
  /**
   * @example
   * xxxx
   */
  content?: string;
  /**
   * @example
   * false
   */
  deleted?: boolean;
  /**
   * @example
   * src/main/update.txt
   */
  filePath?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  lastEditTime?: string;
  /**
   * @example
   * 3
   */
  lineNumber?: string;
  /**
   * @example
   * 4c5dcec6a8dc41e69c369737dadc1841
   */
  parentCommentBizId?: string;
  relatedPatchSet?: CreateCommentResponseBodyResultRelatedPatchSet;
  /**
   * @example
   * false
   */
  resolved?: boolean;
  /**
   * @example
   * dcf2b23cebfc418f98dbd35e423d9fd3
   */
  rootCommentBizId?: string;
  /**
   * @example
   * OPENED
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      commentBizId: 'commentBizId',
      commentTime: 'commentTime',
      commentType: 'commentType',
      content: 'content',
      deleted: 'deleted',
      filePath: 'filePath',
      lastEditTime: 'lastEditTime',
      lineNumber: 'lineNumber',
      parentCommentBizId: 'parentCommentBizId',
      relatedPatchSet: 'relatedPatchSet',
      resolved: 'resolved',
      rootCommentBizId: 'rootCommentBizId',
      state: 'state',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: CreateCommentResponseBodyResultAuthor,
      commentBizId: 'string',
      commentTime: 'string',
      commentType: 'string',
      content: 'string',
      deleted: 'boolean',
      filePath: 'string',
      lastEditTime: 'string',
      lineNumber: 'string',
      parentCommentBizId: 'string',
      relatedPatchSet: CreateCommentResponseBodyResultRelatedPatchSet,
      resolved: 'boolean',
      rootCommentBizId: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitStatusResponseBodyResultCreator extends $tea.Model {
  /**
   * @example
   * 204485087002425236
   */
  aliyunPk?: number;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * codeup
   */
  login?: string;
  /**
   * @example
   * User
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      avatarUrl: 'avatarUrl',
      login: 'login',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'number',
      avatarUrl: 'string',
      login: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitStatusResponseBodyResult extends $tea.Model {
  /**
   * @example
   * default
   */
  context?: string;
  creator?: CreateCommitStatusResponseBodyResultCreator;
  description?: string;
  /**
   * @example
   * 30815
   */
  id?: number;
  /**
   * @example
   * c0ca103441b9fa7f369be8d24a6f20db44dfddf7
   */
  sha?: string;
  /**
   * @example
   * success
   */
  state?: string;
  /**
   * @example
   * xxx
   */
  targetUrl?: string;
  static names(): { [key: string]: string } {
    return {
      context: 'context',
      creator: 'creator',
      description: 'description',
      id: 'id',
      sha: 'sha',
      state: 'state',
      targetUrl: 'targetUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      context: 'string',
      creator: CreateCommitStatusResponseBodyResultCreator,
      description: 'string',
      id: 'number',
      sha: 'string',
      state: 'string',
      targetUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitWithMultipleFilesRequestActions extends $tea.Model {
  /**
   * @example
   * create
   */
  action?: string;
  /**
   * @example
   * xxx
   */
  content?: string;
  /**
   * @example
   * src/test.java
   */
  filePath?: string;
  /**
   * @example
   * src/main/test.java
   */
  previousPath?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'action',
      content: 'content',
      filePath: 'filePath',
      previousPath: 'previousPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      content: 'string',
      filePath: 'string',
      previousPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitWithMultipleFilesResponseBodyResultAuthor extends $tea.Model {
  /**
   * @example
   * 284692704493684695
   */
  aliyunPk?: string;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c4ef67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 19927
   */
  id?: number;
  /**
   * @example
   * test-codeup
   */
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * test-codeup
   */
  username?: string;
  /**
   * @example
   * ""
   */
  websiteUrl?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
      websiteUrl: 'websiteUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
      websiteUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitWithMultipleFilesResponseBodyResultCommitter extends $tea.Model {
  /**
   * @example
   * 235671547828975455
   */
  aliyunPk?: string;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 24661
   */
  id?: number;
  /**
   * @example
   * committer-codeup
   */
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * committer-codeup
   */
  username?: string;
  /**
   * @example
   * ""
   */
  websiteUrl?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
      websiteUrl: 'websiteUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
      websiteUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommitWithMultipleFilesResponseBodyResult extends $tea.Model {
  author?: CreateCommitWithMultipleFilesResponseBodyResultAuthor;
  /**
   * @example
   * username@example.com
   */
  authorEmail?: string;
  /**
   * @example
   * test-codeup
   */
  authorName?: string;
  /**
   * @example
   * 2022-03-18 15:00:00
   */
  authoredDate?: string;
  /**
   * @example
   * 2022-03-18 16:00:00
   */
  committedDate?: string;
  committer?: CreateCommitWithMultipleFilesResponseBodyResultCommitter;
  /**
   * @example
   * username@example.com
   */
  committerEmail?: string;
  /**
   * @example
   * committer-codeup
   */
  committerName?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  createdAt?: string;
  /**
   * @example
   * de02b625ba8488f92eb204bcb3773a40c1b4ddac
   */
  id?: string;
  message?: string;
  parentIds?: string[];
  /**
   * @example
   * de02b625
   */
  shortId?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      authoredDate: 'authoredDate',
      committedDate: 'committedDate',
      committer: 'committer',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: CreateCommitWithMultipleFilesResponseBodyResultAuthor,
      authorEmail: 'string',
      authorName: 'string',
      authoredDate: 'string',
      committedDate: 'string',
      committer: CreateCommitWithMultipleFilesResponseBodyResultCommitter,
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeployKeyResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  createdAt?: string;
  /**
   * @example
   * xx:xx:xx:xx
   */
  fingerprint?: string;
  /**
   * @example
   * 502385
   */
  id?: number;
  /**
   * @example
   * ""
   */
  key?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      createdAt: 'createdAt',
      fingerprint: 'fingerprint',
      id: 'id',
      key: 'key',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdAt: 'string',
      fingerprint: 'string',
      id: 'number',
      key: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileResponseBodyResult extends $tea.Model {
  /**
   * @example
   * master
   */
  branchName?: string;
  /**
   * @example
   * /src/main/test.java
   */
  filePath?: string;
  static names(): { [key: string]: string } {
    return {
      branchName: 'branchName',
      filePath: 'filePath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      branchName: 'string',
      filePath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMergeRequestResponseBodyResultAuthor extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 19230
   */
  id?: number;
  /**
   * @example
   * test-codeup
   */
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * test-codeup-nickname
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMergeRequestResponseBodyResultReviewers extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * false
   */
  hasReviewed?: boolean;
  /**
   * @example
   * 7905
   */
  id?: number;
  /**
   * @example
   * codeup
   */
  name?: string;
  /**
   * @example
   * PASS
   */
  reviewOpinionStatus?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * root-codeup
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      hasReviewed: 'hasReviewed',
      id: 'id',
      name: 'name',
      reviewOpinionStatus: 'reviewOpinionStatus',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      hasReviewed: 'boolean',
      id: 'number',
      name: 'string',
      reviewOpinionStatus: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMergeRequestResponseBodyResultSubscribers extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 10092
   */
  id?: number;
  /**
   * @example
   * test-codeup
   */
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * root-test-codeup
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMergeRequestResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 2
   */
  ahead?: number;
  /**
   * @example
   * true
   */
  allRequirementsPass?: boolean;
  author?: CreateMergeRequestResponseBodyResultAuthor;
  /**
   * @example
   * 0
   */
  behind?: number;
  /**
   * @example
   * WEB
   */
  createFrom?: string;
  /**
   * @example
   * 2023-06-02T03:41:22Z
   */
  createTime?: string;
  description?: string;
  /**
   * @example
   * xxx
   */
  detailUrl?: string;
  /**
   * @example
   * 1
   */
  localId?: number;
  /**
   * @example
   * bca90244c4b749e0b109df52ac0eb570
   */
  mrBizId?: string;
  /**
   * @example
   * CODE_REVIEW
   */
  mrType?: string;
  /**
   * @example
   * 2369234
   */
  projectId?: number;
  reviewers?: CreateMergeRequestResponseBodyResultReviewers[];
  /**
   * @example
   * sourceBranch
   */
  sourceBranch?: string;
  /**
   * @example
   * 2369234
   */
  sourceProjectId?: number;
  /**
   * @example
   * UNDER_REVIEW
   */
  status?: string;
  subscribers?: CreateMergeRequestResponseBodyResultSubscribers[];
  /**
   * @example
   * true
   */
  supportMergeFastForwardOnly?: boolean;
  /**
   * @example
   * targetBranch
   */
  targetBranch?: string;
  /**
   * @example
   * 2369234
   */
  targetProjectId?: number;
  title?: string;
  /**
   * @example
   * 2023-06-02T03:41:22Z
   */
  updateTime?: string;
  /**
   * @example
   * https://codeup.aliyun.com/xxx/test/test
   */
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      ahead: 'ahead',
      allRequirementsPass: 'allRequirementsPass',
      author: 'author',
      behind: 'behind',
      createFrom: 'createFrom',
      createTime: 'createTime',
      description: 'description',
      detailUrl: 'detailUrl',
      localId: 'localId',
      mrBizId: 'mrBizId',
      mrType: 'mrType',
      projectId: 'projectId',
      reviewers: 'reviewers',
      sourceBranch: 'sourceBranch',
      sourceProjectId: 'sourceProjectId',
      status: 'status',
      subscribers: 'subscribers',
      supportMergeFastForwardOnly: 'supportMergeFastForwardOnly',
      targetBranch: 'targetBranch',
      targetProjectId: 'targetProjectId',
      title: 'title',
      updateTime: 'updateTime',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ahead: 'number',
      allRequirementsPass: 'boolean',
      author: CreateMergeRequestResponseBodyResultAuthor,
      behind: 'number',
      createFrom: 'string',
      createTime: 'string',
      description: 'string',
      detailUrl: 'string',
      localId: 'number',
      mrBizId: 'string',
      mrType: 'string',
      projectId: 'number',
      reviewers: { 'type': 'array', 'itemType': CreateMergeRequestResponseBodyResultReviewers },
      sourceBranch: 'string',
      sourceProjectId: 'number',
      status: 'string',
      subscribers: { 'type': 'array', 'itemType': CreateMergeRequestResponseBodyResultSubscribers },
      supportMergeFastForwardOnly: 'boolean',
      targetBranch: 'string',
      targetProjectId: 'number',
      title: 'string',
      updateTime: 'string',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOAuthTokenResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 2aeb4cd012af879e54f0d37dfa526f51
   */
  accessToken?: string;
  /**
   * @remarks
   * id
   * 
   * @example
   * 30815
   */
  id?: string;
  /**
   * @example
   * read:repo
   */
  scope?: string;
  /**
   * @example
   * code
   */
  tokenType?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'accessToken',
      id: 'id',
      scope: 'scope',
      tokenType: 'tokenType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      id: 'string',
      scope: 'string',
      tokenType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePipelineGroupResponseBodyPipelineGroup extends $tea.Model {
  /**
   * @example
   * 111
   */
  id?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectResponseBodyProject extends $tea.Model {
  /**
   * @example
   * Project
   */
  categoryIdentifier?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  creator?: string;
  /**
   * @example
   * OJAY
   */
  customCode?: string;
  /**
   * @example
   * xxx
   */
  description?: string;
  /**
   * @example
   * 1623916393000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1623916393000
   */
  gmtModified?: number;
  /**
   * @example
   * https://xxxxxx.png
   */
  icon?: string;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  identifier?: string;
  /**
   * @example
   * NORMAL
   */
  logicalStatus?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  modifier?: string;
  /**
   * @example
   * demo示例项目
   */
  name?: string;
  /**
   * @example
   * 5e70xxxxxxcd000xxxxe96
   */
  organizationIdentifier?: string;
  /**
   * @example
   * public
   */
  scope?: string;
  /**
   * @example
   * 8a40xxxxxxxxxxxxx64
   */
  statusIdentifier?: string;
  /**
   * @example
   * 1
   */
  statusStageIdentifier?: string;
  /**
   * @example
   * CustomProject
   */
  typeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      customCode: 'customCode',
      description: 'description',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      icon: 'icon',
      identifier: 'identifier',
      logicalStatus: 'logicalStatus',
      modifier: 'modifier',
      name: 'name',
      organizationIdentifier: 'organizationIdentifier',
      scope: 'scope',
      statusIdentifier: 'statusIdentifier',
      statusStageIdentifier: 'statusStageIdentifier',
      typeIdentifier: 'typeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryIdentifier: 'string',
      creator: 'string',
      customCode: 'string',
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      icon: 'string',
      identifier: 'string',
      logicalStatus: 'string',
      modifier: 'string',
      name: 'string',
      organizationIdentifier: 'string',
      scope: 'string',
      statusIdentifier: 'string',
      statusStageIdentifier: 'string',
      typeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectLabelResponseBodyResult extends $tea.Model {
  /**
   * @example
   * #006AD4
   */
  color?: string;
  description?: string;
  /**
   * @example
   * b5b5738b94954bc6aa5a293316ed1d24
   */
  id?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      color: 'color',
      description: 'description',
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      color: 'string',
      description: 'string',
      id: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchRequestMergeRequestSetting extends $tea.Model {
  allowMergeRequestRoles?: number[];
  defaultAssignees?: string[];
  /**
   * @example
   * true
   */
  isAllowSelfApproval?: boolean;
  /**
   * @example
   * true
   */
  isRequireDiscussionProcessed?: boolean;
  /**
   * @example
   * true
   */
  isRequired?: boolean;
  /**
   * @example
   * false
   */
  isResetApprovalWhenNewPush?: boolean;
  /**
   * @example
   * 1
   */
  minimumApproval?: number;
  /**
   * @example
   * general
   */
  mrMode?: string;
  /**
   * @example
   * **.java
   */
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      allowMergeRequestRoles: 'allowMergeRequestRoles',
      defaultAssignees: 'defaultAssignees',
      isAllowSelfApproval: 'isAllowSelfApproval',
      isRequireDiscussionProcessed: 'isRequireDiscussionProcessed',
      isRequired: 'isRequired',
      isResetApprovalWhenNewPush: 'isResetApprovalWhenNewPush',
      minimumApproval: 'minimumApproval',
      mrMode: 'mrMode',
      whiteList: 'whiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowMergeRequestRoles: { 'type': 'array', 'itemType': 'number' },
      defaultAssignees: { 'type': 'array', 'itemType': 'string' },
      isAllowSelfApproval: 'boolean',
      isRequireDiscussionProcessed: 'boolean',
      isRequired: 'boolean',
      isResetApprovalWhenNewPush: 'boolean',
      minimumApproval: 'number',
      mrMode: 'string',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchRequestTestSettingDTOCheckConfigCheckItems extends $tea.Model {
  /**
   * @example
   * false
   */
  isRequired?: boolean;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      isRequired: 'isRequired',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isRequired: 'boolean',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchRequestTestSettingDTOCheckConfig extends $tea.Model {
  checkItems?: CreateProtectdBranchRequestTestSettingDTOCheckConfigCheckItems[];
  static names(): { [key: string]: string } {
    return {
      checkItems: 'checkItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkItems: { 'type': 'array', 'itemType': CreateProtectdBranchRequestTestSettingDTOCheckConfigCheckItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchRequestTestSettingDTOCheckTaskQualityConfig extends $tea.Model {
  /**
   * @example
   * 123456
   */
  bizNo?: string;
  /**
   * @example
   * false
   */
  enabled?: boolean;
  /**
   * @example
   * test_task_quality
   */
  message?: string;
  /**
   * @example
   * bz-task-quality
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      bizNo: 'bizNo',
      enabled: 'enabled',
      message: 'message',
      taskName: 'taskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizNo: 'string',
      enabled: 'boolean',
      message: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchRequestTestSettingDTOCodeGuidelinesDetection extends $tea.Model {
  /**
   * @example
   * false
   */
  enabled?: boolean;
  /**
   * @example
   * test_code_guide_lines
   */
  message?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'enabled',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchRequestTestSettingDTOSensitiveInfoDetection extends $tea.Model {
  /**
   * @example
   * false
   */
  enabled?: boolean;
  /**
   * @example
   * test_code_sensitive_info
   */
  message?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'enabled',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchRequestTestSettingDTO extends $tea.Model {
  checkConfig?: CreateProtectdBranchRequestTestSettingDTOCheckConfig;
  checkTaskQualityConfig?: CreateProtectdBranchRequestTestSettingDTOCheckTaskQualityConfig;
  codeGuidelinesDetection?: CreateProtectdBranchRequestTestSettingDTOCodeGuidelinesDetection;
  /**
   * @example
   * false
   */
  isRequired?: boolean;
  sensitiveInfoDetection?: CreateProtectdBranchRequestTestSettingDTOSensitiveInfoDetection;
  static names(): { [key: string]: string } {
    return {
      checkConfig: 'checkConfig',
      checkTaskQualityConfig: 'checkTaskQualityConfig',
      codeGuidelinesDetection: 'codeGuidelinesDetection',
      isRequired: 'isRequired',
      sensitiveInfoDetection: 'sensitiveInfoDetection',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkConfig: CreateProtectdBranchRequestTestSettingDTOCheckConfig,
      checkTaskQualityConfig: CreateProtectdBranchRequestTestSettingDTOCheckTaskQualityConfig,
      codeGuidelinesDetection: CreateProtectdBranchRequestTestSettingDTOCodeGuidelinesDetection,
      isRequired: 'boolean',
      sensitiveInfoDetection: CreateProtectdBranchRequestTestSettingDTOSensitiveInfoDetection,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchResponseBodyResultMergeRequestSetting extends $tea.Model {
  allowMergeRequestRoles?: number[];
  defaultAssignees?: string[];
  /**
   * @example
   * true
   */
  isAllowSelfApproval?: boolean;
  /**
   * @example
   * true
   */
  isRequireDiscussionProcessed?: boolean;
  /**
   * @example
   * true
   */
  isRequired?: boolean;
  /**
   * @example
   * false
   */
  isResetApprovalWhenNewPush?: boolean;
  /**
   * @example
   * 1
   */
  minimumApproval?: number;
  /**
   * @example
   * general
   */
  mrMode?: string;
  /**
   * @example
   * **.java
   */
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      allowMergeRequestRoles: 'allowMergeRequestRoles',
      defaultAssignees: 'defaultAssignees',
      isAllowSelfApproval: 'isAllowSelfApproval',
      isRequireDiscussionProcessed: 'isRequireDiscussionProcessed',
      isRequired: 'isRequired',
      isResetApprovalWhenNewPush: 'isResetApprovalWhenNewPush',
      minimumApproval: 'minimumApproval',
      mrMode: 'mrMode',
      whiteList: 'whiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowMergeRequestRoles: { 'type': 'array', 'itemType': 'number' },
      defaultAssignees: { 'type': 'array', 'itemType': 'string' },
      isAllowSelfApproval: 'boolean',
      isRequireDiscussionProcessed: 'boolean',
      isRequired: 'boolean',
      isResetApprovalWhenNewPush: 'boolean',
      minimumApproval: 'number',
      mrMode: 'string',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfigCheckItems extends $tea.Model {
  /**
   * @example
   * false
   */
  isRequired?: boolean;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      isRequired: 'isRequired',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isRequired: 'boolean',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfig extends $tea.Model {
  checkItems?: CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfigCheckItems[];
  static names(): { [key: string]: string } {
    return {
      checkItems: 'checkItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkItems: { 'type': 'array', 'itemType': CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfigCheckItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchResponseBodyResultTestSettingDTOCheckTaskQualityConfig extends $tea.Model {
  /**
   * @example
   * 123456
   */
  bizNo?: string;
  /**
   * @example
   * false
   */
  enabled?: boolean;
  /**
   * @example
   * test_task_quality
   */
  message?: string;
  /**
   * @example
   * biz-task-quality
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      bizNo: 'bizNo',
      enabled: 'enabled',
      message: 'message',
      taskName: 'taskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizNo: 'string',
      enabled: 'boolean',
      message: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchResponseBodyResultTestSettingDTOCodeGuidelinesDetection extends $tea.Model {
  /**
   * @example
   * false
   */
  enabled?: boolean;
  /**
   * @example
   * test_code_guide_lines
   */
  message?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'enabled',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchResponseBodyResultTestSettingDTOSensitiveInfoDetection extends $tea.Model {
  /**
   * @example
   * false
   */
  enabled?: boolean;
  /**
   * @example
   * test_code_sensitive_info
   */
  message?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'enabled',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchResponseBodyResultTestSettingDTO extends $tea.Model {
  checkConfig?: CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfig;
  checkTaskQualityConfig?: CreateProtectdBranchResponseBodyResultTestSettingDTOCheckTaskQualityConfig;
  codeGuidelinesDetection?: CreateProtectdBranchResponseBodyResultTestSettingDTOCodeGuidelinesDetection;
  /**
   * @example
   * false
   */
  isRequired?: boolean;
  sensitiveInfoDetection?: CreateProtectdBranchResponseBodyResultTestSettingDTOSensitiveInfoDetection;
  static names(): { [key: string]: string } {
    return {
      checkConfig: 'checkConfig',
      checkTaskQualityConfig: 'checkTaskQualityConfig',
      codeGuidelinesDetection: 'codeGuidelinesDetection',
      isRequired: 'isRequired',
      sensitiveInfoDetection: 'sensitiveInfoDetection',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkConfig: CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfig,
      checkTaskQualityConfig: CreateProtectdBranchResponseBodyResultTestSettingDTOCheckTaskQualityConfig,
      codeGuidelinesDetection: CreateProtectdBranchResponseBodyResultTestSettingDTOCodeGuidelinesDetection,
      isRequired: 'boolean',
      sensitiveInfoDetection: CreateProtectdBranchResponseBodyResultTestSettingDTOSensitiveInfoDetection,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProtectdBranchResponseBodyResult extends $tea.Model {
  allowMergeRoles?: number[];
  allowMergeUserIds?: number[];
  allowPushRoles?: number[];
  allowPushUserIds?: number[];
  /**
   * @example
   * protectBranch
   */
  branch?: string;
  /**
   * @example
   * 5240
   */
  id?: number;
  mergeRequestSetting?: CreateProtectdBranchResponseBodyResultMergeRequestSetting;
  testSettingDTO?: CreateProtectdBranchResponseBodyResultTestSettingDTO;
  static names(): { [key: string]: string } {
    return {
      allowMergeRoles: 'allowMergeRoles',
      allowMergeUserIds: 'allowMergeUserIds',
      allowPushRoles: 'allowPushRoles',
      allowPushUserIds: 'allowPushUserIds',
      branch: 'branch',
      id: 'id',
      mergeRequestSetting: 'mergeRequestSetting',
      testSettingDTO: 'testSettingDTO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowMergeRoles: { 'type': 'array', 'itemType': 'number' },
      allowMergeUserIds: { 'type': 'array', 'itemType': 'number' },
      allowPushRoles: { 'type': 'array', 'itemType': 'number' },
      allowPushUserIds: { 'type': 'array', 'itemType': 'number' },
      branch: 'string',
      id: 'number',
      mergeRequestSetting: CreateProtectdBranchResponseBodyResultMergeRequestSetting,
      testSettingDTO: CreateProtectdBranchResponseBodyResultTestSettingDTO,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePushRuleRequestRuleInfos extends $tea.Model {
  /**
   * @example
   * CommitMessageChecker
   */
  checkerName?: string;
  /**
   * @example
   * warn
   */
  checkerType?: string;
  /**
   * @example
   * user@example.com
   */
  extraMessage?: string;
  fileRuleRegexes?: string[];
  static names(): { [key: string]: string } {
    return {
      checkerName: 'checkerName',
      checkerType: 'checkerType',
      extraMessage: 'extraMessage',
      fileRuleRegexes: 'fileRuleRegexes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkerName: 'string',
      checkerType: 'string',
      extraMessage: 'string',
      fileRuleRegexes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePushRuleResponseBodyResultRuleInfos extends $tea.Model {
  /**
   * @example
   * ForcePushChecker
   */
  checkerName?: string;
  /**
   * @example
   * warn
   */
  checkerType?: string;
  /**
   * @example
   * disabled
   */
  extraMessage?: string;
  fileRuleRegexes?: string[];
  static names(): { [key: string]: string } {
    return {
      checkerName: 'checkerName',
      checkerType: 'checkerType',
      extraMessage: 'extraMessage',
      fileRuleRegexes: 'fileRuleRegexes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkerName: 'string',
      checkerType: 'string',
      extraMessage: 'string',
      fileRuleRegexes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePushRuleResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 2023-09-03T18:20:06+08:00
   */
  gmtCreate?: string;
  /**
   * @example
   * 2023-09-03T18:20:06+08:00
   */
  gmtModified?: string;
  /**
   * @example
   * 2077
   */
  id?: number;
  ruleInfos?: CreatePushRuleResponseBodyResultRuleInfos[];
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      id: 'id',
      ruleInfos: 'ruleInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      ruleInfos: { 'type': 'array', 'itemType': CreatePushRuleResponseBodyResultRuleInfos },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRepositoryResponseBodyResultNamespace extends $tea.Model {
  /**
   * @example
   * ""
   */
  avatar?: string;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  createdAt?: string;
  /**
   * @example
   * codeup repo description
   */
  description?: string;
  /**
   * @remarks
   * id
   * 
   * @example
   * 3194
   */
  id?: number;
  /**
   * @example
   * codeup
   */
  name?: string;
  /**
   * @example
   * 123
   */
  ownerId?: number;
  /**
   * @example
   * codeup
   */
  path?: string;
  /**
   * @example
   * true
   */
  public?: boolean;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  updatedAt?: string;
  /**
   * @example
   * 0
   */
  visibilityLevel?: string;
  static names(): { [key: string]: string } {
    return {
      avatar: 'avatar',
      createdAt: 'createdAt',
      description: 'description',
      id: 'id',
      name: 'name',
      ownerId: 'ownerId',
      path: 'path',
      public: 'public',
      updatedAt: 'updatedAt',
      visibilityLevel: 'visibilityLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatar: 'string',
      createdAt: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
      ownerId: 'number',
      path: 'string',
      public: 'boolean',
      updatedAt: 'string',
      visibilityLevel: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRepositoryResponseBodyResult extends $tea.Model {
  /**
   * @example
   * false
   */
  importFromSvn?: boolean;
  /**
   * @example
   * false
   */
  archived?: boolean;
  /**
   * @example
   * ""
   */
  avatarUrl?: string;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  createdAt?: string;
  /**
   * @example
   * 1233
   */
  creatorId?: number;
  /**
   * @example
   * master
   */
  defaultBranch?: string;
  /**
   * @example
   * false
   */
  demoProject?: boolean;
  description?: string;
  /**
   * @example
   * ""
   */
  httpUrlToRepo?: string;
  /**
   * @remarks
   * id
   * 
   * @example
   * 2959
   */
  id?: number;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  lastActivityAt?: string;
  /**
   * @example
   * codeupTest
   */
  name?: string;
  /**
   * @example
   * codeup-test-org / test-codeup
   */
  nameWithNamespace?: string;
  namespace?: CreateRepositoryResponseBodyResultNamespace;
  /**
   * @example
   * test-codeup
   */
  path?: string;
  /**
   * @example
   * codeup-test-org/test-codeup
   */
  pathWithNamespace?: string;
  /**
   * @example
   * ""
   */
  sshUrlToRepo?: string;
  /**
   * @example
   * 0
   */
  visibilityLevel?: string;
  /**
   * @remarks
   * web url
   * 
   * @example
   * ""
   */
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      importFromSvn: 'Import_from_svn',
      archived: 'archived',
      avatarUrl: 'avatar_url',
      createdAt: 'createdAt',
      creatorId: 'creatorId',
      defaultBranch: 'defaultBranch',
      demoProject: 'demoProject',
      description: 'description',
      httpUrlToRepo: 'httpUrlToRepo',
      id: 'id',
      lastActivityAt: 'lastActivityAt',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      namespace: 'namespace',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      sshUrlToRepo: 'sshUrlToRepo',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      importFromSvn: 'boolean',
      archived: 'boolean',
      avatarUrl: 'string',
      createdAt: 'string',
      creatorId: 'number',
      defaultBranch: 'string',
      demoProject: 'boolean',
      description: 'string',
      httpUrlToRepo: 'string',
      id: 'number',
      lastActivityAt: 'string',
      name: 'string',
      nameWithNamespace: 'string',
      namespace: CreateRepositoryResponseBodyResultNamespace,
      path: 'string',
      pathWithNamespace: 'string',
      sshUrlToRepo: 'string',
      visibilityLevel: 'string',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRepositoryGroupResponseBodyResult extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  description?: string;
  /**
   * @example
   * 18685
   */
  id?: number;
  /**
   * @example
   * test-create-group
   */
  name?: string;
  nameWithNamespace?: string;
  /**
   * @example
   * 19230
   */
  ownerId?: number;
  /**
   * @example
   * 26842
   */
  parentId?: number;
  /**
   * @example
   * test-create-group
   */
  path?: string;
  /**
   * @example
   * codeup-test-org/test-create-group
   */
  pathWithNamespace?: string;
  /**
   * @example
   * Group
   */
  type?: string;
  /**
   * @example
   * 10
   */
  visibilityLevel?: number;
  /**
   * @example
   * ""
   */
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      description: 'description',
      id: 'id',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      ownerId: 'ownerId',
      parentId: 'parentId',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      type: 'type',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
      nameWithNamespace: 'string',
      ownerId: 'number',
      parentId: 'number',
      path: 'string',
      pathWithNamespace: 'string',
      type: 'string',
      visibilityLevel: 'number',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSprintResponseBodySprint extends $tea.Model {
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  creator?: string;
  /**
   * @example
   * xxx
   */
  description?: string;
  /**
   * @example
   * 1623916393000
   */
  endDate?: number;
  /**
   * @example
   * 1623916393000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1623916393000
   */
  gmtModified?: number;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  identifier?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  modifier?: string;
  /**
   * @example
   * demo示例项目
   */
  name?: string;
  /**
   * @example
   * public
   */
  scope?: string;
  /**
   * @example
   * 5e70xxxxxxcd000xxxxe96
   */
  spaceIdentifier?: string;
  /**
   * @example
   * 1638403200000
   */
  startDate?: number;
  /**
   * @example
   * TODO
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      creator: 'creator',
      description: 'description',
      endDate: 'endDate',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      modifier: 'modifier',
      name: 'name',
      scope: 'scope',
      spaceIdentifier: 'spaceIdentifier',
      startDate: 'startDate',
      status: 'status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creator: 'string',
      description: 'string',
      endDate: 'number',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      modifier: 'string',
      name: 'string',
      scope: 'string',
      spaceIdentifier: 'string',
      startDate: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSshKeyResponseBodySshKey extends $tea.Model {
  /**
   * @example
   * 123
   */
  id?: number;
  /**
   * @example
   * assssssssssss
   */
  publicKey?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      publicKey: 'publicKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      publicKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagResponseBodyResultCommit extends $tea.Model {
  /**
   * @example
   * username@example.com
   */
  authorEmail?: string;
  authorName?: string;
  /**
   * @example
   * 2022-03-18 10:00:00
   */
  authoredDate?: string;
  /**
   * @example
   * 2022-03-18 09:00:00
   */
  committedDate?: string;
  /**
   * @example
   * username@example.com
   */
  committerEmail?: string;
  committerName?: string;
  /**
   * @example
   * 2022-03-18 10:00:00
   */
  createdAt?: string;
  /**
   * @example
   * e0297d8fb0393c833a8531e7cc8832739e3cba6d
   */
  id?: string;
  message?: string;
  parentIds?: string[];
  /**
   * @example
   * e0297d8f
   */
  shortId?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      authoredDate: 'authoredDate',
      committedDate: 'committedDate',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorEmail: 'string',
      authorName: 'string',
      authoredDate: 'string',
      committedDate: 'string',
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagResponseBodyResult extends $tea.Model {
  commit?: CreateTagResponseBodyResultCommit;
  /**
   * @example
   * 0e3b6aa5eab2b086b59fde74766b28d4e5faab0d
   */
  id?: string;
  message?: string;
  /**
   * @example
   * v1.0
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      commit: 'commit',
      id: 'id',
      message: 'message',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commit: CreateTagResponseBodyResultCommit,
      id: 'string',
      message: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseRequestFieldValueList extends $tea.Model {
  /**
   * @example
   * 6aexxxxxa1d98c09c60xxxx16
   */
  fieldIdentifier?: string;
  /**
   * @example
   * 77c7fb03c4186c8691d6...
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      fieldIdentifier: 'fieldIdentifier',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldIdentifier: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseRequestTestcaseStepContentInfoStepResultList extends $tea.Model {
  expected?: string;
  step?: string;
  static names(): { [key: string]: string } {
    return {
      expected: 'expected',
      step: 'step',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expected: 'string',
      step: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseRequestTestcaseStepContentInfo extends $tea.Model {
  precondition?: string;
  stepResultList?: CreateTestCaseRequestTestcaseStepContentInfoStepResultList[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * TEXT
   */
  stepType?: string;
  static names(): { [key: string]: string } {
    return {
      precondition: 'precondition',
      stepResultList: 'stepResultList',
      stepType: 'stepType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      precondition: 'string',
      stepResultList: { 'type': 'array', 'itemType': CreateTestCaseRequestTestcaseStepContentInfoStepResultList },
      stepType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponseBodyTestcaseAssignedTo extends $tea.Model {
  /**
   * @example
   * 134xxx343xxxxx
   */
  assignIdentifier?: string;
  name?: string;
  /**
   * @example
   * 3c2253c22xxxxxxxx53a
   */
  tbRoleId?: string;
  static names(): { [key: string]: string } {
    return {
      assignIdentifier: 'assignIdentifier',
      name: 'name',
      tbRoleId: 'tbRoleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignIdentifier: 'string',
      name: 'string',
      tbRoleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponseBodyTestcaseCreator extends $tea.Model {
  /**
   * @example
   * 134xxx343xxxxx
   */
  createIdentifier?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      createIdentifier: 'createIdentifier',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createIdentifier: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponseBodyTestcaseDetailInfoExpectedResult extends $tea.Model {
  expectContent?: string;
  /**
   * @example
   * RICHTEXT
   */
  expectContentType?: string;
  /**
   * @example
   * 59253164xxxxxxf2e98dbc7e27
   */
  expectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      expectContent: 'expectContent',
      expectContentType: 'expectContentType',
      expectIdentifier: 'expectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expectContent: 'string',
      expectContentType: 'string',
      expectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponseBodyTestcaseDetailInfoPrecondition extends $tea.Model {
  preContent?: string;
  /**
   * @example
   * RICHTEXT
   */
  preContentType?: string;
  /**
   * @example
   * 59253164xxxxxxf2e98dbc7e27
   */
  preIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      preContent: 'preContent',
      preContentType: 'preContentType',
      preIdentifier: 'preIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preContent: 'string',
      preContentType: 'string',
      preIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponseBodyTestcaseDetailInfoStepContent extends $tea.Model {
  stepContent?: string;
  /**
   * @example
   * RICHTEXT
   */
  stepContentType?: string;
  /**
   * @example
   * 59253164xxxxxxf2e98dbc7e27
   */
  stepIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      stepContent: 'stepContent',
      stepContentType: 'stepContentType',
      stepIdentifier: 'stepIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      stepContent: 'string',
      stepContentType: 'string',
      stepIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponseBodyTestcaseDetailInfo extends $tea.Model {
  expectedResult?: CreateTestCaseResponseBodyTestcaseDetailInfoExpectedResult;
  precondition?: CreateTestCaseResponseBodyTestcaseDetailInfoPrecondition;
  stepContent?: CreateTestCaseResponseBodyTestcaseDetailInfoStepContent;
  /**
   * @example
   * TEXT/TABLE
   */
  stepType?: string;
  static names(): { [key: string]: string } {
    return {
      expectedResult: 'expectedResult',
      precondition: 'precondition',
      stepContent: 'stepContent',
      stepType: 'stepType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expectedResult: CreateTestCaseResponseBodyTestcaseDetailInfoExpectedResult,
      precondition: CreateTestCaseResponseBodyTestcaseDetailInfoPrecondition,
      stepContent: CreateTestCaseResponseBodyTestcaseDetailInfoStepContent,
      stepType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponseBodyTestcaseDirectory extends $tea.Model {
  /**
   * @example
   * 0bc1150dcxxxxxxxx04c
   */
  childIdentifier?: string;
  /**
   * @example
   * 0bc1150dcxxxxxxxx04c
   */
  directoryIdentifier?: string;
  name?: string;
  pathName?: string[];
  static names(): { [key: string]: string } {
    return {
      childIdentifier: 'childIdentifier',
      directoryIdentifier: 'directoryIdentifier',
      name: 'name',
      pathName: 'pathName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      childIdentifier: 'string',
      directoryIdentifier: 'string',
      name: 'string',
      pathName: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponseBodyTestcaseModifier extends $tea.Model {
  /**
   * @example
   * 134xxx343xxxxx
   */
  modifyIdentifier?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      modifyIdentifier: 'modifyIdentifier',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      modifyIdentifier: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTestCaseResponseBodyTestcase extends $tea.Model {
  assignedTo?: CreateTestCaseResponseBodyTestcaseAssignedTo;
  /**
   * @example
   * TestCase
   */
  categoryIdentifier?: string;
  creator?: CreateTestCaseResponseBodyTestcaseCreator;
  detailInfo?: CreateTestCaseResponseBodyTestcaseDetailInfo;
  directory?: CreateTestCaseResponseBodyTestcaseDirectory;
  /**
   * @example
   * 5a73f81c834d013361d92bdcce
   */
  identifier?: string;
  modifier?: CreateTestCaseResponseBodyTestcaseModifier;
  /**
   * @example
   * a18571eba8fe9267cd8375fc06
   */
  spaceIdentifier?: string;
  /**
   * @example
   * TestRepo
   */
  spaceType?: string;
  subject?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      detailInfo: 'detailInfo',
      directory: 'directory',
      identifier: 'identifier',
      modifier: 'modifier',
      spaceIdentifier: 'spaceIdentifier',
      spaceType: 'spaceType',
      subject: 'subject',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: CreateTestCaseResponseBodyTestcaseAssignedTo,
      categoryIdentifier: 'string',
      creator: CreateTestCaseResponseBodyTestcaseCreator,
      detailInfo: CreateTestCaseResponseBodyTestcaseDetailInfo,
      directory: CreateTestCaseResponseBodyTestcaseDirectory,
      identifier: 'string',
      modifier: CreateTestCaseResponseBodyTestcaseModifier,
      spaceIdentifier: 'string',
      spaceType: 'string',
      subject: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserKeyResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 2022-03-12 12:00:00
   */
  createdAt?: string;
  /**
   * @example
   * 2022-03-12 12:00:00
   */
  expireTime?: string;
  /**
   * @example
   * xxx
   */
  fingerPrint?: string;
  /**
   * @example
   * 11072
   */
  id?: number;
  /**
   * @example
   * ALL
   */
  keyScope?: string;
  /**
   * @example
   * 2022-03-12 12:00:00
   */
  lastUsedTime?: string;
  /**
   * @example
   * xxx
   */
  publicKey?: string;
  /**
   * @example
   * My Title
   */
  title?: string;
  static names(): { [key: string]: string } {
    return {
      createdAt: 'createdAt',
      expireTime: 'expireTime',
      fingerPrint: 'fingerPrint',
      id: 'id',
      keyScope: 'keyScope',
      lastUsedTime: 'lastUsedTime',
      publicKey: 'publicKey',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdAt: 'string',
      expireTime: 'string',
      fingerPrint: 'string',
      id: 'number',
      keyScope: 'string',
      lastUsedTime: 'string',
      publicKey: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemRequestFieldValueList extends $tea.Model {
  /**
   * @example
   * 6aexxxxxa1d98c09c60xxxx16
   */
  fieldIdentifier?: string;
  /**
   * @example
   * 77c7fb03c4186c8691d6...
   */
  value?: string;
  /**
   * @example
   * null
   */
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      fieldIdentifier: 'fieldIdentifier',
      value: 'value',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldIdentifier: 'string',
      value: 'string',
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemResponseBodyWorkitem extends $tea.Model {
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  assignedTo?: string;
  /**
   * @example
   * Req
   */
  categoryIdentifier?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  creator?: string;
  /**
   * @example
   * html格式
   */
  document?: string;
  documentFormat?: string;
  /**
   * @example
   * 1640850318000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1640850318000
   */
  gmtModified?: number;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  identifier?: string;
  /**
   * @example
   * NORMAL
   */
  logicalStatus?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  modifier?: string;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx24
   */
  parentIdentifier?: string;
  /**
   * @example
   * ABCD-1
   */
  serialNumber?: string;
  /**
   * @example
   * e8b26xxxxx6e76aa20xxxxx23
   */
  spaceIdentifier?: string;
  /**
   * @example
   * 需求项目
   */
  spaceName?: string;
  /**
   * @example
   * Project
   */
  spaceType?: string;
  /**
   * @example
   * 75528f17703e92e5a568......
   */
  sprintIdentifier?: string;
  /**
   * @example
   * 待处理
   */
  status?: string;
  /**
   * @example
   * 28
   */
  statusIdentifier?: string;
  /**
   * @example
   * 100005
   */
  statusStageIdentifier?: string;
  /**
   * @example
   * 测试工作项
   */
  subject?: string;
  /**
   * @example
   * 1640850328000
   */
  updateStatusAt?: number;
  /**
   * @example
   * 9uxxxxxxre573f5xxxxxx0
   */
  workitemTypeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      document: 'document',
      documentFormat: 'documentFormat',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      logicalStatus: 'logicalStatus',
      modifier: 'modifier',
      parentIdentifier: 'parentIdentifier',
      serialNumber: 'serialNumber',
      spaceIdentifier: 'spaceIdentifier',
      spaceName: 'spaceName',
      spaceType: 'spaceType',
      sprintIdentifier: 'sprintIdentifier',
      status: 'status',
      statusIdentifier: 'statusIdentifier',
      statusStageIdentifier: 'statusStageIdentifier',
      subject: 'subject',
      updateStatusAt: 'updateStatusAt',
      workitemTypeIdentifier: 'workitemTypeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: 'string',
      categoryIdentifier: 'string',
      creator: 'string',
      document: 'string',
      documentFormat: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      logicalStatus: 'string',
      modifier: 'string',
      parentIdentifier: 'string',
      serialNumber: 'string',
      spaceIdentifier: 'string',
      spaceName: 'string',
      spaceType: 'string',
      sprintIdentifier: 'string',
      status: 'string',
      statusIdentifier: 'string',
      statusStageIdentifier: 'string',
      subject: 'string',
      updateStatusAt: 'number',
      workitemTypeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemCommentResponseBodyCommentUser extends $tea.Model {
  /**
   * @example
   * 13164xxxxx41068
   */
  account?: string;
  /**
   * @example
   * https://xxxxx/thumbnail/112m7150e256dbba0d6456bafbb65c81f90d/w/200/h/200
   */
  avatar?: string;
  displayName?: string;
  /**
   * @example
   * 1e9903d8bxxxxxxe9df9286ef5
   */
  identifier?: string;
  nickName?: string;
  realName?: string;
  /**
   * @example
   * workitem
   */
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'account',
      avatar: 'avatar',
      displayName: 'displayName',
      identifier: 'identifier',
      nickName: 'nickName',
      realName: 'realName',
      targetType: 'targetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      avatar: 'string',
      displayName: 'string',
      identifier: 'string',
      nickName: 'string',
      realName: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemCommentResponseBodyComment extends $tea.Model {
  /**
   * @example
   * 26842
   */
  id?: number;
  content?: string;
  /**
   * @example
   * 1667202662000
   */
  createTime?: number;
  /**
   * @example
   * RICHTEXT/MARKDOWN
   */
  formatType?: string;
  /**
   * @example
   * true/false
   */
  isTop?: boolean;
  /**
   * @example
   * 1637995553000
   */
  modifiedTime?: number;
  /**
   * @example
   * 26842
   */
  parentId?: number;
  /**
   * @example
   * 79d523806bdxxxxx95612a5154
   */
  targetIdentifier?: string;
  /**
   * @example
   * workitem
   */
  targetType?: string;
  /**
   * @example
   * 1667202662000
   */
  topTime?: number;
  user?: CreateWorkitemCommentResponseBodyCommentUser;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      content: 'content',
      createTime: 'createTime',
      formatType: 'formatType',
      isTop: 'isTop',
      modifiedTime: 'modifiedTime',
      parentId: 'parentId',
      targetIdentifier: 'targetIdentifier',
      targetType: 'targetType',
      topTime: 'topTime',
      user: 'user',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      content: 'string',
      createTime: 'number',
      formatType: 'string',
      isTop: 'boolean',
      modifiedTime: 'number',
      parentId: 'number',
      targetIdentifier: 'string',
      targetType: 'string',
      topTime: 'number',
      user: CreateWorkitemCommentResponseBodyCommentUser,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser extends $tea.Model {
  /**
   * @example
   * 1316458xxxxx41068
   */
  account?: string;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112m7150e256dbba0d6456bafbb65c81f90d/w/200/h/200
   */
  avatar?: string;
  /**
   * @example
   * fdsad12xxx11
   */
  dingTalkId?: string;
  displayName?: string;
  /**
   * @example
   * wangwu
   */
  displayNickName?: string;
  /**
   * @example
   * wangwu
   */
  displayRealName?: string;
  /**
   * @example
   * xxxxxxcc@xxx.com
   */
  email?: string;
  gender?: string;
  /**
   * @example
   * deafe5f33xxxxx6a259d8dafd
   */
  identifier?: string;
  /**
   * @example
   * true/false
   */
  isDisabled?: boolean;
  mobile?: string;
  /**
   * @example
   * wangwu
   */
  nameEn?: string;
  nickName?: string;
  /**
   * @example
   * wangwu
   */
  nickNamePinyin?: string;
  realName?: string;
  /**
   * @example
   * wangwu
   */
  realNamePinyin?: string;
  stamp?: string;
  /**
   * @example
   * 9144ef6b72d8exxxxx9e61a4d0
   */
  tbRoleId?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'account',
      avatar: 'avatar',
      dingTalkId: 'dingTalkId',
      displayName: 'displayName',
      displayNickName: 'displayNickName',
      displayRealName: 'displayRealName',
      email: 'email',
      gender: 'gender',
      identifier: 'identifier',
      isDisabled: 'isDisabled',
      mobile: 'mobile',
      nameEn: 'nameEn',
      nickName: 'nickName',
      nickNamePinyin: 'nickNamePinyin',
      realName: 'realName',
      realNamePinyin: 'realNamePinyin',
      stamp: 'stamp',
      tbRoleId: 'tbRoleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      avatar: 'string',
      dingTalkId: 'string',
      displayName: 'string',
      displayNickName: 'string',
      displayRealName: 'string',
      email: 'string',
      gender: 'string',
      identifier: 'string',
      isDisabled: 'boolean',
      mobile: 'string',
      nameEn: 'string',
      nickName: 'string',
      nickNamePinyin: 'string',
      realName: 'string',
      realNamePinyin: 'string',
      stamp: 'string',
      tbRoleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemEstimateResponseBodyWorkitemTimeEstimate extends $tea.Model {
  description?: string;
  /**
   * @example
   * deafe5f33xxxxx6a259d8dafd
   */
  identifier?: string;
  recordUser?: CreateWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser;
  /**
   * @example
   * 11
   */
  spentTime?: number;
  /**
   * @example
   * 9144ef6b72d8exxxxx9e61a4d0
   */
  type?: string;
  /**
   * @example
   * 1e9903d8b3f1xxxxxf9286ef5
   */
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'description',
      identifier: 'identifier',
      recordUser: 'recordUser',
      spentTime: 'spentTime',
      type: 'type',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      identifier: 'string',
      recordUser: CreateWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser,
      spentTime: 'number',
      type: 'string',
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemRecordResponseBodyWorkitemTimeRecordUser extends $tea.Model {
  /**
   * @example
   * 1316458xxxxx41068
   */
  account?: string;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112m7150e256dbba0d6456bafbb65c81f90d/w/200/h/200
   */
  avatar?: string;
  /**
   * @example
   * xx12322
   */
  dingTalkId?: string;
  displayName?: string;
  displayNickName?: string;
  displayRealName?: string;
  /**
   * @example
   * xxx@xxx.com
   */
  email?: string;
  gender?: string;
  /**
   * @example
   * deafe5f33xxxxx6a259d8dafd
   */
  identifier?: string;
  /**
   * @example
   * true/false
   */
  isDisabled?: boolean;
  mobile?: string;
  /**
   * @example
   * wangwu
   */
  nameEn?: string;
  nickName?: string;
  /**
   * @example
   * wangwu
   */
  nickNamePinyin?: string;
  realName?: string;
  /**
   * @example
   * wangwu
   */
  realNamePinyin?: string;
  stamp?: string;
  /**
   * @example
   * 1e9903d8b3f1xxxxxf9286ef5
   */
  tbRoleId?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'account',
      avatar: 'avatar',
      dingTalkId: 'dingTalkId',
      displayName: 'displayName',
      displayNickName: 'displayNickName',
      displayRealName: 'displayRealName',
      email: 'email',
      gender: 'gender',
      identifier: 'identifier',
      isDisabled: 'isDisabled',
      mobile: 'mobile',
      nameEn: 'nameEn',
      nickName: 'nickName',
      nickNamePinyin: 'nickNamePinyin',
      realName: 'realName',
      realNamePinyin: 'realNamePinyin',
      stamp: 'stamp',
      tbRoleId: 'tbRoleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      avatar: 'string',
      dingTalkId: 'string',
      displayName: 'string',
      displayNickName: 'string',
      displayRealName: 'string',
      email: 'string',
      gender: 'string',
      identifier: 'string',
      isDisabled: 'boolean',
      mobile: 'string',
      nameEn: 'string',
      nickName: 'string',
      nickNamePinyin: 'string',
      realName: 'string',
      realNamePinyin: 'string',
      stamp: 'string',
      tbRoleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemRecordResponseBodyWorkitemTime extends $tea.Model {
  /**
   * @example
   * 12
   */
  actualTime?: number;
  description?: string;
  /**
   * @example
   * 1667205617089
   */
  gmtEnd?: number;
  /**
   * @example
   * 1667205617061
   */
  gmtStart?: number;
  /**
   * @example
   * deafe5f33xxxxx6a259d8dafd
   */
  identifier?: string;
  recordUser?: CreateWorkitemRecordResponseBodyWorkitemTimeRecordUser;
  /**
   * @example
   * deafe5f33xxxxx6a259d8dafd
   */
  type?: string;
  /**
   * @example
   * 9144ef6b72d8exxxxx9e61a4d0
   */
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      actualTime: 'actualTime',
      description: 'description',
      gmtEnd: 'gmtEnd',
      gmtStart: 'gmtStart',
      identifier: 'identifier',
      recordUser: 'recordUser',
      type: 'type',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualTime: 'number',
      description: 'string',
      gmtEnd: 'number',
      gmtStart: 'number',
      identifier: 'string',
      recordUser: CreateWorkitemRecordResponseBodyWorkitemTimeRecordUser,
      type: 'string',
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkitemV2RequestFieldValueList extends $tea.Model {
  /**
   * @example
   * 6aexxxxxa1d98c09c60xxxx16
   */
  fieldIdentifier?: string;
  /**
   * @example
   * 10
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      fieldIdentifier: 'fieldIdentifier',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldIdentifier: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceResponseBodyWorkspace extends $tea.Model {
  /**
   * @example
   * 1628564442000
   */
  createTime?: string;
  /**
   * @example
   * 1470227819xxxxxx
   */
  creator?: string;
  /**
   * @example
   * 6ed82817-ab75-4563-865d-81e60dxxxxxx
   */
  id?: string;
  /**
   * @example
   * Demo
   */
  name?: string;
  /**
   * @example
   * SUCCESS
   */
  status?: string;
  /**
   * @example
   * all-in-one
   */
  template?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'createTime',
      creator: 'creator',
      id: 'id',
      name: 'name',
      status: 'status',
      template: 'template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      creator: 'string',
      id: 'string',
      name: 'string',
      status: 'string',
      template: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBranchResponseBodyResult extends $tea.Model {
  /**
   * @example
   * deleteBranch
   */
  branchName?: string;
  static names(): { [key: string]: string } {
    return {
      branchName: 'branchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      branchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFileResponseBodyResult extends $tea.Model {
  /**
   * @example
   * master
   */
  branchName?: string;
  /**
   * @example
   * src/main/delete.java
   */
  filePath?: string;
  static names(): { [key: string]: string } {
    return {
      branchName: 'branchName',
      filePath: 'filePath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      branchName: 'string',
      filePath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGroupMemberResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 40
   */
  accessLevel?: number;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * 524836
   */
  id?: number;
  /**
   * @example
   * USERS
   */
  memberType?: string;
  /**
   * @example
   * codeup
   */
  name?: string;
  /**
   * @example
   * 2080398
   */
  sourceId?: number;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * test-codeup
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      avatarUrl: 'avatarUrl',
      id: 'id',
      memberType: 'memberType',
      name: 'name',
      sourceId: 'sourceId',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      avatarUrl: 'string',
      id: 'number',
      memberType: 'string',
      name: 'string',
      sourceId: 'number',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectLabelResponseBodyResult extends $tea.Model {
  /**
   * @example
   * true
   */
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProtectedBranchResponseBodyResult extends $tea.Model {
  /**
   * @example
   * true
   */
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePushRuleResponseBodyResult extends $tea.Model {
  /**
   * @example
   * true
   */
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryResponseBodyResult extends $tea.Model {
  /**
   * @example
   * true
   */
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryGroupResponseBodyResult extends $tea.Model {
  /**
   * @example
   * true
   */
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryMemberResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 30
   */
  accessLevel?: number;
  /**
   * @example
   * 2022-03-12 12:00:00
   */
  createAt?: string;
  /**
   * @example
   * 30815
   */
  id?: number;
  /**
   * @example
   * 2080398
   */
  sourceId?: number;
  /**
   * @example
   * Project
   */
  sourceType?: string;
  /**
   * @example
   * 2022-03-12 12:00:00
   */
  updateAt?: string;
  /**
   * @example
   * 19280
   */
  userId?: number;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      createAt: 'createAt',
      id: 'id',
      sourceId: 'sourceId',
      sourceType: 'sourceType',
      updateAt: 'updateAt',
      userId: 'userId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      createAt: 'string',
      id: 'number',
      sourceId: 'number',
      sourceType: 'string',
      updateAt: 'string',
      userId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRepositoryWebhookResponseBodyResult extends $tea.Model {
  /**
   * @example
   * false
   */
  buildEvents?: boolean;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  createdAt?: string;
  description?: string;
  /**
   * @example
   * false
   */
  enableSslVerification?: boolean;
  /**
   * @example
   * 524836
   */
  id?: number;
  /**
   * @example
   * false
   */
  issuesEvents?: boolean;
  /**
   * @example
   * ""
   */
  lastTestResult?: string;
  /**
   * @example
   * true
   */
  mergeRequestsEvents?: boolean;
  /**
   * @example
   * true
   */
  noteEvents?: boolean;
  /**
   * @example
   * 2369234
   */
  projectId?: number;
  /**
   * @example
   * true
   */
  pushEvents?: boolean;
  /**
   * @example
   * xxxx
   */
  secretToken?: string;
  /**
   * @example
   * true
   */
  tagPushEvents?: boolean;
  /**
   * @example
   * ProjectHook
   */
  type?: string;
  /**
   * @example
   * https://xxxxx
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      buildEvents: 'buildEvents',
      createdAt: 'createdAt',
      description: 'description',
      enableSslVerification: 'enableSslVerification',
      id: 'id',
      issuesEvents: 'issuesEvents',
      lastTestResult: 'lastTestResult',
      mergeRequestsEvents: 'mergeRequestsEvents',
      noteEvents: 'noteEvents',
      projectId: 'projectId',
      pushEvents: 'pushEvents',
      secretToken: 'secretToken',
      tagPushEvents: 'tagPushEvents',
      type: 'type',
      url: 'url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      buildEvents: 'boolean',
      createdAt: 'string',
      description: 'string',
      enableSslVerification: 'boolean',
      id: 'number',
      issuesEvents: 'boolean',
      lastTestResult: 'string',
      mergeRequestsEvents: 'boolean',
      noteEvents: 'boolean',
      projectId: 'number',
      pushEvents: 'boolean',
      secretToken: 'string',
      tagPushEvents: 'boolean',
      type: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagResponseBodyResult extends $tea.Model {
  /**
   * @example
   * v1.0
   */
  tagName?: string;
  static names(): { [key: string]: string } {
    return {
      tagName: 'tagName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserKeyResponseBodyResult extends $tea.Model {
  /**
   * @example
   * xxx
   */
  context?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  createdAt?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  expireTime?: string;
  /**
   * @example
   * xxx
   */
  fingerPrint?: string;
  /**
   * @example
   * 50998
   */
  id?: number;
  /**
   * @example
   * ALL
   */
  keyScope?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  lastUsedTime?: string;
  /**
   * @example
   * xxx
   */
  publicKey?: string;
  /**
   * @example
   * xxx
   */
  shaContext?: string;
  title?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  updatedAt?: string;
  static names(): { [key: string]: string } {
    return {
      context: 'context',
      createdAt: 'createdAt',
      expireTime: 'expireTime',
      fingerPrint: 'fingerPrint',
      id: 'id',
      keyScope: 'keyScope',
      lastUsedTime: 'lastUsedTime',
      publicKey: 'publicKey',
      shaContext: 'shaContext',
      title: 'title',
      updatedAt: 'updatedAt',
    };
  }

  static types(): { [key: string]: any } {
    return {
      context: 'string',
      createdAt: 'string',
      expireTime: 'string',
      fingerPrint: 'string',
      id: 'number',
      keyScope: 'string',
      lastUsedTime: 'string',
      publicKey: 'string',
      shaContext: 'string',
      title: 'string',
      updatedAt: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeployKeyResponseBodyResult extends $tea.Model {
  /**
   * @example
   * true
   */
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightCustomValueResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 66.6
   */
  doubleValue?: number;
  /**
   * @example
   * 34dde3dfa5e3750151a7c4xxxx
   */
  fieldId?: string;
  /**
   * @example
   * 1704950971000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1714669494000
   */
  gmtModified?: number;
  /**
   * @example
   * 320737507
   */
  id?: number;
  /**
   * @example
   * 442d4a6a9980e841dc192a411080xxxx
   */
  identifier?: string;
  /**
   * @example
   * N
   */
  isDeleted?: string;
  /**
   * @example
   * 66
   */
  longValue?: number;
  /**
   * @example
   * 61db9af2148974246bexxxx
   */
  organizationId?: string;
  /**
   * @example
   * 1ee00fcb1a18c2dc83dafdxxxx
   */
  targetId?: string;
  /**
   * @example
   * Workitem
   */
  targetType?: string;
  /**
   * @example
   * string
   */
  type?: string;
  /**
   * @example
   * 66
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      doubleValue: 'doubleValue',
      fieldId: 'fieldId',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      id: 'id',
      identifier: 'identifier',
      isDeleted: 'isDeleted',
      longValue: 'longValue',
      organizationId: 'organizationId',
      targetId: 'targetId',
      targetType: 'targetType',
      type: 'type',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      doubleValue: 'number',
      fieldId: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      id: 'number',
      identifier: 'string',
      isDeleted: 'string',
      longValue: 'number',
      organizationId: 'string',
      targetId: 'string',
      targetType: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightExpectedWorkTimeResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 1714976497000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1714976520000
   */
  gmtModified?: number;
  /**
   * @example
   * 26281535
   */
  id?: number;
  /**
   * @example
   * bd4ddc7b0ea0ef2ab52699xxxx
   */
  identifier?: string;
  /**
   * @example
   * N
   */
  isDeleted?: string;
  /**
   * @example
   * 61db9af2148974246be6xxxx
   */
  organizationId?: string;
  /**
   * @example
   * 6c4687b0179e1d458fedf1xxxx
   */
  projectId?: string;
  /**
   * @example
   * 63466a385dc8531eebd7xxxx
   */
  recorderId?: string;
  /**
   * @example
   * projex
   */
  source?: string;
  type?: string;
  /**
   * @example
   * 180
   */
  value?: number;
  /**
   * @example
   * de7c6fd3bd4b53f4d9e279xxxx
   */
  workitemId?: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      id: 'id',
      identifier: 'identifier',
      isDeleted: 'isDeleted',
      organizationId: 'organizationId',
      projectId: 'projectId',
      recorderId: 'recorderId',
      source: 'source',
      type: 'type',
      value: 'value',
      workitemId: 'workitemId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      gmtModified: 'number',
      id: 'number',
      identifier: 'string',
      isDeleted: 'string',
      organizationId: 'string',
      projectId: 'string',
      recorderId: 'string',
      source: 'string',
      type: 'string',
      value: 'number',
      workitemId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightFieldResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 9798551
   */
  fieldId?: string;
  fieldName?: string;
  /**
   * @example
   * 1713752162000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1714977502000
   */
  gmtModified?: number;
  /**
   * @example
   * 666666
   */
  id?: number;
  /**
   * @example
   * field-444153
   */
  identifier?: string;
  /**
   * @example
   * N
   */
  isDeleted?: string;
  /**
   * @example
   * N
   */
  isSystem?: string;
  optionValue?: string;
  /**
   * @example
   * 61db9af2148974246bexxxx
   */
  organizationId?: string;
  /**
   * @example
   * 150
   */
  position?: number;
  /**
   * @example
   * global
   */
  scope?: string;
  /**
   * @example
   * projex
   */
  source?: string;
  /**
   * @example
   * 61db9af2148974246bexxxx
   */
  targetId?: string;
  /**
   * @example
   * organization
   */
  targetType?: string;
  /**
   * @example
   * string
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      fieldId: 'fieldId',
      fieldName: 'fieldName',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      id: 'id',
      identifier: 'identifier',
      isDeleted: 'isDeleted',
      isSystem: 'isSystem',
      optionValue: 'optionValue',
      organizationId: 'organizationId',
      position: 'position',
      scope: 'scope',
      source: 'source',
      targetId: 'targetId',
      targetType: 'targetType',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldId: 'string',
      fieldName: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      id: 'number',
      identifier: 'string',
      isDeleted: 'string',
      isSystem: 'string',
      optionValue: 'string',
      organizationId: 'string',
      position: 'number',
      scope: 'string',
      source: 'string',
      targetId: 'string',
      targetType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightSpaceResponseBodyResult extends $tea.Model {
  /**
   * @example
   * Project
   */
  category?: string;
  description?: string;
  /**
   * @example
   * 1706510424000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1706511201000
   */
  gmtModified?: number;
  /**
   * @example
   * 11034222
   */
  id?: number;
  /**
   * @example
   * 83a2861bbb43b270a04b42xxxx
   */
  identifier?: string;
  /**
   * @example
   * N
   */
  isDeleted?: string;
  name?: string;
  /**
   * @example
   * 61db9af2148974246be6xxxx
   */
  organizationId?: string;
  /**
   * @example
   * projex
   */
  source?: string;
  /**
   * @example
   * 10
   */
  stage?: string;
  status?: string;
  /**
   * @example
   * Project
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'category',
      description: 'description',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      id: 'id',
      identifier: 'identifier',
      isDeleted: 'isDeleted',
      name: 'name',
      organizationId: 'organizationId',
      source: 'source',
      stage: 'stage',
      status: 'status',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      id: 'number',
      identifier: 'string',
      isDeleted: 'string',
      name: 'string',
      organizationId: 'string',
      source: 'string',
      stage: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightSpaceRefResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 65659358c319d2a0f912xxxx
   */
  creatorId?: string;
  /**
   * @example
   * 7bc2be989727d0d4c9801fxxxx
   */
  fromId?: string;
  /**
   * @example
   * 1704267849000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1704267849000
   */
  gmtModified?: number;
  /**
   * @example
   * 356525
   */
  id?: number;
  /**
   * @example
   * 49565
   */
  identifier?: string;
  /**
   * @example
   * N
   */
  isDeleted?: string;
  /**
   * @example
   * 65659358c319d2a0f912xxxx
   */
  modifierId?: string;
  /**
   * @example
   * 61db9af2148974246bexxxx
   */
  organizationId?: string;
  /**
   * @example
   * 732026500a48d7a74f8b43xxxx
   */
  toId?: string;
  /**
   * @example
   * ASSOCIATED
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      creatorId: 'creatorId',
      fromId: 'fromId',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      id: 'id',
      identifier: 'identifier',
      isDeleted: 'isDeleted',
      modifierId: 'modifierId',
      organizationId: 'organizationId',
      toId: 'toId',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorId: 'string',
      fromId: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      id: 'number',
      identifier: 'string',
      isDeleted: 'string',
      modifierId: 'string',
      organizationId: 'string',
      toId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightSprintResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 1711936113000
   */
  actualEnd?: number;
  /**
   * @example
   * 1711936113000
   */
  actualStart?: number;
  /**
   * @example
   * 1710989643000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1711728000000
   */
  gmtEnd?: number;
  /**
   * @example
   * 1711936113000
   */
  gmtModified?: number;
  /**
   * @example
   * 1711936113000
   */
  gmtStart?: number;
  /**
   * @example
   * 18471761
   */
  id?: number;
  /**
   * @example
   * e4895cadc86632f34dfaa7xxxx
   */
  identifier?: string;
  /**
   * @example
   * N
   */
  isDeleted?: string;
  name?: string;
  /**
   * @example
   * 61db9af2148974246bexxxx
   */
  organizationId?: string;
  /**
   * @example
   * 385e7e5a4be6791f0a5185xxxx
   */
  projectId?: string;
  /**
   * @example
   * projex
   */
  source?: string;
  /**
   * @example
   * 50
   */
  status?: number;
  /**
   * @example
   * 60.0
   */
  workTimeCapacity?: number;
  static names(): { [key: string]: string } {
    return {
      actualEnd: 'actualEnd',
      actualStart: 'actualStart',
      gmtCreate: 'gmtCreate',
      gmtEnd: 'gmtEnd',
      gmtModified: 'gmtModified',
      gmtStart: 'gmtStart',
      id: 'id',
      identifier: 'identifier',
      isDeleted: 'isDeleted',
      name: 'name',
      organizationId: 'organizationId',
      projectId: 'projectId',
      source: 'source',
      status: 'status',
      workTimeCapacity: 'workTimeCapacity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualEnd: 'number',
      actualStart: 'number',
      gmtCreate: 'number',
      gmtEnd: 'number',
      gmtModified: 'number',
      gmtStart: 'number',
      id: 'number',
      identifier: 'string',
      isDeleted: 'string',
      name: 'string',
      organizationId: 'string',
      projectId: 'string',
      source: 'string',
      status: 'number',
      workTimeCapacity: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightTagRefResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 1696660187000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1696660187000
   */
  gmtModified?: number;
  /**
   * @example
   * 41317426
   */
  id?: number;
  /**
   * @example
   * 8545272
   */
  identifier?: string;
  /**
   * @example
   * N
   */
  isDeleted?: string;
  /**
   * @example
   * 1
   */
  name?: string;
  /**
   * @example
   * 61db9af2148974246bexxxx
   */
  organizationId?: string;
  /**
   * @example
   * 19e0bc5348ccbe6c0d00fbxxxx
   */
  tagId?: string;
  /**
   * @example
   * bde89961b5a4acc8cf54eaxxxx
   */
  targetId?: string;
  /**
   * @example
   * Workitem
   */
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      id: 'id',
      identifier: 'identifier',
      isDeleted: 'isDeleted',
      name: 'name',
      organizationId: 'organizationId',
      tagId: 'tagId',
      targetId: 'targetId',
      targetType: 'targetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      gmtModified: 'number',
      id: 'number',
      identifier: 'string',
      isDeleted: 'string',
      name: 'string',
      organizationId: 'string',
      tagId: 'string',
      targetId: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightWorkTimeResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 120
   */
  actualValue?: number;
  description?: string;
  /**
   * @example
   * 1714978610000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1715011199999
   */
  gmtEnd?: number;
  /**
   * @example
   * 1714978610000
   */
  gmtModified?: number;
  /**
   * @example
   * 1714924800000
   */
  gmtStart?: number;
  /**
   * @example
   * 49506082
   */
  id?: number;
  /**
   * @example
   * da70ce5824231ca3c04ef808e0
   */
  identifier?: string;
  /**
   * @example
   * N
   */
  isDeleted?: string;
  /**
   * @example
   * 61db9af2148974246bexxxx
   */
  organizationId?: string;
  /**
   * @example
   * 09670872890eb1a0bb998exxxx
   */
  projectId?: string;
  /**
   * @example
   * 65659358c319d2a0f912xxxx
   */
  recorderId?: string;
  /**
   * @example
   * projex
   */
  source?: string;
  type?: string;
  /**
   * @example
   * 000000000cd82d3df50d5e5a5c094094fd7b4461
   */
  uuid?: string;
  /**
   * @example
   * 120
   */
  value?: number;
  /**
   * @example
   * 17bc1cf9a037a15fc9ce76xxxx
   */
  workitemId?: string;
  static names(): { [key: string]: string } {
    return {
      actualValue: 'actualValue',
      description: 'description',
      gmtCreate: 'gmtCreate',
      gmtEnd: 'gmtEnd',
      gmtModified: 'gmtModified',
      gmtStart: 'gmtStart',
      id: 'id',
      identifier: 'identifier',
      isDeleted: 'isDeleted',
      organizationId: 'organizationId',
      projectId: 'projectId',
      recorderId: 'recorderId',
      source: 'source',
      type: 'type',
      uuid: 'uuid',
      value: 'value',
      workitemId: 'workitemId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualValue: 'number',
      description: 'string',
      gmtCreate: 'number',
      gmtEnd: 'number',
      gmtModified: 'number',
      gmtStart: 'number',
      id: 'number',
      identifier: 'string',
      isDeleted: 'string',
      organizationId: 'string',
      projectId: 'string',
      recorderId: 'string',
      source: 'string',
      type: 'string',
      uuid: 'string',
      value: 'number',
      workitemId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightWorkitemStatusResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 65e836b981d758be7a25xxxx
   */
  assignedToId?: string;
  /**
   * @example
   * 65e836b981d758be7a25xxxx
   */
  creatorId?: string;
  /**
   * @example
   * 10
   */
  expectedWorkTime?: number;
  /**
   * @example
   * 33166339200000
   */
  gmtClosed?: number;
  /**
   * @example
   * 1713430241000
   */
  gmtCreate?: number;
  /**
   * @example
   * 33166339200000
   */
  gmtDue?: number;
  /**
   * @example
   * 1713430241000
   */
  gmtModified?: number;
  /**
   * @example
   * 33166339200000
   */
  gmtStart?: number;
  /**
   * @example
   * 33166339200000
   */
  gmtTodo?: number;
  /**
   * @example
   * 701615370
   */
  id?: number;
  /**
   * @example
   * N
   */
  isArchived?: string;
  /**
   * @example
   * N
   */
  isDeleted?: string;
  /**
   * @example
   * Y
   */
  isDone?: string;
  /**
   * @example
   * 61db9af2148974246bexxxx
   */
  organizationId?: string;
  /**
   * @example
   * c3640ab6233fcc10a7e3aaxxxx
   */
  parentId?: string;
  /**
   * @example
   * 6135b21fb383ef39551cxxxx,63466a385dc8531eebd7xxxx
   */
  participantIds?: string;
  /**
   * @example
   * 10
   */
  phase?: number;
  /**
   * @example
   * 0
   */
  priority?: number;
  productId?: string;
  /**
   * @example
   * 505ac6433dfbda8df0b08bxxxx
   */
  projectId?: string;
  serialNumber?: number;
  /**
   * @example
   * projex
   */
  source?: string;
  /**
   * @example
   * 505ac6433dfbda8df0b08bxxxx
   */
  sprintId?: string;
  /**
   * @example
   * 10
   */
  stage?: number;
  status?: string;
  /**
   * @example
   * 100005
   */
  statusId?: string;
  /**
   * @example
   * 10.0
   */
  storyPoint?: number;
  /**
   * @example
   * 9uy29901re573f561d69xxxx
   */
  subType?: string;
  subject?: string;
  /**
   * @example
   * 1
   */
  type?: number;
  versionId?: string;
  /**
   * @example
   * [6a8cdda167415bea1506c7262c]
   */
  versions?: string;
  /**
   * @example
   * 10
   */
  workTime?: number;
  /**
   * @example
   * 636f661a612a945bbcdb4cxxxx
   */
  workitemId?: string;
  static names(): { [key: string]: string } {
    return {
      assignedToId: 'assignedToId',
      creatorId: 'creatorId',
      expectedWorkTime: 'expectedWorkTime',
      gmtClosed: 'gmtClosed',
      gmtCreate: 'gmtCreate',
      gmtDue: 'gmtDue',
      gmtModified: 'gmtModified',
      gmtStart: 'gmtStart',
      gmtTodo: 'gmtTodo',
      id: 'id',
      isArchived: 'isArchived',
      isDeleted: 'isDeleted',
      isDone: 'isDone',
      organizationId: 'organizationId',
      parentId: 'parentId',
      participantIds: 'participantIds',
      phase: 'phase',
      priority: 'priority',
      productId: 'productId',
      projectId: 'projectId',
      serialNumber: 'serialNumber',
      source: 'source',
      sprintId: 'sprintId',
      stage: 'stage',
      status: 'status',
      statusId: 'statusId',
      storyPoint: 'storyPoint',
      subType: 'subType',
      subject: 'subject',
      type: 'type',
      versionId: 'versionId',
      versions: 'versions',
      workTime: 'workTime',
      workitemId: 'workitemId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedToId: 'string',
      creatorId: 'string',
      expectedWorkTime: 'number',
      gmtClosed: 'number',
      gmtCreate: 'number',
      gmtDue: 'number',
      gmtModified: 'number',
      gmtStart: 'number',
      gmtTodo: 'number',
      id: 'number',
      isArchived: 'string',
      isDeleted: 'string',
      isDone: 'string',
      organizationId: 'string',
      parentId: 'string',
      participantIds: 'string',
      phase: 'number',
      priority: 'number',
      productId: 'string',
      projectId: 'string',
      serialNumber: 'number',
      source: 'string',
      sprintId: 'string',
      stage: 'number',
      status: 'string',
      statusId: 'string',
      storyPoint: 'number',
      subType: 'string',
      subject: 'string',
      type: 'number',
      versionId: 'string',
      versions: 'string',
      workTime: 'number',
      workitemId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 65e836b981d758be7a25xxxx
   */
  assignedToId?: string;
  /**
   * @example
   * 65e836b981d758be7a25xxxx
   */
  creatorId?: string;
  /**
   * @example
   * 10
   */
  expectedWorkTime?: number;
  /**
   * @example
   * 123
   */
  extraId?: number;
  /**
   * @example
   * N
   */
  extraIsDeleted?: string;
  /**
   * @example
   * 10
   */
  foundPhase?: number;
  /**
   * @example
   * 33166339200000
   */
  gmtClosed?: number;
  /**
   * @example
   * 1713430241000
   */
  gmtCreate?: number;
  /**
   * @example
   * 33166339200000
   */
  gmtDue?: number;
  gmtFixed?: string;
  /**
   * @example
   * 1714755985000
   */
  gmtModified?: number;
  /**
   * @example
   * 33166339200000
   */
  gmtStart?: number;
  /**
   * @example
   * 33166339200000
   */
  gmtTodo?: number;
  /**
   * @example
   * 701615370
   */
  id?: number;
  /**
   * @example
   * N
   */
  isArchived?: string;
  /**
   * @example
   * N
   */
  isDeleted?: string;
  /**
   * @example
   * Y
   */
  isDone?: string;
  isStupid?: string;
  /**
   * @example
   * 61db9af2148974246bexxxx
   */
  organizationId?: string;
  /**
   * @example
   * a80a203a9078a7a1b1f2c6xxxx
   */
  parentId?: string;
  /**
   * @example
   * 6135b21fb383ef39551cf02e,63466a385dc8531eebd764e9
   */
  participantIds?: string;
  /**
   * @example
   * 10
   */
  phase?: number;
  /**
   * @example
   * 2
   */
  priority?: number;
  productId?: string;
  /**
   * @example
   * 6732a29d846bf998dc09e7xxxx
   */
  projectId?: string;
  reopenNum?: number;
  serialNumber?: number;
  seriousLevel?: number;
  solution?: string;
  /**
   * @example
   * projex
   */
  source?: string;
  /**
   * @example
   * 731c83a40bbf3c2f080e07xxxx
   */
  sprintId?: string;
  /**
   * @example
   * 10
   */
  stage?: number;
  status?: string;
  /**
   * @example
   * 100005
   */
  statusId?: string;
  /**
   * @example
   * 10.0
   */
  storyPoint?: number;
  /**
   * @example
   * 9uy29901re573f561d69xxxx
   */
  subType?: string;
  subject?: string;
  /**
   * @example
   * 1
   */
  type?: number;
  /**
   * @example
   * 65e836b981d758be7a25xxxx
   */
  verifierId?: string;
  versionId?: string;
  /**
   * @example
   * {6a8cdda167415bea1506c7262c}
   */
  versions?: string;
  /**
   * @example
   * 10
   */
  workTime?: number;
  /**
   * @example
   * 636f661a612a945bbcdb4cxxxx
   */
  workitemId?: string;
  static names(): { [key: string]: string } {
    return {
      assignedToId: 'assignedToId',
      creatorId: 'creatorId',
      expectedWorkTime: 'expectedWorkTime',
      extraId: 'extraId',
      extraIsDeleted: 'extraIsDeleted',
      foundPhase: 'foundPhase',
      gmtClosed: 'gmtClosed',
      gmtCreate: 'gmtCreate',
      gmtDue: 'gmtDue',
      gmtFixed: 'gmtFixed',
      gmtModified: 'gmtModified',
      gmtStart: 'gmtStart',
      gmtTodo: 'gmtTodo',
      id: 'id',
      isArchived: 'isArchived',
      isDeleted: 'isDeleted',
      isDone: 'isDone',
      isStupid: 'isStupid',
      organizationId: 'organizationId',
      parentId: 'parentId',
      participantIds: 'participantIds',
      phase: 'phase',
      priority: 'priority',
      productId: 'productId',
      projectId: 'projectId',
      reopenNum: 'reopenNum',
      serialNumber: 'serialNumber',
      seriousLevel: 'seriousLevel',
      solution: 'solution',
      source: 'source',
      sprintId: 'sprintId',
      stage: 'stage',
      status: 'status',
      statusId: 'statusId',
      storyPoint: 'storyPoint',
      subType: 'subType',
      subject: 'subject',
      type: 'type',
      verifierId: 'verifierId',
      versionId: 'versionId',
      versions: 'versions',
      workTime: 'workTime',
      workitemId: 'workitemId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedToId: 'string',
      creatorId: 'string',
      expectedWorkTime: 'number',
      extraId: 'number',
      extraIsDeleted: 'string',
      foundPhase: 'number',
      gmtClosed: 'number',
      gmtCreate: 'number',
      gmtDue: 'number',
      gmtFixed: 'string',
      gmtModified: 'number',
      gmtStart: 'number',
      gmtTodo: 'number',
      id: 'number',
      isArchived: 'string',
      isDeleted: 'string',
      isDone: 'string',
      isStupid: 'string',
      organizationId: 'string',
      parentId: 'string',
      participantIds: 'string',
      phase: 'number',
      priority: 'number',
      productId: 'string',
      projectId: 'string',
      reopenNum: 'number',
      serialNumber: 'number',
      seriousLevel: 'number',
      solution: 'string',
      source: 'string',
      sprintId: 'string',
      stage: 'number',
      status: 'string',
      statusId: 'string',
      storyPoint: 'number',
      subType: 'string',
      subject: 'string',
      type: 'number',
      verifierId: 'string',
      versionId: 'string',
      versions: 'string',
      workTime: 'number',
      workitemId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportInsightWorkitemVersionResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 1704251228000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1704251228000
   */
  gmtModified?: number;
  /**
   * @example
   * 1704902400000
   */
  gmtPublish?: number;
  /**
   * @example
   * 1704297600000
   */
  gmtStart?: number;
  /**
   * @example
   * 648131
   */
  id?: number;
  /**
   * @example
   * 7ba6e8261b973c976df76b7de1
   */
  identifier?: string;
  /**
   * @example
   * N
   */
  isDeleted?: string;
  /**
   * @example
   * 0
   */
  lockStatus?: number;
  name?: string;
  /**
   * @example
   * 61db9af2148974246bexxxx
   */
  organizationId?: string;
  /**
   * @example
   * projex
   */
  source?: string;
  /**
   * @example
   * 100
   */
  status?: number;
  /**
   * @example
   * 7eee44ec7f699d4e6980faxxxx
   */
  targetId?: string;
  /**
   * @example
   * Project
   */
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      gmtPublish: 'gmtPublish',
      gmtStart: 'gmtStart',
      id: 'id',
      identifier: 'identifier',
      isDeleted: 'isDeleted',
      lockStatus: 'lockStatus',
      name: 'name',
      organizationId: 'organizationId',
      source: 'source',
      status: 'status',
      targetId: 'targetId',
      targetType: 'targetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      gmtModified: 'number',
      gmtPublish: 'number',
      gmtStart: 'number',
      id: 'number',
      identifier: 'string',
      isDeleted: 'string',
      lockStatus: 'number',
      name: 'string',
      organizationId: 'string',
      source: 'string',
      status: 'number',
      targetId: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportWorkitemActivityResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 1714961337000
   */
  gmtEvent?: number;
  /**
   * @example
   * 4406380356
   */
  id?: number;
  /**
   * @example
   * 254662353
   */
  identifier?: string;
  /**
   * @example
   * 1
   */
  newValue?: string;
  /**
   * @example
   * 2
   */
  oldValue?: string;
  /**
   * @example
   * 61db9af2148974246bexxxx
   */
  organizationId?: string;
  /**
   * @example
   * 2a62349afcbef7f23d8f31xxxx
   */
  projectId?: string;
  /**
   * @example
   * projex
   */
  source?: string;
  /**
   * @example
   * workitem.update.priority
   */
  type?: string;
  /**
   * @example
   * ec69eae498acce08ff7260xxxx
   */
  workitemId?: string;
  static names(): { [key: string]: string } {
    return {
      gmtEvent: 'gmtEvent',
      id: 'id',
      identifier: 'identifier',
      newValue: 'newValue',
      oldValue: 'oldValue',
      organizationId: 'organizationId',
      projectId: 'projectId',
      source: 'source',
      type: 'type',
      workitemId: 'workitemId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtEvent: 'number',
      id: 'number',
      identifier: 'string',
      newValue: 'string',
      oldValue: 'string',
      organizationId: 'string',
      projectId: 'string',
      source: 'string',
      type: 'string',
      workitemId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBranchInfoResponseBodyResultCommitAuthor extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 28056
   */
  id?: number;
  /**
   * @example
   * codeup-test
   */
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * testtest
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBranchInfoResponseBodyResultCommitCommitter extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 5035
   */
  id?: number;
  /**
   * @example
   * codeup-commit
   */
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * commitcommit
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBranchInfoResponseBodyResultCommitSignature extends $tea.Model {
  /**
   * @example
   * ""
   */
  gpgKeyId?: string;
  /**
   * @example
   * verified
   */
  verificationStatus?: string;
  static names(): { [key: string]: string } {
    return {
      gpgKeyId: 'gpgKeyId',
      verificationStatus: 'verificationStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gpgKeyId: 'string',
      verificationStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBranchInfoResponseBodyResultCommit extends $tea.Model {
  author?: GetBranchInfoResponseBodyResultCommitAuthor;
  /**
   * @example
   * username@example.com
   */
  authorEmail?: string;
  authorName?: string;
  /**
   * @example
   * 2022-03-18 08:00:00
   */
  authoredDate?: string;
  /**
   * @example
   * 0
   */
  commentsCount?: number;
  /**
   * @example
   * 2022-03-18 09:00:00
   */
  committedDate?: string;
  committer?: GetBranchInfoResponseBodyResultCommitCommitter;
  /**
   * @example
   * username@example.com
   */
  committerEmail?: string;
  committerName?: string;
  /**
   * @example
   * 2022-03-18 10:00:00
   */
  createdAt?: string;
  /**
   * @example
   * e0297d8fb0393c833a8531e7cc8832739e3cba6d
   */
  id?: string;
  message?: string;
  parentIds?: string[];
  /**
   * @example
   * e0297d8f
   */
  shortId?: string;
  signature?: GetBranchInfoResponseBodyResultCommitSignature;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      authoredDate: 'authoredDate',
      commentsCount: 'commentsCount',
      committedDate: 'committedDate',
      committer: 'committer',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      signature: 'signature',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: GetBranchInfoResponseBodyResultCommitAuthor,
      authorEmail: 'string',
      authorName: 'string',
      authoredDate: 'string',
      commentsCount: 'number',
      committedDate: 'string',
      committer: GetBranchInfoResponseBodyResultCommitCommitter,
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      signature: GetBranchInfoResponseBodyResultCommitSignature,
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBranchInfoResponseBodyResult extends $tea.Model {
  commit?: GetBranchInfoResponseBodyResultCommit;
  /**
   * @example
   * master
   */
  name?: string;
  /**
   * @example
   * false
   */
  protected?: string;
  static names(): { [key: string]: string } {
    return {
      commit: 'commit',
      name: 'name',
      protected: 'protected',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commit: GetBranchInfoResponseBodyResultCommit,
      name: 'string',
      protected: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRunResponseBodyResultAnnotations extends $tea.Model {
  /**
   * @example
   * warning
   */
  annotationLevel?: string;
  /**
   * @example
   * 4
   */
  endColumn?: number;
  /**
   * @example
   * 2
   */
  endLine?: number;
  /**
   * @example
   * 1
   */
  id?: number;
  message?: string;
  /**
   * @example
   * demo/test.txt
   */
  path?: string;
  rawDetails?: string;
  /**
   * @example
   * 3
   */
  startColumn?: number;
  /**
   * @example
   * 1
   */
  startLine?: number;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      annotationLevel: 'annotationLevel',
      endColumn: 'endColumn',
      endLine: 'endLine',
      id: 'id',
      message: 'message',
      path: 'path',
      rawDetails: 'rawDetails',
      startColumn: 'startColumn',
      startLine: 'startLine',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotationLevel: 'string',
      endColumn: 'number',
      endLine: 'number',
      id: 'number',
      message: 'string',
      path: 'string',
      rawDetails: 'string',
      startColumn: 'number',
      startLine: 'number',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRunResponseBodyResultCheckSuite extends $tea.Model {
  /**
   * @example
   * 1
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRunResponseBodyResultOutputImages extends $tea.Model {
  /**
   * @example
   * test-image-alt
   */
  alt?: string;
  /**
   * @example
   * test
   */
  caption?: string;
  /**
   * @example
   * xxx
   */
  imageUrl?: string;
  static names(): { [key: string]: string } {
    return {
      alt: 'alt',
      caption: 'caption',
      imageUrl: 'imageUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alt: 'string',
      caption: 'string',
      imageUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRunResponseBodyResultOutput extends $tea.Model {
  images?: GetCheckRunResponseBodyResultOutputImages[];
  summary?: string;
  text?: string;
  /**
   * @example
   * Mighty Readme report
   */
  title?: string;
  static names(): { [key: string]: string } {
    return {
      images: 'images',
      summary: 'summary',
      text: 'text',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      images: { 'type': 'array', 'itemType': GetCheckRunResponseBodyResultOutputImages },
      summary: 'string',
      text: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRunResponseBodyResultWriter extends $tea.Model {
  /**
   * @example
   * xxx
   */
  id?: string;
  /**
   * @example
   * xxx
   */
  logoUrl?: string;
  /**
   * @example
   * test-codeup
   */
  name?: string;
  /**
   * @example
   * test-codeup
   */
  slug?: string;
  /**
   * @example
   * User
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      logoUrl: 'logoUrl',
      name: 'name',
      slug: 'slug',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      logoUrl: 'string',
      name: 'string',
      slug: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRunResponseBodyResult extends $tea.Model {
  annotations?: GetCheckRunResponseBodyResultAnnotations[];
  checkSuite?: GetCheckRunResponseBodyResultCheckSuite;
  /**
   * @example
   * 2023-03-15T08:00:00Z
   */
  completedAt?: string;
  /**
   * @example
   * success
   */
  conclusion?: string;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  createdAt?: string;
  /**
   * @example
   * xxx
   */
  detailsUrl?: string;
  /**
   * @example
   * 42
   */
  externalId?: string;
  /**
   * @example
   * 40f4ccfe019cdd4a62d4acb0c57130106fc7e1be
   */
  headSha?: string;
  /**
   * @example
   * 5240
   */
  id?: number;
  /**
   * @example
   * my-check-ci
   */
  name?: string;
  output?: GetCheckRunResponseBodyResultOutput;
  /**
   * @example
   * 2023-03-15T08:00:00Z
   */
  startedAt?: string;
  /**
   * @example
   * completed
   */
  status?: string;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  updatedAt?: string;
  writer?: GetCheckRunResponseBodyResultWriter;
  static names(): { [key: string]: string } {
    return {
      annotations: 'annotations',
      checkSuite: 'checkSuite',
      completedAt: 'completedAt',
      conclusion: 'conclusion',
      createdAt: 'createdAt',
      detailsUrl: 'detailsUrl',
      externalId: 'externalId',
      headSha: 'headSha',
      id: 'id',
      name: 'name',
      output: 'output',
      startedAt: 'startedAt',
      status: 'status',
      updatedAt: 'updatedAt',
      writer: 'writer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotations: { 'type': 'array', 'itemType': GetCheckRunResponseBodyResultAnnotations },
      checkSuite: GetCheckRunResponseBodyResultCheckSuite,
      completedAt: 'string',
      conclusion: 'string',
      createdAt: 'string',
      detailsUrl: 'string',
      externalId: 'string',
      headSha: 'string',
      id: 'number',
      name: 'string',
      output: GetCheckRunResponseBodyResultOutput,
      startedAt: 'string',
      status: 'string',
      updatedAt: 'string',
      writer: GetCheckRunResponseBodyResultWriter,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCodeupOrganizationResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 2022-03-12 12:00:00
   */
  createdAt?: string;
  /**
   * @example
   * 3624
   */
  id?: number;
  /**
   * @example
   * 100003
   */
  namespaceId?: number;
  /**
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  /**
   * @example
   * test-codeup
   */
  path?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  updatedAt?: string;
  /**
   * @example
   * ORG_MEMBER
   */
  userRole?: string;
  static names(): { [key: string]: string } {
    return {
      createdAt: 'createdAt',
      id: 'id',
      namespaceId: 'namespaceId',
      organizationId: 'organizationId',
      path: 'path',
      updatedAt: 'updatedAt',
      userRole: 'userRole',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdAt: 'string',
      id: 'number',
      namespaceId: 'number',
      organizationId: 'string',
      path: 'string',
      updatedAt: 'string',
      userRole: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCompareDetailResponseBodyResultCommitsAuthor extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 21396
   */
  id?: number;
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * Codeup
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCompareDetailResponseBodyResultCommitsCommitter extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 43910
   */
  id?: number;
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * Codeup-commiter
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCompareDetailResponseBodyResultCommits extends $tea.Model {
  author?: GetCompareDetailResponseBodyResultCommitsAuthor;
  /**
   * @example
   * username@example.com
   */
  authorEmail?: string;
  authorName?: string;
  /**
   * @example
   * 2023-01-03T15:41:26+08:00
   */
  authoredDate?: string;
  /**
   * @example
   * 1
   */
  commentsCount?: number;
  /**
   * @example
   * 2023-01-03T15:41:26+08:00
   */
  committedDate?: string;
  committer?: GetCompareDetailResponseBodyResultCommitsCommitter;
  /**
   * @example
   * username@example.com
   */
  committerEmail?: string;
  committerName?: string;
  /**
   * @example
   * 2023-01-03T15:41:26+08:00
   */
  createdAt?: string;
  /**
   * @example
   * b8f6f28520b1936aafe2e638373e19ccafa42b02
   */
  id?: string;
  /**
   * @example
   * ""
   */
  message?: string;
  parentIds?: string[];
  /**
   * @example
   * b8f6f285
   */
  shortId?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      authoredDate: 'authoredDate',
      commentsCount: 'commentsCount',
      committedDate: 'committedDate',
      committer: 'committer',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: GetCompareDetailResponseBodyResultCommitsAuthor,
      authorEmail: 'string',
      authorName: 'string',
      authoredDate: 'string',
      commentsCount: 'number',
      committedDate: 'string',
      committer: GetCompareDetailResponseBodyResultCommitsCommitter,
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCompareDetailResponseBodyResultDiffs extends $tea.Model {
  /**
   * @example
   * 100644
   */
  aMode?: string;
  /**
   * @example
   * 100644
   */
  bMode?: string;
  /**
   * @example
   * false
   */
  deletedFile?: boolean;
  diff?: string;
  /**
   * @example
   * false
   */
  isBinary?: boolean;
  /**
   * @example
   * false
   */
  isNewLfs?: boolean;
  /**
   * @example
   * false
   */
  isOldLfs?: boolean;
  /**
   * @example
   * false
   */
  newFile?: boolean;
  /**
   * @example
   * cb75846da2df3d3d7f290c3569236fcf3dd17224
   */
  newId?: string;
  /**
   * @example
   * new_test.txt
   */
  newPath?: string;
  /**
   * @example
   * 6c268061a546378276559c713d0ad377d4dsjfh
   */
  oldId?: string;
  /**
   * @example
   * test.txt
   */
  oldPath?: string;
  /**
   * @example
   * false
   */
  renamedFile?: boolean;
  static names(): { [key: string]: string } {
    return {
      aMode: 'aMode',
      bMode: 'bMode',
      deletedFile: 'deletedFile',
      diff: 'diff',
      isBinary: 'isBinary',
      isNewLfs: 'isNewLfs',
      isOldLfs: 'isOldLfs',
      newFile: 'newFile',
      newId: 'newId',
      newPath: 'newPath',
      oldId: 'oldId',
      oldPath: 'oldPath',
      renamedFile: 'renamedFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aMode: 'string',
      bMode: 'string',
      deletedFile: 'boolean',
      diff: 'string',
      isBinary: 'boolean',
      isNewLfs: 'boolean',
      isOldLfs: 'boolean',
      newFile: 'boolean',
      newId: 'string',
      newPath: 'string',
      oldId: 'string',
      oldPath: 'string',
      renamedFile: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCompareDetailResponseBodyResult extends $tea.Model {
  commits?: GetCompareDetailResponseBodyResultCommits[];
  diffs?: GetCompareDetailResponseBodyResultDiffs[];
  messages?: string[];
  static names(): { [key: string]: string } {
    return {
      commits: 'commits',
      diffs: 'diffs',
      messages: 'messages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commits: { 'type': 'array', 'itemType': GetCompareDetailResponseBodyResultCommits },
      diffs: { 'type': 'array', 'itemType': GetCompareDetailResponseBodyResultDiffs },
      messages: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCustomFieldOptionResponseBodyFileds extends $tea.Model {
  /**
   * @example
   * 223
   */
  displayValue?: string;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  fieldIdentifier?: string;
  /**
   * @example
   * 3345
   */
  identifier?: string;
  /**
   * @example
   * 1
   */
  level?: number;
  /**
   * @example
   * 1
   */
  position?: number;
  /**
   * @example
   * 223
   */
  value?: string;
  /**
   * @example
   * 223
   */
  valueEn?: string;
  static names(): { [key: string]: string } {
    return {
      displayValue: 'displayValue',
      fieldIdentifier: 'fieldIdentifier',
      identifier: 'identifier',
      level: 'level',
      position: 'position',
      value: 'value',
      valueEn: 'valueEn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayValue: 'string',
      fieldIdentifier: 'string',
      identifier: 'string',
      level: 'number',
      position: 'number',
      value: 'string',
      valueEn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileBlobsResponseBodyResult extends $tea.Model {
  /**
   * @example
   * xxxx
   */
  content?: string;
  size?: number;
  /**
   * @example
   * 65535
   */
  totalLines?: number;
  static names(): { [key: string]: string } {
    return {
      content: 'content',
      size: 'size',
      totalLines: 'totalLines',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      size: 'number',
      totalLines: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileLastCommitResponseBodyResultSignature extends $tea.Model {
  /**
   * @remarks
   * GPG密钥ID
   * 
   * @example
   * 34d2c47c7ce46a5c4639c5ffe208
   */
  gpgKeyId?: string;
  /**
   * @example
   * verified
   */
  verificationStatus?: string;
  static names(): { [key: string]: string } {
    return {
      gpgKeyId: 'gpgKeyId',
      verificationStatus: 'verificationStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gpgKeyId: 'string',
      verificationStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileLastCommitResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 2022-08-08 18:09:09
   */
  authorDate?: string;
  /**
   * @example
   * username@example.com
   */
  authorEmail?: string;
  /**
   * @example
   * test-codeup
   */
  authorName?: string;
  /**
   * @example
   * 2022-03-18 15:00:02
   */
  committedDate?: string;
  /**
   * @example
   * username@example.com
   */
  committerEmail?: string;
  /**
   * @example
   * committer-codeup
   */
  committerName?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  createdAt?: string;
  /**
   * @example
   * ff4fb5ac6d1f44f452654336d2dba468ae6c8d04
   */
  id?: string;
  message?: string;
  parentIds?: string[];
  /**
   * @example
   * ff4fb5ac
   */
  shortId?: string;
  signature?: GetFileLastCommitResponseBodyResultSignature;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      authorDate: 'authorDate',
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      committedDate: 'committedDate',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      signature: 'signature',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorDate: 'string',
      authorEmail: 'string',
      authorName: 'string',
      committedDate: 'string',
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      signature: GetFileLastCommitResponseBodyResultSignature,
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFlowTagGroupResponseBodyFlowTagGroupFlowTagList extends $tea.Model {
  /**
   * @example
   * #1F9AEF
   */
  color?: string;
  /**
   * @example
   * 1111111111111
   */
  creatorAccountId?: string;
  /**
   * @example
   * 111
   */
  id?: number;
  /**
   * @example
   * 1111111111111
   */
  modiferAccountId?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      color: 'color',
      creatorAccountId: 'creatorAccountId',
      id: 'id',
      modiferAccountId: 'modiferAccountId',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      color: 'string',
      creatorAccountId: 'string',
      id: 'number',
      modiferAccountId: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFlowTagGroupResponseBodyFlowTagGroup extends $tea.Model {
  /**
   * @example
   * 1111111111111
   */
  creatorAccountId?: string;
  flowTagList?: GetFlowTagGroupResponseBodyFlowTagGroupFlowTagList[];
  /**
   * @example
   * 1111
   */
  id?: number;
  /**
   * @example
   * 1111111111111
   */
  modiferAccountId?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      creatorAccountId: 'creatorAccountId',
      flowTagList: 'flowTagList',
      id: 'id',
      modiferAccountId: 'modiferAccountId',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorAccountId: 'string',
      flowTagList: { 'type': 'array', 'itemType': GetFlowTagGroupResponseBodyFlowTagGroupFlowTagList },
      id: 'number',
      modiferAccountId: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGroupByPathResponseBodyResult extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  description?: string;
  /**
   * @example
   * 30815
   */
  id?: number;
  /**
   * @example
   * test-group
   */
  name?: string;
  nameWithNamespace?: string;
  /**
   * @example
   * 19230
   */
  ownerId?: string;
  /**
   * @example
   * 26842
   */
  parentId?: string;
  /**
   * @example
   * test-group
   */
  path?: string;
  /**
   * @example
   * codeup-test-org/test-group
   */
  pathWithNamespace?: string;
  /**
   * @example
   * 0
   */
  visibilityLevel?: number;
  /**
   * @example
   * xxx
   */
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      description: 'description',
      id: 'id',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      ownerId: 'ownerId',
      parentId: 'parentId',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
      nameWithNamespace: 'string',
      ownerId: 'string',
      parentId: 'string',
      path: 'string',
      pathWithNamespace: 'string',
      visibilityLevel: 'number',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGroupDetailResponseBodyResult extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  description?: string;
  /**
   * @example
   * 36612
   */
  id?: number;
  /**
   * @example
   * test-group-detail
   */
  name?: string;
  nameWithNamespace?: string;
  /**
   * @example
   * 19230
   */
  ownerId?: number;
  /**
   * @example
   * 26842
   */
  parentId?: number;
  /**
   * @example
   * test-group-detail
   */
  path?: string;
  /**
   * @example
   * codeup-test-org/test-group-detail
   */
  pathWithNamespace?: string;
  /**
   * @example
   * Group
   */
  type?: string;
  /**
   * @example
   * 10
   */
  visibilityLevel?: number;
  /**
   * @example
   * ""
   */
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      description: 'description',
      id: 'id',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      ownerId: 'ownerId',
      parentId: 'parentId',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      type: 'type',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
      nameWithNamespace: 'string',
      ownerId: 'number',
      parentId: 'number',
      path: 'string',
      pathWithNamespace: 'string',
      type: 'string',
      visibilityLevel: 'number',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHostGroupResponseBodyHostGroupHostInfos extends $tea.Model {
  /**
   * @example
   * cn-hangzhou
   */
  aliyunRegionId?: string;
  /**
   * @example
   * 1586863220000
   */
  createTime?: number;
  /**
   * @example
   * 11111
   */
  creatorAccountId?: string;
  /**
   * @example
   * ceshi
   */
  instanceName?: string;
  /**
   * @example
   * 127.0.0.1
   */
  ip?: string;
  /**
   * @example
   * 1ssasa
   */
  machineSn?: string;
  /**
   * @example
   * 11111111111
   */
  modifierAccountId?: string;
  /**
   * @example
   * MachineInfo
   */
  objectType?: string;
  /**
   * @example
   * 1586863220000
   */
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      aliyunRegionId: 'aliyunRegionId',
      createTime: 'createTime',
      creatorAccountId: 'creatorAccountId',
      instanceName: 'instanceName',
      ip: 'ip',
      machineSn: 'machineSn',
      modifierAccountId: 'modifierAccountId',
      objectType: 'objectType',
      updateTime: 'updateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunRegionId: 'string',
      createTime: 'number',
      creatorAccountId: 'string',
      instanceName: 'string',
      ip: 'string',
      machineSn: 'string',
      modifierAccountId: 'string',
      objectType: 'string',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHostGroupResponseBodyHostGroup extends $tea.Model {
  /**
   * @example
   * cn-bejing
   */
  aliyunRegion?: string;
  /**
   * @example
   * 1586863220000
   */
  createTime?: number;
  /**
   * @example
   * 111111
   */
  creatorAccountId?: string;
  description?: string;
  /**
   * @example
   * ecs
   */
  ecsLabelKey?: string;
  /**
   * @example
   * ecs
   */
  ecsLabelValue?: string;
  /**
   * @example
   * ECS_ALIYUN
   */
  ecsType?: string;
  hostInfos?: GetHostGroupResponseBodyHostGroupHostInfos[];
  /**
   * @example
   * 1
   */
  hostNum?: number;
  /**
   * @example
   * 1234
   */
  id?: number;
  /**
   * @example
   * 11111
   */
  modifierAccountId?: string;
  name?: string;
  /**
   * @example
   * 1234
   */
  serviceConnectionId?: number;
  /**
   * @example
   * ECS
   */
  type?: string;
  /**
   * @example
   * 1586863220000
   */
  upateTIme?: number;
  static names(): { [key: string]: string } {
    return {
      aliyunRegion: 'aliyunRegion',
      createTime: 'createTime',
      creatorAccountId: 'creatorAccountId',
      description: 'description',
      ecsLabelKey: 'ecsLabelKey',
      ecsLabelValue: 'ecsLabelValue',
      ecsType: 'ecsType',
      hostInfos: 'hostInfos',
      hostNum: 'hostNum',
      id: 'id',
      modifierAccountId: 'modifierAccountId',
      name: 'name',
      serviceConnectionId: 'serviceConnectionId',
      type: 'type',
      upateTIme: 'upateTIme',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunRegion: 'string',
      createTime: 'number',
      creatorAccountId: 'string',
      description: 'string',
      ecsLabelKey: 'string',
      ecsLabelValue: 'string',
      ecsType: 'string',
      hostInfos: { 'type': 'array', 'itemType': GetHostGroupResponseBodyHostGroupHostInfos },
      hostNum: 'number',
      id: 'number',
      modifierAccountId: 'string',
      name: 'string',
      serviceConnectionId: 'number',
      type: 'string',
      upateTIme: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestResponseBodyResultAuthor extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 19927
   */
  id?: number;
  /**
   * @example
   * test-codeup
   */
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * root-test-codeup
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestResponseBodyResultReviewers extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  hasCommented?: boolean;
  /**
   * @example
   * false
   */
  hasReviewed?: boolean;
  /**
   * @example
   * 90452
   */
  id?: number;
  /**
   * @example
   * test-codeup
   */
  name?: string;
  /**
   * @example
   * NOT_PASS
   */
  reviewOpinionStatus?: string;
  reviewTime?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * root-test-codeup
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      hasCommented: 'hasCommented',
      hasReviewed: 'hasReviewed',
      id: 'id',
      name: 'name',
      reviewOpinionStatus: 'reviewOpinionStatus',
      reviewTime: 'reviewTime',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      hasCommented: 'boolean',
      hasReviewed: 'boolean',
      id: 'number',
      name: 'string',
      reviewOpinionStatus: 'string',
      reviewTime: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestResponseBodyResultSubscribers extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 90452
   */
  id?: number;
  /**
   * @example
   * test-subscriber
   */
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * test-subscriber
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestResponseBodyResultTodoListRequirementCheckItems extends $tea.Model {
  /**
   * @example
   * COMMENTS_CHECK
   */
  itemType?: string;
  /**
   * @example
   * true
   */
  pass?: boolean;
  static names(): { [key: string]: string } {
    return {
      itemType: 'itemType',
      pass: 'pass',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemType: 'string',
      pass: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestResponseBodyResultTodoList extends $tea.Model {
  requirementCheckItems?: GetMergeRequestResponseBodyResultTodoListRequirementCheckItems[];
  static names(): { [key: string]: string } {
    return {
      requirementCheckItems: 'requirementCheckItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requirementCheckItems: { 'type': 'array', 'itemType': GetMergeRequestResponseBodyResultTodoListRequirementCheckItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 1
   */
  ahead?: number;
  /**
   * @example
   * true
   */
  allRequirementsPass?: boolean;
  author?: GetMergeRequestResponseBodyResultAuthor;
  /**
   * @example
   * 1
   */
  behind?: number;
  /**
   * @example
   * WEB
   */
  createFrom?: string;
  /**
   * @example
   * 2023-05-30T02:53:36Z
   */
  createTime?: string;
  description?: string;
  /**
   * @example
   * xxx
   */
  detailUrl?: string;
  /**
   * @example
   * 1
   */
  localId?: number;
  mergedRevision?: string;
  /**
   * @example
   * bca90244c4b749e0b109df52ac0eb570
   */
  mrBizId?: string;
  /**
   * @example
   * CODE_REVIEW
   */
  mrType?: string;
  /**
   * @example
   * 2369234
   */
  projectId?: number;
  reviewers?: GetMergeRequestResponseBodyResultReviewers[];
  /**
   * @example
   * test-merge-request
   */
  sourceBranch?: string;
  /**
   * @example
   * 2369234
   */
  sourceProjectId?: number;
  /**
   * @example
   * UNDER_REVIEW
   */
  status?: string;
  subscribers?: GetMergeRequestResponseBodyResultSubscribers[];
  /**
   * @example
   * true
   */
  supportMergeFastForwardOnly?: boolean;
  /**
   * @example
   * master
   */
  targetBranch?: string;
  /**
   * @example
   * 2369234
   */
  targetProjectId?: number;
  targetProjectNameWithNamespace?: string;
  /**
   * @example
   * orgId/test-group/test-target-repo
   */
  targetProjectPathWithNamespace?: string;
  title?: string;
  todoList?: GetMergeRequestResponseBodyResultTodoList;
  /**
   * @example
   * 2023-05-30T02:53:36Z
   */
  updateTime?: string;
  /**
   * @example
   * xxx
   */
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      ahead: 'ahead',
      allRequirementsPass: 'allRequirementsPass',
      author: 'author',
      behind: 'behind',
      createFrom: 'createFrom',
      createTime: 'createTime',
      description: 'description',
      detailUrl: 'detailUrl',
      localId: 'localId',
      mergedRevision: 'mergedRevision',
      mrBizId: 'mrBizId',
      mrType: 'mrType',
      projectId: 'projectId',
      reviewers: 'reviewers',
      sourceBranch: 'sourceBranch',
      sourceProjectId: 'sourceProjectId',
      status: 'status',
      subscribers: 'subscribers',
      supportMergeFastForwardOnly: 'supportMergeFastForwardOnly',
      targetBranch: 'targetBranch',
      targetProjectId: 'targetProjectId',
      targetProjectNameWithNamespace: 'targetProjectNameWithNamespace',
      targetProjectPathWithNamespace: 'targetProjectPathWithNamespace',
      title: 'title',
      todoList: 'todoList',
      updateTime: 'updateTime',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ahead: 'number',
      allRequirementsPass: 'boolean',
      author: GetMergeRequestResponseBodyResultAuthor,
      behind: 'number',
      createFrom: 'string',
      createTime: 'string',
      description: 'string',
      detailUrl: 'string',
      localId: 'number',
      mergedRevision: 'string',
      mrBizId: 'string',
      mrType: 'string',
      projectId: 'number',
      reviewers: { 'type': 'array', 'itemType': GetMergeRequestResponseBodyResultReviewers },
      sourceBranch: 'string',
      sourceProjectId: 'number',
      status: 'string',
      subscribers: { 'type': 'array', 'itemType': GetMergeRequestResponseBodyResultSubscribers },
      supportMergeFastForwardOnly: 'boolean',
      targetBranch: 'string',
      targetProjectId: 'number',
      targetProjectNameWithNamespace: 'string',
      targetProjectPathWithNamespace: 'string',
      title: 'string',
      todoList: GetMergeRequestResponseBodyResultTodoList,
      updateTime: 'string',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestChangeTreeResponseBodyResultChangedFilesInfos extends $tea.Model {
  /**
   * @example
   * 10
   */
  addLines?: number;
  /**
   * @example
   * false
   */
  binaryFile?: boolean;
  /**
   * @example
   * 0
   */
  delLines?: number;
  /**
   * @example
   * false
   */
  deletedFile?: boolean;
  /**
   * @example
   * true
   */
  newFile?: boolean;
  /**
   * @example
   * test.txt
   */
  newPath?: string;
  /**
   * @example
   * test.txt
   */
  oldPath?: string;
  /**
   * @example
   * false
   */
  renamedFile?: boolean;
  static names(): { [key: string]: string } {
    return {
      addLines: 'addLines',
      binaryFile: 'binaryFile',
      delLines: 'delLines',
      deletedFile: 'deletedFile',
      newFile: 'newFile',
      newPath: 'newPath',
      oldPath: 'oldPath',
      renamedFile: 'renamedFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addLines: 'number',
      binaryFile: 'boolean',
      delLines: 'number',
      deletedFile: 'boolean',
      newFile: 'boolean',
      newPath: 'string',
      oldPath: 'string',
      renamedFile: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMergeRequestChangeTreeResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 20
   */
  changedFilesCount?: number;
  changedFilesInfos?: GetMergeRequestChangeTreeResponseBodyResultChangedFilesInfos[];
  /**
   * @example
   * 100
   */
  totalAddLines?: number;
  /**
   * @example
   * 50
   */
  totalDelLines?: number;
  static names(): { [key: string]: string } {
    return {
      changedFilesCount: 'changedFilesCount',
      changedFilesInfos: 'changedFilesInfos',
      totalAddLines: 'totalAddLines',
      totalDelLines: 'totalDelLines',
    };
  }

  static types(): { [key: string]: any } {
    return {
      changedFilesCount: 'number',
      changedFilesInfos: { 'type': 'array', 'itemType': GetMergeRequestChangeTreeResponseBodyResultChangedFilesInfos },
      totalAddLines: 'number',
      totalDelLines: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrganizationMemberResponseBodyMemberIdentities extends $tea.Model {
  /**
   * @example
   * 1236666
   */
  externUid?: string;
  /**
   * @example
   * Dingtalk
   */
  provider?: string;
  static names(): { [key: string]: string } {
    return {
      externUid: 'externUid',
      provider: 'provider',
    };
  }

  static types(): { [key: string]: any } {
    return {
      externUid: 'string',
      provider: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrganizationMemberResponseBodyMember extends $tea.Model {
  /**
   * @example
   * 123456677888
   */
  accountId?: string;
  /**
   * @example
   * 1631845101798
   */
  birthday?: number;
  deptLists?: string[];
  /**
   * @example
   * 123@mail.com
   */
  email?: string;
  /**
   * @example
   * 1631845101798
   */
  hiredDate?: number;
  identities?: GetOrganizationMemberResponseBodyMemberIdentities;
  jobNumber?: string;
  /**
   * @example
   * 1631845101798
   */
  joinTime?: number;
  /**
   * @example
   * 1631845101798
   */
  lastVisitTime?: number;
  /**
   * @example
   * 1390000****
   */
  mobile?: string;
  organizationMemberName?: string;
  /**
   * @example
   * 8fc0c9ff039711dd64acd000
   */
  organizationRoleId?: string;
  organizationRoleName?: string;
  /**
   * @example
   * normal
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
      birthday: 'birthday',
      deptLists: 'deptLists',
      email: 'email',
      hiredDate: 'hiredDate',
      identities: 'identities',
      jobNumber: 'jobNumber',
      joinTime: 'joinTime',
      lastVisitTime: 'lastVisitTime',
      mobile: 'mobile',
      organizationMemberName: 'organizationMemberName',
      organizationRoleId: 'organizationRoleId',
      organizationRoleName: 'organizationRoleName',
      state: 'state',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
      birthday: 'number',
      deptLists: { 'type': 'array', 'itemType': 'string' },
      email: 'string',
      hiredDate: 'number',
      identities: GetOrganizationMemberResponseBodyMemberIdentities,
      jobNumber: 'string',
      joinTime: 'number',
      lastVisitTime: 'number',
      mobile: 'string',
      organizationMemberName: 'string',
      organizationRoleId: 'string',
      organizationRoleName: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineResponseBodyPipelinePipelineConfigSourcesData extends $tea.Model {
  /**
   * @example
   * master
   */
  branch?: string;
  /**
   * @example
   * 1
   */
  cloneDepth?: number;
  /**
   * @remarks
   * Credential Id
   * 
   * @example
   * 222
   */
  credentialId?: number;
  /**
   * @remarks
   * Credential Label
   * 
   * @example
   * 企业公钥
   */
  credentialLabel?: string;
  /**
   * @remarks
   * Credential Type
   * 
   * @example
   * region-ssh
   */
  credentialType?: string;
  events?: string[];
  /**
   * @example
   * false
   */
  isBranchMode?: boolean;
  /**
   * @example
   * true
   */
  isCloneDepth?: boolean;
  /**
   * @example
   * false
   */
  isSubmodule?: boolean;
  /**
   * @example
   * true
   */
  isTrigger?: boolean;
  /**
   * @example
   * cdup/ss
   */
  label?: string;
  /**
   * @example
   * asasasas
   */
  namespace?: string;
  /**
   * @example
   * https://codeup.aliyun.com/test.git
   */
  repo?: string;
  /**
   * @example
   * 12
   */
  serviceConnectionId?: number;
  /**
   * @example
   * .*
   */
  triggerFilter?: string;
  /**
   * @example
   * https://flow.aliyun/webhook/asassasa
   */
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      branch: 'branch',
      cloneDepth: 'cloneDepth',
      credentialId: 'credentialId',
      credentialLabel: 'credentialLabel',
      credentialType: 'credentialType',
      events: 'events',
      isBranchMode: 'isBranchMode',
      isCloneDepth: 'isCloneDepth',
      isSubmodule: 'isSubmodule',
      isTrigger: 'isTrigger',
      label: 'label',
      namespace: 'namespace',
      repo: 'repo',
      serviceConnectionId: 'serviceConnectionId',
      triggerFilter: 'triggerFilter',
      webhook: 'webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      branch: 'string',
      cloneDepth: 'number',
      credentialId: 'number',
      credentialLabel: 'string',
      credentialType: 'string',
      events: { 'type': 'array', 'itemType': 'string' },
      isBranchMode: 'boolean',
      isCloneDepth: 'boolean',
      isSubmodule: 'boolean',
      isTrigger: 'boolean',
      label: 'string',
      namespace: 'string',
      repo: 'string',
      serviceConnectionId: 'number',
      triggerFilter: 'string',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineResponseBodyPipelinePipelineConfigSources extends $tea.Model {
  data?: GetPipelineResponseBodyPipelinePipelineConfigSourcesData;
  /**
   * @example
   * xxsxsxs
   */
  sign?: string;
  /**
   * @example
   * Codeup
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      sign: 'sign',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetPipelineResponseBodyPipelinePipelineConfigSourcesData,
      sign: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineResponseBodyPipelinePipelineConfig extends $tea.Model {
  /**
   * @example
   * schema: tb pipeline:   - name: 执行命令     stages:       - driven: AUTO         jobs:           - displayName: 执行命令             task: execution-component-production@10             identifier: \"10_1626147407245\"             templateType: task             templateSign: \"\"             templateBatchUpdate: \"N\"             extraInfo: \"\"             params:               version1: pre-jdk1.62               steps:                 - name: 执行命令                   stepType: exec-shell                   stepIdentifier: \"10_1626147407245__11_1626147407249\"                   command: |                     # input your command here                     echo hello,world!                   ARTIFACTS: \"\"                   JSONEncoding: true                   freeInTaskGroupModeFields:                     - ARTIFACTS                   source: 132504-sss_ddd_3mvJ               ENGINE_PIPELINE_NAME: \"${INPUTS.ENGINE_PIPELINE_NAME}\"               ENGINE_PIPELINE_ID: \"${INPUTS.ENGINE_PIPELINE_ID}\"               ENGINE_PIPELINE_INST_ID: \"${INPUTS.ENGINE_PIPELINE_INST_ID}\"               ENGINE_PIPELINE_INST_NUMBER: \"${INPUTS.ENGINE_PIPELINE_INST_NUMBER}\"               buildNodeGroup: K8S-4             plugins: []             output: []             freeInTaskGroupModeFields: []
   */
  flow?: string;
  /**
   * @example
   * {}
   */
  settings?: string;
  sources?: GetPipelineResponseBodyPipelinePipelineConfigSources[];
  static names(): { [key: string]: string } {
    return {
      flow: 'flow',
      settings: 'settings',
      sources: 'sources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flow: 'string',
      settings: 'string',
      sources: { 'type': 'array', 'itemType': GetPipelineResponseBodyPipelinePipelineConfigSources },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineResponseBodyPipelineTagList extends $tea.Model {
  /**
   * @example
   * 22
   */
  id?: number;
  /**
   * @example
   * 标签1
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineResponseBodyPipeline extends $tea.Model {
  /**
   * @example
   * 1586863220000
   */
  createTime?: number;
  /**
   * @example
   * 112222122
   */
  creatorAccountId?: string;
  /**
   * @example
   * 0
   */
  envId?: number;
  /**
   * @example
   * 日常环境
   */
  envName?: string;
  /**
   * @example
   * 1111
   */
  groupId?: number;
  /**
   * @example
   * 112222122
   */
  modifierAccountId?: string;
  /**
   * @example
   * 流水线
   */
  name?: string;
  pipelineConfig?: GetPipelineResponseBodyPipelinePipelineConfig;
  tagList?: GetPipelineResponseBodyPipelineTagList[];
  /**
   * @example
   * 1586863220000
   */
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'createTime',
      creatorAccountId: 'creatorAccountId',
      envId: 'envId',
      envName: 'envName',
      groupId: 'groupId',
      modifierAccountId: 'modifierAccountId',
      name: 'name',
      pipelineConfig: 'pipelineConfig',
      tagList: 'tagList',
      updateTime: 'updateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      creatorAccountId: 'string',
      envId: 'number',
      envName: 'string',
      groupId: 'number',
      modifierAccountId: 'string',
      name: 'string',
      pipelineConfig: GetPipelineResponseBodyPipelinePipelineConfig,
      tagList: { 'type': 'array', 'itemType': GetPipelineResponseBodyPipelineTagList },
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineGroupResponseBodyPipelineGroup extends $tea.Model {
  /**
   * @example
   * 1586863220000
   */
  createTime?: number;
  /**
   * @example
   * 111
   */
  id?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'createTime',
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineRunResponseBodyPipelineRunSourcesData extends $tea.Model {
  /**
   * @example
   * master
   */
  branch?: string;
  /**
   * @example
   * {}
   */
  commint?: string;
  /**
   * @example
   * http://codeup.aliyun.com/a.git
   */
  repo?: string;
  static names(): { [key: string]: string } {
    return {
      branch: 'branch',
      commint: 'commint',
      repo: 'repo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      branch: 'string',
      commint: 'string',
      repo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineRunResponseBodyPipelineRunSources extends $tea.Model {
  data?: GetPipelineRunResponseBodyPipelineRunSourcesData;
  /**
   * @example
   * assaaaaaasasasa
   */
  sign?: string;
  /**
   * @example
   * Codeup
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      sign: 'sign',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetPipelineRunResponseBodyPipelineRunSourcesData,
      sign: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions extends $tea.Model {
  /**
   * @example
   * true
   */
  disable?: boolean;
  /**
   * @example
   * {}
   */
  params?: { [key: string]: any };
  /**
   * @example
   * PassPipelineValidate
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      disable: 'disable',
      params: 'params',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      disable: 'boolean',
      params: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobs extends $tea.Model {
  actions?: GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions[];
  /**
   * @example
   * 1586863220000
   */
  endTime?: number;
  /**
   * @example
   * 21212
   */
  id?: number;
  /**
   * @example
   * java构建
   */
  name?: string;
  /**
   * @example
   * {}
   */
  params?: string;
  /**
   * @example
   * 1586863220000
   */
  startTime?: number;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      actions: 'actions',
      endTime: 'endTime',
      id: 'id',
      name: 'name',
      params: 'params',
      startTime: 'startTime',
      status: 'status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actions: { 'type': 'array', 'itemType': GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions },
      endTime: 'number',
      id: 'number',
      name: 'string',
      params: 'string',
      startTime: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineRunResponseBodyPipelineRunStagesStageInfo extends $tea.Model {
  /**
   * @example
   * 1586863220000
   */
  endTime?: number;
  jobs?: GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobs[];
  /**
   * @example
   * Java构建
   */
  name?: string;
  /**
   * @example
   * 1586863220000
   */
  startTime?: number;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'endTime',
      jobs: 'jobs',
      name: 'name',
      startTime: 'startTime',
      status: 'status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      jobs: { 'type': 'array', 'itemType': GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobs },
      name: 'string',
      startTime: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineRunResponseBodyPipelineRunStages extends $tea.Model {
  /**
   * @example
   * Java构建
   */
  name?: string;
  stageInfo?: GetPipelineRunResponseBodyPipelineRunStagesStageInfo;
  static names(): { [key: string]: string } {
    return {
      name: 'name',
      stageInfo: 'stageInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      stageInfo: GetPipelineRunResponseBodyPipelineRunStagesStageInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPipelineRunResponseBodyPipelineRun extends $tea.Model {
  /**
   * @example
   * 1586863220000
   */
  createTime?: number;
  /**
   * @example
   * 1111111111
   */
  creatorAccountId?: string;
  /**
   * @example
   * 11111111111
   */
  modifierAccountId?: string;
  /**
   * @example
   * 1234
   */
  pipelineId?: number;
  /**
   * @example
   * 1
   */
  pipelineRunId?: number;
  sources?: GetPipelineRunResponseBodyPipelineRunSources[];
  stageGroup?: string[][];
  stages?: GetPipelineRunResponseBodyPipelineRunStages[];
  /**
   * @example
   * SUCCESS
   */
  status?: string;
  /**
   * @example
   * 1
   */
  triggerMode?: number;
  /**
   * @example
   * 1586863220000
   */
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'createTime',
      creatorAccountId: 'creatorAccountId',
      modifierAccountId: 'modifierAccountId',
      pipelineId: 'pipelineId',
      pipelineRunId: 'pipelineRunId',
      sources: 'sources',
      stageGroup: 'stageGroup',
      stages: 'stages',
      status: 'status',
      triggerMode: 'triggerMode',
      updateTime: 'updateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      creatorAccountId: 'string',
      modifierAccountId: 'string',
      pipelineId: 'number',
      pipelineRunId: 'number',
      sources: { 'type': 'array', 'itemType': GetPipelineRunResponseBodyPipelineRunSources },
      stageGroup: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'string' } },
      stages: { 'type': 'array', 'itemType': GetPipelineRunResponseBodyPipelineRunStages },
      status: 'string',
      triggerMode: 'number',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectInfoResponseBodyProject extends $tea.Model {
  /**
   * @example
   * null
   */
  category?: string;
  /**
   * @example
   * Project
   */
  categoryIdentifier?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  creator?: string;
  /**
   * @example
   * OJAY
   */
  customCode?: string;
  /**
   * @example
   * xxx
   */
  description?: string;
  /**
   * @example
   * 1623916393000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1623916393000
   */
  gmtModified?: number;
  /**
   * @example
   * https://xxxxxx.png
   */
  icon?: string;
  /**
   * @example
   * https://xxxxxx.png
   */
  iconBig?: string;
  /**
   * @example
   * {"small":"https://xxxxxx.png","big":"https://img.yyyyyy.png"}
   */
  iconGroup?: string;
  /**
   * @example
   * https://img.yyyyyy.png
   */
  iconSmall?: string;
  /**
   * @example
   * null
   */
  id?: string;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  identifier?: string;
  /**
   * @example
   * e8b2xxxxxx2abdxxxxxxxx23
   */
  identifierPath?: string;
  /**
   * @example
   * NORMAL
   */
  logicalStatus?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  modifier?: string;
  name?: string;
  /**
   * @example
   * 5e70xxxxxxcd000xxxxe96
   */
  organizationIdentifier?: string;
  /**
   * @example
   * null
   */
  parentIdentifier?: string;
  /**
   * @example
   * public
   */
  scope?: string;
  /**
   * @example
   * 8a40xxxxxxxxxxxxx64
   */
  statusIdentifier?: string;
  /**
   * @example
   * 8a4058a71159b68254......
   */
  statusStageIdentifier?: string;
  /**
   * @example
   * null
   */
  subType?: string;
  /**
   * @example
   * CustomProject
   */
  typeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'category',
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      customCode: 'customCode',
      description: 'description',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      icon: 'icon',
      iconBig: 'iconBig',
      iconGroup: 'iconGroup',
      iconSmall: 'iconSmall',
      id: 'id',
      identifier: 'identifier',
      identifierPath: 'identifierPath',
      logicalStatus: 'logicalStatus',
      modifier: 'modifier',
      name: 'name',
      organizationIdentifier: 'organizationIdentifier',
      parentIdentifier: 'parentIdentifier',
      scope: 'scope',
      statusIdentifier: 'statusIdentifier',
      statusStageIdentifier: 'statusStageIdentifier',
      subType: 'subType',
      typeIdentifier: 'typeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      categoryIdentifier: 'string',
      creator: 'string',
      customCode: 'string',
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      icon: 'string',
      iconBig: 'string',
      iconGroup: 'string',
      iconSmall: 'string',
      id: 'string',
      identifier: 'string',
      identifierPath: 'string',
      logicalStatus: 'string',
      modifier: 'string',
      name: 'string',
      organizationIdentifier: 'string',
      parentIdentifier: 'string',
      scope: 'string',
      statusIdentifier: 'string',
      statusStageIdentifier: 'string',
      subType: 'string',
      typeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectMemberResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 30
   */
  accessLevel?: number;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c4ef67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  email?: string;
  /**
   * @example
   * 2959
   */
  id?: number;
  /**
   * @example
   * codeup
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPushRuleResponseBodyResultRuleInfos extends $tea.Model {
  /**
   * @example
   * CommitAuthorChecker
   */
  checkerName?: string;
  /**
   * @example
   * warn
   */
  checkerType?: string;
  /**
   * @example
   * on
   */
  extraMessage?: string;
  fileRuleRegexes?: string[];
  static names(): { [key: string]: string } {
    return {
      checkerName: 'checkerName',
      checkerType: 'checkerType',
      extraMessage: 'extraMessage',
      fileRuleRegexes: 'fileRuleRegexes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkerName: 'string',
      checkerType: 'string',
      extraMessage: 'string',
      fileRuleRegexes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPushRuleResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 2023-09-03T18:20:06+08:00
   */
  gmtCreate?: string;
  /**
   * @example
   * 2023-09-03T18:20:06+08:00
   */
  gmtModified?: string;
  /**
   * @example
   * 2077
   */
  id?: number;
  ruleInfos?: GetPushRuleResponseBodyResultRuleInfos[];
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      id: 'id',
      ruleInfos: 'ruleInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      ruleInfos: { 'type': 'array', 'itemType': GetPushRuleResponseBodyResultRuleInfos },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReleaseStagePipelineRunResponseBodyPipelineRunSourcesData extends $tea.Model {
  /**
   * @example
   * master
   */
  branch?: string;
  /**
   * @example
   * {}
   */
  commit?: string;
  /**
   * @example
   * http://codeup.aliyun.com/a.git
   */
  repo?: string;
  static names(): { [key: string]: string } {
    return {
      branch: 'branch',
      commit: 'commit',
      repo: 'repo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      branch: 'string',
      commit: 'string',
      repo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReleaseStagePipelineRunResponseBodyPipelineRunSources extends $tea.Model {
  data?: GetReleaseStagePipelineRunResponseBodyPipelineRunSourcesData;
  /**
   * @example
   * assaaaaaasasasa
   */
  sign?: string;
  /**
   * @example
   * Codeup
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      sign: 'sign',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetReleaseStagePipelineRunResponseBodyPipelineRunSourcesData,
      sign: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions extends $tea.Model {
  /**
   * @example
   * true
   */
  disable?: boolean;
  /**
   * @example
   * {}
   */
  params?: any;
  /**
   * @example
   * PassPipelineValidate
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      disable: 'disable',
      params: 'params',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      disable: 'boolean',
      params: 'any',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobs extends $tea.Model {
  actions?: GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions[];
  /**
   * @example
   * 1586863220000
   */
  endTime?: number;
  /**
   * @example
   * 21212
   */
  id?: number;
  name?: string;
  /**
   * @example
   * {}
   */
  params?: string;
  /**
   * @example
   * 1586863220000
   */
  startTime?: number;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      actions: 'actions',
      endTime: 'endTime',
      id: 'id',
      name: 'name',
      params: 'params',
      startTime: 'startTime',
      status: 'status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actions: { 'type': 'array', 'itemType': GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions },
      endTime: 'number',
      id: 'number',
      name: 'string',
      params: 'string',
      startTime: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfo extends $tea.Model {
  /**
   * @example
   * 1586863220000
   */
  endTime?: number;
  jobs?: GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobs[];
  name?: string;
  /**
   * @example
   * 1586863220000
   */
  startTime?: number;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'endTime',
      jobs: 'jobs',
      name: 'name',
      startTime: 'startTime',
      status: 'status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      jobs: { 'type': 'array', 'itemType': GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobs },
      name: 'string',
      startTime: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReleaseStagePipelineRunResponseBodyPipelineRunStages extends $tea.Model {
  name?: string;
  stageInfo?: GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfo;
  static names(): { [key: string]: string } {
    return {
      name: 'name',
      stageInfo: 'stageInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      stageInfo: GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReleaseStagePipelineRunResponseBodyPipelineRun extends $tea.Model {
  /**
   * @example
   * 1586863220000
   */
  createTime?: number;
  /**
   * @example
   * 1111111111
   */
  creatorAccountId?: string;
  /**
   * @example
   * 11111111111
   */
  modifierAccountId?: string;
  /**
   * @example
   * 1234
   */
  pipelineId?: number;
  /**
   * @example
   * 1
   */
  pipelineRunId?: number;
  sources?: GetReleaseStagePipelineRunResponseBodyPipelineRunSources[];
  stageGroup?: string[][];
  stages?: GetReleaseStagePipelineRunResponseBodyPipelineRunStages[];
  /**
   * @example
   * SUCCESS
   */
  status?: string;
  /**
   * @example
   * 1
   */
  triggerMode?: number;
  /**
   * @example
   * 1586863220000
   */
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'createTime',
      creatorAccountId: 'creatorAccountId',
      modifierAccountId: 'modifierAccountId',
      pipelineId: 'pipelineId',
      pipelineRunId: 'pipelineRunId',
      sources: 'sources',
      stageGroup: 'stageGroup',
      stages: 'stages',
      status: 'status',
      triggerMode: 'triggerMode',
      updateTime: 'updateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      creatorAccountId: 'string',
      modifierAccountId: 'string',
      pipelineId: 'number',
      pipelineRunId: 'number',
      sources: { 'type': 'array', 'itemType': GetReleaseStagePipelineRunResponseBodyPipelineRunSources },
      stageGroup: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'string' } },
      stages: { 'type': 'array', 'itemType': GetReleaseStagePipelineRunResponseBodyPipelineRunStages },
      status: 'string',
      triggerMode: 'number',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryResponseBodyRepositoryNamespace extends $tea.Model {
  /**
   * @example
   * https://xxx.jpg
   */
  avatar?: string;
  /**
   * @example
   * 2020-06-19T04:02:00.744Z
   */
  createdAt?: string;
  /**
   * @example
   * repo desc
   */
  description?: string;
  /**
   * @remarks
   * id
   * 
   * @example
   * 100
   */
  id?: number;
  /**
   * @example
   * xxx
   */
  name?: string;
  /**
   * @example
   * 100
   */
  ownerId?: number;
  /**
   * @example
   * test
   */
  path?: string;
  /**
   * @example
   * 2020-06-19T04:02:00.744Z
   */
  updatedAt?: string;
  /**
   * @example
   * 0
   */
  visibilityLevel?: number;
  static names(): { [key: string]: string } {
    return {
      avatar: 'avatar',
      createdAt: 'createdAt',
      description: 'description',
      id: 'id',
      name: 'name',
      ownerId: 'ownerId',
      path: 'path',
      updatedAt: 'updatedAt',
      visibilityLevel: 'visibilityLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatar: 'string',
      createdAt: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
      ownerId: 'number',
      path: 'string',
      updatedAt: 'string',
      visibilityLevel: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryResponseBodyRepository extends $tea.Model {
  /**
   * @example
   * false
   */
  archive?: boolean;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * 2020-06-19T04:02:00.744Z
   */
  createdAt?: string;
  /**
   * @example
   * 19258
   */
  creatorId?: number;
  /**
   * @example
   * master
   */
  defaultBranch?: string;
  /**
   * @example
   * false
   */
  demoProjectStatus?: boolean;
  /**
   * @example
   * repo desc
   */
  description?: string;
  /**
   * @example
   * https://codeup.aliyun.com/xxx/test/test.git
   */
  httpUrlToRepository?: string;
  /**
   * @example
   * 100
   */
  id?: number;
  /**
   * @example
   * 2020-06-19T04:02:00.744Z
   */
  lastActivityAt?: string;
  /**
   * @example
   * test
   */
  name?: string;
  /**
   * @example
   * test / test
   */
  nameWithNamespace?: string;
  namespace?: GetRepositoryResponseBodyRepositoryNamespace;
  /**
   * @example
   * test
   */
  path?: string;
  /**
   * @example
   * test/test
   */
  pathWithNamespace?: string;
  /**
   * @example
   * git@codeup.aliyun.com:xxx/test/test.git
   */
  sshUrlToRepository?: string;
  /**
   * @example
   * 0
   */
  visibilityLevel?: number;
  /**
   * @example
   * https://codeup.aliyun.com/xxx/test/test
   */
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      archive: 'archive',
      avatarUrl: 'avatarUrl',
      createdAt: 'createdAt',
      creatorId: 'creatorId',
      defaultBranch: 'defaultBranch',
      demoProjectStatus: 'demoProjectStatus',
      description: 'description',
      httpUrlToRepository: 'httpUrlToRepository',
      id: 'id',
      lastActivityAt: 'lastActivityAt',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      namespace: 'namespace',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      sshUrlToRepository: 'sshUrlToRepository',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      archive: 'boolean',
      avatarUrl: 'string',
      createdAt: 'string',
      creatorId: 'number',
      defaultBranch: 'string',
      demoProjectStatus: 'boolean',
      description: 'string',
      httpUrlToRepository: 'string',
      id: 'number',
      lastActivityAt: 'string',
      name: 'string',
      nameWithNamespace: 'string',
      namespace: GetRepositoryResponseBodyRepositoryNamespace,
      path: 'string',
      pathWithNamespace: 'string',
      sshUrlToRepository: 'string',
      visibilityLevel: 'number',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryCommitResponseBodyResultAuthor extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c4ef67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 19927
   */
  id?: number;
  /**
   * @example
   * test-codeup
   */
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * test-nickname
   */
  username?: string;
  /**
   * @example
   * ""
   */
  websiteUrl?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
      websiteUrl: 'websiteUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
      websiteUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryCommitResponseBodyResultCommitter extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c4ef67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 24661
   */
  id?: number;
  /**
   * @example
   * committer-codeup
   */
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * nickname
   */
  username?: string;
  /**
   * @example
   * ""
   */
  websiteUrl?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
      websiteUrl: 'websiteUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
      websiteUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryCommitResponseBodyResultSignature extends $tea.Model {
  /**
   * @example
   * 34d2c47c7ce46a5c4639c5ffe208
   */
  gpgKeyId?: string;
  /**
   * @example
   * verified
   */
  verificationStatus?: string;
  static names(): { [key: string]: string } {
    return {
      gpgKeyId: 'gpgKeyId',
      verificationStatus: 'verificationStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gpgKeyId: 'string',
      verificationStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryCommitResponseBodyResult extends $tea.Model {
  author?: GetRepositoryCommitResponseBodyResultAuthor;
  /**
   * @example
   * username@example.com
   */
  authorEmail?: string;
  /**
   * @example
   * test-codeup
   */
  authorName?: string;
  /**
   * @example
   * 2022-03-18 15:00:00
   */
  authoredDate?: string;
  /**
   * @example
   * 1
   */
  commentsCount?: number;
  /**
   * @example
   * 2022-03-18 15:00:02
   */
  committedDate?: string;
  committer?: GetRepositoryCommitResponseBodyResultCommitter;
  /**
   * @example
   * username@example.com
   */
  committerEmail?: string;
  /**
   * @example
   * committer-codeup
   */
  committerName?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  createdAt?: string;
  /**
   * @example
   * ff4fb5ac6d1f44f452654336d2dba468ae6c8d04
   */
  id?: string;
  message?: string;
  parentIds?: string[];
  /**
   * @example
   * ff4fb5ac
   */
  shortId?: string;
  signature?: GetRepositoryCommitResponseBodyResultSignature;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      authoredDate: 'authoredDate',
      commentsCount: 'commentsCount',
      committedDate: 'committedDate',
      committer: 'committer',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      signature: 'signature',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: GetRepositoryCommitResponseBodyResultAuthor,
      authorEmail: 'string',
      authorName: 'string',
      authoredDate: 'string',
      commentsCount: 'number',
      committedDate: 'string',
      committer: GetRepositoryCommitResponseBodyResultCommitter,
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      signature: GetRepositoryCommitResponseBodyResultSignature,
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryTagResponseBodyResultCommitSignature extends $tea.Model {
  /**
   * @example
   * ""
   */
  gpgKeyId?: string;
  /**
   * @example
   * verified
   */
  verificationStatus?: string;
  static names(): { [key: string]: string } {
    return {
      gpgKeyId: 'gpgKeyId',
      verificationStatus: 'verificationStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gpgKeyId: 'string',
      verificationStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryTagResponseBodyResultCommit extends $tea.Model {
  /**
   * @example
   * username@example.com
   */
  authorEmail?: string;
  authorName?: string;
  /**
   * @example
   * 2022-03-18 08:00:00
   */
  authoredDate?: string;
  /**
   * @example
   * 2022-03-18 09:00:00
   */
  committedDate?: string;
  /**
   * @example
   * username@example.com
   */
  committerEmail?: string;
  committerName?: string;
  /**
   * @example
   * 2022-03-18 10:00:00
   */
  createdAt?: string;
  /**
   * @example
   * e0297d8fb0393c833a8531e7cc8832739e3cba6d
   */
  id?: string;
  message?: string;
  parentIds?: string[];
  /**
   * @example
   * e0297d8f
   */
  shortId?: string;
  signature?: GetRepositoryTagResponseBodyResultCommitSignature;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      authoredDate: 'authoredDate',
      committedDate: 'committedDate',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      signature: 'signature',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorEmail: 'string',
      authorName: 'string',
      authoredDate: 'string',
      committedDate: 'string',
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      signature: GetRepositoryTagResponseBodyResultCommitSignature,
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRepositoryTagResponseBodyResult extends $tea.Model {
  commit?: GetRepositoryTagResponseBodyResultCommit;
  /**
   * @example
   * 9a494e7b88ca35cde00579af2df4ab46136c022e
   */
  id?: string;
  message?: string;
  /**
   * @example
   * tag v1.0
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      commit: 'commit',
      id: 'id',
      message: 'message',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commit: GetRepositoryTagResponseBodyResultCommit,
      id: 'string',
      message: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSearchCodePreviewResponseBodyResultHighlightTextMap extends $tea.Model {
  /**
   * @example
   * xxx
   */
  clob?: string;
  /**
   * @example
   * test.rb
   */
  fileName?: string;
  /**
   * @example
   * 5ffd468b1e45db3c1cc26ad6
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      clob: 'clob',
      fileName: 'fileName',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clob: 'string',
      fileName: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSearchCodePreviewResponseBodyResultSource extends $tea.Model {
  /**
   * @example
   * master
   */
  branch?: string;
  /**
   * @example
   * 2022-12-12 12:12:12
   */
  checkinDate?: string;
  /**
   * @example
   * test.rb
   */
  fileName?: string;
  /**
   * @example
   * config/environments/test.rb
   */
  filePath?: string;
  /**
   * @example
   * Ruby
   */
  language?: string;
  /**
   * @example
   * 5f9f9f6122a8c7ff3934f99a
   */
  organizationId?: string;
  /**
   * @example
   * codeup/test-repo
   */
  repoPath?: string;
  static names(): { [key: string]: string } {
    return {
      branch: 'branch',
      checkinDate: 'checkinDate',
      fileName: 'fileName',
      filePath: 'filePath',
      language: 'language',
      organizationId: 'organizationId',
      repoPath: 'repoPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      branch: 'string',
      checkinDate: 'string',
      fileName: 'string',
      filePath: 'string',
      language: 'string',
      organizationId: 'string',
      repoPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSearchCodePreviewResponseBodyResult extends $tea.Model {
  /**
   * @example
   * xxx
   */
  docId?: string;
  highlightTextMap?: GetSearchCodePreviewResponseBodyResultHighlightTextMap;
  source?: GetSearchCodePreviewResponseBodyResultSource;
  static names(): { [key: string]: string } {
    return {
      docId: 'docId',
      highlightTextMap: 'highlightTextMap',
      source: 'source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      docId: 'string',
      highlightTextMap: GetSearchCodePreviewResponseBodyResultHighlightTextMap,
      source: GetSearchCodePreviewResponseBodyResultSource,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSprintInfoResponseBodySprint extends $tea.Model {
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  creator?: string;
  /**
   * @example
   * xxx
   */
  description?: string;
  /**
   * @example
   * 1623916393000
   */
  endDate?: number;
  /**
   * @example
   * 1623916393000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1623916393000
   */
  gmtModified?: number;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  identifier?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  modifier?: string;
  /**
   * @example
   * demo示例项目
   */
  name?: string;
  owners?: string[];
  /**
   * @example
   * public
   */
  scope?: string;
  /**
   * @example
   * 5e70xxxxxxcd000xxxxe96
   */
  spaceIdentifier?: string;
  /**
   * @example
   * 1638403200000
   */
  startDate?: number;
  /**
   * @example
   * Todo
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      creator: 'creator',
      description: 'description',
      endDate: 'endDate',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      modifier: 'modifier',
      name: 'name',
      owners: 'owners',
      scope: 'scope',
      spaceIdentifier: 'spaceIdentifier',
      startDate: 'startDate',
      status: 'status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creator: 'string',
      description: 'string',
      endDate: 'number',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      modifier: 'string',
      name: 'string',
      owners: { 'type': 'array', 'itemType': 'string' },
      scope: 'string',
      spaceIdentifier: 'string',
      startDate: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestResultListResponseBodyTestResultAssignedTo extends $tea.Model {
  assignedToIdenttifier?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      assignedToIdenttifier: 'assignedToIdenttifier',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedToIdenttifier: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestResultListResponseBodyTestResultCustomFields extends $tea.Model {
  fieldClassName?: string;
  fieldFormat?: string;
  fieldIdentifier?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      fieldClassName: 'fieldClassName',
      fieldFormat: 'fieldFormat',
      fieldIdentifier: 'fieldIdentifier',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldClassName: 'string',
      fieldFormat: 'string',
      fieldIdentifier: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestResultListResponseBodyTestResultTestResultExecutor extends $tea.Model {
  executorIdentifier?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      executorIdentifier: 'executorIdentifier',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      executorIdentifier: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestResultListResponseBodyTestResult extends $tea.Model {
  assignedTo?: GetTestResultListResponseBodyTestResultAssignedTo;
  /**
   * @example
   * 8
   */
  bugCount?: number;
  /**
   * @example
   * Req
   */
  categoryIdentifier?: string;
  customFields?: GetTestResultListResponseBodyTestResultCustomFields[];
  gmtCreate?: number;
  spaceIdentifier?: string;
  /**
   * @example
   * 测试工作项
   */
  subject?: string;
  testResultExecutor?: GetTestResultListResponseBodyTestResultTestResultExecutor;
  testResultGmtCreate?: number;
  /**
   * @example
   * a8bxxxxxxxxxxxxxxxx54
   */
  testResultIdentifier?: string;
  /**
   * @example
   * TO DO
   */
  testResultStatus?: string;
  testcaseIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      bugCount: 'bugCount',
      categoryIdentifier: 'categoryIdentifier',
      customFields: 'customFields',
      gmtCreate: 'gmtCreate',
      spaceIdentifier: 'spaceIdentifier',
      subject: 'subject',
      testResultExecutor: 'testResultExecutor',
      testResultGmtCreate: 'testResultGmtCreate',
      testResultIdentifier: 'testResultIdentifier',
      testResultStatus: 'testResultStatus',
      testcaseIdentifier: 'testcaseIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: GetTestResultListResponseBodyTestResultAssignedTo,
      bugCount: 'number',
      categoryIdentifier: 'string',
      customFields: { 'type': 'array', 'itemType': GetTestResultListResponseBodyTestResultCustomFields },
      gmtCreate: 'number',
      spaceIdentifier: 'string',
      subject: 'string',
      testResultExecutor: GetTestResultListResponseBodyTestResultTestResultExecutor,
      testResultGmtCreate: 'number',
      testResultIdentifier: 'string',
      testResultStatus: 'string',
      testcaseIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestcaseListResponseBodyTestcaseAssignedTo extends $tea.Model {
  /**
   * @example
   * 12xxxxx456
   */
  assignedToIdenttifier?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      assignedToIdenttifier: 'assignedToIdenttifier',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedToIdenttifier: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestcaseListResponseBodyTestcaseCustomFields extends $tea.Model {
  /**
   * @example
   * User
   */
  fieldClassName?: string;
  /**
   * @example
   * Input
   */
  fieldFormat?: string;
  /**
   * @example
   * 85702b33f14bfa82cb458173ba
   */
  fieldIdentifier?: string;
  /**
   * @example
   * d7f112f9d023e2108fa1b0d8
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      fieldClassName: 'fieldClassName',
      fieldFormat: 'fieldFormat',
      fieldIdentifier: 'fieldIdentifier',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldClassName: 'string',
      fieldFormat: 'string',
      fieldIdentifier: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestcaseListResponseBodyTestcaseSpace extends $tea.Model {
  /**
   * @example
   * 22c32972b853cd703dbf0efe4c
   */
  spaceIdentifier?: string;
  /**
   * @example
   * TestRepo
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      spaceIdentifier: 'spaceIdentifier',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spaceIdentifier: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestcaseListResponseBodyTestcaseTags extends $tea.Model {
  name?: string;
  /**
   * @example
   * 85702b33f14bxxxxxx58173ba
   */
  tagIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'name',
      tagIdentifier: 'tagIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      tagIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTestcaseListResponseBodyTestcase extends $tea.Model {
  assignedTo?: GetTestcaseListResponseBodyTestcaseAssignedTo;
  /**
   * @example
   * Req
   */
  categoryIdentifier?: string;
  customFields?: GetTestcaseListResponseBodyTestcaseCustomFields[];
  /**
   * @example
   * 1621578648000
   */
  gmtCreate?: number;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  identifier?: string;
  space?: GetTestcaseListResponseBodyTestcaseSpace;
  /**
   * @example
   * 测试工作项
   */
  subject?: string;
  tags?: GetTestcaseListResponseBodyTestcaseTags[];
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      categoryIdentifier: 'categoryIdentifier',
      customFields: 'customFields',
      gmtCreate: 'gmtCreate',
      identifier: 'identifier',
      space: 'space',
      subject: 'subject',
      tags: 'tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: GetTestcaseListResponseBodyTestcaseAssignedTo,
      categoryIdentifier: 'string',
      customFields: { 'type': 'array', 'itemType': GetTestcaseListResponseBodyTestcaseCustomFields },
      gmtCreate: 'number',
      identifier: 'string',
      space: GetTestcaseListResponseBodyTestcaseSpace,
      subject: 'string',
      tags: { 'type': 'array', 'itemType': GetTestcaseListResponseBodyTestcaseTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserInfoResponseBodyResult extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 4205
   */
  id?: number;
  name?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVMDeployOrderResponseBodyDeployOrderActions extends $tea.Model {
  /**
   * @example
   * true
   */
  disable?: boolean;
  /**
   * @example
   * {}
   */
  params?: any;
  /**
   * @example
   * StopVMDeployOrder
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      disable: 'disable',
      params: 'params',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      disable: 'boolean',
      params: 'any',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachinesActions extends $tea.Model {
  /**
   * @example
   * true
   */
  disable?: boolean;
  /**
   * @example
   * {}
   */
  params?: any;
  /**
   * @example
   * RetryVMDeployMachine
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      disable: 'disable',
      params: 'params',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      disable: 'boolean',
      params: 'any',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachines extends $tea.Model {
  actions?: GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachinesActions[];
  /**
   * @example
   * 22
   */
  batchNum?: number;
  /**
   * @example
   * ok
   */
  clientStatus?: string;
  /**
   * @example
   * 1111111111
   */
  createTime?: number;
  /**
   * @example
   * 127.0.0.1
   */
  ip?: string;
  /**
   * @example
   * sasssasa
   */
  machineSn?: string;
  /**
   * @example
   * Success
   */
  status?: string;
  /**
   * @example
   * 11111111
   */
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      actions: 'actions',
      batchNum: 'batchNum',
      clientStatus: 'clientStatus',
      createTime: 'createTime',
      ip: 'ip',
      machineSn: 'machineSn',
      status: 'status',
      updateTime: 'updateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actions: { 'type': 'array', 'itemType': GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachinesActions },
      batchNum: 'number',
      clientStatus: 'string',
      createTime: 'number',
      ip: 'string',
      machineSn: 'string',
      status: 'string',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfo extends $tea.Model {
  /**
   * @example
   * 11
   */
  batchNum?: number;
  deployMachines?: GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachines[];
  /**
   * @example
   * 1111
   */
  hostGroupId?: number;
  static names(): { [key: string]: string } {
    return {
      batchNum: 'batchNum',
      deployMachines: 'deployMachines',
      hostGroupId: 'hostGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchNum: 'number',
      deployMachines: { 'type': 'array', 'itemType': GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachines },
      hostGroupId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVMDeployOrderResponseBodyDeployOrder extends $tea.Model {
  actions?: GetVMDeployOrderResponseBodyDeployOrderActions[];
  /**
   * @example
   * 111111111111
   */
  createTime?: number;
  /**
   * @example
   * ssaassa
   */
  creator?: string;
  /**
   * @example
   * 2
   */
  currentBatch?: number;
  deployMachineInfo?: GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfo;
  /**
   * @example
   * 11111
   */
  deployOrderId?: string;
  exceptionCode?: string;
  /**
   * @example
   * Success
   */
  status?: string;
  /**
   * @example
   * 3
   */
  totalBatch?: number;
  /**
   * @example
   * 11111111111
   */
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      actions: 'actions',
      createTime: 'createTime',
      creator: 'creator',
      currentBatch: 'currentBatch',
      deployMachineInfo: 'deployMachineInfo',
      deployOrderId: 'deployOrderId',
      exceptionCode: 'exceptionCode',
      status: 'status',
      totalBatch: 'totalBatch',
      updateTime: 'updateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actions: { 'type': 'array', 'itemType': GetVMDeployOrderResponseBodyDeployOrderActions },
      createTime: 'number',
      creator: 'string',
      currentBatch: 'number',
      deployMachineInfo: GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfo,
      deployOrderId: 'string',
      exceptionCode: 'string',
      status: 'string',
      totalBatch: 'number',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVariableGroupResponseBodyVariableGroupRelatedPipelines extends $tea.Model {
  /**
   * @example
   * 1234
   */
  id?: number;
  /**
   * @example
   * 流水线
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVariableGroupResponseBodyVariableGroupVariables extends $tea.Model {
  /**
   * @example
   * true
   */
  isEncrypted?: boolean;
  /**
   * @example
   * name1
   */
  name?: string;
  /**
   * @example
   * value1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      isEncrypted: 'isEncrypted',
      name: 'name',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isEncrypted: 'boolean',
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVariableGroupResponseBodyVariableGroup extends $tea.Model {
  /**
   * @example
   * 13232343434343
   */
  ccreatorAccountId?: string;
  /**
   * @example
   * 1586863220000
   */
  createTime?: number;
  /**
   * @example
   * 变量组
   */
  description?: string;
  /**
   * @example
   * 12234
   */
  id?: number;
  /**
   * @example
   * 13232343434343
   */
  modifierAccountId?: string;
  /**
   * @example
   * 变量组
   */
  name?: string;
  relatedPipelines?: GetVariableGroupResponseBodyVariableGroupRelatedPipelines[];
  /**
   * @example
   * 1586863220000
   */
  updateTime?: number;
  variables?: GetVariableGroupResponseBodyVariableGroupVariables[];
  static names(): { [key: string]: string } {
    return {
      ccreatorAccountId: 'ccreatorAccountId',
      createTime: 'createTime',
      description: 'description',
      id: 'id',
      modifierAccountId: 'modifierAccountId',
      name: 'name',
      relatedPipelines: 'relatedPipelines',
      updateTime: 'updateTime',
      variables: 'variables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ccreatorAccountId: 'string',
      createTime: 'number',
      description: 'string',
      id: 'number',
      modifierAccountId: 'string',
      name: 'string',
      relatedPipelines: { 'type': 'array', 'itemType': GetVariableGroupResponseBodyVariableGroupRelatedPipelines },
      updateTime: 'number',
      variables: { 'type': 'array', 'itemType': GetVariableGroupResponseBodyVariableGroupVariables },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemActivityResponseBodyActivitiesNewValue extends $tea.Model {
  /**
   * @example
   * Sprint-221124
   */
  displayValue?: string;
  /**
   * @example
   * bed1cca179badeb501a72d1194
   */
  plainValue?: string;
  /**
   * @example
   * Sprint
   */
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      displayValue: 'displayValue',
      plainValue: 'plainValue',
      resourceType: 'resourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayValue: 'string',
      plainValue: 'string',
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemActivityResponseBodyActivitiesOldValue extends $tea.Model {
  /**
   * @example
   * Sprint-221124
   */
  displayValue?: string;
  /**
   * @example
   * bed1cca179badeb501a72d1194
   */
  plainValue?: string;
  /**
   * @example
   * Sprint
   */
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      displayValue: 'displayValue',
      plainValue: 'plainValue',
      resourceType: 'resourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayValue: 'string',
      plainValue: 'string',
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemActivityResponseBodyActivitiesProperty extends $tea.Model {
  /**
   * @example
   * 标题
   */
  displayName?: string;
  /**
   * @example
   * subject
   */
  propertyIdentifier?: string;
  /**
   * @example
   * subject
   */
  propertyName?: string;
  /**
   * @example
   * null
   */
  propertyType?: string;
  static names(): { [key: string]: string } {
    return {
      displayName: 'displayName',
      propertyIdentifier: 'propertyIdentifier',
      propertyName: 'propertyName',
      propertyType: 'propertyType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      propertyIdentifier: 'string',
      propertyName: 'string',
      propertyType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemActivityResponseBodyActivities extends $tea.Model {
  /**
   * @example
   * update
   */
  actionType?: string;
  /**
   * @example
   * 3201131
   */
  eventId?: number;
  /**
   * @example
   * 1640867079624
   */
  eventTime?: number;
  /**
   * @example
   * workitem.updated
   */
  eventType?: string;
  newValue?: GetWorkItemActivityResponseBodyActivitiesNewValue[];
  oldValue?: GetWorkItemActivityResponseBodyActivitiesOldValue[];
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  operator?: string;
  /**
   * @example
   * 3201132
   */
  parentEventId?: number;
  /**
   * @example
   * public
   */
  property?: GetWorkItemActivityResponseBodyActivitiesProperty;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  resourceIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      actionType: 'actionType',
      eventId: 'eventId',
      eventTime: 'eventTime',
      eventType: 'eventType',
      newValue: 'newValue',
      oldValue: 'oldValue',
      operator: 'operator',
      parentEventId: 'parentEventId',
      property: 'property',
      resourceIdentifier: 'resourceIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionType: 'string',
      eventId: 'number',
      eventTime: 'number',
      eventType: 'string',
      newValue: { 'type': 'array', 'itemType': GetWorkItemActivityResponseBodyActivitiesNewValue },
      oldValue: { 'type': 'array', 'itemType': GetWorkItemActivityResponseBodyActivitiesOldValue },
      operator: 'string',
      parentEventId: 'number',
      property: GetWorkItemActivityResponseBodyActivitiesProperty,
      resourceIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemInfoResponseBodyWorkitemCustomFieldsValueList extends $tea.Model {
  /**
   * @example
   * 2022-02-01 00:00:00
   */
  displayValue?: string;
  /**
   * @example
   * 2022-02-01 00:00:00
   */
  identifier?: string;
  /**
   * @example
   * 1
   */
  level?: number;
  /**
   * @example
   * 2022-02-01 00:00:00
   */
  value?: string;
  /**
   * @example
   * null
   */
  valueEn?: string;
  static names(): { [key: string]: string } {
    return {
      displayValue: 'displayValue',
      identifier: 'identifier',
      level: 'level',
      value: 'value',
      valueEn: 'valueEn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayValue: 'string',
      identifier: 'string',
      level: 'number',
      value: 'string',
      valueEn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemInfoResponseBodyWorkitemCustomFields extends $tea.Model {
  /**
   * @example
   * 例如：date
   */
  fieldClassName?: string;
  /**
   * @example
   * 例：input
   */
  fieldFormat?: string;
  /**
   * @example
   * 例：80
   */
  fieldIdentifier?: string;
  /**
   * @example
   * 1
   */
  level?: number;
  /**
   * @example
   * null
   */
  objectValue?: string;
  /**
   * @example
   * 1
   */
  position?: number;
  /**
   * @example
   * 例：2022-01-06 00:00:00
   */
  value?: string;
  valueList?: GetWorkItemInfoResponseBodyWorkitemCustomFieldsValueList[];
  /**
   * @example
   * 5daa9a15c7fd55523996......
   */
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      fieldClassName: 'fieldClassName',
      fieldFormat: 'fieldFormat',
      fieldIdentifier: 'fieldIdentifier',
      level: 'level',
      objectValue: 'objectValue',
      position: 'position',
      value: 'value',
      valueList: 'valueList',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldClassName: 'string',
      fieldFormat: 'string',
      fieldIdentifier: 'string',
      level: 'number',
      objectValue: 'string',
      position: 'number',
      value: 'string',
      valueList: { 'type': 'array', 'itemType': GetWorkItemInfoResponseBodyWorkitemCustomFieldsValueList },
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemInfoResponseBodyWorkitemTagDetails extends $tea.Model {
  color?: string;
  identifier?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      color: 'color',
      identifier: 'identifier',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      color: 'string',
      identifier: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemInfoResponseBodyWorkitem extends $tea.Model {
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  assignedTo?: string;
  /**
   * @example
   * Req
   */
  categoryIdentifier?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  creator?: string;
  customFields?: GetWorkItemInfoResponseBodyWorkitemCustomFields[];
  /**
   * @example
   * html格式
   */
  document?: string;
  documentFormat?: string;
  finishTime?: number;
  /**
   * @example
   * 1640850318000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1640850318000
   */
  gmtModified?: number;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  identifier?: string;
  /**
   * @example
   * NORMAL
   */
  logicalStatus?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  modifier?: string;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx24
   */
  parentIdentifier?: string;
  participant?: string[];
  /**
   * @example
   * ABCD-1
   */
  serialNumber?: string;
  /**
   * @example
   * e8b26xxxxx6e76aa20xxxxx23
   */
  spaceIdentifier?: string;
  /**
   * @example
   * 需求项目
   */
  spaceName?: string;
  /**
   * @example
   * Project
   */
  spaceType?: string;
  sprint?: string[];
  /**
   * @example
   * 待处理
   */
  status?: string;
  /**
   * @example
   * 例：100005
   */
  statusIdentifier?: string;
  /**
   * @example
   * 1
   */
  statusStageIdentifier?: string;
  /**
   * @example
   * 测试工作项
   */
  subject?: string;
  tag?: string[];
  tagDetails?: GetWorkItemInfoResponseBodyWorkitemTagDetails[];
  tracker?: string[];
  /**
   * @example
   * 1640850328000
   */
  updateStatusAt?: number;
  verifier?: string[];
  /**
   * @example
   * 9uxxxxxxre573f5xxxxxx0
   */
  workitemTypeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      customFields: 'customFields',
      document: 'document',
      documentFormat: 'documentFormat',
      finishTime: 'finishTime',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      logicalStatus: 'logicalStatus',
      modifier: 'modifier',
      parentIdentifier: 'parentIdentifier',
      participant: 'participant',
      serialNumber: 'serialNumber',
      spaceIdentifier: 'spaceIdentifier',
      spaceName: 'spaceName',
      spaceType: 'spaceType',
      sprint: 'sprint',
      status: 'status',
      statusIdentifier: 'statusIdentifier',
      statusStageIdentifier: 'statusStageIdentifier',
      subject: 'subject',
      tag: 'tag',
      tagDetails: 'tagDetails',
      tracker: 'tracker',
      updateStatusAt: 'updateStatusAt',
      verifier: 'verifier',
      workitemTypeIdentifier: 'workitemTypeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: 'string',
      categoryIdentifier: 'string',
      creator: 'string',
      customFields: { 'type': 'array', 'itemType': GetWorkItemInfoResponseBodyWorkitemCustomFields },
      document: 'string',
      documentFormat: 'string',
      finishTime: 'number',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      logicalStatus: 'string',
      modifier: 'string',
      parentIdentifier: 'string',
      participant: { 'type': 'array', 'itemType': 'string' },
      serialNumber: 'string',
      spaceIdentifier: 'string',
      spaceName: 'string',
      spaceType: 'string',
      sprint: { 'type': 'array', 'itemType': 'string' },
      status: 'string',
      statusIdentifier: 'string',
      statusStageIdentifier: 'string',
      subject: 'string',
      tag: { 'type': 'array', 'itemType': 'string' },
      tagDetails: { 'type': 'array', 'itemType': GetWorkItemInfoResponseBodyWorkitemTagDetails },
      tracker: { 'type': 'array', 'itemType': 'string' },
      updateStatusAt: 'number',
      verifier: { 'type': 'array', 'itemType': 'string' },
      workitemTypeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemWorkFlowInfoResponseBodyWorkflowStatuses extends $tea.Model {
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  creator?: string;
  /**
   * @example
   * xxx
   */
  description?: string;
  /**
   * @example
   * 1613805843000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1613805843000
   */
  gmtModified?: number;
  /**
   * @example
   * 156603
   */
  identifier?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  modifier?: string;
  /**
   * @example
   * 待处理
   */
  name?: string;
  /**
   * @example
   * Workitem
   */
  resourceType?: string;
  /**
   * @example
   * system
   */
  source?: string;
  /**
   * @example
   * 1
   */
  workflowStageIdentifier?: string;
  /**
   * @example
   * 确认阶段
   */
  workflowStageName?: string;
  static names(): { [key: string]: string } {
    return {
      creator: 'creator',
      description: 'description',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      modifier: 'modifier',
      name: 'name',
      resourceType: 'resourceType',
      source: 'source',
      workflowStageIdentifier: 'workflowStageIdentifier',
      workflowStageName: 'workflowStageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creator: 'string',
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      modifier: 'string',
      name: 'string',
      resourceType: 'string',
      source: 'string',
      workflowStageIdentifier: 'string',
      workflowStageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemWorkFlowInfoResponseBodyWorkflowWorkflowActions extends $tea.Model {
  /**
   * @example
   * 16274887
   */
  id?: number;
  /**
   * @example
   * xxx
   */
  name?: string;
  /**
   * @example
   * 100011
   */
  nextWorkflowStatusIdentifier?: string;
  /**
   * @example
   * fd0xxxxxd00d355b05dxxxx26
   */
  workflowIdentifier?: string;
  /**
   * @example
   * 100005
   */
  workflowStatusIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      name: 'name',
      nextWorkflowStatusIdentifier: 'nextWorkflowStatusIdentifier',
      workflowIdentifier: 'workflowIdentifier',
      workflowStatusIdentifier: 'workflowStatusIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
      nextWorkflowStatusIdentifier: 'string',
      workflowIdentifier: 'string',
      workflowStatusIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkItemWorkFlowInfoResponseBodyWorkflow extends $tea.Model {
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  creator?: string;
  /**
   * @example
   * 100005
   */
  defaultStatusIdentifier?: string;
  /**
   * @example
   * 工作流的描述
   */
  description?: string;
  /**
   * @example
   * 1640850318000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1640850318000
   */
  gmtModified?: number;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  identifier?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  modifier?: string;
  /**
   * @example
   * 名称
   */
  name?: string;
  /**
   * @example
   * e8b26xxxxx6e76aa20xxxxx23
   */
  ownerSpaceIdentifier?: string;
  /**
   * @example
   * null
   */
  ownerSpaceType?: string;
  /**
   * @example
   * Project
   */
  resourceType?: string;
  /**
   * @example
   * system
   */
  source?: string;
  /**
   * @example
   * null
   */
  statusOrder?: string;
  statuses?: GetWorkItemWorkFlowInfoResponseBodyWorkflowStatuses[];
  workflowActions?: GetWorkItemWorkFlowInfoResponseBodyWorkflowWorkflowActions[];
  static names(): { [key: string]: string } {
    return {
      creator: 'creator',
      defaultStatusIdentifier: 'defaultStatusIdentifier',
      description: 'description',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      modifier: 'modifier',
      name: 'name',
      ownerSpaceIdentifier: 'ownerSpaceIdentifier',
      ownerSpaceType: 'ownerSpaceType',
      resourceType: 'resourceType',
      source: 'source',
      statusOrder: 'statusOrder',
      statuses: 'statuses',
      workflowActions: 'workflowActions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creator: 'string',
      defaultStatusIdentifier: 'string',
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      modifier: 'string',
      name: 'string',
      ownerSpaceIdentifier: 'string',
      ownerSpaceType: 'string',
      resourceType: 'string',
      source: 'string',
      statusOrder: 'string',
      statuses: { 'type': 'array', 'itemType': GetWorkItemWorkFlowInfoResponseBodyWorkflowStatuses },
      workflowActions: { 'type': 'array', 'itemType': GetWorkItemWorkFlowInfoResponseBodyWorkflowWorkflowActions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemAttachmentCreatemetaResponseBodyUploadInfo extends $tea.Model {
  /**
   * @example
   * xxxxxxx
   */
  accessid?: string;
  /**
   * @example
   * ddd/dddd
   */
  dir?: string;
  /**
   * @example
   * xxxxx
   */
  host?: string;
  /**
   * @example
   * xxxxxxx
   */
  policy?: string;
  /**
   * @example
   * xdWcrl/yTmIUA0kE7a3B0Ox4Vu8=
   */
  signature?: string;
  static names(): { [key: string]: string } {
    return {
      accessid: 'accessid',
      dir: 'dir',
      host: 'host',
      policy: 'policy',
      signature: 'signature',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessid: 'string',
      dir: 'string',
      host: 'string',
      policy: 'string',
      signature: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemCommentListResponseBodyCommentListUser extends $tea.Model {
  account?: string;
  avatar?: string;
  identifier?: string;
  nickName?: string;
  realName?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'account',
      avatar: 'avatar',
      identifier: 'identifier',
      nickName: 'nickName',
      realName: 'realName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      avatar: 'string',
      identifier: 'string',
      nickName: 'string',
      realName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemCommentListResponseBodyCommentList extends $tea.Model {
  /**
   * @example
   * 066961
   */
  content?: string;
  /**
   * @example
   * 1667205617061
   */
  createTime?: number;
  /**
   * @example
   * RICHTEXT/MARKDOWN
   */
  formatType?: string;
  /**
   * @example
   * 6573
   */
  id?: number;
  /**
   * @example
   * true/false
   */
  isTop?: boolean;
  /**
   * @example
   * 1646323200000
   */
  modifiedTime?: number;
  /**
   * @example
   * 1013131897677566
   */
  parentId?: number;
  /**
   * @example
   * 9144ef6b72d8exxxxx9e61a4d0
   */
  targetIdentifier?: string;
  /**
   * @example
   * workitem
   */
  targetType?: string;
  /**
   * @example
   * 1667205617089
   */
  topTime?: number;
  user?: GetWorkitemCommentListResponseBodyCommentListUser;
  static names(): { [key: string]: string } {
    return {
      content: 'content',
      createTime: 'createTime',
      formatType: 'formatType',
      id: 'id',
      isTop: 'isTop',
      modifiedTime: 'modifiedTime',
      parentId: 'parentId',
      targetIdentifier: 'targetIdentifier',
      targetType: 'targetType',
      topTime: 'topTime',
      user: 'user',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      createTime: 'number',
      formatType: 'string',
      id: 'number',
      isTop: 'boolean',
      modifiedTime: 'number',
      parentId: 'number',
      targetIdentifier: 'string',
      targetType: 'string',
      topTime: 'number',
      user: GetWorkitemCommentListResponseBodyCommentListUser,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemFileResponseBodyWorkitemFile extends $tea.Model {
  /**
   * @example
   * sddrdfdf123df
   */
  id?: string;
  /**
   * @example
   * ddc.pdf
   */
  name?: string;
  /**
   * @example
   * 10001
   */
  size?: number;
  /**
   * @example
   * pdf
   */
  suffix?: string;
  /**
   * @example
   * http://tmaestro-oss.oss-cn-hongkong.aliyuncs.com/thread_1682129288279.log
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      name: 'name',
      size: 'size',
      suffix: 'suffix',
      url: 'url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      name: 'string',
      size: 'number',
      suffix: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemRelationsResponseBodyRelationList extends $tea.Model {
  /**
   * @example
   * aliyun_1384605
   */
  assignedTo?: string;
  /**
   * @example
   * Req
   */
  categoryIdentifier?: string;
  /**
   * @example
   * 1667205617061
   */
  gmtCreate?: string;
  /**
   * @example
   * 1667205617089
   */
  gmtModified?: string;
  /**
   * @example
   * deafe5f33xxxxx6a259d8dafd
   */
  identifier?: string;
  /**
   * @example
   * 2b856dxxxxxxb61d93676255ba
   */
  spaceIdentifier?: string;
  subject?: string;
  /**
   * @example
   * 9uy29901re573f561d69jn40
   */
  workitemTypeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      categoryIdentifier: 'categoryIdentifier',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      spaceIdentifier: 'spaceIdentifier',
      subject: 'subject',
      workitemTypeIdentifier: 'workitemTypeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: 'string',
      categoryIdentifier: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      identifier: 'string',
      spaceIdentifier: 'string',
      subject: 'string',
      workitemTypeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkitemTimeTypeListResponseBodyTimeType extends $tea.Model {
  description?: string;
  /**
   * @example
   * deploy
   */
  displayName?: string;
  /**
   * @example
   * 67fb001005aac8d3d2a3372416
   */
  identifier?: string;
  name?: string;
  /**
   * @example
   * 1
   */
  position?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'description',
      displayName: 'displayName',
      identifier: 'identifier',
      name: 'name',
      position: 'position',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      displayName: 'string',
      identifier: 'string',
      name: 'string',
      position: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspaceResponseBodyWorkspace extends $tea.Model {
  /**
   * @example
   * https://codeup.aliyun.com/demo/group/Codeup-Demo.git
   */
  codeUrl?: string;
  /**
   * @example
   * master
   */
  codeVersion?: string;
  /**
   * @example
   * 1628564442000
   */
  createTime?: string;
  /**
   * @example
   * 6ed82817-ab75-4563-865d-81e60dxxxxxx
   */
  id?: string;
  /**
   * @example
   * Demo
   */
  name?: string;
  /**
   * @example
   * 2::4::60
   */
  spec?: string;
  /**
   * @example
   * SUCCESS
   */
  status?: string;
  /**
   * @example
   * all-in-one
   */
  template?: string;
  /**
   * @example
   * 1470227819xxxxxx
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      codeUrl: 'codeUrl',
      codeVersion: 'codeVersion',
      createTime: 'createTime',
      id: 'id',
      name: 'name',
      spec: 'spec',
      status: 'status',
      template: 'template',
      userId: 'userId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeUrl: 'string',
      codeVersion: 'string',
      createTime: 'string',
      id: 'string',
      name: 'string',
      spec: 'string',
      status: 'string',
      template: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LinkMergeRequestLabelResponseBodyResult extends $tea.Model {
  /**
   * @example
   * true
   */
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllReleaseWorkflowsResponseBodyReleaseStagesVariableGroups extends $tea.Model {
  /**
   * @example
   * dev
   */
  name?: string;
  displayName?: string;
  /**
   * @example
   * APP
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'name',
      displayName: 'displayName',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      displayName: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllReleaseWorkflowsResponseBodyReleaseStages extends $tea.Model {
  /**
   * @example
   * testApp
   */
  appName?: string;
  name?: string;
  /**
   * @example
   * 5aa8cc67e75e41bf9dddeb708775bcc3
   */
  sn?: string;
  /**
   * @example
   * ce51b31b996246ecaf874736838360b2
   */
  releaseWorkflowSn?: string;
  /**
   * @example
   * 1
   */
  order?: string;
  variableGroups?: ListAllReleaseWorkflowsResponseBodyReleaseStagesVariableGroups[];
  static names(): { [key: string]: string } {
    return {
      appName: 'appName',
      name: 'name',
      sn: 'sn',
      releaseWorkflowSn: 'releaseWorkflowSn',
      order: 'order',
      variableGroups: 'variableGroups',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      name: 'string',
      sn: 'string',
      releaseWorkflowSn: 'string',
      order: 'string',
      variableGroups: { 'type': 'array', 'itemType': ListAllReleaseWorkflowsResponseBodyReleaseStagesVariableGroups },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllReleaseWorkflowsResponseBody extends $tea.Model {
  /**
   * @example
   * testApp
   */
  appName?: string;
  /**
   * @example
   * ce51b31b996246ecaf874736838360b2
   */
  sn?: string;
  name?: string;
  /**
   * @example
   * 1
   */
  order?: string;
  releaseStages?: ListAllReleaseWorkflowsResponseBodyReleaseStages[];
  /**
   * @example
   * ""
   */
  note?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'appName',
      sn: 'sn',
      name: 'name',
      order: 'order',
      releaseStages: 'releaseStages',
      note: 'note',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      sn: 'string',
      name: 'string',
      order: 'string',
      releaseStages: { 'type': 'array', 'itemType': ListAllReleaseWorkflowsResponseBodyReleaseStages },
      note: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAppReleaseStageExecutionIntegratedMetadataResponseBodyChangeRequests extends $tea.Model {
  /**
   * @example
   * fcd37726a6f84c60b7eb9c5856007c2f
   */
  sn?: string;
  name?: string;
  /**
   * @example
   * feature/20240625
   */
  branchName?: string;
  /**
   * @example
   * a66cfa8c6869b96bb7d111ba2144c9c764d556b7
   */
  commitId?: string;
  /**
   * @example
   * 262579140573491041
   */
  ownerAccountId?: string;
  static names(): { [key: string]: string } {
    return {
      sn: 'sn',
      name: 'name',
      branchName: 'branchName',
      commitId: 'commitId',
      ownerAccountId: 'ownerAccountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sn: 'string',
      name: 'string',
      branchName: 'string',
      commitId: 'string',
      ownerAccountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAppReleaseStageExecutionIntegratedMetadataResponseBody extends $tea.Model {
  /**
   * @example
   * release/20240625-152603220321211_release_3252057_1
   */
  releaseBranch?: string;
  /**
   * @example
   * a66cfa8c6869b96bb7d111ba2144c9c764d556b7
   */
  releaseRevision?: string;
  /**
   * @example
   * https://codeup.aliyun.com/60d54f3daccf2bbd6659f3ad/auto-test.git
   */
  repoUrl?: string;
  /**
   * @example
   * CODEUP
   */
  repoType?: string;
  changeRequests?: ListAppReleaseStageExecutionIntegratedMetadataResponseBodyChangeRequests[];
  static names(): { [key: string]: string } {
    return {
      releaseBranch: 'releaseBranch',
      releaseRevision: 'releaseRevision',
      repoUrl: 'repoUrl',
      repoType: 'repoType',
      changeRequests: 'changeRequests',
    };
  }

  static types(): { [key: string]: any } {
    return {
      releaseBranch: 'string',
      releaseRevision: 'string',
      repoUrl: 'string',
      repoType: 'string',
      changeRequests: { 'type': 'array', 'itemType': ListAppReleaseStageExecutionIntegratedMetadataResponseBodyChangeRequests },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAppReleaseStageExecutionsResponseBodyData extends $tea.Model {
  /**
   * @example
   * 2024-06-25T07:26:18.000+00:00
   */
  endTime?: string;
  /**
   * @example
   * 1
   */
  number?: string;
  /**
   * @example
   * 2024-06-25T07:25:54.000+00:00
   */
  startTime?: string;
  /**
   * @example
   * SUCCESS
   */
  state?: string;
  /**
   * @example
   * MANUAL
   */
  triggerMode?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'endTime',
      number: 'number',
      startTime: 'startTime',
      state: 'state',
      triggerMode: 'triggerMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      number: 'string',
      startTime: 'string',
      state: 'string',
      triggerMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationMembersResponseBodyRecordsRoleList extends $tea.Model {
  /**
   * @example
   * 开发者
   */
  displayName?: string;
  /**
   * @example
   * developer
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      displayName: 'displayName',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationMembersResponseBodyRecords extends $tea.Model {
  /**
   * @example
   * http://
   */
  avatar?: string;
  /**
   * @example
   * 成语描述
   */
  description?: string;
  /**
   * @example
   * 成员1
   */
  displayName?: string;
  /**
   * @example
   * 1332695887xxxxxx
   */
  id?: string;
  roleList?: ListApplicationMembersResponseBodyRecordsRoleList[];
  /**
   * @example
   * User
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      avatar: 'avatar',
      description: 'description',
      displayName: 'displayName',
      id: 'id',
      roleList: 'roleList',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatar: 'string',
      description: 'string',
      displayName: 'string',
      id: 'string',
      roleList: { 'type': 'array', 'itemType': ListApplicationMembersResponseBodyRecordsRoleList },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsResponseBodyData extends $tea.Model {
  /**
   * @example
   * 1332695887xxxxxx
   */
  creatorAccountId?: string;
  /**
   * @example
   * 应用描述
   */
  description?: string;
  /**
   * @example
   * 2024-01-01T00:00:00.000+00:00
   */
  gmtCreate?: string;
  /**
   * @example
   * testApp
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      creatorAccountId: 'creatorAccountId',
      description: 'description',
      gmtCreate: 'gmtCreate',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorAccountId: 'string',
      description: 'string',
      gmtCreate: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckRunsResponseBodyResultAnnotations extends $tea.Model {
  /**
   * @example
   * warning
   */
  annotationLevel?: string;
  /**
   * @example
   * 5
   */
  endColumn?: number;
  /**
   * @example
   * 2
   */
  endLine?: number;
  /**
   * @example
   * 11806
   */
  id?: number;
  message?: string;
  /**
   * @example
   * demo/test.txt
   */
  path?: string;
  rawDetails?: string;
  /**
   * @example
   * 3
   */
  startColumn?: number;
  /**
   * @example
   * 1
   */
  startLine?: number;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      annotationLevel: 'annotationLevel',
      endColumn: 'endColumn',
      endLine: 'endLine',
      id: 'id',
      message: 'message',
      path: 'path',
      rawDetails: 'rawDetails',
      startColumn: 'startColumn',
      startLine: 'startLine',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotationLevel: 'string',
      endColumn: 'number',
      endLine: 'number',
      id: 'number',
      message: 'string',
      path: 'string',
      rawDetails: 'string',
      startColumn: 'number',
      startLine: 'number',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckRunsResponseBodyResultCheckSuite extends $tea.Model {
  /**
   * @example
   * 1
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckRunsResponseBodyResultOutputImages extends $tea.Model {
  /**
   * @example
   * test-image-alt
   */
  alt?: string;
  /**
   * @example
   * test
   */
  caption?: string;
  /**
   * @example
   * xxx
   */
  imageUrl?: string;
  static names(): { [key: string]: string } {
    return {
      alt: 'alt',
      caption: 'caption',
      imageUrl: 'imageUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alt: 'string',
      caption: 'string',
      imageUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckRunsResponseBodyResultOutput extends $tea.Model {
  images?: ListCheckRunsResponseBodyResultOutputImages[];
  summary?: string;
  text?: string;
  /**
   * @example
   * Mighty Readme report
   */
  title?: string;
  static names(): { [key: string]: string } {
    return {
      images: 'images',
      summary: 'summary',
      text: 'text',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      images: { 'type': 'array', 'itemType': ListCheckRunsResponseBodyResultOutputImages },
      summary: 'string',
      text: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckRunsResponseBodyResultWriter extends $tea.Model {
  /**
   * @example
   * xxx
   */
  id?: string;
  /**
   * @example
   * xxx
   */
  logoUrl?: string;
  /**
   * @example
   * test-codeup
   */
  name?: string;
  /**
   * @example
   * test-codeup
   */
  slug?: string;
  /**
   * @example
   * User
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      logoUrl: 'logoUrl',
      name: 'name',
      slug: 'slug',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      logoUrl: 'string',
      name: 'string',
      slug: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckRunsResponseBodyResult extends $tea.Model {
  annotations?: ListCheckRunsResponseBodyResultAnnotations[];
  checkSuite?: ListCheckRunsResponseBodyResultCheckSuite;
  /**
   * @example
   * 2023-03-15T08:00:00Z
   */
  completedAt?: string;
  /**
   * @example
   * success
   */
  conclusion?: string;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  createdAt?: string;
  /**
   * @example
   * xxx
   */
  detailsUrl?: string;
  /**
   * @example
   * 42
   */
  externalId?: string;
  /**
   * @example
   * 40f4ccfe019cdd4a62d4acb0c57130106fc7e1be
   */
  headSha?: string;
  /**
   * @example
   * 1
   */
  id?: number;
  /**
   * @example
   * my-check-ci
   */
  name?: string;
  output?: ListCheckRunsResponseBodyResultOutput;
  /**
   * @example
   * 2023-03-15T08:00:00Z
   */
  startedAt?: string;
  /**
   * @example
   * completed
   */
  status?: string;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  updatedAt?: string;
  writer?: ListCheckRunsResponseBodyResultWriter;
  static names(): { [key: string]: string } {
    return {
      annotations: 'annotations',
      checkSuite: 'checkSuite',
      completedAt: 'completedAt',
      conclusion: 'conclusion',
      createdAt: 'createdAt',
      detailsUrl: 'detailsUrl',
      externalId: 'externalId',
      headSha: 'headSha',
      id: 'id',
      name: 'name',
      output: 'output',
      startedAt: 'startedAt',
      status: 'status',
      updatedAt: 'updatedAt',
      writer: 'writer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotations: { 'type': 'array', 'itemType': ListCheckRunsResponseBodyResultAnnotations },
      checkSuite: ListCheckRunsResponseBodyResultCheckSuite,
      completedAt: 'string',
      conclusion: 'string',
      createdAt: 'string',
      detailsUrl: 'string',
      externalId: 'string',
      headSha: 'string',
      id: 'number',
      name: 'string',
      output: ListCheckRunsResponseBodyResultOutput,
      startedAt: 'string',
      status: 'string',
      updatedAt: 'string',
      writer: ListCheckRunsResponseBodyResultWriter,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCommitStatusesResponseBodyResultCreator extends $tea.Model {
  /**
   * @example
   * 235671547828975455
   */
  aliyunPk?: string;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * codeup
   */
  login?: string;
  /**
   * @example
   * User
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      avatarUrl: 'avatarUrl',
      login: 'login',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      avatarUrl: 'string',
      login: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCommitStatusesResponseBodyResult extends $tea.Model {
  /**
   * @example
   * test-commit-status-context
   */
  context?: string;
  creator?: ListCommitStatusesResponseBodyResultCreator;
  description?: string;
  /**
   * @example
   * 19285
   */
  id?: number;
  /**
   * @example
   * 61cc69557962d29f737a91730b3e86f497f083a3
   */
  sha?: string;
  /**
   * @example
   * success
   */
  state?: string;
  /**
   * @example
   * xxx
   */
  targetUrl?: string;
  static names(): { [key: string]: string } {
    return {
      context: 'context',
      creator: 'creator',
      description: 'description',
      id: 'id',
      sha: 'sha',
      state: 'state',
      targetUrl: 'targetUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      context: 'string',
      creator: ListCommitStatusesResponseBodyResultCreator,
      description: 'string',
      id: 'number',
      sha: 'string',
      state: 'string',
      targetUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowTagGroupsResponseBodyFlowTagGroups extends $tea.Model {
  /**
   * @example
   * 111111111
   */
  creatorAccountId?: string;
  /**
   * @example
   * 111
   */
  id?: number;
  /**
   * @example
   * 11111111
   */
  modiferAccountId?: string;
  /**
   * @example
   * 标签名称
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      creatorAccountId: 'creatorAccountId',
      id: 'id',
      modiferAccountId: 'modiferAccountId',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorAccountId: 'string',
      id: 'number',
      modiferAccountId: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGroupMemberResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 30
   */
  accessLevel?: number;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 123456
   */
  id?: number;
  /**
   * @example
   * USERS
   */
  memberType?: string;
  /**
   * @example
   * test-codeup
   */
  name?: string;
  /**
   * @example
   * 223241
   */
  sourceId?: number;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * test-codeup-nickname
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      memberType: 'memberType',
      name: 'name',
      sourceId: 'sourceId',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      memberType: 'string',
      name: 'string',
      sourceId: 'number',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGroupRepositoriesResponseBodyResult extends $tea.Model {
  /**
   * @example
   * false
   */
  archived?: boolean;
  /**
   * @example
   * 10
   */
  commitCount?: number;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  createdAt?: string;
  /**
   * @example
   * 19238
   */
  creatorId?: number;
  description?: string;
  /**
   * @example
   * https://xxx/test/test
   */
  httpUrl?: string;
  /**
   * @example
   * 89616
   */
  id?: number;
  /**
   * @example
   * http://xxx/x
   */
  importUrl?: string;
  /**
   * @example
   * true
   */
  isStared?: boolean;
  /**
   * @example
   * true
   */
  issuesEnabled?: boolean;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  lastActivityAt?: string;
  /**
   * @example
   * true
   */
  mergeRequestsEnabled?: boolean;
  /**
   * @example
   * test-group-repo
   */
  name?: string;
  nameWithNamespace?: string;
  /**
   * @example
   * 100003
   */
  namespaceId?: boolean;
  /**
   * @example
   * test-group-repo
   */
  path?: string;
  /**
   * @example
   * codeup-test-org/test-group-repo
   */
  pathWithNamespace?: string;
  /**
   * @example
   * true
   */
  privateFlag?: boolean;
  /**
   * @example
   * false
   */
  snippetsEnabled?: boolean;
  /**
   * @example
   * git@xxx:xxx/test/test.git
   */
  sshUrl?: string;
  /**
   * @example
   * 0
   */
  starCount?: number;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  updatedAt?: string;
  /**
   * @example
   * 0
   */
  visibilityLevel?: number;
  /**
   * @example
   * ""
   */
  webUrl?: string;
  /**
   * @example
   * true
   */
  wikiEnabled?: boolean;
  static names(): { [key: string]: string } {
    return {
      archived: 'archived',
      commitCount: 'commitCount',
      createdAt: 'createdAt',
      creatorId: 'creatorId',
      description: 'description',
      httpUrl: 'httpUrl',
      id: 'id',
      importUrl: 'importUrl',
      isStared: 'isStared',
      issuesEnabled: 'issuesEnabled',
      lastActivityAt: 'lastActivityAt',
      mergeRequestsEnabled: 'mergeRequestsEnabled',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      namespaceId: 'namespaceId',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      privateFlag: 'privateFlag',
      snippetsEnabled: 'snippetsEnabled',
      sshUrl: 'sshUrl',
      starCount: 'starCount',
      updatedAt: 'updatedAt',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
      wikiEnabled: 'wikiEnabled',
    };
  }

  static types(): { [key: string]: any } {
    return {
      archived: 'boolean',
      commitCount: 'number',
      createdAt: 'string',
      creatorId: 'number',
      description: 'string',
      httpUrl: 'string',
      id: 'number',
      importUrl: 'string',
      isStared: 'boolean',
      issuesEnabled: 'boolean',
      lastActivityAt: 'string',
      mergeRequestsEnabled: 'boolean',
      name: 'string',
      nameWithNamespace: 'string',
      namespaceId: 'boolean',
      path: 'string',
      pathWithNamespace: 'string',
      privateFlag: 'boolean',
      snippetsEnabled: 'boolean',
      sshUrl: 'string',
      starCount: 'number',
      updatedAt: 'string',
      visibilityLevel: 'number',
      webUrl: 'string',
      wikiEnabled: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHostGroupsResponseBodyHostGroups extends $tea.Model {
  /**
   * @example
   * cn-beijing
   */
  aliyunRegion?: string;
  /**
   * @example
   * 1586863220000
   */
  createTime?: number;
  /**
   * @example
   * 2222222222222
   */
  creatorAccountId?: string;
  /**
   * @example
   * 主机组
   */
  description?: string;
  /**
   * @example
   * ecs
   */
  ecsLabelKey?: string;
  /**
   * @example
   * value
   */
  ecsLabelValue?: string;
  /**
   * @example
   * ECS_ALIYUN
   */
  ecsType?: string;
  /**
   * @example
   * 3
   */
  hostNum?: number;
  /**
   * @remarks
   * 323232
   * 
   * @example
   * 部署组Id
   */
  id?: number;
  /**
   * @example
   * 211111111
   */
  modifierAccountId?: string;
  /**
   * @example
   * 部署组
   */
  name?: string;
  /**
   * @example
   * 1212122
   */
  serviceConnectionId?: number;
  /**
   * @example
   * ECS
   */
  type?: string;
  /**
   * @example
   * 1586863220000
   */
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      aliyunRegion: 'aliyunRegion',
      createTime: 'createTime',
      creatorAccountId: 'creatorAccountId',
      description: 'description',
      ecsLabelKey: 'ecsLabelKey',
      ecsLabelValue: 'ecsLabelValue',
      ecsType: 'ecsType',
      hostNum: 'hostNum',
      id: 'id',
      modifierAccountId: 'modifierAccountId',
      name: 'name',
      serviceConnectionId: 'serviceConnectionId',
      type: 'type',
      updateTime: 'updateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunRegion: 'string',
      createTime: 'number',
      creatorAccountId: 'string',
      description: 'string',
      ecsLabelKey: 'string',
      ecsLabelValue: 'string',
      ecsType: 'string',
      hostNum: 'number',
      id: 'number',
      modifierAccountId: 'string',
      name: 'string',
      serviceConnectionId: 'number',
      type: 'string',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJoinedOrganizationsResponseBodyOrganizations extends $tea.Model {
  /**
   * @example
   * 65f25d0fa54c216dcf6b1dbd
   */
  id?: string;
  isOrgAdmin?: boolean;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      isOrgAdmin: 'isOrgAdmin',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      isOrgAdmin: 'boolean',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponseBodyResultAuthor extends $tea.Model {
  /**
   * @example
   * 284692704493684695
   */
  aliyunPk?: string;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  id?: number;
  /**
   * @example
   * codeup
   */
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * test-codeup
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponseBodyResultChildCommentsAuthor extends $tea.Model {
  /**
   * @example
   * 204485087002425236
   */
  aliyunPk?: string;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  id?: number;
  /**
   * @example
   * codeup
   */
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * test-codeup
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsAuthor extends $tea.Model {
  /**
   * @example
   * 235671547828975455
   */
  aliyunPk?: string;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  id?: number;
  /**
   * @example
   * codeup
   */
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * test-codeup
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsRelatedPatchSet extends $tea.Model {
  /**
   * @example
   * 1a072f5367c21f9de3464b8c0ee8546e47764d2d
   */
  commitId?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  createdAt?: string;
  /**
   * @example
   * 513fcfd81a9142d2bb0db4f72c0aa15b
   */
  patchSetBizId?: string;
  patchSetName?: string;
  /**
   * @example
   * 1
   */
  patchSetNo?: string;
  /**
   * @example
   * MERGE_SOURCE
   */
  relatedMergeItemType?: string;
  /**
   * @example
   * 1a072f53
   */
  shortId?: string;
  static names(): { [key: string]: string } {
    return {
      commitId: 'commitId',
      createdAt: 'createdAt',
      patchSetBizId: 'patchSetBizId',
      patchSetName: 'patchSetName',
      patchSetNo: 'patchSetNo',
      relatedMergeItemType: 'relatedMergeItemType',
      shortId: 'shortId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commitId: 'string',
      createdAt: 'string',
      patchSetBizId: 'string',
      patchSetName: 'string',
      patchSetNo: 'string',
      relatedMergeItemType: 'string',
      shortId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildComments extends $tea.Model {
  author?: ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsAuthor;
  /**
   * @example
   * 5c399e3685e542a28db16d93e9f82abb
   */
  commentBizId?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  commentTime?: string;
  /**
   * @example
   * GLOBAL_COMMENT
   */
  commentType?: string;
  content?: string;
  /**
   * @example
   * false
   */
  deleted?: boolean;
  /**
   * @example
   * src/main/test.java
   */
  filePath?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  lastEditTime?: string;
  /**
   * @example
   * 3
   */
  lineNumber?: string;
  /**
   * @example
   * 4c5dcec6a8dc41e69c369737dadc1841
   */
  parentCommentBizId?: string;
  relatedPatchSet?: ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsRelatedPatchSet;
  /**
   * @example
   * false
   */
  resolved?: boolean;
  /**
   * @example
   * dcf2b23cebfc418f98dbd35e423d9fd3
   */
  rootCommentBizId?: string;
  /**
   * @example
   * OPENED
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      commentBizId: 'commentBizId',
      commentTime: 'commentTime',
      commentType: 'commentType',
      content: 'content',
      deleted: 'deleted',
      filePath: 'filePath',
      lastEditTime: 'lastEditTime',
      lineNumber: 'lineNumber',
      parentCommentBizId: 'parentCommentBizId',
      relatedPatchSet: 'relatedPatchSet',
      resolved: 'resolved',
      rootCommentBizId: 'rootCommentBizId',
      state: 'state',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsAuthor,
      commentBizId: 'string',
      commentTime: 'string',
      commentType: 'string',
      content: 'string',
      deleted: 'boolean',
      filePath: 'string',
      lastEditTime: 'string',
      lineNumber: 'string',
      parentCommentBizId: 'string',
      relatedPatchSet: ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsRelatedPatchSet,
      resolved: 'boolean',
      rootCommentBizId: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponseBodyResultChildCommentsRelatedPatchSet extends $tea.Model {
  /**
   * @example
   * 1a072f5367c21f9de3464b8c0ee8546e47764d2d
   */
  commitId?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  createdAt?: string;
  /**
   * @example
   * 513fcfd81a9142d2bb0db4f72c0aa15b
   */
  patchSetBizId?: string;
  patchSetName?: string;
  /**
   * @example
   * 1
   */
  patchSetNo?: string;
  /**
   * @example
   * MERGE_SOURCE
   */
  relatedMergeItemType?: string;
  /**
   * @example
   * 1a072f53
   */
  shortId?: string;
  static names(): { [key: string]: string } {
    return {
      commitId: 'commitId',
      createdAt: 'createdAt',
      patchSetBizId: 'patchSetBizId',
      patchSetName: 'patchSetName',
      patchSetNo: 'patchSetNo',
      relatedMergeItemType: 'relatedMergeItemType',
      shortId: 'shortId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commitId: 'string',
      createdAt: 'string',
      patchSetBizId: 'string',
      patchSetName: 'string',
      patchSetNo: 'string',
      relatedMergeItemType: 'string',
      shortId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponseBodyResultChildComments extends $tea.Model {
  author?: ListMergeRequestCommentsResponseBodyResultChildCommentsAuthor;
  /**
   * @example
   * 63f0e293357f48f9846ddc4dbbebd0e3
   */
  commentBizId?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  commentTime?: string;
  /**
   * @example
   * GLOBAL_COMMENT
   */
  commentType?: string;
  content?: string;
  /**
   * @example
   * false
   */
  deleted?: boolean;
  /**
   * @example
   * src/main/test.java
   */
  filePath?: string;
  finalChildComments?: ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildComments[];
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  lastEditTime?: string;
  /**
   * @example
   * 3
   */
  lineNumber?: string;
  /**
   * @example
   * 5c399e3685e542a28db16d93e9f82abb
   */
  parentCommentBizId?: string;
  relatedPatchSet?: ListMergeRequestCommentsResponseBodyResultChildCommentsRelatedPatchSet;
  /**
   * @example
   * false
   */
  resolved?: boolean;
  /**
   * @example
   * dcf2b23cebfc418f98dbd35e423d9fd3
   */
  rootCommentBizId?: string;
  /**
   * @example
   * OPENED
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      commentBizId: 'commentBizId',
      commentTime: 'commentTime',
      commentType: 'commentType',
      content: 'content',
      deleted: 'deleted',
      filePath: 'filePath',
      finalChildComments: 'finalChildComments',
      lastEditTime: 'lastEditTime',
      lineNumber: 'lineNumber',
      parentCommentBizId: 'parentCommentBizId',
      relatedPatchSet: 'relatedPatchSet',
      resolved: 'resolved',
      rootCommentBizId: 'rootCommentBizId',
      state: 'state',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: ListMergeRequestCommentsResponseBodyResultChildCommentsAuthor,
      commentBizId: 'string',
      commentTime: 'string',
      commentType: 'string',
      content: 'string',
      deleted: 'boolean',
      filePath: 'string',
      finalChildComments: { 'type': 'array', 'itemType': ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildComments },
      lastEditTime: 'string',
      lineNumber: 'string',
      parentCommentBizId: 'string',
      relatedPatchSet: ListMergeRequestCommentsResponseBodyResultChildCommentsRelatedPatchSet,
      resolved: 'boolean',
      rootCommentBizId: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponseBodyResultRelatedPatchSet extends $tea.Model {
  /**
   * @example
   * 1a072f5367c21f9de3464b8c0ee8546e47764d2d
   */
  commitId?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  createdAt?: string;
  /**
   * @example
   * 513fcfd81a9142d2bb0db4f72c0aa15b
   */
  patchSetBizId?: string;
  patchSetName?: string;
  /**
   * @example
   * 1
   */
  patchSetNo?: string;
  /**
   * @example
   * MERGE_SOURCE
   */
  relatedMergeItemType?: string;
  /**
   * @example
   * 1a072f53
   */
  shortId?: string;
  static names(): { [key: string]: string } {
    return {
      commitId: 'commitId',
      createdAt: 'createdAt',
      patchSetBizId: 'patchSetBizId',
      patchSetName: 'patchSetName',
      patchSetNo: 'patchSetNo',
      relatedMergeItemType: 'relatedMergeItemType',
      shortId: 'shortId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commitId: 'string',
      createdAt: 'string',
      patchSetBizId: 'string',
      patchSetName: 'string',
      patchSetNo: 'string',
      relatedMergeItemType: 'string',
      shortId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestCommentsResponseBodyResult extends $tea.Model {
  author?: ListMergeRequestCommentsResponseBodyResultAuthor;
  childComments?: ListMergeRequestCommentsResponseBodyResultChildComments[];
  /**
   * @example
   * 5c399e3685e542a28db16d93e9f82abb
   */
  commentBizId?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  commentTime?: string;
  /**
   * @example
   * GLOBAL_COMMENT
   */
  commentType?: string;
  content?: string;
  /**
   * @example
   * false
   */
  deleted?: boolean;
  /**
   * @example
   * src/main/test.java
   */
  filePath?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  lastEditTime?: string;
  /**
   * @example
   * 3
   */
  lineNumber?: string;
  /**
   * @example
   * 4c5dcec6a8dc41e69c369737dadc1841
   */
  parentCommentBizId?: string;
  relatedPatchSet?: ListMergeRequestCommentsResponseBodyResultRelatedPatchSet;
  /**
   * @example
   * false
   */
  resolved?: boolean;
  /**
   * @example
   * dcf2b23cebfc418f98dbd35e423d9fd3
   */
  rootCommentBizId?: string;
  /**
   * @example
   * OPENED
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      childComments: 'childComments',
      commentBizId: 'commentBizId',
      commentTime: 'commentTime',
      commentType: 'commentType',
      content: 'content',
      deleted: 'deleted',
      filePath: 'filePath',
      lastEditTime: 'lastEditTime',
      lineNumber: 'lineNumber',
      parentCommentBizId: 'parentCommentBizId',
      relatedPatchSet: 'relatedPatchSet',
      resolved: 'resolved',
      rootCommentBizId: 'rootCommentBizId',
      state: 'state',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: ListMergeRequestCommentsResponseBodyResultAuthor,
      childComments: { 'type': 'array', 'itemType': ListMergeRequestCommentsResponseBodyResultChildComments },
      commentBizId: 'string',
      commentTime: 'string',
      commentType: 'string',
      content: 'string',
      deleted: 'boolean',
      filePath: 'string',
      lastEditTime: 'string',
      lineNumber: 'string',
      parentCommentBizId: 'string',
      relatedPatchSet: ListMergeRequestCommentsResponseBodyResultRelatedPatchSet,
      resolved: 'boolean',
      rootCommentBizId: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestFilesReadsResponseBodyResultReadUsers extends $tea.Model {
  /**
   * @example
   * 204485087002425236
   */
  aliyunPk?: string;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * codeup
   */
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * test-codeup
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      avatarUrl: 'avatarUrl',
      email: 'email',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      avatarUrl: 'string',
      email: 'string',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestFilesReadsResponseBodyResult extends $tea.Model {
  /**
   * @example
   * false
   */
  deletedFile?: string;
  /**
   * @example
   * true
   */
  newFile?: boolean;
  /**
   * @example
   * text.txt
   */
  newFilePath?: string;
  /**
   * @example
   * text.txt
   */
  oldFilePath?: string;
  readUsers?: ListMergeRequestFilesReadsResponseBodyResultReadUsers[];
  /**
   * @example
   * false
   */
  renamedFile?: string;
  static names(): { [key: string]: string } {
    return {
      deletedFile: 'deletedFile',
      newFile: 'newFile',
      newFilePath: 'newFilePath',
      oldFilePath: 'oldFilePath',
      readUsers: 'readUsers',
      renamedFile: 'renamedFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deletedFile: 'string',
      newFile: 'boolean',
      newFilePath: 'string',
      oldFilePath: 'string',
      readUsers: { 'type': 'array', 'itemType': ListMergeRequestFilesReadsResponseBodyResultReadUsers },
      renamedFile: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestLabelsResponseBodyResult extends $tea.Model {
  /**
   * @example
   * #A16AD7
   */
  color?: string;
  description?: string;
  /**
   * @example
   * f2bf0e0b4ce34a348b2d971c69a1d11f
   */
  id?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      color: 'color',
      description: 'description',
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      color: 'string',
      description: 'string',
      id: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestPatchSetsResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 1a072f5367c21f9de3464b8c0ee8546e47764d2d
   */
  commitId?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  createdAt?: string;
  /**
   * @example
   * 513fcfd81a9142d2bb0db4f72c0aa15b
   */
  patchSetBizId?: string;
  patchSetName?: string;
  /**
   * @example
   * 1
   */
  patchSetNo?: number;
  /**
   * @example
   * MERGE_SOURCE
   */
  relatedMergeItemType?: string;
  /**
   * @example
   * 1a072f53
   */
  shortCommitId?: string;
  static names(): { [key: string]: string } {
    return {
      commitId: 'commitId',
      createdAt: 'createdAt',
      patchSetBizId: 'patchSetBizId',
      patchSetName: 'patchSetName',
      patchSetNo: 'patchSetNo',
      relatedMergeItemType: 'relatedMergeItemType',
      shortCommitId: 'shortCommitId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commitId: 'string',
      createdAt: 'string',
      patchSetBizId: 'string',
      patchSetName: 'string',
      patchSetNo: 'number',
      relatedMergeItemType: 'string',
      shortCommitId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestsResponseBodyResultAuthor extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 19927
   */
  id?: number;
  /**
   * @example
   * test-codeup
   */
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * root-test-codeup
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestsResponseBodyResultLabels extends $tea.Model {
  color?: string;
  description?: string;
  id?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      color: 'color',
      description: 'description',
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      color: 'string',
      description: 'string',
      id: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestsResponseBodyResultReviewers extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  hasCommented?: boolean;
  hasReviewed?: boolean;
  /**
   * @example
   * 43127
   */
  id?: number;
  /**
   * @example
   * test-review-user
   */
  name?: string;
  reviewOpinionStatus?: string;
  reviewTime?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * approved
   */
  status?: string;
  /**
   * @example
   * root-test-review-user
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      hasCommented: 'hasCommented',
      hasReviewed: 'hasReviewed',
      id: 'id',
      name: 'name',
      reviewOpinionStatus: 'reviewOpinionStatus',
      reviewTime: 'reviewTime',
      state: 'state',
      status: 'status',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      hasCommented: 'boolean',
      hasReviewed: 'boolean',
      id: 'number',
      name: 'string',
      reviewOpinionStatus: 'string',
      reviewTime: 'string',
      state: 'string',
      status: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestsResponseBodyResultSubscribers extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 1876119
   */
  id?: number;
  /**
   * @example
   * test-subscriber
   */
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * root-test-subscriber
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMergeRequestsResponseBodyResult extends $tea.Model {
  author?: ListMergeRequestsResponseBodyResultAuthor;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  createdAt?: string;
  /**
   * @example
   * WEB
   */
  creationMethod?: string;
  description?: string;
  /**
   * @example
   * xxx
   */
  detailUrl?: string;
  /**
   * @example
   * 1
   */
  id?: number;
  /**
   * @example
   * 1
   */
  iid?: number;
  labels?: ListMergeRequestsResponseBodyResultLabels[];
  /**
   * @example
   * 2
   */
  localId?: number;
  mergedRevision?: string;
  /**
   * @example
   * bca90244c4b749e0b109df52ac0eb570
   */
  mrBizId?: string;
  nameWithNamespace?: string;
  /**
   * @example
   * true
   */
  newMergeRequestIdentifier?: boolean;
  /**
   * @example
   * UNDER_REVIEW
   */
  newVersionState?: string;
  /**
   * @example
   * 2369234
   */
  projectId?: number;
  reviewers?: ListMergeRequestsResponseBodyResultReviewers[];
  /**
   * @example
   * test-merge-source-branch
   */
  sourceBranch?: string;
  /**
   * @example
   * 2876119
   */
  sourceProjectId?: number;
  /**
   * @example
   * BRANCH
   */
  sourceType?: string;
  /**
   * @example
   * git@xxx:xxx/test/test.git
   */
  sshUrl?: string;
  /**
   * @example
   * opened
   */
  state?: string;
  subscribers?: ListMergeRequestsResponseBodyResultSubscribers[];
  /**
   * @example
   * true
   */
  supportMergeFFOnly?: boolean;
  /**
   * @example
   * test-merge-target-branch
   */
  targetBranch?: string;
  /**
   * @example
   * 2876119
   */
  targetProjectId?: number;
  /**
   * @example
   * BRANCH
   */
  targetType?: string;
  title?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  updatedAt?: string;
  /**
   * @example
   * ""
   */
  webUrl?: string;
  /**
   * @example
   * false
   */
  workInProgress?: boolean;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      createdAt: 'createdAt',
      creationMethod: 'creationMethod',
      description: 'description',
      detailUrl: 'detailUrl',
      id: 'id',
      iid: 'iid',
      labels: 'labels',
      localId: 'localId',
      mergedRevision: 'mergedRevision',
      mrBizId: 'mrBizId',
      nameWithNamespace: 'nameWithNamespace',
      newMergeRequestIdentifier: 'newMergeRequestIdentifier',
      newVersionState: 'newVersionState',
      projectId: 'projectId',
      reviewers: 'reviewers',
      sourceBranch: 'sourceBranch',
      sourceProjectId: 'sourceProjectId',
      sourceType: 'sourceType',
      sshUrl: 'sshUrl',
      state: 'state',
      subscribers: 'subscribers',
      supportMergeFFOnly: 'supportMergeFFOnly',
      targetBranch: 'targetBranch',
      targetProjectId: 'targetProjectId',
      targetType: 'targetType',
      title: 'title',
      updatedAt: 'updatedAt',
      webUrl: 'webUrl',
      workInProgress: 'workInProgress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: ListMergeRequestsResponseBodyResultAuthor,
      createdAt: 'string',
      creationMethod: 'string',
      description: 'string',
      detailUrl: 'string',
      id: 'number',
      iid: 'number',
      labels: { 'type': 'array', 'itemType': ListMergeRequestsResponseBodyResultLabels },
      localId: 'number',
      mergedRevision: 'string',
      mrBizId: 'string',
      nameWithNamespace: 'string',
      newMergeRequestIdentifier: 'boolean',
      newVersionState: 'string',
      projectId: 'number',
      reviewers: { 'type': 'array', 'itemType': ListMergeRequestsResponseBodyResultReviewers },
      sourceBranch: 'string',
      sourceProjectId: 'number',
      sourceType: 'string',
      sshUrl: 'string',
      state: 'string',
      subscribers: { 'type': 'array', 'itemType': ListMergeRequestsResponseBodyResultSubscribers },
      supportMergeFFOnly: 'boolean',
      targetBranch: 'string',
      targetProjectId: 'number',
      targetType: 'string',
      title: 'string',
      updatedAt: 'string',
      webUrl: 'string',
      workInProgress: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrganizationMembersResponseBodyMembersIdentities extends $tea.Model {
  /**
   * @example
   * 1236666
   */
  externUid?: string;
  /**
   * @example
   * Dingtalk
   */
  provider?: string;
  static names(): { [key: string]: string } {
    return {
      externUid: 'externUid',
      provider: 'provider',
    };
  }

  static types(): { [key: string]: any } {
    return {
      externUid: 'string',
      provider: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrganizationMembersResponseBodyMembers extends $tea.Model {
  /**
   * @example
   * 123456677888
   */
  accountId?: string;
  /**
   * @example
   * 1631845101798
   */
  birthday?: number;
  deptLists?: string[];
  /**
   * @example
   * 123@mail.com
   */
  email?: string;
  /**
   * @example
   * 1631845101798
   */
  hiredDate?: number;
  identities?: ListOrganizationMembersResponseBodyMembersIdentities;
  jobNumber?: string;
  /**
   * @example
   * 1631845101798
   */
  joinTime?: number;
  /**
   * @example
   * 1631845101798
   */
  lastVisitTime?: number;
  /**
   * @example
   * 1390000****
   */
  mobile?: string;
  organizationMemberName?: string;
  /**
   * @example
   * 8fc0c9ff039711dd64acd000
   */
  organizationRoleId?: string;
  organizationRoleName?: string;
  /**
   * @example
   * normal
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
      birthday: 'birthday',
      deptLists: 'deptLists',
      email: 'email',
      hiredDate: 'hiredDate',
      identities: 'identities',
      jobNumber: 'jobNumber',
      joinTime: 'joinTime',
      lastVisitTime: 'lastVisitTime',
      mobile: 'mobile',
      organizationMemberName: 'organizationMemberName',
      organizationRoleId: 'organizationRoleId',
      organizationRoleName: 'organizationRoleName',
      state: 'state',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
      birthday: 'number',
      deptLists: { 'type': 'array', 'itemType': 'string' },
      email: 'string',
      hiredDate: 'number',
      identities: ListOrganizationMembersResponseBodyMembersIdentities,
      jobNumber: 'string',
      joinTime: 'number',
      lastVisitTime: 'number',
      mobile: 'string',
      organizationMemberName: 'string',
      organizationRoleId: 'string',
      organizationRoleName: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrganizationsResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 60
   */
  accessLevel?: number;
  /**
   * @example
   * 5240
   */
  id?: number;
  namespaceId?: string;
  organizationAlias?: string;
  /**
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  organizationName?: string;
  /**
   * @example
   * ORG_ADMIN
   */
  organizationRole?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      id: 'id',
      namespaceId: 'namespaceId',
      organizationAlias: 'organizationAlias',
      organizationId: 'organizationId',
      organizationName: 'organizationName',
      organizationRole: 'organizationRole',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      id: 'number',
      namespaceId: 'string',
      organizationAlias: 'string',
      organizationId: 'string',
      organizationName: 'string',
      organizationRole: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineGroupPipelinesResponseBodyPipelines extends $tea.Model {
  /**
   * @example
   * 1586863220000
   */
  createTime?: number;
  /**
   * @example
   * 1111
   */
  pipelineId?: number;
  pipelineName?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'createTime',
      pipelineId: 'pipelineId',
      pipelineName: 'pipelineName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      pipelineId: 'number',
      pipelineName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineGroupsResponseBodyPipelineGroups extends $tea.Model {
  /**
   * @example
   * 1586863220000
   */
  createTime?: number;
  /**
   * @example
   * 111
   */
  id?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'createTime',
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineJobHistorysResponseBodyJobs extends $tea.Model {
  /**
   * @example
   * 1
   */
  executeNumber?: number;
  /**
   * @example
   * 10_xaxxsxa
   */
  identifier?: string;
  /**
   * @example
   * 123
   */
  jobId?: number;
  jobName?: string;
  /**
   * @example
   * ssaasssa
   */
  operatorAccountId?: string;
  /**
   * @example
   * 123
   */
  pipelineId?: number;
  /**
   * @example
   * 123
   */
  pipelineRunId?: number;
  /**
   * @example
   * {}
   */
  sources?: string;
  /**
   * @example
   * SUCCESS
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      executeNumber: 'executeNumber',
      identifier: 'identifier',
      jobId: 'jobId',
      jobName: 'jobName',
      operatorAccountId: 'operatorAccountId',
      pipelineId: 'pipelineId',
      pipelineRunId: 'pipelineRunId',
      sources: 'sources',
      status: 'status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      executeNumber: 'number',
      identifier: 'string',
      jobId: 'number',
      jobName: 'string',
      operatorAccountId: 'string',
      pipelineId: 'number',
      pipelineRunId: 'number',
      sources: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineJobsResponseBodyJobs extends $tea.Model {
  /**
   * @example
   * ss_saxsxsxs
   */
  identifier?: string;
  jobName?: string;
  /**
   * @example
   * 123
   */
  lastJobId?: number;
  /**
   * @example
   * {}
   */
  lastJobParams?: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'identifier',
      jobName: 'jobName',
      lastJobId: 'lastJobId',
      lastJobParams: 'lastJobParams',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
      jobName: 'string',
      lastJobId: 'number',
      lastJobParams: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineRelationsResponseBodyPipelineRelations extends $tea.Model {
  /**
   * @example
   * 12234
   */
  refObjectId?: number;
  static names(): { [key: string]: string } {
    return {
      refObjectId: 'refObjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      refObjectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelineRunsResponseBodyPipelineRuns extends $tea.Model {
  /**
   * @example
   * 1222222222
   */
  creatorAccountId?: string;
  /**
   * @example
   * 1586863220000
   */
  endTime?: number;
  /**
   * @example
   * 1234
   */
  pipelineId?: number;
  /**
   * @example
   * 11
   */
  pipelineRunId?: number;
  /**
   * @example
   * 1586863220000
   */
  startTime?: number;
  /**
   * @example
   * 状态 FAIL 运行失败 SUCCESS 运行成功 RUNNING 运行中
   */
  status?: string;
  /**
   * @example
   * 1
   */
  triggerMode?: number;
  static names(): { [key: string]: string } {
    return {
      creatorAccountId: 'creatorAccountId',
      endTime: 'endTime',
      pipelineId: 'pipelineId',
      pipelineRunId: 'pipelineRunId',
      startTime: 'startTime',
      status: 'status',
      triggerMode: 'triggerMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorAccountId: 'string',
      endTime: 'number',
      pipelineId: 'number',
      pipelineRunId: 'number',
      startTime: 'number',
      status: 'string',
      triggerMode: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPipelinesResponseBodyPipelines extends $tea.Model {
  /**
   * @example
   * 1586863220000
   */
  createTime?: number;
  /**
   * @example
   * 22121222
   */
  creatorAccountId?: string;
  groupId?: number;
  /**
   * @example
   * 124
   */
  pipelineId?: number;
  /**
   * @example
   * 流水线
   */
  pipelineName?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'createTime',
      creatorAccountId: 'creatorAccountId',
      groupId: 'groupId',
      pipelineId: 'pipelineId',
      pipelineName: 'pipelineName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      creatorAccountId: 'string',
      groupId: 'number',
      pipelineId: 'number',
      pipelineName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectLabelsResponseBodyResult extends $tea.Model {
  /**
   * @example
   * #A16AD7
   */
  color?: string;
  description?: string;
  /**
   * @example
   * f2bf0e0b4ce34a348b2d971c69a1d11f
   */
  id?: string;
  name?: string;
  /**
   * @example
   * 1
   */
  openMergeRequestsCount?: number;
  static names(): { [key: string]: string } {
    return {
      color: 'color',
      description: 'description',
      id: 'id',
      name: 'name',
      openMergeRequestsCount: 'openMergeRequestsCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      color: 'string',
      description: 'string',
      id: 'string',
      name: 'string',
      openMergeRequestsCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectMembersResponseBodyMembersDivision extends $tea.Model {
  /**
   * @example
   * 1345xxxxxxx947xxxx
   */
  identifier?: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'identifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectMembersResponseBodyMembersOrganizationUserInfo extends $tea.Model {
  /**
   * @example
   * 5e7xxxxb3cd3711dd6xxx2c
   */
  organizationIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      organizationIdentifier: 'organizationIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectMembersResponseBodyMembers extends $tea.Model {
  /**
   * @example
   * null
   */
  account?: string;
  /**
   * @example
   * https://xxxxxx.png
   */
  avatar?: string;
  /**
   * @example
   * null
   */
  dingTalkId?: string;
  /**
   * @example
   * 名称
   */
  displayName?: string;
  /**
   * @example
   * mingcheng
   */
  displayNickName?: string;
  /**
   * @example
   * 名称
   */
  displayRealName?: string;
  division?: ListProjectMembersResponseBodyMembersDivision;
  /**
   * @example
   * accountsxxxx@mail.com
   */
  email?: string;
  /**
   * @example
   * null
   */
  gender?: string;
  /**
   * @example
   * 19xxxx31947xxxx
   */
  identifier?: string;
  /**
   * @example
   * 135xxxxxxxxx
   */
  mobile?: string;
  /**
   * @example
   * name
   */
  nameEn?: string;
  /**
   * @example
   * 昵称
   */
  nickName?: string;
  /**
   * @example
   * nicheng
   */
  nickNamePinyin?: string;
  organizationUserInfo?: ListProjectMembersResponseBodyMembersOrganizationUserInfo;
  /**
   * @example
   * xxx
   */
  realName?: string;
  /**
   * @example
   * xxx
   */
  realNamePinyin?: string;
  /**
   * @remarks
   * 角色名称
   */
  roleName?: string;
  /**
   * @example
   * User
   */
  stamp?: string;
  /**
   * @example
   * null
   */
  tbRoleId?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'account',
      avatar: 'avatar',
      dingTalkId: 'dingTalkId',
      displayName: 'displayName',
      displayNickName: 'displayNickName',
      displayRealName: 'displayRealName',
      division: 'division',
      email: 'email',
      gender: 'gender',
      identifier: 'identifier',
      mobile: 'mobile',
      nameEn: 'nameEn',
      nickName: 'nickName',
      nickNamePinyin: 'nickNamePinyin',
      organizationUserInfo: 'organizationUserInfo',
      realName: 'realName',
      realNamePinyin: 'realNamePinyin',
      roleName: 'roleName',
      stamp: 'stamp',
      tbRoleId: 'tbRoleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      avatar: 'string',
      dingTalkId: 'string',
      displayName: 'string',
      displayNickName: 'string',
      displayRealName: 'string',
      division: ListProjectMembersResponseBodyMembersDivision,
      email: 'string',
      gender: 'string',
      identifier: 'string',
      mobile: 'string',
      nameEn: 'string',
      nickName: 'string',
      nickNamePinyin: 'string',
      organizationUserInfo: ListProjectMembersResponseBodyMembersOrganizationUserInfo,
      realName: 'string',
      realNamePinyin: 'string',
      roleName: 'string',
      stamp: 'string',
      tbRoleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectTemplatesResponseBodyTemplates extends $tea.Model {
  /**
   * @example
   * null
   */
  copyFrom?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  creator?: string;
  /**
   * @example
   * 迭代的具体信息
   */
  description?: string;
  /**
   * @example
   * 1623916393000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1623916393000
   */
  gmtModified?: number;
  /**
   * @example
   * https://img.xxxx.png
   */
  icon?: string;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  identifier?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  modifier?: string;
  /**
   * @example
   * 专用模板
   */
  name?: string;
  /**
   * @example
   * Test Template
   */
  nameEn?: string;
  /**
   * @example
   * Project
   */
  resourceCategory?: string;
  /**
   * @example
   * null
   */
  resourceType?: string;
  /**
   * @example
   * null
   */
  spaceIdentifier?: string;
  /**
   * @example
   * null
   */
  spaceType?: string;
  /**
   * @example
   * 4
   */
  type?: number;
  static names(): { [key: string]: string } {
    return {
      copyFrom: 'copyFrom',
      creator: 'creator',
      description: 'description',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      icon: 'icon',
      identifier: 'identifier',
      modifier: 'modifier',
      name: 'name',
      nameEn: 'nameEn',
      resourceCategory: 'resourceCategory',
      resourceType: 'resourceType',
      spaceIdentifier: 'spaceIdentifier',
      spaceType: 'spaceType',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      copyFrom: 'string',
      creator: 'string',
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      icon: 'string',
      identifier: 'string',
      modifier: 'string',
      name: 'string',
      nameEn: 'string',
      resourceCategory: 'string',
      resourceType: 'string',
      spaceIdentifier: 'string',
      spaceType: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectWorkitemTypesResponseBodyWorkitemTypes extends $tea.Model {
  /**
   * @example
   * 用户阿里云pk，例如19xxxx31947xxxx
   */
  addUser?: string;
  /**
   * @example
   * Req
   */
  categoryIdentifier?: string;
  /**
   * @example
   * 用户阿里云pk，例如19xxxx31947xxxx
   */
  creator?: string;
  /**
   * @example
   * true或者false
   */
  defaultType?: boolean;
  /**
   * @example
   * 该类型的具体信息
   */
  description?: string;
  /**
   * @example
   * true或者false
   */
  enable?: boolean;
  /**
   * @example
   * 1641870287000
   */
  gmtAdd?: number;
  /**
   * @example
   * 1620455467000
   */
  gmtCreate?: number;
  /**
   * @example
   * dfexxxxxf4fee18xxxxx36
   */
  identifier?: string;
  /**
   * @example
   * 例：业务类需求
   */
  name?: string;
  /**
   * @example
   * 例：Business Requirement
   */
  nameEn?: string;
  /**
   * @example
   * true
   */
  systemDefault?: boolean;
  static names(): { [key: string]: string } {
    return {
      addUser: 'addUser',
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      defaultType: 'defaultType',
      description: 'description',
      enable: 'enable',
      gmtAdd: 'gmtAdd',
      gmtCreate: 'gmtCreate',
      identifier: 'identifier',
      name: 'name',
      nameEn: 'nameEn',
      systemDefault: 'systemDefault',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addUser: 'string',
      categoryIdentifier: 'string',
      creator: 'string',
      defaultType: 'boolean',
      description: 'string',
      enable: 'boolean',
      gmtAdd: 'number',
      gmtCreate: 'number',
      identifier: 'string',
      name: 'string',
      nameEn: 'string',
      systemDefault: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyProjects extends $tea.Model {
  /**
   * @example
   * Project
   */
  categoryIdentifier?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  creator?: string;
  /**
   * @example
   * OJAY
   */
  customCode?: string;
  /**
   * @example
   * null
   */
  deleteTime?: number;
  /**
   * @example
   * xxx
   */
  description?: string;
  /**
   * @example
   * 1640778694000
   */
  gmtCreate?: number;
  /**
   * @example
   * https://xxxxxx.png
   */
  icon?: string;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  identifier?: string;
  /**
   * @example
   * null
   */
  logicalStatus?: string;
  /**
   * @example
   * xxxx
   */
  name?: string;
  /**
   * @example
   * public
   */
  scope?: string;
  /**
   * @example
   * null
   */
  statusStageIdentifier?: string;
  /**
   * @example
   * null
   */
  typeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      customCode: 'customCode',
      deleteTime: 'deleteTime',
      description: 'description',
      gmtCreate: 'gmtCreate',
      icon: 'icon',
      identifier: 'identifier',
      logicalStatus: 'logicalStatus',
      name: 'name',
      scope: 'scope',
      statusStageIdentifier: 'statusStageIdentifier',
      typeIdentifier: 'typeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryIdentifier: 'string',
      creator: 'string',
      customCode: 'string',
      deleteTime: 'number',
      description: 'string',
      gmtCreate: 'number',
      icon: 'string',
      identifier: 'string',
      logicalStatus: 'string',
      name: 'string',
      scope: 'string',
      statusStageIdentifier: 'string',
      typeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResultAllowMergeUsers extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatar?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 19238
   */
  id?: number;
  name?: string;
  /**
   * @example
   * codeup-test
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatar: 'avatar',
      email: 'email',
      id: 'id',
      name: 'name',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatar: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResultAllowPushUsers extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatar?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 19238
   */
  id?: number;
  name?: string;
  /**
   * @example
   * codeup-test
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatar: 'avatar',
      email: 'email',
      id: 'id',
      name: 'name',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatar: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResultMergeRequestSettingDefaultAssignees extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatar?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 19238
   */
  id?: number;
  name?: string;
  /**
   * @example
   * codeup-test
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatar: 'avatar',
      email: 'email',
      id: 'id',
      name: 'name',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatar: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResultMergeRequestSetting extends $tea.Model {
  allowMergeRequestRoles?: number[];
  defaultAssignees?: ListProtectedBranchesResponseBodyResultMergeRequestSettingDefaultAssignees[];
  /**
   * @example
   * true
   */
  isAllowSelfApproval?: boolean;
  /**
   * @example
   * true
   */
  isRequireDiscussionProcessed?: boolean;
  /**
   * @example
   * true
   */
  isRequired?: boolean;
  /**
   * @example
   * false
   */
  isResetApprovalWhenNewPush?: boolean;
  /**
   * @example
   * 1
   */
  minimumApproval?: number;
  /**
   * @example
   * general
   */
  mrMode?: string;
  /**
   * @example
   * **.java
   */
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      allowMergeRequestRoles: 'allowMergeRequestRoles',
      defaultAssignees: 'defaultAssignees',
      isAllowSelfApproval: 'isAllowSelfApproval',
      isRequireDiscussionProcessed: 'isRequireDiscussionProcessed',
      isRequired: 'isRequired',
      isResetApprovalWhenNewPush: 'isResetApprovalWhenNewPush',
      minimumApproval: 'minimumApproval',
      mrMode: 'mrMode',
      whiteList: 'whiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowMergeRequestRoles: { 'type': 'array', 'itemType': 'number' },
      defaultAssignees: { 'type': 'array', 'itemType': ListProtectedBranchesResponseBodyResultMergeRequestSettingDefaultAssignees },
      isAllowSelfApproval: 'boolean',
      isRequireDiscussionProcessed: 'boolean',
      isRequired: 'boolean',
      isResetApprovalWhenNewPush: 'boolean',
      minimumApproval: 'number',
      mrMode: 'string',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems extends $tea.Model {
  /**
   * @example
   * false
   */
  isRequired?: boolean;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      isRequired: 'isRequired',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isRequired: 'boolean',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig extends $tea.Model {
  checkItems?: ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems[];
  static names(): { [key: string]: string } {
    return {
      checkItems: 'checkItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkItems: { 'type': 'array', 'itemType': ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig extends $tea.Model {
  /**
   * @example
   * 123456
   */
  bizNo?: string;
  /**
   * @example
   * false
   */
  enabled?: boolean;
  /**
   * @example
   * test_task_quality
   */
  message?: string;
  /**
   * @example
   * biz-task-quality
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      bizNo: 'bizNo',
      enabled: 'enabled',
      message: 'message',
      taskName: 'taskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizNo: 'string',
      enabled: 'boolean',
      message: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection extends $tea.Model {
  /**
   * @example
   * false
   */
  enabled?: boolean;
  /**
   * @example
   * test_code_guide_lines
   */
  message?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'enabled',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection extends $tea.Model {
  /**
   * @example
   * false
   */
  enabled?: boolean;
  /**
   * @example
   * test_code_sensitive_info
   */
  message?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'enabled',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResultTestSettingDTO extends $tea.Model {
  checkConfig?: ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig;
  checkTaskQualityConfig?: ListProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig;
  codeGuidelinesDetection?: ListProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection;
  /**
   * @example
   * false
   */
  isRequired?: boolean;
  sensitiveInfoDetection?: ListProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection;
  static names(): { [key: string]: string } {
    return {
      checkConfig: 'checkConfig',
      checkTaskQualityConfig: 'checkTaskQualityConfig',
      codeGuidelinesDetection: 'codeGuidelinesDetection',
      isRequired: 'isRequired',
      sensitiveInfoDetection: 'sensitiveInfoDetection',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkConfig: ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig,
      checkTaskQualityConfig: ListProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig,
      codeGuidelinesDetection: ListProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection,
      isRequired: 'boolean',
      sensitiveInfoDetection: ListProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProtectedBranchesResponseBodyResult extends $tea.Model {
  allowMergeRoles?: number[];
  allowMergeUserIds?: number[];
  allowMergeUsers?: ListProtectedBranchesResponseBodyResultAllowMergeUsers[];
  allowPushRoles?: number[];
  allowPushUserIds?: number[];
  allowPushUsers?: ListProtectedBranchesResponseBodyResultAllowPushUsers[];
  /**
   * @example
   * protectedBranch
   */
  branch?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  createdAt?: string;
  /**
   * @example
   * 19285
   */
  id?: number;
  matches?: string[];
  mergeRequestSetting?: ListProtectedBranchesResponseBodyResultMergeRequestSetting;
  testSettingDTO?: ListProtectedBranchesResponseBodyResultTestSettingDTO;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  updatedAt?: string;
  static names(): { [key: string]: string } {
    return {
      allowMergeRoles: 'allowMergeRoles',
      allowMergeUserIds: 'allowMergeUserIds',
      allowMergeUsers: 'allowMergeUsers',
      allowPushRoles: 'allowPushRoles',
      allowPushUserIds: 'allowPushUserIds',
      allowPushUsers: 'allowPushUsers',
      branch: 'branch',
      createdAt: 'createdAt',
      id: 'id',
      matches: 'matches',
      mergeRequestSetting: 'mergeRequestSetting',
      testSettingDTO: 'testSettingDTO',
      updatedAt: 'updatedAt',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowMergeRoles: { 'type': 'array', 'itemType': 'number' },
      allowMergeUserIds: { 'type': 'array', 'itemType': 'number' },
      allowMergeUsers: { 'type': 'array', 'itemType': ListProtectedBranchesResponseBodyResultAllowMergeUsers },
      allowPushRoles: { 'type': 'array', 'itemType': 'number' },
      allowPushUserIds: { 'type': 'array', 'itemType': 'number' },
      allowPushUsers: { 'type': 'array', 'itemType': ListProtectedBranchesResponseBodyResultAllowPushUsers },
      branch: 'string',
      createdAt: 'string',
      id: 'number',
      matches: { 'type': 'array', 'itemType': 'string' },
      mergeRequestSetting: ListProtectedBranchesResponseBodyResultMergeRequestSetting,
      testSettingDTO: ListProtectedBranchesResponseBodyResultTestSettingDTO,
      updatedAt: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPushRulesResponseBodyResultRuleInfos extends $tea.Model {
  /**
   * @example
   * CommitFilesChecker
   */
  checkerName?: string;
  /**
   * @example
   * warn
   */
  checkerType?: string;
  /**
   * @example
   * ""
   */
  extraMessage?: string;
  fileRuleRegexes?: string[];
  static names(): { [key: string]: string } {
    return {
      checkerName: 'checkerName',
      checkerType: 'checkerType',
      extraMessage: 'extraMessage',
      fileRuleRegexes: 'fileRuleRegexes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkerName: 'string',
      checkerType: 'string',
      extraMessage: 'string',
      fileRuleRegexes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPushRulesResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 2023-09-03T18:20:06+08:00
   */
  gmtCreate?: string;
  /**
   * @example
   * 2023-09-03T18:20:06+08:00
   */
  gmtModified?: string;
  /**
   * @example
   * 2077
   */
  id?: number;
  ruleInfos?: ListPushRulesResponseBodyResultRuleInfos[];
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      id: 'id',
      ruleInfos: 'ruleInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      ruleInfos: { 'type': 'array', 'itemType': ListPushRulesResponseBodyResultRuleInfos },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoriesResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 1
   */
  id?: number;
  /**
   * @example
   * 40
   */
  accessLevel?: number;
  /**
   * @example
   * false
   */
  archive?: boolean;
  avatarUrl?: string;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  createdAt?: string;
  description?: string;
  importStatus?: string;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  lastActivityAt?: string;
  /**
   * @example
   * codeupTest
   */
  name?: string;
  nameWithNamespace?: string;
  /**
   * @example
   * 745
   */
  namespaceId?: number;
  /**
   * @example
   * test-codeup
   */
  path?: string;
  /**
   * @example
   * codeup-test-org/test-codeup
   */
  pathWithNamespace?: string;
  /**
   * @example
   * false
   */
  star?: boolean;
  /**
   * @example
   * 0
   */
  starCount?: number;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  updatedAt?: string;
  /**
   * @example
   * 0
   */
  visibilityLevel?: string;
  /**
   * @example
   * ""
   */
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      accessLevel: 'accessLevel',
      archive: 'archive',
      avatarUrl: 'avatarUrl',
      createdAt: 'createdAt',
      description: 'description',
      importStatus: 'importStatus',
      lastActivityAt: 'lastActivityAt',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      namespaceId: 'namespaceId',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      star: 'star',
      starCount: 'starCount',
      updatedAt: 'updatedAt',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      accessLevel: 'number',
      archive: 'boolean',
      avatarUrl: 'string',
      createdAt: 'string',
      description: 'string',
      importStatus: 'string',
      lastActivityAt: 'string',
      name: 'string',
      nameWithNamespace: 'string',
      namespaceId: 'number',
      path: 'string',
      pathWithNamespace: 'string',
      star: 'boolean',
      starCount: 'number',
      updatedAt: 'string',
      visibilityLevel: 'string',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryBranchesResponseBodyResultCommit extends $tea.Model {
  /**
   * @example
   * username@example.com
   */
  authorEmail?: string;
  /**
   * @example
   * test-codeup
   */
  authorName?: string;
  /**
   * @example
   * 2022-03-18 10:00:00
   */
  authoredDate?: string;
  /**
   * @example
   * 2022-03-18 11:00:00
   */
  committedDate?: string;
  /**
   * @example
   * username@example.com
   */
  committerEmail?: string;
  /**
   * @example
   * commit-codeup
   */
  committerName?: string;
  /**
   * @example
   * 2022-03-18 10:00:00
   */
  createdAt?: string;
  /**
   * @example
   * de02b625ba8488f92eb204bcb3773a40c1b4ddac
   */
  id?: string;
  message?: string;
  parentIds?: string[];
  /**
   * @example
   * e0297d8f
   */
  shortId?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      authoredDate: 'authoredDate',
      committedDate: 'committedDate',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorEmail: 'string',
      authorName: 'string',
      authoredDate: 'string',
      committedDate: 'string',
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryBranchesResponseBodyResult extends $tea.Model {
  commit?: ListRepositoryBranchesResponseBodyResultCommit;
  /**
   * @example
   * testBranch
   */
  name?: string;
  /**
   * @example
   * false
   */
  protected?: string;
  static names(): { [key: string]: string } {
    return {
      commit: 'commit',
      name: 'name',
      protected: 'protected',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commit: ListRepositoryBranchesResponseBodyResultCommit,
      name: 'string',
      protected: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitDiffResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 100644
   */
  aMode?: string;
  /**
   * @example
   * 100755
   */
  bMode?: string;
  deletedFile?: boolean;
  /**
   * @example
   * --- /dev/null\\n+++ b/src/test/java/com/aliyun/codeupdemo/CodeupDemoApplicationTests.java\\n@@ -0,0 +1,13 @@\\n+package com.aliyun.codeupdemo;\\n+\\n+import org.junit.jupiter.api.Test;\\n+import org.springframework.boot.test.context.SpringBootTest;\\n+\\n+@SpringBootTest\\n+class CodeupDemoApplicationTest {\\n+\\n+ @Test\\n+ void contextLoads() {\\n+ }\\n+\\n+}\\n
   */
  diff?: string;
  isBinary?: boolean;
  isNewLfs?: boolean;
  isOldLfs?: boolean;
  newFile?: boolean;
  /**
   * @example
   * 6c268061a546378276559c713d0ad377d4xxxxxx
   */
  newId?: string;
  /**
   * @example
   * src/test/java/com/aliyun/codeupdemo/CodeupDemoApplicationTests.java
   */
  newPath?: string;
  /**
   * @example
   * 0000000000000000000000000000000000000000
   */
  oldId?: string;
  /**
   * @example
   * src/test/java/com/aliyun/codeupdemo/CodeupDemoApplicationTests.java
   */
  oldPath?: string;
  renamedFile?: boolean;
  static names(): { [key: string]: string } {
    return {
      aMode: 'aMode',
      bMode: 'bMode',
      deletedFile: 'deletedFile',
      diff: 'diff',
      isBinary: 'isBinary',
      isNewLfs: 'isNewLfs',
      isOldLfs: 'isOldLfs',
      newFile: 'newFile',
      newId: 'newId',
      newPath: 'newPath',
      oldId: 'oldId',
      oldPath: 'oldPath',
      renamedFile: 'renamedFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aMode: 'string',
      bMode: 'string',
      deletedFile: 'boolean',
      diff: 'string',
      isBinary: 'boolean',
      isNewLfs: 'boolean',
      isOldLfs: 'boolean',
      newFile: 'boolean',
      newId: 'string',
      newPath: 'string',
      oldId: 'string',
      oldPath: 'string',
      renamedFile: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitsResponseBodyResultAuthor extends $tea.Model {
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 7914
   */
  id?: number;
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * nickname
   */
  username?: string;
  /**
   * @example
   * ""
   */
  websiteUrl?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
      websiteUrl: 'websiteUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
      websiteUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitsResponseBodyResultCommitter extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 41031
   */
  id?: number;
  /**
   * @example
   * committer-codeup
   */
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * nickname
   */
  username?: string;
  /**
   * @example
   * ""
   */
  websiteUrl?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
      websiteUrl: 'websiteUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
      websiteUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitsResponseBodyResultSignature extends $tea.Model {
  /**
   * @example
   * ”“
   */
  gpgKeyId?: string;
  /**
   * @example
   * verified
   */
  verificationStatus?: string;
  static names(): { [key: string]: string } {
    return {
      gpgKeyId: 'gpgKeyId',
      verificationStatus: 'verificationStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gpgKeyId: 'string',
      verificationStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryCommitsResponseBodyResult extends $tea.Model {
  author?: ListRepositoryCommitsResponseBodyResultAuthor;
  /**
   * @example
   * username@example.com
   */
  authorEmail?: string;
  /**
   * @example
   * test-codeup
   */
  authorName?: string;
  /**
   * @example
   * 2022-03-18 15:00:00
   */
  authoredDate?: string;
  /**
   * @example
   * 1
   */
  commentsCount?: number;
  /**
   * @example
   * 2022-03-18 16:00:00
   */
  committedDate?: string;
  committer?: ListRepositoryCommitsResponseBodyResultCommitter;
  /**
   * @example
   * username@example.com
   */
  committerEmail?: string;
  /**
   * @example
   * committer-codeup
   */
  committerName?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  createdAt?: string;
  /**
   * @example
   * de02b625ba8488f92eb204bcb3773a40c1b4ddac
   */
  id?: string;
  message?: string;
  parentIds?: string[];
  /**
   * @example
   * de02b625
   */
  shortId?: string;
  signature?: ListRepositoryCommitsResponseBodyResultSignature;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      authoredDate: 'authoredDate',
      commentsCount: 'commentsCount',
      committedDate: 'committedDate',
      committer: 'committer',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      signature: 'signature',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: ListRepositoryCommitsResponseBodyResultAuthor,
      authorEmail: 'string',
      authorName: 'string',
      authoredDate: 'string',
      commentsCount: 'number',
      committedDate: 'string',
      committer: ListRepositoryCommitsResponseBodyResultCommitter,
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      signature: ListRepositoryCommitsResponseBodyResultSignature,
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryGroupsResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 40
   */
  accessLevel?: number;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  createdAt?: string;
  description?: string;
  /**
   * @example
   * 10
   */
  groupCount?: number;
  /**
   * @example
   * 19285
   */
  id?: number;
  /**
   * @example
   * test-codeup
   */
  name?: string;
  nameWithNamespace?: string;
  /**
   * @example
   * 19230
   */
  ownerId?: number;
  /**
   * @example
   * 26842
   */
  parentId?: number;
  /**
   * @example
   * test-codeup
   */
  path?: string;
  /**
   * @example
   * 60de7a6852743a5162b5f957/test-codeup
   */
  pathWithNamespace?: string;
  /**
   * @example
   * 10
   */
  projectCount?: number;
  /**
   * @example
   * Group
   */
  type?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  updatedAt?: string;
  /**
   * @example
   * 0
   */
  visibilityLevel?: number;
  /**
   * @example
   * ""
   */
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      avatarUrl: 'avatarUrl',
      createdAt: 'createdAt',
      description: 'description',
      groupCount: 'groupCount',
      id: 'id',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      ownerId: 'ownerId',
      parentId: 'parentId',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      projectCount: 'projectCount',
      type: 'type',
      updatedAt: 'updatedAt',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      avatarUrl: 'string',
      createdAt: 'string',
      description: 'string',
      groupCount: 'number',
      id: 'number',
      name: 'string',
      nameWithNamespace: 'string',
      ownerId: 'number',
      parentId: 'number',
      path: 'string',
      pathWithNamespace: 'string',
      projectCount: 'number',
      type: 'string',
      updatedAt: 'string',
      visibilityLevel: 'number',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryMemberWithInheritedResponseBodyResultInherited extends $tea.Model {
  /**
   * @remarks
   * id
   */
  id?: number;
  /**
   * @example
   * codeup
   */
  name?: string;
  nameWithNamespace?: string;
  /**
   * @example
   * codeup
   */
  path?: string;
  pathWithNamespace?: string;
  type?: string;
  /**
   * @example
   * 0
   */
  visibilityLevel?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      type: 'type',
      visibilityLevel: 'visibilityLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
      nameWithNamespace: 'string',
      path: 'string',
      pathWithNamespace: 'string',
      type: 'string',
      visibilityLevel: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryMemberWithInheritedResponseBodyResult extends $tea.Model {
  accessLevel?: number;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  email?: string;
  id?: number;
  inherited?: ListRepositoryMemberWithInheritedResponseBodyResultInherited;
  /**
   * @example
   * codeup
   */
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * yunxiao
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      inherited: 'inherited',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      inherited: ListRepositoryMemberWithInheritedResponseBodyResultInherited,
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryTagsResponseBodyResultCommitSignature extends $tea.Model {
  /**
   * @example
   * ""
   */
  gpgKeyId?: string;
  /**
   * @example
   * verified
   */
  verificationStatus?: string;
  static names(): { [key: string]: string } {
    return {
      gpgKeyId: 'gpgKeyId',
      verificationStatus: 'verificationStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gpgKeyId: 'string',
      verificationStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryTagsResponseBodyResultCommit extends $tea.Model {
  /**
   * @example
   * username@example.com
   */
  authorEmail?: string;
  authorName?: string;
  /**
   * @example
   * 2022-03-18 10:00:00
   */
  authoredDate?: string;
  /**
   * @example
   * 2022-03-18 09:00:00
   */
  committedDate?: string;
  /**
   * @example
   * username@example.com
   */
  committerEmail?: string;
  committerName?: string;
  /**
   * @example
   * 2022-03-18 10:00:00
   */
  createdAt?: string;
  /**
   * @example
   * de02b625ba8488f92eb204bcb3773a40c1b4ddac
   */
  id?: string;
  message?: string;
  parentIds?: string[];
  /**
   * @example
   * de02b625
   */
  shortId?: string;
  signature?: ListRepositoryTagsResponseBodyResultCommitSignature;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      authorEmail: 'authorEmail',
      authorName: 'authorName',
      authoredDate: 'authoredDate',
      committedDate: 'committedDate',
      committerEmail: 'committerEmail',
      committerName: 'committerName',
      createdAt: 'createdAt',
      id: 'id',
      message: 'message',
      parentIds: 'parentIds',
      shortId: 'shortId',
      signature: 'signature',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorEmail: 'string',
      authorName: 'string',
      authoredDate: 'string',
      committedDate: 'string',
      committerEmail: 'string',
      committerName: 'string',
      createdAt: 'string',
      id: 'string',
      message: 'string',
      parentIds: { 'type': 'array', 'itemType': 'string' },
      shortId: 'string',
      signature: ListRepositoryTagsResponseBodyResultCommitSignature,
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryTagsResponseBodyResult extends $tea.Model {
  commit?: ListRepositoryTagsResponseBodyResultCommit;
  /**
   * @example
   * 9a494e7b88ca35cde00579af2df4ab46136c022e
   */
  id?: string;
  message?: string;
  /**
   * @example
   * tag v1.0
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      commit: 'commit',
      id: 'id',
      message: 'message',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commit: ListRepositoryTagsResponseBodyResultCommit,
      id: 'string',
      message: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryTreeResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 76c3f251f414ac31f2e01faf6f2008a9d756a437
   */
  id?: string;
  /**
   * @example
   * false
   */
  isLFS?: boolean;
  /**
   * @example
   * 100644
   */
  mode?: string;
  /**
   * @example
   * test-codeup
   */
  name?: string;
  /**
   * @example
   * test-codeup
   */
  path?: string;
  /**
   * @example
   * blob
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      isLFS: 'isLFS',
      mode: 'mode',
      name: 'name',
      path: 'path',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      isLFS: 'boolean',
      mode: 'string',
      name: 'string',
      path: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRepositoryWebhookResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  createdAt?: string;
  description?: string;
  /**
   * @example
   * false
   */
  enableSslVerification?: boolean;
  /**
   * @example
   * 16776
   */
  id?: number;
  lastTestResult?: string;
  /**
   * @example
   * true
   */
  mergeRequestsEvents?: boolean;
  /**
   * @example
   * false
   */
  noteEvents?: boolean;
  projectId?: number;
  /**
   * @example
   * false
   */
  pushEvents?: boolean;
  /**
   * @example
   * xxxx
   */
  secretToken?: string;
  /**
   * @example
   * false
   */
  tagPushEvents?: boolean;
  /**
   * @example
   * https://xxxx
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      createdAt: 'createdAt',
      description: 'description',
      enableSslVerification: 'enableSslVerification',
      id: 'id',
      lastTestResult: 'lastTestResult',
      mergeRequestsEvents: 'mergeRequestsEvents',
      noteEvents: 'noteEvents',
      projectId: 'projectId',
      pushEvents: 'pushEvents',
      secretToken: 'secretToken',
      tagPushEvents: 'tagPushEvents',
      url: 'url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdAt: 'string',
      description: 'string',
      enableSslVerification: 'boolean',
      id: 'number',
      lastTestResult: 'string',
      mergeRequestsEvents: 'boolean',
      noteEvents: 'boolean',
      projectId: 'number',
      pushEvents: 'boolean',
      secretToken: 'string',
      tagPushEvents: 'boolean',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourceMembersResponseBodyResourceMembers extends $tea.Model {
  /**
   * @example
   * 22212212
   */
  accountId?: string;
  /**
   * @example
   * admin
   */
  roleName?: string;
  /**
   * @example
   * 张三
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
      roleName: 'roleName',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
      roleName: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchCommitRequestRepoPath extends $tea.Model {
  /**
   * @example
   * term
   */
  matchType?: string;
  /**
   * @example
   * equal
   */
  operatorType?: string;
  /**
   * @example
   * orgId/test-group/spring-boot-demo
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      matchType: 'matchType',
      operatorType: 'operatorType',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchType: 'string',
      operatorType: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchCommitResponseBodyResultHighlightTextMap extends $tea.Model {
  /**
   * @example
   * df1b701cb0f3f7ca92320d49d31995821f2d045c
   */
  commitId?: string;
  commitMessage?: string;
  /**
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      commitId: 'commitId',
      commitMessage: 'commitMessage',
      organizationId: 'organizationId',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commitId: 'string',
      commitMessage: 'string',
      organizationId: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchCommitResponseBodyResultSourceAuthor extends $tea.Model {
  /**
   * @example
   * username@example.com
   */
  email?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      email: 'email',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      email: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchCommitResponseBodyResultSource extends $tea.Model {
  author?: ListSearchCommitResponseBodyResultSourceAuthor;
  /**
   * @example
   * 2022-11-11 11:11:11
   */
  authorTime?: string;
  /**
   * @example
   * a748f5ecb17a93900d4808944bfcc96dc158ee2d
   */
  commitId?: string;
  commitMessage?: string;
  /**
   * @example
   * 61133b011bd96aa110f1b500
   */
  organizationId?: string;
  /**
   * @example
   * codeup/test-repo
   */
  repoPath?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      authorTime: 'authorTime',
      commitId: 'commitId',
      commitMessage: 'commitMessage',
      organizationId: 'organizationId',
      repoPath: 'repoPath',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: ListSearchCommitResponseBodyResultSourceAuthor,
      authorTime: 'string',
      commitId: 'string',
      commitMessage: 'string',
      organizationId: 'string',
      repoPath: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchCommitResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 60d54f3daccf2bbd6659f3ad/gitlabhq/master/config/environments/test.rb
   */
  docId?: string;
  highlightTextMap?: ListSearchCommitResponseBodyResultHighlightTextMap;
  source?: ListSearchCommitResponseBodyResultSource;
  static names(): { [key: string]: string } {
    return {
      docId: 'docId',
      highlightTextMap: 'highlightTextMap',
      source: 'source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      docId: 'string',
      highlightTextMap: ListSearchCommitResponseBodyResultHighlightTextMap,
      source: ListSearchCommitResponseBodyResultSource,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchRepositoryRequestRepoPath extends $tea.Model {
  /**
   * @example
   * term
   */
  matchType?: string;
  /**
   * @example
   * equal
   */
  operatorType?: string;
  /**
   * @example
   * orgId/test-group/spring-boot-demo
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      matchType: 'matchType',
      operatorType: 'operatorType',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchType: 'string',
      operatorType: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchRepositoryResponseBodyResultHighlightTextMap extends $tea.Model {
  /**
   * @example
   * xxx
   */
  creatorUserId?: string;
  description?: string;
  /**
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  /**
   * @example
   * xx
   */
  readMe?: string;
  /**
   * @example
   * codeup/test-repo
   */
  repoNameWithNamespace?: string;
  /**
   * @example
   * codeup/test-repo
   */
  repoPath?: string;
  static names(): { [key: string]: string } {
    return {
      creatorUserId: 'creatorUserId',
      description: 'description',
      organizationId: 'organizationId',
      readMe: 'readMe',
      repoNameWithNamespace: 'repoNameWithNamespace',
      repoPath: 'repoPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorUserId: 'string',
      description: 'string',
      organizationId: 'string',
      readMe: 'string',
      repoNameWithNamespace: 'string',
      repoPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchRepositoryResponseBodyResultSource extends $tea.Model {
  /**
   * @example
   * 2022-10-10 10:10:10
   */
  createTime?: string;
  description?: string;
  /**
   * @example
   * 2022-11-11 11:11:11
   */
  lastActivityTime?: string;
  /**
   * @example
   * 62a94a8611fc0f0c9e2a7bc1
   */
  organizationId?: string;
  /**
   * @example
   * xxx
   */
  readMe?: string;
  /**
   * @example
   * test-repo
   */
  repoName?: string;
  /**
   * @example
   * codeup/test-repo
   */
  repoPath?: string;
  /**
   * @example
   * 0
   */
  visibilityLevel?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'createTime',
      description: 'description',
      lastActivityTime: 'lastActivityTime',
      organizationId: 'organizationId',
      readMe: 'readMe',
      repoName: 'repoName',
      repoPath: 'repoPath',
      visibilityLevel: 'visibilityLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      description: 'string',
      lastActivityTime: 'string',
      organizationId: 'string',
      readMe: 'string',
      repoName: 'string',
      repoPath: 'string',
      visibilityLevel: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchRepositoryResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 60d54f3daccf2bbd6659f3ad/gitlabhq/master/config/environments/test.rb
   */
  docId?: string;
  highlightTextMap?: ListSearchRepositoryResponseBodyResultHighlightTextMap;
  source?: ListSearchRepositoryResponseBodyResultSource;
  static names(): { [key: string]: string } {
    return {
      docId: 'docId',
      highlightTextMap: 'highlightTextMap',
      source: 'source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      docId: 'string',
      highlightTextMap: ListSearchRepositoryResponseBodyResultHighlightTextMap,
      source: ListSearchRepositoryResponseBodyResultSource,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchSourceCodeRequestFilePath extends $tea.Model {
  /**
   * @example
   * term
   */
  matchType?: string;
  /**
   * @example
   * equal
   */
  operatorType?: string;
  /**
   * @example
   * orgId/test-group/spring-boot-demo/test.java
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      matchType: 'matchType',
      operatorType: 'operatorType',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchType: 'string',
      operatorType: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchSourceCodeRequestRepoPath extends $tea.Model {
  /**
   * @example
   * term
   */
  matchType?: string;
  /**
   * @example
   * equal
   */
  operatorType?: string;
  /**
   * @example
   * xxx
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      matchType: 'matchType',
      operatorType: 'operatorType',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchType: 'string',
      operatorType: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchSourceCodeResponseBodyResultHighlightTextMap extends $tea.Model {
  /**
   * @example
   * xxx
   */
  clob?: string;
  /**
   * @example
   * test.java
   */
  fileName?: string;
  /**
   * @example
   * java
   */
  language?: string;
  /**
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      clob: 'clob',
      fileName: 'fileName',
      language: 'language',
      organizationId: 'organizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clob: 'string',
      fileName: 'string',
      language: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchSourceCodeResponseBodyResultSource extends $tea.Model {
  /**
   * @example
   * master
   */
  branch?: string;
  /**
   * @example
   * 2022-10-10 10:00:00
   */
  checkinDate?: string;
  /**
   * @example
   * test_utils.js
   */
  fileName?: string;
  /**
   * @example
   * spec/frontend/snippets/test_utils.js
   */
  filePath?: string;
  /**
   * @example
   * JavaScript
   */
  language?: string;
  /**
   * @example
   * 60de7a6852743a5162b5f957
   */
  organizationId?: string;
  /**
   * @example
   * codeup/test-repo
   */
  repoPath?: string;
  static names(): { [key: string]: string } {
    return {
      branch: 'branch',
      checkinDate: 'checkinDate',
      fileName: 'fileName',
      filePath: 'filePath',
      language: 'language',
      organizationId: 'organizationId',
      repoPath: 'repoPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      branch: 'string',
      checkinDate: 'string',
      fileName: 'string',
      filePath: 'string',
      language: 'string',
      organizationId: 'string',
      repoPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSearchSourceCodeResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 60d54f3daccf2bbd6659f3ad/gitlabhq/master/spec/frontend/snippets/test_utils.js
   */
  docId?: string;
  highlightTextMap?: ListSearchSourceCodeResponseBodyResultHighlightTextMap;
  source?: ListSearchSourceCodeResponseBodyResultSource;
  static names(): { [key: string]: string } {
    return {
      docId: 'docId',
      highlightTextMap: 'highlightTextMap',
      source: 'source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      docId: 'string',
      highlightTextMap: ListSearchSourceCodeResponseBodyResultHighlightTextMap,
      source: ListSearchSourceCodeResponseBodyResultSource,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceAuthsResponseBodyServiceAuths extends $tea.Model {
  /**
   * @example
   * 123
   */
  id?: number;
  /**
   * @example
   * 张三
   */
  ownerName?: string;
  /**
   * @example
   * 123456789
   */
  ownerStaffId?: string;
  /**
   * @example
   * Codeup
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      ownerName: 'ownerName',
      ownerStaffId: 'ownerStaffId',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      ownerName: 'string',
      ownerStaffId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceConnectionsResponseBodyServiceConnections extends $tea.Model {
  /**
   * @example
   * 1586863220000
   */
  createTime?: number;
  /**
   * @example
   * 123
   */
  id?: number;
  /**
   * @example
   * 张三的oss服务连接
   */
  name?: string;
  /**
   * @example
   * 1212123212121212
   */
  ownerAccountId?: number;
  /**
   * @example
   * oss
   */
  type?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'createTime',
      id: 'id',
      name: 'name',
      ownerAccountId: 'ownerAccountId',
      type: 'type',
      uuid: 'uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      id: 'number',
      name: 'string',
      ownerAccountId: 'number',
      type: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceCredentialsResponseBodyServiceCredentials extends $tea.Model {
  /**
   * @example
   * 123
   */
  id?: number;
  /**
   * @example
   * 张三
   */
  ownerName?: string;
  /**
   * @example
   * 123456789
   */
  ownerStaffId?: string;
  /**
   * @example
   * Codeup
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      ownerName: 'ownerName',
      ownerStaffId: 'ownerStaffId',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      ownerName: 'string',
      ownerStaffId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSprintsResponseBodySprints extends $tea.Model {
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  creator?: string;
  /**
   * @example
   * xxx
   */
  description?: string;
  /**
   * @example
   * 1623916393000
   */
  endDate?: number;
  /**
   * @example
   * 1623916393000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1623916393000
   */
  gmtModified?: number;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  identifier?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  modifier?: string;
  /**
   * @example
   * demo示例项目
   */
  name?: string;
  /**
   * @example
   * public
   */
  scope?: string;
  /**
   * @example
   * 5e70xxxxxxcd000xxxxe96
   */
  spaceIdentifier?: string;
  /**
   * @example
   * 1638403200000
   */
  startDate?: number;
  /**
   * @example
   * TODO
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      creator: 'creator',
      description: 'description',
      endDate: 'endDate',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      modifier: 'modifier',
      name: 'name',
      scope: 'scope',
      spaceIdentifier: 'spaceIdentifier',
      startDate: 'startDate',
      status: 'status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creator: 'string',
      description: 'string',
      endDate: 'number',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      modifier: 'string',
      name: 'string',
      scope: 'string',
      spaceIdentifier: 'string',
      startDate: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTestCaseFieldsResponseBodyFieldsOptions extends $tea.Model {
  /**
   * @example
   * 重复的缺陷
   */
  displayValue?: string;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  fieldIdentifier?: string;
  /**
   * @example
   * 重复的缺陷
   */
  identifier?: string;
  /**
   * @example
   * 1
   */
  level?: number;
  /**
   * @example
   * null
   */
  position?: number;
  /**
   * @example
   * 重复的缺陷
   */
  value?: string;
  /**
   * @example
   * null
   */
  valueEn?: string;
  static names(): { [key: string]: string } {
    return {
      displayValue: 'displayValue',
      fieldIdentifier: 'fieldIdentifier',
      identifier: 'identifier',
      level: 'level',
      position: 'position',
      value: 'value',
      valueEn: 'valueEn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayValue: 'string',
      fieldIdentifier: 'string',
      identifier: 'string',
      level: 'number',
      position: 'number',
      value: 'string',
      valueEn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTestCaseFieldsResponseBodyFields extends $tea.Model {
  /**
   * @example
   * 例：date
   */
  className?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  creator?: string;
  /**
   * @example
   * 123
   */
  defaultValue?: string;
  /**
   * @example
   * 字段的具体信息
   */
  description?: string;
  /**
   * @example
   * list
   */
  format?: string;
  /**
   * @example
   * 1623916393000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1623916393000
   */
  gmtModified?: number;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  identifier?: string;
  /**
   * @example
   * false
   */
  isRequired?: boolean;
  /**
   * @example
   * false
   */
  isShowWhenCreate?: boolean;
  /**
   * @example
   * false
   */
  isSystemRequired?: boolean;
  /**
   * @example
   * null
   */
  linkWithService?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  modifier?: string;
  /**
   * @example
   * 负责人
   */
  name?: string;
  options?: ListTestCaseFieldsResponseBodyFieldsOptions[];
  /**
   * @example
   * 例：Workitem
   */
  resourceType?: string;
  /**
   * @example
   * NativeField
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      className: 'className',
      creator: 'creator',
      defaultValue: 'defaultValue',
      description: 'description',
      format: 'format',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      isRequired: 'isRequired',
      isShowWhenCreate: 'isShowWhenCreate',
      isSystemRequired: 'isSystemRequired',
      linkWithService: 'linkWithService',
      modifier: 'modifier',
      name: 'name',
      options: 'options',
      resourceType: 'resourceType',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      className: 'string',
      creator: 'string',
      defaultValue: 'string',
      description: 'string',
      format: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      isRequired: 'boolean',
      isShowWhenCreate: 'boolean',
      isSystemRequired: 'boolean',
      linkWithService: 'string',
      modifier: 'string',
      name: 'string',
      options: { 'type': 'array', 'itemType': ListTestCaseFieldsResponseBodyFieldsOptions },
      resourceType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserDrawRecordByPkResponseBodyData extends $tea.Model {
  /**
   * @example
   * 1401072305438324
   */
  aliyunPk?: string;
  /**
   * @example
   * dsadsadsadas
   */
  drawGroup?: string;
  /**
   * @example
   * dasdsadasdas
   */
  drawPoolName?: string;
  /**
   * @example
   * 2
   */
  drawResult?: string;
  /**
   * @example
   * 1545726028000
   */
  gmtCreate?: string;
  /**
   * @example
   * null
   */
  taskGroupId?: string;
  /**
   * @example
   * dsadsadasd
   */
  uccId?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunPk: 'aliyunPk',
      drawGroup: 'drawGroup',
      drawPoolName: 'drawPoolName',
      drawResult: 'drawResult',
      gmtCreate: 'gmtCreate',
      taskGroupId: 'taskGroupId',
      uccId: 'uccId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunPk: 'string',
      drawGroup: 'string',
      drawPoolName: 'string',
      drawResult: 'string',
      gmtCreate: 'string',
      taskGroupId: 'string',
      uccId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserKeysResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  createdAt?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  expireTime?: string;
  /**
   * @example
   * xxx
   */
  fingerPrint?: string;
  /**
   * @example
   * 5240
   */
  id?: number;
  /**
   * @example
   * ALL
   */
  keyScope?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  lastUsedTime?: string;
  /**
   * @example
   * xxx
   */
  publicKey?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      createdAt: 'createdAt',
      expireTime: 'expireTime',
      fingerPrint: 'fingerPrint',
      id: 'id',
      keyScope: 'keyScope',
      lastUsedTime: 'lastUsedTime',
      publicKey: 'publicKey',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdAt: 'string',
      expireTime: 'string',
      fingerPrint: 'string',
      id: 'number',
      keyScope: 'string',
      lastUsedTime: 'string',
      publicKey: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesResponseBodyResultGroupInfosGroupInfo extends $tea.Model {
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  createdAt?: string;
  /**
   * @example
   * test-group
   */
  description?: string;
  /**
   * @example
   * 35268
   */
  id?: number;
  /**
   * @example
   * test-group
   */
  name?: string;
  nameWithNamespace?: string;
  /**
   * @example
   * 1234
   */
  ownerId?: number;
  /**
   * @example
   * 1183319
   */
  parentId?: number;
  /**
   * @example
   * test-group
   */
  path?: string;
  /**
   * @example
   * test-org/test-group
   */
  pathWithNamespace?: string;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  updatedAt?: string;
  /**
   * @example
   * 0
   */
  visibilityLevel?: number;
  static names(): { [key: string]: string } {
    return {
      createdAt: 'createdAt',
      description: 'description',
      id: 'id',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      ownerId: 'ownerId',
      parentId: 'parentId',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      updatedAt: 'updatedAt',
      visibilityLevel: 'visibilityLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdAt: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
      nameWithNamespace: 'string',
      ownerId: 'number',
      parentId: 'number',
      path: 'string',
      pathWithNamespace: 'string',
      updatedAt: 'string',
      visibilityLevel: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesResponseBodyResultGroupInfosGroupRole extends $tea.Model {
  /**
   * @example
   * 40
   */
  accessLevel?: number;
  cnRoleName?: string;
  /**
   * @example
   * Admin
   */
  enRoleName?: string;
  /**
   * @example
   * 35268
   */
  sourceId?: number;
  /**
   * @example
   * Namespace
   */
  sourceType?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      cnRoleName: 'cnRoleName',
      enRoleName: 'enRoleName',
      sourceId: 'sourceId',
      sourceType: 'sourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      cnRoleName: 'string',
      enRoleName: 'string',
      sourceId: 'number',
      sourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesResponseBodyResultGroupInfos extends $tea.Model {
  groupInfo?: ListUserResourcesResponseBodyResultGroupInfosGroupInfo;
  groupRole?: ListUserResourcesResponseBodyResultGroupInfosGroupRole;
  static names(): { [key: string]: string } {
    return {
      groupInfo: 'groupInfo',
      groupRole: 'groupRole',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupInfo: ListUserResourcesResponseBodyResultGroupInfosGroupInfo,
      groupRole: ListUserResourcesResponseBodyResultGroupInfosGroupRole,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesResponseBodyResultRepositoryInfosRepositoryInfo extends $tea.Model {
  /**
   * @example
   * 40
   */
  accessLevel?: number;
  /**
   * @example
   * false
   */
  archived?: boolean;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  createdAt?: string;
  /**
   * @example
   * 12679
   */
  creatorId?: number;
  description?: string;
  /**
   * @example
   * false
   */
  encrypted?: boolean;
  /**
   * @example
   * 37229
   */
  id?: number;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  lastActivityAt?: string;
  /**
   * @example
   * test-repo
   */
  name?: string;
  nameWithNamespace?: string;
  /**
   * @example
   * 600002
   */
  namespaceId?: number;
  /**
   * @example
   * test-repo
   */
  path?: string;
  /**
   * @example
   * test-org/test-group/test-repo
   */
  pathWithNamespace?: string;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  updatedAt?: string;
  /**
   * @example
   * 0
   */
  visibilityLevel?: number;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      archived: 'archived',
      createdAt: 'createdAt',
      creatorId: 'creatorId',
      description: 'description',
      encrypted: 'encrypted',
      id: 'id',
      lastActivityAt: 'lastActivityAt',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      namespaceId: 'namespaceId',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      updatedAt: 'updatedAt',
      visibilityLevel: 'visibilityLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      archived: 'boolean',
      createdAt: 'string',
      creatorId: 'number',
      description: 'string',
      encrypted: 'boolean',
      id: 'number',
      lastActivityAt: 'string',
      name: 'string',
      nameWithNamespace: 'string',
      namespaceId: 'number',
      path: 'string',
      pathWithNamespace: 'string',
      updatedAt: 'string',
      visibilityLevel: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesResponseBodyResultRepositoryInfosRepositoryRole extends $tea.Model {
  /**
   * @example
   * 40
   */
  accessLevel?: number;
  cnRoleName?: string;
  /**
   * @example
   * Admin
   */
  enRoleName?: string;
  /**
   * @example
   * 37229
   */
  sourceId?: number;
  /**
   * @example
   * Project
   */
  sourceType?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      cnRoleName: 'cnRoleName',
      enRoleName: 'enRoleName',
      sourceId: 'sourceId',
      sourceType: 'sourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      cnRoleName: 'string',
      enRoleName: 'string',
      sourceId: 'number',
      sourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesResponseBodyResultRepositoryInfos extends $tea.Model {
  repositoryInfo?: ListUserResourcesResponseBodyResultRepositoryInfosRepositoryInfo;
  repositoryRole?: ListUserResourcesResponseBodyResultRepositoryInfosRepositoryRole;
  static names(): { [key: string]: string } {
    return {
      repositoryInfo: 'repositoryInfo',
      repositoryRole: 'repositoryRole',
    };
  }

  static types(): { [key: string]: any } {
    return {
      repositoryInfo: ListUserResourcesResponseBodyResultRepositoryInfosRepositoryInfo,
      repositoryRole: ListUserResourcesResponseBodyResultRepositoryInfosRepositoryRole,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesResponseBodyResultUserInfo extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 19230
   */
  id?: number;
  /**
   * @example
   * test-codeup
   */
  name?: string;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * test-codeup
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      name: 'name',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      name: 'string',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserResourcesResponseBodyResult extends $tea.Model {
  groupInfos?: ListUserResourcesResponseBodyResultGroupInfos[];
  repositoryInfos?: ListUserResourcesResponseBodyResultRepositoryInfos[];
  userInfo?: ListUserResourcesResponseBodyResultUserInfo;
  static names(): { [key: string]: string } {
    return {
      groupInfos: 'groupInfos',
      repositoryInfos: 'repositoryInfos',
      userInfo: 'userInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupInfos: { 'type': 'array', 'itemType': ListUserResourcesResponseBodyResultGroupInfos },
      repositoryInfos: { 'type': 'array', 'itemType': ListUserResourcesResponseBodyResultRepositoryInfos },
      userInfo: ListUserResourcesResponseBodyResultUserInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVariableGroupsResponseBodyVariableGroupsRelatedPipelines extends $tea.Model {
  /**
   * @example
   * 1234
   */
  id?: number;
  /**
   * @example
   * 流水线
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVariableGroupsResponseBodyVariableGroupsVariables extends $tea.Model {
  /**
   * @example
   * true
   */
  isEncrypted?: boolean;
  /**
   * @example
   * name1
   */
  name?: string;
  /**
   * @example
   * value1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      isEncrypted: 'isEncrypted',
      name: 'name',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isEncrypted: 'boolean',
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVariableGroupsResponseBodyVariableGroups extends $tea.Model {
  /**
   * @example
   * 1586863220000
   */
  createTime?: number;
  /**
   * @example
   * 13232343434343
   */
  creatorAccountId?: string;
  /**
   * @example
   * 变量组
   */
  description?: string;
  /**
   * @example
   * 12234
   */
  id?: number;
  /**
   * @example
   * 13232343434343
   */
  modifierAccountId?: string;
  /**
   * @example
   * 变量组
   */
  name?: string;
  relatedPipelines?: ListVariableGroupsResponseBodyVariableGroupsRelatedPipelines[];
  /**
   * @example
   * 1586863220000
   */
  updateTime?: number;
  variables?: ListVariableGroupsResponseBodyVariableGroupsVariables[];
  static names(): { [key: string]: string } {
    return {
      createTime: 'createTime',
      creatorAccountId: 'creatorAccountId',
      description: 'description',
      id: 'id',
      modifierAccountId: 'modifierAccountId',
      name: 'name',
      relatedPipelines: 'relatedPipelines',
      updateTime: 'updateTime',
      variables: 'variables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      creatorAccountId: 'string',
      description: 'string',
      id: 'number',
      modifierAccountId: 'string',
      name: 'string',
      relatedPipelines: { 'type': 'array', 'itemType': ListVariableGroupsResponseBodyVariableGroupsRelatedPipelines },
      updateTime: 'number',
      variables: { 'type': 'array', 'itemType': ListVariableGroupsResponseBodyVariableGroupsVariables },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkItemAllFieldsResponseBodyFieldsOptions extends $tea.Model {
  /**
   * @example
   * 重复的缺陷
   */
  displayValue?: string;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  fieldIdentifier?: string;
  /**
   * @example
   * 重复的缺陷
   */
  identifier?: string;
  /**
   * @example
   * 1
   */
  level?: number;
  /**
   * @example
   * 1
   */
  position?: number;
  /**
   * @example
   * 重复的缺陷
   */
  value?: string;
  /**
   * @example
   * null
   */
  valueEn?: string;
  static names(): { [key: string]: string } {
    return {
      displayValue: 'displayValue',
      fieldIdentifier: 'fieldIdentifier',
      identifier: 'identifier',
      level: 'level',
      position: 'position',
      value: 'value',
      valueEn: 'valueEn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayValue: 'string',
      fieldIdentifier: 'string',
      identifier: 'string',
      level: 'number',
      position: 'number',
      value: 'string',
      valueEn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkItemAllFieldsResponseBodyFields extends $tea.Model {
  /**
   * @example
   * 例：date
   */
  className?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  creator?: string;
  /**
   * @example
   * 123
   */
  defaultValue?: string;
  /**
   * @example
   * 字段的具体信息
   */
  description?: string;
  /**
   * @example
   * list
   */
  format?: string;
  /**
   * @example
   * 1623916393000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1623916393000
   */
  gmtModified?: number;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  identifier?: string;
  /**
   * @example
   * false
   */
  isRequired?: boolean;
  /**
   * @example
   * false
   */
  isShowWhenCreate?: boolean;
  /**
   * @example
   * false
   */
  isSystemRequired?: boolean;
  /**
   * @example
   * null
   */
  linkWithService?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  modifier?: string;
  /**
   * @example
   * 负责人
   */
  name?: string;
  options?: ListWorkItemAllFieldsResponseBodyFieldsOptions[];
  /**
   * @example
   * 例：Workitem
   */
  resourceType?: string;
  /**
   * @example
   * NativeField
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      className: 'className',
      creator: 'creator',
      defaultValue: 'defaultValue',
      description: 'description',
      format: 'format',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      isRequired: 'isRequired',
      isShowWhenCreate: 'isShowWhenCreate',
      isSystemRequired: 'isSystemRequired',
      linkWithService: 'linkWithService',
      modifier: 'modifier',
      name: 'name',
      options: 'options',
      resourceType: 'resourceType',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      className: 'string',
      creator: 'string',
      defaultValue: 'string',
      description: 'string',
      format: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      isRequired: 'boolean',
      isShowWhenCreate: 'boolean',
      isSystemRequired: 'boolean',
      linkWithService: 'string',
      modifier: 'string',
      name: 'string',
      options: { 'type': 'array', 'itemType': ListWorkItemAllFieldsResponseBodyFieldsOptions },
      resourceType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkItemWorkFlowStatusResponseBodyStatuses extends $tea.Model {
  /**
   * @example
   * 用户阿里云pk，例如19xxxx31947xxxx
   */
  creator?: string;
  /**
   * @example
   * 该状态的具体信息
   */
  description?: string;
  /**
   * @example
   * 1620455467000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1641870287000
   */
  gmtModified?: number;
  /**
   * @example
   * dfexxxxxf4fee18xxxxx36
   */
  identifier?: string;
  /**
   * @example
   * 用户阿里云pk，例如19xxxx31947xxxx
   */
  modifier?: string;
  /**
   * @example
   * 例：待处理
   */
  name?: string;
  /**
   * @example
   * Workitem
   */
  resourceType?: string;
  /**
   * @example
   * system
   */
  source?: string;
  /**
   * @example
   * 例如：1
   */
  workflowStageIdentifier?: string;
  /**
   * @example
   * 例：确认阶段
   */
  workflowStageName?: string;
  static names(): { [key: string]: string } {
    return {
      creator: 'creator',
      description: 'description',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      modifier: 'modifier',
      name: 'name',
      resourceType: 'resourceType',
      source: 'source',
      workflowStageIdentifier: 'workflowStageIdentifier',
      workflowStageName: 'workflowStageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creator: 'string',
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      modifier: 'string',
      name: 'string',
      resourceType: 'string',
      source: 'string',
      workflowStageIdentifier: 'string',
      workflowStageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemAttachmentsResponseBodyAttachments extends $tea.Model {
  /**
   * @example
   * 237109
   */
  creator?: string;
  /**
   * @example
   * dflkjlsdddsdl234lkjfg
   */
  fileIdentifier?: string;
  /**
   * @example
   * Artifacts_1565193_1.tgz
   */
  fileName?: string;
  /**
   * @example
   * tgz
   */
  fileSuffix?: string;
  /**
   * @example
   * 1545726028000
   */
  gmtCreate?: number;
  /**
   * @example
   * 50
   */
  size?: string;
  /**
   * @example
   * http://grace-share.oss-cn-hangzhou.aliyuncs.com/qf%2Fheap.bin?Expires=1675750082&OSSAccessKeyId=LTAI5t8irN2Wu3BGrBpffZue&Signature=RqRUEuHiwW8wuahYz6CenHaWWs4%3D
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      creator: 'creator',
      fileIdentifier: 'fileIdentifier',
      fileName: 'fileName',
      fileSuffix: 'fileSuffix',
      gmtCreate: 'gmtCreate',
      size: 'size',
      url: 'url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creator: 'string',
      fileIdentifier: 'string',
      fileName: 'string',
      fileSuffix: 'string',
      gmtCreate: 'number',
      size: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser extends $tea.Model {
  /**
   * @example
   * 132xxxx123
   */
  identifier?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'identifier',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemEstimateResponseBodyWorkitemTimeEstimate extends $tea.Model {
  /**
   * @example
   * 开发代码等
   */
  description?: string;
  /**
   * @example
   * 1653235200000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1653235200000
   */
  gmtEnd?: number;
  /**
   * @example
   * 1653235200000
   */
  gmtModified?: number;
  /**
   * @example
   * 1653235200000
   */
  gmtStart?: number;
  /**
   * @example
   * a4ac3a81e90217db32b7......
   */
  identifier?: string;
  recordUser?: ListWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser;
  /**
   * @example
   * 8
   */
  spentTime?: number;
  /**
   * @example
   * 研发
   */
  type?: string;
  /**
   * @example
   * 5daa9a15c7fd55523996......
   */
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'description',
      gmtCreate: 'gmtCreate',
      gmtEnd: 'gmtEnd',
      gmtModified: 'gmtModified',
      gmtStart: 'gmtStart',
      identifier: 'identifier',
      recordUser: 'recordUser',
      spentTime: 'spentTime',
      type: 'type',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      gmtCreate: 'number',
      gmtEnd: 'number',
      gmtModified: 'number',
      gmtStart: 'number',
      identifier: 'string',
      recordUser: ListWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser,
      spentTime: 'number',
      type: 'string',
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemTimeResponseBodyWorkitemTime extends $tea.Model {
  /**
   * @example
   * 1
   */
  actualTime?: number;
  /**
   * @example
   * 开发代码等
   */
  description?: string;
  /**
   * @example
   * 1653235200000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1653235200000
   */
  gmtEnd?: number;
  /**
   * @example
   * 1653235200000
   */
  gmtModified?: number;
  /**
   * @example
   * 1653235200000
   */
  gmtStart?: number;
  /**
   * @example
   * a4ac3a81e90217db32b7......
   */
  identifier?: string;
  /**
   * @example
   * 1967043931......
   */
  recordUser?: string;
  /**
   * @example
   * 研发
   */
  type?: string;
  /**
   * @example
   * 5daa9a15c7fd55523996......
   */
  workitemIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      actualTime: 'actualTime',
      description: 'description',
      gmtCreate: 'gmtCreate',
      gmtEnd: 'gmtEnd',
      gmtModified: 'gmtModified',
      gmtStart: 'gmtStart',
      identifier: 'identifier',
      recordUser: 'recordUser',
      type: 'type',
      workitemIdentifier: 'workitemIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualTime: 'number',
      description: 'string',
      gmtCreate: 'number',
      gmtEnd: 'number',
      gmtModified: 'number',
      gmtStart: 'number',
      identifier: 'string',
      recordUser: 'string',
      type: 'string',
      workitemIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkitemsResponseBodyWorkitems extends $tea.Model {
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  assignedTo?: string;
  /**
   * @example
   * Req
   */
  categoryIdentifier?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  creator?: string;
  /**
   * @example
   * html格式
   */
  document?: string;
  finishTime?: number;
  /**
   * @example
   * 1640850318000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1640850318000
   */
  gmtModified?: number;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  identifier?: string;
  /**
   * @example
   * NORMAL
   */
  logicalStatus?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  modifier?: string;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx24
   */
  parentIdentifier?: string;
  /**
   * @example
   * ABCD-1
   */
  serialNumber?: string;
  /**
   * @example
   * e8b26xxxxx6e76aa20xxxxx23
   */
  spaceIdentifier?: string;
  /**
   * @example
   * 需求项目
   */
  spaceName?: string;
  /**
   * @example
   * Project
   */
  spaceType?: string;
  /**
   * @example
   * 75528f17703e92e5a568......
   */
  sprintIdentifier?: string;
  /**
   * @example
   * 待处理
   */
  status?: string;
  /**
   * @example
   * 100005
   */
  statusIdentifier?: string;
  /**
   * @example
   * 1
   */
  statusStageIdentifier?: string;
  /**
   * @example
   * 测试工作项
   */
  subject?: string;
  /**
   * @example
   * 1640850328000
   */
  updateStatusAt?: number;
  /**
   * @example
   * 9uxxxxxxre573f5xxxxxx0
   */
  workitemTypeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      document: 'document',
      finishTime: 'finishTime',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      logicalStatus: 'logicalStatus',
      modifier: 'modifier',
      parentIdentifier: 'parentIdentifier',
      serialNumber: 'serialNumber',
      spaceIdentifier: 'spaceIdentifier',
      spaceName: 'spaceName',
      spaceType: 'spaceType',
      sprintIdentifier: 'sprintIdentifier',
      status: 'status',
      statusIdentifier: 'statusIdentifier',
      statusStageIdentifier: 'statusStageIdentifier',
      subject: 'subject',
      updateStatusAt: 'updateStatusAt',
      workitemTypeIdentifier: 'workitemTypeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: 'string',
      categoryIdentifier: 'string',
      creator: 'string',
      document: 'string',
      finishTime: 'number',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      logicalStatus: 'string',
      modifier: 'string',
      parentIdentifier: 'string',
      serialNumber: 'string',
      spaceIdentifier: 'string',
      spaceName: 'string',
      spaceType: 'string',
      sprintIdentifier: 'string',
      status: 'string',
      statusIdentifier: 'string',
      statusStageIdentifier: 'string',
      subject: 'string',
      updateStatusAt: 'number',
      workitemTypeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkspacesResponseBodyWorkspaces extends $tea.Model {
  /**
   * @example
   * https://codeup.aliyun.com/demo/group/Codeup-Demo.git
   */
  codeUrl?: string;
  /**
   * @example
   * master
   */
  codeVersion?: string;
  /**
   * @example
   * 1628564442000
   */
  createTime?: string;
  /**
   * @example
   * 6ed82817-ab75-4563-865d-81e60dxxxxxx
   */
  id?: string;
  /**
   * @example
   * Demo
   */
  name?: string;
  /**
   * @example
   * 2::4::60
   */
  spec?: string;
  /**
   * @example
   * SUCCESS
   */
  status?: string;
  /**
   * @example
   * all-in-one
   */
  template?: string;
  /**
   * @example
   * 1470227819xxxxxx
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      codeUrl: 'codeUrl',
      codeVersion: 'codeVersion',
      createTime: 'createTime',
      id: 'id',
      name: 'name',
      spec: 'spec',
      status: 'status',
      template: 'template',
      userId: 'userId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeUrl: 'string',
      codeVersion: 'string',
      createTime: 'string',
      id: 'string',
      name: 'string',
      spec: 'string',
      status: 'string',
      template: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LogPipelineJobRunResponseBodyLog extends $tea.Model {
  /**
   * @example
   * success
   */
  content?: string;
  /**
   * @example
   * true
   */
  more?: boolean;
  static names(): { [key: string]: string } {
    return {
      content: 'content',
      more: 'more',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      more: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LogVMDeployMachineResponseBodyDeployMachineLog extends $tea.Model {
  /**
   * @example
   * cn-hangzhou
   */
  aliyunRegion?: string;
  /**
   * @example
   * 11111111111
   */
  deployBeginTime?: number;
  /**
   * @example
   * 12222222
   */
  deployEndTime?: number;
  /**
   * @example
   * success
   */
  deployLog?: string;
  /**
   * @example
   * /tmp/log
   */
  deployLogPath?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunRegion: 'aliyunRegion',
      deployBeginTime: 'deployBeginTime',
      deployEndTime: 'deployEndTime',
      deployLog: 'deployLog',
      deployLogPath: 'deployLogPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunRegion: 'string',
      deployBeginTime: 'number',
      deployEndTime: 'number',
      deployLog: 'string',
      deployLogPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MergeMergeRequestResponseBodyResult extends $tea.Model {
  bizId?: string;
  localId?: number;
  mergedRevision?: string;
  projectId?: number;
  /**
   * @example
   * true
   */
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      bizId: 'bizId',
      localId: 'localId',
      mergedRevision: 'mergedRevision',
      projectId: 'projectId',
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizId: 'string',
      localId: 'number',
      mergedRevision: 'string',
      projectId: 'number',
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReopenMergeRequestResponseBodyResult extends $tea.Model {
  /**
   * @example
   * true
   */
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetSshKeyResponseBodySshKey extends $tea.Model {
  /**
   * @example
   * 1212
   */
  id?: number;
  /**
   * @example
   * saaaaaaaaaaaaaaaa
   */
  publicKey?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      publicKey: 'publicKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      publicKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReviewMergeRequestResponseBodyResult extends $tea.Model {
  /**
   * @example
   * true
   */
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TransferRepositoryResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 30
   */
  accessLevel?: number;
  /**
   * @example
   * false
   */
  archived?: boolean;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  createdAt?: string;
  /**
   * @example
   * 19238
   */
  creatorId?: number;
  /**
   * @example
   * false
   */
  demoProject?: boolean;
  description?: string;
  /**
   * @example
   * false
   */
  encrypted?: boolean;
  /**
   * @example
   * 19285
   */
  id?: number;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  lastActivityAt?: string;
  /**
   * @example
   * test-repo
   */
  name?: string;
  nameWithNamespace?: string;
  /**
   * @example
   * 100003
   */
  namespaceId?: number;
  /**
   * @example
   * test-repo
   */
  path?: string;
  /**
   * @example
   * codeup-test-org/test-create-codeup
   */
  pathWithNamespace?: string;
  /**
   * @example
   * 0
   */
  starCount?: number;
  /**
   * @example
   * true
   */
  starred?: boolean;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  updatedAt?: string;
  /**
   * @example
   * 0
   */
  visibilityLevel?: number;
  /**
   * @example
   * ""
   */
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      archived: 'archived',
      createdAt: 'createdAt',
      creatorId: 'creatorId',
      demoProject: 'demoProject',
      description: 'description',
      encrypted: 'encrypted',
      id: 'id',
      lastActivityAt: 'lastActivityAt',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      namespaceId: 'namespaceId',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      starCount: 'starCount',
      starred: 'starred',
      updatedAt: 'updatedAt',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      archived: 'boolean',
      createdAt: 'string',
      creatorId: 'number',
      demoProject: 'boolean',
      description: 'string',
      encrypted: 'boolean',
      id: 'number',
      lastActivityAt: 'string',
      name: 'string',
      nameWithNamespace: 'string',
      namespaceId: 'number',
      path: 'string',
      pathWithNamespace: 'string',
      starCount: 'number',
      starred: 'boolean',
      updatedAt: 'string',
      visibilityLevel: 'number',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TriggerRepositoryMirrorSyncResponseBodyResult extends $tea.Model {
  /**
   * @example
   * true
   */
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAppMemberRequestPlayer extends $tea.Model {
  /**
   * @example
   * 1332695887xxxxxx
   */
  id?: string;
  /**
   * @example
   * User
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunRequestAnnotations extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * failure
   */
  annotationLevel?: string;
  /**
   * @example
   * 5
   */
  endColumn?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2
   */
  endLine?: number;
  /**
   * @remarks
   * This parameter is required.
   */
  message?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * demo/test.txt
   */
  path?: string;
  rawDetails?: string;
  /**
   * @example
   * 3
   */
  startColumn?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1
   */
  startLine?: number;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      annotationLevel: 'annotationLevel',
      endColumn: 'endColumn',
      endLine: 'endLine',
      message: 'message',
      path: 'path',
      rawDetails: 'rawDetails',
      startColumn: 'startColumn',
      startLine: 'startLine',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotationLevel: 'string',
      endColumn: 'number',
      endLine: 'number',
      message: 'string',
      path: 'string',
      rawDetails: 'string',
      startColumn: 'number',
      startLine: 'number',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunRequestOutputImages extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test-image-alt
   */
  alt?: string;
  /**
   * @example
   * test
   */
  caption?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * xxx
   */
  imageUrl?: string;
  static names(): { [key: string]: string } {
    return {
      alt: 'alt',
      caption: 'caption',
      imageUrl: 'imageUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alt: 'string',
      caption: 'string',
      imageUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunRequestOutput extends $tea.Model {
  images?: UpdateCheckRunRequestOutputImages[];
  /**
   * @remarks
   * This parameter is required.
   */
  summary?: string;
  text?: string;
  /**
   * @example
   * Mighty Readme report
   */
  title?: string;
  static names(): { [key: string]: string } {
    return {
      images: 'images',
      summary: 'summary',
      text: 'text',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      images: { 'type': 'array', 'itemType': UpdateCheckRunRequestOutputImages },
      summary: 'string',
      text: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunResponseBodyResultAnnotations extends $tea.Model {
  /**
   * @example
   * warning
   */
  annotationLevel?: string;
  /**
   * @example
   * 5
   */
  endColumn?: number;
  /**
   * @example
   * 2
   */
  endLine?: number;
  /**
   * @example
   * 1
   */
  id?: number;
  message?: string;
  /**
   * @example
   * demo/test.txt
   */
  path?: string;
  rawDetails?: string;
  /**
   * @example
   * 3
   */
  startColumn?: number;
  /**
   * @example
   * 1
   */
  startLine?: number;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      annotationLevel: 'annotationLevel',
      endColumn: 'endColumn',
      endLine: 'endLine',
      id: 'id',
      message: 'message',
      path: 'path',
      rawDetails: 'rawDetails',
      startColumn: 'startColumn',
      startLine: 'startLine',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotationLevel: 'string',
      endColumn: 'number',
      endLine: 'number',
      id: 'number',
      message: 'string',
      path: 'string',
      rawDetails: 'string',
      startColumn: 'number',
      startLine: 'number',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunResponseBodyResultCheckSuite extends $tea.Model {
  /**
   * @example
   * 1
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunResponseBodyResultOutputImages extends $tea.Model {
  /**
   * @example
   * test-image-alt
   */
  alt?: string;
  /**
   * @example
   * test
   */
  caption?: string;
  /**
   * @example
   * xxx
   */
  imageUrl?: string;
  static names(): { [key: string]: string } {
    return {
      alt: 'alt',
      caption: 'caption',
      imageUrl: 'imageUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alt: 'string',
      caption: 'string',
      imageUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunResponseBodyResultOutput extends $tea.Model {
  images?: UpdateCheckRunResponseBodyResultOutputImages[];
  summary?: string;
  text?: string;
  /**
   * @example
   * Mighty Readme report
   */
  title?: string;
  static names(): { [key: string]: string } {
    return {
      images: 'images',
      summary: 'summary',
      text: 'text',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      images: { 'type': 'array', 'itemType': UpdateCheckRunResponseBodyResultOutputImages },
      summary: 'string',
      text: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunResponseBodyResultWriter extends $tea.Model {
  /**
   * @example
   * xxx
   */
  id?: string;
  /**
   * @example
   * xxx
   */
  logoUrl?: string;
  /**
   * @example
   * test-codeup
   */
  name?: string;
  /**
   * @example
   * test-codeup
   */
  slug?: string;
  /**
   * @example
   * User
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      logoUrl: 'logoUrl',
      name: 'name',
      slug: 'slug',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      logoUrl: 'string',
      name: 'string',
      slug: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCheckRunResponseBodyResult extends $tea.Model {
  annotations?: UpdateCheckRunResponseBodyResultAnnotations[];
  checkSuite?: UpdateCheckRunResponseBodyResultCheckSuite;
  /**
   * @example
   * 2023-03-15T08:00:00Z
   */
  completedAt?: string;
  /**
   * @example
   * success
   */
  conclusion?: string;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  createdAt?: string;
  /**
   * @example
   * xxx
   */
  detailsUrl?: string;
  /**
   * @example
   * 42
   */
  externalId?: string;
  /**
   * @example
   * 40f4ccfe019cdd4a62d4acb0c57130106fc7e1be
   */
  headSha?: string;
  /**
   * @example
   * 524836
   */
  id?: number;
  /**
   * @example
   * my-check-ci
   */
  name?: string;
  output?: UpdateCheckRunResponseBodyResultOutput;
  /**
   * @example
   * 2023-03-15T08:00:00Z
   */
  startedAt?: string;
  /**
   * @example
   * completed
   */
  status?: string;
  /**
   * @example
   * 2022-01-14T21:08:26+08:00
   */
  updatedAt?: string;
  writer?: UpdateCheckRunResponseBodyResultWriter;
  static names(): { [key: string]: string } {
    return {
      annotations: 'annotations',
      checkSuite: 'checkSuite',
      completedAt: 'completedAt',
      conclusion: 'conclusion',
      createdAt: 'createdAt',
      detailsUrl: 'detailsUrl',
      externalId: 'externalId',
      headSha: 'headSha',
      id: 'id',
      name: 'name',
      output: 'output',
      startedAt: 'startedAt',
      status: 'status',
      updatedAt: 'updatedAt',
      writer: 'writer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotations: { 'type': 'array', 'itemType': UpdateCheckRunResponseBodyResultAnnotations },
      checkSuite: UpdateCheckRunResponseBodyResultCheckSuite,
      completedAt: 'string',
      conclusion: 'string',
      createdAt: 'string',
      detailsUrl: 'string',
      externalId: 'string',
      headSha: 'string',
      id: 'number',
      name: 'string',
      output: UpdateCheckRunResponseBodyResultOutput,
      startedAt: 'string',
      status: 'string',
      updatedAt: 'string',
      writer: UpdateCheckRunResponseBodyResultWriter,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileResponseBodyResult extends $tea.Model {
  /**
   * @example
   * master
   */
  branchName?: string;
  /**
   * @example
   * src/main/update.txt
   */
  filePath?: string;
  static names(): { [key: string]: string } {
    return {
      branchName: 'branchName',
      filePath: 'filePath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      branchName: 'string',
      filePath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGroupResponseBodyResult extends $tea.Model {
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c4ef67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  description?: string;
  /**
   * @example
   * 30815
   */
  id?: number;
  /**
   * @example
   * codeup
   */
  name?: string;
  nameWithNamespace?: string;
  /**
   * @example
   * 19230
   */
  ownerId?: number;
  /**
   * @example
   * 26842
   */
  parentId?: number;
  /**
   * @example
   * test-codeup
   */
  path?: string;
  /**
   * @example
   * codeup-test-org/test-codeup
   */
  pathWithNamespace?: string;
  /**
   * @example
   * Group
   */
  type?: string;
  /**
   * @example
   * 10
   */
  visibilityLevel?: number;
  /**
   * @example
   * ""
   */
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      avatarUrl: 'avatarUrl',
      description: 'description',
      id: 'id',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      ownerId: 'ownerId',
      parentId: 'parentId',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      type: 'type',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarUrl: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
      nameWithNamespace: 'string',
      ownerId: 'number',
      parentId: 'number',
      path: 'string',
      pathWithNamespace: 'string',
      type: 'string',
      visibilityLevel: 'number',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGroupMemberResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 30
   */
  accessLevel?: number;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @example
   * 24661
   */
  id?: number;
  /**
   * @example
   * USERS
   */
  memberType?: string;
  /**
   * @example
   * codeup
   */
  name?: string;
  /**
   * @example
   * 223241
   */
  sourceId?: number;
  /**
   * @example
   * active
   */
  state?: string;
  /**
   * @example
   * test-codeup
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      avatarUrl: 'avatarUrl',
      email: 'email',
      id: 'id',
      memberType: 'memberType',
      name: 'name',
      sourceId: 'sourceId',
      state: 'state',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      avatarUrl: 'string',
      email: 'string',
      id: 'number',
      memberType: 'string',
      name: 'string',
      sourceId: 'number',
      state: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMergeRequestResponseBodyResult extends $tea.Model {
  /**
   * @example
   * true
   */
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMergeRequestPersonnelResponseBodyResult extends $tea.Model {
  /**
   * @example
   * true
   */
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOrganizationMemberResponseBodyMember extends $tea.Model {
  /**
   * @example
   * 292035769476261xxx
   */
  accountId?: string;
  organizationMemberName?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
      organizationMemberName: 'organizationMemberName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
      organizationMemberName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectFieldRequestUpdateBasicFieldRequestList extends $tea.Model {
  /**
   * @example
   * name
   */
  propertyKey?: string;
  propertyValue?: string;
  static names(): { [key: string]: string } {
    return {
      propertyKey: 'propertyKey',
      propertyValue: 'propertyValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyKey: 'string',
      propertyValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectFieldRequestUpdateForOpenApiList extends $tea.Model {
  /**
   * @example
   * c4fd21xxxxxxxx9oj8jk
   */
  fieldIdentifier?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      fieldIdentifier: 'fieldIdentifier',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldIdentifier: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectFieldResponseBodyProjectFieldList extends $tea.Model {
  displayName?: string;
  /**
   * @example
   * b787ff504c0b36f8b71d15a4fd
   */
  identifier?: string;
  /**
   * @example
   * ace3wxxxxxxx7rff3ee
   */
  value?: string;
  /**
   * @example
   * user
   */
  valueType?: string;
  static names(): { [key: string]: string } {
    return {
      displayName: 'displayName',
      identifier: 'identifier',
      value: 'value',
      valueType: 'valueType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      identifier: 'string',
      value: 'string',
      valueType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectFieldResponseBodyProject extends $tea.Model {
  /**
   * @example
   * Project
   */
  category?: string;
  /**
   * @example
   * Project
   */
  categoryIdentifier?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  creator?: string;
  /**
   * @example
   * OJAY
   */
  customCode?: string;
  description?: string;
  fieldList?: UpdateProjectFieldResponseBodyProjectFieldList[];
  /**
   * @example
   * 1623916393000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1684134690000
   */
  gmtModified?: number;
  /**
   * @example
   * https://xxxxxx.png
   */
  icon?: string;
  /**
   * @example
   * https://xxxxxx.png
   */
  iconBig?: string;
  /**
   * @example
   * {"small":"https://xxxxxx.png","big":"https://img.yyyyyy.png"}
   */
  iconGroup?: string;
  /**
   * @example
   * https://img.yyyyyy.png
   */
  iconSmall?: string;
  /**
   * @example
   * 66893
   */
  id?: string;
  /**
   * @example
   * 1e2ea73d24652d5874d001b351
   */
  identifier?: string;
  /**
   * @example
   * e8b2xxxxxx2abdxxxxxxxx23
   */
  identifierPath?: string;
  /**
   * @example
   * NORMAL
   */
  logicalStatus?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  modifier?: string;
  name?: string;
  /**
   * @example
   * 5e70xxxxxxcd000xxxxe96
   */
  organizationIdentifier?: string;
  /**
   * @example
   * null
   */
  parentIdentifier?: string;
  /**
   * @example
   * public
   */
  scope?: string;
  /**
   * @example
   * 8a40xxxxxxxxxxxxx64
   */
  statusIdentifier?: string;
  statusName?: string;
  /**
   * @example
   * 8a4058a71159b68254......
   */
  statusStageIdentifier?: string;
  /**
   * @example
   * null
   */
  subType?: string;
  /**
   * @example
   * CustomProject
   */
  typeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'category',
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      customCode: 'customCode',
      description: 'description',
      fieldList: 'fieldList',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      icon: 'icon',
      iconBig: 'iconBig',
      iconGroup: 'iconGroup',
      iconSmall: 'iconSmall',
      id: 'id',
      identifier: 'identifier',
      identifierPath: 'identifierPath',
      logicalStatus: 'logicalStatus',
      modifier: 'modifier',
      name: 'name',
      organizationIdentifier: 'organizationIdentifier',
      parentIdentifier: 'parentIdentifier',
      scope: 'scope',
      statusIdentifier: 'statusIdentifier',
      statusName: 'statusName',
      statusStageIdentifier: 'statusStageIdentifier',
      subType: 'subType',
      typeIdentifier: 'typeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      categoryIdentifier: 'string',
      creator: 'string',
      customCode: 'string',
      description: 'string',
      fieldList: { 'type': 'array', 'itemType': UpdateProjectFieldResponseBodyProjectFieldList },
      gmtCreate: 'number',
      gmtModified: 'number',
      icon: 'string',
      iconBig: 'string',
      iconGroup: 'string',
      iconSmall: 'string',
      id: 'string',
      identifier: 'string',
      identifierPath: 'string',
      logicalStatus: 'string',
      modifier: 'string',
      name: 'string',
      organizationIdentifier: 'string',
      parentIdentifier: 'string',
      scope: 'string',
      statusIdentifier: 'string',
      statusName: 'string',
      statusStageIdentifier: 'string',
      subType: 'string',
      typeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectLabelResponseBodyResult extends $tea.Model {
  /**
   * @example
   * #EF433B
   */
  color?: string;
  description?: string;
  /**
   * @example
   * 8d84d73cf315473683400760f02dbfc1
   */
  id?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      color: 'color',
      description: 'description',
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      color: 'string',
      description: 'string',
      id: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectMemberResponseBodyMember extends $tea.Model {
  /**
   * @example
   * 1623916393000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1623916393000
   */
  gmtModified?: number;
  /**
   * @example
   * 1124382
   */
  id?: string;
  /**
   * @example
   * project.admin
   */
  roleIdentifier?: string;
  /**
   * @example
   * 5e70xxxxxxcd000xxxxe96
   */
  targetIdentifier?: string;
  /**
   * @example
   * Space
   */
  targetType?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  userIdentifier?: string;
  /**
   * @example
   * user
   */
  userType?: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      id: 'id',
      roleIdentifier: 'roleIdentifier',
      targetIdentifier: 'targetIdentifier',
      targetType: 'targetType',
      userIdentifier: 'userIdentifier',
      userType: 'userType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      gmtModified: 'number',
      id: 'string',
      roleIdentifier: 'string',
      targetIdentifier: 'string',
      targetType: 'string',
      userIdentifier: 'string',
      userType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesRequestMergeRequestSetting extends $tea.Model {
  allowMergeRequestRoles?: number[];
  defaultAssignees?: string[];
  /**
   * @example
   * true
   */
  isAllowSelfApproval?: boolean;
  /**
   * @example
   * true
   */
  isRequireDiscussionProcessed?: boolean;
  /**
   * @example
   * true
   */
  isRequired?: boolean;
  /**
   * @example
   * false
   */
  isResetApprovalWhenNewPush?: boolean;
  /**
   * @example
   * 1
   */
  minimumApproval?: number;
  /**
   * @example
   * general
   */
  mrMode?: string;
  /**
   * @example
   * **.java
   */
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      allowMergeRequestRoles: 'allowMergeRequestRoles',
      defaultAssignees: 'defaultAssignees',
      isAllowSelfApproval: 'isAllowSelfApproval',
      isRequireDiscussionProcessed: 'isRequireDiscussionProcessed',
      isRequired: 'isRequired',
      isResetApprovalWhenNewPush: 'isResetApprovalWhenNewPush',
      minimumApproval: 'minimumApproval',
      mrMode: 'mrMode',
      whiteList: 'whiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowMergeRequestRoles: { 'type': 'array', 'itemType': 'number' },
      defaultAssignees: { 'type': 'array', 'itemType': 'string' },
      isAllowSelfApproval: 'boolean',
      isRequireDiscussionProcessed: 'boolean',
      isRequired: 'boolean',
      isResetApprovalWhenNewPush: 'boolean',
      minimumApproval: 'number',
      mrMode: 'string',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesRequestTestSettingDTOCheckConfigCheckItems extends $tea.Model {
  /**
   * @example
   * false
   */
  isRequired?: boolean;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      isRequired: 'isRequired',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isRequired: 'boolean',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesRequestTestSettingDTOCheckConfig extends $tea.Model {
  checkItems?: UpdateProtectedBranchesRequestTestSettingDTOCheckConfigCheckItems[];
  static names(): { [key: string]: string } {
    return {
      checkItems: 'checkItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkItems: { 'type': 'array', 'itemType': UpdateProtectedBranchesRequestTestSettingDTOCheckConfigCheckItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesRequestTestSettingDTOCheckTaskQualityConfig extends $tea.Model {
  /**
   * @example
   * 123456
   */
  bizNo?: string;
  /**
   * @example
   * false
   */
  enabled?: boolean;
  /**
   * @example
   * test_task_quality
   */
  message?: string;
  /**
   * @example
   * bz-task-quality
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      bizNo: 'bizNo',
      enabled: 'enabled',
      message: 'message',
      taskName: 'taskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizNo: 'string',
      enabled: 'boolean',
      message: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesRequestTestSettingDTOCodeGuidelinesDetection extends $tea.Model {
  /**
   * @example
   * false
   */
  enabled?: boolean;
  /**
   * @example
   * test_code_guide_lines
   */
  message?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'enabled',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesRequestTestSettingDTOSensitiveInfoDetection extends $tea.Model {
  /**
   * @example
   * false
   */
  enabled?: boolean;
  /**
   * @example
   * test_code_sensitive_info
   */
  message?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'enabled',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesRequestTestSettingDTO extends $tea.Model {
  checkConfig?: UpdateProtectedBranchesRequestTestSettingDTOCheckConfig;
  checkTaskQualityConfig?: UpdateProtectedBranchesRequestTestSettingDTOCheckTaskQualityConfig;
  codeGuidelinesDetection?: UpdateProtectedBranchesRequestTestSettingDTOCodeGuidelinesDetection;
  /**
   * @example
   * false
   */
  isRequired?: boolean;
  sensitiveInfoDetection?: UpdateProtectedBranchesRequestTestSettingDTOSensitiveInfoDetection;
  static names(): { [key: string]: string } {
    return {
      checkConfig: 'checkConfig',
      checkTaskQualityConfig: 'checkTaskQualityConfig',
      codeGuidelinesDetection: 'codeGuidelinesDetection',
      isRequired: 'isRequired',
      sensitiveInfoDetection: 'sensitiveInfoDetection',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkConfig: UpdateProtectedBranchesRequestTestSettingDTOCheckConfig,
      checkTaskQualityConfig: UpdateProtectedBranchesRequestTestSettingDTOCheckTaskQualityConfig,
      codeGuidelinesDetection: UpdateProtectedBranchesRequestTestSettingDTOCodeGuidelinesDetection,
      isRequired: 'boolean',
      sensitiveInfoDetection: UpdateProtectedBranchesRequestTestSettingDTOSensitiveInfoDetection,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesResponseBodyResultMergeRequestSetting extends $tea.Model {
  allowMergeRequestRoles?: number[];
  defaultAssignees?: string[];
  /**
   * @example
   * true
   */
  isAllowSelfApproval?: boolean;
  /**
   * @example
   * true
   */
  isRequireDiscussionProcessed?: boolean;
  /**
   * @example
   * true
   */
  isRequired?: boolean;
  /**
   * @example
   * false
   */
  isResetApprovalWhenNewPush?: boolean;
  /**
   * @example
   * 1
   */
  minimumApproval?: number;
  /**
   * @example
   * general
   */
  mrMode?: string;
  /**
   * @example
   * **.java
   */
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      allowMergeRequestRoles: 'allowMergeRequestRoles',
      defaultAssignees: 'defaultAssignees',
      isAllowSelfApproval: 'isAllowSelfApproval',
      isRequireDiscussionProcessed: 'isRequireDiscussionProcessed',
      isRequired: 'isRequired',
      isResetApprovalWhenNewPush: 'isResetApprovalWhenNewPush',
      minimumApproval: 'minimumApproval',
      mrMode: 'mrMode',
      whiteList: 'whiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowMergeRequestRoles: { 'type': 'array', 'itemType': 'number' },
      defaultAssignees: { 'type': 'array', 'itemType': 'string' },
      isAllowSelfApproval: 'boolean',
      isRequireDiscussionProcessed: 'boolean',
      isRequired: 'boolean',
      isResetApprovalWhenNewPush: 'boolean',
      minimumApproval: 'number',
      mrMode: 'string',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems extends $tea.Model {
  /**
   * @example
   * false
   */
  isRequired?: boolean;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      isRequired: 'isRequired',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isRequired: 'boolean',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig extends $tea.Model {
  checkItems?: UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems[];
  static names(): { [key: string]: string } {
    return {
      checkItems: 'checkItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkItems: { 'type': 'array', 'itemType': UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig extends $tea.Model {
  /**
   * @example
   * 123456
   */
  bizNo?: string;
  /**
   * @example
   * false
   */
  enabled?: boolean;
  /**
   * @example
   * test_task_quality
   */
  message?: string;
  /**
   * @example
   * biz-task-quality
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      bizNo: 'bizNo',
      enabled: 'enabled',
      message: 'message',
      taskName: 'taskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizNo: 'string',
      enabled: 'boolean',
      message: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection extends $tea.Model {
  /**
   * @example
   * false
   */
  enabled?: boolean;
  /**
   * @example
   * test_code_guide_lines
   */
  message?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'enabled',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection extends $tea.Model {
  /**
   * @example
   * false
   */
  enabled?: boolean;
  /**
   * @example
   * test_code_sensitive_info
   */
  message?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'enabled',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesResponseBodyResultTestSettingDTO extends $tea.Model {
  checkConfig?: UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig;
  checkTaskQualityConfig?: UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig;
  codeGuidelinesDetection?: UpdateProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection;
  /**
   * @example
   * false
   */
  isRequired?: boolean;
  sensitiveInfoDetection?: UpdateProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection;
  static names(): { [key: string]: string } {
    return {
      checkConfig: 'checkConfig',
      checkTaskQualityConfig: 'checkTaskQualityConfig',
      codeGuidelinesDetection: 'codeGuidelinesDetection',
      isRequired: 'isRequired',
      sensitiveInfoDetection: 'sensitiveInfoDetection',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkConfig: UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig,
      checkTaskQualityConfig: UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig,
      codeGuidelinesDetection: UpdateProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection,
      isRequired: 'boolean',
      sensitiveInfoDetection: UpdateProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProtectedBranchesResponseBodyResult extends $tea.Model {
  allowMergeRoles?: number[];
  allowMergeUserIds?: number[];
  allowPushRoles?: number[];
  allowPushUserIds?: number[];
  /**
   * @example
   * master
   */
  branch?: string;
  /**
   * @example
   * 123456
   */
  id?: number;
  mergeRequestSetting?: UpdateProtectedBranchesResponseBodyResultMergeRequestSetting;
  testSettingDTO?: UpdateProtectedBranchesResponseBodyResultTestSettingDTO;
  static names(): { [key: string]: string } {
    return {
      allowMergeRoles: 'allowMergeRoles',
      allowMergeUserIds: 'allowMergeUserIds',
      allowPushRoles: 'allowPushRoles',
      allowPushUserIds: 'allowPushUserIds',
      branch: 'branch',
      id: 'id',
      mergeRequestSetting: 'mergeRequestSetting',
      testSettingDTO: 'testSettingDTO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowMergeRoles: { 'type': 'array', 'itemType': 'number' },
      allowMergeUserIds: { 'type': 'array', 'itemType': 'number' },
      allowPushRoles: { 'type': 'array', 'itemType': 'number' },
      allowPushUserIds: { 'type': 'array', 'itemType': 'number' },
      branch: 'string',
      id: 'number',
      mergeRequestSetting: UpdateProtectedBranchesResponseBodyResultMergeRequestSetting,
      testSettingDTO: UpdateProtectedBranchesResponseBodyResultTestSettingDTO,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePushReviewOnOffResponseBodyResult extends $tea.Model {
  /**
   * @example
   * true
   */
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePushRuleRequestRuleInfos extends $tea.Model {
  /**
   * @example
   * CommitAuthorChecker
   */
  checkerName?: string;
  /**
   * @example
   * warn
   */
  checkerType?: string;
  /**
   * @example
   * on
   */
  extraMessage?: string;
  fileRuleRegexes?: string[];
  static names(): { [key: string]: string } {
    return {
      checkerName: 'checkerName',
      checkerType: 'checkerType',
      extraMessage: 'extraMessage',
      fileRuleRegexes: 'fileRuleRegexes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkerName: 'string',
      checkerType: 'string',
      extraMessage: 'string',
      fileRuleRegexes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePushRuleResponseBodyResultRuleInfos extends $tea.Model {
  /**
   * @example
   * CommitAuthorChecker
   */
  checkerName?: string;
  /**
   * @example
   * warn
   */
  checkerType?: string;
  /**
   * @example
   * on
   */
  extraMessage?: string;
  fileRuleRegexes?: string[];
  static names(): { [key: string]: string } {
    return {
      checkerName: 'checkerName',
      checkerType: 'checkerType',
      extraMessage: 'extraMessage',
      fileRuleRegexes: 'fileRuleRegexes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkerName: 'string',
      checkerType: 'string',
      extraMessage: 'string',
      fileRuleRegexes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePushRuleResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 2023-09-03T18:20:06+08:00
   */
  gmtCreate?: string;
  /**
   * @example
   * 2023-09-03T18:20:06+08:00
   */
  gmtModified?: string;
  id?: number;
  ruleInfos?: UpdatePushRuleResponseBodyResultRuleInfos[];
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      id: 'id',
      ruleInfos: 'ruleInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      ruleInfos: { 'type': 'array', 'itemType': UpdatePushRuleResponseBodyResultRuleInfos },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryRequestProjectCloneDownloadMethodList extends $tea.Model {
  /**
   * @example
   * true
   */
  allowed?: boolean;
  /**
   * @example
   * project:download
   */
  permissionCode?: string;
  static names(): { [key: string]: string } {
    return {
      allowed: 'allowed',
      permissionCode: 'permissionCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowed: 'boolean',
      permissionCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryRequestProjectCloneDownloadRoleList extends $tea.Model {
  /**
   * @example
   * true
   */
  allowed?: boolean;
  /**
   * @example
   * 15
   */
  roleCode?: number;
  static names(): { [key: string]: string } {
    return {
      allowed: 'allowed',
      roleCode: 'roleCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowed: 'boolean',
      roleCode: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryResponseBodyResultNamespace extends $tea.Model {
  /**
   * @example
   * https://xxx
   */
  avatar?: string;
  /**
   * @example
   * 2022-02-18 14:24:54
   */
  createdAt?: string;
  description?: string;
  /**
   * @example
   * 29322
   */
  id?: number;
  /**
   * @example
   * codeup
   */
  name?: string;
  /**
   * @example
   * 19238
   */
  ownerId?: number;
  path?: string;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  updatedAt?: string;
  /**
   * @example
   * 0
   */
  visibilityLevel?: number;
  static names(): { [key: string]: string } {
    return {
      avatar: 'avatar',
      createdAt: 'createdAt',
      description: 'description',
      id: 'id',
      name: 'name',
      ownerId: 'ownerId',
      path: 'path',
      updatedAt: 'updatedAt',
      visibilityLevel: 'visibilityLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatar: 'string',
      createdAt: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
      ownerId: 'number',
      path: 'string',
      updatedAt: 'string',
      visibilityLevel: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryResponseBodyResult extends $tea.Model {
  /**
   * @example
   * false
   */
  archived?: boolean;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * false
   */
  buildsEnabled?: boolean;
  /**
   * @example
   * 2022-03-18 14:24:54
   */
  createdAt?: string;
  /**
   * @example
   * 19238
   */
  creatorId?: number;
  /**
   * @example
   * master
   */
  defaultBranch?: string;
  description?: string;
  /**
   * @example
   * https://codeup.aliyun.com/xxx/test/test.git
   */
  httpUrlToRepo?: string;
  /**
   * @example
   * 2825387
   */
  id?: number;
  /**
   * @example
   * true
   */
  issuesEnabled?: boolean;
  /**
   * @example
   * 2022-03-20 14:24:54
   */
  lastActivityAt?: string;
  /**
   * @example
   * true
   */
  mergeRequestsEnabled?: boolean;
  /**
   * @example
   * codeup
   */
  name?: string;
  nameWithNamespace?: string;
  namespace?: UpdateRepositoryResponseBodyResultNamespace;
  /**
   * @example
   * codeup
   */
  path?: string;
  /**
   * @example
   * codeup-test-org / codeup
   */
  pathWithNamespace?: string;
  /**
   * @example
   * false
   */
  snippetsEnabled?: boolean;
  /**
   * @example
   * git@codeup.aliyun.com:xxx/test/test.git
   */
  sshUrlToRepo?: string;
  /**
   * @example
   * 0
   */
  visibilityLevel?: number;
  /**
   * @example
   * https://codeup.aliyun.com/xxx/test/test
   */
  webUrl?: string;
  /**
   * @example
   * true
   */
  wikiEnabled?: boolean;
  static names(): { [key: string]: string } {
    return {
      archived: 'archived',
      avatarUrl: 'avatarUrl',
      buildsEnabled: 'buildsEnabled',
      createdAt: 'createdAt',
      creatorId: 'creatorId',
      defaultBranch: 'defaultBranch',
      description: 'description',
      httpUrlToRepo: 'httpUrlToRepo',
      id: 'id',
      issuesEnabled: 'issuesEnabled',
      lastActivityAt: 'lastActivityAt',
      mergeRequestsEnabled: 'mergeRequestsEnabled',
      name: 'name',
      nameWithNamespace: 'nameWithNamespace',
      namespace: 'namespace',
      path: 'path',
      pathWithNamespace: 'pathWithNamespace',
      snippetsEnabled: 'snippetsEnabled',
      sshUrlToRepo: 'sshUrlToRepo',
      visibilityLevel: 'visibilityLevel',
      webUrl: 'webUrl',
      wikiEnabled: 'wikiEnabled',
    };
  }

  static types(): { [key: string]: any } {
    return {
      archived: 'boolean',
      avatarUrl: 'string',
      buildsEnabled: 'boolean',
      createdAt: 'string',
      creatorId: 'number',
      defaultBranch: 'string',
      description: 'string',
      httpUrlToRepo: 'string',
      id: 'number',
      issuesEnabled: 'boolean',
      lastActivityAt: 'string',
      mergeRequestsEnabled: 'boolean',
      name: 'string',
      nameWithNamespace: 'string',
      namespace: UpdateRepositoryResponseBodyResultNamespace,
      path: 'string',
      pathWithNamespace: 'string',
      snippetsEnabled: 'boolean',
      sshUrlToRepo: 'string',
      visibilityLevel: 'number',
      webUrl: 'string',
      wikiEnabled: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryMemberRequestRelatedInfos extends $tea.Model {
  /**
   * @example
   * 10011
   */
  relatedId?: string;
  /**
   * @example
   * 24790
   */
  sourceId?: number;
  /**
   * @example
   * Project
   */
  sourceType?: string;
  static names(): { [key: string]: string } {
    return {
      relatedId: 'relatedId',
      sourceId: 'sourceId',
      sourceType: 'sourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      relatedId: 'string',
      sourceId: 'number',
      sourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRepositoryMemberResponseBodyResult extends $tea.Model {
  /**
   * @example
   * 40
   */
  accessLevel?: number;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112afcb7a6a35c3f67f1bea827c4/w/100/h/100
   */
  avatarUrl?: string;
  /**
   * @example
   * test@alibaba.com
   */
  email?: string;
  /**
   * @example
   * 2020-08-08 08:08:08
   */
  expireAt?: string;
  /**
   * @example
   * 30815
   */
  id?: number;
  /**
   * @example
   * test_memeber_name
   */
  memberName?: string;
  /**
   * @example
   * USERS
   */
  memberType?: string;
  /**
   * @example
   * codeup
   */
  name?: string;
  /**
   * @example
   * 223241
   */
  sourceId?: number;
  /**
   * @example
   * Project
   */
  sourceType?: string;
  /**
   * @example
   * normal
   */
  state?: string;
  /**
   * @example
   * codeup-test
   */
  username?: string;
  /**
   * @remarks
   * web url
   * 
   * @example
   * ""
   */
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      accessLevel: 'accessLevel',
      avatarUrl: 'avatarUrl',
      email: 'email',
      expireAt: 'expireAt',
      id: 'id',
      memberName: 'memberName',
      memberType: 'memberType',
      name: 'name',
      sourceId: 'sourceId',
      sourceType: 'sourceType',
      state: 'state',
      username: 'username',
      webUrl: 'webUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLevel: 'number',
      avatarUrl: 'string',
      email: 'string',
      expireAt: 'string',
      id: 'number',
      memberName: 'string',
      memberType: 'string',
      name: 'string',
      sourceId: 'number',
      sourceType: 'string',
      state: 'string',
      username: 'string',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseRequestUpdateWorkitemPropertyRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * tc.type
   */
  fieldIdentifier?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 0a032xx28107xxxx53e87a9
   */
  fieldValue?: string;
  static names(): { [key: string]: string } {
    return {
      fieldIdentifier: 'fieldIdentifier',
      fieldValue: 'fieldValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldIdentifier: 'string',
      fieldValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponseBodyTestcaseAssignedTo extends $tea.Model {
  /**
   * @example
   * 1316xxxxxx8624xxx
   */
  assignIdentifier?: string;
  name?: string;
  /**
   * @example
   * xxxxxxxewdds12xxx
   */
  tbRoleId?: string;
  static names(): { [key: string]: string } {
    return {
      assignIdentifier: 'assignIdentifier',
      name: 'name',
      tbRoleId: 'tbRoleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignIdentifier: 'string',
      name: 'string',
      tbRoleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponseBodyTestcaseCreator extends $tea.Model {
  /**
   * @example
   * 1316xxxxxx8624xxx
   */
  createIdentifier?: string;
  /**
   * @example
   * xxxxxxx
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      createIdentifier: 'createIdentifier',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createIdentifier: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponseBodyTestcaseDetailInfoExpectedResult extends $tea.Model {
  expectContent?: string;
  /**
   * @example
   * MARKDOWN
   */
  expectContentType?: string;
  /**
   * @example
   * 685340d13127b01185335bd360
   */
  expectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      expectContent: 'expectContent',
      expectContentType: 'expectContentType',
      expectIdentifier: 'expectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expectContent: 'string',
      expectContentType: 'string',
      expectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponseBodyTestcaseDetailInfoPrecondition extends $tea.Model {
  preContent?: string;
  /**
   * @example
   * MARKDOWN
   */
  preContentType?: string;
  /**
   * @example
   * 3354596c7b3004480b635acf95
   */
  preIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      preContent: 'preContent',
      preContentType: 'preContentType',
      preIdentifier: 'preIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preContent: 'string',
      preContentType: 'string',
      preIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponseBodyTestcaseDetailInfoStepContent extends $tea.Model {
  stepContent?: string;
  /**
   * @example
   * RICHTEXT
   */
  stepContentType?: string;
  /**
   * @example
   * ad504e6cdcd2165b28eb1e1b9f
   */
  stepIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      stepContent: 'stepContent',
      stepContentType: 'stepContentType',
      stepIdentifier: 'stepIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      stepContent: 'string',
      stepContentType: 'string',
      stepIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponseBodyTestcaseDetailInfo extends $tea.Model {
  expectedResult?: UpdateTestCaseResponseBodyTestcaseDetailInfoExpectedResult;
  precondition?: UpdateTestCaseResponseBodyTestcaseDetailInfoPrecondition;
  stepContent?: UpdateTestCaseResponseBodyTestcaseDetailInfoStepContent;
  /**
   * @example
   * TEXT/TABLE
   */
  stepType?: string;
  static names(): { [key: string]: string } {
    return {
      expectedResult: 'expectedResult',
      precondition: 'precondition',
      stepContent: 'stepContent',
      stepType: 'stepType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expectedResult: UpdateTestCaseResponseBodyTestcaseDetailInfoExpectedResult,
      precondition: UpdateTestCaseResponseBodyTestcaseDetailInfoPrecondition,
      stepContent: UpdateTestCaseResponseBodyTestcaseDetailInfoStepContent,
      stepType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponseBodyTestcaseDirectory extends $tea.Model {
  /**
   * @example
   * 2973f597c14c6f533fffdcd05c
   */
  childIdentifier?: string;
  /**
   * @example
   * e27b8eace6501ce51cf5d56784
   */
  directoryIdentifier?: string;
  name?: string;
  pathName?: string[];
  static names(): { [key: string]: string } {
    return {
      childIdentifier: 'childIdentifier',
      directoryIdentifier: 'directoryIdentifier',
      name: 'name',
      pathName: 'pathName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      childIdentifier: 'string',
      directoryIdentifier: 'string',
      name: 'string',
      pathName: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponseBodyTestcaseModifier extends $tea.Model {
  /**
   * @example
   * 1316xxxxxx8624xxx
   */
  modifyIdentifier?: string;
  /**
   * @example
   * xxxxxxx
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      modifyIdentifier: 'modifyIdentifier',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      modifyIdentifier: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTestCaseResponseBodyTestcase extends $tea.Model {
  assignedTo?: UpdateTestCaseResponseBodyTestcaseAssignedTo;
  /**
   * @example
   * TestCase
   */
  categoryIdentifier?: string;
  creator?: UpdateTestCaseResponseBodyTestcaseCreator;
  detailInfo?: UpdateTestCaseResponseBodyTestcaseDetailInfo;
  directory?: UpdateTestCaseResponseBodyTestcaseDirectory;
  /**
   * @example
   * c7f7033b021ead52cc42721382
   */
  identifier?: string;
  modifier?: UpdateTestCaseResponseBodyTestcaseModifier;
  /**
   * @example
   * 1e7d7a412b91a2144ec4aa8411
   */
  spaceIdentifier?: string;
  /**
   * @example
   * TestRepo
   */
  spaceType?: string;
  subject?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      detailInfo: 'detailInfo',
      directory: 'directory',
      identifier: 'identifier',
      modifier: 'modifier',
      spaceIdentifier: 'spaceIdentifier',
      spaceType: 'spaceType',
      subject: 'subject',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: UpdateTestCaseResponseBodyTestcaseAssignedTo,
      categoryIdentifier: 'string',
      creator: UpdateTestCaseResponseBodyTestcaseCreator,
      detailInfo: UpdateTestCaseResponseBodyTestcaseDetailInfo,
      directory: UpdateTestCaseResponseBodyTestcaseDirectory,
      identifier: 'string',
      modifier: UpdateTestCaseResponseBodyTestcaseModifier,
      spaceIdentifier: 'string',
      spaceType: 'string',
      subject: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkItemResponseBodyWorkitem extends $tea.Model {
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  assignedTo?: string;
  /**
   * @example
   * Req
   */
  categoryIdentifier?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  creator?: string;
  /**
   * @example
   * html格式
   */
  document?: string;
  documentFormat?: string;
  /**
   * @example
   * 1640850318000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1640850318000
   */
  gmtModified?: number;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  identifier?: string;
  /**
   * @example
   * NORMAL
   */
  logicalStatus?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  modifier?: string;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx24
   */
  parentIdentifier?: string;
  /**
   * @example
   * ACFS-1
   */
  serialNumber?: string;
  /**
   * @example
   * e8b26xxxxx6e76aa20xxxxx23
   */
  spaceIdentifier?: string;
  /**
   * @example
   * 需求项目
   */
  spaceName?: string;
  /**
   * @example
   * Project
   */
  spaceType?: string;
  /**
   * @example
   * 75528f17703e92e5a568......
   */
  sprintIdentifier?: string;
  /**
   * @example
   * 待处理
   */
  status?: string;
  /**
   * @example
   * 111000
   */
  statusIdentifier?: string;
  /**
   * @example
   * 1
   */
  statusStageIdentifier?: string;
  /**
   * @example
   * 测试工作项
   */
  subject?: string;
  /**
   * @example
   * 1640850328000
   */
  updateStatusAt?: number;
  /**
   * @example
   * 9uxxxxxxre573f5xxxxxx0
   */
  workitemTypeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      document: 'document',
      documentFormat: 'documentFormat',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      logicalStatus: 'logicalStatus',
      modifier: 'modifier',
      parentIdentifier: 'parentIdentifier',
      serialNumber: 'serialNumber',
      spaceIdentifier: 'spaceIdentifier',
      spaceName: 'spaceName',
      spaceType: 'spaceType',
      sprintIdentifier: 'sprintIdentifier',
      status: 'status',
      statusIdentifier: 'statusIdentifier',
      statusStageIdentifier: 'statusStageIdentifier',
      subject: 'subject',
      updateStatusAt: 'updateStatusAt',
      workitemTypeIdentifier: 'workitemTypeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: 'string',
      categoryIdentifier: 'string',
      creator: 'string',
      document: 'string',
      documentFormat: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      logicalStatus: 'string',
      modifier: 'string',
      parentIdentifier: 'string',
      serialNumber: 'string',
      spaceIdentifier: 'string',
      spaceName: 'string',
      spaceType: 'string',
      sprintIdentifier: 'string',
      status: 'string',
      statusIdentifier: 'string',
      statusStageIdentifier: 'string',
      subject: 'string',
      updateStatusAt: 'number',
      workitemTypeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkitemCommentResponseBodyCommentUser extends $tea.Model {
  /**
   * @example
   * 1316458xxxxx41068
   */
  account?: string;
  /**
   * @example
   * https://tcs-devops.aliyuncs.com/thumbnail/112m7150e256dbba0d6456bafbb65c81f90d/w/200/h/200
   */
  avatar?: string;
  displayName?: string;
  /**
   * @example
   * 9144ef6b72d8exxxxx9e61a4d0
   */
  identifier?: string;
  nickName?: string;
  realName?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'account',
      avatar: 'avatar',
      displayName: 'displayName',
      identifier: 'identifier',
      nickName: 'nickName',
      realName: 'realName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      avatar: 'string',
      displayName: 'string',
      identifier: 'string',
      nickName: 'string',
      realName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkitemCommentResponseBodyComment extends $tea.Model {
  content?: string;
  /**
   * @example
   * 1667205617061
   */
  createTime?: number;
  /**
   * @example
   * MARKDOWN/RICHTEXT
   */
  formatType?: string;
  /**
   * @example
   * 1964584
   */
  id?: string;
  /**
   * @example
   * true/false
   */
  isTop?: boolean;
  /**
   * @example
   * 1646323200000
   */
  modifiedTime?: number;
  /**
   * @example
   * 2684432
   */
  parentId?: number;
  /**
   * @example
   * deafe5f33xxxxx6a259d8dafd
   */
  targetIdentifier?: string;
  /**
   * @example
   * workitem
   */
  targetType?: string;
  /**
   * @example
   * 1667205617089
   */
  topTime?: number;
  user?: UpdateWorkitemCommentResponseBodyCommentUser;
  static names(): { [key: string]: string } {
    return {
      content: 'content',
      createTime: 'createTime',
      formatType: 'formatType',
      id: 'id',
      isTop: 'isTop',
      modifiedTime: 'modifiedTime',
      parentId: 'parentId',
      targetIdentifier: 'targetIdentifier',
      targetType: 'targetType',
      topTime: 'topTime',
      user: 'user',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      createTime: 'number',
      formatType: 'string',
      id: 'string',
      isTop: 'boolean',
      modifiedTime: 'number',
      parentId: 'number',
      targetIdentifier: 'string',
      targetType: 'string',
      topTime: 'number',
      user: UpdateWorkitemCommentResponseBodyCommentUser,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkitemFieldRequestUpdateWorkitemPropertyRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * tag
   */
  fieldIdentifier?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  fieldValue?: string;
  static names(): { [key: string]: string } {
    return {
      fieldIdentifier: 'fieldIdentifier',
      fieldValue: 'fieldValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldIdentifier: 'string',
      fieldValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkitemFieldResponseBodyWorkitem extends $tea.Model {
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  assignedTo?: string;
  /**
   * @example
   * Req
   */
  categoryIdentifier?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  creator?: string;
  /**
   * @example
   * html格式
   */
  document?: string;
  /**
   * @example
   * 1640850318000
   */
  gmtCreate?: number;
  /**
   * @example
   * 1640850318000
   */
  gmtModified?: number;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx23
   */
  identifier?: string;
  /**
   * @example
   * NORMAL
   */
  logicalStatus?: string;
  /**
   * @example
   * 19xx7043xxxxxxx914
   */
  modifier?: string;
  /**
   * @example
   * e8bxxxxxxxxxxxxxxxx24
   */
  parentIdentifier?: string;
  /**
   * @example
   * 1
   */
  serialNumber?: string;
  /**
   * @example
   * e8b26xxxxx6e76aa20xxxxx23
   */
  spaceIdentifier?: string;
  /**
   * @example
   * 需求项目
   */
  spaceName?: string;
  /**
   * @example
   * Project
   */
  spaceType?: string;
  /**
   * @example
   * 75528f17703e92e5a568......
   */
  sprintIdentifier?: string;
  /**
   * @example
   * 待处理
   */
  status?: string;
  /**
   * @example
   * 28
   */
  statusIdentifier?: string;
  /**
   * @example
   * 1
   */
  statusStageIdentifier?: string;
  /**
   * @example
   * 测试工作项
   */
  subject?: string;
  /**
   * @example
   * 1640850328000
   */
  updateStatusAt?: number;
  /**
   * @example
   * 9uxxxxxxre573f5xxxxxx0
   */
  workitemTypeIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      assignedTo: 'assignedTo',
      categoryIdentifier: 'categoryIdentifier',
      creator: 'creator',
      document: 'document',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      identifier: 'identifier',
      logicalStatus: 'logicalStatus',
      modifier: 'modifier',
      parentIdentifier: 'parentIdentifier',
      serialNumber: 'serialNumber',
      spaceIdentifier: 'spaceIdentifier',
      spaceName: 'spaceName',
      spaceType: 'spaceType',
      sprintIdentifier: 'sprintIdentifier',
      status: 'status',
      statusIdentifier: 'statusIdentifier',
      statusStageIdentifier: 'statusStageIdentifier',
      subject: 'subject',
      updateStatusAt: 'updateStatusAt',
      workitemTypeIdentifier: 'workitemTypeIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assignedTo: 'string',
      categoryIdentifier: 'string',
      creator: 'string',
      document: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      identifier: 'string',
      logicalStatus: 'string',
      modifier: 'string',
      parentIdentifier: 'string',
      serialNumber: 'string',
      spaceIdentifier: 'string',
      spaceName: 'string',
      spaceType: 'string',
      sprintIdentifier: 'string',
      status: 'string',
      statusIdentifier: 'string',
      statusStageIdentifier: 'string',
      subject: 'string',
      updateStatusAt: 'number',
      workitemTypeIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "";
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("devops", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  /**
   * 添加组成员
   * 
   * @param request - AddGroupMemberRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddGroupMemberResponse
   */
  async addGroupMemberWithOptions(groupId: string, request: AddGroupMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<AddGroupMemberResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessLevel)) {
      body["accessLevel"] = request.accessLevel;
    }

    if (!Util.isUnset(request.aliyunPks)) {
      body["aliyunPks"] = request.aliyunPks;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AddGroupMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/groups/${OpenApiUtil.getEncodeParam(groupId)}/members/create`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<AddGroupMemberResponse>(await this.callApi(params, req, runtime), new AddGroupMemberResponse({}));
  }

  /**
   * 添加组成员
   * 
   * @param request - AddGroupMemberRequest
   * @returns AddGroupMemberResponse
   */
  async addGroupMember(groupId: string, request: AddGroupMemberRequest): Promise<AddGroupMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.addGroupMemberWithOptions(groupId, request, headers, runtime);
  }

  /**
   * 添加流水线关联
   * 
   * @param request - AddPipelineRelationsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddPipelineRelationsResponse
   */
  async addPipelineRelationsWithOptions(organizationId: string, pipelineId: string, request: AddPipelineRelationsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<AddPipelineRelationsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.relObjectIds)) {
      query["relObjectIds"] = request.relObjectIds;
    }

    if (!Util.isUnset(request.relObjectType)) {
      query["relObjectType"] = request.relObjectType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddPipelineRelations",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRelations`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<AddPipelineRelationsResponse>(await this.callApi(params, req, runtime), new AddPipelineRelationsResponse({}));
  }

  /**
   * 添加流水线关联
   * 
   * @param request - AddPipelineRelationsRequest
   * @returns AddPipelineRelationsResponse
   */
  async addPipelineRelations(organizationId: string, pipelineId: string, request: AddPipelineRelationsRequest): Promise<AddPipelineRelationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.addPipelineRelationsWithOptions(organizationId, pipelineId, request, headers, runtime);
  }

  /**
   * 添加代码库成员
   * 
   * @param request - AddRepositoryMemberRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddRepositoryMemberResponse
   */
  async addRepositoryMemberWithOptions(repositoryId: string, request: AddRepositoryMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<AddRepositoryMemberResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessLevel)) {
      body["accessLevel"] = request.accessLevel;
    }

    if (!Util.isUnset(request.aliyunPks)) {
      body["aliyunPks"] = request.aliyunPks;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AddRepositoryMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/members`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<AddRepositoryMemberResponse>(await this.callApi(params, req, runtime), new AddRepositoryMemberResponse({}));
  }

  /**
   * 添加代码库成员
   * 
   * @param request - AddRepositoryMemberRequest
   * @returns AddRepositoryMemberResponse
   */
  async addRepositoryMember(repositoryId: string, request: AddRepositoryMemberRequest): Promise<AddRepositoryMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.addRepositoryMemberWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 添加代码库Webhook
   * 
   * @param request - AddWebhookRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddWebhookResponse
   */
  async addWebhookWithOptions(repositoryId: string, request: AddWebhookRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<AddWebhookResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.enableSslVerification)) {
      body["enableSslVerification"] = request.enableSslVerification;
    }

    if (!Util.isUnset(request.mergeRequestsEvents)) {
      body["mergeRequestsEvents"] = request.mergeRequestsEvents;
    }

    if (!Util.isUnset(request.noteEvents)) {
      body["noteEvents"] = request.noteEvents;
    }

    if (!Util.isUnset(request.pushEvents)) {
      body["pushEvents"] = request.pushEvents;
    }

    if (!Util.isUnset(request.secretToken)) {
      body["secretToken"] = request.secretToken;
    }

    if (!Util.isUnset(request.tagPushEvents)) {
      body["tagPushEvents"] = request.tagPushEvents;
    }

    if (!Util.isUnset(request.url)) {
      body["url"] = request.url;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AddWebhook",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/webhooks/create`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<AddWebhookResponse>(await this.callApi(params, req, runtime), new AddWebhookResponse({}));
  }

  /**
   * 添加代码库Webhook
   * 
   * @param request - AddWebhookRequest
   * @returns AddWebhookResponse
   */
  async addWebhook(repositoryId: string, request: AddWebhookRequest): Promise<AddWebhookResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.addWebhookWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 取消执行研发阶段流水线
   * 
   * @param request - CancelExecutionReleaseStageRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CancelExecutionReleaseStageResponse
   */
  async cancelExecutionReleaseStageWithOptions(appName: string, releaseWorkflowSn: string, releaseStageSn: string, executionNumber: string, request: CancelExecutionReleaseStageRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CancelExecutionReleaseStageResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CancelExecutionReleaseStage",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}/releaseWorkflows/${OpenApiUtil.getEncodeParam(releaseWorkflowSn)}/releaseStages/${OpenApiUtil.getEncodeParam(releaseStageSn)}/executions/${OpenApiUtil.getEncodeParam(executionNumber)}%3Acancel`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CancelExecutionReleaseStageResponse>(await this.callApi(params, req, runtime), new CancelExecutionReleaseStageResponse({}));
  }

  /**
   * 取消执行研发阶段流水线
   * 
   * @param request - CancelExecutionReleaseStageRequest
   * @returns CancelExecutionReleaseStageResponse
   */
  async cancelExecutionReleaseStage(appName: string, releaseWorkflowSn: string, releaseStageSn: string, executionNumber: string, request: CancelExecutionReleaseStageRequest): Promise<CancelExecutionReleaseStageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.cancelExecutionReleaseStageWithOptions(appName, releaseWorkflowSn, releaseStageSn, executionNumber, request, headers, runtime);
  }

  /**
   * 关闭代码评审
   * 
   * @param request - CloseMergeRequestRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CloseMergeRequestResponse
   */
  async closeMergeRequestWithOptions(repositoryId: string, localId: string, request: CloseMergeRequestRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CloseMergeRequestResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CloseMergeRequest",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/merge_requests/${OpenApiUtil.getEncodeParam(localId)}/close`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CloseMergeRequestResponse>(await this.callApi(params, req, runtime), new CloseMergeRequestResponse({}));
  }

  /**
   * 关闭代码评审
   * 
   * @param request - CloseMergeRequestRequest
   * @returns CloseMergeRequestResponse
   */
  async closeMergeRequest(repositoryId: string, localId: string, request: CloseMergeRequestRequest): Promise<CloseMergeRequestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.closeMergeRequestWithOptions(repositoryId, localId, request, headers, runtime);
  }

  /**
   * 添加应用成员
   * 
   * @param request - CreateAppMembersRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateAppMembersResponse
   */
  async createAppMembersWithOptions(appName: string, request: CreateAppMembersRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateAppMembersResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.playerList)) {
      body["playerList"] = request.playerList;
    }

    if (!Util.isUnset(request.roleNames)) {
      body["roleNames"] = request.roleNames;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateAppMembers",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}/members`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "string",
    });
    return $tea.cast<CreateAppMembersResponse>(await this.callApi(params, req, runtime), new CreateAppMembersResponse({}));
  }

  /**
   * 添加应用成员
   * 
   * @param request - CreateAppMembersRequest
   * @returns CreateAppMembersResponse
   */
  async createAppMembers(appName: string, request: CreateAppMembersRequest): Promise<CreateAppMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createAppMembersWithOptions(appName, request, headers, runtime);
  }

  /**
   * 创建分支
   * 
   * @param request - CreateBranchRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateBranchResponse
   */
  async createBranchWithOptions(repositoryId: string, request: CreateBranchRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateBranchResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.branchName)) {
      body["branchName"] = request.branchName;
    }

    if (!Util.isUnset(request.ref)) {
      body["ref"] = request.ref;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateBranch",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/branches`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateBranchResponse>(await this.callApi(params, req, runtime), new CreateBranchResponse({}));
  }

  /**
   * 创建分支
   * 
   * @param request - CreateBranchRequest
   * @returns CreateBranchResponse
   */
  async createBranch(repositoryId: string, request: CreateBranchRequest): Promise<CreateBranchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createBranchWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 创建变更
   * 
   * @param request - CreateChangeRequestRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateChangeRequestResponse
   */
  async createChangeRequestWithOptions(appName: string, request: CreateChangeRequestRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateChangeRequestResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appCodeRepoSn)) {
      body["appCodeRepoSn"] = request.appCodeRepoSn;
    }

    if (!Util.isUnset(request.autoDeleteBranchWhenEnd)) {
      body["autoDeleteBranchWhenEnd"] = request.autoDeleteBranchWhenEnd;
    }

    if (!Util.isUnset(request.branchName)) {
      body["branchName"] = request.branchName;
    }

    if (!Util.isUnset(request.createBranch)) {
      body["createBranch"] = request.createBranch;
    }

    if (!Util.isUnset(request.ownerAccountId)) {
      body["ownerAccountId"] = request.ownerAccountId;
    }

    if (!Util.isUnset(request.ownerId)) {
      body["ownerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.title)) {
      body["title"] = request.title;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateChangeRequest",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}/changeRequests`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateChangeRequestResponse>(await this.callApi(params, req, runtime), new CreateChangeRequestResponse({}));
  }

  /**
   * 创建变更
   * 
   * @param request - CreateChangeRequestRequest
   * @returns CreateChangeRequestResponse
   */
  async createChangeRequest(appName: string, request: CreateChangeRequestRequest): Promise<CreateChangeRequestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createChangeRequestWithOptions(appName, request, headers, runtime);
  }

  /**
   * 添加检查运行记录
   * 
   * @param request - CreateCheckRunRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateCheckRunResponse
   */
  async createCheckRunWithOptions(request: CreateCheckRunRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateCheckRunResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.annotations)) {
      body["annotations"] = request.annotations;
    }

    if (!Util.isUnset(request.completedAt)) {
      body["completedAt"] = request.completedAt;
    }

    if (!Util.isUnset(request.conclusion)) {
      body["conclusion"] = request.conclusion;
    }

    if (!Util.isUnset(request.detailsUrl)) {
      body["detailsUrl"] = request.detailsUrl;
    }

    if (!Util.isUnset(request.externalId)) {
      body["externalId"] = request.externalId;
    }

    if (!Util.isUnset(request.headSha)) {
      body["headSha"] = request.headSha;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.output)) {
      body["output"] = request.output;
    }

    if (!Util.isUnset(request.startedAt)) {
      body["startedAt"] = request.startedAt;
    }

    if (!Util.isUnset(request.status)) {
      body["status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateCheckRun",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/check_runs/create_check_run`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateCheckRunResponse>(await this.callApi(params, req, runtime), new CreateCheckRunResponse({}));
  }

  /**
   * 添加检查运行记录
   * 
   * @param request - CreateCheckRunRequest
   * @returns CreateCheckRunResponse
   */
  async createCheckRun(request: CreateCheckRunRequest): Promise<CreateCheckRunResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createCheckRunWithOptions(request, headers, runtime);
  }

  /**
   * 创建评论
   * 
   * @param request - CreateCommentRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateCommentResponse
   */
  async createCommentWithOptions(request: CreateCommentRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateCommentResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.localId)) {
      query["localId"] = request.localId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.commentType)) {
      body["commentType"] = request.commentType;
    }

    if (!Util.isUnset(request.content)) {
      body["content"] = request.content;
    }

    if (!Util.isUnset(request.draft)) {
      body["draft"] = request.draft;
    }

    if (!Util.isUnset(request.filePath)) {
      body["filePath"] = request.filePath;
    }

    if (!Util.isUnset(request.lineNumber)) {
      body["lineNumber"] = request.lineNumber;
    }

    if (!Util.isUnset(request.parentCommentBizId)) {
      body["parentCommentBizId"] = request.parentCommentBizId;
    }

    if (!Util.isUnset(request.patchSetBizId)) {
      body["patchSetBizId"] = request.patchSetBizId;
    }

    if (!Util.isUnset(request.resolved)) {
      body["resolved"] = request.resolved;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateComment",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/code_reviews/comments/create_comment`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateCommentResponse>(await this.callApi(params, req, runtime), new CreateCommentResponse({}));
  }

  /**
   * 创建评论
   * 
   * @param request - CreateCommentRequest
   * @returns CreateCommentResponse
   */
  async createComment(request: CreateCommentRequest): Promise<CreateCommentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createCommentWithOptions(request, headers, runtime);
  }

  /**
   * 创建提交状态记录
   * 
   * @param request - CreateCommitStatusRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateCommitStatusResponse
   */
  async createCommitStatusWithOptions(request: CreateCommitStatusRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateCommitStatusResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    if (!Util.isUnset(request.sha)) {
      query["sha"] = request.sha;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.context)) {
      body["context"] = request.context;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.state)) {
      body["state"] = request.state;
    }

    if (!Util.isUnset(request.targetUrl)) {
      body["targetUrl"] = request.targetUrl;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateCommitStatus",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/repository/commit_statuses/create_commit_status`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateCommitStatusResponse>(await this.callApi(params, req, runtime), new CreateCommitStatusResponse({}));
  }

  /**
   * 创建提交状态记录
   * 
   * @param request - CreateCommitStatusRequest
   * @returns CreateCommitStatusResponse
   */
  async createCommitStatus(request: CreateCommitStatusRequest): Promise<CreateCommitStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createCommitStatusWithOptions(request, headers, runtime);
  }

  /**
   * 单提交变更多个文件
   * 
   * @param request - CreateCommitWithMultipleFilesRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateCommitWithMultipleFilesResponse
   */
  async createCommitWithMultipleFilesWithOptions(request: CreateCommitWithMultipleFilesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateCommitWithMultipleFilesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.actions)) {
      body["actions"] = request.actions;
    }

    if (!Util.isUnset(request.branch)) {
      body["branch"] = request.branch;
    }

    if (!Util.isUnset(request.commitMessage)) {
      body["commitMessage"] = request.commitMessage;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateCommitWithMultipleFiles",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/repository/commits/files`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateCommitWithMultipleFilesResponse>(await this.callApi(params, req, runtime), new CreateCommitWithMultipleFilesResponse({}));
  }

  /**
   * 单提交变更多个文件
   * 
   * @param request - CreateCommitWithMultipleFilesRequest
   * @returns CreateCommitWithMultipleFilesResponse
   */
  async createCommitWithMultipleFiles(request: CreateCommitWithMultipleFilesRequest): Promise<CreateCommitWithMultipleFilesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createCommitWithMultipleFilesWithOptions(request, headers, runtime);
  }

  /**
   * 创建部署密钥
   * 
   * @param request - CreateDeployKeyRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDeployKeyResponse
   */
  async createDeployKeyWithOptions(repositoryId: string, request: CreateDeployKeyRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateDeployKeyResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.key)) {
      body["key"] = request.key;
    }

    if (!Util.isUnset(request.title)) {
      body["title"] = request.title;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateDeployKey",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/keys/create`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateDeployKeyResponse>(await this.callApi(params, req, runtime), new CreateDeployKeyResponse({}));
  }

  /**
   * 创建部署密钥
   * 
   * @param request - CreateDeployKeyRequest
   * @returns CreateDeployKeyResponse
   */
  async createDeployKey(repositoryId: string, request: CreateDeployKeyRequest): Promise<CreateDeployKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createDeployKeyWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 创建文件
   * 
   * @param request - CreateFileRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateFileResponse
   */
  async createFileWithOptions(repositoryId: string, request: CreateFileRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateFileResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.branchName)) {
      body["branchName"] = request.branchName;
    }

    if (!Util.isUnset(request.commitMessage)) {
      body["commitMessage"] = request.commitMessage;
    }

    if (!Util.isUnset(request.content)) {
      body["content"] = request.content;
    }

    if (!Util.isUnset(request.encoding)) {
      body["encoding"] = request.encoding;
    }

    if (!Util.isUnset(request.filePath)) {
      body["filePath"] = request.filePath;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateFile",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/files`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateFileResponse>(await this.callApi(params, req, runtime), new CreateFileResponse({}));
  }

  /**
   * 创建文件
   * 
   * @param request - CreateFileRequest
   * @returns CreateFileResponse
   */
  async createFile(repositoryId: string, request: CreateFileRequest): Promise<CreateFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createFileWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 创建标签
   * 
   * @param request - CreateFlowTagRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateFlowTagResponse
   */
  async createFlowTagWithOptions(organizationId: string, request: CreateFlowTagRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateFlowTagResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.color)) {
      query["color"] = request.color;
    }

    if (!Util.isUnset(request.flowTagGroupId)) {
      query["flowTagGroupId"] = request.flowTagGroupId;
    }

    if (!Util.isUnset(request.name)) {
      query["name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateFlowTag",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/flow/tags`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateFlowTagResponse>(await this.callApi(params, req, runtime), new CreateFlowTagResponse({}));
  }

  /**
   * 创建标签
   * 
   * @param request - CreateFlowTagRequest
   * @returns CreateFlowTagResponse
   */
  async createFlowTag(organizationId: string, request: CreateFlowTagRequest): Promise<CreateFlowTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createFlowTagWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 创建标签分类
   * 
   * @param request - CreateFlowTagGroupRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateFlowTagGroupResponse
   */
  async createFlowTagGroupWithOptions(organizationId: string, request: CreateFlowTagGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateFlowTagGroupResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      query["name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateFlowTagGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/flow/tagGroups`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateFlowTagGroupResponse>(await this.callApi(params, req, runtime), new CreateFlowTagGroupResponse({}));
  }

  /**
   * 创建标签分类
   * 
   * @param request - CreateFlowTagGroupRequest
   * @returns CreateFlowTagGroupResponse
   */
  async createFlowTagGroup(organizationId: string, request: CreateFlowTagGroupRequest): Promise<CreateFlowTagGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createFlowTagGroupWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 创建主机组
   * 
   * @param request - CreateHostGroupRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateHostGroupResponse
   */
  async createHostGroupWithOptions(organizationId: string, request: CreateHostGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateHostGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.aliyunRegion)) {
      body["aliyunRegion"] = request.aliyunRegion;
    }

    if (!Util.isUnset(request.ecsLabelKey)) {
      body["ecsLabelKey"] = request.ecsLabelKey;
    }

    if (!Util.isUnset(request.ecsLabelValue)) {
      body["ecsLabelValue"] = request.ecsLabelValue;
    }

    if (!Util.isUnset(request.ecsType)) {
      body["ecsType"] = request.ecsType;
    }

    if (!Util.isUnset(request.envId)) {
      body["envId"] = request.envId;
    }

    if (!Util.isUnset(request.machineInfos)) {
      body["machineInfos"] = request.machineInfos;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.serviceConnectionId)) {
      body["serviceConnectionId"] = request.serviceConnectionId;
    }

    if (!Util.isUnset(request.tagIds)) {
      body["tagIds"] = request.tagIds;
    }

    if (!Util.isUnset(request.type)) {
      body["type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateHostGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/hostGroups`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateHostGroupResponse>(await this.callApi(params, req, runtime), new CreateHostGroupResponse({}));
  }

  /**
   * 创建主机组
   * 
   * @param request - CreateHostGroupRequest
   * @returns CreateHostGroupResponse
   */
  async createHostGroup(organizationId: string, request: CreateHostGroupRequest): Promise<CreateHostGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createHostGroupWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 创建代码评审
   * 
   * @param request - CreateMergeRequestRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateMergeRequestResponse
   */
  async createMergeRequestWithOptions(repositoryId: string, request: CreateMergeRequestRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateMergeRequestResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.createFrom)) {
      body["createFrom"] = request.createFrom;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.reviewerIds)) {
      body["reviewerIds"] = request.reviewerIds;
    }

    if (!Util.isUnset(request.sourceBranch)) {
      body["sourceBranch"] = request.sourceBranch;
    }

    if (!Util.isUnset(request.sourceProjectId)) {
      body["sourceProjectId"] = request.sourceProjectId;
    }

    if (!Util.isUnset(request.targetBranch)) {
      body["targetBranch"] = request.targetBranch;
    }

    if (!Util.isUnset(request.targetProjectId)) {
      body["targetProjectId"] = request.targetProjectId;
    }

    if (!Util.isUnset(request.title)) {
      body["title"] = request.title;
    }

    if (!Util.isUnset(request.workItemIds)) {
      body["workItemIds"] = request.workItemIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateMergeRequest",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/merge_requests`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateMergeRequestResponse>(await this.callApi(params, req, runtime), new CreateMergeRequestResponse({}));
  }

  /**
   * 创建代码评审
   * 
   * @param request - CreateMergeRequestRequest
   * @returns CreateMergeRequestResponse
   */
  async createMergeRequest(repositoryId: string, request: CreateMergeRequestRequest): Promise<CreateMergeRequestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createMergeRequestWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 创建OAuth令牌
   * 
   * @param request - CreateOAuthTokenRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateOAuthTokenResponse
   */
  async createOAuthTokenWithOptions(request: CreateOAuthTokenRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateOAuthTokenResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.clientId)) {
      body["clientId"] = request.clientId;
    }

    if (!Util.isUnset(request.clientSecret)) {
      body["clientSecret"] = request.clientSecret;
    }

    if (!Util.isUnset(request.code)) {
      body["code"] = request.code;
    }

    if (!Util.isUnset(request.grantType)) {
      body["grantType"] = request.grantType;
    }

    if (!Util.isUnset(request.login)) {
      body["login"] = request.login;
    }

    if (!Util.isUnset(request.scope)) {
      body["scope"] = request.scope;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateOAuthToken",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/login/oauth/create`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateOAuthTokenResponse>(await this.callApi(params, req, runtime), new CreateOAuthTokenResponse({}));
  }

  /**
   * 创建OAuth令牌
   * 
   * @param request - CreateOAuthTokenRequest
   * @returns CreateOAuthTokenResponse
   */
  async createOAuthToken(request: CreateOAuthTokenRequest): Promise<CreateOAuthTokenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createOAuthTokenWithOptions(request, headers, runtime);
  }

  /**
   * 创建流水线。
   * 
   * @param request - CreatePipelineRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreatePipelineResponse
   */
  async createPipelineWithOptions(organizationId: string, request: CreatePipelineRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreatePipelineResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.content)) {
      body["content"] = request.content;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreatePipeline",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreatePipelineResponse>(await this.callApi(params, req, runtime), new CreatePipelineResponse({}));
  }

  /**
   * 创建流水线。
   * 
   * @param request - CreatePipelineRequest
   * @returns CreatePipelineResponse
   */
  async createPipeline(organizationId: string, request: CreatePipelineRequest): Promise<CreatePipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createPipelineWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 创建流水线分组
   * 
   * @param request - CreatePipelineGroupRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreatePipelineGroupResponse
   */
  async createPipelineGroupWithOptions(organizationId: string, request: CreatePipelineGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreatePipelineGroupResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      query["name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreatePipelineGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelineGroups`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreatePipelineGroupResponse>(await this.callApi(params, req, runtime), new CreatePipelineGroupResponse({}));
  }

  /**
   * 创建流水线分组
   * 
   * @param request - CreatePipelineGroupRequest
   * @returns CreatePipelineGroupResponse
   */
  async createPipelineGroup(organizationId: string, request: CreatePipelineGroupRequest): Promise<CreatePipelineGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createPipelineGroupWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 创建项目
   * 
   * @param request - CreateProjectRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateProjectResponse
   */
  async createProjectWithOptions(organizationId: string, request: CreateProjectRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateProjectResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.customCode)) {
      body["customCode"] = request.customCode;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.scope)) {
      body["scope"] = request.scope;
    }

    if (!Util.isUnset(request.templateIdentifier)) {
      body["templateIdentifier"] = request.templateIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateProject",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/projects/createProject`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateProjectResponse>(await this.callApi(params, req, runtime), new CreateProjectResponse({}));
  }

  /**
   * 创建项目
   * 
   * @param request - CreateProjectRequest
   * @returns CreateProjectResponse
   */
  async createProject(organizationId: string, request: CreateProjectRequest): Promise<CreateProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createProjectWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 创建代码库Label
   * 
   * @param request - CreateProjectLabelRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateProjectLabelResponse
   */
  async createProjectLabelWithOptions(request: CreateProjectLabelRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateProjectLabelResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.color)) {
      body["color"] = request.color;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateProjectLabel",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/labels`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateProjectLabelResponse>(await this.callApi(params, req, runtime), new CreateProjectLabelResponse({}));
  }

  /**
   * 创建代码库Label
   * 
   * @param request - CreateProjectLabelRequest
   * @returns CreateProjectLabelResponse
   */
  async createProjectLabel(request: CreateProjectLabelRequest): Promise<CreateProjectLabelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createProjectLabelWithOptions(request, headers, runtime);
  }

  /**
   * 创建保护分支
   * 
   * @param request - CreateProtectdBranchRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateProtectdBranchResponse
   */
  async createProtectdBranchWithOptions(repositoryId: string, request: CreateProtectdBranchRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateProtectdBranchResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.allowMergeRoles)) {
      body["allowMergeRoles"] = request.allowMergeRoles;
    }

    if (!Util.isUnset(request.allowMergeUserIds)) {
      body["allowMergeUserIds"] = request.allowMergeUserIds;
    }

    if (!Util.isUnset(request.allowPushRoles)) {
      body["allowPushRoles"] = request.allowPushRoles;
    }

    if (!Util.isUnset(request.allowPushUserIds)) {
      body["allowPushUserIds"] = request.allowPushUserIds;
    }

    if (!Util.isUnset(request.branch)) {
      body["branch"] = request.branch;
    }

    if (!Util.isUnset(request.id)) {
      body["id"] = request.id;
    }

    if (!Util.isUnset(request.mergeRequestSetting)) {
      body["mergeRequestSetting"] = request.mergeRequestSetting;
    }

    if (!Util.isUnset(request.testSettingDTO)) {
      body["testSettingDTO"] = request.testSettingDTO;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateProtectdBranch",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/protect_branches`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateProtectdBranchResponse>(await this.callApi(params, req, runtime), new CreateProtectdBranchResponse({}));
  }

  /**
   * 创建保护分支
   * 
   * @param request - CreateProtectdBranchRequest
   * @returns CreateProtectdBranchResponse
   */
  async createProtectdBranch(repositoryId: string, request: CreateProtectdBranchRequest): Promise<CreateProtectdBranchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createProtectdBranchWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 创建推送规则
   * 
   * @param request - CreatePushRuleRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreatePushRuleResponse
   */
  async createPushRuleWithOptions(repositoryId: string, request: CreatePushRuleRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreatePushRuleResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.ruleInfos)) {
      body["ruleInfos"] = request.ruleInfos;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreatePushRule",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/push_rule`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreatePushRuleResponse>(await this.callApi(params, req, runtime), new CreatePushRuleResponse({}));
  }

  /**
   * 创建推送规则
   * 
   * @param request - CreatePushRuleRequest
   * @returns CreatePushRuleResponse
   */
  async createPushRule(repositoryId: string, request: CreatePushRuleRequest): Promise<CreatePushRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createPushRuleWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 创建(导入)代码库
   * 
   * @param request - CreateRepositoryRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRepositoryResponse
   */
  async createRepositoryWithOptions(request: CreateRepositoryRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateRepositoryResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.createParentPath)) {
      query["createParentPath"] = request.createParentPath;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.sync)) {
      query["sync"] = request.sync;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.avatarUrl)) {
      body["avatarUrl"] = request.avatarUrl;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.gitignoreType)) {
      body["gitignoreType"] = request.gitignoreType;
    }

    if (!Util.isUnset(request.importAccount)) {
      body["importAccount"] = request.importAccount;
    }

    if (!Util.isUnset(request.importDemoProject)) {
      body["importDemoProject"] = request.importDemoProject;
    }

    if (!Util.isUnset(request.importRepoType)) {
      body["importRepoType"] = request.importRepoType;
    }

    if (!Util.isUnset(request.importToken)) {
      body["importToken"] = request.importToken;
    }

    if (!Util.isUnset(request.importTokenEncrypted)) {
      body["importTokenEncrypted"] = request.importTokenEncrypted;
    }

    if (!Util.isUnset(request.importUrl)) {
      body["importUrl"] = request.importUrl;
    }

    if (!Util.isUnset(request.initStandardService)) {
      body["initStandardService"] = request.initStandardService;
    }

    if (!Util.isUnset(request.isCryptoEnabled)) {
      body["isCryptoEnabled"] = request.isCryptoEnabled;
    }

    if (!Util.isUnset(request.localImportUrl)) {
      body["localImportUrl"] = request.localImportUrl;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.namespaceId)) {
      body["namespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.path)) {
      body["path"] = request.path;
    }

    if (!Util.isUnset(request.readmeType)) {
      body["readmeType"] = request.readmeType;
    }

    if (!Util.isUnset(request.visibilityLevel)) {
      body["visibilityLevel"] = request.visibilityLevel;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateRepository",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/create`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateRepositoryResponse>(await this.callApi(params, req, runtime), new CreateRepositoryResponse({}));
  }

  /**
   * 创建(导入)代码库
   * 
   * @param request - CreateRepositoryRequest
   * @returns CreateRepositoryResponse
   */
  async createRepository(request: CreateRepositoryRequest): Promise<CreateRepositoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createRepositoryWithOptions(request, headers, runtime);
  }

  /**
   * 创建代码组
   * 
   * @param request - CreateRepositoryGroupRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRepositoryGroupResponse
   */
  async createRepositoryGroupWithOptions(request: CreateRepositoryGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateRepositoryGroupResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.avatarUrl)) {
      body["avatarUrl"] = request.avatarUrl;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.parentId)) {
      body["parentId"] = request.parentId;
    }

    if (!Util.isUnset(request.path)) {
      body["path"] = request.path;
    }

    if (!Util.isUnset(request.visibilityLevel)) {
      body["visibilityLevel"] = request.visibilityLevel;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateRepositoryGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/groups/create`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateRepositoryGroupResponse>(await this.callApi(params, req, runtime), new CreateRepositoryGroupResponse({}));
  }

  /**
   * 创建代码组
   * 
   * @param request - CreateRepositoryGroupRequest
   * @returns CreateRepositoryGroupResponse
   */
  async createRepositoryGroup(request: CreateRepositoryGroupRequest): Promise<CreateRepositoryGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createRepositoryGroupWithOptions(request, headers, runtime);
  }

  /**
   * 插入资源成员
   * 
   * @param request - CreateResourceMemberRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateResourceMemberResponse
   */
  async createResourceMemberWithOptions(organizationId: string, resourceType: string, resourceId: string, request: CreateResourceMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateResourceMemberResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accountId)) {
      body["accountId"] = request.accountId;
    }

    if (!Util.isUnset(request.roleName)) {
      body["roleName"] = request.roleName;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateResourceMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/${OpenApiUtil.getEncodeParam(resourceType)}/${OpenApiUtil.getEncodeParam(resourceId)}/members`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateResourceMemberResponse>(await this.callApi(params, req, runtime), new CreateResourceMemberResponse({}));
  }

  /**
   * 插入资源成员
   * 
   * @param request - CreateResourceMemberRequest
   * @returns CreateResourceMemberResponse
   */
  async createResourceMember(organizationId: string, resourceType: string, resourceId: string, request: CreateResourceMemberRequest): Promise<CreateResourceMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createResourceMemberWithOptions(organizationId, resourceType, resourceId, request, headers, runtime);
  }

  /**
   * 创建服务授权
   * 
   * @param request - CreateServiceAuthRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateServiceAuthResponse
   */
  async createServiceAuthWithOptions(organizationId: string, request: CreateServiceAuthRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateServiceAuthResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.serviceAuthType)) {
      query["serviceAuthType"] = request.serviceAuthType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateServiceAuth",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/serviceAuths`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateServiceAuthResponse>(await this.callApi(params, req, runtime), new CreateServiceAuthResponse({}));
  }

  /**
   * 创建服务授权
   * 
   * @param request - CreateServiceAuthRequest
   * @returns CreateServiceAuthResponse
   */
  async createServiceAuth(organizationId: string, request: CreateServiceAuthRequest): Promise<CreateServiceAuthResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createServiceAuthWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 创建服务连接
   * 
   * @param request - CreateServiceConnectionRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateServiceConnectionResponse
   */
  async createServiceConnectionWithOptions(organizationId: string, request: CreateServiceConnectionRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateServiceConnectionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.authType)) {
      body["authType"] = request.authType;
    }

    if (!Util.isUnset(request.connectionName)) {
      body["connectionName"] = request.connectionName;
    }

    if (!Util.isUnset(request.connectionType)) {
      body["connectionType"] = request.connectionType;
    }

    if (!Util.isUnset(request.scope)) {
      body["scope"] = request.scope;
    }

    if (!Util.isUnset(request.serviceAuthId)) {
      body["serviceAuthId"] = request.serviceAuthId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateServiceConnection",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/createServiceConnection`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateServiceConnectionResponse>(await this.callApi(params, req, runtime), new CreateServiceConnectionResponse({}));
  }

  /**
   * 创建服务连接
   * 
   * @param request - CreateServiceConnectionRequest
   * @returns CreateServiceConnectionResponse
   */
  async createServiceConnection(organizationId: string, request: CreateServiceConnectionRequest): Promise<CreateServiceConnectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createServiceConnectionWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 创建用户名密码类型的证书
   * 
   * @param request - CreateServiceCredentialRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateServiceCredentialResponse
   */
  async createServiceCredentialWithOptions(organizationId: string, request: CreateServiceCredentialRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateServiceCredentialResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.password)) {
      body["password"] = request.password;
    }

    if (!Util.isUnset(request.scope)) {
      body["scope"] = request.scope;
    }

    if (!Util.isUnset(request.type)) {
      body["type"] = request.type;
    }

    if (!Util.isUnset(request.username)) {
      body["username"] = request.username;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateServiceCredential",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/serviceCredentials`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateServiceCredentialResponse>(await this.callApi(params, req, runtime), new CreateServiceCredentialResponse({}));
  }

  /**
   * 创建用户名密码类型的证书
   * 
   * @param request - CreateServiceCredentialRequest
   * @returns CreateServiceCredentialResponse
   */
  async createServiceCredential(organizationId: string, request: CreateServiceCredentialRequest): Promise<CreateServiceCredentialResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createServiceCredentialWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 创建迭代
   * 
   * @param request - CreateSprintRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSprintResponse
   */
  async createSprintWithOptions(organizationId: string, request: CreateSprintRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateSprintResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endDate)) {
      body["endDate"] = request.endDate;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.spaceIdentifier)) {
      body["spaceIdentifier"] = request.spaceIdentifier;
    }

    if (!Util.isUnset(request.staffIds)) {
      body["staffIds"] = request.staffIds;
    }

    if (!Util.isUnset(request.startDate)) {
      body["startDate"] = request.startDate;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateSprint",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/sprints/create`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateSprintResponse>(await this.callApi(params, req, runtime), new CreateSprintResponse({}));
  }

  /**
   * 创建迭代
   * 
   * @param request - CreateSprintRequest
   * @returns CreateSprintResponse
   */
  async createSprint(organizationId: string, request: CreateSprintRequest): Promise<CreateSprintResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createSprintWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 创建企业公钥
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSshKeyResponse
   */
  async createSshKeyWithOptions(organizationId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateSshKeyResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "CreateSshKey",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/sshKey`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateSshKeyResponse>(await this.callApi(params, req, runtime), new CreateSshKeyResponse({}));
  }

  /**
   * 创建企业公钥
   * @returns CreateSshKeyResponse
   */
  async createSshKey(organizationId: string): Promise<CreateSshKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createSshKeyWithOptions(organizationId, headers, runtime);
  }

  /**
   * 创建标签Tag
   * 
   * @param request - CreateTagRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTagResponse
   */
  async createTagWithOptions(repositoryId: string, request: CreateTagRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateTagResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.message)) {
      body["message"] = request.message;
    }

    if (!Util.isUnset(request.ref)) {
      body["ref"] = request.ref;
    }

    if (!Util.isUnset(request.tagName)) {
      body["tagName"] = request.tagName;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateTag",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/tags/create`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateTagResponse>(await this.callApi(params, req, runtime), new CreateTagResponse({}));
  }

  /**
   * 创建标签Tag
   * 
   * @param request - CreateTagRequest
   * @returns CreateTagResponse
   */
  async createTag(repositoryId: string, request: CreateTagRequest): Promise<CreateTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createTagWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 创建测试用例
   * 
   * @param request - CreateTestCaseRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTestCaseResponse
   */
  async createTestCaseWithOptions(organizationId: string, request: CreateTestCaseRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateTestCaseResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.assignedTo)) {
      body["assignedTo"] = request.assignedTo;
    }

    if (!Util.isUnset(request.directoryIdentifier)) {
      body["directoryIdentifier"] = request.directoryIdentifier;
    }

    if (!Util.isUnset(request.fieldValueList)) {
      body["fieldValueList"] = request.fieldValueList;
    }

    if (!Util.isUnset(request.priority)) {
      body["priority"] = request.priority;
    }

    if (!Util.isUnset(request.spaceIdentifier)) {
      body["spaceIdentifier"] = request.spaceIdentifier;
    }

    if (!Util.isUnset(request.subject)) {
      body["subject"] = request.subject;
    }

    if (!Util.isUnset(request.tags)) {
      body["tags"] = request.tags;
    }

    if (!Util.isUnset(request.testcaseStepContentInfo)) {
      body["testcaseStepContentInfo"] = request.testcaseStepContentInfo;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateTestCase",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/testhub/testcase`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateTestCaseResponse>(await this.callApi(params, req, runtime), new CreateTestCaseResponse({}));
  }

  /**
   * 创建测试用例
   * 
   * @param request - CreateTestCaseRequest
   * @returns CreateTestCaseResponse
   */
  async createTestCase(organizationId: string, request: CreateTestCaseRequest): Promise<CreateTestCaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createTestCaseWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 创建SSH Key密钥
   * 
   * @param request - CreateUserKeyRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateUserKeyResponse
   */
  async createUserKeyWithOptions(request: CreateUserKeyRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateUserKeyResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.expireTime)) {
      body["expireTime"] = request.expireTime;
    }

    if (!Util.isUnset(request.keyScope)) {
      body["keyScope"] = request.keyScope;
    }

    if (!Util.isUnset(request.publicKey)) {
      body["publicKey"] = request.publicKey;
    }

    if (!Util.isUnset(request.title)) {
      body["title"] = request.title;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateUserKey",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v3/user/keys/create`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateUserKeyResponse>(await this.callApi(params, req, runtime), new CreateUserKeyResponse({}));
  }

  /**
   * 创建SSH Key密钥
   * 
   * @param request - CreateUserKeyRequest
   * @returns CreateUserKeyResponse
   */
  async createUserKey(request: CreateUserKeyRequest): Promise<CreateUserKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createUserKeyWithOptions(request, headers, runtime);
  }

  /**
   * 创建变量组
   * 
   * @param request - CreateVariableGroupRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateVariableGroupResponse
   */
  async createVariableGroupWithOptions(organizationId: string, request: CreateVariableGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateVariableGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.variables)) {
      body["variables"] = request.variables;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateVariableGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/variableGroups`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateVariableGroupResponse>(await this.callApi(params, req, runtime), new CreateVariableGroupResponse({}));
  }

  /**
   * 创建变量组
   * 
   * @param request - CreateVariableGroupRequest
   * @returns CreateVariableGroupResponse
   */
  async createVariableGroup(organizationId: string, request: CreateVariableGroupRequest): Promise<CreateVariableGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createVariableGroupWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 新建工作项
   * 
   * @param request - CreateWorkitemRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateWorkitemResponse
   */
  async createWorkitemWithOptions(organizationId: string, request: CreateWorkitemRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateWorkitemResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.assignedTo)) {
      body["assignedTo"] = request.assignedTo;
    }

    if (!Util.isUnset(request.category)) {
      body["category"] = request.category;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.descriptionFormat)) {
      body["descriptionFormat"] = request.descriptionFormat;
    }

    if (!Util.isUnset(request.fieldValueList)) {
      body["fieldValueList"] = request.fieldValueList;
    }

    if (!Util.isUnset(request.parent)) {
      body["parent"] = request.parent;
    }

    if (!Util.isUnset(request.participant)) {
      body["participant"] = request.participant;
    }

    if (!Util.isUnset(request.space)) {
      body["space"] = request.space;
    }

    if (!Util.isUnset(request.spaceIdentifier)) {
      body["spaceIdentifier"] = request.spaceIdentifier;
    }

    if (!Util.isUnset(request.spaceType)) {
      body["spaceType"] = request.spaceType;
    }

    if (!Util.isUnset(request.sprint)) {
      body["sprint"] = request.sprint;
    }

    if (!Util.isUnset(request.subject)) {
      body["subject"] = request.subject;
    }

    if (!Util.isUnset(request.tracker)) {
      body["tracker"] = request.tracker;
    }

    if (!Util.isUnset(request.verifier)) {
      body["verifier"] = request.verifier;
    }

    if (!Util.isUnset(request.workitemType)) {
      body["workitemType"] = request.workitemType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateWorkitem",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/create`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateWorkitemResponse>(await this.callApi(params, req, runtime), new CreateWorkitemResponse({}));
  }

  /**
   * 新建工作项
   * 
   * @param request - CreateWorkitemRequest
   * @returns CreateWorkitemResponse
   */
  async createWorkitem(organizationId: string, request: CreateWorkitemRequest): Promise<CreateWorkitemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createWorkitemWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 创建一个评论
   * 
   * @param request - CreateWorkitemCommentRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateWorkitemCommentResponse
   */
  async createWorkitemCommentWithOptions(organizationId: string, request: CreateWorkitemCommentRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateWorkitemCommentResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.content)) {
      body["content"] = request.content;
    }

    if (!Util.isUnset(request.formatType)) {
      body["formatType"] = request.formatType;
    }

    if (!Util.isUnset(request.parentId)) {
      body["parentId"] = request.parentId;
    }

    if (!Util.isUnset(request.workitemIdentifier)) {
      body["workitemIdentifier"] = request.workitemIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateWorkitemComment",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/comment`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateWorkitemCommentResponse>(await this.callApi(params, req, runtime), new CreateWorkitemCommentResponse({}));
  }

  /**
   * 创建一个评论
   * 
   * @param request - CreateWorkitemCommentRequest
   * @returns CreateWorkitemCommentResponse
   */
  async createWorkitemComment(organizationId: string, request: CreateWorkitemCommentRequest): Promise<CreateWorkitemCommentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createWorkitemCommentWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 登记预计工时
   * 
   * @param request - CreateWorkitemEstimateRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateWorkitemEstimateResponse
   */
  async createWorkitemEstimateWithOptions(organizationId: string, request: CreateWorkitemEstimateRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateWorkitemEstimateResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.recordUserIdentifier)) {
      body["recordUserIdentifier"] = request.recordUserIdentifier;
    }

    if (!Util.isUnset(request.spentTime)) {
      body["spentTime"] = request.spentTime;
    }

    if (!Util.isUnset(request.type)) {
      body["type"] = request.type;
    }

    if (!Util.isUnset(request.workitemIdentifier)) {
      body["workitemIdentifier"] = request.workitemIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateWorkitemEstimate",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/estimate`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateWorkitemEstimateResponse>(await this.callApi(params, req, runtime), new CreateWorkitemEstimateResponse({}));
  }

  /**
   * 登记预计工时
   * 
   * @param request - CreateWorkitemEstimateRequest
   * @returns CreateWorkitemEstimateResponse
   */
  async createWorkitemEstimate(organizationId: string, request: CreateWorkitemEstimateRequest): Promise<CreateWorkitemEstimateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createWorkitemEstimateWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 登记实际工时
   * 
   * @param request - CreateWorkitemRecordRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateWorkitemRecordResponse
   */
  async createWorkitemRecordWithOptions(organizationId: string, request: CreateWorkitemRecordRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateWorkitemRecordResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.actualTime)) {
      body["actualTime"] = request.actualTime;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.gmtEnd)) {
      body["gmtEnd"] = request.gmtEnd;
    }

    if (!Util.isUnset(request.gmtStart)) {
      body["gmtStart"] = request.gmtStart;
    }

    if (!Util.isUnset(request.recordUserIdentifier)) {
      body["recordUserIdentifier"] = request.recordUserIdentifier;
    }

    if (!Util.isUnset(request.type)) {
      body["type"] = request.type;
    }

    if (!Util.isUnset(request.workitemIdentifier)) {
      body["workitemIdentifier"] = request.workitemIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateWorkitemRecord",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/record`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateWorkitemRecordResponse>(await this.callApi(params, req, runtime), new CreateWorkitemRecordResponse({}));
  }

  /**
   * 登记实际工时
   * 
   * @param request - CreateWorkitemRecordRequest
   * @returns CreateWorkitemRecordResponse
   */
  async createWorkitemRecord(organizationId: string, request: CreateWorkitemRecordRequest): Promise<CreateWorkitemRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createWorkitemRecordWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 创建工作项
   * 
   * @param request - CreateWorkitemV2Request
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateWorkitemV2Response
   */
  async createWorkitemV2WithOptions(organizationId: string, request: CreateWorkitemV2Request, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateWorkitemV2Response> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.assignedTo)) {
      body["assignedTo"] = request.assignedTo;
    }

    if (!Util.isUnset(request.category)) {
      body["category"] = request.category;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.fieldValueList)) {
      body["fieldValueList"] = request.fieldValueList;
    }

    if (!Util.isUnset(request.parentIdentifier)) {
      body["parentIdentifier"] = request.parentIdentifier;
    }

    if (!Util.isUnset(request.participants)) {
      body["participants"] = request.participants;
    }

    if (!Util.isUnset(request.spaceIdentifier)) {
      body["spaceIdentifier"] = request.spaceIdentifier;
    }

    if (!Util.isUnset(request.sprintIdentifier)) {
      body["sprintIdentifier"] = request.sprintIdentifier;
    }

    if (!Util.isUnset(request.subject)) {
      body["subject"] = request.subject;
    }

    if (!Util.isUnset(request.tags)) {
      body["tags"] = request.tags;
    }

    if (!Util.isUnset(request.trackers)) {
      body["trackers"] = request.trackers;
    }

    if (!Util.isUnset(request.verifier)) {
      body["verifier"] = request.verifier;
    }

    if (!Util.isUnset(request.versions)) {
      body["versions"] = request.versions;
    }

    if (!Util.isUnset(request.workitemTypeIdentifier)) {
      body["workitemTypeIdentifier"] = request.workitemTypeIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateWorkitemV2",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitem`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateWorkitemV2Response>(await this.callApi(params, req, runtime), new CreateWorkitemV2Response({}));
  }

  /**
   * 创建工作项
   * 
   * @param request - CreateWorkitemV2Request
   * @returns CreateWorkitemV2Response
   */
  async createWorkitemV2(organizationId: string, request: CreateWorkitemV2Request): Promise<CreateWorkitemV2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createWorkitemV2WithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 创建工作空间
   * 
   * @param request - CreateWorkspaceRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateWorkspaceResponse
   */
  async createWorkspaceWithOptions(request: CreateWorkspaceRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<CreateWorkspaceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.codeUrl)) {
      body["codeUrl"] = request.codeUrl;
    }

    if (!Util.isUnset(request.codeVersion)) {
      body["codeVersion"] = request.codeVersion;
    }

    if (!Util.isUnset(request.filePath)) {
      body["filePath"] = request.filePath;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.requestFrom)) {
      body["requestFrom"] = request.requestFrom;
    }

    if (!Util.isUnset(request.resourceIdentifier)) {
      body["resourceIdentifier"] = request.resourceIdentifier;
    }

    if (!Util.isUnset(request.reuse)) {
      body["reuse"] = request.reuse;
    }

    if (!Util.isUnset(request.workspaceTemplate)) {
      body["workspaceTemplate"] = request.workspaceTemplate;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateWorkspace",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/workspaces`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateWorkspaceResponse>(await this.callApi(params, req, runtime), new CreateWorkspaceResponse({}));
  }

  /**
   * 创建工作空间
   * 
   * @param request - CreateWorkspaceRequest
   * @returns CreateWorkspaceResponse
   */
  async createWorkspace(request: CreateWorkspaceRequest): Promise<CreateWorkspaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.createWorkspaceWithOptions(request, headers, runtime);
  }

  /**
   * 删除应用成员
   * 
   * @param request - DeleteAppMemberRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteAppMemberResponse
   */
  async deleteAppMemberWithOptions(appName: string, request: DeleteAppMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteAppMemberResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.subjectId)) {
      query["subjectId"] = request.subjectId;
    }

    if (!Util.isUnset(request.subjectType)) {
      query["subjectType"] = request.subjectType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAppMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}/members`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "string",
    });
    return $tea.cast<DeleteAppMemberResponse>(await this.callApi(params, req, runtime), new DeleteAppMemberResponse({}));
  }

  /**
   * 删除应用成员
   * 
   * @param request - DeleteAppMemberRequest
   * @returns DeleteAppMemberResponse
   */
  async deleteAppMember(appName: string, request: DeleteAppMemberRequest): Promise<DeleteAppMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteAppMemberWithOptions(appName, request, headers, runtime);
  }

  /**
   * 删除分支
   * 
   * @param request - DeleteBranchRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteBranchResponse
   */
  async deleteBranchWithOptions(repositoryId: string, request: DeleteBranchRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteBranchResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.branchName)) {
      query["branchName"] = request.branchName;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteBranch",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/branches/delete`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteBranchResponse>(await this.callApi(params, req, runtime), new DeleteBranchResponse({}));
  }

  /**
   * 删除分支
   * 
   * @param request - DeleteBranchRequest
   * @returns DeleteBranchResponse
   */
  async deleteBranch(repositoryId: string, request: DeleteBranchRequest): Promise<DeleteBranchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteBranchWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 删除文件
   * 
   * @param request - DeleteFileRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteFileResponse
   */
  async deleteFileWithOptions(repositoryId: string, request: DeleteFileRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteFileResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.branchName)) {
      query["branchName"] = request.branchName;
    }

    if (!Util.isUnset(request.commitMessage)) {
      query["commitMessage"] = request.commitMessage;
    }

    if (!Util.isUnset(request.filePath)) {
      query["filePath"] = request.filePath;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteFile",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/files/delete`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteFileResponse>(await this.callApi(params, req, runtime), new DeleteFileResponse({}));
  }

  /**
   * 删除文件
   * 
   * @param request - DeleteFileRequest
   * @returns DeleteFileResponse
   */
  async deleteFile(repositoryId: string, request: DeleteFileRequest): Promise<DeleteFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteFileWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 删除标签
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteFlowTagResponse
   */
  async deleteFlowTagWithOptions(organizationId: string, id: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteFlowTagResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "DeleteFlowTag",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/flow/tags/${OpenApiUtil.getEncodeParam(id)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteFlowTagResponse>(await this.callApi(params, req, runtime), new DeleteFlowTagResponse({}));
  }

  /**
   * 删除标签
   * @returns DeleteFlowTagResponse
   */
  async deleteFlowTag(organizationId: string, id: string): Promise<DeleteFlowTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteFlowTagWithOptions(organizationId, id, headers, runtime);
  }

  /**
   * 删除标签分类
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteFlowTagGroupResponse
   */
  async deleteFlowTagGroupWithOptions(organizationId: string, id: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteFlowTagGroupResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "DeleteFlowTagGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/flow/tagGroups/${OpenApiUtil.getEncodeParam(id)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteFlowTagGroupResponse>(await this.callApi(params, req, runtime), new DeleteFlowTagGroupResponse({}));
  }

  /**
   * 删除标签分类
   * @returns DeleteFlowTagGroupResponse
   */
  async deleteFlowTagGroup(organizationId: string, id: string): Promise<DeleteFlowTagGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteFlowTagGroupWithOptions(organizationId, id, headers, runtime);
  }

  /**
   * 删除组成员
   * 
   * @param request - DeleteGroupMemberRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteGroupMemberResponse
   */
  async deleteGroupMemberWithOptions(groupId: string, request: DeleteGroupMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteGroupMemberResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.aliyunPk)) {
      query["aliyunPk"] = request.aliyunPk;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.memberType)) {
      body["memberType"] = request.memberType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteGroupMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/groups/${OpenApiUtil.getEncodeParam(groupId)}/members/remove/aliyun_pk`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteGroupMemberResponse>(await this.callApi(params, req, runtime), new DeleteGroupMemberResponse({}));
  }

  /**
   * 删除组成员
   * 
   * @param request - DeleteGroupMemberRequest
   * @returns DeleteGroupMemberResponse
   */
  async deleteGroupMember(groupId: string, request: DeleteGroupMemberRequest): Promise<DeleteGroupMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteGroupMemberWithOptions(groupId, request, headers, runtime);
  }

  /**
   * 删除主机组
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteHostGroupResponse
   */
  async deleteHostGroupWithOptions(organizationId: string, id: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteHostGroupResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "DeleteHostGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/hostGroups/${OpenApiUtil.getEncodeParam(id)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteHostGroupResponse>(await this.callApi(params, req, runtime), new DeleteHostGroupResponse({}));
  }

  /**
   * 删除主机组
   * @returns DeleteHostGroupResponse
   */
  async deleteHostGroup(organizationId: string, id: string): Promise<DeleteHostGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteHostGroupWithOptions(organizationId, id, headers, runtime);
  }

  /**
   * 删除流水线
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeletePipelineResponse
   */
  async deletePipelineWithOptions(organizationId: string, pipelineId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeletePipelineResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "DeletePipeline",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeletePipelineResponse>(await this.callApi(params, req, runtime), new DeletePipelineResponse({}));
  }

  /**
   * 删除流水线
   * @returns DeletePipelineResponse
   */
  async deletePipeline(organizationId: string, pipelineId: string): Promise<DeletePipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deletePipelineWithOptions(organizationId, pipelineId, headers, runtime);
  }

  /**
   * 删除流水线分组
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeletePipelineGroupResponse
   */
  async deletePipelineGroupWithOptions(organizationId: string, groupId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeletePipelineGroupResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "DeletePipelineGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelineGroups/${OpenApiUtil.getEncodeParam(groupId)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeletePipelineGroupResponse>(await this.callApi(params, req, runtime), new DeletePipelineGroupResponse({}));
  }

  /**
   * 删除流水线分组
   * @returns DeletePipelineGroupResponse
   */
  async deletePipelineGroup(organizationId: string, groupId: string): Promise<DeletePipelineGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deletePipelineGroupWithOptions(organizationId, groupId, headers, runtime);
  }

  /**
   * 删除流水线关联
   * 
   * @param request - DeletePipelineRelationsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeletePipelineRelationsResponse
   */
  async deletePipelineRelationsWithOptions(organizationId: string, pipelineId: string, request: DeletePipelineRelationsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeletePipelineRelationsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.relObjectId)) {
      query["relObjectId"] = request.relObjectId;
    }

    if (!Util.isUnset(request.relObjectType)) {
      query["relObjectType"] = request.relObjectType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeletePipelineRelations",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRelations`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeletePipelineRelationsResponse>(await this.callApi(params, req, runtime), new DeletePipelineRelationsResponse({}));
  }

  /**
   * 删除流水线关联
   * 
   * @param request - DeletePipelineRelationsRequest
   * @returns DeletePipelineRelationsResponse
   */
  async deletePipelineRelations(organizationId: string, pipelineId: string, request: DeletePipelineRelationsRequest): Promise<DeletePipelineRelationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deletePipelineRelationsWithOptions(organizationId, pipelineId, request, headers, runtime);
  }

  /**
   * 删除项目
   * 
   * @param request - DeleteProjectRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteProjectResponse
   */
  async deleteProjectWithOptions(organizationId: string, request: DeleteProjectRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteProjectResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.identifier)) {
      query["identifier"] = request.identifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteProject",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/projects/delete`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteProjectResponse>(await this.callApi(params, req, runtime), new DeleteProjectResponse({}));
  }

  /**
   * 删除项目
   * 
   * @param request - DeleteProjectRequest
   * @returns DeleteProjectResponse
   */
  async deleteProject(organizationId: string, request: DeleteProjectRequest): Promise<DeleteProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteProjectWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 删除代码库Label
   * 
   * @param request - DeleteProjectLabelRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteProjectLabelResponse
   */
  async deleteProjectLabelWithOptions(labelId: string, request: DeleteProjectLabelRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteProjectLabelResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteProjectLabel",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/labels/${OpenApiUtil.getEncodeParam(labelId)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteProjectLabelResponse>(await this.callApi(params, req, runtime), new DeleteProjectLabelResponse({}));
  }

  /**
   * 删除代码库Label
   * 
   * @param request - DeleteProjectLabelRequest
   * @returns DeleteProjectLabelResponse
   */
  async deleteProjectLabel(labelId: string, request: DeleteProjectLabelRequest): Promise<DeleteProjectLabelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteProjectLabelWithOptions(labelId, request, headers, runtime);
  }

  /**
   * 删除保护分支
   * 
   * @param request - DeleteProtectedBranchRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteProtectedBranchResponse
   */
  async deleteProtectedBranchWithOptions(repositoryId: string, protectedBranchId: string, request: DeleteProtectedBranchRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteProtectedBranchResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteProtectedBranch",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/protect_branches/${OpenApiUtil.getEncodeParam(protectedBranchId)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteProtectedBranchResponse>(await this.callApi(params, req, runtime), new DeleteProtectedBranchResponse({}));
  }

  /**
   * 删除保护分支
   * 
   * @param request - DeleteProtectedBranchRequest
   * @returns DeleteProtectedBranchResponse
   */
  async deleteProtectedBranch(repositoryId: string, protectedBranchId: string, request: DeleteProtectedBranchRequest): Promise<DeleteProtectedBranchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteProtectedBranchWithOptions(repositoryId, protectedBranchId, request, headers, runtime);
  }

  /**
   * 删除推送规则
   * 
   * @param request - DeletePushRuleRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeletePushRuleResponse
   */
  async deletePushRuleWithOptions(repositoryId: string, pushRuleId: string, request: DeletePushRuleRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeletePushRuleResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeletePushRule",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/push_rule/${OpenApiUtil.getEncodeParam(pushRuleId)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeletePushRuleResponse>(await this.callApi(params, req, runtime), new DeletePushRuleResponse({}));
  }

  /**
   * 删除推送规则
   * 
   * @param request - DeletePushRuleRequest
   * @returns DeletePushRuleResponse
   */
  async deletePushRule(repositoryId: string, pushRuleId: string, request: DeletePushRuleRequest): Promise<DeletePushRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deletePushRuleWithOptions(repositoryId, pushRuleId, request, headers, runtime);
  }

  /**
   * 删除代码库
   * 
   * @param request - DeleteRepositoryRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRepositoryResponse
   */
  async deleteRepositoryWithOptions(repositoryId: string, request: DeleteRepositoryRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteRepositoryResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.reason)) {
      body["reason"] = request.reason;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRepository",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/remove`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteRepositoryResponse>(await this.callApi(params, req, runtime), new DeleteRepositoryResponse({}));
  }

  /**
   * 删除代码库
   * 
   * @param request - DeleteRepositoryRequest
   * @returns DeleteRepositoryResponse
   */
  async deleteRepository(repositoryId: string, request: DeleteRepositoryRequest): Promise<DeleteRepositoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteRepositoryWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 删除代码组
   * 
   * @param request - DeleteRepositoryGroupRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRepositoryGroupResponse
   */
  async deleteRepositoryGroupWithOptions(groupId: string, request: DeleteRepositoryGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteRepositoryGroupResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.reason)) {
      body["reason"] = request.reason;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRepositoryGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/groups/${OpenApiUtil.getEncodeParam(groupId)}/remove`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteRepositoryGroupResponse>(await this.callApi(params, req, runtime), new DeleteRepositoryGroupResponse({}));
  }

  /**
   * 删除代码组
   * 
   * @param request - DeleteRepositoryGroupRequest
   * @returns DeleteRepositoryGroupResponse
   */
  async deleteRepositoryGroup(groupId: string, request: DeleteRepositoryGroupRequest): Promise<DeleteRepositoryGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteRepositoryGroupWithOptions(groupId, request, headers, runtime);
  }

  /**
   * 删除代码库成员
   * 
   * @param request - DeleteRepositoryMemberRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRepositoryMemberResponse
   */
  async deleteRepositoryMemberWithOptions(repositoryId: string, aliyunPk: string, request: DeleteRepositoryMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteRepositoryMemberResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.memberType)) {
      body["memberType"] = request.memberType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRepositoryMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/members/delete/${OpenApiUtil.getEncodeParam(aliyunPk)}`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteRepositoryMemberResponse>(await this.callApi(params, req, runtime), new DeleteRepositoryMemberResponse({}));
  }

  /**
   * 删除代码库成员
   * 
   * @param request - DeleteRepositoryMemberRequest
   * @returns DeleteRepositoryMemberResponse
   */
  async deleteRepositoryMember(repositoryId: string, aliyunPk: string, request: DeleteRepositoryMemberRequest): Promise<DeleteRepositoryMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteRepositoryMemberWithOptions(repositoryId, aliyunPk, request, headers, runtime);
  }

  /**
   * 删除代码库Webhook
   * 
   * @param request - DeleteRepositoryWebhookRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRepositoryWebhookResponse
   */
  async deleteRepositoryWebhookWithOptions(repositoryId: string, hookId: string, request: DeleteRepositoryWebhookRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteRepositoryWebhookResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRepositoryWebhook",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/hooks/${OpenApiUtil.getEncodeParam(hookId)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteRepositoryWebhookResponse>(await this.callApi(params, req, runtime), new DeleteRepositoryWebhookResponse({}));
  }

  /**
   * 删除代码库Webhook
   * 
   * @param request - DeleteRepositoryWebhookRequest
   * @returns DeleteRepositoryWebhookResponse
   */
  async deleteRepositoryWebhook(repositoryId: string, hookId: string, request: DeleteRepositoryWebhookRequest): Promise<DeleteRepositoryWebhookResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteRepositoryWebhookWithOptions(repositoryId, hookId, request, headers, runtime);
  }

  /**
   * 删除资源成员
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteResourceMemberResponse
   */
  async deleteResourceMemberWithOptions(organizationId: string, resourceType: string, resourceId: string, accountId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteResourceMemberResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "DeleteResourceMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/${OpenApiUtil.getEncodeParam(resourceType)}/${OpenApiUtil.getEncodeParam(resourceId)}/members/${OpenApiUtil.getEncodeParam(accountId)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteResourceMemberResponse>(await this.callApi(params, req, runtime), new DeleteResourceMemberResponse({}));
  }

  /**
   * 删除资源成员
   * @returns DeleteResourceMemberResponse
   */
  async deleteResourceMember(organizationId: string, resourceType: string, resourceId: string, accountId: string): Promise<DeleteResourceMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteResourceMemberWithOptions(organizationId, resourceType, resourceId, accountId, headers, runtime);
  }

  /**
   * 删除标签
   * 
   * @param request - DeleteTagRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTagResponse
   */
  async deleteTagWithOptions(repositoryId: string, request: DeleteTagRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteTagResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.tagName)) {
      query["tagName"] = request.tagName;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTag",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/tags/delete`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteTagResponse>(await this.callApi(params, req, runtime), new DeleteTagResponse({}));
  }

  /**
   * 删除标签
   * 
   * @param request - DeleteTagRequest
   * @returns DeleteTagResponse
   */
  async deleteTag(repositoryId: string, request: DeleteTagRequest): Promise<DeleteTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteTagWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 删除用户的SSH Key
   * 
   * @param request - DeleteUserKeyRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteUserKeyResponse
   */
  async deleteUserKeyWithOptions(keyId: string, request: DeleteUserKeyRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteUserKeyResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteUserKey",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v3/user/keys/${OpenApiUtil.getEncodeParam(keyId)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteUserKeyResponse>(await this.callApi(params, req, runtime), new DeleteUserKeyResponse({}));
  }

  /**
   * 删除用户的SSH Key
   * 
   * @param request - DeleteUserKeyRequest
   * @returns DeleteUserKeyResponse
   */
  async deleteUserKey(keyId: string, request: DeleteUserKeyRequest): Promise<DeleteUserKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteUserKeyWithOptions(keyId, request, headers, runtime);
  }

  /**
   * 删除变量组
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteVariableGroupResponse
   */
  async deleteVariableGroupWithOptions(organizationId: string, id: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteVariableGroupResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "DeleteVariableGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/variableGroups/${OpenApiUtil.getEncodeParam(id)}`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteVariableGroupResponse>(await this.callApi(params, req, runtime), new DeleteVariableGroupResponse({}));
  }

  /**
   * 删除变量组
   * @returns DeleteVariableGroupResponse
   */
  async deleteVariableGroup(organizationId: string, id: string): Promise<DeleteVariableGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteVariableGroupWithOptions(organizationId, id, headers, runtime);
  }

  /**
   * 删除工作项
   * 
   * @param request - DeleteWorkitemRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteWorkitemResponse
   */
  async deleteWorkitemWithOptions(organizationId: string, request: DeleteWorkitemRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteWorkitemResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.identifier)) {
      query["identifier"] = request.identifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteWorkitem",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitem/delete`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteWorkitemResponse>(await this.callApi(params, req, runtime), new DeleteWorkitemResponse({}));
  }

  /**
   * 删除工作项
   * 
   * @param request - DeleteWorkitemRequest
   * @returns DeleteWorkitemResponse
   */
  async deleteWorkitem(organizationId: string, request: DeleteWorkitemRequest): Promise<DeleteWorkitemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteWorkitemWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 删除所有评论
   * 
   * @param request - DeleteWorkitemAllCommentRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteWorkitemAllCommentResponse
   */
  async deleteWorkitemAllCommentWithOptions(organizationId: string, request: DeleteWorkitemAllCommentRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteWorkitemAllCommentResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.identifier)) {
      query["identifier"] = request.identifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteWorkitemAllComment",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/deleteAllComment`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteWorkitemAllCommentResponse>(await this.callApi(params, req, runtime), new DeleteWorkitemAllCommentResponse({}));
  }

  /**
   * 删除所有评论
   * 
   * @param request - DeleteWorkitemAllCommentRequest
   * @returns DeleteWorkitemAllCommentResponse
   */
  async deleteWorkitemAllComment(organizationId: string, request: DeleteWorkitemAllCommentRequest): Promise<DeleteWorkitemAllCommentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteWorkitemAllCommentWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 删除单条评论
   * 
   * @param request - DeleteWorkitemCommentRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteWorkitemCommentResponse
   */
  async deleteWorkitemCommentWithOptions(organizationId: string, request: DeleteWorkitemCommentRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<DeleteWorkitemCommentResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.commentId)) {
      body["commentId"] = request.commentId;
    }

    if (!Util.isUnset(request.identifier)) {
      body["identifier"] = request.identifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteWorkitemComment",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/deleteComent`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteWorkitemCommentResponse>(await this.callApi(params, req, runtime), new DeleteWorkitemCommentResponse({}));
  }

  /**
   * 删除单条评论
   * 
   * @param request - DeleteWorkitemCommentRequest
   * @returns DeleteWorkitemCommentResponse
   */
  async deleteWorkitemComment(organizationId: string, request: DeleteWorkitemCommentRequest): Promise<DeleteWorkitemCommentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.deleteWorkitemCommentWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 启用部署密钥
   * 
   * @param request - EnableDeployKeyRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnableDeployKeyResponse
   */
  async enableDeployKeyWithOptions(repositoryId: string, keyId: string, request: EnableDeployKeyRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<EnableDeployKeyResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableDeployKey",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/keys/${OpenApiUtil.getEncodeParam(keyId)}/enable`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<EnableDeployKeyResponse>(await this.callApi(params, req, runtime), new EnableDeployKeyResponse({}));
  }

  /**
   * 启用部署密钥
   * 
   * @param request - EnableDeployKeyRequest
   * @returns EnableDeployKeyResponse
   */
  async enableDeployKey(repositoryId: string, keyId: string, request: EnableDeployKeyRequest): Promise<EnableDeployKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.enableDeployKeyWithOptions(repositoryId, keyId, request, headers, runtime);
  }

  /**
   * 执行研发阶段流水线
   * 
   * @param request - ExecuteChangeRequestReleaseStageRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExecuteChangeRequestReleaseStageResponse
   */
  async executeChangeRequestReleaseStageWithOptions(appName: string, releaseWorkflowSn: string, releaseStageSn: string, request: ExecuteChangeRequestReleaseStageRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ExecuteChangeRequestReleaseStageResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.params)) {
      body["params"] = request.params;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ExecuteChangeRequestReleaseStage",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}/releaseWorkflows/${OpenApiUtil.getEncodeParam(releaseWorkflowSn)}/releaseStages/${OpenApiUtil.getEncodeParam(releaseStageSn)}%3Aexecute`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ExecuteChangeRequestReleaseStageResponse>(await this.callApi(params, req, runtime), new ExecuteChangeRequestReleaseStageResponse({}));
  }

  /**
   * 执行研发阶段流水线
   * 
   * @param request - ExecuteChangeRequestReleaseStageRequest
   * @returns ExecuteChangeRequestReleaseStageResponse
   */
  async executeChangeRequestReleaseStage(appName: string, releaseWorkflowSn: string, releaseStageSn: string, request: ExecuteChangeRequestReleaseStageRequest): Promise<ExecuteChangeRequestReleaseStageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.executeChangeRequestReleaseStageWithOptions(appName, releaseWorkflowSn, releaseStageSn, request, headers, runtime);
  }

  /**
   * 导出Insight custom_value表
   * 
   * @param request - ExportInsightCustomValueRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExportInsightCustomValueResponse
   */
  async exportInsightCustomValueWithOptions(organizationId: string, request: ExportInsightCustomValueRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ExportInsightCustomValueResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["endTime"] = request.endTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      body["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.startTime)) {
      body["startTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ExportInsightCustomValue",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/data/customValues`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ExportInsightCustomValueResponse>(await this.callApi(params, req, runtime), new ExportInsightCustomValueResponse({}));
  }

  /**
   * 导出Insight custom_value表
   * 
   * @param request - ExportInsightCustomValueRequest
   * @returns ExportInsightCustomValueResponse
   */
  async exportInsightCustomValue(organizationId: string, request: ExportInsightCustomValueRequest): Promise<ExportInsightCustomValueResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.exportInsightCustomValueWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 导出Insight expected_work_time表数据
   * 
   * @param request - ExportInsightExpectedWorkTimeRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExportInsightExpectedWorkTimeResponse
   */
  async exportInsightExpectedWorkTimeWithOptions(organizationId: string, request: ExportInsightExpectedWorkTimeRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ExportInsightExpectedWorkTimeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["endTime"] = request.endTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      body["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.startTime)) {
      body["startTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ExportInsightExpectedWorkTime",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/data/expectedWorkTimes`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ExportInsightExpectedWorkTimeResponse>(await this.callApi(params, req, runtime), new ExportInsightExpectedWorkTimeResponse({}));
  }

  /**
   * 导出Insight expected_work_time表数据
   * 
   * @param request - ExportInsightExpectedWorkTimeRequest
   * @returns ExportInsightExpectedWorkTimeResponse
   */
  async exportInsightExpectedWorkTime(organizationId: string, request: ExportInsightExpectedWorkTimeRequest): Promise<ExportInsightExpectedWorkTimeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.exportInsightExpectedWorkTimeWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 导出Insight field表
   * 
   * @param request - ExportInsightFieldRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExportInsightFieldResponse
   */
  async exportInsightFieldWithOptions(organizationId: string, request: ExportInsightFieldRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ExportInsightFieldResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["endTime"] = request.endTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      body["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.startTime)) {
      body["startTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ExportInsightField",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/data/fields`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ExportInsightFieldResponse>(await this.callApi(params, req, runtime), new ExportInsightFieldResponse({}));
  }

  /**
   * 导出Insight field表
   * 
   * @param request - ExportInsightFieldRequest
   * @returns ExportInsightFieldResponse
   */
  async exportInsightField(organizationId: string, request: ExportInsightFieldRequest): Promise<ExportInsightFieldResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.exportInsightFieldWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 导出Insight space表数据
   * 
   * @param request - ExportInsightSpaceRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExportInsightSpaceResponse
   */
  async exportInsightSpaceWithOptions(organizationId: string, request: ExportInsightSpaceRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ExportInsightSpaceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["endTime"] = request.endTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      body["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.startTime)) {
      body["startTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ExportInsightSpace",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/data/spaces`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ExportInsightSpaceResponse>(await this.callApi(params, req, runtime), new ExportInsightSpaceResponse({}));
  }

  /**
   * 导出Insight space表数据
   * 
   * @param request - ExportInsightSpaceRequest
   * @returns ExportInsightSpaceResponse
   */
  async exportInsightSpace(organizationId: string, request: ExportInsightSpaceRequest): Promise<ExportInsightSpaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.exportInsightSpaceWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 导出Insight space_ref表数据
   * 
   * @param request - ExportInsightSpaceRefRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExportInsightSpaceRefResponse
   */
  async exportInsightSpaceRefWithOptions(organizationId: string, request: ExportInsightSpaceRefRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ExportInsightSpaceRefResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["endTime"] = request.endTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      body["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.startTime)) {
      body["startTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ExportInsightSpaceRef",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/data/spaceRefs`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ExportInsightSpaceRefResponse>(await this.callApi(params, req, runtime), new ExportInsightSpaceRefResponse({}));
  }

  /**
   * 导出Insight space_ref表数据
   * 
   * @param request - ExportInsightSpaceRefRequest
   * @returns ExportInsightSpaceRefResponse
   */
  async exportInsightSpaceRef(organizationId: string, request: ExportInsightSpaceRefRequest): Promise<ExportInsightSpaceRefResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.exportInsightSpaceRefWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 导出Insight sprint表数据
   * 
   * @param request - ExportInsightSprintRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExportInsightSprintResponse
   */
  async exportInsightSprintWithOptions(organizationId: string, request: ExportInsightSprintRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ExportInsightSprintResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["endTime"] = request.endTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      body["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.startTime)) {
      body["startTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ExportInsightSprint",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/data/sprints`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ExportInsightSprintResponse>(await this.callApi(params, req, runtime), new ExportInsightSprintResponse({}));
  }

  /**
   * 导出Insight sprint表数据
   * 
   * @param request - ExportInsightSprintRequest
   * @returns ExportInsightSprintResponse
   */
  async exportInsightSprint(organizationId: string, request: ExportInsightSprintRequest): Promise<ExportInsightSprintResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.exportInsightSprintWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 导出Insight tag_ref表数据
   * 
   * @param request - ExportInsightTagRefRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExportInsightTagRefResponse
   */
  async exportInsightTagRefWithOptions(organizationId: string, request: ExportInsightTagRefRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ExportInsightTagRefResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["endTime"] = request.endTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      body["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.startTime)) {
      body["startTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ExportInsightTagRef",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/data/tagRefs`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ExportInsightTagRefResponse>(await this.callApi(params, req, runtime), new ExportInsightTagRefResponse({}));
  }

  /**
   * 导出Insight tag_ref表数据
   * 
   * @param request - ExportInsightTagRefRequest
   * @returns ExportInsightTagRefResponse
   */
  async exportInsightTagRef(organizationId: string, request: ExportInsightTagRefRequest): Promise<ExportInsightTagRefResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.exportInsightTagRefWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 导出Insight work_time表数据
   * 
   * @param request - ExportInsightWorkTimeRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExportInsightWorkTimeResponse
   */
  async exportInsightWorkTimeWithOptions(organizationId: string, request: ExportInsightWorkTimeRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ExportInsightWorkTimeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["endTime"] = request.endTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      body["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.startTime)) {
      body["startTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ExportInsightWorkTime",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/data/workTimes`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ExportInsightWorkTimeResponse>(await this.callApi(params, req, runtime), new ExportInsightWorkTimeResponse({}));
  }

  /**
   * 导出Insight work_time表数据
   * 
   * @param request - ExportInsightWorkTimeRequest
   * @returns ExportInsightWorkTimeResponse
   */
  async exportInsightWorkTime(organizationId: string, request: ExportInsightWorkTimeRequest): Promise<ExportInsightWorkTimeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.exportInsightWorkTimeWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 导出Insight workitem_stauts表数据
   * 
   * @param request - ExportInsightWorkitemStatusRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExportInsightWorkitemStatusResponse
   */
  async exportInsightWorkitemStatusWithOptions(organizationId: string, request: ExportInsightWorkitemStatusRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ExportInsightWorkitemStatusResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["endTime"] = request.endTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      body["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.startTime)) {
      body["startTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ExportInsightWorkitemStatus",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/data/workitemStatuses`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ExportInsightWorkitemStatusResponse>(await this.callApi(params, req, runtime), new ExportInsightWorkitemStatusResponse({}));
  }

  /**
   * 导出Insight workitem_stauts表数据
   * 
   * @param request - ExportInsightWorkitemStatusRequest
   * @returns ExportInsightWorkitemStatusResponse
   */
  async exportInsightWorkitemStatus(organizationId: string, request: ExportInsightWorkitemStatusRequest): Promise<ExportInsightWorkitemStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.exportInsightWorkitemStatusWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 导出Insight workitem_stauts表 join workitem_defect_extra表表数据
   * 
   * @param request - ExportInsightWorkitemStatusJoinWorkitemDefectExtraRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponse
   */
  async exportInsightWorkitemStatusJoinWorkitemDefectExtraWithOptions(organizationId: string, request: ExportInsightWorkitemStatusJoinWorkitemDefectExtraRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["endTime"] = request.endTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      body["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.startTime)) {
      body["startTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ExportInsightWorkitemStatusJoinWorkitemDefectExtra",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/data/workitemStatusJoinWorkitemDefectExtras`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponse>(await this.callApi(params, req, runtime), new ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponse({}));
  }

  /**
   * 导出Insight workitem_stauts表 join workitem_defect_extra表表数据
   * 
   * @param request - ExportInsightWorkitemStatusJoinWorkitemDefectExtraRequest
   * @returns ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponse
   */
  async exportInsightWorkitemStatusJoinWorkitemDefectExtra(organizationId: string, request: ExportInsightWorkitemStatusJoinWorkitemDefectExtraRequest): Promise<ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.exportInsightWorkitemStatusJoinWorkitemDefectExtraWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 导出Insight workitem_version表数据
   * 
   * @param request - ExportInsightWorkitemVersionRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExportInsightWorkitemVersionResponse
   */
  async exportInsightWorkitemVersionWithOptions(organizationId: string, request: ExportInsightWorkitemVersionRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ExportInsightWorkitemVersionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["endTime"] = request.endTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      body["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.startTime)) {
      body["startTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ExportInsightWorkitemVersion",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/data/workitemVersions`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ExportInsightWorkitemVersionResponse>(await this.callApi(params, req, runtime), new ExportInsightWorkitemVersionResponse({}));
  }

  /**
   * 导出Insight workitem_version表数据
   * 
   * @param request - ExportInsightWorkitemVersionRequest
   * @returns ExportInsightWorkitemVersionResponse
   */
  async exportInsightWorkitemVersion(organizationId: string, request: ExportInsightWorkitemVersionRequest): Promise<ExportInsightWorkitemVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.exportInsightWorkitemVersionWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 导出Insight workitem_activity表数据
   * 
   * @param request - ExportWorkitemActivityRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExportWorkitemActivityResponse
   */
  async exportWorkitemActivityWithOptions(organizationId: string, request: ExportWorkitemActivityRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ExportWorkitemActivityResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["endTime"] = request.endTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      body["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.startTime)) {
      body["startTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ExportWorkitemActivity",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/data/workitemActivities`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ExportWorkitemActivityResponse>(await this.callApi(params, req, runtime), new ExportWorkitemActivityResponse({}));
  }

  /**
   * 导出Insight workitem_activity表数据
   * 
   * @param request - ExportWorkitemActivityRequest
   * @returns ExportWorkitemActivityResponse
   */
  async exportWorkitemActivity(organizationId: string, request: ExportWorkitemActivityRequest): Promise<ExportWorkitemActivityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.exportWorkitemActivityWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 冻结工作空间
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns FrozenWorkspaceResponse
   */
  async frozenWorkspaceWithOptions(workspaceId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<FrozenWorkspaceResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "FrozenWorkspace",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/workspaces/${OpenApiUtil.getEncodeParam(workspaceId)}/frozen`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<FrozenWorkspaceResponse>(await this.callApi(params, req, runtime), new FrozenWorkspaceResponse({}));
  }

  /**
   * 冻结工作空间
   * @returns FrozenWorkspaceResponse
   */
  async frozenWorkspace(workspaceId: string): Promise<FrozenWorkspaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.frozenWorkspaceWithOptions(workspaceId, headers, runtime);
  }

  /**
   * 查找应用详情
   * 
   * @param request - GetApplicationRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetApplicationResponse
   */
  async getApplicationWithOptions(appName: string, request: GetApplicationRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetApplicationResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetApplication",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetApplicationResponse>(await this.callApi(params, req, runtime), new GetApplicationResponse({}));
  }

  /**
   * 查找应用详情
   * 
   * @param request - GetApplicationRequest
   * @returns GetApplicationResponse
   */
  async getApplication(appName: string, request: GetApplicationRequest): Promise<GetApplicationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getApplicationWithOptions(appName, request, headers, runtime);
  }

  /**
   * 查询单个分支
   * 
   * @param request - GetBranchInfoRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetBranchInfoResponse
   */
  async getBranchInfoWithOptions(repositoryId: string, request: GetBranchInfoRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetBranchInfoResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.branchName)) {
      query["branchName"] = request.branchName;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetBranchInfo",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/branches/detail`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetBranchInfoResponse>(await this.callApi(params, req, runtime), new GetBranchInfoResponse({}));
  }

  /**
   * 查询单个分支
   * 
   * @param request - GetBranchInfoRequest
   * @returns GetBranchInfoResponse
   */
  async getBranchInfo(repositoryId: string, request: GetBranchInfoRequest): Promise<GetBranchInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getBranchInfoWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 查询检查运行
   * 
   * @param request - GetCheckRunRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetCheckRunResponse
   */
  async getCheckRunWithOptions(request: GetCheckRunRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetCheckRunResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.checkRunId)) {
      query["checkRunId"] = request.checkRunId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetCheckRun",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/check_runs/get_check_run`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetCheckRunResponse>(await this.callApi(params, req, runtime), new GetCheckRunResponse({}));
  }

  /**
   * 查询检查运行
   * 
   * @param request - GetCheckRunRequest
   * @returns GetCheckRunResponse
   */
  async getCheckRun(request: GetCheckRunRequest): Promise<GetCheckRunResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getCheckRunWithOptions(request, headers, runtime);
  }

  /**
   * 获取企业信息
   * 
   * @param request - GetCodeupOrganizationRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetCodeupOrganizationResponse
   */
  async getCodeupOrganizationWithOptions(identity: string, request: GetCodeupOrganizationRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetCodeupOrganizationResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetCodeupOrganization",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/organization/${OpenApiUtil.getEncodeParam(identity)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetCodeupOrganizationResponse>(await this.callApi(params, req, runtime), new GetCodeupOrganizationResponse({}));
  }

  /**
   * 获取企业信息
   * 
   * @param request - GetCodeupOrganizationRequest
   * @returns GetCodeupOrganizationResponse
   */
  async getCodeupOrganization(identity: string, request: GetCodeupOrganizationRequest): Promise<GetCodeupOrganizationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getCodeupOrganizationWithOptions(identity, request, headers, runtime);
  }

  /**
   * 获取比较详情
   * 
   * @param request - GetCompareDetailRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetCompareDetailResponse
   */
  async getCompareDetailWithOptions(repositoryId: string, request: GetCompareDetailRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetCompareDetailResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.from)) {
      query["from"] = request.from;
    }

    if (!Util.isUnset(request.maxDiffByte)) {
      query["maxDiffByte"] = request.maxDiffByte;
    }

    if (!Util.isUnset(request.maxDiffFile)) {
      query["maxDiffFile"] = request.maxDiffFile;
    }

    if (!Util.isUnset(request.mergeBase)) {
      query["mergeBase"] = request.mergeBase;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.to)) {
      query["to"] = request.to;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetCompareDetail",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/commits/compare/detail`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetCompareDetailResponse>(await this.callApi(params, req, runtime), new GetCompareDetailResponse({}));
  }

  /**
   * 获取比较详情
   * 
   * @param request - GetCompareDetailRequest
   * @returns GetCompareDetailResponse
   */
  async getCompareDetail(repositoryId: string, request: GetCompareDetailRequest): Promise<GetCompareDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getCompareDetailWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 获取自定义字段的选项值
   * 
   * @param request - GetCustomFieldOptionRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetCustomFieldOptionResponse
   */
  async getCustomFieldOptionWithOptions(organizationId: string, fieldId: string, request: GetCustomFieldOptionRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetCustomFieldOptionResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.spaceIdentifier)) {
      query["spaceIdentifier"] = request.spaceIdentifier;
    }

    if (!Util.isUnset(request.spaceType)) {
      query["spaceType"] = request.spaceType;
    }

    if (!Util.isUnset(request.workitemTypeIdentifier)) {
      query["workitemTypeIdentifier"] = request.workitemTypeIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetCustomFieldOption",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/fields/${OpenApiUtil.getEncodeParam(fieldId)}/getCustomOption`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetCustomFieldOptionResponse>(await this.callApi(params, req, runtime), new GetCustomFieldOptionResponse({}));
  }

  /**
   * 获取自定义字段的选项值
   * 
   * @param request - GetCustomFieldOptionRequest
   * @returns GetCustomFieldOptionResponse
   */
  async getCustomFieldOption(organizationId: string, fieldId: string, request: GetCustomFieldOptionRequest): Promise<GetCustomFieldOptionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getCustomFieldOptionWithOptions(organizationId, fieldId, request, headers, runtime);
  }

  /**
   * 查询文件
   * 
   * @param request - GetFileBlobsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetFileBlobsResponse
   */
  async getFileBlobsWithOptions(repositoryId: string, request: GetFileBlobsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetFileBlobsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.filePath)) {
      query["filePath"] = request.filePath;
    }

    if (!Util.isUnset(request.from)) {
      query["from"] = request.from;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.ref)) {
      query["ref"] = request.ref;
    }

    if (!Util.isUnset(request.to)) {
      query["to"] = request.to;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetFileBlobs",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/files/blobs`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetFileBlobsResponse>(await this.callApi(params, req, runtime), new GetFileBlobsResponse({}));
  }

  /**
   * 查询文件
   * 
   * @param request - GetFileBlobsRequest
   * @returns GetFileBlobsResponse
   */
  async getFileBlobs(repositoryId: string, request: GetFileBlobsRequest): Promise<GetFileBlobsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getFileBlobsWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 获取文件上一次提交信息
   * 
   * @param request - GetFileLastCommitRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetFileLastCommitResponse
   */
  async getFileLastCommitWithOptions(repositoryId: string, request: GetFileLastCommitRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetFileLastCommitResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.filePath)) {
      query["filePath"] = request.filePath;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.sha)) {
      query["sha"] = request.sha;
    }

    if (!Util.isUnset(request.showSignature)) {
      query["showSignature"] = request.showSignature;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetFileLastCommit",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/files/lastCommit`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetFileLastCommitResponse>(await this.callApi(params, req, runtime), new GetFileLastCommitResponse({}));
  }

  /**
   * 获取文件上一次提交信息
   * 
   * @param request - GetFileLastCommitRequest
   * @returns GetFileLastCommitResponse
   */
  async getFileLastCommit(repositoryId: string, request: GetFileLastCommitRequest): Promise<GetFileLastCommitResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getFileLastCommitWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 获取标签分类
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetFlowTagGroupResponse
   */
  async getFlowTagGroupWithOptions(organizationId: string, id: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetFlowTagGroupResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetFlowTagGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/flow/tagGroups/${OpenApiUtil.getEncodeParam(id)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetFlowTagGroupResponse>(await this.callApi(params, req, runtime), new GetFlowTagGroupResponse({}));
  }

  /**
   * 获取标签分类
   * @returns GetFlowTagGroupResponse
   */
  async getFlowTagGroup(organizationId: string, id: string): Promise<GetFlowTagGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getFlowTagGroupWithOptions(organizationId, id, headers, runtime);
  }

  /**
   * 根据路径查询代码组
   * 
   * @param request - GetGroupByPathRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetGroupByPathResponse
   */
  async getGroupByPathWithOptions(request: GetGroupByPathRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetGroupByPathResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.identity)) {
      query["identity"] = request.identity;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetGroupByPath",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/4/groups/find_by_path`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetGroupByPathResponse>(await this.callApi(params, req, runtime), new GetGroupByPathResponse({}));
  }

  /**
   * 根据路径查询代码组
   * 
   * @param request - GetGroupByPathRequest
   * @returns GetGroupByPathResponse
   */
  async getGroupByPath(request: GetGroupByPathRequest): Promise<GetGroupByPathResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getGroupByPathWithOptions(request, headers, runtime);
  }

  /**
   * 查询代码组信息
   * 
   * @param request - GetGroupDetailRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetGroupDetailResponse
   */
  async getGroupDetailWithOptions(request: GetGroupDetailRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetGroupDetailResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.groupId)) {
      query["groupId"] = request.groupId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetGroupDetail",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/groups/get_detail`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetGroupDetailResponse>(await this.callApi(params, req, runtime), new GetGroupDetailResponse({}));
  }

  /**
   * 查询代码组信息
   * 
   * @param request - GetGroupDetailRequest
   * @returns GetGroupDetailResponse
   */
  async getGroupDetail(request: GetGroupDetailRequest): Promise<GetGroupDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getGroupDetailWithOptions(request, headers, runtime);
  }

  /**
   * 获取主机组信息
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetHostGroupResponse
   */
  async getHostGroupWithOptions(organizationId: string, id: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetHostGroupResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetHostGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/hostGroups/${OpenApiUtil.getEncodeParam(id)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetHostGroupResponse>(await this.callApi(params, req, runtime), new GetHostGroupResponse({}));
  }

  /**
   * 获取主机组信息
   * @returns GetHostGroupResponse
   */
  async getHostGroup(organizationId: string, id: string): Promise<GetHostGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getHostGroupWithOptions(organizationId, id, headers, runtime);
  }

  /**
   * 查询合并请求详情
   * 
   * @param request - GetMergeRequestRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMergeRequestResponse
   */
  async getMergeRequestWithOptions(repositoryId: string, localId: string, request: GetMergeRequestRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetMergeRequestResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMergeRequest",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/merge_requests/${OpenApiUtil.getEncodeParam(localId)}/detail`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetMergeRequestResponse>(await this.callApi(params, req, runtime), new GetMergeRequestResponse({}));
  }

  /**
   * 查询合并请求详情
   * 
   * @param request - GetMergeRequestRequest
   * @returns GetMergeRequestResponse
   */
  async getMergeRequest(repositoryId: string, localId: string, request: GetMergeRequestRequest): Promise<GetMergeRequestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getMergeRequestWithOptions(repositoryId, localId, request, headers, runtime);
  }

  /**
   * 查询合并请求的变更信息
   * 
   * @param request - GetMergeRequestChangeTreeRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMergeRequestChangeTreeResponse
   */
  async getMergeRequestChangeTreeWithOptions(request: GetMergeRequestChangeTreeRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetMergeRequestChangeTreeResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.fromPatchSetBizId)) {
      query["fromPatchSetBizId"] = request.fromPatchSetBizId;
    }

    if (!Util.isUnset(request.localId)) {
      query["localId"] = request.localId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    if (!Util.isUnset(request.toPatchSetBizId)) {
      query["toPatchSetBizId"] = request.toPatchSetBizId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMergeRequestChangeTree",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/merge_requests/diffs/change_tree`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetMergeRequestChangeTreeResponse>(await this.callApi(params, req, runtime), new GetMergeRequestChangeTreeResponse({}));
  }

  /**
   * 查询合并请求的变更信息
   * 
   * @param request - GetMergeRequestChangeTreeRequest
   * @returns GetMergeRequestChangeTreeResponse
   */
  async getMergeRequestChangeTree(request: GetMergeRequestChangeTreeRequest): Promise<GetMergeRequestChangeTreeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getMergeRequestChangeTreeWithOptions(request, headers, runtime);
  }

  /**
   * 获取企业成员
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetOrganizationMemberResponse
   */
  async getOrganizationMemberWithOptions(organizationId: string, accountId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetOrganizationMemberResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetOrganizationMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/members/${OpenApiUtil.getEncodeParam(accountId)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetOrganizationMemberResponse>(await this.callApi(params, req, runtime), new GetOrganizationMemberResponse({}));
  }

  /**
   * 获取企业成员
   * @returns GetOrganizationMemberResponse
   */
  async getOrganizationMember(organizationId: string, accountId: string): Promise<GetOrganizationMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getOrganizationMemberWithOptions(organizationId, accountId, headers, runtime);
  }

  /**
   * 获取流水线
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPipelineResponse
   */
  async getPipelineWithOptions(organizationId: string, pipelineId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetPipelineResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetPipeline",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetPipelineResponse>(await this.callApi(params, req, runtime), new GetPipelineResponse({}));
  }

  /**
   * 获取流水线
   * @returns GetPipelineResponse
   */
  async getPipeline(organizationId: string, pipelineId: string): Promise<GetPipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getPipelineWithOptions(organizationId, pipelineId, headers, runtime);
  }

  /**
   * 获取构建物下载链接
   * 
   * @param request - GetPipelineArtifactUrlRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPipelineArtifactUrlResponse
   */
  async getPipelineArtifactUrlWithOptions(organizationId: string, request: GetPipelineArtifactUrlRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetPipelineArtifactUrlResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.fileName)) {
      query["fileName"] = request.fileName;
    }

    if (!Util.isUnset(request.filePath)) {
      query["filePath"] = request.filePath;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPipelineArtifactUrl",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipeline/getArtifactDownloadUrl`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetPipelineArtifactUrlResponse>(await this.callApi(params, req, runtime), new GetPipelineArtifactUrlResponse({}));
  }

  /**
   * 获取构建物下载链接
   * 
   * @param request - GetPipelineArtifactUrlRequest
   * @returns GetPipelineArtifactUrlResponse
   */
  async getPipelineArtifactUrl(organizationId: string, request: GetPipelineArtifactUrlRequest): Promise<GetPipelineArtifactUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getPipelineArtifactUrlWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 获取emase构建物下载链接
   * 
   * @param request - GetPipelineEmasArtifactUrlRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPipelineEmasArtifactUrlResponse
   */
  async getPipelineEmasArtifactUrlWithOptions(organizationId: string, emasJobInstanceId: string, md5: string, pipelineId: string, pipelineRunId: string, request: GetPipelineEmasArtifactUrlRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetPipelineEmasArtifactUrlResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.serviceConnectionId)) {
      query["serviceConnectionId"] = request.serviceConnectionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPipelineEmasArtifactUrl",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipeline/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRun/${OpenApiUtil.getEncodeParam(pipelineRunId)}/emas/artifact/${OpenApiUtil.getEncodeParam(emasJobInstanceId)}/${OpenApiUtil.getEncodeParam(md5)}`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetPipelineEmasArtifactUrlResponse>(await this.callApi(params, req, runtime), new GetPipelineEmasArtifactUrlResponse({}));
  }

  /**
   * 获取emase构建物下载链接
   * 
   * @param request - GetPipelineEmasArtifactUrlRequest
   * @returns GetPipelineEmasArtifactUrlResponse
   */
  async getPipelineEmasArtifactUrl(organizationId: string, emasJobInstanceId: string, md5: string, pipelineId: string, pipelineRunId: string, request: GetPipelineEmasArtifactUrlRequest): Promise<GetPipelineEmasArtifactUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getPipelineEmasArtifactUrlWithOptions(organizationId, emasJobInstanceId, md5, pipelineId, pipelineRunId, request, headers, runtime);
  }

  /**
   * 获取流水线分组
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPipelineGroupResponse
   */
  async getPipelineGroupWithOptions(organizationId: string, groupId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetPipelineGroupResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetPipelineGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelineGroups/${OpenApiUtil.getEncodeParam(groupId)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetPipelineGroupResponse>(await this.callApi(params, req, runtime), new GetPipelineGroupResponse({}));
  }

  /**
   * 获取流水线分组
   * @returns GetPipelineGroupResponse
   */
  async getPipelineGroup(organizationId: string, groupId: string): Promise<GetPipelineGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getPipelineGroupWithOptions(organizationId, groupId, headers, runtime);
  }

  /**
   * 获取流水线运行信息
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPipelineRunResponse
   */
  async getPipelineRunWithOptions(organizationId: string, pipelineId: string, pipelineRunId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetPipelineRunResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetPipelineRun",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRuns/${OpenApiUtil.getEncodeParam(pipelineRunId)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetPipelineRunResponse>(await this.callApi(params, req, runtime), new GetPipelineRunResponse({}));
  }

  /**
   * 获取流水线运行信息
   * @returns GetPipelineRunResponse
   */
  async getPipelineRun(organizationId: string, pipelineId: string, pipelineRunId: string): Promise<GetPipelineRunResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getPipelineRunWithOptions(organizationId, pipelineId, pipelineRunId, headers, runtime);
  }

  /**
   * 获取扫描报告下载链接
   * 
   * @param request - GetPipelineScanReportUrlRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPipelineScanReportUrlResponse
   */
  async getPipelineScanReportUrlWithOptions(organizationId: string, request: GetPipelineScanReportUrlRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetPipelineScanReportUrlResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.reportPath)) {
      body["reportPath"] = request.reportPath;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetPipelineScanReportUrl",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipeline/getPipelineScanReportUrl`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetPipelineScanReportUrlResponse>(await this.callApi(params, req, runtime), new GetPipelineScanReportUrlResponse({}));
  }

  /**
   * 获取扫描报告下载链接
   * 
   * @param request - GetPipelineScanReportUrlRequest
   * @returns GetPipelineScanReportUrlResponse
   */
  async getPipelineScanReportUrl(organizationId: string, request: GetPipelineScanReportUrlRequest): Promise<GetPipelineScanReportUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getPipelineScanReportUrlWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 根据id获取项目详情-Projex
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetProjectInfoResponse
   */
  async getProjectInfoWithOptions(organizationId: string, projectId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetProjectInfoResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetProjectInfo",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/project/${OpenApiUtil.getEncodeParam(projectId)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetProjectInfoResponse>(await this.callApi(params, req, runtime), new GetProjectInfoResponse({}));
  }

  /**
   * 根据id获取项目详情-Projex
   * @returns GetProjectInfoResponse
   */
  async getProjectInfo(organizationId: string, projectId: string): Promise<GetProjectInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getProjectInfoWithOptions(organizationId, projectId, headers, runtime);
  }

  /**
   * 查询代码库成员
   * 
   * @param request - GetProjectMemberRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetProjectMemberResponse
   */
  async getProjectMemberWithOptions(repositoryId: string, aliyunPk: string, request: GetProjectMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetProjectMemberResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetProjectMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/members/get/${OpenApiUtil.getEncodeParam(aliyunPk)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetProjectMemberResponse>(await this.callApi(params, req, runtime), new GetProjectMemberResponse({}));
  }

  /**
   * 查询代码库成员
   * 
   * @param request - GetProjectMemberRequest
   * @returns GetProjectMemberResponse
   */
  async getProjectMember(repositoryId: string, aliyunPk: string, request: GetProjectMemberRequest): Promise<GetProjectMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getProjectMemberWithOptions(repositoryId, aliyunPk, request, headers, runtime);
  }

  /**
   * 查询推送规则
   * 
   * @param request - GetPushRuleRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPushRuleResponse
   */
  async getPushRuleWithOptions(repositoryId: string, pushRuleId: string, request: GetPushRuleRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetPushRuleResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPushRule",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/push_rule/${OpenApiUtil.getEncodeParam(pushRuleId)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetPushRuleResponse>(await this.callApi(params, req, runtime), new GetPushRuleResponse({}));
  }

  /**
   * 查询推送规则
   * 
   * @param request - GetPushRuleRequest
   * @returns GetPushRuleResponse
   */
  async getPushRule(repositoryId: string, pushRuleId: string, request: GetPushRuleRequest): Promise<GetPushRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getPushRuleWithOptions(repositoryId, pushRuleId, request, headers, runtime);
  }

  /**
   * 获取研发阶段流水线运行实例
   * 
   * @param request - GetReleaseStagePipelineRunRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetReleaseStagePipelineRunResponse
   */
  async getReleaseStagePipelineRunWithOptions(appName: string, releaseWorkflowSn: string, releaseStageSn: string, executionNumber: string, request: GetReleaseStagePipelineRunRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetReleaseStagePipelineRunResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetReleaseStagePipelineRun",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}/releaseWorkflows/${OpenApiUtil.getEncodeParam(releaseWorkflowSn)}/releaseStages/${OpenApiUtil.getEncodeParam(releaseStageSn)}/executions/${OpenApiUtil.getEncodeParam(executionNumber)}%3AgetPipelineRun`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetReleaseStagePipelineRunResponse>(await this.callApi(params, req, runtime), new GetReleaseStagePipelineRunResponse({}));
  }

  /**
   * 获取研发阶段流水线运行实例
   * 
   * @param request - GetReleaseStagePipelineRunRequest
   * @returns GetReleaseStagePipelineRunResponse
   */
  async getReleaseStagePipelineRun(appName: string, releaseWorkflowSn: string, releaseStageSn: string, executionNumber: string, request: GetReleaseStagePipelineRunRequest): Promise<GetReleaseStagePipelineRunResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getReleaseStagePipelineRunWithOptions(appName, releaseWorkflowSn, releaseStageSn, executionNumber, request, headers, runtime);
  }

  /**
   * 使用代码库ID或路径查询代码库信息
   * 
   * @param request - GetRepositoryRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRepositoryResponse
   */
  async getRepositoryWithOptions(request: GetRepositoryRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetRepositoryResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.identity)) {
      query["identity"] = request.identity;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRepository",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/get`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetRepositoryResponse>(await this.callApi(params, req, runtime), new GetRepositoryResponse({}));
  }

  /**
   * 使用代码库ID或路径查询代码库信息
   * 
   * @param request - GetRepositoryRequest
   * @returns GetRepositoryResponse
   */
  async getRepository(request: GetRepositoryRequest): Promise<GetRepositoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getRepositoryWithOptions(request, headers, runtime);
  }

  /**
   * 查询代码库提交信息
   * 
   * @param request - GetRepositoryCommitRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRepositoryCommitResponse
   */
  async getRepositoryCommitWithOptions(repositoryId: string, sha: string, request: GetRepositoryCommitRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetRepositoryCommitResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.showSignature)) {
      query["showSignature"] = request.showSignature;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRepositoryCommit",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/commits/${OpenApiUtil.getEncodeParam(sha)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetRepositoryCommitResponse>(await this.callApi(params, req, runtime), new GetRepositoryCommitResponse({}));
  }

  /**
   * 查询代码库提交信息
   * 
   * @param request - GetRepositoryCommitRequest
   * @returns GetRepositoryCommitResponse
   */
  async getRepositoryCommit(repositoryId: string, sha: string, request: GetRepositoryCommitRequest): Promise<GetRepositoryCommitResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getRepositoryCommitWithOptions(repositoryId, sha, request, headers, runtime);
  }

  /**
   * 查询单个标签
   * 
   * @param request - GetRepositoryTagRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRepositoryTagResponse
   */
  async getRepositoryTagWithOptions(repositoryId: string, request: GetRepositoryTagRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetRepositoryTagResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.tagName)) {
      query["tagName"] = request.tagName;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRepositoryTag",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/tag/info`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetRepositoryTagResponse>(await this.callApi(params, req, runtime), new GetRepositoryTagResponse({}));
  }

  /**
   * 查询单个标签
   * 
   * @param request - GetRepositoryTagRequest
   * @returns GetRepositoryTagResponse
   */
  async getRepositoryTag(repositoryId: string, request: GetRepositoryTagRequest): Promise<GetRepositoryTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getRepositoryTagWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 预览代码片段
   * 
   * @param request - GetSearchCodePreviewRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSearchCodePreviewResponse
   */
  async getSearchCodePreviewWithOptions(request: GetSearchCodePreviewRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetSearchCodePreviewResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.docId)) {
      query["docId"] = request.docId;
    }

    if (!Util.isUnset(request.isDsl)) {
      query["isDsl"] = request.isDsl;
    }

    if (!Util.isUnset(request.keyword)) {
      query["keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSearchCodePreview",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/search/code_preview`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetSearchCodePreviewResponse>(await this.callApi(params, req, runtime), new GetSearchCodePreviewResponse({}));
  }

  /**
   * 预览代码片段
   * 
   * @param request - GetSearchCodePreviewRequest
   * @returns GetSearchCodePreviewResponse
   */
  async getSearchCodePreview(request: GetSearchCodePreviewRequest): Promise<GetSearchCodePreviewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getSearchCodePreviewWithOptions(request, headers, runtime);
  }

  /**
   * 获取迭代详情
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSprintInfoResponse
   */
  async getSprintInfoWithOptions(organizationId: string, sprintId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetSprintInfoResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetSprintInfo",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/sprints/${OpenApiUtil.getEncodeParam(sprintId)}/getSprintinfo`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetSprintInfoResponse>(await this.callApi(params, req, runtime), new GetSprintInfoResponse({}));
  }

  /**
   * 获取迭代详情
   * @returns GetSprintInfoResponse
   */
  async getSprintInfo(organizationId: string, sprintId: string): Promise<GetSprintInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getSprintInfoWithOptions(organizationId, sprintId, headers, runtime);
  }

  /**
   * 获取测试计划中的测试用例列表
   * 
   * @param request - GetTestResultListRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetTestResultListResponse
   */
  async getTestResultListWithOptions(organizationId: string, testPlanIdentifier: string, request: GetTestResultListRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetTestResultListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.conditions)) {
      body["conditions"] = request.conditions;
    }

    if (!Util.isUnset(request.directoryIdentifier)) {
      body["directoryIdentifier"] = request.directoryIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetTestResultList",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/testhub/testplan/${OpenApiUtil.getEncodeParam(testPlanIdentifier)}/testresults`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetTestResultListResponse>(await this.callApi(params, req, runtime), new GetTestResultListResponse({}));
  }

  /**
   * 获取测试计划中的测试用例列表
   * 
   * @param request - GetTestResultListRequest
   * @returns GetTestResultListResponse
   */
  async getTestResultList(organizationId: string, testPlanIdentifier: string, request: GetTestResultListRequest): Promise<GetTestResultListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getTestResultListWithOptions(organizationId, testPlanIdentifier, request, headers, runtime);
  }

  /**
   * 获取测试用例列表
   * 
   * @param request - GetTestcaseListRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetTestcaseListResponse
   */
  async getTestcaseListWithOptions(organizationId: string, request: GetTestcaseListRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetTestcaseListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.conditions)) {
      body["conditions"] = request.conditions;
    }

    if (!Util.isUnset(request.directoryIdentifier)) {
      body["directoryIdentifier"] = request.directoryIdentifier;
    }

    if (!Util.isUnset(request.maxResult)) {
      body["maxResult"] = request.maxResult;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.spaceIdentifier)) {
      body["spaceIdentifier"] = request.spaceIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetTestcaseList",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/testhub/testcases`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetTestcaseListResponse>(await this.callApi(params, req, runtime), new GetTestcaseListResponse({}));
  }

  /**
   * 获取测试用例列表
   * 
   * @param request - GetTestcaseListRequest
   * @returns GetTestcaseListResponse
   */
  async getTestcaseList(organizationId: string, request: GetTestcaseListRequest): Promise<GetTestcaseListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getTestcaseListWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 查询当前用户信息
   * 
   * @param request - GetUserInfoRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetUserInfoResponse
   */
  async getUserInfoWithOptions(request: GetUserInfoRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetUserInfoResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetUserInfo",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/users/current`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetUserInfoResponse>(await this.callApi(params, req, runtime), new GetUserInfoResponse({}));
  }

  /**
   * 查询当前用户信息
   * 
   * @param request - GetUserInfoRequest
   * @returns GetUserInfoResponse
   */
  async getUserInfo(request: GetUserInfoRequest): Promise<GetUserInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getUserInfoWithOptions(request, headers, runtime);
  }

  /**
   * 获取部署单信息
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetVMDeployOrderResponse
   */
  async getVMDeployOrderWithOptions(organizationId: string, pipelineId: string, deployOrderId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetVMDeployOrderResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetVMDeployOrder",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/deploy/${OpenApiUtil.getEncodeParam(deployOrderId)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetVMDeployOrderResponse>(await this.callApi(params, req, runtime), new GetVMDeployOrderResponse({}));
  }

  /**
   * 获取部署单信息
   * @returns GetVMDeployOrderResponse
   */
  async getVMDeployOrder(organizationId: string, pipelineId: string, deployOrderId: string): Promise<GetVMDeployOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getVMDeployOrderWithOptions(organizationId, pipelineId, deployOrderId, headers, runtime);
  }

  /**
   * 获取变量组
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetVariableGroupResponse
   */
  async getVariableGroupWithOptions(organizationId: string, id: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetVariableGroupResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetVariableGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/variableGroups/${OpenApiUtil.getEncodeParam(id)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetVariableGroupResponse>(await this.callApi(params, req, runtime), new GetVariableGroupResponse({}));
  }

  /**
   * 获取变量组
   * @returns GetVariableGroupResponse
   */
  async getVariableGroup(organizationId: string, id: string): Promise<GetVariableGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getVariableGroupWithOptions(organizationId, id, headers, runtime);
  }

  /**
   * 获取工作项动态
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetWorkItemActivityResponse
   */
  async getWorkItemActivityWithOptions(organizationId: string, workitemId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetWorkItemActivityResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetWorkItemActivity",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/${OpenApiUtil.getEncodeParam(workitemId)}/getActivity`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetWorkItemActivityResponse>(await this.callApi(params, req, runtime), new GetWorkItemActivityResponse({}));
  }

  /**
   * 获取工作项动态
   * @returns GetWorkItemActivityResponse
   */
  async getWorkItemActivity(organizationId: string, workitemId: string): Promise<GetWorkItemActivityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getWorkItemActivityWithOptions(organizationId, workitemId, headers, runtime);
  }

  /**
   * 根据id获取工作项详情
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetWorkItemInfoResponse
   */
  async getWorkItemInfoWithOptions(organizationId: string, workitemId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetWorkItemInfoResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetWorkItemInfo",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/${OpenApiUtil.getEncodeParam(workitemId)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetWorkItemInfoResponse>(await this.callApi(params, req, runtime), new GetWorkItemInfoResponse({}));
  }

  /**
   * 根据id获取工作项详情
   * @returns GetWorkItemInfoResponse
   */
  async getWorkItemInfo(organizationId: string, workitemId: string): Promise<GetWorkItemInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getWorkItemInfoWithOptions(organizationId, workitemId, headers, runtime);
  }

  /**
   * 获取工作项工作流信息
   * 
   * @param request - GetWorkItemWorkFlowInfoRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetWorkItemWorkFlowInfoResponse
   */
  async getWorkItemWorkFlowInfoWithOptions(organizationId: string, workitemId: string, request: GetWorkItemWorkFlowInfoRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetWorkItemWorkFlowInfoResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.configurationId)) {
      query["configurationId"] = request.configurationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetWorkItemWorkFlowInfo",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/${OpenApiUtil.getEncodeParam(workitemId)}/getWorkflowInfo`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetWorkItemWorkFlowInfoResponse>(await this.callApi(params, req, runtime), new GetWorkItemWorkFlowInfoResponse({}));
  }

  /**
   * 获取工作项工作流信息
   * 
   * @param request - GetWorkItemWorkFlowInfoRequest
   * @returns GetWorkItemWorkFlowInfoResponse
   */
  async getWorkItemWorkFlowInfo(organizationId: string, workitemId: string, request: GetWorkItemWorkFlowInfoRequest): Promise<GetWorkItemWorkFlowInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getWorkItemWorkFlowInfoWithOptions(organizationId, workitemId, request, headers, runtime);
  }

  /**
   * 获取附件上传的元信息
   * 
   * @param request - GetWorkitemAttachmentCreatemetaRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetWorkitemAttachmentCreatemetaResponse
   */
  async getWorkitemAttachmentCreatemetaWithOptions(organizationId: string, workitemIdentifier: string, request: GetWorkitemAttachmentCreatemetaRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetWorkitemAttachmentCreatemetaResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.fileName)) {
      query["fileName"] = request.fileName;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetWorkitemAttachmentCreatemeta",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitem/${OpenApiUtil.getEncodeParam(workitemIdentifier)}/attachment/createmeta`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetWorkitemAttachmentCreatemetaResponse>(await this.callApi(params, req, runtime), new GetWorkitemAttachmentCreatemetaResponse({}));
  }

  /**
   * 获取附件上传的元信息
   * 
   * @param request - GetWorkitemAttachmentCreatemetaRequest
   * @returns GetWorkitemAttachmentCreatemetaResponse
   */
  async getWorkitemAttachmentCreatemeta(organizationId: string, workitemIdentifier: string, request: GetWorkitemAttachmentCreatemetaRequest): Promise<GetWorkitemAttachmentCreatemetaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getWorkitemAttachmentCreatemetaWithOptions(organizationId, workitemIdentifier, request, headers, runtime);
  }

  /**
   * 获得所有评论
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetWorkitemCommentListResponse
   */
  async getWorkitemCommentListWithOptions(organizationId: string, workitemId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetWorkitemCommentListResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetWorkitemCommentList",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/${OpenApiUtil.getEncodeParam(workitemId)}/commentList`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetWorkitemCommentListResponse>(await this.callApi(params, req, runtime), new GetWorkitemCommentListResponse({}));
  }

  /**
   * 获得所有评论
   * @returns GetWorkitemCommentListResponse
   */
  async getWorkitemCommentList(organizationId: string, workitemId: string): Promise<GetWorkitemCommentListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getWorkitemCommentListWithOptions(organizationId, workitemId, headers, runtime);
  }

  /**
   * 获取工作项文件信息
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetWorkitemFileResponse
   */
  async getWorkitemFileWithOptions(organizationId: string, workitemIdentifier: string, fileIdentifier: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetWorkitemFileResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetWorkitemFile",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitem/${OpenApiUtil.getEncodeParam(workitemIdentifier)}/files/${OpenApiUtil.getEncodeParam(fileIdentifier)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetWorkitemFileResponse>(await this.callApi(params, req, runtime), new GetWorkitemFileResponse({}));
  }

  /**
   * 获取工作项文件信息
   * @returns GetWorkitemFileResponse
   */
  async getWorkitemFile(organizationId: string, workitemIdentifier: string, fileIdentifier: string): Promise<GetWorkitemFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getWorkitemFileWithOptions(organizationId, workitemIdentifier, fileIdentifier, headers, runtime);
  }

  /**
   * 获得一个工作项的指定关联项
   * 
   * @param request - GetWorkitemRelationsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetWorkitemRelationsResponse
   */
  async getWorkitemRelationsWithOptions(organizationId: string, workitemId: string, request: GetWorkitemRelationsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetWorkitemRelationsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.relationType)) {
      query["relationType"] = request.relationType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetWorkitemRelations",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/${OpenApiUtil.getEncodeParam(workitemId)}/getRelations`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetWorkitemRelationsResponse>(await this.callApi(params, req, runtime), new GetWorkitemRelationsResponse({}));
  }

  /**
   * 获得一个工作项的指定关联项
   * 
   * @param request - GetWorkitemRelationsRequest
   * @returns GetWorkitemRelationsResponse
   */
  async getWorkitemRelations(organizationId: string, workitemId: string, request: GetWorkitemRelationsRequest): Promise<GetWorkitemRelationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getWorkitemRelationsWithOptions(organizationId, workitemId, request, headers, runtime);
  }

  /**
   * 获得一个企业下所有工时类型
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetWorkitemTimeTypeListResponse
   */
  async getWorkitemTimeTypeListWithOptions(organizationId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetWorkitemTimeTypeListResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetWorkitemTimeTypeList",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/type/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetWorkitemTimeTypeListResponse>(await this.callApi(params, req, runtime), new GetWorkitemTimeTypeListResponse({}));
  }

  /**
   * 获得一个企业下所有工时类型
   * @returns GetWorkitemTimeTypeListResponse
   */
  async getWorkitemTimeTypeList(organizationId: string): Promise<GetWorkitemTimeTypeListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getWorkitemTimeTypeListWithOptions(organizationId, headers, runtime);
  }

  /**
   * 查询工作空间详情
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetWorkspaceResponse
   */
  async getWorkspaceWithOptions(workspaceId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<GetWorkspaceResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "GetWorkspace",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/workspaces/${OpenApiUtil.getEncodeParam(workspaceId)}`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetWorkspaceResponse>(await this.callApi(params, req, runtime), new GetWorkspaceResponse({}));
  }

  /**
   * 查询工作空间详情
   * @returns GetWorkspaceResponse
   */
  async getWorkspace(workspaceId: string): Promise<GetWorkspaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.getWorkspaceWithOptions(workspaceId, headers, runtime);
  }

  /**
   * 加入流水线分组
   * 
   * @param request - JoinPipelineGroupRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns JoinPipelineGroupResponse
   */
  async joinPipelineGroupWithOptions(organizationId: string, request: JoinPipelineGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<JoinPipelineGroupResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.groupId)) {
      query["groupId"] = request.groupId;
    }

    if (!Util.isUnset(request.pipelineIds)) {
      query["pipelineIds"] = request.pipelineIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "JoinPipelineGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelineGroups/join`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<JoinPipelineGroupResponse>(await this.callApi(params, req, runtime), new JoinPipelineGroupResponse({}));
  }

  /**
   * 加入流水线分组
   * 
   * @param request - JoinPipelineGroupRequest
   * @returns JoinPipelineGroupResponse
   */
  async joinPipelineGroup(organizationId: string, request: JoinPipelineGroupRequest): Promise<JoinPipelineGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.joinPipelineGroupWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 关联合并请求Label
   * 
   * @param request - LinkMergeRequestLabelRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns LinkMergeRequestLabelResponse
   */
  async linkMergeRequestLabelWithOptions(request: LinkMergeRequestLabelRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<LinkMergeRequestLabelResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.localId)) {
      query["localId"] = request.localId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.labelIds)) {
      body["labelIds"] = request.labelIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "LinkMergeRequestLabel",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/merge_requests/link_labels`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<LinkMergeRequestLabelResponse>(await this.callApi(params, req, runtime), new LinkMergeRequestLabelResponse({}));
  }

  /**
   * 关联合并请求Label
   * 
   * @param request - LinkMergeRequestLabelRequest
   * @returns LinkMergeRequestLabelResponse
   */
  async linkMergeRequestLabel(request: LinkMergeRequestLabelRequest): Promise<LinkMergeRequestLabelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.linkMergeRequestLabelWithOptions(request, headers, runtime);
  }

  /**
   * 查找应用下所有的研发流程
   * 
   * @param request - ListAllReleaseWorkflowsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListAllReleaseWorkflowsResponse
   */
  async listAllReleaseWorkflowsWithOptions(appName: string, request: ListAllReleaseWorkflowsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListAllReleaseWorkflowsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAllReleaseWorkflows",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}/releaseWorkflows`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "array",
    });
    return $tea.cast<ListAllReleaseWorkflowsResponse>(await this.callApi(params, req, runtime), new ListAllReleaseWorkflowsResponse({}));
  }

  /**
   * 查找应用下所有的研发流程
   * 
   * @param request - ListAllReleaseWorkflowsRequest
   * @returns ListAllReleaseWorkflowsResponse
   */
  async listAllReleaseWorkflows(appName: string, request: ListAllReleaseWorkflowsRequest): Promise<ListAllReleaseWorkflowsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listAllReleaseWorkflowsWithOptions(appName, request, headers, runtime);
  }

  /**
   * 查询研发阶段执行记录集成变更信息
   * 
   * @param request - ListAppReleaseStageExecutionIntegratedMetadataRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListAppReleaseStageExecutionIntegratedMetadataResponse
   */
  async listAppReleaseStageExecutionIntegratedMetadataWithOptions(appName: string, releaseWorkflowSn: string, releaseStageSn: string, executionNumber: string, request: ListAppReleaseStageExecutionIntegratedMetadataRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListAppReleaseStageExecutionIntegratedMetadataResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAppReleaseStageExecutionIntegratedMetadata",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}/releaseWorkflows/${OpenApiUtil.getEncodeParam(releaseWorkflowSn)}/releaseStages/${OpenApiUtil.getEncodeParam(releaseStageSn)}/executions/${OpenApiUtil.getEncodeParam(executionNumber)}/integratedMetadata`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "array",
    });
    return $tea.cast<ListAppReleaseStageExecutionIntegratedMetadataResponse>(await this.callApi(params, req, runtime), new ListAppReleaseStageExecutionIntegratedMetadataResponse({}));
  }

  /**
   * 查询研发阶段执行记录集成变更信息
   * 
   * @param request - ListAppReleaseStageExecutionIntegratedMetadataRequest
   * @returns ListAppReleaseStageExecutionIntegratedMetadataResponse
   */
  async listAppReleaseStageExecutionIntegratedMetadata(appName: string, releaseWorkflowSn: string, releaseStageSn: string, executionNumber: string, request: ListAppReleaseStageExecutionIntegratedMetadataRequest): Promise<ListAppReleaseStageExecutionIntegratedMetadataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listAppReleaseStageExecutionIntegratedMetadataWithOptions(appName, releaseWorkflowSn, releaseStageSn, executionNumber, request, headers, runtime);
  }

  /**
   * 批量查询研发阶段执行记录
   * 
   * @param request - ListAppReleaseStageExecutionsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListAppReleaseStageExecutionsResponse
   */
  async listAppReleaseStageExecutionsWithOptions(appName: string, releaseWorkflowSn: string, releaseStageSn: string, request: ListAppReleaseStageExecutionsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListAppReleaseStageExecutionsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["orderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pagination)) {
      query["pagination"] = request.pagination;
    }

    if (!Util.isUnset(request.perPage)) {
      query["perPage"] = request.perPage;
    }

    if (!Util.isUnset(request.sort)) {
      query["sort"] = request.sort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAppReleaseStageExecutions",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}/releaseWorkflows/${OpenApiUtil.getEncodeParam(releaseWorkflowSn)}/releaseStages/${OpenApiUtil.getEncodeParam(releaseStageSn)}/executions`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListAppReleaseStageExecutionsResponse>(await this.callApi(params, req, runtime), new ListAppReleaseStageExecutionsResponse({}));
  }

  /**
   * 批量查询研发阶段执行记录
   * 
   * @param request - ListAppReleaseStageExecutionsRequest
   * @returns ListAppReleaseStageExecutionsResponse
   */
  async listAppReleaseStageExecutions(appName: string, releaseWorkflowSn: string, releaseStageSn: string, request: ListAppReleaseStageExecutionsRequest): Promise<ListAppReleaseStageExecutionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listAppReleaseStageExecutionsWithOptions(appName, releaseWorkflowSn, releaseStageSn, request, headers, runtime);
  }

  /**
   * 查找应用成员列表
   * 
   * @param request - ListApplicationMembersRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListApplicationMembersResponse
   */
  async listApplicationMembersWithOptions(appName: string, request: ListApplicationMembersRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListApplicationMembersResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListApplicationMembers",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}/members`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListApplicationMembersResponse>(await this.callApi(params, req, runtime), new ListApplicationMembersResponse({}));
  }

  /**
   * 查找应用成员列表
   * 
   * @param request - ListApplicationMembersRequest
   * @returns ListApplicationMembersResponse
   */
  async listApplicationMembers(appName: string, request: ListApplicationMembersRequest): Promise<ListApplicationMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listApplicationMembersWithOptions(appName, request, headers, runtime);
  }

  /**
   * 分页查找应用详情
   * 
   * @param request - ListApplicationsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListApplicationsResponse
   */
  async listApplicationsWithOptions(request: ListApplicationsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListApplicationsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["orderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.pagination)) {
      query["pagination"] = request.pagination;
    }

    if (!Util.isUnset(request.perPage)) {
      query["perPage"] = request.perPage;
    }

    if (!Util.isUnset(request.sort)) {
      query["sort"] = request.sort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListApplications",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps%3Asearch`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListApplicationsResponse>(await this.callApi(params, req, runtime), new ListApplicationsResponse({}));
  }

  /**
   * 分页查找应用详情
   * 
   * @param request - ListApplicationsRequest
   * @returns ListApplicationsResponse
   */
  async listApplications(request: ListApplicationsRequest): Promise<ListApplicationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listApplicationsWithOptions(request, headers, runtime);
  }

  /**
   * 查询变更研发流程运行记录
   * 
   * @param request - ListChangeRequestWorkflowExecutionsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListChangeRequestWorkflowExecutionsResponse
   */
  async listChangeRequestWorkflowExecutionsWithOptions(appName: string, sn: string, request: ListChangeRequestWorkflowExecutionsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListChangeRequestWorkflowExecutionsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.orderBy)) {
      query["orderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.perPage)) {
      query["perPage"] = request.perPage;
    }

    if (!Util.isUnset(request.releaseStageSn)) {
      query["releaseStageSn"] = request.releaseStageSn;
    }

    if (!Util.isUnset(request.releaseWorkflowSn)) {
      query["releaseWorkflowSn"] = request.releaseWorkflowSn;
    }

    if (!Util.isUnset(request.sort)) {
      query["sort"] = request.sort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListChangeRequestWorkflowExecutions",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}/changeRequests/${OpenApiUtil.getEncodeParam(sn)}/executions`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListChangeRequestWorkflowExecutionsResponse>(await this.callApi(params, req, runtime), new ListChangeRequestWorkflowExecutionsResponse({}));
  }

  /**
   * 查询变更研发流程运行记录
   * 
   * @param request - ListChangeRequestWorkflowExecutionsRequest
   * @returns ListChangeRequestWorkflowExecutionsResponse
   */
  async listChangeRequestWorkflowExecutions(appName: string, sn: string, request: ListChangeRequestWorkflowExecutionsRequest): Promise<ListChangeRequestWorkflowExecutionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listChangeRequestWorkflowExecutionsWithOptions(appName, sn, request, headers, runtime);
  }

  /**
   * 查询变更列表
   * 
   * @param tmpReq - ListChangeRequestsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListChangeRequestsResponse
   */
  async listChangeRequestsWithOptions(appName: string, tmpReq: ListChangeRequestsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListChangeRequestsResponse> {
    Util.validateModel(tmpReq);
    let request = new ListChangeRequestsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.appNameList)) {
      request.appNameListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.appNameList, "appNameList", "json");
    }

    if (!Util.isUnset(tmpReq.ownerIdList)) {
      request.ownerIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ownerIdList, "ownerIdList", "json");
    }

    if (!Util.isUnset(tmpReq.stateList)) {
      request.stateListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.stateList, "stateList", "json");
    }

    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appNameListShrink)) {
      query["appNameList"] = request.appNameListShrink;
    }

    if (!Util.isUnset(request.displayNameKeyword)) {
      query["displayNameKeyword"] = request.displayNameKeyword;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["orderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.ownerIdListShrink)) {
      query["ownerIdList"] = request.ownerIdListShrink;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pagination)) {
      query["pagination"] = request.pagination;
    }

    if (!Util.isUnset(request.perPage)) {
      query["perPage"] = request.perPage;
    }

    if (!Util.isUnset(request.sort)) {
      query["sort"] = request.sort;
    }

    if (!Util.isUnset(request.stateListShrink)) {
      query["stateList"] = request.stateListShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListChangeRequests",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}/changeRequests`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListChangeRequestsResponse>(await this.callApi(params, req, runtime), new ListChangeRequestsResponse({}));
  }

  /**
   * 查询变更列表
   * 
   * @param request - ListChangeRequestsRequest
   * @returns ListChangeRequestsResponse
   */
  async listChangeRequests(appName: string, request: ListChangeRequestsRequest): Promise<ListChangeRequestsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listChangeRequestsWithOptions(appName, request, headers, runtime);
  }

  /**
   * 查询检查运行列表
   * 
   * @param request - ListCheckRunsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListCheckRunsResponse
   */
  async listCheckRunsWithOptions(request: ListCheckRunsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListCheckRunsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.ref)) {
      query["ref"] = request.ref;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCheckRuns",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/check_runs/list_check_runs`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListCheckRunsResponse>(await this.callApi(params, req, runtime), new ListCheckRunsResponse({}));
  }

  /**
   * 查询检查运行列表
   * 
   * @param request - ListCheckRunsRequest
   * @returns ListCheckRunsResponse
   */
  async listCheckRuns(request: ListCheckRunsRequest): Promise<ListCheckRunsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listCheckRunsWithOptions(request, headers, runtime);
  }

  /**
   * 查询提交状态列表
   * 
   * @param request - ListCommitStatusesRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListCommitStatusesResponse
   */
  async listCommitStatusesWithOptions(request: ListCommitStatusesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListCommitStatusesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    if (!Util.isUnset(request.sha)) {
      query["sha"] = request.sha;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCommitStatuses",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/repository/commit_statuses/list_commit_statuses`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListCommitStatusesResponse>(await this.callApi(params, req, runtime), new ListCommitStatusesResponse({}));
  }

  /**
   * 查询提交状态列表
   * 
   * @param request - ListCommitStatusesRequest
   * @returns ListCommitStatusesResponse
   */
  async listCommitStatuses(request: ListCommitStatusesRequest): Promise<ListCommitStatusesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listCommitStatusesWithOptions(request, headers, runtime);
  }

  /**
   * 获取标签分类列表
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListFlowTagGroupsResponse
   */
  async listFlowTagGroupsWithOptions(organizationId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListFlowTagGroupsResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "ListFlowTagGroups",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/flow/tagGroups`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListFlowTagGroupsResponse>(await this.callApi(params, req, runtime), new ListFlowTagGroupsResponse({}));
  }

  /**
   * 获取标签分类列表
   * @returns ListFlowTagGroupsResponse
   */
  async listFlowTagGroups(organizationId: string): Promise<ListFlowTagGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listFlowTagGroupsWithOptions(organizationId, headers, runtime);
  }

  /**
   * 查询组成员列表
   * 
   * @param request - ListGroupMemberRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListGroupMemberResponse
   */
  async listGroupMemberWithOptions(groupId: string, request: ListGroupMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListGroupMemberResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListGroupMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/groups/${OpenApiUtil.getEncodeParam(groupId)}/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListGroupMemberResponse>(await this.callApi(params, req, runtime), new ListGroupMemberResponse({}));
  }

  /**
   * 查询组成员列表
   * 
   * @param request - ListGroupMemberRequest
   * @returns ListGroupMemberResponse
   */
  async listGroupMember(groupId: string, request: ListGroupMemberRequest): Promise<ListGroupMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listGroupMemberWithOptions(groupId, request, headers, runtime);
  }

  /**
   * 查询代码组下的库列表
   * 
   * @param request - ListGroupRepositoriesRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListGroupRepositoriesResponse
   */
  async listGroupRepositoriesWithOptions(groupId: string, request: ListGroupRepositoriesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListGroupRepositoriesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.search)) {
      query["search"] = request.search;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListGroupRepositories",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/groups/${OpenApiUtil.getEncodeParam(groupId)}/projects`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListGroupRepositoriesResponse>(await this.callApi(params, req, runtime), new ListGroupRepositoriesResponse({}));
  }

  /**
   * 查询代码组下的库列表
   * 
   * @param request - ListGroupRepositoriesRequest
   * @returns ListGroupRepositoriesResponse
   */
  async listGroupRepositories(groupId: string, request: ListGroupRepositoriesRequest): Promise<ListGroupRepositoriesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listGroupRepositoriesWithOptions(groupId, request, headers, runtime);
  }

  /**
   * 获取主机组列表
   * 
   * @param request - ListHostGroupsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListHostGroupsResponse
   */
  async listHostGroupsWithOptions(organizationId: string, request: ListHostGroupsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListHostGroupsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.createEndTime)) {
      query["createEndTime"] = request.createEndTime;
    }

    if (!Util.isUnset(request.createStartTime)) {
      query["createStartTime"] = request.createStartTime;
    }

    if (!Util.isUnset(request.creatorAccountIds)) {
      query["creatorAccountIds"] = request.creatorAccountIds;
    }

    if (!Util.isUnset(request.ids)) {
      query["ids"] = request.ids;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.name)) {
      query["name"] = request.name;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.pageOrder)) {
      query["pageOrder"] = request.pageOrder;
    }

    if (!Util.isUnset(request.pageSort)) {
      query["pageSort"] = request.pageSort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListHostGroups",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/hostGroups`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListHostGroupsResponse>(await this.callApi(params, req, runtime), new ListHostGroupsResponse({}));
  }

  /**
   * 获取主机组列表
   * 
   * @param request - ListHostGroupsRequest
   * @returns ListHostGroupsResponse
   */
  async listHostGroups(organizationId: string, request: ListHostGroupsRequest): Promise<ListHostGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listHostGroupsWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 当前用户加入的企业列表
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListJoinedOrganizationsResponse
   */
  async listJoinedOrganizationsWithOptions(headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListJoinedOrganizationsResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "ListJoinedOrganizations",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/users/joinedOrgs`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListJoinedOrganizationsResponse>(await this.callApi(params, req, runtime), new ListJoinedOrganizationsResponse({}));
  }

  /**
   * 当前用户加入的企业列表
   * @returns ListJoinedOrganizationsResponse
   */
  async listJoinedOrganizations(): Promise<ListJoinedOrganizationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listJoinedOrganizationsWithOptions(headers, runtime);
  }

  /**
   * 查询合并请求评论列表
   * 
   * @param request - ListMergeRequestCommentsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListMergeRequestCommentsResponse
   */
  async listMergeRequestCommentsWithOptions(request: ListMergeRequestCommentsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListMergeRequestCommentsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.localId)) {
      query["localId"] = request.localId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.commentType)) {
      body["commentType"] = request.commentType;
    }

    if (!Util.isUnset(request.filePath)) {
      body["filePath"] = request.filePath;
    }

    if (!Util.isUnset(request.patchSetBizIds)) {
      body["patchSetBizIds"] = request.patchSetBizIds;
    }

    if (!Util.isUnset(request.resolved)) {
      body["resolved"] = request.resolved;
    }

    if (!Util.isUnset(request.state)) {
      body["state"] = request.state;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListMergeRequestComments",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/merge_requests/comments/list_comments`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListMergeRequestCommentsResponse>(await this.callApi(params, req, runtime), new ListMergeRequestCommentsResponse({}));
  }

  /**
   * 查询合并请求评论列表
   * 
   * @param request - ListMergeRequestCommentsRequest
   * @returns ListMergeRequestCommentsResponse
   */
  async listMergeRequestComments(request: ListMergeRequestCommentsRequest): Promise<ListMergeRequestCommentsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listMergeRequestCommentsWithOptions(request, headers, runtime);
  }

  /**
   * 查询合并请求文件已读列表
   * 
   * @param request - ListMergeRequestFilesReadsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListMergeRequestFilesReadsResponse
   */
  async listMergeRequestFilesReadsWithOptions(request: ListMergeRequestFilesReadsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListMergeRequestFilesReadsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.fromPatchSetBizId)) {
      query["fromPatchSetBizId"] = request.fromPatchSetBizId;
    }

    if (!Util.isUnset(request.localId)) {
      query["localId"] = request.localId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    if (!Util.isUnset(request.toPatchSetBizId)) {
      query["toPatchSetBizId"] = request.toPatchSetBizId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListMergeRequestFilesReads",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/merge_requests/diffs/files_read_infos`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListMergeRequestFilesReadsResponse>(await this.callApi(params, req, runtime), new ListMergeRequestFilesReadsResponse({}));
  }

  /**
   * 查询合并请求文件已读列表
   * 
   * @param request - ListMergeRequestFilesReadsRequest
   * @returns ListMergeRequestFilesReadsResponse
   */
  async listMergeRequestFilesReads(request: ListMergeRequestFilesReadsRequest): Promise<ListMergeRequestFilesReadsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listMergeRequestFilesReadsWithOptions(request, headers, runtime);
  }

  /**
   * 查询合并请求Label列表
   * 
   * @param request - ListMergeRequestLabelsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListMergeRequestLabelsResponse
   */
  async listMergeRequestLabelsWithOptions(request: ListMergeRequestLabelsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListMergeRequestLabelsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.localId)) {
      query["localId"] = request.localId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListMergeRequestLabels",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/merge_requests/labels`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListMergeRequestLabelsResponse>(await this.callApi(params, req, runtime), new ListMergeRequestLabelsResponse({}));
  }

  /**
   * 查询合并请求Label列表
   * 
   * @param request - ListMergeRequestLabelsRequest
   * @returns ListMergeRequestLabelsResponse
   */
  async listMergeRequestLabels(request: ListMergeRequestLabelsRequest): Promise<ListMergeRequestLabelsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listMergeRequestLabelsWithOptions(request, headers, runtime);
  }

  /**
   * 查询合并请求的版本列表
   * 
   * @param request - ListMergeRequestPatchSetsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListMergeRequestPatchSetsResponse
   */
  async listMergeRequestPatchSetsWithOptions(request: ListMergeRequestPatchSetsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListMergeRequestPatchSetsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.localId)) {
      query["localId"] = request.localId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListMergeRequestPatchSets",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/merge_requests/diffs/list_patchsets`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListMergeRequestPatchSetsResponse>(await this.callApi(params, req, runtime), new ListMergeRequestPatchSetsResponse({}));
  }

  /**
   * 查询合并请求的版本列表
   * 
   * @param request - ListMergeRequestPatchSetsRequest
   * @returns ListMergeRequestPatchSetsResponse
   */
  async listMergeRequestPatchSets(request: ListMergeRequestPatchSetsRequest): Promise<ListMergeRequestPatchSetsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listMergeRequestPatchSetsWithOptions(request, headers, runtime);
  }

  /**
   * 查询代码评审列表
   * 
   * @param request - ListMergeRequestsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListMergeRequestsResponse
   */
  async listMergeRequestsWithOptions(request: ListMergeRequestsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListMergeRequestsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.authorIds)) {
      query["authorIds"] = request.authorIds;
    }

    if (!Util.isUnset(request.createdAfter)) {
      query["createdAfter"] = request.createdAfter;
    }

    if (!Util.isUnset(request.createdBefore)) {
      query["createdBefore"] = request.createdBefore;
    }

    if (!Util.isUnset(request.filter)) {
      query["filter"] = request.filter;
    }

    if (!Util.isUnset(request.groupIds)) {
      query["groupIds"] = request.groupIds;
    }

    if (!Util.isUnset(request.labelIds)) {
      query["labelIds"] = request.labelIds;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["orderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectIds)) {
      query["projectIds"] = request.projectIds;
    }

    if (!Util.isUnset(request.reviewerIds)) {
      query["reviewerIds"] = request.reviewerIds;
    }

    if (!Util.isUnset(request.search)) {
      query["search"] = request.search;
    }

    if (!Util.isUnset(request.sort)) {
      query["sort"] = request.sort;
    }

    if (!Util.isUnset(request.state)) {
      query["state"] = request.state;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListMergeRequests",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/merge_requests/advanced_search`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListMergeRequestsResponse>(await this.callApi(params, req, runtime), new ListMergeRequestsResponse({}));
  }

  /**
   * 查询代码评审列表
   * 
   * @param request - ListMergeRequestsRequest
   * @returns ListMergeRequestsResponse
   */
  async listMergeRequests(request: ListMergeRequestsRequest): Promise<ListMergeRequestsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listMergeRequestsWithOptions(request, headers, runtime);
  }

  /**
   * 获取企业成员列表
   * 
   * @param request - ListOrganizationMembersRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListOrganizationMembersResponse
   */
  async listOrganizationMembersWithOptions(organizationId: string, request: ListOrganizationMembersRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListOrganizationMembersResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.containsExternInfo)) {
      query["containsExternInfo"] = request.containsExternInfo;
    }

    if (!Util.isUnset(request.externUid)) {
      query["externUid"] = request.externUid;
    }

    if (!Util.isUnset(request.joinTimeFrom)) {
      query["joinTimeFrom"] = request.joinTimeFrom;
    }

    if (!Util.isUnset(request.joinTimeTo)) {
      query["joinTimeTo"] = request.joinTimeTo;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.organizationMemberName)) {
      query["organizationMemberName"] = request.organizationMemberName;
    }

    if (!Util.isUnset(request.provider)) {
      query["provider"] = request.provider;
    }

    if (!Util.isUnset(request.state)) {
      query["state"] = request.state;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOrganizationMembers",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/members`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListOrganizationMembersResponse>(await this.callApi(params, req, runtime), new ListOrganizationMembersResponse({}));
  }

  /**
   * 获取企业成员列表
   * 
   * @param request - ListOrganizationMembersRequest
   * @returns ListOrganizationMembersResponse
   */
  async listOrganizationMembers(organizationId: string, request: ListOrganizationMembersRequest): Promise<ListOrganizationMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listOrganizationMembersWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 查询用户企业列表
   * 
   * @param request - ListOrganizationsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListOrganizationsResponse
   */
  async listOrganizationsWithOptions(request: ListOrganizationsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListOrganizationsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessLevel)) {
      query["accessLevel"] = request.accessLevel;
    }

    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.minAccessLevel)) {
      query["minAccessLevel"] = request.minAccessLevel;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOrganizations",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organizations/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListOrganizationsResponse>(await this.callApi(params, req, runtime), new ListOrganizationsResponse({}));
  }

  /**
   * 查询用户企业列表
   * 
   * @param request - ListOrganizationsRequest
   * @returns ListOrganizationsResponse
   */
  async listOrganizations(request: ListOrganizationsRequest): Promise<ListOrganizationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listOrganizationsWithOptions(request, headers, runtime);
  }

  /**
   * 获取流水线分组下流水线列表列表
   * 
   * @param request - ListPipelineGroupPipelinesRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPipelineGroupPipelinesResponse
   */
  async listPipelineGroupPipelinesWithOptions(organizationId: string, groupId: string, request: ListPipelineGroupPipelinesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListPipelineGroupPipelinesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.createEndTime)) {
      query["createEndTime"] = request.createEndTime;
    }

    if (!Util.isUnset(request.createStartTime)) {
      query["createStartTime"] = request.createStartTime;
    }

    if (!Util.isUnset(request.executeEndTime)) {
      query["executeEndTime"] = request.executeEndTime;
    }

    if (!Util.isUnset(request.executeStartTime)) {
      query["executeStartTime"] = request.executeStartTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.pipelineName)) {
      query["pipelineName"] = request.pipelineName;
    }

    if (!Util.isUnset(request.resultStatusList)) {
      query["resultStatusList"] = request.resultStatusList;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPipelineGroupPipelines",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelineGroups/${OpenApiUtil.getEncodeParam(groupId)}/pipelines`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListPipelineGroupPipelinesResponse>(await this.callApi(params, req, runtime), new ListPipelineGroupPipelinesResponse({}));
  }

  /**
   * 获取流水线分组下流水线列表列表
   * 
   * @param request - ListPipelineGroupPipelinesRequest
   * @returns ListPipelineGroupPipelinesResponse
   */
  async listPipelineGroupPipelines(organizationId: string, groupId: string, request: ListPipelineGroupPipelinesRequest): Promise<ListPipelineGroupPipelinesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listPipelineGroupPipelinesWithOptions(organizationId, groupId, request, headers, runtime);
  }

  /**
   * 获取流水线分组列表
   * 
   * @param request - ListPipelineGroupsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPipelineGroupsResponse
   */
  async listPipelineGroupsWithOptions(organizationId: string, request: ListPipelineGroupsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListPipelineGroupsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPipelineGroups",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelineGroups`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListPipelineGroupsResponse>(await this.callApi(params, req, runtime), new ListPipelineGroupsResponse({}));
  }

  /**
   * 获取流水线分组列表
   * 
   * @param request - ListPipelineGroupsRequest
   * @returns ListPipelineGroupsResponse
   */
  async listPipelineGroups(organizationId: string, request: ListPipelineGroupsRequest): Promise<ListPipelineGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listPipelineGroupsWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 获取流水线运行过的任务历史
   * 
   * @param request - ListPipelineJobHistorysRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPipelineJobHistorysResponse
   */
  async listPipelineJobHistorysWithOptions(organizationId: string, pipelineId: string, request: ListPipelineJobHistorysRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListPipelineJobHistorysResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.category)) {
      query["category"] = request.category;
    }

    if (!Util.isUnset(request.identifier)) {
      query["identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPipelineJobHistorys",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipeline/${OpenApiUtil.getEncodeParam(pipelineId)}/job/historys`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListPipelineJobHistorysResponse>(await this.callApi(params, req, runtime), new ListPipelineJobHistorysResponse({}));
  }

  /**
   * 获取流水线运行过的任务历史
   * 
   * @param request - ListPipelineJobHistorysRequest
   * @returns ListPipelineJobHistorysResponse
   */
  async listPipelineJobHistorys(organizationId: string, pipelineId: string, request: ListPipelineJobHistorysRequest): Promise<ListPipelineJobHistorysResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listPipelineJobHistorysWithOptions(organizationId, pipelineId, request, headers, runtime);
  }

  /**
   * 获取流水线运行过的任务
   * 
   * @param request - ListPipelineJobsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPipelineJobsResponse
   */
  async listPipelineJobsWithOptions(organizationId: string, pipelineId: string, request: ListPipelineJobsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListPipelineJobsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.category)) {
      query["category"] = request.category;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPipelineJobs",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipeline/${OpenApiUtil.getEncodeParam(pipelineId)}/jobs`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListPipelineJobsResponse>(await this.callApi(params, req, runtime), new ListPipelineJobsResponse({}));
  }

  /**
   * 获取流水线运行过的任务
   * 
   * @param request - ListPipelineJobsRequest
   * @returns ListPipelineJobsResponse
   */
  async listPipelineJobs(organizationId: string, pipelineId: string, request: ListPipelineJobsRequest): Promise<ListPipelineJobsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listPipelineJobsWithOptions(organizationId, pipelineId, request, headers, runtime);
  }

  /**
   * 获取流水线关联列表
   * 
   * @param request - ListPipelineRelationsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPipelineRelationsResponse
   */
  async listPipelineRelationsWithOptions(organizationId: string, pipelineId: string, request: ListPipelineRelationsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListPipelineRelationsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.relObjectType)) {
      query["relObjectType"] = request.relObjectType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPipelineRelations",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRelations`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListPipelineRelationsResponse>(await this.callApi(params, req, runtime), new ListPipelineRelationsResponse({}));
  }

  /**
   * 获取流水线关联列表
   * 
   * @param request - ListPipelineRelationsRequest
   * @returns ListPipelineRelationsResponse
   */
  async listPipelineRelations(organizationId: string, pipelineId: string, request: ListPipelineRelationsRequest): Promise<ListPipelineRelationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listPipelineRelationsWithOptions(organizationId, pipelineId, request, headers, runtime);
  }

  /**
   * 获取流水线运行历史
   * 
   * @param request - ListPipelineRunsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPipelineRunsResponse
   */
  async listPipelineRunsWithOptions(organizationId: string, pipelineId: string, request: ListPipelineRunsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListPipelineRunsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      query["endTime"] = request.endTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.startTime)) {
      query["startTime"] = request.startTime;
    }

    if (!Util.isUnset(request.status)) {
      query["status"] = request.status;
    }

    if (!Util.isUnset(request.triggerMode)) {
      query["triggerMode"] = request.triggerMode;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPipelineRuns",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRuns`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListPipelineRunsResponse>(await this.callApi(params, req, runtime), new ListPipelineRunsResponse({}));
  }

  /**
   * 获取流水线运行历史
   * 
   * @param request - ListPipelineRunsRequest
   * @returns ListPipelineRunsResponse
   */
  async listPipelineRuns(organizationId: string, pipelineId: string, request: ListPipelineRunsRequest): Promise<ListPipelineRunsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listPipelineRunsWithOptions(organizationId, pipelineId, request, headers, runtime);
  }

  /**
   * 获取流水线列表
   * 
   * @param request - ListPipelinesRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPipelinesResponse
   */
  async listPipelinesWithOptions(organizationId: string, request: ListPipelinesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListPipelinesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.createEndTime)) {
      query["createEndTime"] = request.createEndTime;
    }

    if (!Util.isUnset(request.createStartTime)) {
      query["createStartTime"] = request.createStartTime;
    }

    if (!Util.isUnset(request.creatorAccountIds)) {
      query["creatorAccountIds"] = request.creatorAccountIds;
    }

    if (!Util.isUnset(request.executeAccountIds)) {
      query["executeAccountIds"] = request.executeAccountIds;
    }

    if (!Util.isUnset(request.executeEndTime)) {
      query["executeEndTime"] = request.executeEndTime;
    }

    if (!Util.isUnset(request.executeStartTime)) {
      query["executeStartTime"] = request.executeStartTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.pipelineName)) {
      query["pipelineName"] = request.pipelineName;
    }

    if (!Util.isUnset(request.statusList)) {
      query["statusList"] = request.statusList;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPipelines",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListPipelinesResponse>(await this.callApi(params, req, runtime), new ListPipelinesResponse({}));
  }

  /**
   * 获取流水线列表
   * 
   * @param request - ListPipelinesRequest
   * @returns ListPipelinesResponse
   */
  async listPipelines(organizationId: string, request: ListPipelinesRequest): Promise<ListPipelinesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listPipelinesWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 查询代码库Label列表
   * 
   * @param request - ListProjectLabelsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListProjectLabelsResponse
   */
  async listProjectLabelsWithOptions(request: ListProjectLabelsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListProjectLabelsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["orderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    if (!Util.isUnset(request.search)) {
      query["search"] = request.search;
    }

    if (!Util.isUnset(request.sort)) {
      query["sort"] = request.sort;
    }

    if (!Util.isUnset(request.withCounts)) {
      query["withCounts"] = request.withCounts;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProjectLabels",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/labels`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListProjectLabelsResponse>(await this.callApi(params, req, runtime), new ListProjectLabelsResponse({}));
  }

  /**
   * 查询代码库Label列表
   * 
   * @param request - ListProjectLabelsRequest
   * @returns ListProjectLabelsResponse
   */
  async listProjectLabels(request: ListProjectLabelsRequest): Promise<ListProjectLabelsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listProjectLabelsWithOptions(request, headers, runtime);
  }

  /**
   * 根据项目id获取项目所以成员
   * 
   * @param request - ListProjectMembersRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListProjectMembersResponse
   */
  async listProjectMembersWithOptions(organizationId: string, projectId: string, request: ListProjectMembersRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListProjectMembersResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.targetType)) {
      query["targetType"] = request.targetType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProjectMembers",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/projects/${OpenApiUtil.getEncodeParam(projectId)}/listMembers`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListProjectMembersResponse>(await this.callApi(params, req, runtime), new ListProjectMembersResponse({}));
  }

  /**
   * 根据项目id获取项目所以成员
   * 
   * @param request - ListProjectMembersRequest
   * @returns ListProjectMembersResponse
   */
  async listProjectMembers(organizationId: string, projectId: string, request: ListProjectMembersRequest): Promise<ListProjectMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listProjectMembersWithOptions(organizationId, projectId, request, headers, runtime);
  }

  /**
   * 获取项目模板列表
   * 
   * @param request - ListProjectTemplatesRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListProjectTemplatesResponse
   */
  async listProjectTemplatesWithOptions(organizationId: string, request: ListProjectTemplatesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListProjectTemplatesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.category)) {
      query["category"] = request.category;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProjectTemplates",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/projects/listTemplates`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListProjectTemplatesResponse>(await this.callApi(params, req, runtime), new ListProjectTemplatesResponse({}));
  }

  /**
   * 获取项目模板列表
   * 
   * @param request - ListProjectTemplatesRequest
   * @returns ListProjectTemplatesResponse
   */
  async listProjectTemplates(organizationId: string, request: ListProjectTemplatesRequest): Promise<ListProjectTemplatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listProjectTemplatesWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 获取项目下开启的工作项类型
   * 
   * @param request - ListProjectWorkitemTypesRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListProjectWorkitemTypesResponse
   */
  async listProjectWorkitemTypesWithOptions(organizationId: string, projectId: string, request: ListProjectWorkitemTypesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListProjectWorkitemTypesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.category)) {
      query["category"] = request.category;
    }

    if (!Util.isUnset(request.spaceType)) {
      query["spaceType"] = request.spaceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProjectWorkitemTypes",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/projects/${OpenApiUtil.getEncodeParam(projectId)}/getWorkitemType`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListProjectWorkitemTypesResponse>(await this.callApi(params, req, runtime), new ListProjectWorkitemTypesResponse({}));
  }

  /**
   * 获取项目下开启的工作项类型
   * 
   * @param request - ListProjectWorkitemTypesRequest
   * @returns ListProjectWorkitemTypesResponse
   */
  async listProjectWorkitemTypes(organizationId: string, projectId: string, request: ListProjectWorkitemTypesRequest): Promise<ListProjectWorkitemTypesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listProjectWorkitemTypesWithOptions(organizationId, projectId, request, headers, runtime);
  }

  /**
   * 获取项目列表
   * 
   * @param request - ListProjectsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListProjectsResponse
   */
  async listProjectsWithOptions(organizationId: string, request: ListProjectsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListProjectsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.category)) {
      query["category"] = request.category;
    }

    if (!Util.isUnset(request.conditions)) {
      query["conditions"] = request.conditions;
    }

    if (!Util.isUnset(request.extraConditions)) {
      query["extraConditions"] = request.extraConditions;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.scope)) {
      query["scope"] = request.scope;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProjects",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/listProjects`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListProjectsResponse>(await this.callApi(params, req, runtime), new ListProjectsResponse({}));
  }

  /**
   * 获取项目列表
   * 
   * @param request - ListProjectsRequest
   * @returns ListProjectsResponse
   */
  async listProjects(organizationId: string, request: ListProjectsRequest): Promise<ListProjectsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listProjectsWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 查询保护分支列表
   * 
   * @param request - ListProtectedBranchesRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListProtectedBranchesResponse
   */
  async listProtectedBranchesWithOptions(repositoryId: string, request: ListProtectedBranchesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListProtectedBranchesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProtectedBranches",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/protect_branches`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListProtectedBranchesResponse>(await this.callApi(params, req, runtime), new ListProtectedBranchesResponse({}));
  }

  /**
   * 查询保护分支列表
   * 
   * @param request - ListProtectedBranchesRequest
   * @returns ListProtectedBranchesResponse
   */
  async listProtectedBranches(repositoryId: string, request: ListProtectedBranchesRequest): Promise<ListProtectedBranchesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listProtectedBranchesWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 查询推送规则列表
   * 
   * @param request - ListPushRulesRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPushRulesResponse
   */
  async listPushRulesWithOptions(repositoryId: string, request: ListPushRulesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListPushRulesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPushRules",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/push_rule/push_rules/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListPushRulesResponse>(await this.callApi(params, req, runtime), new ListPushRulesResponse({}));
  }

  /**
   * 查询推送规则列表
   * 
   * @param request - ListPushRulesRequest
   * @returns ListPushRulesResponse
   */
  async listPushRules(repositoryId: string, request: ListPushRulesRequest): Promise<ListPushRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listPushRulesWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 查询代码库列表
   * 
   * @param request - ListRepositoriesRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListRepositoriesResponse
   */
  async listRepositoriesWithOptions(request: ListRepositoriesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListRepositoriesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.archived)) {
      query["archived"] = request.archived;
    }

    if (!Util.isUnset(request.minAccessLevel)) {
      query["minAccessLevel"] = request.minAccessLevel;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["orderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.perPage)) {
      query["perPage"] = request.perPage;
    }

    if (!Util.isUnset(request.search)) {
      query["search"] = request.search;
    }

    if (!Util.isUnset(request.sort)) {
      query["sort"] = request.sort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRepositories",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListRepositoriesResponse>(await this.callApi(params, req, runtime), new ListRepositoriesResponse({}));
  }

  /**
   * 查询代码库列表
   * 
   * @param request - ListRepositoriesRequest
   * @returns ListRepositoriesResponse
   */
  async listRepositories(request: ListRepositoriesRequest): Promise<ListRepositoriesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listRepositoriesWithOptions(request, headers, runtime);
  }

  /**
   * 查询分支列表
   * 
   * @param request - ListRepositoryBranchesRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListRepositoryBranchesResponse
   */
  async listRepositoryBranchesWithOptions(repositoryId: string, request: ListRepositoryBranchesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListRepositoryBranchesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.search)) {
      query["search"] = request.search;
    }

    if (!Util.isUnset(request.sort)) {
      query["sort"] = request.sort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRepositoryBranches",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/branches`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListRepositoryBranchesResponse>(await this.callApi(params, req, runtime), new ListRepositoryBranchesResponse({}));
  }

  /**
   * 查询分支列表
   * 
   * @param request - ListRepositoryBranchesRequest
   * @returns ListRepositoryBranchesResponse
   */
  async listRepositoryBranches(repositoryId: string, request: ListRepositoryBranchesRequest): Promise<ListRepositoryBranchesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listRepositoryBranchesWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 查询代码库单个提交（Commit）的提交内容
   * 
   * @param request - ListRepositoryCommitDiffRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListRepositoryCommitDiffResponse
   */
  async listRepositoryCommitDiffWithOptions(repositoryId: string, sha: string, request: ListRepositoryCommitDiffRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListRepositoryCommitDiffResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.contextLine)) {
      query["contextLine"] = request.contextLine;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRepositoryCommitDiff",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/commits/${OpenApiUtil.getEncodeParam(sha)}/diff`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListRepositoryCommitDiffResponse>(await this.callApi(params, req, runtime), new ListRepositoryCommitDiffResponse({}));
  }

  /**
   * 查询代码库单个提交（Commit）的提交内容
   * 
   * @param request - ListRepositoryCommitDiffRequest
   * @returns ListRepositoryCommitDiffResponse
   */
  async listRepositoryCommitDiff(repositoryId: string, sha: string, request: ListRepositoryCommitDiffRequest): Promise<ListRepositoryCommitDiffResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listRepositoryCommitDiffWithOptions(repositoryId, sha, request, headers, runtime);
  }

  /**
   * 查询代码库提交历史
   * 
   * @param request - ListRepositoryCommitsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListRepositoryCommitsResponse
   */
  async listRepositoryCommitsWithOptions(repositoryId: string, request: ListRepositoryCommitsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListRepositoryCommitsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.end)) {
      query["end"] = request.end;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.path)) {
      query["path"] = request.path;
    }

    if (!Util.isUnset(request.refName)) {
      query["refName"] = request.refName;
    }

    if (!Util.isUnset(request.search)) {
      query["search"] = request.search;
    }

    if (!Util.isUnset(request.showCommentsCount)) {
      query["showCommentsCount"] = request.showCommentsCount;
    }

    if (!Util.isUnset(request.showSignature)) {
      query["showSignature"] = request.showSignature;
    }

    if (!Util.isUnset(request.start)) {
      query["start"] = request.start;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRepositoryCommits",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/commits`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListRepositoryCommitsResponse>(await this.callApi(params, req, runtime), new ListRepositoryCommitsResponse({}));
  }

  /**
   * 查询代码库提交历史
   * 
   * @param request - ListRepositoryCommitsRequest
   * @returns ListRepositoryCommitsResponse
   */
  async listRepositoryCommits(repositoryId: string, request: ListRepositoryCommitsRequest): Promise<ListRepositoryCommitsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listRepositoryCommitsWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 查询代码组列表
   * 
   * @param request - ListRepositoryGroupsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListRepositoryGroupsResponse
   */
  async listRepositoryGroupsWithOptions(request: ListRepositoryGroupsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListRepositoryGroupsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.includePersonal)) {
      query["includePersonal"] = request.includePersonal;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["orderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.parentId)) {
      query["parentId"] = request.parentId;
    }

    if (!Util.isUnset(request.search)) {
      query["search"] = request.search;
    }

    if (!Util.isUnset(request.sort)) {
      query["sort"] = request.sort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRepositoryGroups",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/groups/get/all`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListRepositoryGroupsResponse>(await this.callApi(params, req, runtime), new ListRepositoryGroupsResponse({}));
  }

  /**
   * 查询代码组列表
   * 
   * @param request - ListRepositoryGroupsRequest
   * @returns ListRepositoryGroupsResponse
   */
  async listRepositoryGroups(request: ListRepositoryGroupsRequest): Promise<ListRepositoryGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listRepositoryGroupsWithOptions(request, headers, runtime);
  }

  /**
   * 查询代码库成员列表
   * 
   * @param request - ListRepositoryMemberWithInheritedRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListRepositoryMemberWithInheritedResponse
   */
  async listRepositoryMemberWithInheritedWithOptions(repositoryId: string, request: ListRepositoryMemberWithInheritedRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListRepositoryMemberWithInheritedResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRepositoryMemberWithInherited",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/members/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListRepositoryMemberWithInheritedResponse>(await this.callApi(params, req, runtime), new ListRepositoryMemberWithInheritedResponse({}));
  }

  /**
   * 查询代码库成员列表
   * 
   * @param request - ListRepositoryMemberWithInheritedRequest
   * @returns ListRepositoryMemberWithInheritedResponse
   */
  async listRepositoryMemberWithInherited(repositoryId: string, request: ListRepositoryMemberWithInheritedRequest): Promise<ListRepositoryMemberWithInheritedResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listRepositoryMemberWithInheritedWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 查询标签列表
   * 
   * @param request - ListRepositoryTagsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListRepositoryTagsResponse
   */
  async listRepositoryTagsWithOptions(repositoryId: string, request: ListRepositoryTagsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListRepositoryTagsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.search)) {
      query["search"] = request.search;
    }

    if (!Util.isUnset(request.sort)) {
      query["sort"] = request.sort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRepositoryTags",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/tag/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListRepositoryTagsResponse>(await this.callApi(params, req, runtime), new ListRepositoryTagsResponse({}));
  }

  /**
   * 查询标签列表
   * 
   * @param request - ListRepositoryTagsRequest
   * @returns ListRepositoryTagsResponse
   */
  async listRepositoryTags(repositoryId: string, request: ListRepositoryTagsRequest): Promise<ListRepositoryTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listRepositoryTagsWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 查询代码库文件树
   * 
   * @param request - ListRepositoryTreeRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListRepositoryTreeResponse
   */
  async listRepositoryTreeWithOptions(repositoryId: string, request: ListRepositoryTreeRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListRepositoryTreeResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.path)) {
      query["path"] = request.path;
    }

    if (!Util.isUnset(request.refName)) {
      query["refName"] = request.refName;
    }

    if (!Util.isUnset(request.type)) {
      query["type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRepositoryTree",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/files/tree`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListRepositoryTreeResponse>(await this.callApi(params, req, runtime), new ListRepositoryTreeResponse({}));
  }

  /**
   * 查询代码库文件树
   * 
   * @param request - ListRepositoryTreeRequest
   * @returns ListRepositoryTreeResponse
   */
  async listRepositoryTree(repositoryId: string, request: ListRepositoryTreeRequest): Promise<ListRepositoryTreeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listRepositoryTreeWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 查询代码库Webhook列表
   * 
   * @param request - ListRepositoryWebhookRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListRepositoryWebhookResponse
   */
  async listRepositoryWebhookWithOptions(repositoryId: string, request: ListRepositoryWebhookRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListRepositoryWebhookResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRepositoryWebhook",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/webhooks/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListRepositoryWebhookResponse>(await this.callApi(params, req, runtime), new ListRepositoryWebhookResponse({}));
  }

  /**
   * 查询代码库Webhook列表
   * 
   * @param request - ListRepositoryWebhookRequest
   * @returns ListRepositoryWebhookResponse
   */
  async listRepositoryWebhook(repositoryId: string, request: ListRepositoryWebhookRequest): Promise<ListRepositoryWebhookResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listRepositoryWebhookWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 获取资源成员列表
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListResourceMembersResponse
   */
  async listResourceMembersWithOptions(organizationId: string, resourceType: string, resourceId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListResourceMembersResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "ListResourceMembers",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/${OpenApiUtil.getEncodeParam(resourceType)}/${OpenApiUtil.getEncodeParam(resourceId)}/members`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListResourceMembersResponse>(await this.callApi(params, req, runtime), new ListResourceMembersResponse({}));
  }

  /**
   * 获取资源成员列表
   * @returns ListResourceMembersResponse
   */
  async listResourceMembers(organizationId: string, resourceType: string, resourceId: string): Promise<ListResourceMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listResourceMembersWithOptions(organizationId, resourceType, resourceId, headers, runtime);
  }

  /**
   * 搜索代码提交数据
   * 
   * @param request - ListSearchCommitRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSearchCommitResponse
   */
  async listSearchCommitWithOptions(request: ListSearchCommitRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListSearchCommitResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.keyword)) {
      body["keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.order)) {
      body["order"] = request.order;
    }

    if (!Util.isUnset(request.page)) {
      body["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.repoPath)) {
      body["repoPath"] = request.repoPath;
    }

    if (!Util.isUnset(request.scope)) {
      body["scope"] = request.scope;
    }

    if (!Util.isUnset(request.sort)) {
      body["sort"] = request.sort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListSearchCommit",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/search/commit`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListSearchCommitResponse>(await this.callApi(params, req, runtime), new ListSearchCommitResponse({}));
  }

  /**
   * 搜索代码提交数据
   * 
   * @param request - ListSearchCommitRequest
   * @returns ListSearchCommitResponse
   */
  async listSearchCommit(request: ListSearchCommitRequest): Promise<ListSearchCommitResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listSearchCommitWithOptions(request, headers, runtime);
  }

  /**
   * 搜索代码仓库数据
   * 
   * @param request - ListSearchRepositoryRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSearchRepositoryResponse
   */
  async listSearchRepositoryWithOptions(request: ListSearchRepositoryRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListSearchRepositoryResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.aliyunPk)) {
      body["aliyunPk"] = request.aliyunPk;
    }

    if (!Util.isUnset(request.keyword)) {
      body["keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.order)) {
      body["order"] = request.order;
    }

    if (!Util.isUnset(request.page)) {
      body["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.repoPath)) {
      body["repoPath"] = request.repoPath;
    }

    if (!Util.isUnset(request.scope)) {
      body["scope"] = request.scope;
    }

    if (!Util.isUnset(request.sort)) {
      body["sort"] = request.sort;
    }

    if (!Util.isUnset(request.visibilityLevel)) {
      body["visibilityLevel"] = request.visibilityLevel;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListSearchRepository",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/search/repo`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListSearchRepositoryResponse>(await this.callApi(params, req, runtime), new ListSearchRepositoryResponse({}));
  }

  /**
   * 搜索代码仓库数据
   * 
   * @param request - ListSearchRepositoryRequest
   * @returns ListSearchRepositoryResponse
   */
  async listSearchRepository(request: ListSearchRepositoryRequest): Promise<ListSearchRepositoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listSearchRepositoryWithOptions(request, headers, runtime);
  }

  /**
   * 搜索代码片段
   * 
   * @param request - ListSearchSourceCodeRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSearchSourceCodeResponse
   */
  async listSearchSourceCodeWithOptions(request: ListSearchSourceCodeRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListSearchSourceCodeResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.filePath)) {
      body["filePath"] = request.filePath;
    }

    if (!Util.isUnset(request.isCodeBlock)) {
      body["isCodeBlock"] = request.isCodeBlock;
    }

    if (!Util.isUnset(request.keyword)) {
      body["keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.language)) {
      body["language"] = request.language;
    }

    if (!Util.isUnset(request.order)) {
      body["order"] = request.order;
    }

    if (!Util.isUnset(request.page)) {
      body["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.repoPath)) {
      body["repoPath"] = request.repoPath;
    }

    if (!Util.isUnset(request.scope)) {
      body["scope"] = request.scope;
    }

    if (!Util.isUnset(request.sort)) {
      body["sort"] = request.sort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListSearchSourceCode",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/search/code`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListSearchSourceCodeResponse>(await this.callApi(params, req, runtime), new ListSearchSourceCodeResponse({}));
  }

  /**
   * 搜索代码片段
   * 
   * @param request - ListSearchSourceCodeRequest
   * @returns ListSearchSourceCodeResponse
   */
  async listSearchSourceCode(request: ListSearchSourceCodeRequest): Promise<ListSearchSourceCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listSearchSourceCodeWithOptions(request, headers, runtime);
  }

  /**
   * 获取服务授权列表
   * 
   * @param request - ListServiceAuthsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListServiceAuthsResponse
   */
  async listServiceAuthsWithOptions(organizationId: string, request: ListServiceAuthsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListServiceAuthsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.serviceAuthType)) {
      query["serviceAuthType"] = request.serviceAuthType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListServiceAuths",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/serviceAuths`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListServiceAuthsResponse>(await this.callApi(params, req, runtime), new ListServiceAuthsResponse({}));
  }

  /**
   * 获取服务授权列表
   * 
   * @param request - ListServiceAuthsRequest
   * @returns ListServiceAuthsResponse
   */
  async listServiceAuths(organizationId: string, request: ListServiceAuthsRequest): Promise<ListServiceAuthsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listServiceAuthsWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 获取服务连接列表
   * 
   * @param request - ListServiceConnectionsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListServiceConnectionsResponse
   */
  async listServiceConnectionsWithOptions(organizationId: string, request: ListServiceConnectionsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListServiceConnectionsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.sericeConnectionType)) {
      query["sericeConnectionType"] = request.sericeConnectionType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListServiceConnections",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/serviceConnections`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListServiceConnectionsResponse>(await this.callApi(params, req, runtime), new ListServiceConnectionsResponse({}));
  }

  /**
   * 获取服务连接列表
   * 
   * @param request - ListServiceConnectionsRequest
   * @returns ListServiceConnectionsResponse
   */
  async listServiceConnections(organizationId: string, request: ListServiceConnectionsRequest): Promise<ListServiceConnectionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listServiceConnectionsWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 获取服务证书列表
   * 
   * @param request - ListServiceCredentialsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListServiceCredentialsResponse
   */
  async listServiceCredentialsWithOptions(organizationId: string, request: ListServiceCredentialsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListServiceCredentialsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.serviceCredentialType)) {
      query["serviceCredentialType"] = request.serviceCredentialType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListServiceCredentials",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/serviceCredentials`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListServiceCredentialsResponse>(await this.callApi(params, req, runtime), new ListServiceCredentialsResponse({}));
  }

  /**
   * 获取服务证书列表
   * 
   * @param request - ListServiceCredentialsRequest
   * @returns ListServiceCredentialsResponse
   */
  async listServiceCredentials(organizationId: string, request: ListServiceCredentialsRequest): Promise<ListServiceCredentialsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listServiceCredentialsWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 获取迭代列表
   * 
   * @param request - ListSprintsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSprintsResponse
   */
  async listSprintsWithOptions(organizationId: string, request: ListSprintsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListSprintsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.spaceIdentifier)) {
      query["spaceIdentifier"] = request.spaceIdentifier;
    }

    if (!Util.isUnset(request.spaceType)) {
      query["spaceType"] = request.spaceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSprints",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/sprints/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListSprintsResponse>(await this.callApi(params, req, runtime), new ListSprintsResponse({}));
  }

  /**
   * 获取迭代列表
   * 
   * @param request - ListSprintsRequest
   * @returns ListSprintsResponse
   */
  async listSprints(organizationId: string, request: ListSprintsRequest): Promise<ListSprintsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listSprintsWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 获取测试用例全部字段
   * 
   * @param request - ListTestCaseFieldsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTestCaseFieldsResponse
   */
  async listTestCaseFieldsWithOptions(organizationId: string, request: ListTestCaseFieldsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListTestCaseFieldsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.spaceIdentifier)) {
      query["spaceIdentifier"] = request.spaceIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTestCaseFields",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/testhub/testcase/fields`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListTestCaseFieldsResponse>(await this.callApi(params, req, runtime), new ListTestCaseFieldsResponse({}));
  }

  /**
   * 获取测试用例全部字段
   * 
   * @param request - ListTestCaseFieldsRequest
   * @returns ListTestCaseFieldsResponse
   */
  async listTestCaseFields(organizationId: string, request: ListTestCaseFieldsRequest): Promise<ListTestCaseFieldsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listTestCaseFieldsWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 测试DrawService
   * 
   * @param request - ListUserDrawRecordByPkRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListUserDrawRecordByPkResponse
   */
  async listUserDrawRecordByPkWithOptions(request: ListUserDrawRecordByPkRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListUserDrawRecordByPkResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.aliyunPk)) {
      query["aliyunPk"] = request.aliyunPk;
    }

    if (!Util.isUnset(request.drawGroup)) {
      query["drawGroup"] = request.drawGroup;
    }

    if (!Util.isUnset(request.drawPoolName)) {
      query["drawPoolName"] = request.drawPoolName;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListUserDrawRecordByPk",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/listUserDrawRecords`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListUserDrawRecordByPkResponse>(await this.callApi(params, req, runtime), new ListUserDrawRecordByPkResponse({}));
  }

  /**
   * 测试DrawService
   * 
   * @param request - ListUserDrawRecordByPkRequest
   * @returns ListUserDrawRecordByPkResponse
   */
  async listUserDrawRecordByPk(request: ListUserDrawRecordByPkRequest): Promise<ListUserDrawRecordByPkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listUserDrawRecordByPkWithOptions(request, headers, runtime);
  }

  /**
   * 查询当前用户的SSH Key列表
   * 
   * @param request - ListUserKeysRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListUserKeysResponse
   */
  async listUserKeysWithOptions(request: ListUserKeysRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListUserKeysResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["orderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.sort)) {
      query["sort"] = request.sort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListUserKeys",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v3/user/keys`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListUserKeysResponse>(await this.callApi(params, req, runtime), new ListUserKeysResponse({}));
  }

  /**
   * 查询当前用户的SSH Key列表
   * 
   * @param request - ListUserKeysRequest
   * @returns ListUserKeysResponse
   */
  async listUserKeys(request: ListUserKeysRequest): Promise<ListUserKeysResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listUserKeysWithOptions(request, headers, runtime);
  }

  /**
   * 查询用户有权限的资源（代码库、组）
   * 
   * @param request - ListUserResourcesRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListUserResourcesResponse
   */
  async listUserResourcesWithOptions(request: ListUserResourcesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListUserResourcesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.page)) {
      query["page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["pageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.userIds)) {
      query["userIds"] = request.userIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListUserResources",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/user/vision/user_resources`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListUserResourcesResponse>(await this.callApi(params, req, runtime), new ListUserResourcesResponse({}));
  }

  /**
   * 查询用户有权限的资源（代码库、组）
   * 
   * @param request - ListUserResourcesRequest
   * @returns ListUserResourcesResponse
   */
  async listUserResources(request: ListUserResourcesRequest): Promise<ListUserResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listUserResourcesWithOptions(request, headers, runtime);
  }

  /**
   * 获取变量组列表
   * 
   * @param request - ListVariableGroupsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListVariableGroupsResponse
   */
  async listVariableGroupsWithOptions(organizationId: string, request: ListVariableGroupsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListVariableGroupsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.pageOrder)) {
      query["pageOrder"] = request.pageOrder;
    }

    if (!Util.isUnset(request.pageSort)) {
      query["pageSort"] = request.pageSort;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListVariableGroups",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/variableGroups`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListVariableGroupsResponse>(await this.callApi(params, req, runtime), new ListVariableGroupsResponse({}));
  }

  /**
   * 获取变量组列表
   * 
   * @param request - ListVariableGroupsRequest
   * @returns ListVariableGroupsResponse
   */
  async listVariableGroups(organizationId: string, request: ListVariableGroupsRequest): Promise<ListVariableGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listVariableGroupsWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 获取项目下工作项的所有字段
   * 
   * @param request - ListWorkItemAllFieldsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWorkItemAllFieldsResponse
   */
  async listWorkItemAllFieldsWithOptions(organizationId: string, request: ListWorkItemAllFieldsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListWorkItemAllFieldsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.spaceIdentifier)) {
      query["spaceIdentifier"] = request.spaceIdentifier;
    }

    if (!Util.isUnset(request.spaceType)) {
      query["spaceType"] = request.spaceType;
    }

    if (!Util.isUnset(request.workitemTypeIdentifier)) {
      query["workitemTypeIdentifier"] = request.workitemTypeIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListWorkItemAllFields",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/fields/listAll`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListWorkItemAllFieldsResponse>(await this.callApi(params, req, runtime), new ListWorkItemAllFieldsResponse({}));
  }

  /**
   * 获取项目下工作项的所有字段
   * 
   * @param request - ListWorkItemAllFieldsRequest
   * @returns ListWorkItemAllFieldsResponse
   */
  async listWorkItemAllFields(organizationId: string, request: ListWorkItemAllFieldsRequest): Promise<ListWorkItemAllFieldsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listWorkItemAllFieldsWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 查询工作项工作流的所有状态
   * 
   * @param request - ListWorkItemWorkFlowStatusRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWorkItemWorkFlowStatusResponse
   */
  async listWorkItemWorkFlowStatusWithOptions(organizationId: string, request: ListWorkItemWorkFlowStatusRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListWorkItemWorkFlowStatusResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.spaceIdentifier)) {
      query["spaceIdentifier"] = request.spaceIdentifier;
    }

    if (!Util.isUnset(request.spaceType)) {
      query["spaceType"] = request.spaceType;
    }

    if (!Util.isUnset(request.workitemCategoryIdentifier)) {
      query["workitemCategoryIdentifier"] = request.workitemCategoryIdentifier;
    }

    if (!Util.isUnset(request.workitemTypeIdentifier)) {
      query["workitemTypeIdentifier"] = request.workitemTypeIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListWorkItemWorkFlowStatus",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/workflow/listWorkflowStatus`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListWorkItemWorkFlowStatusResponse>(await this.callApi(params, req, runtime), new ListWorkItemWorkFlowStatusResponse({}));
  }

  /**
   * 查询工作项工作流的所有状态
   * 
   * @param request - ListWorkItemWorkFlowStatusRequest
   * @returns ListWorkItemWorkFlowStatusResponse
   */
  async listWorkItemWorkFlowStatus(organizationId: string, request: ListWorkItemWorkFlowStatusRequest): Promise<ListWorkItemWorkFlowStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listWorkItemWorkFlowStatusWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 获取工作项的附件列表
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWorkitemAttachmentsResponse
   */
  async listWorkitemAttachmentsWithOptions(organizationId: string, workitemIdentifier: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListWorkitemAttachmentsResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "ListWorkitemAttachments",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitem/${OpenApiUtil.getEncodeParam(workitemIdentifier)}/attachments`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListWorkitemAttachmentsResponse>(await this.callApi(params, req, runtime), new ListWorkitemAttachmentsResponse({}));
  }

  /**
   * 获取工作项的附件列表
   * @returns ListWorkitemAttachmentsResponse
   */
  async listWorkitemAttachments(organizationId: string, workitemIdentifier: string): Promise<ListWorkitemAttachmentsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listWorkitemAttachmentsWithOptions(organizationId, workitemIdentifier, headers, runtime);
  }

  /**
   * 获取工作项预计工时明细列表
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWorkitemEstimateResponse
   */
  async listWorkitemEstimateWithOptions(organizationId: string, workitemId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListWorkitemEstimateResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "ListWorkitemEstimate",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/${OpenApiUtil.getEncodeParam(workitemId)}/estimate/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListWorkitemEstimateResponse>(await this.callApi(params, req, runtime), new ListWorkitemEstimateResponse({}));
  }

  /**
   * 获取工作项预计工时明细列表
   * @returns ListWorkitemEstimateResponse
   */
  async listWorkitemEstimate(organizationId: string, workitemId: string): Promise<ListWorkitemEstimateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listWorkitemEstimateWithOptions(organizationId, workitemId, headers, runtime);
  }

  /**
   * 获取工作项工时明细列表
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWorkitemTimeResponse
   */
  async listWorkitemTimeWithOptions(organizationId: string, workitemId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListWorkitemTimeResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "ListWorkitemTime",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/${OpenApiUtil.getEncodeParam(workitemId)}/time/list`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListWorkitemTimeResponse>(await this.callApi(params, req, runtime), new ListWorkitemTimeResponse({}));
  }

  /**
   * 获取工作项工时明细列表
   * @returns ListWorkitemTimeResponse
   */
  async listWorkitemTime(organizationId: string, workitemId: string): Promise<ListWorkitemTimeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listWorkitemTimeWithOptions(organizationId, workitemId, headers, runtime);
  }

  /**
   * 获取工作项列表
   * 
   * @param request - ListWorkitemsRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWorkitemsResponse
   */
  async listWorkitemsWithOptions(organizationId: string, request: ListWorkitemsRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListWorkitemsResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.category)) {
      query["category"] = request.category;
    }

    if (!Util.isUnset(request.conditions)) {
      query["conditions"] = request.conditions;
    }

    if (!Util.isUnset(request.extraConditions)) {
      query["extraConditions"] = request.extraConditions;
    }

    if (!Util.isUnset(request.groupCondition)) {
      query["groupCondition"] = request.groupCondition;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["orderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.searchType)) {
      query["searchType"] = request.searchType;
    }

    if (!Util.isUnset(request.spaceIdentifier)) {
      query["spaceIdentifier"] = request.spaceIdentifier;
    }

    if (!Util.isUnset(request.spaceType)) {
      query["spaceType"] = request.spaceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListWorkitems",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/listWorkitems`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListWorkitemsResponse>(await this.callApi(params, req, runtime), new ListWorkitemsResponse({}));
  }

  /**
   * 获取工作项列表
   * 
   * @param request - ListWorkitemsRequest
   * @returns ListWorkitemsResponse
   */
  async listWorkitems(organizationId: string, request: ListWorkitemsRequest): Promise<ListWorkitemsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listWorkitemsWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 查询工作空间列表
   * 
   * @param tmpReq - ListWorkspacesRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWorkspacesResponse
   */
  async listWorkspacesWithOptions(tmpReq: ListWorkspacesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ListWorkspacesResponse> {
    Util.validateModel(tmpReq);
    let request = new ListWorkspacesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.statusList)) {
      request.statusListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.statusList, "statusList", "simple");
    }

    if (!Util.isUnset(tmpReq.workspaceTemplateList)) {
      request.workspaceTemplateListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.workspaceTemplateList, "workspaceTemplateList", "simple");
    }

    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.maxResults)) {
      query["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.statusListShrink)) {
      query["statusList"] = request.statusListShrink;
    }

    if (!Util.isUnset(request.workspaceTemplateListShrink)) {
      query["workspaceTemplateList"] = request.workspaceTemplateListShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListWorkspaces",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/workspaces`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListWorkspacesResponse>(await this.callApi(params, req, runtime), new ListWorkspacesResponse({}));
  }

  /**
   * 查询工作空间列表
   * 
   * @param request - ListWorkspacesRequest
   * @returns ListWorkspacesResponse
   */
  async listWorkspaces(request: ListWorkspacesRequest): Promise<ListWorkspacesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.listWorkspacesWithOptions(request, headers, runtime);
  }

  /**
   * 获取流水线运行任务日志
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns LogPipelineJobRunResponse
   */
  async logPipelineJobRunWithOptions(organizationId: string, pipelineId: string, jobId: string, pipelineRunId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<LogPipelineJobRunResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "LogPipelineJobRun",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipeline/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRun/${OpenApiUtil.getEncodeParam(pipelineRunId)}/job/${OpenApiUtil.getEncodeParam(jobId)}/logs`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<LogPipelineJobRunResponse>(await this.callApi(params, req, runtime), new LogPipelineJobRunResponse({}));
  }

  /**
   * 获取流水线运行任务日志
   * @returns LogPipelineJobRunResponse
   */
  async logPipelineJobRun(organizationId: string, pipelineId: string, jobId: string, pipelineRunId: string): Promise<LogPipelineJobRunResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.logPipelineJobRunWithOptions(organizationId, pipelineId, jobId, pipelineRunId, headers, runtime);
  }

  /**
   * 获取机器部署日志
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns LogVMDeployMachineResponse
   */
  async logVMDeployMachineWithOptions(organizationId: string, pipelineId: string, deployOrderId: string, machineSn: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<LogVMDeployMachineResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "LogVMDeployMachine",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/deploy/${OpenApiUtil.getEncodeParam(deployOrderId)}/machine/${OpenApiUtil.getEncodeParam(machineSn)}/log`,
      method: "GET",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<LogVMDeployMachineResponse>(await this.callApi(params, req, runtime), new LogVMDeployMachineResponse({}));
  }

  /**
   * 获取机器部署日志
   * @returns LogVMDeployMachineResponse
   */
  async logVMDeployMachine(organizationId: string, pipelineId: string, deployOrderId: string, machineSn: string): Promise<LogVMDeployMachineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.logVMDeployMachineWithOptions(organizationId, pipelineId, deployOrderId, machineSn, headers, runtime);
  }

  /**
   * 合并代码评审
   * 
   * @param request - MergeMergeRequestRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns MergeMergeRequestResponse
   */
  async mergeMergeRequestWithOptions(repositoryId: string, localId: string, request: MergeMergeRequestRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<MergeMergeRequestResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.mergeMessage)) {
      body["mergeMessage"] = request.mergeMessage;
    }

    if (!Util.isUnset(request.mergeType)) {
      body["mergeType"] = request.mergeType;
    }

    if (!Util.isUnset(request.removeSourceBranch)) {
      body["removeSourceBranch"] = request.removeSourceBranch;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "MergeMergeRequest",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/merge_requests/${OpenApiUtil.getEncodeParam(localId)}/merge`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<MergeMergeRequestResponse>(await this.callApi(params, req, runtime), new MergeMergeRequestResponse({}));
  }

  /**
   * 合并代码评审
   * 
   * @param request - MergeMergeRequestRequest
   * @returns MergeMergeRequestResponse
   */
  async mergeMergeRequest(repositoryId: string, localId: string, request: MergeMergeRequestRequest): Promise<MergeMergeRequestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.mergeMergeRequestWithOptions(repositoryId, localId, request, headers, runtime);
  }

  /**
   * 通过人工卡点
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PassPipelineValidateResponse
   */
  async passPipelineValidateWithOptions(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<PassPipelineValidateResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "PassPipelineValidate",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRuns/${OpenApiUtil.getEncodeParam(pipelineRunId)}/jobs/${OpenApiUtil.getEncodeParam(jobId)}/pass`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<PassPipelineValidateResponse>(await this.callApi(params, req, runtime), new PassPipelineValidateResponse({}));
  }

  /**
   * 通过人工卡点
   * @returns PassPipelineValidateResponse
   */
  async passPipelineValidate(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string): Promise<PassPipelineValidateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.passPipelineValidateWithOptions(organizationId, pipelineId, pipelineRunId, jobId, headers, runtime);
  }

  /**
   * 通过人工卡点
   * 
   * @param request - PassReleaseStagePipelineValidateRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PassReleaseStagePipelineValidateResponse
   */
  async passReleaseStagePipelineValidateWithOptions(appName: string, releaseWorkflowSn: string, releaseStageSn: string, executionNumber: string, request: PassReleaseStagePipelineValidateRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<PassReleaseStagePipelineValidateResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.jobId)) {
      query["jobId"] = request.jobId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PassReleaseStagePipelineValidate",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}/releaseWorkflows/${OpenApiUtil.getEncodeParam(releaseWorkflowSn)}/releaseStages/${OpenApiUtil.getEncodeParam(releaseStageSn)}/executions/${OpenApiUtil.getEncodeParam(executionNumber)}%3ApassPipelineValidate`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<PassReleaseStagePipelineValidateResponse>(await this.callApi(params, req, runtime), new PassReleaseStagePipelineValidateResponse({}));
  }

  /**
   * 通过人工卡点
   * 
   * @param request - PassReleaseStagePipelineValidateRequest
   * @returns PassReleaseStagePipelineValidateResponse
   */
  async passReleaseStagePipelineValidate(appName: string, releaseWorkflowSn: string, releaseStageSn: string, executionNumber: string, request: PassReleaseStagePipelineValidateRequest): Promise<PassReleaseStagePipelineValidateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.passReleaseStagePipelineValidateWithOptions(appName, releaseWorkflowSn, releaseStageSn, executionNumber, request, headers, runtime);
  }

  /**
   * 拒绝人工卡点
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RefusePipelineValidateResponse
   */
  async refusePipelineValidateWithOptions(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<RefusePipelineValidateResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "RefusePipelineValidate",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRuns/${OpenApiUtil.getEncodeParam(pipelineRunId)}/jobs/${OpenApiUtil.getEncodeParam(jobId)}/refuse`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<RefusePipelineValidateResponse>(await this.callApi(params, req, runtime), new RefusePipelineValidateResponse({}));
  }

  /**
   * 拒绝人工卡点
   * @returns RefusePipelineValidateResponse
   */
  async refusePipelineValidate(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string): Promise<RefusePipelineValidateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.refusePipelineValidateWithOptions(organizationId, pipelineId, pipelineRunId, jobId, headers, runtime);
  }

  /**
   * 拒绝人工卡点
   * 
   * @param request - RefuseReleaseStagePipelineValidateRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RefuseReleaseStagePipelineValidateResponse
   */
  async refuseReleaseStagePipelineValidateWithOptions(appName: string, releaseWorkflowSn: string, releaseStageSn: string, executionNumber: string, request: RefuseReleaseStagePipelineValidateRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<RefuseReleaseStagePipelineValidateResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.jobId)) {
      query["jobId"] = request.jobId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RefuseReleaseStagePipelineValidate",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}/releaseWorkflows/${OpenApiUtil.getEncodeParam(releaseWorkflowSn)}/releaseStages/${OpenApiUtil.getEncodeParam(releaseStageSn)}/executions/${OpenApiUtil.getEncodeParam(executionNumber)}%3ArefusePipelineValidate`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<RefuseReleaseStagePipelineValidateResponse>(await this.callApi(params, req, runtime), new RefuseReleaseStagePipelineValidateResponse({}));
  }

  /**
   * 拒绝人工卡点
   * 
   * @param request - RefuseReleaseStagePipelineValidateRequest
   * @returns RefuseReleaseStagePipelineValidateResponse
   */
  async refuseReleaseStagePipelineValidate(appName: string, releaseWorkflowSn: string, releaseStageSn: string, executionNumber: string, request: RefuseReleaseStagePipelineValidateRequest): Promise<RefuseReleaseStagePipelineValidateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.refuseReleaseStagePipelineValidateWithOptions(appName, releaseWorkflowSn, releaseStageSn, executionNumber, request, headers, runtime);
  }

  /**
   * 释放工作空间
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ReleaseWorkspaceResponse
   */
  async releaseWorkspaceWithOptions(workspaceId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ReleaseWorkspaceResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "ReleaseWorkspace",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/workspaces/${OpenApiUtil.getEncodeParam(workspaceId)}/release`,
      method: "DELETE",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ReleaseWorkspaceResponse>(await this.callApi(params, req, runtime), new ReleaseWorkspaceResponse({}));
  }

  /**
   * 释放工作空间
   * @returns ReleaseWorkspaceResponse
   */
  async releaseWorkspace(workspaceId: string): Promise<ReleaseWorkspaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.releaseWorkspaceWithOptions(workspaceId, headers, runtime);
  }

  /**
   * 重新打开代码评审
   * 
   * @param request - ReopenMergeRequestRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ReopenMergeRequestResponse
   */
  async reopenMergeRequestWithOptions(repositoryId: string, localId: string, request: ReopenMergeRequestRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ReopenMergeRequestResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ReopenMergeRequest",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/merge_requests/${OpenApiUtil.getEncodeParam(localId)}/reopen`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ReopenMergeRequestResponse>(await this.callApi(params, req, runtime), new ReopenMergeRequestResponse({}));
  }

  /**
   * 重新打开代码评审
   * 
   * @param request - ReopenMergeRequestRequest
   * @returns ReopenMergeRequestResponse
   */
  async reopenMergeRequest(repositoryId: string, localId: string, request: ReopenMergeRequestRequest): Promise<ReopenMergeRequestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.reopenMergeRequestWithOptions(repositoryId, localId, request, headers, runtime);
  }

  /**
   * 重置企业公钥
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ResetSshKeyResponse
   */
  async resetSshKeyWithOptions(organizationId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ResetSshKeyResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "ResetSshKey",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/sshKey`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ResetSshKeyResponse>(await this.callApi(params, req, runtime), new ResetSshKeyResponse({}));
  }

  /**
   * 重置企业公钥
   * @returns ResetSshKeyResponse
   */
  async resetSshKey(organizationId: string): Promise<ResetSshKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.resetSshKeyWithOptions(organizationId, headers, runtime);
  }

  /**
   * 继续部署
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ResumeVMDeployOrderResponse
   */
  async resumeVMDeployOrderWithOptions(organizationId: string, pipelineId: string, deployOrderId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ResumeVMDeployOrderResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "ResumeVMDeployOrder",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/deploy/${OpenApiUtil.getEncodeParam(deployOrderId)}/resume`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ResumeVMDeployOrderResponse>(await this.callApi(params, req, runtime), new ResumeVMDeployOrderResponse({}));
  }

  /**
   * 继续部署
   * @returns ResumeVMDeployOrderResponse
   */
  async resumeVMDeployOrder(organizationId: string, pipelineId: string, deployOrderId: string): Promise<ResumeVMDeployOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.resumeVMDeployOrderWithOptions(organizationId, pipelineId, deployOrderId, headers, runtime);
  }

  /**
   * 重试流水线运行
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RetryPipelineJobRunResponse
   */
  async retryPipelineJobRunWithOptions(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<RetryPipelineJobRunResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "RetryPipelineJobRun",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRuns/${OpenApiUtil.getEncodeParam(pipelineRunId)}/jobs/${OpenApiUtil.getEncodeParam(jobId)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<RetryPipelineJobRunResponse>(await this.callApi(params, req, runtime), new RetryPipelineJobRunResponse({}));
  }

  /**
   * 重试流水线运行
   * @returns RetryPipelineJobRunResponse
   */
  async retryPipelineJobRun(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string): Promise<RetryPipelineJobRunResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.retryPipelineJobRunWithOptions(organizationId, pipelineId, pipelineRunId, jobId, headers, runtime);
  }

  /**
   * 重试机器部署
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RetryVMDeployMachineResponse
   */
  async retryVMDeployMachineWithOptions(organizationId: string, pipelineId: string, deployOrderId: string, machineSn: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<RetryVMDeployMachineResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "RetryVMDeployMachine",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/deploy/${OpenApiUtil.getEncodeParam(deployOrderId)}/machine/${OpenApiUtil.getEncodeParam(machineSn)}/retry`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<RetryVMDeployMachineResponse>(await this.callApi(params, req, runtime), new RetryVMDeployMachineResponse({}));
  }

  /**
   * 重试机器部署
   * @returns RetryVMDeployMachineResponse
   */
  async retryVMDeployMachine(organizationId: string, pipelineId: string, deployOrderId: string, machineSn: string): Promise<RetryVMDeployMachineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.retryVMDeployMachineWithOptions(organizationId, pipelineId, deployOrderId, machineSn, headers, runtime);
  }

  /**
   * 提交变更请求的评审意见
   * 
   * @param request - ReviewMergeRequestRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ReviewMergeRequestResponse
   */
  async reviewMergeRequestWithOptions(repositoryId: string, localId: string, request: ReviewMergeRequestRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<ReviewMergeRequestResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.draftCommentIds)) {
      body["draftCommentIds"] = request.draftCommentIds;
    }

    if (!Util.isUnset(request.reviewComment)) {
      body["reviewComment"] = request.reviewComment;
    }

    if (!Util.isUnset(request.reviewOpinion)) {
      body["reviewOpinion"] = request.reviewOpinion;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ReviewMergeRequest",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/merge_requests/${OpenApiUtil.getEncodeParam(localId)}/submit_review_opinion`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ReviewMergeRequestResponse>(await this.callApi(params, req, runtime), new ReviewMergeRequestResponse({}));
  }

  /**
   * 提交变更请求的评审意见
   * 
   * @param request - ReviewMergeRequestRequest
   * @returns ReviewMergeRequestResponse
   */
  async reviewMergeRequest(repositoryId: string, localId: string, request: ReviewMergeRequestRequest): Promise<ReviewMergeRequestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.reviewMergeRequestWithOptions(repositoryId, localId, request, headers, runtime);
  }

  /**
   * 跳过流水线任务运行
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SkipPipelineJobRunResponse
   */
  async skipPipelineJobRunWithOptions(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<SkipPipelineJobRunResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "SkipPipelineJobRun",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRuns/${OpenApiUtil.getEncodeParam(pipelineRunId)}/jobs/${OpenApiUtil.getEncodeParam(jobId)}/skip`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<SkipPipelineJobRunResponse>(await this.callApi(params, req, runtime), new SkipPipelineJobRunResponse({}));
  }

  /**
   * 跳过流水线任务运行
   * @returns SkipPipelineJobRunResponse
   */
  async skipPipelineJobRun(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string): Promise<SkipPipelineJobRunResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.skipPipelineJobRunWithOptions(organizationId, pipelineId, pipelineRunId, jobId, headers, runtime);
  }

  /**
   * 跳过机器部署
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SkipVMDeployMachineResponse
   */
  async skipVMDeployMachineWithOptions(organizationId: string, pipelineId: string, deployOrderId: string, machineSn: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<SkipVMDeployMachineResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "SkipVMDeployMachine",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/deploy/${OpenApiUtil.getEncodeParam(deployOrderId)}/machine/${OpenApiUtil.getEncodeParam(machineSn)}/skip`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<SkipVMDeployMachineResponse>(await this.callApi(params, req, runtime), new SkipVMDeployMachineResponse({}));
  }

  /**
   * 跳过机器部署
   * @returns SkipVMDeployMachineResponse
   */
  async skipVMDeployMachine(organizationId: string, pipelineId: string, deployOrderId: string, machineSn: string): Promise<SkipVMDeployMachineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.skipVMDeployMachineWithOptions(organizationId, pipelineId, deployOrderId, machineSn, headers, runtime);
  }

  /**
   * 运行流水线
   * 
   * @param request - StartPipelineRunRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StartPipelineRunResponse
   */
  async startPipelineRunWithOptions(organizationId: string, pipelineId: string, request: StartPipelineRunRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<StartPipelineRunResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.params)) {
      body["params"] = request.params;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "StartPipelineRun",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organizations/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/run`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartPipelineRunResponse>(await this.callApi(params, req, runtime), new StartPipelineRunResponse({}));
  }

  /**
   * 运行流水线
   * 
   * @param request - StartPipelineRunRequest
   * @returns StartPipelineRunResponse
   */
  async startPipelineRun(organizationId: string, pipelineId: string, request: StartPipelineRunRequest): Promise<StartPipelineRunResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.startPipelineRunWithOptions(organizationId, pipelineId, request, headers, runtime);
  }

  /**
   * 终止流水线任务运行
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StopPipelineJobRunResponse
   */
  async stopPipelineJobRunWithOptions(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<StopPipelineJobRunResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "StopPipelineJobRun",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRuns/${OpenApiUtil.getEncodeParam(pipelineRunId)}/jobs/${OpenApiUtil.getEncodeParam(jobId)}/stop`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<StopPipelineJobRunResponse>(await this.callApi(params, req, runtime), new StopPipelineJobRunResponse({}));
  }

  /**
   * 终止流水线任务运行
   * @returns StopPipelineJobRunResponse
   */
  async stopPipelineJobRun(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string): Promise<StopPipelineJobRunResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.stopPipelineJobRunWithOptions(organizationId, pipelineId, pipelineRunId, jobId, headers, runtime);
  }

  /**
   * 终止流水线运行
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StopPipelineRunResponse
   */
  async stopPipelineRunWithOptions(organizationId: string, pipelineId: string, pipelineRunId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<StopPipelineRunResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "StopPipelineRun",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/pipelineRuns/${OpenApiUtil.getEncodeParam(pipelineRunId)}/stop`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<StopPipelineRunResponse>(await this.callApi(params, req, runtime), new StopPipelineRunResponse({}));
  }

  /**
   * 终止流水线运行
   * @returns StopPipelineRunResponse
   */
  async stopPipelineRun(organizationId: string, pipelineId: string, pipelineRunId: string): Promise<StopPipelineRunResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.stopPipelineRunWithOptions(organizationId, pipelineId, pipelineRunId, headers, runtime);
  }

  /**
   * 取消部署单
   * 
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StopVMDeployOrderResponse
   */
  async stopVMDeployOrderWithOptions(organizationId: string, pipelineId: string, deployOrderId: string, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<StopVMDeployOrderResponse> {
    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
    });
    let params = new $OpenApi.Params({
      action: "StopVMDeployOrder",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/deploy/${OpenApiUtil.getEncodeParam(deployOrderId)}/stop`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<StopVMDeployOrderResponse>(await this.callApi(params, req, runtime), new StopVMDeployOrderResponse({}));
  }

  /**
   * 取消部署单
   * @returns StopVMDeployOrderResponse
   */
  async stopVMDeployOrder(organizationId: string, pipelineId: string, deployOrderId: string): Promise<StopVMDeployOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.stopVMDeployOrderWithOptions(organizationId, pipelineId, deployOrderId, headers, runtime);
  }

  /**
   * 转移代码库
   * 
   * @param request - TransferRepositoryRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns TransferRepositoryResponse
   */
  async transferRepositoryWithOptions(request: TransferRepositoryRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<TransferRepositoryResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.groupId)) {
      query["groupId"] = request.groupId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryId)) {
      query["repositoryId"] = request.repositoryId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "TransferRepository",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/repository/transfer`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<TransferRepositoryResponse>(await this.callApi(params, req, runtime), new TransferRepositoryResponse({}));
  }

  /**
   * 转移代码库
   * 
   * @param request - TransferRepositoryRequest
   * @returns TransferRepositoryResponse
   */
  async transferRepository(request: TransferRepositoryRequest): Promise<TransferRepositoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.transferRepositoryWithOptions(request, headers, runtime);
  }

  /**
   * 触发仓库同步
   * 
   * @param request - TriggerRepositoryMirrorSyncRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns TriggerRepositoryMirrorSyncResponse
   */
  async triggerRepositoryMirrorSyncWithOptions(repositoryId: string, request: TriggerRepositoryMirrorSyncRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<TriggerRepositoryMirrorSyncResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.account)) {
      query["account"] = request.account;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.token)) {
      query["token"] = request.token;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "TriggerRepositoryMirrorSync",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/mirror`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<TriggerRepositoryMirrorSyncResponse>(await this.callApi(params, req, runtime), new TriggerRepositoryMirrorSyncResponse({}));
  }

  /**
   * 触发仓库同步
   * 
   * @param request - TriggerRepositoryMirrorSyncRequest
   * @returns TriggerRepositoryMirrorSyncResponse
   */
  async triggerRepositoryMirrorSync(repositoryId: string, request: TriggerRepositoryMirrorSyncRequest): Promise<TriggerRepositoryMirrorSyncResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.triggerRepositoryMirrorSyncWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 更新应用成员
   * 
   * @param request - UpdateAppMemberRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateAppMemberResponse
   */
  async updateAppMemberWithOptions(appName: string, request: UpdateAppMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateAppMemberResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.player)) {
      body["player"] = request.player;
    }

    if (!Util.isUnset(request.roleNames)) {
      body["roleNames"] = request.roleNames;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateAppMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}/members`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "string",
    });
    return $tea.cast<UpdateAppMemberResponse>(await this.callApi(params, req, runtime), new UpdateAppMemberResponse({}));
  }

  /**
   * 更新应用成员
   * 
   * @param request - UpdateAppMemberRequest
   * @returns UpdateAppMemberResponse
   */
  async updateAppMember(appName: string, request: UpdateAppMemberRequest): Promise<UpdateAppMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateAppMemberWithOptions(appName, request, headers, runtime);
  }

  /**
   * 更新应用
   * 
   * @param request - UpdateApplicationRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateApplicationResponse
   */
  async updateApplicationWithOptions(appName: string, request: UpdateApplicationRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateApplicationResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.ownerAccountId)) {
      body["ownerAccountId"] = request.ownerAccountId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateApplication",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/appstack/apps/${OpenApiUtil.getEncodeParam(appName)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateApplicationResponse>(await this.callApi(params, req, runtime), new UpdateApplicationResponse({}));
  }

  /**
   * 更新应用
   * 
   * @param request - UpdateApplicationRequest
   * @returns UpdateApplicationResponse
   */
  async updateApplication(appName: string, request: UpdateApplicationRequest): Promise<UpdateApplicationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateApplicationWithOptions(appName, request, headers, runtime);
  }

  /**
   * 更新检查运行记录
   * 
   * @param request - UpdateCheckRunRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCheckRunResponse
   */
  async updateCheckRunWithOptions(request: UpdateCheckRunRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateCheckRunResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.checkRunId)) {
      query["checkRunId"] = request.checkRunId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.annotations)) {
      body["annotations"] = request.annotations;
    }

    if (!Util.isUnset(request.completedAt)) {
      body["completedAt"] = request.completedAt;
    }

    if (!Util.isUnset(request.conclusion)) {
      body["conclusion"] = request.conclusion;
    }

    if (!Util.isUnset(request.detailsUrl)) {
      body["detailsUrl"] = request.detailsUrl;
    }

    if (!Util.isUnset(request.externalId)) {
      body["externalId"] = request.externalId;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.output)) {
      body["output"] = request.output;
    }

    if (!Util.isUnset(request.startedAt)) {
      body["startedAt"] = request.startedAt;
    }

    if (!Util.isUnset(request.status)) {
      body["status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCheckRun",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/check_runs/update_check_run`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateCheckRunResponse>(await this.callApi(params, req, runtime), new UpdateCheckRunResponse({}));
  }

  /**
   * 更新检查运行记录
   * 
   * @param request - UpdateCheckRunRequest
   * @returns UpdateCheckRunResponse
   */
  async updateCheckRun(request: UpdateCheckRunRequest): Promise<UpdateCheckRunResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateCheckRunWithOptions(request, headers, runtime);
  }

  /**
   * 更新代码库文件
   * 
   * @param request - UpdateFileRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateFileResponse
   */
  async updateFileWithOptions(repositoryId: string, request: UpdateFileRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateFileResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.branchName)) {
      body["branchName"] = request.branchName;
    }

    if (!Util.isUnset(request.commitMessage)) {
      body["commitMessage"] = request.commitMessage;
    }

    if (!Util.isUnset(request.content)) {
      body["content"] = request.content;
    }

    if (!Util.isUnset(request.encoding)) {
      body["encoding"] = request.encoding;
    }

    if (!Util.isUnset(request.newPath)) {
      body["newPath"] = request.newPath;
    }

    if (!Util.isUnset(request.oldPath)) {
      body["oldPath"] = request.oldPath;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateFile",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/files/update`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateFileResponse>(await this.callApi(params, req, runtime), new UpdateFileResponse({}));
  }

  /**
   * 更新代码库文件
   * 
   * @param request - UpdateFileRequest
   * @returns UpdateFileResponse
   */
  async updateFile(repositoryId: string, request: UpdateFileRequest): Promise<UpdateFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateFileWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 更新标签
   * 
   * @param request - UpdateFlowTagRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateFlowTagResponse
   */
  async updateFlowTagWithOptions(organizationId: string, id: string, request: UpdateFlowTagRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateFlowTagResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.color)) {
      query["color"] = request.color;
    }

    if (!Util.isUnset(request.flowTagGroupId)) {
      query["flowTagGroupId"] = request.flowTagGroupId;
    }

    if (!Util.isUnset(request.name)) {
      query["name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateFlowTag",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/flow/tags/${OpenApiUtil.getEncodeParam(id)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateFlowTagResponse>(await this.callApi(params, req, runtime), new UpdateFlowTagResponse({}));
  }

  /**
   * 更新标签
   * 
   * @param request - UpdateFlowTagRequest
   * @returns UpdateFlowTagResponse
   */
  async updateFlowTag(organizationId: string, id: string, request: UpdateFlowTagRequest): Promise<UpdateFlowTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateFlowTagWithOptions(organizationId, id, request, headers, runtime);
  }

  /**
   * 标签分类
   * 
   * @param request - UpdateFlowTagGroupRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateFlowTagGroupResponse
   */
  async updateFlowTagGroupWithOptions(organizationId: string, id: string, request: UpdateFlowTagGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateFlowTagGroupResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      query["name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateFlowTagGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/flow/tagGroups/${OpenApiUtil.getEncodeParam(id)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateFlowTagGroupResponse>(await this.callApi(params, req, runtime), new UpdateFlowTagGroupResponse({}));
  }

  /**
   * 标签分类
   * 
   * @param request - UpdateFlowTagGroupRequest
   * @returns UpdateFlowTagGroupResponse
   */
  async updateFlowTagGroup(organizationId: string, id: string, request: UpdateFlowTagGroupRequest): Promise<UpdateFlowTagGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateFlowTagGroupWithOptions(organizationId, id, request, headers, runtime);
  }

  /**
   * 更新单个代码组信息
   * 
   * @param request - UpdateGroupRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGroupResponse
   */
  async updateGroupWithOptions(request: UpdateGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateGroupResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.avatarUrl)) {
      body["avatarUrl"] = request.avatarUrl;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.path)) {
      body["path"] = request.path;
    }

    if (!Util.isUnset(request.pathWithNamespace)) {
      body["pathWithNamespace"] = request.pathWithNamespace;
    }

    if (!Util.isUnset(request.visibilityLevel)) {
      body["visibilityLevel"] = request.visibilityLevel;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/groups/modify`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateGroupResponse>(await this.callApi(params, req, runtime), new UpdateGroupResponse({}));
  }

  /**
   * 更新单个代码组信息
   * 
   * @param request - UpdateGroupRequest
   * @returns UpdateGroupResponse
   */
  async updateGroup(request: UpdateGroupRequest): Promise<UpdateGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateGroupWithOptions(request, headers, runtime);
  }

  /**
   * 修改组成员
   * 
   * @param request - UpdateGroupMemberRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGroupMemberResponse
   */
  async updateGroupMemberWithOptions(groupId: string, request: UpdateGroupMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateGroupMemberResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.aliyunPk)) {
      query["aliyunPk"] = request.aliyunPk;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessLevel)) {
      body["accessLevel"] = request.accessLevel;
    }

    if (!Util.isUnset(request.memberType)) {
      body["memberType"] = request.memberType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGroupMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/groups/${OpenApiUtil.getEncodeParam(groupId)}/members/update/aliyun_pk`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateGroupMemberResponse>(await this.callApi(params, req, runtime), new UpdateGroupMemberResponse({}));
  }

  /**
   * 修改组成员
   * 
   * @param request - UpdateGroupMemberRequest
   * @returns UpdateGroupMemberResponse
   */
  async updateGroupMember(groupId: string, request: UpdateGroupMemberRequest): Promise<UpdateGroupMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateGroupMemberWithOptions(groupId, request, headers, runtime);
  }

  /**
   * 更新主机组
   * 
   * @param request - UpdateHostGroupRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateHostGroupResponse
   */
  async updateHostGroupWithOptions(organizationId: string, id: string, request: UpdateHostGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateHostGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.aliyunRegion)) {
      body["aliyunRegion"] = request.aliyunRegion;
    }

    if (!Util.isUnset(request.ecsLabelKey)) {
      body["ecsLabelKey"] = request.ecsLabelKey;
    }

    if (!Util.isUnset(request.ecsLabelValue)) {
      body["ecsLabelValue"] = request.ecsLabelValue;
    }

    if (!Util.isUnset(request.ecsType)) {
      body["ecsType"] = request.ecsType;
    }

    if (!Util.isUnset(request.envId)) {
      body["envId"] = request.envId;
    }

    if (!Util.isUnset(request.machineInfos)) {
      body["machineInfos"] = request.machineInfos;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.serviceConnectionId)) {
      body["serviceConnectionId"] = request.serviceConnectionId;
    }

    if (!Util.isUnset(request.tagIds)) {
      body["tagIds"] = request.tagIds;
    }

    if (!Util.isUnset(request.type)) {
      body["type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateHostGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/hostGroups/${OpenApiUtil.getEncodeParam(id)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateHostGroupResponse>(await this.callApi(params, req, runtime), new UpdateHostGroupResponse({}));
  }

  /**
   * 更新主机组
   * 
   * @param request - UpdateHostGroupRequest
   * @returns UpdateHostGroupResponse
   */
  async updateHostGroup(organizationId: string, id: string, request: UpdateHostGroupRequest): Promise<UpdateHostGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateHostGroupWithOptions(organizationId, id, request, headers, runtime);
  }

  /**
   * 更新代码评审的标题和描述
   * 
   * @param request - UpdateMergeRequestRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateMergeRequestResponse
   */
  async updateMergeRequestWithOptions(repositoryId: string, localId: string, request: UpdateMergeRequestRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateMergeRequestResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.title)) {
      body["title"] = request.title;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateMergeRequest",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/merge_requests/${OpenApiUtil.getEncodeParam(localId)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateMergeRequestResponse>(await this.callApi(params, req, runtime), new UpdateMergeRequestResponse({}));
  }

  /**
   * 更新代码评审的标题和描述
   * 
   * @param request - UpdateMergeRequestRequest
   * @returns UpdateMergeRequestResponse
   */
  async updateMergeRequest(repositoryId: string, localId: string, request: UpdateMergeRequestRequest): Promise<UpdateMergeRequestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateMergeRequestWithOptions(repositoryId, localId, request, headers, runtime);
  }

  /**
   * 更新代码评审的干系人
   * 
   * @param request - UpdateMergeRequestPersonnelRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateMergeRequestPersonnelResponse
   */
  async updateMergeRequestPersonnelWithOptions(repositoryId: string, localId: string, personType: string, request: UpdateMergeRequestPersonnelRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateMergeRequestPersonnelResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.newUserIdList)) {
      body["newUserIdList"] = request.newUserIdList;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateMergeRequestPersonnel",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/merge_requests/${OpenApiUtil.getEncodeParam(localId)}/person/${OpenApiUtil.getEncodeParam(personType)}`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateMergeRequestPersonnelResponse>(await this.callApi(params, req, runtime), new UpdateMergeRequestPersonnelResponse({}));
  }

  /**
   * 更新代码评审的干系人
   * 
   * @param request - UpdateMergeRequestPersonnelRequest
   * @returns UpdateMergeRequestPersonnelResponse
   */
  async updateMergeRequestPersonnel(repositoryId: string, localId: string, personType: string, request: UpdateMergeRequestPersonnelRequest): Promise<UpdateMergeRequestPersonnelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateMergeRequestPersonnelWithOptions(repositoryId, localId, personType, request, headers, runtime);
  }

  /**
   * 当前用户加入的企业列表
   * 
   * @param request - UpdateOrganizationMemberRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateOrganizationMemberResponse
   */
  async updateOrganizationMemberWithOptions(organizationId: string, accountId: string, request: UpdateOrganizationMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateOrganizationMemberResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationMemberName)) {
      query["organizationMemberName"] = request.organizationMemberName;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateOrganizationMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/members/${OpenApiUtil.getEncodeParam(accountId)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateOrganizationMemberResponse>(await this.callApi(params, req, runtime), new UpdateOrganizationMemberResponse({}));
  }

  /**
   * 当前用户加入的企业列表
   * 
   * @param request - UpdateOrganizationMemberRequest
   * @returns UpdateOrganizationMemberResponse
   */
  async updateOrganizationMember(organizationId: string, accountId: string, request: UpdateOrganizationMemberRequest): Promise<UpdateOrganizationMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateOrganizationMemberWithOptions(organizationId, accountId, request, headers, runtime);
  }

  /**
   * 更新流水线。
   * 
   * @param request - UpdatePipelineRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdatePipelineResponse
   */
  async updatePipelineWithOptions(organizationId: string, request: UpdatePipelineRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdatePipelineResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.content)) {
      body["content"] = request.content;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.pipelineId)) {
      body["pipelineId"] = request.pipelineId;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdatePipeline",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/update`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdatePipelineResponse>(await this.callApi(params, req, runtime), new UpdatePipelineResponse({}));
  }

  /**
   * 更新流水线。
   * 
   * @param request - UpdatePipelineRequest
   * @returns UpdatePipelineResponse
   */
  async updatePipeline(organizationId: string, request: UpdatePipelineRequest): Promise<UpdatePipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updatePipelineWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 删除标签
   * 
   * @param request - UpdatePipelineBaseInfoRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdatePipelineBaseInfoResponse
   */
  async updatePipelineBaseInfoWithOptions(organizationId: string, pipelineId: string, request: UpdatePipelineBaseInfoRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdatePipelineBaseInfoResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.envId)) {
      query["envId"] = request.envId;
    }

    if (!Util.isUnset(request.pipelineName)) {
      query["pipelineName"] = request.pipelineName;
    }

    if (!Util.isUnset(request.tagList)) {
      query["tagList"] = request.tagList;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdatePipelineBaseInfo",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelines/${OpenApiUtil.getEncodeParam(pipelineId)}/baseInfo`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdatePipelineBaseInfoResponse>(await this.callApi(params, req, runtime), new UpdatePipelineBaseInfoResponse({}));
  }

  /**
   * 删除标签
   * 
   * @param request - UpdatePipelineBaseInfoRequest
   * @returns UpdatePipelineBaseInfoResponse
   */
  async updatePipelineBaseInfo(organizationId: string, pipelineId: string, request: UpdatePipelineBaseInfoRequest): Promise<UpdatePipelineBaseInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updatePipelineBaseInfoWithOptions(organizationId, pipelineId, request, headers, runtime);
  }

  /**
   * 更新流水线分组
   * 
   * @param request - UpdatePipelineGroupRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdatePipelineGroupResponse
   */
  async updatePipelineGroupWithOptions(organizationId: string, groupId: string, request: UpdatePipelineGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdatePipelineGroupResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      query["name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdatePipelineGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/pipelineGroups/${OpenApiUtil.getEncodeParam(groupId)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdatePipelineGroupResponse>(await this.callApi(params, req, runtime), new UpdatePipelineGroupResponse({}));
  }

  /**
   * 更新流水线分组
   * 
   * @param request - UpdatePipelineGroupRequest
   * @returns UpdatePipelineGroupResponse
   */
  async updatePipelineGroup(organizationId: string, groupId: string, request: UpdatePipelineGroupRequest): Promise<UpdatePipelineGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updatePipelineGroupWithOptions(organizationId, groupId, request, headers, runtime);
  }

  /**
   * 更新项目属性与字段
   * 
   * @param request - UpdateProjectFieldRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateProjectFieldResponse
   */
  async updateProjectFieldWithOptions(organizationId: string, identifier: string, request: UpdateProjectFieldRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateProjectFieldResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.statusIdentifier)) {
      body["statusIdentifier"] = request.statusIdentifier;
    }

    if (!Util.isUnset(request.updateBasicFieldRequestList)) {
      body["updateBasicFieldRequestList"] = request.updateBasicFieldRequestList;
    }

    if (!Util.isUnset(request.updateForOpenApiList)) {
      body["updateForOpenApiList"] = request.updateForOpenApiList;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateProjectField",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/project/${OpenApiUtil.getEncodeParam(identifier)}`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateProjectFieldResponse>(await this.callApi(params, req, runtime), new UpdateProjectFieldResponse({}));
  }

  /**
   * 更新项目属性与字段
   * 
   * @param request - UpdateProjectFieldRequest
   * @returns UpdateProjectFieldResponse
   */
  async updateProjectField(organizationId: string, identifier: string, request: UpdateProjectFieldRequest): Promise<UpdateProjectFieldResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateProjectFieldWithOptions(organizationId, identifier, request, headers, runtime);
  }

  /**
   * 更新代码库Label
   * 
   * @param request - UpdateProjectLabelRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateProjectLabelResponse
   */
  async updateProjectLabelWithOptions(labelId: string, request: UpdateProjectLabelRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateProjectLabelResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.repositoryIdentity)) {
      query["repositoryIdentity"] = request.repositoryIdentity;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.color)) {
      body["color"] = request.color;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateProjectLabel",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/labels/${OpenApiUtil.getEncodeParam(labelId)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateProjectLabelResponse>(await this.callApi(params, req, runtime), new UpdateProjectLabelResponse({}));
  }

  /**
   * 更新代码库Label
   * 
   * @param request - UpdateProjectLabelRequest
   * @returns UpdateProjectLabelResponse
   */
  async updateProjectLabel(labelId: string, request: UpdateProjectLabelRequest): Promise<UpdateProjectLabelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateProjectLabelWithOptions(labelId, request, headers, runtime);
  }

  /**
   * 添加项目成员
   * 
   * @param request - UpdateProjectMemberRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateProjectMemberResponse
   */
  async updateProjectMemberWithOptions(organizationId: string, projectId: string, request: UpdateProjectMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateProjectMemberResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.roleIdentifier)) {
      body["roleIdentifier"] = request.roleIdentifier;
    }

    if (!Util.isUnset(request.targetIdentifier)) {
      body["targetIdentifier"] = request.targetIdentifier;
    }

    if (!Util.isUnset(request.targetType)) {
      body["targetType"] = request.targetType;
    }

    if (!Util.isUnset(request.userIdentifier)) {
      body["userIdentifier"] = request.userIdentifier;
    }

    if (!Util.isUnset(request.userType)) {
      body["userType"] = request.userType;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateProjectMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/projects/${OpenApiUtil.getEncodeParam(projectId)}/updateMember`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateProjectMemberResponse>(await this.callApi(params, req, runtime), new UpdateProjectMemberResponse({}));
  }

  /**
   * 添加项目成员
   * 
   * @param request - UpdateProjectMemberRequest
   * @returns UpdateProjectMemberResponse
   */
  async updateProjectMember(organizationId: string, projectId: string, request: UpdateProjectMemberRequest): Promise<UpdateProjectMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateProjectMemberWithOptions(organizationId, projectId, request, headers, runtime);
  }

  /**
   * 更改保护分支设置
   * 
   * @param request - UpdateProtectedBranchesRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateProtectedBranchesResponse
   */
  async updateProtectedBranchesWithOptions(repositoryId: string, id: string, request: UpdateProtectedBranchesRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateProtectedBranchesResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.allowMergeRoles)) {
      body["allowMergeRoles"] = request.allowMergeRoles;
    }

    if (!Util.isUnset(request.allowMergeUserIds)) {
      body["allowMergeUserIds"] = request.allowMergeUserIds;
    }

    if (!Util.isUnset(request.allowPushRoles)) {
      body["allowPushRoles"] = request.allowPushRoles;
    }

    if (!Util.isUnset(request.allowPushUserIds)) {
      body["allowPushUserIds"] = request.allowPushUserIds;
    }

    if (!Util.isUnset(request.branch)) {
      body["branch"] = request.branch;
    }

    if (!Util.isUnset(request.id)) {
      body["id"] = request.id;
    }

    if (!Util.isUnset(request.mergeRequestSetting)) {
      body["mergeRequestSetting"] = request.mergeRequestSetting;
    }

    if (!Util.isUnset(request.testSettingDTO)) {
      body["testSettingDTO"] = request.testSettingDTO;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateProtectedBranches",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/${OpenApiUtil.getEncodeParam(repositoryId)}/protect_branches/${OpenApiUtil.getEncodeParam(id)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateProtectedBranchesResponse>(await this.callApi(params, req, runtime), new UpdateProtectedBranchesResponse({}));
  }

  /**
   * 更改保护分支设置
   * 
   * @param request - UpdateProtectedBranchesRequest
   * @returns UpdateProtectedBranchesResponse
   */
  async updateProtectedBranches(repositoryId: string, id: string, request: UpdateProtectedBranchesRequest): Promise<UpdateProtectedBranchesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateProtectedBranchesWithOptions(repositoryId, id, request, headers, runtime);
  }

  /**
   * 推送评审模式开关
   * 
   * @param request - UpdatePushReviewOnOffRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdatePushReviewOnOffResponse
   */
  async updatePushReviewOnOffWithOptions(repositoryId: string, request: UpdatePushReviewOnOffRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdatePushReviewOnOffResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.trunkMode)) {
      query["trunkMode"] = request.trunkMode;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdatePushReviewOnOff",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/settings/trunk_mode`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdatePushReviewOnOffResponse>(await this.callApi(params, req, runtime), new UpdatePushReviewOnOffResponse({}));
  }

  /**
   * 推送评审模式开关
   * 
   * @param request - UpdatePushReviewOnOffRequest
   * @returns UpdatePushReviewOnOffResponse
   */
  async updatePushReviewOnOff(repositoryId: string, request: UpdatePushReviewOnOffRequest): Promise<UpdatePushReviewOnOffResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updatePushReviewOnOffWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 更新推送规则
   * 
   * @param request - UpdatePushRuleRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdatePushRuleResponse
   */
  async updatePushRuleWithOptions(repositoryId: string, pushRuleId: string, request: UpdatePushRuleRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdatePushRuleResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.ruleInfos)) {
      body["ruleInfos"] = request.ruleInfos;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdatePushRule",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/api/v4/projects/${OpenApiUtil.getEncodeParam(repositoryId)}/push_rule/${OpenApiUtil.getEncodeParam(pushRuleId)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdatePushRuleResponse>(await this.callApi(params, req, runtime), new UpdatePushRuleResponse({}));
  }

  /**
   * 更新推送规则
   * 
   * @param request - UpdatePushRuleRequest
   * @returns UpdatePushRuleResponse
   */
  async updatePushRule(repositoryId: string, pushRuleId: string, request: UpdatePushRuleRequest): Promise<UpdatePushRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updatePushRuleWithOptions(repositoryId, pushRuleId, request, headers, runtime);
  }

  /**
   * 更新代码库名称、路径、描述、默认分支等设置
   * 
   * @param request - UpdateRepositoryRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateRepositoryResponse
   */
  async updateRepositoryWithOptions(repositoryId: string, request: UpdateRepositoryRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateRepositoryResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.adminSettingLanguage)) {
      body["adminSettingLanguage"] = request.adminSettingLanguage;
    }

    if (!Util.isUnset(request.avatar)) {
      body["avatar"] = request.avatar;
    }

    if (!Util.isUnset(request.buildsEnabled)) {
      body["buildsEnabled"] = request.buildsEnabled;
    }

    if (!Util.isUnset(request.checkEmail)) {
      body["checkEmail"] = request.checkEmail;
    }

    if (!Util.isUnset(request.defaultBranch)) {
      body["defaultBranch"] = request.defaultBranch;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.id)) {
      body["id"] = request.id;
    }

    if (!Util.isUnset(request.issuesEnabled)) {
      body["issuesEnabled"] = request.issuesEnabled;
    }

    if (!Util.isUnset(request.mergeRequestsEnabled)) {
      body["mergeRequestsEnabled"] = request.mergeRequestsEnabled;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.openCloneDownloadControl)) {
      body["openCloneDownloadControl"] = request.openCloneDownloadControl;
    }

    if (!Util.isUnset(request.path)) {
      body["path"] = request.path;
    }

    if (!Util.isUnset(request.projectCloneDownloadMethodList)) {
      body["projectCloneDownloadMethodList"] = request.projectCloneDownloadMethodList;
    }

    if (!Util.isUnset(request.projectCloneDownloadRoleList)) {
      body["projectCloneDownloadRoleList"] = request.projectCloneDownloadRoleList;
    }

    if (!Util.isUnset(request.snippetsEnabled)) {
      body["snippetsEnabled"] = request.snippetsEnabled;
    }

    if (!Util.isUnset(request.visibilityLevel)) {
      body["visibilityLevel"] = request.visibilityLevel;
    }

    if (!Util.isUnset(request.wikiEnabled)) {
      body["wikiEnabled"] = request.wikiEnabled;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateRepository",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateRepositoryResponse>(await this.callApi(params, req, runtime), new UpdateRepositoryResponse({}));
  }

  /**
   * 更新代码库名称、路径、描述、默认分支等设置
   * 
   * @param request - UpdateRepositoryRequest
   * @returns UpdateRepositoryResponse
   */
  async updateRepository(repositoryId: string, request: UpdateRepositoryRequest): Promise<UpdateRepositoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateRepositoryWithOptions(repositoryId, request, headers, runtime);
  }

  /**
   * 修改代码库成员的权限（角色）
   * 
   * @param request - UpdateRepositoryMemberRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateRepositoryMemberResponse
   */
  async updateRepositoryMemberWithOptions(repositoryId: string, aliyunPk: string, request: UpdateRepositoryMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateRepositoryMemberResponse> {
    Util.validateModel(request);
    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessToken)) {
      query["accessToken"] = request.accessToken;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["organizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessLevel)) {
      body["accessLevel"] = request.accessLevel;
    }

    if (!Util.isUnset(request.expireAt)) {
      body["expireAt"] = request.expireAt;
    }

    if (!Util.isUnset(request.memberType)) {
      body["memberType"] = request.memberType;
    }

    if (!Util.isUnset(request.relatedId)) {
      body["relatedId"] = request.relatedId;
    }

    if (!Util.isUnset(request.relatedInfos)) {
      body["relatedInfos"] = request.relatedInfos;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateRepositoryMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/repository/${OpenApiUtil.getEncodeParam(repositoryId)}/members/${OpenApiUtil.getEncodeParam(aliyunPk)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateRepositoryMemberResponse>(await this.callApi(params, req, runtime), new UpdateRepositoryMemberResponse({}));
  }

  /**
   * 修改代码库成员的权限（角色）
   * 
   * @param request - UpdateRepositoryMemberRequest
   * @returns UpdateRepositoryMemberResponse
   */
  async updateRepositoryMember(repositoryId: string, aliyunPk: string, request: UpdateRepositoryMemberRequest): Promise<UpdateRepositoryMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateRepositoryMemberWithOptions(repositoryId, aliyunPk, request, headers, runtime);
  }

  /**
   * 更新资源成员
   * 
   * @param request - UpdateResourceMemberRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateResourceMemberResponse
   */
  async updateResourceMemberWithOptions(organizationId: string, resourceType: string, resourceId: string, accountId: string, request: UpdateResourceMemberRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateResourceMemberResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.roleName)) {
      body["roleName"] = request.roleName;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateResourceMember",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/${OpenApiUtil.getEncodeParam(resourceType)}/${OpenApiUtil.getEncodeParam(resourceId)}/members/${OpenApiUtil.getEncodeParam(accountId)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateResourceMemberResponse>(await this.callApi(params, req, runtime), new UpdateResourceMemberResponse({}));
  }

  /**
   * 更新资源成员
   * 
   * @param request - UpdateResourceMemberRequest
   * @returns UpdateResourceMemberResponse
   */
  async updateResourceMember(organizationId: string, resourceType: string, resourceId: string, accountId: string, request: UpdateResourceMemberRequest): Promise<UpdateResourceMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateResourceMemberWithOptions(organizationId, resourceType, resourceId, accountId, request, headers, runtime);
  }

  /**
   * 更新测试用例字段
   * 
   * @param request - UpdateTestCaseRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTestCaseResponse
   */
  async updateTestCaseWithOptions(organizationId: string, testcaseIdentifier: string, request: UpdateTestCaseRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateTestCaseResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.updateWorkitemPropertyRequest)) {
      body["updateWorkitemPropertyRequest"] = request.updateWorkitemPropertyRequest;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTestCase",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/testhub/testcase/${OpenApiUtil.getEncodeParam(testcaseIdentifier)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateTestCaseResponse>(await this.callApi(params, req, runtime), new UpdateTestCaseResponse({}));
  }

  /**
   * 更新测试用例字段
   * 
   * @param request - UpdateTestCaseRequest
   * @returns UpdateTestCaseResponse
   */
  async updateTestCase(organizationId: string, testcaseIdentifier: string, request: UpdateTestCaseRequest): Promise<UpdateTestCaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateTestCaseWithOptions(organizationId, testcaseIdentifier, request, headers, runtime);
  }

  /**
   * 更新了测试计划中测试用例的执行人与状态
   * 
   * @param request - UpdateTestResultRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTestResultResponse
   */
  async updateTestResultWithOptions(organizationId: string, testPlanIdentifier: string, testcaseIdentifier: string, request: UpdateTestResultRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateTestResultResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.executor)) {
      body["executor"] = request.executor;
    }

    if (!Util.isUnset(request.status)) {
      body["status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTestResult",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/testhub/testplan/${OpenApiUtil.getEncodeParam(testPlanIdentifier)}/testresult/${OpenApiUtil.getEncodeParam(testcaseIdentifier)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateTestResultResponse>(await this.callApi(params, req, runtime), new UpdateTestResultResponse({}));
  }

  /**
   * 更新了测试计划中测试用例的执行人与状态
   * 
   * @param request - UpdateTestResultRequest
   * @returns UpdateTestResultResponse
   */
  async updateTestResult(organizationId: string, testPlanIdentifier: string, testcaseIdentifier: string, request: UpdateTestResultRequest): Promise<UpdateTestResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateTestResultWithOptions(organizationId, testPlanIdentifier, testcaseIdentifier, request, headers, runtime);
  }

  /**
   * 更新变量组
   * 
   * @param request - UpdateVariableGroupRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateVariableGroupResponse
   */
  async updateVariableGroupWithOptions(organizationId: string, id: string, request: UpdateVariableGroupRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateVariableGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      body["name"] = request.name;
    }

    if (!Util.isUnset(request.variables)) {
      body["variables"] = request.variables;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateVariableGroup",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/variableGroups/${OpenApiUtil.getEncodeParam(id)}`,
      method: "PUT",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateVariableGroupResponse>(await this.callApi(params, req, runtime), new UpdateVariableGroupResponse({}));
  }

  /**
   * 更新变量组
   * 
   * @param request - UpdateVariableGroupRequest
   * @returns UpdateVariableGroupResponse
   */
  async updateVariableGroup(organizationId: string, id: string, request: UpdateVariableGroupRequest): Promise<UpdateVariableGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateVariableGroupWithOptions(organizationId, id, request, headers, runtime);
  }

  /**
   * 更新工作项信息
   * 
   * @param request - UpdateWorkItemRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateWorkItemResponse
   */
  async updateWorkItemWithOptions(organizationId: string, request: UpdateWorkItemRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateWorkItemResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.fieldType)) {
      body["fieldType"] = request.fieldType;
    }

    if (!Util.isUnset(request.identifier)) {
      body["identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.propertyKey)) {
      body["propertyKey"] = request.propertyKey;
    }

    if (!Util.isUnset(request.propertyValue)) {
      body["propertyValue"] = request.propertyValue;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateWorkItem",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/update`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateWorkItemResponse>(await this.callApi(params, req, runtime), new UpdateWorkItemResponse({}));
  }

  /**
   * 更新工作项信息
   * 
   * @param request - UpdateWorkItemRequest
   * @returns UpdateWorkItemResponse
   */
  async updateWorkItem(organizationId: string, request: UpdateWorkItemRequest): Promise<UpdateWorkItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateWorkItemWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 更新工作项评论
   * 
   * @param request - UpdateWorkitemCommentRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateWorkitemCommentResponse
   */
  async updateWorkitemCommentWithOptions(organizationId: string, request: UpdateWorkitemCommentRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateWorkitemCommentResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.commentId)) {
      body["commentId"] = request.commentId;
    }

    if (!Util.isUnset(request.content)) {
      body["content"] = request.content;
    }

    if (!Util.isUnset(request.formatType)) {
      body["formatType"] = request.formatType;
    }

    if (!Util.isUnset(request.workitemIdentifier)) {
      body["workitemIdentifier"] = request.workitemIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateWorkitemComment",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/commentUpdate`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateWorkitemCommentResponse>(await this.callApi(params, req, runtime), new UpdateWorkitemCommentResponse({}));
  }

  /**
   * 更新工作项评论
   * 
   * @param request - UpdateWorkitemCommentRequest
   * @returns UpdateWorkitemCommentResponse
   */
  async updateWorkitemComment(organizationId: string, request: UpdateWorkitemCommentRequest): Promise<UpdateWorkitemCommentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateWorkitemCommentWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 批量更新工作项字段信息
   * 
   * @param request - UpdateWorkitemFieldRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateWorkitemFieldResponse
   */
  async updateWorkitemFieldWithOptions(organizationId: string, request: UpdateWorkitemFieldRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<UpdateWorkitemFieldResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.updateWorkitemPropertyRequest)) {
      body["updateWorkitemPropertyRequest"] = request.updateWorkitemPropertyRequest;
    }

    if (!Util.isUnset(request.workitemIdentifier)) {
      body["workitemIdentifier"] = request.workitemIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateWorkitemField",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitems/updateWorkitemField`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateWorkitemFieldResponse>(await this.callApi(params, req, runtime), new UpdateWorkitemFieldResponse({}));
  }

  /**
   * 批量更新工作项字段信息
   * 
   * @param request - UpdateWorkitemFieldRequest
   * @returns UpdateWorkitemFieldResponse
   */
  async updateWorkitemField(organizationId: string, request: UpdateWorkitemFieldRequest): Promise<UpdateWorkitemFieldResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.updateWorkitemFieldWithOptions(organizationId, request, headers, runtime);
  }

  /**
   * 工作项附件创建
   * 
   * @param request - WorkitemAttachmentCreateRequest
   * @param headers - map
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns WorkitemAttachmentCreateResponse
   */
  async workitemAttachmentCreateWithOptions(organizationId: string, workitemIdentifier: string, request: WorkitemAttachmentCreateRequest, headers: {[key: string ]: string}, runtime: $Util.RuntimeOptions): Promise<WorkitemAttachmentCreateResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.fileKey)) {
      body["fileKey"] = request.fileKey;
    }

    if (!Util.isUnset(request.originalFilename)) {
      body["originalFilename"] = request.originalFilename;
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: headers,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "WorkitemAttachmentCreate",
      version: "2021-06-25",
      protocol: "HTTPS",
      pathname: `/organization/${OpenApiUtil.getEncodeParam(organizationId)}/workitem/${OpenApiUtil.getEncodeParam(workitemIdentifier)}/attachment`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<WorkitemAttachmentCreateResponse>(await this.callApi(params, req, runtime), new WorkitemAttachmentCreateResponse({}));
  }

  /**
   * 工作项附件创建
   * 
   * @param request - WorkitemAttachmentCreateRequest
   * @returns WorkitemAttachmentCreateResponse
   */
  async workitemAttachmentCreate(organizationId: string, workitemIdentifier: string, request: WorkitemAttachmentCreateRequest): Promise<WorkitemAttachmentCreateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers : {[key: string ]: string} = { };
    return await this.workitemAttachmentCreateWithOptions(organizationId, workitemIdentifier, request, headers, runtime);
  }

}
