// This file is auto-generated, don't edit it
/**
 */
import Util, * as $Util from '@alicloud/tea-util';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class GatewayDomain extends $tea.Model {
  certIdentifier?: string;
  gatewayId?: number;
  gatewayName?: string;
  gatewayUniqueId?: string;
  gmtCreate?: string;
  gmtModified?: string;
  id?: number;
  mustHttps?: string;
  name?: string;
  protocol?: string;
  static names(): { [key: string]: string } {
    return {
      certIdentifier: 'CertIdentifier',
      gatewayId: 'GatewayId',
      gatewayName: 'GatewayName',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      mustHttps: 'MustHttps',
      name: 'Name',
      protocol: 'Protocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certIdentifier: 'string',
      gatewayId: 'number',
      gatewayName: 'string',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      mustHttps: 'string',
      name: 'string',
      protocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GatewayOption extends $tea.Model {
  disableHttp2Alpn?: boolean;
  enableHardwareAcceleration?: boolean;
  enableWaf?: boolean;
  logConfigDetails?: GatewayOptionLogConfigDetails;
  traceDetails?: GatewayOptionTraceDetails;
  static names(): { [key: string]: string } {
    return {
      disableHttp2Alpn: 'DisableHttp2Alpn',
      enableHardwareAcceleration: 'EnableHardwareAcceleration',
      enableWaf: 'EnableWaf',
      logConfigDetails: 'LogConfigDetails',
      traceDetails: 'TraceDetails',
    };
  }

  static types(): { [key: string]: any } {
    return {
      disableHttp2Alpn: 'boolean',
      enableHardwareAcceleration: 'boolean',
      enableWaf: 'boolean',
      logConfigDetails: GatewayOptionLogConfigDetails,
      traceDetails: GatewayOptionTraceDetails,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GatewayService extends $tea.Model {
  gatewayTrafficPolicy?: TrafficPolicy;
  gatewayUniqueId?: string;
  groupName?: string;
  id?: number;
  metaInfo?: string;
  name?: string;
  namespace?: string;
  sourceType?: string;
  static names(): { [key: string]: string } {
    return {
      gatewayTrafficPolicy: 'GatewayTrafficPolicy',
      gatewayUniqueId: 'GatewayUniqueId',
      groupName: 'GroupName',
      id: 'Id',
      metaInfo: 'MetaInfo',
      name: 'Name',
      namespace: 'Namespace',
      sourceType: 'SourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gatewayTrafficPolicy: TrafficPolicy,
      gatewayUniqueId: 'string',
      groupName: 'string',
      id: 'number',
      metaInfo: 'string',
      name: 'string',
      namespace: 'string',
      sourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TrafficPolicy extends $tea.Model {
  loadBalancerSettings?: TrafficPolicyLoadBalancerSettings;
  tlsSetting?: TrafficPolicyTlsSetting;
  static names(): { [key: string]: string } {
    return {
      loadBalancerSettings: 'LoadBalancerSettings',
      tlsSetting: 'TlsSetting',
    };
  }

  static types(): { [key: string]: any } {
    return {
      loadBalancerSettings: TrafficPolicyLoadBalancerSettings,
      tlsSetting: TrafficPolicyTlsSetting,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RulesValue extends $tea.Model {
  status?: number;
  rate?: number;
  enable?: boolean;
  tag?: string;
  /**
   * @example
   * gray
   */
  name?: string;
  id?: number;
  instanceNum?: number;
  rules?: RulesValueRules;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      rate: 'Rate',
      enable: 'Enable',
      tag: 'Tag',
      name: 'Name',
      id: 'Id',
      instanceNum: 'InstanceNum',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'number',
      rate: 'number',
      enable: 'boolean',
      tag: 'string',
      name: 'string',
      id: 'number',
      instanceNum: 'number',
      rules: RulesValueRules,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DataValue extends $tea.Model {
  /**
   * @remarks
   * The ID of the user to which the application belongs.
   * 
   * @example
   * 12345
   */
  userId?: string;
  /**
   * @remarks
   * The region where the application resides.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The microservice namespace where the application resides.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * example-app-name
   */
  appName?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * 123456abcde@12345abcde
   */
  appId?: string;
  static names(): { [key: string]: string } {
    return {
      userId: 'UserId',
      regionId: 'RegionId',
      namespace: 'Namespace',
      appName: 'AppName',
      appId: 'AppId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userId: 'string',
      regionId: 'string',
      namespace: 'string',
      appName: 'string',
      appId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAuthPolicyRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @example
   * e9clba2xlc@***
   */
  appId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * [{"all":true,"black":false,"appIds":["dez4qt7weh@***"]}]
   */
  authRule?: string;
  /**
   * @example
   * 0
   */
  authType?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * true
   */
  enable?: string;
  /**
   * @example
   * c19c6c500e1ff4d7abc7***
   */
  k8sNamespace?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * SPRING_CLOUD
   */
  protocol?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * edasmsc
   */
  source?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      authRule: 'AuthRule',
      authType: 'AuthType',
      enable: 'Enable',
      k8sNamespace: 'K8sNamespace',
      name: 'Name',
      namespace: 'Namespace',
      protocol: 'Protocol',
      region: 'Region',
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      authRule: 'string',
      authType: 'number',
      enable: 'string',
      k8sNamespace: 'string',
      name: 'string',
      namespace: 'string',
      protocol: 'string',
      region: 'string',
      source: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAuthPolicyResponseBody extends $tea.Model {
  /**
   * @example
   * 200
   */
  code?: number;
  data?: string;
  /**
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @example
   * OK
   */
  message?: string;
  /**
   * @example
   * dc63-465d-8ef5-20dc18af****
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAuthPolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddAuthPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddAuthPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAuthResourceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the authorization record.
   * 
   * @example
   * 13
   */
  authId?: number;
  /**
   * @remarks
   * The authentication resource headers.
   */
  authResourceHeaderList?: AddAuthResourceRequestAuthResourceHeaderList[];
  /**
   * @remarks
   * The domain ID.
   * 
   * @example
   * 128
   */
  domainId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-86575c0bc9f04ecfbacb92b8e392****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * Specifies whether the matching is not case-sensitive. Default value: true.
   * 
   * @example
   * true
   */
  ignoreCase?: boolean;
  /**
   * @remarks
   * The matching type. Valid values:
   * 
   * *   EQUAL
   * *   PRE
   * *   ERGULAR
   * 
   * @example
   * exact
   */
  matchType?: string;
  /**
   * @remarks
   * The path.
   * 
   * @example
   * /abc
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      authId: 'AuthId',
      authResourceHeaderList: 'AuthResourceHeaderList',
      domainId: 'DomainId',
      gatewayUniqueId: 'GatewayUniqueId',
      ignoreCase: 'IgnoreCase',
      matchType: 'MatchType',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      authId: 'number',
      authResourceHeaderList: { 'type': 'array', 'itemType': AddAuthResourceRequestAuthResourceHeaderList },
      domainId: 'number',
      gatewayUniqueId: 'string',
      ignoreCase: 'boolean',
      matchType: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAuthResourceShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the authorization record.
   * 
   * @example
   * 13
   */
  authId?: number;
  /**
   * @remarks
   * The authentication resource headers.
   */
  authResourceHeaderListShrink?: string;
  /**
   * @remarks
   * The domain ID.
   * 
   * @example
   * 128
   */
  domainId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-86575c0bc9f04ecfbacb92b8e392****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * Specifies whether the matching is not case-sensitive. Default value: true.
   * 
   * @example
   * true
   */
  ignoreCase?: boolean;
  /**
   * @remarks
   * The matching type. Valid values:
   * 
   * *   EQUAL
   * *   PRE
   * *   ERGULAR
   * 
   * @example
   * exact
   */
  matchType?: string;
  /**
   * @remarks
   * The path.
   * 
   * @example
   * /abc
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      authId: 'AuthId',
      authResourceHeaderListShrink: 'AuthResourceHeaderList',
      domainId: 'DomainId',
      gatewayUniqueId: 'GatewayUniqueId',
      ignoreCase: 'IgnoreCase',
      matchType: 'MatchType',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      authId: 'number',
      authResourceHeaderListShrink: 'string',
      domainId: 'number',
      gatewayUniqueId: 'string',
      ignoreCase: 'boolean',
      matchType: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAuthResourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data structure.
   * 
   * @example
   * 24
   */
  data?: number;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 403
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4BBCF560-4DD7-5DBD-B849-CCB135BBBAB7
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAuthResourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddAuthResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddAuthResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddBlackWhiteListRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The content of the blacklist.
   * 
   * @example
   * 1.117.115.51
   */
  content?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-0fe488252dc44d55a9dd57875193****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The whitelist. Default value: No.
   * 
   * @example
   * false
   */
  isWhite?: boolean;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * name
   */
  name?: string;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * this is a note
   */
  note?: string;
  /**
   * @remarks
   * The resource IDs in the JSON format.
   * 
   * @example
   * [123]
   */
  resourceIdJsonList?: string;
  /**
   * @remarks
   * The effective scope of the blacklist or whitelist. Valid values:
   * 
   * *   GATEWAY
   * *   DOMAIN
   * *   ROUTE
   * 
   * @example
   * GATEWAY
   */
  resourceType?: string;
  /**
   * @remarks
   * The status of the blacklist.
   * 
   * *   on: enabled
   * *   off: disabled
   * 
   * @example
   * off
   */
  status?: string;
  /**
   * @remarks
   * The type of object in the blacklist or whitelist.
   * 
   * @example
   * IP
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      content: 'Content',
      gatewayUniqueId: 'GatewayUniqueId',
      isWhite: 'IsWhite',
      name: 'Name',
      note: 'Note',
      resourceIdJsonList: 'ResourceIdJsonList',
      resourceType: 'ResourceType',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      content: 'string',
      gatewayUniqueId: 'string',
      isWhite: 'boolean',
      name: 'string',
      note: 'string',
      resourceIdJsonList: 'string',
      resourceType: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddBlackWhiteListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The ID of the record.
   * 
   * @example
   * 2
   */
  data?: number;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 966F6CA7-16D0-50AB-AB02-E140934F90C1
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddBlackWhiteListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddBlackWhiteListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddBlackWhiteListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The billing method you specify when you purchase an ordinary instance.
   * 
   * Valid values:
   * 
   * *   PREPAY: subscription
   * *   POSTPAY: pay-as-you-go
   * 
   * @example
   * POSTPAY
   */
  chargeType?: string;
  /**
   * @remarks
   * The network type of the purchased Classic Load Balancer (CLB) instance that is billed based on LCUs.
   * 
   * *   pubnet: Internet
   * *   privatenet: private network
   * *   privatepubnet: Internet and private network
   * 
   * @example
   * pubnet
   */
  clbNetworkType?: string;
  /**
   * @remarks
   * Specifies whether to activate Tracing Analysis.
   * 
   * @example
   * false
   */
  enableHardwareAcceleration?: boolean;
  /**
   * @remarks
   * The tag of the gateway.
   * 
   * @example
   * false
   */
  enableSls?: boolean;
  /**
   * @remarks
   * The sampling rate of Tracing Analysis. Valid values: [1,100].
   * 
   * @example
   * false
   */
  enableXtrace?: boolean;
  /**
   * @remarks
   * Specifies whether to enable hardware acceleration.
   * 
   * @example
   * false
   */
  enterpriseSecurityGroup?: boolean;
  /**
   * @remarks
   * The specifications of the Internet-facing Server Load Balancer (SLB) instance. Valid values:
   * 
   * *   slb.s1.small
   * *   slb.s2.smal
   * *   slb.s2.medium
   * *   slb.s3.small
   * *   slb.s3.medium
   * *   slb.s3.large
   * 
   * @example
   * slb.s2.small
   */
  internetSlbSpec?: string;
  /**
   * @remarks
   * The MSE instance type. Valid values:
   * 
   * *   mse_pro: ordinary instance
   * *   mse_serverless: serverless instance
   * 
   * @example
   * mse_pro
   */
  mserVersion?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * test-ceshi
   */
  name?: string;
  /**
   * @remarks
   * The network type of the Network Load Balancer (NLB) instance you specify when you purchase a serverless instance.
   * 
   * *   pubnet: Internet
   * *   privatenet: private network
   * *   privatepubnet: Internet and private network
   * 
   * @example
   * pubnet
   */
  nlbNetworkType?: string;
  /**
   * @remarks
   * The specifications of the internal-facing Server Load Balancer (SLB) instance. Valid values:
   * 
   * *   slb.s1.small
   * *   slb.s2.small
   * *   slb.s2.medium
   * *   slb.s3.small
   * *   slb.s3.medium
   * *   slb.s3.large
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The number of nodes you specify when you purchase an ordinary instance.
   * 
   * @example
   * 2
   */
  replica?: number;
  /**
   * @remarks
   * The extended field.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * rg-acfm34x43l*****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The specifications of the internal-facing Server Load Balancer (SLB) instance. Valid values:
   * 
   * *   slb.s1.small
   * *   slb.s2.small
   * *   slb.s2.medium
   * *   slb.s3.small
   * *   slb.s3.medium
   * *   slb.s3.large
   * 
   * @example
   * slb.s2.small
   */
  slbSpec?: string;
  /**
   * @remarks
   * The node specifications you specify when you purchase an ordinary instance. Valid values:
   * 
   * *   MSE_GTW_16_32_200_c(16C32G)
   * *   MSE_GTW_2_4_200_c(2C4G)
   * *   MSE_GTW_4_8_200_c(4C8G)
   * *   MSE_GTW_8_16_200_c(8C16G)
   * 
   * @example
   * MSE_GTW_2_4_200_c
   */
  spec?: string;
  /**
   * @remarks
   * The tag object.
   */
  tag?: AddGatewayRequestTag[];
  /**
   * @remarks
   * The ID of the primary vSwitch.
   * 
   * @example
   * vsw-bp1q8th57frl5khj2li43
   */
  vSwitchId?: string;
  /**
   * @remarks
   * Specifies whether to use an advanced security group.
   * 
   * @example
   * vsw-wz9bu6o5vsvitt5mrxo6s
   */
  vSwitchId2?: string;
  /**
   * @remarks
   * The ID of the primary vSwitch.
   * 
   * This parameter is required.
   * 
   * @example
   * vpc-bp15mncnrtm83uauxd1xb
   */
  vpc?: string;
  /**
   * @remarks
   * Specifies whether to activate Log Service.
   * 
   * @example
   * 10
   */
  xtraceRatio?: string;
  /**
   * @remarks
   * The details of the zone.
   */
  zoneInfo?: AddGatewayRequestZoneInfo[];
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      chargeType: 'ChargeType',
      clbNetworkType: 'ClbNetworkType',
      enableHardwareAcceleration: 'EnableHardwareAcceleration',
      enableSls: 'EnableSls',
      enableXtrace: 'EnableXtrace',
      enterpriseSecurityGroup: 'EnterpriseSecurityGroup',
      internetSlbSpec: 'InternetSlbSpec',
      mserVersion: 'MserVersion',
      name: 'Name',
      nlbNetworkType: 'NlbNetworkType',
      region: 'Region',
      replica: 'Replica',
      requestPars: 'RequestPars',
      resourceGroupId: 'ResourceGroupId',
      slbSpec: 'SlbSpec',
      spec: 'Spec',
      tag: 'Tag',
      vSwitchId: 'VSwitchId',
      vSwitchId2: 'VSwitchId2',
      vpc: 'Vpc',
      xtraceRatio: 'XtraceRatio',
      zoneInfo: 'ZoneInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      chargeType: 'string',
      clbNetworkType: 'string',
      enableHardwareAcceleration: 'boolean',
      enableSls: 'boolean',
      enableXtrace: 'boolean',
      enterpriseSecurityGroup: 'boolean',
      internetSlbSpec: 'string',
      mserVersion: 'string',
      name: 'string',
      nlbNetworkType: 'string',
      region: 'string',
      replica: 'number',
      requestPars: 'string',
      resourceGroupId: 'string',
      slbSpec: 'string',
      spec: 'string',
      tag: { 'type': 'array', 'itemType': AddGatewayRequestTag },
      vSwitchId: 'string',
      vSwitchId2: 'string',
      vpc: 'string',
      xtraceRatio: 'string',
      zoneInfo: { 'type': 'array', 'itemType': AddGatewayRequestZoneInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The billing method you specify when you purchase an ordinary instance.
   * 
   * Valid values:
   * 
   * *   PREPAY: subscription
   * *   POSTPAY: pay-as-you-go
   * 
   * @example
   * POSTPAY
   */
  chargeType?: string;
  /**
   * @remarks
   * The network type of the purchased Classic Load Balancer (CLB) instance that is billed based on LCUs.
   * 
   * *   pubnet: Internet
   * *   privatenet: private network
   * *   privatepubnet: Internet and private network
   * 
   * @example
   * pubnet
   */
  clbNetworkType?: string;
  /**
   * @remarks
   * Specifies whether to activate Tracing Analysis.
   * 
   * @example
   * false
   */
  enableHardwareAcceleration?: boolean;
  /**
   * @remarks
   * The tag of the gateway.
   * 
   * @example
   * false
   */
  enableSls?: boolean;
  /**
   * @remarks
   * The sampling rate of Tracing Analysis. Valid values: [1,100].
   * 
   * @example
   * false
   */
  enableXtrace?: boolean;
  /**
   * @remarks
   * Specifies whether to enable hardware acceleration.
   * 
   * @example
   * false
   */
  enterpriseSecurityGroup?: boolean;
  /**
   * @remarks
   * The specifications of the Internet-facing Server Load Balancer (SLB) instance. Valid values:
   * 
   * *   slb.s1.small
   * *   slb.s2.smal
   * *   slb.s2.medium
   * *   slb.s3.small
   * *   slb.s3.medium
   * *   slb.s3.large
   * 
   * @example
   * slb.s2.small
   */
  internetSlbSpec?: string;
  /**
   * @remarks
   * The MSE instance type. Valid values:
   * 
   * *   mse_pro: ordinary instance
   * *   mse_serverless: serverless instance
   * 
   * @example
   * mse_pro
   */
  mserVersion?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * test-ceshi
   */
  name?: string;
  /**
   * @remarks
   * The network type of the Network Load Balancer (NLB) instance you specify when you purchase a serverless instance.
   * 
   * *   pubnet: Internet
   * *   privatenet: private network
   * *   privatepubnet: Internet and private network
   * 
   * @example
   * pubnet
   */
  nlbNetworkType?: string;
  /**
   * @remarks
   * The specifications of the internal-facing Server Load Balancer (SLB) instance. Valid values:
   * 
   * *   slb.s1.small
   * *   slb.s2.small
   * *   slb.s2.medium
   * *   slb.s3.small
   * *   slb.s3.medium
   * *   slb.s3.large
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The number of nodes you specify when you purchase an ordinary instance.
   * 
   * @example
   * 2
   */
  replica?: number;
  /**
   * @remarks
   * The extended field.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * rg-acfm34x43l*****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The specifications of the internal-facing Server Load Balancer (SLB) instance. Valid values:
   * 
   * *   slb.s1.small
   * *   slb.s2.small
   * *   slb.s2.medium
   * *   slb.s3.small
   * *   slb.s3.medium
   * *   slb.s3.large
   * 
   * @example
   * slb.s2.small
   */
  slbSpec?: string;
  /**
   * @remarks
   * The node specifications you specify when you purchase an ordinary instance. Valid values:
   * 
   * *   MSE_GTW_16_32_200_c(16C32G)
   * *   MSE_GTW_2_4_200_c(2C4G)
   * *   MSE_GTW_4_8_200_c(4C8G)
   * *   MSE_GTW_8_16_200_c(8C16G)
   * 
   * @example
   * MSE_GTW_2_4_200_c
   */
  spec?: string;
  /**
   * @remarks
   * The tag object.
   */
  tag?: AddGatewayShrinkRequestTag[];
  /**
   * @remarks
   * The ID of the primary vSwitch.
   * 
   * @example
   * vsw-bp1q8th57frl5khj2li43
   */
  vSwitchId?: string;
  /**
   * @remarks
   * Specifies whether to use an advanced security group.
   * 
   * @example
   * vsw-wz9bu6o5vsvitt5mrxo6s
   */
  vSwitchId2?: string;
  /**
   * @remarks
   * The ID of the primary vSwitch.
   * 
   * This parameter is required.
   * 
   * @example
   * vpc-bp15mncnrtm83uauxd1xb
   */
  vpc?: string;
  /**
   * @remarks
   * Specifies whether to activate Log Service.
   * 
   * @example
   * 10
   */
  xtraceRatio?: string;
  /**
   * @remarks
   * The details of the zone.
   */
  zoneInfoShrink?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      chargeType: 'ChargeType',
      clbNetworkType: 'ClbNetworkType',
      enableHardwareAcceleration: 'EnableHardwareAcceleration',
      enableSls: 'EnableSls',
      enableXtrace: 'EnableXtrace',
      enterpriseSecurityGroup: 'EnterpriseSecurityGroup',
      internetSlbSpec: 'InternetSlbSpec',
      mserVersion: 'MserVersion',
      name: 'Name',
      nlbNetworkType: 'NlbNetworkType',
      region: 'Region',
      replica: 'Replica',
      requestPars: 'RequestPars',
      resourceGroupId: 'ResourceGroupId',
      slbSpec: 'SlbSpec',
      spec: 'Spec',
      tag: 'Tag',
      vSwitchId: 'VSwitchId',
      vSwitchId2: 'VSwitchId2',
      vpc: 'Vpc',
      xtraceRatio: 'XtraceRatio',
      zoneInfoShrink: 'ZoneInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      chargeType: 'string',
      clbNetworkType: 'string',
      enableHardwareAcceleration: 'boolean',
      enableSls: 'boolean',
      enableXtrace: 'boolean',
      enterpriseSecurityGroup: 'boolean',
      internetSlbSpec: 'string',
      mserVersion: 'string',
      name: 'string',
      nlbNetworkType: 'string',
      region: 'string',
      replica: 'number',
      requestPars: 'string',
      resourceGroupId: 'string',
      slbSpec: 'string',
      spec: 'string',
      tag: { 'type': 'array', 'itemType': AddGatewayShrinkRequestTag },
      vSwitchId: 'string',
      vSwitchId2: 'string',
      vpc: 'string',
      xtraceRatio: 'string',
      zoneInfoShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   */
  data?: AddGatewayResponseBodyData;
  /**
   * @remarks
   * The message returned.
   * 
   * *   If the request is successful, a success message is returned.
   * *   If the request fails, an error message is returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request is successfully processed.
   * 
   * @example
   * The return value.
   */
  message?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 2F46B9E7-67EF-5C8A-BA52-D38D5B32AF2C
   */
  requestId?: string;
  /**
   * @remarks
   * The returned data.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: AddGatewayResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddGatewayResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddGatewayResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayAuthRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  authResourceConfig?: string;
  /**
   * @remarks
   * The information about the resource to be authorized.
   */
  authResourceList?: AddGatewayAuthRequestAuthResourceList[];
  /**
   * @example
   * 1
   */
  authResourceMode?: number;
  /**
   * @remarks
   * The application ID registered with the OIDC authentication service.
   * 
   * @example
   * 23460e2fdd9bf9ad106****
   */
  clientId?: string;
  /**
   * @remarks
   * The application secret registered with the OIDC authentication service.
   * 
   * @example
   * 123****
   */
  clientSecret?: string;
  /**
   * @remarks
   * The domain name of the cookie. After the authentication is passed, the cookie is sent to the specified domain name to maintain the logon status. For example, if you set `Cookie-domain` to a.example.com, the cookie is sent to the domain name `a.example.com`. If you set `Cookie-domain` to .example.com, the cookie is sent to all subdomains of `example.com`.
   * 
   * @example
   * test.com
   */
  cookieDomain?: string;
  /**
   * @remarks
   * The information about the custom authentication service.
   */
  externalAuthZJSON?: AddGatewayAuthRequestExternalAuthZJSON;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-492af9b04bb4474cae9d645be850e3d7
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * Specifies whether to enable the whitelist feature.
   * 
   * @example
   * true
   */
  isWhite?: boolean;
  /**
   * @remarks
   * The iss value of JWT claims, which indicates the issuer. You must make sure that the value of this parameter is the same as the iss value in the payload of JWT claims.
   * 
   * @example
   * testing@secure.istio.io
   */
  issuer?: string;
  /**
   * @remarks
   * The JWT public key. The JSON format is supported.
   * 
   * @example
   * {"keys":[{"e":"AQAB","kid":"DHFbpoIUqrY8t2zpA2qXfCmr5VO5ZEr4RzHU_-envvQ","kty":"RSA","n":"xAE7eB6qugXyCAG3yhh7pkDkT65pHymX-P7KfIupjf59vsdo91bSP9C8H07pSAGQO1MV_xFj9VswgsCg4R6otmg5PV2He95lZdHtOcU5DXIg_pbhLdKXbi66GlVeK6ABZOUW3WYtnNHD-91gVuoeJT_DwtGGcp4ignkgXfkiEm4sw-4sfb4qdt5oLbyVpmW6x9cfa7vs2WTfURiCrBoUqgBo_-4WTiULmmHSGZHOjzwa8WtrtOQGsAFjIbno85jp6MnGGGZPYZbDAa_b3y5u-YpW7ypZrvD8BgtKVjgtQgZhLAGezMt0ua3DRrWnKqTZ0BJ_EyxOGuHJrLsn00fnMQ"}]}
   */
  jwks?: string;
  /**
   * @remarks
   * The URL that is used to log on to the IDaaS instance.
   * 
   * @example
   * ***
   */
  loginUrl?: string;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * jwt
   */
  name?: string;
  /**
   * @remarks
   * The redirect URL.
   * 
   * @example
   * https://test-.com/oauth2/callback
   */
  redirectUrl?: string;
  /**
   * @remarks
   * The OIDC scope.
   */
  scopesList?: string[];
  /**
   * @remarks
   * The status.
   * 
   * @example
   * true
   */
  status?: boolean;
  /**
   * @remarks
   * The sub value of JWT claims, which indicates the subject. You must make sure that the value of this parameter is the same as the sub value in the payload of JWT claims. If you do not set this parameter or leave it empty, the default value, which is the value of the Issuer parameter, is used.
   * 
   * @example
   * testing@secure.istio.io
   */
  sub?: string;
  /**
   * @remarks
   * The name of the parameter that is required to verify a token. By default, a token is prefixed with Bearer and stored in the authorization header. Example: `Authorization: Bearer token`.
   * 
   * @example
   * Authorization
   */
  tokenName?: string;
  /**
   * @remarks
   * The name prefix of the parameter that is required to verify a token. By default, a token is prefixed with Bearer and stored in the authorization header. Example: `Authorization: Bearer token`
   * 
   * @example
   * Bearer
   */
  tokenNamePrefix?: string;
  /**
   * @remarks
   * Specifies whether to enable pass-through.
   * 
   * @example
   * true
   */
  tokenPass?: boolean;
  /**
   * @remarks
   * The position of the parameter that is required to verify a token. By default, a token is prefixed with Bearer and stored in the authorization header. Example: `Authorization: Bearer token`.
   * 
   * @example
   * HEADER
   */
  tokenPosition?: string;
  /**
   * @remarks
   * The authentication type. JSON Web Token (JWT) authentication, OpenID Connect (OIDC) authentication, Identity as a Service (IDaaS) authentication, or custom authentication are supported.
   * 
   * @example
   * JWT
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      authResourceConfig: 'AuthResourceConfig',
      authResourceList: 'AuthResourceList',
      authResourceMode: 'AuthResourceMode',
      clientId: 'ClientId',
      clientSecret: 'ClientSecret',
      cookieDomain: 'CookieDomain',
      externalAuthZJSON: 'ExternalAuthZJSON',
      gatewayUniqueId: 'GatewayUniqueId',
      isWhite: 'IsWhite',
      issuer: 'Issuer',
      jwks: 'Jwks',
      loginUrl: 'LoginUrl',
      name: 'Name',
      redirectUrl: 'RedirectUrl',
      scopesList: 'ScopesList',
      status: 'Status',
      sub: 'Sub',
      tokenName: 'TokenName',
      tokenNamePrefix: 'TokenNamePrefix',
      tokenPass: 'TokenPass',
      tokenPosition: 'TokenPosition',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      authResourceConfig: 'string',
      authResourceList: { 'type': 'array', 'itemType': AddGatewayAuthRequestAuthResourceList },
      authResourceMode: 'number',
      clientId: 'string',
      clientSecret: 'string',
      cookieDomain: 'string',
      externalAuthZJSON: AddGatewayAuthRequestExternalAuthZJSON,
      gatewayUniqueId: 'string',
      isWhite: 'boolean',
      issuer: 'string',
      jwks: 'string',
      loginUrl: 'string',
      name: 'string',
      redirectUrl: 'string',
      scopesList: { 'type': 'array', 'itemType': 'string' },
      status: 'boolean',
      sub: 'string',
      tokenName: 'string',
      tokenNamePrefix: 'string',
      tokenPass: 'boolean',
      tokenPosition: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayAuthShrinkRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  authResourceConfig?: string;
  /**
   * @remarks
   * The information about the resource to be authorized.
   */
  authResourceListShrink?: string;
  /**
   * @example
   * 1
   */
  authResourceMode?: number;
  /**
   * @remarks
   * The application ID registered with the OIDC authentication service.
   * 
   * @example
   * 23460e2fdd9bf9ad106****
   */
  clientId?: string;
  /**
   * @remarks
   * The application secret registered with the OIDC authentication service.
   * 
   * @example
   * 123****
   */
  clientSecret?: string;
  /**
   * @remarks
   * The domain name of the cookie. After the authentication is passed, the cookie is sent to the specified domain name to maintain the logon status. For example, if you set `Cookie-domain` to a.example.com, the cookie is sent to the domain name `a.example.com`. If you set `Cookie-domain` to .example.com, the cookie is sent to all subdomains of `example.com`.
   * 
   * @example
   * test.com
   */
  cookieDomain?: string;
  /**
   * @remarks
   * The information about the custom authentication service.
   */
  externalAuthZJSONShrink?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-492af9b04bb4474cae9d645be850e3d7
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * Specifies whether to enable the whitelist feature.
   * 
   * @example
   * true
   */
  isWhite?: boolean;
  /**
   * @remarks
   * The iss value of JWT claims, which indicates the issuer. You must make sure that the value of this parameter is the same as the iss value in the payload of JWT claims.
   * 
   * @example
   * testing@secure.istio.io
   */
  issuer?: string;
  /**
   * @remarks
   * The JWT public key. The JSON format is supported.
   * 
   * @example
   * {"keys":[{"e":"AQAB","kid":"DHFbpoIUqrY8t2zpA2qXfCmr5VO5ZEr4RzHU_-envvQ","kty":"RSA","n":"xAE7eB6qugXyCAG3yhh7pkDkT65pHymX-P7KfIupjf59vsdo91bSP9C8H07pSAGQO1MV_xFj9VswgsCg4R6otmg5PV2He95lZdHtOcU5DXIg_pbhLdKXbi66GlVeK6ABZOUW3WYtnNHD-91gVuoeJT_DwtGGcp4ignkgXfkiEm4sw-4sfb4qdt5oLbyVpmW6x9cfa7vs2WTfURiCrBoUqgBo_-4WTiULmmHSGZHOjzwa8WtrtOQGsAFjIbno85jp6MnGGGZPYZbDAa_b3y5u-YpW7ypZrvD8BgtKVjgtQgZhLAGezMt0ua3DRrWnKqTZ0BJ_EyxOGuHJrLsn00fnMQ"}]}
   */
  jwks?: string;
  /**
   * @remarks
   * The URL that is used to log on to the IDaaS instance.
   * 
   * @example
   * ***
   */
  loginUrl?: string;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * jwt
   */
  name?: string;
  /**
   * @remarks
   * The redirect URL.
   * 
   * @example
   * https://test-.com/oauth2/callback
   */
  redirectUrl?: string;
  /**
   * @remarks
   * The OIDC scope.
   */
  scopesListShrink?: string;
  /**
   * @remarks
   * The status.
   * 
   * @example
   * true
   */
  status?: boolean;
  /**
   * @remarks
   * The sub value of JWT claims, which indicates the subject. You must make sure that the value of this parameter is the same as the sub value in the payload of JWT claims. If you do not set this parameter or leave it empty, the default value, which is the value of the Issuer parameter, is used.
   * 
   * @example
   * testing@secure.istio.io
   */
  sub?: string;
  /**
   * @remarks
   * The name of the parameter that is required to verify a token. By default, a token is prefixed with Bearer and stored in the authorization header. Example: `Authorization: Bearer token`.
   * 
   * @example
   * Authorization
   */
  tokenName?: string;
  /**
   * @remarks
   * The name prefix of the parameter that is required to verify a token. By default, a token is prefixed with Bearer and stored in the authorization header. Example: `Authorization: Bearer token`
   * 
   * @example
   * Bearer
   */
  tokenNamePrefix?: string;
  /**
   * @remarks
   * Specifies whether to enable pass-through.
   * 
   * @example
   * true
   */
  tokenPass?: boolean;
  /**
   * @remarks
   * The position of the parameter that is required to verify a token. By default, a token is prefixed with Bearer and stored in the authorization header. Example: `Authorization: Bearer token`.
   * 
   * @example
   * HEADER
   */
  tokenPosition?: string;
  /**
   * @remarks
   * The authentication type. JSON Web Token (JWT) authentication, OpenID Connect (OIDC) authentication, Identity as a Service (IDaaS) authentication, or custom authentication are supported.
   * 
   * @example
   * JWT
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      authResourceConfig: 'AuthResourceConfig',
      authResourceListShrink: 'AuthResourceList',
      authResourceMode: 'AuthResourceMode',
      clientId: 'ClientId',
      clientSecret: 'ClientSecret',
      cookieDomain: 'CookieDomain',
      externalAuthZJSONShrink: 'ExternalAuthZJSON',
      gatewayUniqueId: 'GatewayUniqueId',
      isWhite: 'IsWhite',
      issuer: 'Issuer',
      jwks: 'Jwks',
      loginUrl: 'LoginUrl',
      name: 'Name',
      redirectUrl: 'RedirectUrl',
      scopesListShrink: 'ScopesList',
      status: 'Status',
      sub: 'Sub',
      tokenName: 'TokenName',
      tokenNamePrefix: 'TokenNamePrefix',
      tokenPass: 'TokenPass',
      tokenPosition: 'TokenPosition',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      authResourceConfig: 'string',
      authResourceListShrink: 'string',
      authResourceMode: 'number',
      clientId: 'string',
      clientSecret: 'string',
      cookieDomain: 'string',
      externalAuthZJSONShrink: 'string',
      gatewayUniqueId: 'string',
      isWhite: 'boolean',
      issuer: 'string',
      jwks: 'string',
      loginUrl: 'string',
      name: 'string',
      redirectUrl: 'string',
      scopesListShrink: 'string',
      status: 'boolean',
      sub: 'string',
      tokenName: 'string',
      tokenNamePrefix: 'string',
      tokenPass: 'boolean',
      tokenPosition: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayAuthResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data returned.
   * 
   * @example
   * 3
   */
  data?: number;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4279C00F-A5E1-53C6-A43B-751C1C524D0B
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayAuthResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddGatewayAuthResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddGatewayAuthResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayAuthConsumerRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The description of the consumer.
   * 
   * @example
   * description
   */
  description?: string;
  /**
   * @remarks
   * The encryption type. Valid values:
   * 
   * *   RSA
   * *   OCT
   * 
   * @example
   * RSA
   */
  encodeType?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-c70622ff52fe49beb29bea9a6f52****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The JWT public key. The JSON format is supported.
   * 
   * @example
   * {"keys":[{"e":"AQAB","kid":"DHFbpoIUqrY8t2zpA2qXfCmr5VO5ZEr4RzHU_-envvQ","kty":"RSA","n":"xAE7eB6qugXyCAG3yhh7pkDkT65pHymX-P7KfIupjf59vsdo91bSP9C8H07pSAGQO1MV_xFj9VswgsCg4R6otmg5PV2He95lZdHtOcU5DXIg_pbhLdKXbi66GlVeK6ABZOUW3WYtnNHD-91gVuoeJT_DwtGGcp4ignkgXfkiEm4sw-4sfb4qdt5oLbyVpmW6x9cfa7vs2WTfURiCrBoUqgBo_-4WTiULmmHSGZHOjzwa8WtrtOQGsAFjIbno85jp6MnGGGZPYZbDAa_b3y5u-YpW7ypZrvD8BgtKVjgtQgZhLAGezMt0ua3DRrWnKqTZ0BJ_EyxOGuHJrLsn00fnMQ"}]}
   */
  jwks?: string;
  /**
   * @remarks
   * The name of the key used for JWT-based identity authentication.
   * 
   * @example
   * iss
   */
  keyName?: string;
  /**
   * @remarks
   * The value of the key used for JWT-based identity authentication.
   * 
   * @example
   * abcd
   */
  keyValue?: string;
  /**
   * @remarks
   * The name of the consumer.
   * 
   * This parameter is required.
   * 
   * @example
   * name
   */
  name?: string;
  /**
   * @remarks
   * The names of the parameters that are required to verify each token. By default, each token is prefixed with Bearer and stored in the Authorization header, such as `Authorization: Bearer <Content of a token>`.
   * 
   * @example
   * Authorization
   */
  tokenName?: string;
  /**
   * @remarks
   * Specifies whether to enable pass-through.
   * 
   * @example
   * true
   */
  tokenPass?: boolean;
  /**
   * @remarks
   * The positions of the parameters that are required to verify each token. By default, each token is prefixed with Bearer and stored in the Authorization header, such as `Authorization: Bearer <Content of a token>`.
   * 
   * @example
   * HEADER
   */
  tokenPosition?: string;
  /**
   * @remarks
   * The prefixes of the parameters that are required to verify each token. By default, each token is prefixed with Bearer and stored in the Authorization header, such as `Authorization: Bearer <Content of a token>`.
   * 
   * @example
   * Bearer
   */
  tokenPrefix?: string;
  /**
   * @remarks
   * The authentication type. Valid values:
   * 
   * *   JWT
   * 
   * This parameter is required.
   * 
   * @example
   * JWT
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      description: 'Description',
      encodeType: 'EncodeType',
      gatewayUniqueId: 'GatewayUniqueId',
      jwks: 'Jwks',
      keyName: 'KeyName',
      keyValue: 'KeyValue',
      name: 'Name',
      tokenName: 'TokenName',
      tokenPass: 'TokenPass',
      tokenPosition: 'TokenPosition',
      tokenPrefix: 'TokenPrefix',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      description: 'string',
      encodeType: 'string',
      gatewayUniqueId: 'string',
      jwks: 'string',
      keyName: 'string',
      keyValue: 'string',
      name: 'string',
      tokenName: 'string',
      tokenPass: 'boolean',
      tokenPosition: 'string',
      tokenPrefix: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayAuthConsumerResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. A value of 200 is returned if the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The ID of the consumer.
   * 
   * @example
   * 2
   */
  data?: number;
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the `%s` variable in the `ErrMessage` parameter.
   * 
   * >  If the return value of the `ErrMessage` parameter is `The Value of Input Parameter %s is not valid` and the return value of the `DynamicMessage` parameter is `DtsJobId`, the specified `DtsJobId` parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code that is returned.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 69AD2AA7-DB47-449B-941B-B14409DF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayAuthConsumerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddGatewayAuthConsumerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddGatewayAuthConsumerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the certificate.
   * 
   * @example
   * 6828169-cn-hangzhou
   */
  certIdentifier?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-86575c0bc9f04ecfbacb92b8e392****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * Specifies whether to enable `HTTP/2`.
   * 
   * *   `open`: enables `HTTP/2`
   * *   `close`: disables `HTTP/2`
   * *   `globalConfig`: uses global configurations
   * 
   * @example
   * close
   */
  http2?: string;
  /**
   * @remarks
   * Specifies whether to enable HTTPS.
   * 
   * @example
   * true
   */
  mustHttps?: boolean;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * test.com
   */
  name?: string;
  /**
   * @remarks
   * The type of the protocol. Valid values:
   * 
   * *   `HTTP`
   * *   `HTTPS`
   * 
   * @example
   * HTTP
   */
  protocol?: string;
  /**
   * @remarks
   * The maximum version of Transport Layer Security (TLS).
   * 
   * @example
   * TLS 1.3
   */
  tlsMax?: string;
  /**
   * @remarks
   * The minimum version of TLS.
   * 
   * @example
   * TLS 1.0
   */
  tlsMin?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      certIdentifier: 'CertIdentifier',
      gatewayUniqueId: 'GatewayUniqueId',
      http2: 'Http2',
      mustHttps: 'MustHttps',
      name: 'Name',
      protocol: 'Protocol',
      tlsMax: 'TlsMax',
      tlsMin: 'TlsMin',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      certIdentifier: 'string',
      gatewayUniqueId: 'string',
      http2: 'string',
      mustHttps: 'boolean',
      name: 'string',
      protocol: 'string',
      tlsMax: 'string',
      tlsMin: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   * 
   * @example
   * 100
   */
  data?: number;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 16BA802F-B848-55DF-9F57-CD71B7272D1F
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddGatewayDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddGatewayDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayRouteRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @example
   * a route for xxx
   */
  description?: string;
  /**
   * @remarks
   * The type of the destination service. Valid values:
   * 
   * *   Single
   * *   Multiple
   * *   VersionOriented
   * *   Mock
   * *   Redirect
   * 
   * @example
   * Multiple
   */
  destinationType?: string;
  /**
   * @remarks
   * The mock response configuration.
   */
  directResponseJSON?: AddGatewayRouteRequestDirectResponseJSON;
  /**
   * @remarks
   * The domain ID.
   * 
   * @example
   * 20
   */
  domainId?: number;
  /**
   * @remarks
   * The domain IDs.
   * 
   * @example
   * [0,94]
   */
  domainIdListJSON?: string;
  /**
   * @remarks
   * Specifies whether to activate Web Application Firewall (WAF).
   * 
   * @example
   * true
   */
  enableWaf?: boolean;
  /**
   * @remarks
   * Specifies whether to enable the Fallback service.
   * 
   * @example
   * true
   */
  fallback?: boolean;
  /**
   * @remarks
   * The information about the Fallback service.
   */
  fallbackServices?: AddGatewayRouteRequestFallbackServices[];
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 526
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-492af9b04bb4474cae9d645be8*****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The name of the route.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The routing policy in a JSON string.
   * 
   * @example
   * {"CORS":"{\\"allowMethods\\":\\"GET,POST,PUT,DELETE,HEAD,OPTIONS,PATCH\\",\\"allowHeaders\\":\\"*\\",\\"exposeHeaders\\":\\"*\\",\\"unitNum\\":12,\\"allowCredentials\\":true,\\"status\\":\\"off\\",\\"allowOrigins\\":\\"*\\",\\"timeUnit\\":\\"h\\"}","Timeout":"{\\"unitNum\\":10,\\"timeUnit\\":\\"s\\",\\"status\\":\\"off\\"}","Retry":"{\\"attempts\\":2,\\"retryOn\\":[\\"5xx\\"],\\"status\\":\\"off\\"}","HTTPRewrite":"{\\"pathType\\":\\"EQUAL\\",\\"path\\":\\"/o\\",\\"status\\":\\"off\\"}","Waf":"{\\"enabled\\":false}","HeaderOp":"{\\"status\\":\\"off\\",\\"headerOpItems\\":[{\\"directionType\\":\\"Request\\",\\"opType\\":\\"Add\\",\\"key\\":\\"kkk\\",\\"value\\":\\"ll\\"}]}"}
   */
  policies?: string;
  /**
   * @remarks
   * The matching rule.
   */
  predicates?: AddGatewayRouteRequestPredicates;
  /**
   * @remarks
   * The configuration of the redirection.
   */
  redirectJSON?: AddGatewayRouteRequestRedirectJSON;
  /**
   * @remarks
   * The sequence number of the route. (A small value indicates a high priority.)
   * 
   * @example
   * 1
   */
  routeOrder?: number;
  /**
   * @remarks
   * The route type. Valid values:
   * 
   * Op: Manage routes.
   * 
   * @example
   * Op
   */
  routeType?: string;
  /**
   * @remarks
   * The list of services.
   */
  services?: AddGatewayRouteRequestServices[];
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      description: 'Description',
      destinationType: 'DestinationType',
      directResponseJSON: 'DirectResponseJSON',
      domainId: 'DomainId',
      domainIdListJSON: 'DomainIdListJSON',
      enableWaf: 'EnableWaf',
      fallback: 'Fallback',
      fallbackServices: 'FallbackServices',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      name: 'Name',
      policies: 'Policies',
      predicates: 'Predicates',
      redirectJSON: 'RedirectJSON',
      routeOrder: 'RouteOrder',
      routeType: 'RouteType',
      services: 'Services',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      description: 'string',
      destinationType: 'string',
      directResponseJSON: AddGatewayRouteRequestDirectResponseJSON,
      domainId: 'number',
      domainIdListJSON: 'string',
      enableWaf: 'boolean',
      fallback: 'boolean',
      fallbackServices: { 'type': 'array', 'itemType': AddGatewayRouteRequestFallbackServices },
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      name: 'string',
      policies: 'string',
      predicates: AddGatewayRouteRequestPredicates,
      redirectJSON: AddGatewayRouteRequestRedirectJSON,
      routeOrder: 'number',
      routeType: 'string',
      services: { 'type': 'array', 'itemType': AddGatewayRouteRequestServices },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayRouteShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @example
   * a route for xxx
   */
  description?: string;
  /**
   * @remarks
   * The type of the destination service. Valid values:
   * 
   * *   Single
   * *   Multiple
   * *   VersionOriented
   * *   Mock
   * *   Redirect
   * 
   * @example
   * Multiple
   */
  destinationType?: string;
  /**
   * @remarks
   * The mock response configuration.
   */
  directResponseJSONShrink?: string;
  /**
   * @remarks
   * The domain ID.
   * 
   * @example
   * 20
   */
  domainId?: number;
  /**
   * @remarks
   * The domain IDs.
   * 
   * @example
   * [0,94]
   */
  domainIdListJSON?: string;
  /**
   * @remarks
   * Specifies whether to activate Web Application Firewall (WAF).
   * 
   * @example
   * true
   */
  enableWaf?: boolean;
  /**
   * @remarks
   * Specifies whether to enable the Fallback service.
   * 
   * @example
   * true
   */
  fallback?: boolean;
  /**
   * @remarks
   * The information about the Fallback service.
   */
  fallbackServicesShrink?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 526
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-492af9b04bb4474cae9d645be8*****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The name of the route.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The routing policy in a JSON string.
   * 
   * @example
   * {"CORS":"{\\"allowMethods\\":\\"GET,POST,PUT,DELETE,HEAD,OPTIONS,PATCH\\",\\"allowHeaders\\":\\"*\\",\\"exposeHeaders\\":\\"*\\",\\"unitNum\\":12,\\"allowCredentials\\":true,\\"status\\":\\"off\\",\\"allowOrigins\\":\\"*\\",\\"timeUnit\\":\\"h\\"}","Timeout":"{\\"unitNum\\":10,\\"timeUnit\\":\\"s\\",\\"status\\":\\"off\\"}","Retry":"{\\"attempts\\":2,\\"retryOn\\":[\\"5xx\\"],\\"status\\":\\"off\\"}","HTTPRewrite":"{\\"pathType\\":\\"EQUAL\\",\\"path\\":\\"/o\\",\\"status\\":\\"off\\"}","Waf":"{\\"enabled\\":false}","HeaderOp":"{\\"status\\":\\"off\\",\\"headerOpItems\\":[{\\"directionType\\":\\"Request\\",\\"opType\\":\\"Add\\",\\"key\\":\\"kkk\\",\\"value\\":\\"ll\\"}]}"}
   */
  policies?: string;
  /**
   * @remarks
   * The matching rule.
   */
  predicatesShrink?: string;
  /**
   * @remarks
   * The configuration of the redirection.
   */
  redirectJSONShrink?: string;
  /**
   * @remarks
   * The sequence number of the route. (A small value indicates a high priority.)
   * 
   * @example
   * 1
   */
  routeOrder?: number;
  /**
   * @remarks
   * The route type. Valid values:
   * 
   * Op: Manage routes.
   * 
   * @example
   * Op
   */
  routeType?: string;
  /**
   * @remarks
   * The list of services.
   */
  servicesShrink?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      description: 'Description',
      destinationType: 'DestinationType',
      directResponseJSONShrink: 'DirectResponseJSON',
      domainId: 'DomainId',
      domainIdListJSON: 'DomainIdListJSON',
      enableWaf: 'EnableWaf',
      fallback: 'Fallback',
      fallbackServicesShrink: 'FallbackServices',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      name: 'Name',
      policies: 'Policies',
      predicatesShrink: 'Predicates',
      redirectJSONShrink: 'RedirectJSON',
      routeOrder: 'RouteOrder',
      routeType: 'RouteType',
      servicesShrink: 'Services',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      description: 'string',
      destinationType: 'string',
      directResponseJSONShrink: 'string',
      domainId: 'number',
      domainIdListJSON: 'string',
      enableWaf: 'boolean',
      fallback: 'boolean',
      fallbackServicesShrink: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      name: 'string',
      policies: 'string',
      predicatesShrink: 'string',
      redirectJSONShrink: 'string',
      routeOrder: 'number',
      routeType: 'string',
      servicesShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayRouteResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The ID of the created route.
   * 
   * @example
   * 555
   */
  data?: number;
  /**
   * @remarks
   * The error code that is returned.
   * 
   * *   InvalidParameter: The parameter is invalid. For example, the parameter is incomplete or the parameter format is invalid.
   * *   IllegalRequest: The request is invalid. Unauthorized access to data initiated by parameters is identified.
   * *   NoPermission: You are not authorized to perform this operation.
   * *   NotFound: The resource does not exist and error 404 is returned.
   * *   InternalError: An internal error occurred.
   * 
   * @example
   * InvalidParameter
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 03A3E2F4-6804-5663-9D5D-2EC47A1*****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayRouteResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddGatewayRouteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddGatewayRouteResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayServiceVersionRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-913a49bab6c5461187a3305fb8da****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the service.
   * 
   * @example
   * 33
   */
  serviceId?: number;
  /**
   * @remarks
   * The version of the service.
   * 
   * @example
   * {\\"name\\":\\"v1\\",\\"labels\\":[{\\"key\\":\\"version\\",\\"value\\":\\"v1\\"}]}
   */
  serviceVersion?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      serviceId: 'ServiceId',
      serviceVersion: 'ServiceVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      serviceId: 'number',
      serviceVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayServiceVersionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned. The value 200 indicates that the request is successfully processed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The ID of the gateway service.
   * 
   * @example
   * 330
   */
  data?: number;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 403
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * BA4046B6-CFC6-583C-B608-DD75011A590F
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayServiceVersionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddGatewayServiceVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddGatewayServiceVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewaySlbRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-9cdcf8e4f58144059e73ff4c5ef9****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The HTTP port number (virtual service group).
   * 
   * @example
   * 80
   */
  httpPort?: number;
  /**
   * @remarks
   * The HTTPS port number (virtual service group).
   * 
   * @example
   * 443
   */
  httpsPort?: number;
  /**
   * @remarks
   * The ID of the HTTPS virtual service group.
   * 
   * @example
   * 353
   */
  httpsVServerGroupId?: string;
  /**
   * @remarks
   * The service weight.
   * 
   * @example
   * 80
   */
  serviceWeight?: number;
  /**
   * @remarks
   * The ID of the SLB instance.
   * 
   * This parameter is required.
   * 
   * @example
   * lb-bp18t6jjskwxh6wy1****
   */
  slbId?: string;
  /**
   * @remarks
   * The type of the service source. Valid values:
   * 
   * *   PUB_NET: Internet
   * *   PRIVATE_NET: VPC
   * 
   * @example
   * PUB_NET
   */
  type?: string;
  /**
   * @remarks
   * The ID of the HTTP virtual service group.
   * 
   * @example
   * 353
   */
  VServerGroupId?: string;
  /**
   * @remarks
   * The SLB monitoring information.
   */
  VServiceList?: AddGatewaySlbRequestVServiceList[];
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      httpPort: 'HttpPort',
      httpsPort: 'HttpsPort',
      httpsVServerGroupId: 'HttpsVServerGroupId',
      serviceWeight: 'ServiceWeight',
      slbId: 'SlbId',
      type: 'Type',
      VServerGroupId: 'VServerGroupId',
      VServiceList: 'VServiceList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      httpPort: 'number',
      httpsPort: 'number',
      httpsVServerGroupId: 'string',
      serviceWeight: 'number',
      slbId: 'string',
      type: 'string',
      VServerGroupId: 'string',
      VServiceList: { 'type': 'array', 'itemType': AddGatewaySlbRequestVServiceList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewaySlbShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-9cdcf8e4f58144059e73ff4c5ef9****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The HTTP port number (virtual service group).
   * 
   * @example
   * 80
   */
  httpPort?: number;
  /**
   * @remarks
   * The HTTPS port number (virtual service group).
   * 
   * @example
   * 443
   */
  httpsPort?: number;
  /**
   * @remarks
   * The ID of the HTTPS virtual service group.
   * 
   * @example
   * 353
   */
  httpsVServerGroupId?: string;
  /**
   * @remarks
   * The service weight.
   * 
   * @example
   * 80
   */
  serviceWeight?: number;
  /**
   * @remarks
   * The ID of the SLB instance.
   * 
   * This parameter is required.
   * 
   * @example
   * lb-bp18t6jjskwxh6wy1****
   */
  slbId?: string;
  /**
   * @remarks
   * The type of the service source. Valid values:
   * 
   * *   PUB_NET: Internet
   * *   PRIVATE_NET: VPC
   * 
   * @example
   * PUB_NET
   */
  type?: string;
  /**
   * @remarks
   * The ID of the HTTP virtual service group.
   * 
   * @example
   * 353
   */
  VServerGroupId?: string;
  /**
   * @remarks
   * The SLB monitoring information.
   */
  VServiceListShrink?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      httpPort: 'HttpPort',
      httpsPort: 'HttpsPort',
      httpsVServerGroupId: 'HttpsVServerGroupId',
      serviceWeight: 'ServiceWeight',
      slbId: 'SlbId',
      type: 'Type',
      VServerGroupId: 'VServerGroupId',
      VServiceListShrink: 'VServiceList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      httpPort: 'number',
      httpsPort: 'number',
      httpsVServerGroupId: 'string',
      serviceWeight: 'number',
      slbId: 'string',
      type: 'string',
      VServerGroupId: 'string',
      VServiceListShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewaySlbResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data returned.
   * 
   * @example
   * lb-uf6dqr4ondqi5w3df7hdf
   */
  data?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * *   If the request is successful, a success message is returned.
   * *   If the request fails, an error message is returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 316F5F64-F73D-42DC-8632-01E308B6****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewaySlbResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddGatewaySlbResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddGatewaySlbResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMigrationTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The type of the instance. Valid values:
   * 
   * *   Nacos-Ans
   * *   ZooKeeper
   * *   Eureka
   * 
   * @example
   * Nacos-Ans
   */
  clusterType?: string;
  /**
   * @remarks
   * The endpoint of the source instance node.
   * 
   * @example
   * 192.168.1.1:8848
   */
  originInstanceAddress?: string;
  /**
   * @remarks
   * The name of the source instance.
   * 
   * @example
   * Source instance
   */
  originInstanceName?: string;
  /**
   * @remarks
   * The list of namespaces. This parameter is optional if you want to migrate applications from a Nacos instance.
   * 
   * @example
   * namesapceId1,namesapceId2
   */
  originInstanceNamespace?: string;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * This is a description.
   */
  projectDesc?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  syncType?: string;
  /**
   * @remarks
   * The name of the destination instance.
   * 
   * @example
   * Destination instance
   */
  targetClusterName?: string;
  /**
   * @remarks
   * The URL of the destination instance.
   * 
   * @example
   * mse-66*****-nacos-ans.mse.aliyuncs.com:8848
   */
  targetClusterUrl?: string;
  /**
   * @remarks
   * The ID of the destination instance.
   * 
   * @example
   * mse-cn-ud82*****
   */
  targetInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterType: 'ClusterType',
      originInstanceAddress: 'OriginInstanceAddress',
      originInstanceName: 'OriginInstanceName',
      originInstanceNamespace: 'OriginInstanceNamespace',
      projectDesc: 'ProjectDesc',
      requestPars: 'RequestPars',
      syncType: 'SyncType',
      targetClusterName: 'TargetClusterName',
      targetClusterUrl: 'TargetClusterUrl',
      targetInstanceId: 'TargetInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterType: 'string',
      originInstanceAddress: 'string',
      originInstanceName: 'string',
      originInstanceNamespace: 'string',
      projectDesc: 'string',
      requestPars: 'string',
      syncType: 'string',
      targetClusterName: 'string',
      targetClusterUrl: 'string',
      targetInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMigrationTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data structure.
   */
  data?: AddMigrationTaskResponseBodyData;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is processed successfully.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7466566F-F30F-4A29-965D-3E0AF21D****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: AddMigrationTaskResponseBodyData,
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMigrationTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddMigrationTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddMigrationTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMockRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the custom application.
   * 
   * This parameter is required.
   * 
   * @example
   * [{\\"appName\\":\\"provide\\",\\"appId\\":\\"bst8l6o735@f6d8aaf6e56e67d\\"}]
   */
  consumerAppIds?: string;
  /**
   * @remarks
   * The items in the recycle bin.
   * 
   * This parameter is required.
   * 
   * @example
   * []
   */
  dubboMockItems?: string;
  /**
   * @remarks
   * Specifies whether to enable the alert rule. Valid values:
   * 
   * *   `true`: enables the alert rule.
   * *   `false`: disables the alert rule.
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The description.
   * 
   * This parameter is required.
   * 
   * @example
   * {}
   */
  extraJson?: string;
  /**
   * @remarks
   * The response time (RT) threshold of slow calls. Valid values:
   * 
   * *   \\- 15: 15 ms
   * *   \\- 30: 30 ms
   * *   \\- 60: 60 ms
   * *   \\- 120: 120 ms
   * 
   * @example
   * 1
   */
  mockType?: number;
  /**
   * @remarks
   * The name of the rule.
   * 
   * This parameter is required.
   * 
   * @example
   * agent-auto-test-sc
   */
  name?: string;
  /**
   * @remarks
   * The ID of the service provider application.
   * 
   * @example
   * dcqtkuhnc4@66e5235415****
   */
  providerAppId?: string;
  /**
   * @remarks
   * The name of the service provider application.
   * 
   * @example
   * demo-cartservice
   */
  providerAppName?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The input parameters. The JSON format is supported.
   * 
   * This parameter is required.
   * 
   * @example
   * []
   */
  scMockItems?: string;
  /**
   * @remarks
   * The rule source.
   * 
   * This parameter is required.
   * 
   * @example
   * edasmsc
   */
  source?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      consumerAppIds: 'ConsumerAppIds',
      dubboMockItems: 'DubboMockItems',
      enable: 'Enable',
      extraJson: 'ExtraJson',
      mockType: 'MockType',
      name: 'Name',
      providerAppId: 'ProviderAppId',
      providerAppName: 'ProviderAppName',
      region: 'Region',
      scMockItems: 'ScMockItems',
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      consumerAppIds: 'string',
      dubboMockItems: 'string',
      enable: 'boolean',
      extraJson: 'string',
      mockType: 'number',
      name: 'string',
      providerAppId: 'string',
      providerAppName: 'string',
      region: 'string',
      scMockItems: 'string',
      source: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMockRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The details of the data.
   */
  data?: AddMockRuleResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 316F5F64-F73D-42DC-8632-01E308B6****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: AddMockRuleResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMockRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddMockRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddMockRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddSSLCertRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the certificate.
   * 
   * @example
   * 5213641-cn-hangzhou
   */
  certIdentifier?: string;
  /**
   * @remarks
   * The domain ID.
   * 
   * @example
   * 0
   */
  domainId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-c70622ff52fe49beb29bea9a6f52****
   */
  gatewayUniqueId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      certIdentifier: 'CertIdentifier',
      domainId: 'DomainId',
      gatewayUniqueId: 'GatewayUniqueId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      certIdentifier: 'string',
      domainId: 'number',
      gatewayUniqueId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddSSLCertResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the association is successful.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E1CC74F0-5BDE-5220-A031-5CA622D80723
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddSSLCertResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddSSLCertResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddSSLCertResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddSecurityGroupRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * description
   */
  description?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-c9bc5afd61014165bd58f621b491****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The range of port numbers.
   * 
   * This parameter is required.
   * 
   * @example
   * 1/65535
   */
  portRange?: string;
  /**
   * @remarks
   * The ID of the security group.
   * 
   * This parameter is required.
   * 
   * @example
   * sg-wz929kxhcdpw9z8idqd8
   */
  securityGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      description: 'Description',
      gatewayUniqueId: 'GatewayUniqueId',
      portRange: 'PortRange',
      securityGroupId: 'SecurityGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      description: 'string',
      gatewayUniqueId: 'string',
      portRange: 'string',
      securityGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddSecurityGroupRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   * 
   * @example
   * 12
   */
  data?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D0DB055C-51F2-5BB2-82A6-CD8A3C6EE6BA
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddSecurityGroupRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddSecurityGroupRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddSecurityGroupRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddServiceSourceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh-CN (default): Chinese
   * *   en-US: English
   * *   ja: Japanese
   * 
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to monitor Ingress classes.
   * 
   * @example
   * c9ad2a0717032427e920754e25b49e3b5
   */
  address?: string;
  /**
   * @remarks
   * Specifies whether to update the Ingress status.
   * 
   * @example
   * gw-c70622ff52fe49beb29bea9a6f52****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The data structure.
   */
  groupList?: string[];
  /**
   * @remarks
   * The list of service groups.
   */
  ingressOptionsRequest?: AddServiceSourceRequestIngressOptionsRequest;
  /**
   * @remarks
   * The namespace whose resources you want to monitor.
   * 
   * @example
   * istio
   */
  name?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   */
  pathList?: string[];
  /**
   * @remarks
   * The service source.
   * 
   * *   K8s: ACK cluster
   * *   NACOS: MSE Nacos instance
   * 
   * @example
   * K8s,MSE
   */
  source?: string;
  /**
   * @remarks
   * The list of security groups to be authorized. You can specify security groups to allow backend services to access data sources that you create.
   */
  toAuthorizeSecurityGroups?: AddServiceSourceRequestToAuthorizeSecurityGroups[];
  /**
   * @remarks
   * The type of the service source.
   * 
   * *   K8s: Container Service for Kubernetes (ACK) cluster
   * *   NACOS: Nacos instance
   * 
   * @example
   * The Ingress configuration.
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      address: 'Address',
      gatewayUniqueId: 'GatewayUniqueId',
      groupList: 'GroupList',
      ingressOptionsRequest: 'IngressOptionsRequest',
      name: 'Name',
      pathList: 'PathList',
      source: 'Source',
      toAuthorizeSecurityGroups: 'ToAuthorizeSecurityGroups',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      address: 'string',
      gatewayUniqueId: 'string',
      groupList: { 'type': 'array', 'itemType': 'string' },
      ingressOptionsRequest: AddServiceSourceRequestIngressOptionsRequest,
      name: 'string',
      pathList: { 'type': 'array', 'itemType': 'string' },
      source: 'string',
      toAuthorizeSecurityGroups: { 'type': 'array', 'itemType': AddServiceSourceRequestToAuthorizeSecurityGroups },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddServiceSourceShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh-CN (default): Chinese
   * *   en-US: English
   * *   ja: Japanese
   * 
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to monitor Ingress classes.
   * 
   * @example
   * c9ad2a0717032427e920754e25b49e3b5
   */
  address?: string;
  /**
   * @remarks
   * Specifies whether to update the Ingress status.
   * 
   * @example
   * gw-c70622ff52fe49beb29bea9a6f52****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The data structure.
   */
  groupListShrink?: string;
  /**
   * @remarks
   * The list of service groups.
   */
  ingressOptionsRequestShrink?: string;
  /**
   * @remarks
   * The namespace whose resources you want to monitor.
   * 
   * @example
   * istio
   */
  name?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   */
  pathListShrink?: string;
  /**
   * @remarks
   * The service source.
   * 
   * *   K8s: ACK cluster
   * *   NACOS: MSE Nacos instance
   * 
   * @example
   * K8s,MSE
   */
  source?: string;
  /**
   * @remarks
   * The list of security groups to be authorized. You can specify security groups to allow backend services to access data sources that you create.
   */
  toAuthorizeSecurityGroupsShrink?: string;
  /**
   * @remarks
   * The type of the service source.
   * 
   * *   K8s: Container Service for Kubernetes (ACK) cluster
   * *   NACOS: Nacos instance
   * 
   * @example
   * The Ingress configuration.
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      address: 'Address',
      gatewayUniqueId: 'GatewayUniqueId',
      groupListShrink: 'GroupList',
      ingressOptionsRequestShrink: 'IngressOptionsRequest',
      name: 'Name',
      pathListShrink: 'PathList',
      source: 'Source',
      toAuthorizeSecurityGroupsShrink: 'ToAuthorizeSecurityGroups',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      address: 'string',
      gatewayUniqueId: 'string',
      groupListShrink: 'string',
      ingressOptionsRequestShrink: 'string',
      name: 'string',
      pathListShrink: 'string',
      source: 'string',
      toAuthorizeSecurityGroupsShrink: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddServiceSourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * duplicatedClusterAliasName
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * mse-100-007
   * 
   * @example
   * 63
   */
  data?: number;
  /**
   * @remarks
   * code
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * mse-200-105
   * 
   * @example
   * You are not authorized to perform this operation. Action: mse:AddServiceSource, Resource: acs:mse:cn-hangzhou:1105471854403716:instance/gw-082c943a8c304e48a37a7a29a5ddeda7
   */
  message?: string;
  /**
   * @remarks
   * The response data.
   * 
   * @example
   * D0DB055C-51F2-5BB2-82A6-CD8A3C6EE6BA
   */
  requestId?: string;
  /**
   * @remarks
   * duplicated cluster alias name
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddServiceSourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddServiceSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddServiceSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyGatewayRouteRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-1a4ab101d5924b6f92c5ec98a841761f
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the route.
   * 
   * @example
   * 950
   */
  routeId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      routeId: 'RouteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      routeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyGatewayRouteResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data of the node.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 1DB1AB36-8395-540E-AACC-7571D6B2057A
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyGatewayRouteResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ApplyGatewayRouteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ApplyGatewayRouteResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyTagPoliciesRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * h5pohqu3gd@xxx
   * 
   * @deprecated
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * example-app
   */
  appName?: string;
  /**
   * @remarks
   * Specifies whether to enable the routing rule.
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The Microservices Engine (MSE) namespace to which the application belongs.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * Optional. The ID of the namespace.
   * 
   * @example
   * 12233****
   */
  namespaceId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The details of the routing rule.
   * 
   * @example
   * { "blue": { # Tag key. "rate": 20, # Rate. A value of 20 indicates that 20% of the traffic is routed to the node identified by the tag. "name": "luoye-route-test", # Routing rule name. "carryData": false, # Specifies whether to enable pass-through. This parameter is applicable to end-to-end canary release. "rules": { # Rule information. "dubbo": [{ # Dubbo rule. The system also supports Spring Cloud and Istio rule. "serviceName": "com.taobao.hsf.common.DemoService", # Service name (operation name). "group": "", # Group name. "version": "", # Service version. "methodName": "sayHello", # Method name. "condition": "AND", # Logical operator used by the following items. Valid values: AND and OR. "argumentItems": [{ # Array of rule details. "index": 0, # Index field. "expr": "", # Expression. Its details is described below. "operator": "rawvalue", # The comparison mode. A value of rawvalue indicates direct comparison. A value of mode indicates the modulo operation. A value of list indicates using a whitelist. "value": "jim", # Base value. The value obtained by the expression will be compared with this value. If operator is set to list, separate the items specified for this parameter with commas (,). Example: 1,2,3. "cond": "==" # Comparison operator. Valid values: >=, <=, >, <, and ==. }] }] } }, "_base": { # Another tag key. "rate": 80 # Rate. A value of 20 indicates that 20% of the traffic is routed to the node identified by the tag. } }
   */
  rules?: { [key: string]: RulesValue };
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      enable: 'Enable',
      namespace: 'Namespace',
      namespaceId: 'NamespaceId',
      region: 'Region',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      enable: 'boolean',
      namespace: 'string',
      namespaceId: 'string',
      region: 'string',
      rules: { 'type': 'map', 'keyType': 'string', 'valueType': RulesValue },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyTagPoliciesShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * h5pohqu3gd@xxx
   * 
   * @deprecated
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * example-app
   */
  appName?: string;
  /**
   * @remarks
   * Specifies whether to enable the routing rule.
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The Microservices Engine (MSE) namespace to which the application belongs.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * Optional. The ID of the namespace.
   * 
   * @example
   * 12233****
   */
  namespaceId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The details of the routing rule.
   * 
   * @example
   * { "blue": { # Tag key. "rate": 20, # Rate. A value of 20 indicates that 20% of the traffic is routed to the node identified by the tag. "name": "luoye-route-test", # Routing rule name. "carryData": false, # Specifies whether to enable pass-through. This parameter is applicable to end-to-end canary release. "rules": { # Rule information. "dubbo": [{ # Dubbo rule. The system also supports Spring Cloud and Istio rule. "serviceName": "com.taobao.hsf.common.DemoService", # Service name (operation name). "group": "", # Group name. "version": "", # Service version. "methodName": "sayHello", # Method name. "condition": "AND", # Logical operator used by the following items. Valid values: AND and OR. "argumentItems": [{ # Array of rule details. "index": 0, # Index field. "expr": "", # Expression. Its details is described below. "operator": "rawvalue", # The comparison mode. A value of rawvalue indicates direct comparison. A value of mode indicates the modulo operation. A value of list indicates using a whitelist. "value": "jim", # Base value. The value obtained by the expression will be compared with this value. If operator is set to list, separate the items specified for this parameter with commas (,). Example: 1,2,3. "cond": "==" # Comparison operator. Valid values: >=, <=, >, <, and ==. }] }] } }, "_base": { # Another tag key. "rate": 80 # Rate. A value of 20 indicates that 20% of the traffic is routed to the node identified by the tag. } }
   */
  rulesShrink?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      enable: 'Enable',
      namespace: 'Namespace',
      namespaceId: 'NamespaceId',
      region: 'Region',
      rulesShrink: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      enable: 'boolean',
      namespace: 'string',
      namespaceId: 'string',
      region: 'string',
      rulesShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyTagPoliciesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   */
  data?: ApplyTagPoliciesResponseBodyData[];
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 316F5F64-F73D-42DC-8632-01E308B6****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ApplyTagPoliciesResponseBodyData },
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyTagPoliciesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ApplyTagPoliciesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ApplyTagPoliciesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindSentinelBlockFallbackDefinitionRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 21
   */
  fallbackId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * prod
   */
  namespace?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * /a
   */
  resource?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1
   */
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appName: 'AppName',
      fallbackId: 'FallbackId',
      namespace: 'Namespace',
      resource: 'Resource',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appName: 'string',
      fallbackId: 'number',
      namespace: 'string',
      resource: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindSentinelBlockFallbackDefinitionResponseBody extends $tea.Model {
  /**
   * @example
   * 200
   */
  code?: number;
  /**
   * @example
   * true
   */
  data?: boolean;
  /**
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @example
   * OK
   */
  message?: string;
  /**
   * @example
   * 4E9FDCFE-0738-493B-B801-82BDFBCB****
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindSentinelBlockFallbackDefinitionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BindSentinelBlockFallbackDefinitionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BindSentinelBlockFallbackDefinitionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeResourceGroupRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * rg-acfm34x43l*****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * mse-cn-xxxxxxxxxxx，
   * gw-xxxxxxxxxxxxxxxxxxxx
   */
  resourceId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  resourceRegionId?: string;
  /**
   * @example
   * Cluster,Gateway
   */
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      resourceGroupId: 'ResourceGroupId',
      resourceId: 'ResourceId',
      resourceRegionId: 'ResourceRegionId',
      resourceType: 'ResourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      resourceGroupId: 'string',
      resourceId: 'string',
      resourceRegionId: 'string',
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeResourceGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 54973C90-F379-4372-9AA5-053A3F7****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeResourceGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ChangeResourceGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ChangeResourceGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloneNacosConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The configuration items that you want to clone. The value of this parameter is the combination of the values of the dataId and group parameters. Separate multiple configuration items with commas (,).
   */
  dataIds?: string;
  /**
   * @remarks
   * The list of configuration IDs.
   * 
   * @example
   * 253661,253662
   * 
   * @deprecated
   */
  ids?: string;
  /**
   * @remarks
   * The ID of the destination namespace.
   * 
   * This parameter is required.
   * 
   * @example
   * mse_prepaid_public_cn-i7m25igg403
   */
  instanceId?: string;
  /**
   * @remarks
   * The policy used when a write conflict occurs.
   * 
   * *   ABORT
   * *   SKIP
   * *   OVERWRITE
   * 
   * @example
   * be821963-6d48-4ea5-9910-6057d****
   */
  originNamespaceId?: string;
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * This parameter is required.
   * 
   * @example
   * OVERWRITE
   */
  policy?: string;
  /**
   * @remarks
   * The IDs of configurations.
   * 
   * @example
   * 08be4b5d-2d1c-4e6e-aa85-83b9****
   */
  targetNamespaceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      dataIds: 'DataIds',
      ids: 'Ids',
      instanceId: 'InstanceId',
      originNamespaceId: 'OriginNamespaceId',
      policy: 'Policy',
      targetNamespaceId: 'TargetNamespaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      dataIds: 'string',
      ids: 'string',
      instanceId: 'string',
      originNamespaceId: 'string',
      policy: 'string',
      targetNamespaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloneNacosConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the \\*\\*%s\\*\\* variable in the **ErrMessage** parameter.
   * 
   * >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data returned.
   */
  data?: CloneNacosConfigResponseBodyData;
  /**
   * @remarks
   * The number of successful operations.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The details of the data.
   * 
   * @example
   * Clone Completed Successfully
   */
  message?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * 6678DBA9-5600-5948-ACF8-ED3105B288A3
   */
  requestId?: string;
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: CloneNacosConfigResponseBodyData,
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloneNacosConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CloneNacosConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CloneNacosConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloneSentinelRuleFromAhasRequest extends $tea.Model {
  /**
   * @remarks
   * The language in which you want to display the results. Valid values: zh and en. zh indicates Chinese, which is the default value. en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The namespace (environment) of Application High Availability Service (AHAS).
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  ahasNamespace?: string;
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * Specifies whether AHAS is deployed in the Internet region.
   * 
   * @example
   * false
   */
  isAHASPublicRegion?: boolean;
  /**
   * @remarks
   * The namespace.
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      ahasNamespace: 'AhasNamespace',
      appName: 'AppName',
      isAHASPublicRegion: 'IsAHASPublicRegion',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      ahasNamespace: 'string',
      appName: 'string',
      isAHASPublicRegion: 'boolean',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloneSentinelRuleFromAhasResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data.
   */
  data?: { [key: string]: string[] };
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE5C32A1-BC0E-4B79-817C-103E4EDF****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': 'string' } },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloneSentinelRuleFromAhasResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CloneSentinelRuleFromAhasResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CloneSentinelRuleFromAhasResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateApplicationRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * The programming language of the application.
   * 
   * @example
   * JAVA
   */
  language?: string;
  /**
   * @remarks
   * MSE命名空间名字。
   * 
   * @example
   * prod
   */
  namespace?: string;
  /**
   * @remarks
   * The region to which the application belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * Specifies whether to start the switch.
   * 
   * @example
   * true
   */
  sentinelEnable?: string;
  /**
   * @remarks
   * The service where the application is deployed. A value of ACK indicates Container Service for Kubernetes.
   * 
   * @example
   * ACK
   */
  source?: string;
  /**
   * @remarks
   * The name of the Microservices Engine (MSE) namespace.
   * 
   * @example
   * true
   */
  switchEnable?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appName: 'AppName',
      language: 'Language',
      namespace: 'Namespace',
      region: 'Region',
      sentinelEnable: 'SentinelEnable',
      source: 'Source',
      switchEnable: 'SwitchEnable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appName: 'string',
      language: 'string',
      namespace: 'string',
      region: 'string',
      sentinelEnable: 'string',
      source: 'string',
      switchEnable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateApplicationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data of the node.
   * 
   * @example
   * data
   */
  data?: CreateApplicationResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 68D91223-CCE9-5F9C-B538-20F617DA48B1
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: CreateApplicationResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateApplicationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateApplicationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateApplicationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCircuitBreakerRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the application.
   * 
   * @example
   * hkhon1po62@c3df23522bXXXXX
   */
  appId?: string;
  /**
   * @remarks
   * The application name.
   * 
   * This parameter is required.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * Specifies whether to enable the rule.
   * 
   * Valid values:
   * 
   * *   true
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   false
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The minimum number of requests that can be passed in each step after circuit breaking recovers. Default value: 1.
   * 
   * @example
   * 5
   */
  halfOpenBaseAmountPerStep?: number;
  /**
   * @remarks
   * The number of circuit breaking recovery steps. Default value: 1.
   * 
   * @example
   * 1
   */
  halfOpenRecoveryStepNum?: number;
  /**
   * @remarks
   * The maximum response time (RT). Unit: milliseconds. If the RT of a request is greater than the value of this parameter, a slow call is counted. If you set Strategy to 0, you must specify this parameter.
   * 
   * @example
   * 200
   */
  maxAllowedRtMs?: number;
  /**
   * @remarks
   * The minimum number of requests to trigger circuit breaking. If the number of requests in the current time window is less than the value of this parameter, circuit breaking is not triggered even if the circuit breaking rule is met. Default value: 10.
   * 
   * @example
   * 10
   */
  minRequestAmount?: number;
  /**
   * @remarks
   * The microservice namespace to which the application belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The region in which the instance resides.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the interface to which the rule applies. The interface name must be the same as the name on the interface details page in the console.
   * 
   * This parameter is required.
   * 
   * @example
   * /a
   */
  resource?: string;
  /**
   * @remarks
   * The resource type.
   * 
   * Valid values:
   * 
   * *   0: custom interface
   * *   1: web
   * *   2: RPC
   * *   3: route
   * *   4: SQL
   * 
   * @example
   * 0
   */
  resourceType?: number;
  /**
   * @remarks
   * The period in which circuit breaking is implemented. Unit: milliseconds. If circuit breaking is implemented on the requests for the route, the calls to all the requests for the route fail in the configured circuit breaking period. The value must be an integral multiple of 1,000. Default value: 10000. This value indicates 10 seconds.
   * 
   * @example
   * 10000
   */
  retryTimeoutMs?: number;
  /**
   * @remarks
   * The length of the time window. Unit: milliseconds. The valid range is from 1 second to 120 minutes. The default value is 20000. This value indicates 20 seconds.
   * 
   * @example
   * 20000
   */
  statIntervalMs?: number;
  /**
   * @remarks
   * The threshold type.
   * 
   * Valid values:
   * 
   * *   0
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     slow call proportion
   * 
   *     <!-- -->
   * 
   * *   1
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     abnormal proportion
   * 
   *     <!-- -->
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  strategy?: number;
  /**
   * @remarks
   * A percentage threshold for triggering circuit breaking. Valid values: 0-1. These values represent 0% to 100%.
   * 
   * This parameter is required.
   * 
   * @example
   * 0.8
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      enable: 'Enable',
      halfOpenBaseAmountPerStep: 'HalfOpenBaseAmountPerStep',
      halfOpenRecoveryStepNum: 'HalfOpenRecoveryStepNum',
      maxAllowedRtMs: 'MaxAllowedRtMs',
      minRequestAmount: 'MinRequestAmount',
      namespace: 'Namespace',
      regionId: 'RegionId',
      resource: 'Resource',
      resourceType: 'ResourceType',
      retryTimeoutMs: 'RetryTimeoutMs',
      statIntervalMs: 'StatIntervalMs',
      strategy: 'Strategy',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      enable: 'boolean',
      halfOpenBaseAmountPerStep: 'number',
      halfOpenRecoveryStepNum: 'number',
      maxAllowedRtMs: 'number',
      minRequestAmount: 'number',
      namespace: 'string',
      regionId: 'string',
      resource: 'string',
      resourceType: 'number',
      retryTimeoutMs: 'number',
      statIntervalMs: 'number',
      strategy: 'number',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCircuitBreakerRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The details of the rule.
   */
  data?: CreateCircuitBreakerRuleResponseBodyData;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * OK
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE5C32A1-BC0E-4B79-817C-103E4EDF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * Valid values:
   * 
   * *   true
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   false
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateCircuitBreakerRuleResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCircuitBreakerRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateCircuitBreakerRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCircuitBreakerRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The billing method. Valid values: PREPAY and POSTPAY.
   * 
   * Ignore this parameter for serverless instances.
   * 
   * @example
   * POSTPAY
   */
  chargeType?: string;
  /**
   * @remarks
   * The engine specifications. Valid values:
   * 
   * [Professional Edition]
   * 
   * *   `MSE_SC_2_4_60_c`: 2 vCPUs and 4 GB of memory
   * *   `MSE_SC_1_2_60_c`: 1 vCPU and 2 GB of memory
   * *   `MSE_SC_4_8_60_c`: 4 vCPUs and 8 GB of memory
   * *   `MSE_SC_8_16_60_c`: 8 vCPUs and 16 GB of memory
   * *   `MSE_SC_16_32_60_c`: 16 vCPUs and 32 GB of memory
   * 
   * [Developer Edition]
   * 
   * *   `MSE_SC_1_2_60_c`: 1 vCPU and 2 GB of memory
   * *   `MSE_SC_2_4_60_c`: 2 vCPUs and 4 GB of memory
   * 
   * [Serverless Edition]
   * 
   * Ignore this parameter or set this parameter to `MSE_SC_SERVERLESS`.
   * 
   * This parameter is required.
   * 
   * @example
   * MSE_SC_2_4_60_c
   */
  clusterSpecification?: string;
  /**
   * @remarks
   * The type of the instance. Valid values: ZooKeeper and Nacos-Ans.
   * 
   * This parameter is required.
   * 
   * @example
   * Nacos-Ans
   */
  clusterType?: string;
  /**
   * @remarks
   * The engine version of the instance. Valid values:
   * 
   * [Professional Edition]
   * 
   * *   `NACOS_2_0_0`
   * *   `ZooKeeper_3_8_0`
   * 
   * [Developer Edition]
   * 
   * *   `NACOS_2_0_0`
   * *   `ZooKeeper_3_8_0`
   * 
   * [Serverless Edition]
   * 
   * *   `NACOS_2_0_0`
   * *   `ZooKeeper_3_8_0`
   * 
   * This parameter is required.
   * 
   * @example
   * NACOS_2_0_0
   */
  clusterVersion?: string;
  /**
   * @remarks
   * The network connection type. Valid values: `slb` or `single_eni`. For instances of the Developer Edition in some regions, only the value `single_eni` is supported.
   * 
   * @example
   * slb
   */
  connectionType?: string;
  /**
   * @remarks
   * This parameter is obsolete.
   * 
   * @example
   * alicloud-disk-ssd
   * 
   * @deprecated
   */
  diskType?: string;
  /**
   * @remarks
   * Specifies whether to enable Internet access (Elastic IP Address) if ConnectionType is set to `single_eni`.
   * 
   * Valid values:
   * 
   * *   true
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   false
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * **if can be null:**
   * false
   */
  eipEnabled?: boolean;
  /**
   * @remarks
   * The number of nodes in the instance. Valid values: 1 to 9.
   * 
   * [Professional Edition]
   * 
   * *   The value must be greater than or equal to 3 and must be an odd number.
   * 
   * [Developer Edition]
   * 
   * *   The value must be 1.
   * 
   * [Serverless Edition]
   * 
   * Ignore this parameter.
   * 
   * This parameter is required.
   * 
   * @example
   * 3
   */
  instanceCount?: number;
  /**
   * @remarks
   * The custom name of the instance.
   * 
   * @example
   * tanshuyingtest001
   */
  instanceName?: string;
  /**
   * @remarks
   * Configure this parameter unless otherwise specified. Valid values:
   * 
   * *   `mse_pro`: Professional Edition
   * *   `mse_dev`: Developer Edition
   * *   `mse_dev`: Serverless Edition
   * 
   * @example
   * mse_pro
   */
  mseVersion?: string;
  /**
   * @remarks
   * The network type of the MSE instance. Valid values:
   * 
   * *   `privatenet`: VPC
   * *   `pubnet`: Internet
   * 
   * This parameter is required.
   * 
   * @example
   * privatenet
   */
  netType?: string;
  /**
   * @remarks
   * This parameter is obsolete.
   * 
   * @example
   * slb.s1.small
   * 
   * @deprecated
   */
  privateSlbSpecification?: string;
  /**
   * @remarks
   * This parameter is valid only if the ConnectionType parameter is set to `slb`. The value 0 indicates that the Server Load Balancer (SLB) instance is not connected over the Internet. A value greater than 1 indicates the fixed bandwidth that is used to access the SLB instance over the Internet. Unit: Mbit/s.
   * 
   * Valid values: 0 to 5000.
   * 
   * @example
   * 0
   */
  pubNetworkFlow?: string;
  /**
   * @remarks
   * This parameter is obsolete.
   * 
   * @example
   * slb.s1.small
   * 
   * @deprecated
   */
  pubSlbSpecification?: string;
  /**
   * @remarks
   * The region where the instance resides. Examples:
   * 
   * *   `cn-hangzhou`: China (Hangzhou)
   * *   `cn-beijing`: China (Beijing)
   * *   `cn-shanghai`: China (Shanghai)
   * *   `cn-zhangjiakou`: China (Zhangjiakou)
   * *   `cn-shenzhen`: China (Shenzhen)
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  /**
   * @remarks
   * The ID of the resource group. For the details of resource groups, see [View basic information of a resource group](https://help.aliyun.com/document_detail/457230.html).
   * 
   * @example
   * rg-aekzcqmoay3dlyq
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The type of the security group to which the instance belongs. This parameter is valid only if the ConnectionType parameter is set to `single_eni`.
   * 
   * Valid values:
   * 
   * *   enterprise
   * *   normal
   * 
   * @example
   * enterprise
   */
  securityGroupType?: string;
  /**
   * @remarks
   * The tags to add to the resource. You can specify up to 20 tags.
   */
  tag?: CreateClusterRequestTag[];
  /**
   * @remarks
   * The ID of the vSwitch.
   * 
   * @example
   * vsw-bp17opt4v18sto39k****
   */
  vSwitchId?: string;
  /**
   * @remarks
   * The ID of the virtual private cloud (VPC).
   * 
   * @example
   * vpc-bp1t50e045b5g7i3p****
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      chargeType: 'ChargeType',
      clusterSpecification: 'ClusterSpecification',
      clusterType: 'ClusterType',
      clusterVersion: 'ClusterVersion',
      connectionType: 'ConnectionType',
      diskType: 'DiskType',
      eipEnabled: 'EipEnabled',
      instanceCount: 'InstanceCount',
      instanceName: 'InstanceName',
      mseVersion: 'MseVersion',
      netType: 'NetType',
      privateSlbSpecification: 'PrivateSlbSpecification',
      pubNetworkFlow: 'PubNetworkFlow',
      pubSlbSpecification: 'PubSlbSpecification',
      region: 'Region',
      requestPars: 'RequestPars',
      resourceGroupId: 'ResourceGroupId',
      securityGroupType: 'SecurityGroupType',
      tag: 'Tag',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      chargeType: 'string',
      clusterSpecification: 'string',
      clusterType: 'string',
      clusterVersion: 'string',
      connectionType: 'string',
      diskType: 'string',
      eipEnabled: 'boolean',
      instanceCount: 'number',
      instanceName: 'string',
      mseVersion: 'string',
      netType: 'string',
      privateSlbSpecification: 'string',
      pubNetworkFlow: 'string',
      pubSlbSpecification: 'string',
      region: 'string',
      requestPars: 'string',
      resourceGroupId: 'string',
      securityGroupType: 'string',
      tag: { 'type': 'array', 'itemType': CreateClusterRequestTag },
      vSwitchId: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-cn-st21ri2****
   */
  instanceId?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the order.
   * 
   * @example
   * 20574710974****
   */
  orderId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * dc63-465d-8ef5-20dc18af****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      instanceId: 'InstanceId',
      message: 'Message',
      orderId: 'OrderId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      instanceId: 'string',
      message: 'string',
      orderId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEngineNamespaceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-98s****
   */
  clusterId?: string;
  /**
   * @remarks
   * The description of the namespace.
   * 
   * @example
   * Development environment
   */
  desc?: string;
  /**
   * @remarks
   * The custom ID of the namespace. If you do not specify this parameter, the automatically generated Universally Unique Identifier (UUID) is returned.
   * 
   * @example
   * f4fa5b81-2f26-4900-833a-7516b315ebb2
   */
  id?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-cn-st21ri2****
   */
  instanceId?: string;
  /**
   * @remarks
   * The display name of the namespace.
   * 
   * This parameter is required.
   * 
   * @example
   * dev
   */
  name?: string;
  /**
   * @remarks
   * The maximum number of services that can run in the namespace.
   * 
   * @example
   * 100
   */
  serviceCount?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      desc: 'Desc',
      id: 'Id',
      instanceId: 'InstanceId',
      name: 'Name',
      serviceCount: 'ServiceCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      desc: 'string',
      id: 'string',
      instanceId: 'string',
      name: 'string',
      serviceCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEngineNamespaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-892k****
   */
  clusterId?: string;
  /**
   * @remarks
   * The details of the data.
   */
  data?: CreateEngineNamespaceResponseBodyData;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F6092602-C357-4750-89D9-E572FBEA****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      data: 'Data',
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      data: CreateEngineNamespaceResponseBodyData,
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEngineNamespaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateEngineNamespaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEngineNamespaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * ib09eblv6p@c3df23522******
   */
  appId?: string;
  /**
   * @remarks
   * The application name.
   * 
   * This parameter is required.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * The throttling effect.
   * 
   * Valid values:
   * 
   * *   0: fast failure
   * *   2: in queue
   * 
   * @example
   * 0
   */
  controlBehavior?: number;
  /**
   * @remarks
   * Specifies whether to enable the rule.
   * 
   * Valid values:
   * 
   * *   true
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   false
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * This parameter is required.
   * 
   * @example
   * false
   */
  enable?: boolean;
  /**
   * @remarks
   * The timeout period. Unit: milliseconds. This value is required if the ControlBehavior parameter is set to 2.
   * 
   * @example
   * 10
   */
  maxQueueingTimeMs?: number;
  /**
   * @remarks
   * The namespace.
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The region in which the instance resides.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the API resource.
   * 
   * This parameter is required.
   * 
   * @example
   * /b
   */
  resource?: string;
  resourceType?: number;
  /**
   * @remarks
   * The throttling threshold.
   * 
   * This parameter is required.
   * 
   * @example
   * 20
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      controlBehavior: 'ControlBehavior',
      enable: 'Enable',
      maxQueueingTimeMs: 'MaxQueueingTimeMs',
      namespace: 'Namespace',
      regionId: 'RegionId',
      resource: 'Resource',
      resourceType: 'ResourceType',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      controlBehavior: 'number',
      enable: 'boolean',
      maxQueueingTimeMs: 'number',
      namespace: 'string',
      regionId: 'string',
      resource: 'string',
      resourceType: 'number',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The data returned.
   */
  data?: CreateFlowRuleResponseBodyData;
  /**
   * @remarks
   * The error message returned.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 69AD2AA7-DB47-449B-941B-B14409DF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * Valid values:
   * 
   * *   true
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   false
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateFlowRuleResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateFlowRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateFlowRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGatewayCircuitBreakerRuleRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 0
   */
  behaviorType?: number;
  /**
   * @example
   * 0
   */
  bodyEncoding?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 0
   */
  enable?: number;
  /**
   * @example
   * 14407
   */
  gatewayId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * gw-c9bc5afd61014165bd58f621b491*****
   */
  gatewayUniqueId?: string;
  /**
   * @example
   * 10
   */
  maxAllowedMs?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 10
   */
  minRequestAmount?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 12
   */
  recoveryTimeoutSec?: number;
  /**
   * @example
   * text
   */
  responseContentBody?: string;
  /**
   * @example
   * www.******.com
   */
  responseRedirectUrl?: string;
  /**
   * @example
   * 429
   */
  responseStatusCode?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 645
   */
  routeId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * routeName
   */
  routeName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 11
   */
  statDurationSec?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 0
   */
  strategy?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 10
   */
  triggerRatio?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      behaviorType: 'BehaviorType',
      bodyEncoding: 'BodyEncoding',
      enable: 'Enable',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      maxAllowedMs: 'MaxAllowedMs',
      minRequestAmount: 'MinRequestAmount',
      recoveryTimeoutSec: 'RecoveryTimeoutSec',
      responseContentBody: 'ResponseContentBody',
      responseRedirectUrl: 'ResponseRedirectUrl',
      responseStatusCode: 'ResponseStatusCode',
      routeId: 'RouteId',
      routeName: 'RouteName',
      statDurationSec: 'StatDurationSec',
      strategy: 'Strategy',
      triggerRatio: 'TriggerRatio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      behaviorType: 'number',
      bodyEncoding: 'number',
      enable: 'number',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      maxAllowedMs: 'number',
      minRequestAmount: 'number',
      recoveryTimeoutSec: 'number',
      responseContentBody: 'string',
      responseRedirectUrl: 'string',
      responseStatusCode: 'number',
      routeId: 'number',
      routeName: 'string',
      statDurationSec: 'number',
      strategy: 'number',
      triggerRatio: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGatewayCircuitBreakerRuleResponseBody extends $tea.Model {
  /**
   * @example
   * 28
   */
  data?: number;
  /**
   * @example
   * DC34E4A3-5F1C-4E40-86EA-02EDF967****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGatewayCircuitBreakerRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateGatewayCircuitBreakerRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateGatewayCircuitBreakerRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGatewayFlowRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The language in which you want to display the results. Valid values: zh and en. zh indicates Chinese, which is the default value. en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The type of the web fallback behavior.
   * 
   * 0: returns the specified content.
   * 
   * 1: redirects to the specified page.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  behaviorType?: number;
  /**
   * @remarks
   * The encoding format.
   * 
   * 0: normal text
   * 
   * 1: JSON
   * 
   * @example
   * 0
   */
  bodyEncoding?: number;
  /**
   * @remarks
   * Specifies whether to enable the throttling rule.
   * 
   * 0: disables the throttling rule.
   * 
   * 1: enables the throttling rule.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  enable?: number;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 14407
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-e2d226bba4b2445c9e29fa7f8216****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The HTTP text to be returned.
   * 
   * @example
   * text
   */
  responseContentBody?: string;
  /**
   * @remarks
   * The address to be redirected to.
   * 
   * @example
   * www.******.com
   */
  responseRedirectUrl?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 429
   */
  responseStatusCode?: number;
  /**
   * @remarks
   * The ID of the route.
   * 
   * This parameter is required.
   * 
   * @example
   * 52853
   */
  routeId?: number;
  /**
   * @remarks
   * The name of the routing rule.
   * 
   * This parameter is required.
   * 
   * @example
   * routeName
   */
  routeName?: string;
  /**
   * @remarks
   * The overall queries per second (QPS) threshold.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      behaviorType: 'BehaviorType',
      bodyEncoding: 'BodyEncoding',
      enable: 'Enable',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      responseContentBody: 'ResponseContentBody',
      responseRedirectUrl: 'ResponseRedirectUrl',
      responseStatusCode: 'ResponseStatusCode',
      routeId: 'RouteId',
      routeName: 'RouteName',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      behaviorType: 'number',
      bodyEncoding: 'number',
      enable: 'number',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      responseContentBody: 'string',
      responseRedirectUrl: 'string',
      responseStatusCode: 'number',
      routeId: 'number',
      routeName: 'string',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGatewayFlowRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the rule.
   * 
   * @example
   * 608
   */
  data?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 72FC625E-9629-591B-9C01-3F0BFDAB****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGatewayFlowRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateGatewayFlowRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateGatewayFlowRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGatewayIsolationRuleRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 0
   */
  behaviorType?: number;
  /**
   * @example
   * 0
   */
  bodyEncoding?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 0
   */
  enable?: number;
  /**
   * @example
   * 14407
   */
  gatewayId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * gw-e2d226bba4b2445c9e29fa7f8216****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 100
   */
  maxConcurrency?: number;
  /**
   * @example
   * text
   */
  responseContentBody?: string;
  /**
   * @example
   * www.******.com
   */
  responseRedirectUrl?: string;
  /**
   * @example
   * 429
   */
  responseStatusCode?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 52853
   */
  routeId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * routeName
   */
  routeName?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      behaviorType: 'BehaviorType',
      bodyEncoding: 'BodyEncoding',
      enable: 'Enable',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      maxConcurrency: 'MaxConcurrency',
      responseContentBody: 'ResponseContentBody',
      responseRedirectUrl: 'ResponseRedirectUrl',
      responseStatusCode: 'ResponseStatusCode',
      routeId: 'RouteId',
      routeName: 'RouteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      behaviorType: 'number',
      bodyEncoding: 'number',
      enable: 'number',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      maxConcurrency: 'number',
      responseContentBody: 'string',
      responseRedirectUrl: 'string',
      responseStatusCode: 'number',
      routeId: 'number',
      routeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGatewayIsolationRuleResponseBody extends $tea.Model {
  /**
   * @example
   * 608
   */
  data?: number;
  /**
   * @example
   * 94B12406-E44D-57C9-BF93-A8B35BFF****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGatewayIsolationRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateGatewayIsolationRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateGatewayIsolationRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateIsolationRuleRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @example
   * hkhon1po62@c3df23522bXXXXX
   */
  appId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * /a
   */
  resource?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 3
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      enable: 'Enable',
      namespace: 'Namespace',
      regionId: 'RegionId',
      resource: 'Resource',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      enable: 'boolean',
      namespace: 'string',
      regionId: 'string',
      resource: 'string',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateIsolationRuleResponseBody extends $tea.Model {
  /**
   * @example
   * 200
   */
  code?: string;
  data?: CreateIsolationRuleResponseBodyData;
  /**
   * @example
   * OK
   */
  message?: string;
  /**
   * @example
   * 4E9FDCFE-0738-493B-B801-82BDFBCB****
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateIsolationRuleResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateIsolationRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateIsolationRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateIsolationRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMseServiceApplicationRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * bsd-xxyp-open-goods-server
   */
  appName?: string;
  /**
   * @remarks
   * The additional information.
   * 
   * @example
   * {}
   */
  extraInfo?: string;
  /**
   * @remarks
   * The programming language of the application.
   * 
   * @example
   * JAVA
   */
  language?: string;
  /**
   * @remarks
   * The edition of the MSE instance that you want to purchase.
   * 
   * *   mse_pro: Professional Edition.
   * *   mse_dev: Developer Edition.
   * 
   * @example
   * mse_pro
   */
  mseVersion?: string;
  /**
   * @remarks
   * The ID of the region where the instance resides. Examples:
   * 
   * *   cn-hangzhou: China (Hangzhou)
   * *   cn-beijing: China (Beijing)
   * *   cn-shanghai: China (Shanghai)
   * *   cn-zhangjiakou: China (Zhangjiakou)
   * *   cn-shenzhen: China (Shenzhen)
   * 
   * This parameter is required.
   * 
   * @example
   * cn-shenzhen
   */
  region?: string;
  /**
   * @remarks
   * Specifies whether to enable the Sentinel-compatible mode.
   * 
   * @example
   * true
   */
  sentinelEnable?: string;
  /**
   * @remarks
   * The service source.
   * 
   * @example
   * edasmsc
   */
  source?: string;
  /**
   * @remarks
   * Specifies whether to enable switching.
   * 
   * @example
   * true
   */
  switchEnable?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appName: 'AppName',
      extraInfo: 'ExtraInfo',
      language: 'Language',
      mseVersion: 'MseVersion',
      region: 'Region',
      sentinelEnable: 'SentinelEnable',
      source: 'Source',
      switchEnable: 'SwitchEnable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appName: 'string',
      extraInfo: 'string',
      language: 'string',
      mseVersion: 'string',
      region: 'string',
      sentinelEnable: 'string',
      source: 'string',
      switchEnable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMseServiceApplicationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data structure.
   */
  data?: CreateMseServiceApplicationResponseBodyData;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 904F6C04-1284-****-8ED2-FFC57E507A72
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: CreateMseServiceApplicationResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMseServiceApplicationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateMseServiceApplicationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMseServiceApplicationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNacosConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * saledatacenter-task
   */
  appName?: string;
  /**
   * @remarks
   * The list of IP addresses where the beta release of the configuration is performed.
   * 
   * @example
   * 100.117.XX.XX,100.117.XX.XX
   */
  betaIps?: string;
  /**
   * @remarks
   * The content of the configuration.
   * 
   * @example
   * asdf
   */
  content?: string;
  /**
   * @remarks
   * The ID of the data.
   * 
   * This parameter is required.
   * 
   * @example
   * common.yaml
   */
  dataId?: string;
  /**
   * @remarks
   * The description of the configuration.
   * 
   * @example
   * Basic module configuration.
   */
  desc?: string;
  /**
   * @remarks
   * The ID of the group.
   * 
   * This parameter is required.
   * 
   * @example
   * alime-bridge-aliyun
   */
  group?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse_prepaid_public_cn-tl32****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 547fd2a0-d0d6-****-80db2a1afb82
   */
  namespaceId?: string;
  /**
   * @remarks
   * The tags of the configuration.
   * 
   * @example
   * Basic configurations
   */
  tags?: string;
  /**
   * @remarks
   * The format of the configuration. Supported formats include TEXT, JSON, and XML.
   * 
   * @example
   * text
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appName: 'AppName',
      betaIps: 'BetaIps',
      content: 'Content',
      dataId: 'DataId',
      desc: 'Desc',
      group: 'Group',
      instanceId: 'InstanceId',
      namespaceId: 'NamespaceId',
      tags: 'Tags',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appName: 'string',
      betaIps: 'string',
      content: 'string',
      dataId: 'string',
      desc: 'string',
      group: 'string',
      instanceId: 'string',
      namespaceId: 'string',
      tags: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNacosConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The code returned.
   * 
   * @example
   * 1
   */
  code?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 202
   */
  httpCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 673DBD43-569E-510F-B3DE-20BB8DFEB20A
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNacosConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateNacosConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateNacosConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNacosInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the Nacos instance.
   * 
   * @example
   * DEFAULT
   */
  clusterName?: string;
  /**
   * @remarks
   * Specifies whether to enable the service for the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  enabled?: boolean;
  /**
   * @remarks
   * Specifies whether to mark the instance as a temporary node.
   * 
   * This parameter is required.
   * 
   * @example
   * false
   */
  ephemeral?: boolean;
  /**
   * @remarks
   * The name of the group.
   * 
   * This parameter is required.
   * 
   * @example
   * DEFAULT_GROUP
   */
  groupName?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse-cn-123456
   */
  instanceId?: string;
  /**
   * @remarks
   * The IP address of the Nacos instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 1.2.xx.xx
   */
  ip?: string;
  /**
   * @remarks
   * The node metadata of the instance.
   * 
   * @example
   * {\\"grayversion\\":\\"1.0\\",\\"preserved.register.source\\":\\"SPRING_CLOUD\\",\\"management.context-path\\":\\"\\"}
   */
  metadata?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 9e78a671-4b9b-4dd4-99c1-0b9da87****
   */
  namespaceId?: string;
  /**
   * @remarks
   * The port number of the Nacos instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 12281
   */
  port?: number;
  /**
   * @remarks
   * The name of the service.
   * 
   * This parameter is required.
   * 
   * @example
   * hello_service
   */
  serviceName?: string;
  /**
   * @remarks
   * The weight. Valid values: 0 to 10000. The value must be an integer. A larger value indicates a higher frequency at which the instance is accessed.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  weight?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterName: 'ClusterName',
      enabled: 'Enabled',
      ephemeral: 'Ephemeral',
      groupName: 'GroupName',
      instanceId: 'InstanceId',
      ip: 'Ip',
      metadata: 'Metadata',
      namespaceId: 'NamespaceId',
      port: 'Port',
      serviceName: 'ServiceName',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterName: 'string',
      enabled: 'boolean',
      ephemeral: 'boolean',
      groupName: 'string',
      instanceId: 'string',
      ip: 'string',
      metadata: 'string',
      namespaceId: 'string',
      port: 'number',
      serviceName: 'string',
      weight: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNacosInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The result returned.
   * 
   * @example
   * ok
   */
  data?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9e78a671-4b9b-4dd4-99c1-0b9da87d3dec
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNacosInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateNacosInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateNacosInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNacosServiceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
   * 
   * @example
   * mse-3691a080
   */
  clusterId?: string;
  /**
   * @remarks
   * Specifies whether the instance is marked as a temporary node. Valid values:
   * 
   * *   `true`: yes
   * *   `false`: no
   * 
   * @example
   * true
   */
  ephemeral?: boolean;
  /**
   * @remarks
   * The name of the group.
   * 
   * @example
   * DEFAULT_GROUP
   */
  groupName?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
   * 
   * @example
   * mse-cn-st21ri2****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * production
   */
  namespaceId?: string;
  /**
   * @remarks
   * The protection threshold.
   * 
   * @example
   * 0
   */
  protectThreshold?: string;
  /**
   * @remarks
   * The name of the service.
   * 
   * This parameter is required.
   * 
   * @example
   * com.alibabacloud.hipstershop.cartserviceapi.service.CartService
   */
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      ephemeral: 'Ephemeral',
      groupName: 'GroupName',
      instanceId: 'InstanceId',
      namespaceId: 'NamespaceId',
      protectThreshold: 'ProtectThreshold',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      ephemeral: 'boolean',
      groupName: 'string',
      instanceId: 'string',
      namespaceId: 'string',
      protectThreshold: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNacosServiceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data of the node.
   * 
   * @example
   * data
   */
  data?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 5B170A0D-2C5D-4CF8-B808-03966B86****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNacosServiceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateNacosServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateNacosServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSwimmingLaneRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values: zh and en. Default value: zh. The value zh indicates Chinese, and the value en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to enable the lane.
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * Specifies whether to configure a routing rule for the lane. If an Ingress gateway is used, this parameter is not required.
   * 
   * @example
   * false
   */
  enableRules?: boolean;
  /**
   * @remarks
   * The JSON string.
   * 
   * @example
   * {}
   * 
   * @deprecated
   */
  entryRule?: string;
  entryRules?: CreateOrUpdateSwimmingLaneRequestEntryRules[];
  /**
   * @remarks
   * The information about the routing rule for the gateway. This parameter is required when a cloud-native gateway is used as the ingress.
   */
  gatewaySwimmingLaneRouteJson?: CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson;
  /**
   * @remarks
   * The language of the response. Valid values:****
   * 
   * *   **zh-CN**: Chinese
   * *   **en-US**: English
   * 
   * > Default value: **zh-CN**.
   * 
   * @example
   * 115
   */
  groupId?: number;
  /**
   * @remarks
   * The ID of the primary key. The value -1 indicates a request that is used to create a lane. A value greater than 0 indicates a request that is used to modify a lane.
   * 
   * @example
   * -1
   */
  id?: number;
  /**
   * @remarks
   * The name of the lane.
   * 
   * This parameter is required.
   * 
   * @example
   * Test lane
   */
  name?: string;
  /**
   * @example
   * default
   */
  namespace?: string;
  pathIndependentPercentageEnable?: boolean;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-beijing
   */
  regionId?: string;
  /**
   * @remarks
   * The tag.
   * 
   * @example
   * gray
   */
  tag?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      enable: 'Enable',
      enableRules: 'EnableRules',
      entryRule: 'EntryRule',
      entryRules: 'EntryRules',
      gatewaySwimmingLaneRouteJson: 'GatewaySwimmingLaneRouteJson',
      groupId: 'GroupId',
      id: 'Id',
      name: 'Name',
      namespace: 'Namespace',
      pathIndependentPercentageEnable: 'PathIndependentPercentageEnable',
      regionId: 'RegionId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      enable: 'boolean',
      enableRules: 'boolean',
      entryRule: 'string',
      entryRules: { 'type': 'array', 'itemType': CreateOrUpdateSwimmingLaneRequestEntryRules },
      gatewaySwimmingLaneRouteJson: CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson,
      groupId: 'number',
      id: 'number',
      name: 'string',
      namespace: 'string',
      pathIndependentPercentageEnable: 'boolean',
      regionId: 'string',
      tag: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSwimmingLaneShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values: zh and en. Default value: zh. The value zh indicates Chinese, and the value en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to enable the lane.
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * Specifies whether to configure a routing rule for the lane. If an Ingress gateway is used, this parameter is not required.
   * 
   * @example
   * false
   */
  enableRules?: boolean;
  /**
   * @remarks
   * The JSON string.
   * 
   * @example
   * {}
   * 
   * @deprecated
   */
  entryRule?: string;
  entryRules?: CreateOrUpdateSwimmingLaneShrinkRequestEntryRules[];
  /**
   * @remarks
   * The information about the routing rule for the gateway. This parameter is required when a cloud-native gateway is used as the ingress.
   */
  gatewaySwimmingLaneRouteJsonShrink?: string;
  /**
   * @remarks
   * The language of the response. Valid values:****
   * 
   * *   **zh-CN**: Chinese
   * *   **en-US**: English
   * 
   * > Default value: **zh-CN**.
   * 
   * @example
   * 115
   */
  groupId?: number;
  /**
   * @remarks
   * The ID of the primary key. The value -1 indicates a request that is used to create a lane. A value greater than 0 indicates a request that is used to modify a lane.
   * 
   * @example
   * -1
   */
  id?: number;
  /**
   * @remarks
   * The name of the lane.
   * 
   * This parameter is required.
   * 
   * @example
   * Test lane
   */
  name?: string;
  /**
   * @example
   * default
   */
  namespace?: string;
  pathIndependentPercentageEnable?: boolean;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-beijing
   */
  regionId?: string;
  /**
   * @remarks
   * The tag.
   * 
   * @example
   * gray
   */
  tag?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      enable: 'Enable',
      enableRules: 'EnableRules',
      entryRule: 'EntryRule',
      entryRules: 'EntryRules',
      gatewaySwimmingLaneRouteJsonShrink: 'GatewaySwimmingLaneRouteJson',
      groupId: 'GroupId',
      id: 'Id',
      name: 'Name',
      namespace: 'Namespace',
      pathIndependentPercentageEnable: 'PathIndependentPercentageEnable',
      regionId: 'RegionId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      enable: 'boolean',
      enableRules: 'boolean',
      entryRule: 'string',
      entryRules: { 'type': 'array', 'itemType': CreateOrUpdateSwimmingLaneShrinkRequestEntryRules },
      gatewaySwimmingLaneRouteJsonShrink: 'string',
      groupId: 'number',
      id: 'number',
      name: 'string',
      namespace: 'string',
      pathIndependentPercentageEnable: 'boolean',
      regionId: 'string',
      tag: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSwimmingLaneResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The value 200 is returned if the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The details of the data.
   * 
   * @example
   * {}
   */
  data?: CreateOrUpdateSwimmingLaneResponseBodyData;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE5C32A1-BC0E-4B79-817C-103E4EDF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: CreateOrUpdateSwimmingLaneResponseBodyData,
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSwimmingLaneResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOrUpdateSwimmingLaneResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOrUpdateSwimmingLaneResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSwimmingLaneGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The IDs of applications. Separate application IDs with commas (,).
   * 
   * @example
   * hkhon1po62@c3df23522baa898,hkhon1po62@66e5235415730a5,hkhon1po62@958bba95910341f
   */
  appIds?: string;
  canaryModel?: number;
  /**
   * @remarks
   * Specifies whether to enable database canary release.
   * 
   * @example
   * true
   */
  dbGrayEnable?: boolean;
  /**
   * @remarks
   * The ingress application.
   * 
   * @example
   * Ingress
   */
  entryApp?: string;
  /**
   * @remarks
   * The ID of the lane group. A value of -1 is used to create a lane group. A value greater than 0 is used to modify the specified lane group.
   * 
   * @example
   * 120
   */
  id?: number;
  /**
   * @remarks
   * The side for message filtering when the canary release for messaging feature is enabled.
   * 
   * @example
   * Server
   */
  messageQueueFilterSide?: string;
  /**
   * @remarks
   * Specifies whether to enable canary release for messaging.
   * 
   * @example
   * true
   * 
   * **if can be null:**
   * true
   */
  messageQueueGrayEnable?: boolean;
  /**
   * @remarks
   * The name.
   * 
   * This parameter is required.
   * 
   * @example
   * group1
   */
  name?: string;
  /**
   * @remarks
   * The name of the Microservices Engine (MSE) namespace.
   * 
   * @example
   * default
   */
  namespace?: string;
  paths?: string[];
  /**
   * @remarks
   * Specifies whether to record request details.
   */
  recordCanaryDetail?: boolean;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-shanghai
   */
  region?: string;
  routeIds?: number[];
  /**
   * @remarks
   * The status of the lane group. The value 0 specifies that the lane group is disabled. The value 1 specifies that the lane group is enabled.
   * 
   * @example
   * 0
   */
  status?: number;
  swimVersion?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appIds: 'AppIds',
      canaryModel: 'CanaryModel',
      dbGrayEnable: 'DbGrayEnable',
      entryApp: 'EntryApp',
      id: 'Id',
      messageQueueFilterSide: 'MessageQueueFilterSide',
      messageQueueGrayEnable: 'MessageQueueGrayEnable',
      name: 'Name',
      namespace: 'Namespace',
      paths: 'Paths',
      recordCanaryDetail: 'RecordCanaryDetail',
      region: 'Region',
      routeIds: 'RouteIds',
      status: 'Status',
      swimVersion: 'SwimVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appIds: 'string',
      canaryModel: 'number',
      dbGrayEnable: 'boolean',
      entryApp: 'string',
      id: 'number',
      messageQueueFilterSide: 'string',
      messageQueueGrayEnable: 'boolean',
      name: 'string',
      namespace: 'string',
      paths: { 'type': 'array', 'itemType': 'string' },
      recordCanaryDetail: 'boolean',
      region: 'string',
      routeIds: { 'type': 'array', 'itemType': 'number' },
      status: 'number',
      swimVersion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSwimmingLaneGroupShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The IDs of applications. Separate application IDs with commas (,).
   * 
   * @example
   * hkhon1po62@c3df23522baa898,hkhon1po62@66e5235415730a5,hkhon1po62@958bba95910341f
   */
  appIds?: string;
  canaryModel?: number;
  /**
   * @remarks
   * Specifies whether to enable database canary release.
   * 
   * @example
   * true
   */
  dbGrayEnable?: boolean;
  /**
   * @remarks
   * The ingress application.
   * 
   * @example
   * Ingress
   */
  entryApp?: string;
  /**
   * @remarks
   * The ID of the lane group. A value of -1 is used to create a lane group. A value greater than 0 is used to modify the specified lane group.
   * 
   * @example
   * 120
   */
  id?: number;
  /**
   * @remarks
   * The side for message filtering when the canary release for messaging feature is enabled.
   * 
   * @example
   * Server
   */
  messageQueueFilterSide?: string;
  /**
   * @remarks
   * Specifies whether to enable canary release for messaging.
   * 
   * @example
   * true
   * 
   * **if can be null:**
   * true
   */
  messageQueueGrayEnable?: boolean;
  /**
   * @remarks
   * The name.
   * 
   * This parameter is required.
   * 
   * @example
   * group1
   */
  name?: string;
  /**
   * @remarks
   * The name of the Microservices Engine (MSE) namespace.
   * 
   * @example
   * default
   */
  namespace?: string;
  pathsShrink?: string;
  /**
   * @remarks
   * Specifies whether to record request details.
   */
  recordCanaryDetail?: boolean;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-shanghai
   */
  region?: string;
  routeIdsShrink?: string;
  /**
   * @remarks
   * The status of the lane group. The value 0 specifies that the lane group is disabled. The value 1 specifies that the lane group is enabled.
   * 
   * @example
   * 0
   */
  status?: number;
  swimVersion?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appIds: 'AppIds',
      canaryModel: 'CanaryModel',
      dbGrayEnable: 'DbGrayEnable',
      entryApp: 'EntryApp',
      id: 'Id',
      messageQueueFilterSide: 'MessageQueueFilterSide',
      messageQueueGrayEnable: 'MessageQueueGrayEnable',
      name: 'Name',
      namespace: 'Namespace',
      pathsShrink: 'Paths',
      recordCanaryDetail: 'RecordCanaryDetail',
      region: 'Region',
      routeIdsShrink: 'RouteIds',
      status: 'Status',
      swimVersion: 'SwimVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appIds: 'string',
      canaryModel: 'number',
      dbGrayEnable: 'boolean',
      entryApp: 'string',
      id: 'number',
      messageQueueFilterSide: 'string',
      messageQueueGrayEnable: 'boolean',
      name: 'string',
      namespace: 'string',
      pathsShrink: 'string',
      recordCanaryDetail: 'boolean',
      region: 'string',
      routeIdsShrink: 'string',
      status: 'number',
      swimVersion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSwimmingLaneGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response parameters.
   * 
   * @example
   * {}
   */
  data?: CreateOrUpdateSwimmingLaneGroupResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE5C32A1-BC0E-4B79-817C-103E4EDF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * true: The request was successful. false: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: CreateOrUpdateSwimmingLaneGroupResponseBodyData,
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSwimmingLaneGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOrUpdateSwimmingLaneGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOrUpdateSwimmingLaneGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePluginConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The language in which you want to display the results. Valid values: zh and en. zh indicates Chinese, which is the default value. en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The plug-in configuration. The configuration content of the WebAssembly (Wasm) plug-in is in the YAML format. The configuration content of the Lua plug-in is Lua code.
   * 
   * @example
   * status_code: 200
   * headers:
   * - Content-Type=application/json
   * body: "{\\"rule\\": \\"global\\"}"
   */
  config?: string;
  /**
   * @remarks
   * The application scope of the plug-in. Valid values:
   * 
   * *   0: global
   * *   1: route
   * *   2: domain name
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  configLevel?: number;
  /**
   * @remarks
   * Indicates whether the plug-in is enabled.
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-ubuwqygbq4783gqb2y3f87q****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The gateway plug-in ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 20
   */
  pluginId?: number;
  /**
   * @remarks
   * The domain IDs or route IDs. They are distinguished based on ConfigLevel.
   */
  resourceIdList?: number[];
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      config: 'Config',
      configLevel: 'ConfigLevel',
      enable: 'Enable',
      gatewayUniqueId: 'GatewayUniqueId',
      pluginId: 'PluginId',
      resourceIdList: 'ResourceIdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      config: 'string',
      configLevel: 'number',
      enable: 'boolean',
      gatewayUniqueId: 'string',
      pluginId: 'number',
      resourceIdList: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePluginConfigShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language in which you want to display the results. Valid values: zh and en. zh indicates Chinese, which is the default value. en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The plug-in configuration. The configuration content of the WebAssembly (Wasm) plug-in is in the YAML format. The configuration content of the Lua plug-in is Lua code.
   * 
   * @example
   * status_code: 200
   * headers:
   * - Content-Type=application/json
   * body: "{\\"rule\\": \\"global\\"}"
   */
  config?: string;
  /**
   * @remarks
   * The application scope of the plug-in. Valid values:
   * 
   * *   0: global
   * *   1: route
   * *   2: domain name
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  configLevel?: number;
  /**
   * @remarks
   * Indicates whether the plug-in is enabled.
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-ubuwqygbq4783gqb2y3f87q****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The gateway plug-in ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 20
   */
  pluginId?: number;
  /**
   * @remarks
   * The domain IDs or route IDs. They are distinguished based on ConfigLevel.
   */
  resourceIdListShrink?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      config: 'Config',
      configLevel: 'ConfigLevel',
      enable: 'Enable',
      gatewayUniqueId: 'GatewayUniqueId',
      pluginId: 'PluginId',
      resourceIdListShrink: 'ResourceIdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      config: 'string',
      configLevel: 'number',
      enable: 'boolean',
      gatewayUniqueId: 'string',
      pluginId: 'number',
      resourceIdListShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePluginConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The plug-in configuration ID.
   * 
   * @example
   * 10
   */
  pluginConfigID?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 03A3E2F4-6804-5663-9D5D-2EC47A1*****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pluginConfigID: 'PluginConfigID',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pluginConfigID: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePluginConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePluginConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePluginConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateZnodeRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-09k1q11****
   */
  clusterId?: string;
  /**
   * @remarks
   * The data of the node.
   * 
   * @example
   * data
   */
  data?: string;
  /**
   * @remarks
   * The path of the node.
   * 
   * @example
   * /zookeeper
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      data: 'Data',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      data: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateZnodeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   */
  data?: CreateZnodeResponseBodyData;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * DC34E4A3-5F1C-4E40-86EA-02EDF967****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: CreateZnodeResponseBodyData,
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateZnodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateZnodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateZnodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAuthResourceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-3f97e2989c344f35ab3fd62b19f1****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The destination ID.
   * 
   * @example
   * 36
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAuthResourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 1
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   */
  data?: DeleteAuthResourceResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 559412D1-BFCE-53CC-B88E-0192C331EF44
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: DeleteAuthResourceResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAuthResourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteAuthResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAuthResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCircuitBreakerRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values: zh and en. Default value: zh. The value zh indicates Chinese, and the value en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * The IDs of the rules that you want to delete.
   */
  ids?: number[];
  /**
   * @remarks
   * The microservice namespace to which the application belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appName: 'AppName',
      ids: 'Ids',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appName: 'string',
      ids: { 'type': 'array', 'itemType': 'number' },
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCircuitBreakerRulesShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values: zh and en. Default value: zh. The value zh indicates Chinese, and the value en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * The IDs of the rules that you want to delete.
   */
  idsShrink?: string;
  /**
   * @remarks
   * The microservice namespace to which the application belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appName: 'AppName',
      idsShrink: 'Ids',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appName: 'string',
      idsShrink: 'string',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCircuitBreakerRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The IDs of the rules that were deleted.
   */
  data?: number[];
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * OK
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * FAF577DD-8E8E-5BE6-80CC-380E19******
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': 'number' },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCircuitBreakerRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteCircuitBreakerRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCircuitBreakerRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClusterRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-cn-6ja1rgl****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClusterResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 202
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3369AD10-F1A6-4E6F-B99E-20F51826****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClusterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEngineNamespaceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * @example
   * mse-0c738****
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 678ca857-****-b1bf-d0a98c5ca84b
   */
  id?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-cn-7pp2d1****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      id: 'Id',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      id: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEngineNamespaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 202
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A73AC37C-C617-4E3A-8049-372CF49C****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEngineNamespaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteEngineNamespaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteEngineNamespaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The application name.
   * 
   * This parameter is required.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * The IDs of the rules to be deleted.
   * 
   * @example
   * [1,2]
   */
  ids?: number[];
  /**
   * @remarks
   * The microservice namespace to which the application belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appName: 'AppName',
      ids: 'Ids',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appName: 'string',
      ids: { 'type': 'array', 'itemType': 'number' },
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowRulesShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The application name.
   * 
   * This parameter is required.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * The IDs of the rules to be deleted.
   * 
   * @example
   * [1,2]
   */
  idsShrink?: string;
  /**
   * @remarks
   * The microservice namespace to which the application belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appName: 'AppName',
      idsShrink: 'Ids',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appName: 'string',
      idsShrink: 'string',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The IDs of the rules that were deleted.
   */
  data?: number[];
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * OK
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * FAF577DD-8E8E-5BE6-80CC-380E19******
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': 'number' },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteFlowRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteFlowRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to delete the SLB instance purchased for the gateway when you delete the gateway.
   * 
   * @example
   * true
   */
  deleteSlb?: boolean;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-0fe488252dc44d55a9dd57875193a1d7
   */
  gatewayUniqueId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      deleteSlb: 'DeleteSlb',
      gatewayUniqueId: 'GatewayUniqueId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      deleteSlb: 'boolean',
      gatewayUniqueId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code returned. The value 200 indicates that the request was successful. Other values indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The details of the data.
   */
  data?: DeleteGatewayResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * *   If the request is successful, a success message is returned.
   * *   If the request fails, an error message is returned, such as the "TaskId not found" message.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 2FFEA345-BE30-5FE0-8885-42E2DEFD5FE6
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: DeleteGatewayResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteGatewayResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteGatewayResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayAuthConsumerRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-c70622ff52fe49beb29bea9a6f52****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the consumer on which the gateway performs authentication operations.
   * 
   * This parameter is required.
   * 
   * @example
   * 33ff74b6-d21e-4f9b-91a8-bc1ea4ef****
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayAuthConsumerResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. A value of 200 is returned if the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the execution was successful. Valid values:
   * 
   * *   true: The execution was successful.
   * *   false: The execution failed.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the \\*\\*%s\\*\\* variable in the **ErrMessage** parameter.
   * 
   * > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 69AD2AA7-DB47-449B-941B-B14409DF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayAuthConsumerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteGatewayAuthConsumerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteGatewayAuthConsumerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayAuthConsumerResourceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The consumer ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  consumerId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-ubuwqygbq4783gqb2y3f87q****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The IDs of the authorized resources that you want to delete.
   * 
   * This parameter is required.
   * 
   * @example
   * 1,2,3,4
   */
  idList?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      consumerId: 'ConsumerId',
      gatewayUniqueId: 'GatewayUniqueId',
      idList: 'IdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      consumerId: 'number',
      gatewayUniqueId: 'string',
      idList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayAuthConsumerResourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the \\*\\*%s\\*\\* variable in the **ErrMessage** parameter.
   * 
   * > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * NoPermission
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 3369AD10-F1A6-4E6F-B99E-20F51826****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayAuthConsumerResourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteGatewayAuthConsumerResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteGatewayAuthConsumerResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayCircuitBreakerRuleRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * gw-1cef5440bf2d484db419fb264d4f****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 11151
   */
  routeId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1
   */
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      routeId: 'RouteId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      routeId: 'number',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayCircuitBreakerRuleResponseBody extends $tea.Model {
  /**
   * @example
   * True
   */
  data?: boolean;
  /**
   * @example
   * 52BA6DA6-A702-4362-A32F-DFF79655****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayCircuitBreakerRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteGatewayCircuitBreakerRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteGatewayCircuitBreakerRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-90392d768a3847a7b804c505254d****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The domain ID.
   * 
   * @example
   * 109
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   */
  data?: DeleteGatewayDomainResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 39016EAC-6EDB-52FE-AE20-4B013DF236FF
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: DeleteGatewayDomainResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteGatewayDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteGatewayDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayFlowRuleRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * gw-e2d226bba4b2445c9e29fa7f8216****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 11151
   */
  routeId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1
   */
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      routeId: 'RouteId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      routeId: 'number',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayFlowRuleResponseBody extends $tea.Model {
  /**
   * @example
   * True
   */
  data?: boolean;
  /**
   * @example
   * 2B74E7F7-DF54-5AB1-B8F2-67391B83****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayFlowRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteGatewayFlowRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteGatewayFlowRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayIsolationRuleRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * gw-e2d226bba4b2445c9e29fa7f8216****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 11151
   */
  routeId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1
   */
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      routeId: 'RouteId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      routeId: 'number',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayIsolationRuleResponseBody extends $tea.Model {
  /**
   * @example
   * True
   */
  data?: boolean;
  /**
   * @example
   * 94B12406-E44D-57C9-BF93-A8B35BFF****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayIsolationRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteGatewayIsolationRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteGatewayIsolationRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayRouteRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-492af9b04bb4474cae9d645be850e3d7
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the route.
   * 
   * @example
   * 252
   */
  routeId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      routeId: 'RouteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      routeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayRouteResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data returned.
   */
  data?: DeleteGatewayRouteResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * ADDD8AB7-8D1C-4697-A83E-410D2607****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: DeleteGatewayRouteResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayRouteResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteGatewayRouteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteGatewayRouteResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayServiceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 60
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-1a4ab101d5924b6f92c5ec98a841761f
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the service.
   * 
   * @example
   * 190
   */
  serviceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      serviceId: 'ServiceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      serviceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayServiceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   */
  data?: DeleteGatewayServiceResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  message?: string;
  /**
   * @remarks
   * The unique ID of the request.
   * 
   * @example
   * B3545F76-6ED1-586F-8DB9-ECE07985F381
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: DeleteGatewayServiceResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayServiceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteGatewayServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteGatewayServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayServiceVersionRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-b6988bd16920479d9104e1729f97****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the service.
   * 
   * @example
   * 777
   */
  serviceId?: number;
  /**
   * @remarks
   * The version of the service.
   * 
   * @example
   * {\\"name\\":\\"app\\",\\"labels\\":[{\\"key\\":\\"app\\",\\"value\\":\\"demo-server\\"}]}
   */
  serviceVersion?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      serviceId: 'ServiceId',
      serviceVersion: 'ServiceVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      serviceId: 'number',
      serviceVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayServiceVersionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 1
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   * 
   * @example
   * 1
   */
  data?: number;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * *   If the request is successful, a success message is returned.
   * *   If the request fails, an error message is returned, such as the "TaskId not found" message.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 29D52777-BE96-563E-BC6B-796ACE47A7A5
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayServiceVersionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteGatewayServiceVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteGatewayServiceVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewaySlbRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to delete the SLB instance purchased for the gateway when you delete the gateway.
   * 
   * @example
   * true
   */
  deleteSlb?: boolean;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-c9bc5afd61014165bd58f621b491****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the association record.
   * 
   * @example
   * 395
   */
  id?: string;
  /**
   * @remarks
   * The ID of the SLB instance that needs to be deleted.
   * 
   * @example
   * lb-uf6duug6s13x4abc8****
   */
  slbId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      deleteSlb: 'DeleteSlb',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      slbId: 'SlbId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      deleteSlb: 'boolean',
      gatewayUniqueId: 'string',
      id: 'string',
      slbId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewaySlbResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 1
   */
  code?: number;
  /**
   * @remarks
   * The deletion result.
   * 
   * @example
   * 28
   */
  data?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * *   If the request is successful, a success message is returned.
   * *   If the request fails, an error message is returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9297B27D-D932-5E9F-93B9-99D6C5F3A879
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewaySlbResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteGatewaySlbResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteGatewaySlbResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteIsolationRulesRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  ids?: number[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * default
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appName: 'AppName',
      ids: 'Ids',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appName: 'string',
      ids: { 'type': 'array', 'itemType': 'number' },
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteIsolationRulesShrinkRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  idsShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * default
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appName: 'AppName',
      idsShrink: 'Ids',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appName: 'string',
      idsShrink: 'string',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteIsolationRulesResponseBody extends $tea.Model {
  /**
   * @example
   * 200
   */
  code?: number;
  data?: number[];
  /**
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @example
   * OK
   */
  message?: string;
  /**
   * @example
   * 4E9FDCFE-0738-493B-B801-82BDFBCB****
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': 'number' },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteIsolationRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteIsolationRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteIsolationRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMigrationTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the task.
   * 
   * @example
   * 1
   */
  id?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      id: 'Id',
      requestPars: 'RequestPars',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      id: 'string',
      requestPars: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMigrationTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The deletion result.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 8BD1E58D-0755-42AC-A599-E6B55112****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMigrationTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteMigrationTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMigrationTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNacosConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * true
   */
  beta?: boolean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * This parameter is required.
   * 
   * @example
   * user-ds.yml
   */
  dataId?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * This parameter is required.
   * 
   * @example
   * HALVIE_MICRO_GROUP
   */
  group?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * This parameter is required.
   * 
   * @example
   * mse_prepaid_public_cn-tl32epfyu18
   */
  instanceId?: string;
  /**
   * @remarks
   * The request is successfully processed.
   * 
   * @example
   * 0e9d849b-****-8435da6c21ad
   */
  namespaceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      beta: 'Beta',
      dataId: 'DataId',
      group: 'Group',
      instanceId: 'InstanceId',
      namespaceId: 'NamespaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      beta: 'boolean',
      dataId: 'string',
      group: 'string',
      instanceId: 'string',
      namespaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNacosConfigResponseBody extends $tea.Model {
  /**
   * @example
   * 200
   */
  code?: string;
  /**
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @example
   * 202
   */
  httpCode?: string;
  message?: string;
  /**
   * @remarks
   * Deletes a Nacos configuration.
   * 
   * @example
   * 4FEFC13F-EB50-51E1-97D8-C5CBA8CD1B84
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNacosConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteNacosConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteNacosConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNacosConfigsRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The IDs of configurations.
   * 
   * This parameter is required.
   * 
   * @example
   * 20024,20025,20026,20027,20034,20104,20394
   */
  ids?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse_prepaid_public_cn-i7m2e32pd0n
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * This parameter is required.
   * 
   * @example
   * 1ef93a21-3487-4367-a859-857d8****
   */
  namespaceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      ids: 'Ids',
      instanceId: 'InstanceId',
      namespaceId: 'NamespaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      ids: 'string',
      instanceId: 'string',
      namespaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNacosConfigsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 73EB5563-CBB3-5F48-999D-512F4EFB7377
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNacosConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteNacosConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteNacosConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNacosInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The alias of the cluster.
   * 
   * @example
   * DEFAULT
   */
  clusterName?: string;
  /**
   * @remarks
   * Specifies whether the node is an ephemeral node. Valid values:
   * 
   * *   `true`: yes
   * *   `false`: no
   * 
   * This parameter is required.
   * 
   * @example
   * false
   */
  ephemeral?: boolean;
  /**
   * @remarks
   * The name of the group.
   * 
   * This parameter is required.
   * 
   * @example
   * DEFAULT_GROUP
   */
  groupName?: string;
  /**
   * @remarks
   * The ID of the Nacos instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse-cn-st21v5****
   */
  instanceId?: string;
  /**
   * @remarks
   * The IP address of the Nacos instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 10.237.1.32
   */
  ip?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 9e78a671-4b9b-4dd4-99c1-0b9da87****
   */
  namespaceId?: string;
  /**
   * @remarks
   * The port of the Nacos instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 8080
   */
  port?: number;
  /**
   * @remarks
   * The name of the service.
   * 
   * This parameter is required.
   * 
   * @example
   * hello_service
   */
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterName: 'ClusterName',
      ephemeral: 'Ephemeral',
      groupName: 'GroupName',
      instanceId: 'InstanceId',
      ip: 'Ip',
      namespaceId: 'NamespaceId',
      port: 'Port',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterName: 'string',
      ephemeral: 'boolean',
      groupName: 'string',
      instanceId: 'string',
      ip: 'string',
      namespaceId: 'string',
      port: 'number',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNacosInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The value 200 is returned if the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data of the node.
   * 
   * @example
   * OK
   */
  data?: string;
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 8BD1E58D-0755-42AC-A599-E6B55112****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNacosInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteNacosInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteNacosInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNacosServiceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the group.
   * 
   * This parameter is required.
   * 
   * @example
   * DEFAULT_GROUP
   */
  groupName?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse-cn-123456
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 9e78a671-4b9b-4dd4-99c1-0****
   */
  namespaceId?: string;
  /**
   * @remarks
   * The name of the service.
   * 
   * This parameter is required.
   * 
   * @example
   * hello_service
   */
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      groupName: 'GroupName',
      instanceId: 'InstanceId',
      namespaceId: 'NamespaceId',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      groupName: 'string',
      instanceId: 'string',
      namespaceId: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNacosServiceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The deletion result.
   * 
   * @example
   * ok
   */
  data?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9e78a671-4b9b-4dd4-99c1-0b9da87d3dec
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNacosServiceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteNacosServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteNacosServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNamespaceRequest extends $tea.Model {
  /**
   * @remarks
   * The language in which you want to display the results. Valid values: zh and en. Default value: zh. The value zh indicates Chinese, and the value en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @example
   * prod
   */
  name?: string;
  /**
   * @example
   * cn-hangzhou
   */
  region?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      name: 'Name',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      name: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNamespaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * NO_PERMISSION
   */
  errorCode?: string;
  /**
   * @example
   * 200
   */
  httpStatusCode?: number;
  message?: string;
  /**
   * @example
   * abcde-efg
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNamespaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteNamespaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteNamespaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePluginConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The language in which you want to display the results. Valid values: zh and en. zh indicates Chinese, which is the default value. en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-e2d226bba4b2445c9e29fa7f8216****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The plug-in configuration ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 200
   */
  pluginConfigId?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      pluginConfigId: 'PluginConfigId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      pluginConfigId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePluginConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DC34E4A3-5F1C-4E40-86EA-02EDF967****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePluginConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeletePluginConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeletePluginConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSecurityGroupRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  cascadingDelete?: boolean;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-83b0ddb569434f82b9fe8e4c60c40f7c
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The destination ID.
   * 
   * @example
   * 93
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      cascadingDelete: 'CascadingDelete',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      cascadingDelete: 'boolean',
      gatewayUniqueId: 'string',
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSecurityGroupRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   */
  data?: DeleteSecurityGroupRuleResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 43E50CB7-258E-5AFF-9B93-ECC19928C699
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: DeleteSecurityGroupRuleResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSecurityGroupRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteSecurityGroupRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSecurityGroupRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteServiceSourceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-492af9b04bb4474cae9d645be850****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the data source.
   * 
   * @example
   * 17
   */
  sourceId?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      sourceId: 'SourceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      sourceId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteServiceSourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 1
   */
  code?: number;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 2CEF593F-D60C-5449-9E98-15CA6ECD9189
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteServiceSourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteServiceSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteServiceSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSwimmingLaneRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the lane.
   * 
   * This parameter is required.
   * 
   * @example
   * 229
   */
  laneId?: number;
  /**
   * @remarks
   * The name of the Microservices Engine (MSE) namespace.
   * 
   * @example
   * default
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      laneId: 'LaneId',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      laneId: 'number',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSwimmingLaneResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 69AD2AA7-DB47-449B-941B-B14409DF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSwimmingLaneResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteSwimmingLaneResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSwimmingLaneResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSwimmingLaneGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the lane group.
   * 
   * @example
   * 145
   */
  groupId?: number;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * example-app
   */
  name?: string;
  /**
   * @remarks
   * The name of the Microservices Engine (MSE) namespace.
   * 
   * @example
   * default
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      groupId: 'GroupId',
      name: 'Name',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      groupId: 'number',
      name: 'string',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSwimmingLaneGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   * 
   * @example
   * {}
   */
  data?: any;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 52BA6DA6-A702-4362-A32F-DFF79655****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'any',
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSwimmingLaneGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteSwimmingLaneGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSwimmingLaneGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteZnodeRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse-09k1q11****
   */
  clusterId?: string;
  /**
   * @remarks
   * The path of the node.
   * 
   * This parameter is required.
   * 
   * @example
   * /zookeeper
   */
  path?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      path: 'Path',
      requestPars: 'RequestPars',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      path: 'string',
      requestPars: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteZnodeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   */
  data?: DeleteZnodeResponseBodyData;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * DC34E4A3-5F1C-4E40-86EA-02EDF967****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DeleteZnodeResponseBodyData,
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteZnodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteZnodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteZnodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableHttp2Request extends $tea.Model {
  /**
   * @remarks
   * The language in which you want to display the results. Valid values: zh and en. zh indicates Chinese, which is the default value. en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to enable HTTP/2 for negotiation between the server and client. This parameter applies to requests. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  enableHttp2?: boolean;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-0adf3ad751284cc69fcf9669fba*****
   */
  gatewayUniqueId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      enableHttp2: 'EnableHttp2',
      gatewayUniqueId: 'GatewayUniqueId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      enableHttp2: 'boolean',
      gatewayUniqueId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableHttp2ResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. A value of 200 is returned if the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether HTTP/2 is enabled.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the \\*\\*%s\\*\\* variable in the **ErrMessage** parameter.
   * 
   * >  The request parameter **DtsJobId** is invalid if **The Value of Input Parameter %s is not valid** is returned for **ErrMessage** and **DtsJobId** is returned for **DynamicMessage**.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The status code.
   * 
   * @example
   * Success
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * OK
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 52BA6DA6-A702-4362-A32F-DFF79655****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableHttp2Response extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EnableHttp2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableHttp2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableProxyProtocolRequest extends $tea.Model {
  /**
   * @remarks
   * The language in which you want to display the results. Valid values: zh and en. zh indicates Chinese, which is the default value. en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to use the proxy protocol to preserve client IP addresses. Valid values:
   * 
   * *   **true**
   * *   **false** (default)
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  enableProxyProtocol?: boolean;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-c9bc5afd61014165bd58f621b491*****
   */
  gatewayUniqueId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      enableProxyProtocol: 'EnableProxyProtocol',
      gatewayUniqueId: 'GatewayUniqueId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      enableProxyProtocol: 'boolean',
      gatewayUniqueId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableProxyProtocolResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. A value of 200 is returned if the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the **%s** variable in the **ErrMessage** parameter.
   * 
   * >  For example, if the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the **DtsJobId** parameter in the request is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The status code.
   * 
   * @example
   * Success
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * OK
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 316F5F64-F73D-42DC-8632-01E308B6****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableProxyProtocolResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EnableProxyProtocolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableProxyProtocolResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportNacosConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The application tag.
   * 
   * @example
   * qjl-gateway-openapi
   * 
   * @deprecated
   */
  appName?: string;
  /**
   * @remarks
   * The ID of the data that you want to export.
   * 
   * > 
   * 
   * *   Multiple export methods are supported.
   * 
   * *   If you want to export a single configuration, you must leave the Ids parameter empty and specify the DataID and Group parameters.
   * 
   * @example
   * sms-mes-develop.prop****
   * 
   * @deprecated
   */
  dataId?: string;
  /**
   * @remarks
   * The configuration group name and the ID of the configuration that you want to export. Separate multiple configurations with comma (,).
   * 
   * @example
   * testGroup+testDataId1,testGroup+testDataId2
   */
  dataIds?: string;
  /**
   * @remarks
   * The name of the configuration group.
   * 
   * @example
   * TIMEDTASK_COMMON_GROUP
   * 
   * @deprecated
   */
  group?: string;
  /**
   * @remarks
   * The ID of the primary key of a configuration item.
   * 
   * >  - Multiple export methods are supported. You must specify this parameter if you want to export multiple configurations. - You can obtain the value of this parameter by calling the ListNacosConfigs operation. - If you specify this parameter, multiple configurations are exported. The DataId and Group parameters are invalid.
   * 
   * @example
   * 1709,1710
   * 
   * @deprecated
   */
  ids?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse-cn-2r42ddc****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * ae77c258-4d4f-478f-baaa-084aee0****
   */
  namespaceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appName: 'AppName',
      dataId: 'DataId',
      dataIds: 'DataIds',
      group: 'Group',
      ids: 'Ids',
      instanceId: 'InstanceId',
      namespaceId: 'NamespaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appName: 'string',
      dataId: 'string',
      dataIds: 'string',
      group: 'string',
      ids: 'string',
      instanceId: 'string',
      namespaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportNacosConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The details of the data.
   */
  data?: ExportNacosConfigResponseBodyData;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace **%s** in the **ErrMessage** parameter.
   * 
   * > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 92245803-49B7-54CF-8D49-01A34A0E1CD6
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: ExportNacosConfigResponseBodyData,
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportNacosConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExportNacosConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportNacosConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportZookeeperDataRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The type of the object that is exported. Valid values:
   * 
   * *   transactionLog: transaction logs
   * *   snapshot: snapshots
   * 
   * @example
   * snapshot
   */
  exportType?: string;
  /**
   * @remarks
   * The instance ID.
   * 
   * @example
   * mse-cn-78v1l83****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the region in which the instance resides. The region is supported by Microservices Engine (MSE).
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      exportType: 'ExportType',
      instanceId: 'InstanceId',
      regionId: 'RegionId',
      requestPars: 'RequestPars',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      exportType: 'string',
      instanceId: 'string',
      regionId: 'string',
      requestPars: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportZookeeperDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   */
  data?: ExportZookeeperDataResponseBodyData;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the \\*\\*%s\\*\\* variable in the **ErrMessage** parameter.
   * 
   * > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * *   If the request is successful, a success message is returned.
   * *   If the request fails, an error message is returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 25EA0A83-9007-4E87-808C-637BE1A****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ExportZookeeperDataResponseBodyData,
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportZookeeperDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExportZookeeperDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportZookeeperDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FetchLosslessRuleListRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the application.
   * 
   * @example
   * hyaziyb6sc@86827c61f5ed8fc
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * spring-boot-sample
   */
  appName?: string;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The page number.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-beijing
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      namespace: 'Namespace',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      namespace: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FetchLosslessRuleListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned result.
   */
  data?: FetchLosslessRuleListResponseBodyData;
  /**
   * @example
   * Success
   */
  errorCode?: string;
  /**
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 56D9E600-6348-4260-B35F-583413F****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: FetchLosslessRuleListResponseBodyData,
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FetchLosslessRuleListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: FetchLosslessRuleListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: FetchLosslessRuleListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GatewayBlackWhiteListRequest extends $tea.Model {
  /**
   * @remarks
   * The language in which you want to display the results. Valid values: zh and en. zh indicates Chinese, which is the default value. en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is unavailable for public use.
   * 
   * @example
   * ""
   */
  descSort?: boolean;
  /**
   * @remarks
   * The filter parameters.
   */
  filterParams?: GatewayBlackWhiteListRequestFilterParams;
  /**
   * @remarks
   * This parameter is unavailable for public use.
   * 
   * @example
   * ""
   */
  orderItem?: string;
  /**
   * @remarks
   * The page number. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 1.
   * 
   * @example
   * 1
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      descSort: 'DescSort',
      filterParams: 'FilterParams',
      orderItem: 'OrderItem',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      descSort: 'boolean',
      filterParams: GatewayBlackWhiteListRequestFilterParams,
      orderItem: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GatewayBlackWhiteListShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language in which you want to display the results. Valid values: zh and en. zh indicates Chinese, which is the default value. en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is unavailable for public use.
   * 
   * @example
   * ""
   */
  descSort?: boolean;
  /**
   * @remarks
   * The filter parameters.
   */
  filterParamsShrink?: string;
  /**
   * @remarks
   * This parameter is unavailable for public use.
   * 
   * @example
   * ""
   */
  orderItem?: string;
  /**
   * @remarks
   * The page number. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 1.
   * 
   * @example
   * 1
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      descSort: 'DescSort',
      filterParamsShrink: 'FilterParams',
      orderItem: 'OrderItem',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      descSort: 'boolean',
      filterParamsShrink: 'string',
      orderItem: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GatewayBlackWhiteListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. A value of 200 is returned if the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data returned.
   */
  data?: GatewayBlackWhiteListResponseBodyData;
  /**
   * @remarks
   * The placeholder in the dynamic error message. This parameter is not returned.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic message. This parameter is not returned.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Success
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * OK
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 58E06A0A-BD2C-47A0-99C2-B100F353****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GatewayBlackWhiteListResponseBodyData,
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GatewayBlackWhiteListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GatewayBlackWhiteListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GatewayBlackWhiteListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppMessageQueueRouteRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * hkhon1po62@c3df23522baa898
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * example-app
   */
  appName?: string;
  /**
   * @remarks
   * The name of the Microservices Engine (MSE) namespace.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The region where the instance resides. Examples:
   * 
   * *   `cn-hangzhou`: China (Hangzhou)
   * *   `cn-beijing`: China (Beijing)
   * *   `cn-shanghai`: China (Shanghai)
   * *   `cn-zhangjiakou`: China (Zhangjiakou)
   * *   `cn-shenzhen`: China (Shenzhen)
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      namespace: 'Namespace',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      namespace: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppMessageQueueRouteResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data returned.
   */
  data?: GetAppMessageQueueRouteResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * *   If the request is successful, a success message is returned.
   * *   If the request fails, an error message is returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4B00BCB0-105F-5A2A-B75B-641C8E9B18FC
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: true and false. The value true indicates that the request was successful. The value false indicates that the request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GetAppMessageQueueRouteResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppMessageQueueRouteResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetAppMessageQueueRouteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAppMessageQueueRouteResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationInstanceListRequest extends $tea.Model {
  /**
   * @remarks
   * The language in which you want to display the results. Valid values: zh and en. zh indicates Chinese, which is the default value. en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * abcde@12345
   * 
   * @deprecated
   */
  appId?: string;
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * example-app
   */
  appName?: string;
  /**
   * @remarks
   * The Microservices Engine (MSE) namespace to which the application belongs.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The page number. Pages start from page 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The region.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The tags that you want to add to nodes.
   * 
   * @example
   * gray
   */
  tag?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      namespace: 'Namespace',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      region: 'Region',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      namespace: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      region: 'string',
      tag: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationInstanceListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data.
   */
  data?: GetApplicationInstanceListResponseBodyData;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetApplicationInstanceListResponseBodyData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationInstanceListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetApplicationInstanceListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetApplicationInstanceListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationListRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of an application.
   * 
   * @example
   * hkhon1po62@c3df23522b*****
   */
  appId?: string;
  /**
   * @remarks
   * The name of an application.
   * 
   * @example
   * rest-container
   */
  appName?: string;
  /**
   * @remarks
   * The programming language of the application, such as Java and Go.
   * 
   * @example
   * Java
   */
  language?: string;
  /**
   * @remarks
   * The microservice namespace to which the application belongs.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * Specifies whether to enable the Sentinel-compatible mode.
   * 
   * @example
   * true
   */
  sentinelEnable?: boolean;
  /**
   * @remarks
   * The source of the application. The value is fixed as edasmsc.
   * 
   * @example
   * edasmsc
   */
  source?: string;
  /**
   * @remarks
   * Specifies whether to enable switching.
   * 
   * @example
   * true
   */
  switchEnable?: boolean;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      language: 'Language',
      namespace: 'Namespace',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      region: 'Region',
      sentinelEnable: 'SentinelEnable',
      source: 'Source',
      switchEnable: 'SwitchEnable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      language: 'string',
      namespace: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      region: 'string',
      sentinelEnable: 'boolean',
      source: 'string',
      switchEnable: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   */
  data?: GetApplicationListResponseBodyData;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F55E608F-7C15-****-9CFD-DF832EBC4A0F
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetApplicationListResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetApplicationListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetApplicationListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBlackWhiteListRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-32d5c9769c1842b1a2cc3426c59e****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * Specifies whether to enable the whitelist.
   * 
   * @example
   * true
   */
  isWhite?: boolean;
  /**
   * @remarks
   * The type of the resource.
   * 
   * @example
   * GATEWAY
   */
  resourceType?: string;
  /**
   * @remarks
   * The type.
   * 
   * @example
   * IP
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      isWhite: 'IsWhite',
      resourceType: 'ResourceType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      isWhite: 'boolean',
      resourceType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBlackWhiteListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned. A value of 200 indicates that the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data of the node.
   */
  data?: GetBlackWhiteListResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 89CBC928-4F57-51FA-A413-EE0F4CD87200
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GetBlackWhiteListResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBlackWhiteListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetBlackWhiteListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetBlackWhiteListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEngineNamepaceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * @example
   * mse-98s****
   */
  clusterId?: string;
  /**
   * @remarks
   * The destination ID.
   * 
   * @example
   * 0e958d79-****-b282-b702d66362b5
   */
  id?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse.cn-hangzhou.aliyuncs.com
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      id: 'Id',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      id: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEngineNamepaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The number of configurations.
   * 
   * @example
   * 1
   */
  configCount?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 202
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * public
   */
  namespace?: string;
  /**
   * @remarks
   * The description of the namespace.
   * 
   * @example
   * mytest
   */
  namespaceDesc?: string;
  /**
   * @remarks
   * The display name of the namespace.
   * 
   * @example
   * public
   */
  namespaceShowName?: string;
  /**
   * @remarks
   * The quota of configurations.
   * 
   * @example
   * 200
   */
  quota?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * FA8F966F-420C-52F5-B49E-6ED7CCE02697
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The type of the namespace. Valid values:
   * 
   * *   0: global configuration
   * *   1: default namespace
   * *   2: custom namespace
   * 
   * @example
   * 1
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      configCount: 'ConfigCount',
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      namespace: 'Namespace',
      namespaceDesc: 'NamespaceDesc',
      namespaceShowName: 'NamespaceShowName',
      quota: 'Quota',
      requestId: 'RequestId',
      success: 'Success',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configCount: 'string',
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      namespace: 'string',
      namespaceDesc: 'string',
      namespaceShowName: 'string',
      quota: 'string',
      requestId: 'string',
      success: 'boolean',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEngineNamepaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetEngineNamepaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetEngineNamepaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-685f661467b54f48b7b7a76605ce****
   */
  gatewayUniqueId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned. A value of 200 indicates that the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The information about the gateway.
   */
  data?: GetGatewayResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9C96CDF8-9E6C-5AB6-B83C-8F87A10117E6
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GetGatewayResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetGatewayResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetGatewayResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayAuthConsumerDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-1a4ab101d5924b6f92c5ec98a84*****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the consumer.
   * 
   * This parameter is required.
   * 
   * @example
   * 120
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayAuthConsumerDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. A value of 200 is returned if the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data returned.
   */
  data?: GetGatewayAuthConsumerDetailResponseBodyData;
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the \\*\\*%s\\*\\* variable in the **ErrMessage** parameter.
   * 
   * >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code that is returned.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 316F5F64-F73D-42DC-8632-01E308B6****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GetGatewayAuthConsumerDetailResponseBodyData,
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayAuthConsumerDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetGatewayAuthConsumerDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetGatewayAuthConsumerDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayAuthDetailRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @example
   * 2274
   */
  gatewayId?: number;
  /**
   * @example
   * gw-6f0dbd108a0249d2b675b3ef50b*****
   */
  gatewayUniqueId?: string;
  /**
   * @example
   * 1100
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayAuthDetailResponseBody extends $tea.Model {
  /**
   * @example
   * 200
   */
  code?: number;
  data?: GetGatewayAuthDetailResponseBodyData;
  /**
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @example
   * OK
   */
  message?: string;
  /**
   * @example
   * 9C96CDF8-9E6C-XXXX-XXXX-8F87A10117E6
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GetGatewayAuthDetailResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayAuthDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetGatewayAuthDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetGatewayAuthDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayConfigRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * gw-61f465fa2dd044069e2208c4912*****
   */
  gatewayUniqueId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayConfigResponseBody extends $tea.Model {
  /**
   * @example
   * 200
   */
  code?: number;
  data?: GetGatewayConfigResponseBodyData;
  /**
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @example
   * Success
   */
  errorCode?: string;
  /**
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @example
   * OK
   */
  message?: string;
  /**
   * @example
   * F6092602-C357-4750-89D9-E572FBEA****
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GetGatewayConfigResponseBodyData,
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetGatewayConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetGatewayConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayDomainDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-6d0b23e1d39e41658a968d79a635****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The domain ID.
   * 
   * @example
   * 29
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayDomainDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 403
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   */
  data?: GetGatewayDomainDetailResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 88B83302-CD88-54D3-8DF2-208BFDC73F0D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GetGatewayDomainDetailResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayDomainDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetGatewayDomainDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetGatewayDomainDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayOptionRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 429
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-c9bc5afd61014165bd58f621b491*****
   */
  gatewayUniqueId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayOptionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned. The value 200 indicates that the request is successfully processed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The detailed configurations of the gateway.
   * 
   * *   **TraceDetails**: the sampling description of Managed Service for OpenTelemetry. Content: TraceEnabled indicates whether Managed Service for OpenTelemetry is activated. Sample indicates the sampling rate of Managed Service for OpenTelemetry.
   * *   **LogConfigDetails**: the description of Simple Log Service. Content: LogEnabled indicates whether Simple Log Service is activated. ProjectName indicates the Simple Log Service project to which logs are delivered. LogStoreName indicates the name of the Logstore.
   * *   **EnableHardwareAcceleration**: indicates whether hardware acceleration is enabled.
   * *   **DisableHttp2Alpn**: indicates whether the HTTP/2 protocol is disabled.
   * *   **EnableWaf**: indicates whether Web Application Firewall (WAF) is enabled.
   * 
   * @example
   * {\\"LogConfigDetails\\": {\\"LogEnabled\\": False}, \\"TraceDetails\\": {\\"TraceEnabled\\": False}}
   */
  data?: GatewayOption;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * *   If the request is successful, a success message is returned.
   * *   If the request fails, an error message is returned, such as the "TaskId not found" message.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C92F4A4D-A2FD-593E-839E-F3D4DFD2****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GatewayOption,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayOptionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetGatewayOptionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetGatewayOptionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-5d3a78a53ec947aa928212d671d400ac
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the route.
   * 
   * @example
   * 1050
   */
  routeId?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      routeId: 'RouteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      routeId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned. A value of 200 indicates that the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data returned.
   */
  data?: GetGatewayRouteDetailResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * FDF2D16C-5D28-5FAA-A56B-30BDE3559880
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GetGatewayRouteDetailResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetGatewayRouteDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetGatewayRouteDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayServiceDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-f4c960ad071a48a790b36324394c****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the service.
   * 
   * @example
   * 35
   */
  serviceId?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      serviceId: 'ServiceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      serviceId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayServiceDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 1
   */
  code?: number;
  /**
   * @remarks
   * The data returned.
   */
  data?: GetGatewayServiceDetailResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9802C54E-5CC5-5706-927B-993DBB6DCF2F
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GetGatewayServiceDetailResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayServiceDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetGatewayServiceDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetGatewayServiceDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGovernanceKubernetesClusterRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cd23228b3c80c4d4f9ad7af1d87cc****
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the region in which the instance resides. The region is supported by MSE.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGovernanceKubernetesClusterResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   */
  data?: GetGovernanceKubernetesClusterResponseBodyData;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 5B170A0D-2C5D-4CF8-B808-03966B86****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetGovernanceKubernetesClusterResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGovernanceKubernetesClusterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetGovernanceKubernetesClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetGovernanceKubernetesClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetImageRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The version number of the current instance.
   * 
   * This parameter is required.
   * 
   * @example
   * ZooKeeper_3_5_5
   */
  versionCode?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      versionCode: 'VersionCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      versionCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetImageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   */
  data?: GetImageResponseBodyData;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 25EA0A83-9007-4E87-808C-637BE1A****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetImageResponseBodyData,
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetImageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetImageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetImageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetImportFileUrlRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The file type.
   * 
   * @example
   * application/zip
   */
  contentType?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse_prepaid_public_cn-7pp2b****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 12788f73-9848-4388-98f1-507778f2****
   */
  namespaceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      contentType: 'ContentType',
      instanceId: 'InstanceId',
      namespaceId: 'NamespaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      contentType: 'string',
      instanceId: 'string',
      namespaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetImportFileUrlResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The details of the data.
   */
  data?: GetImportFileUrlResponseBodyData;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the \\\\*\\\\*%s\\\\*\\\\* variable in the **ErrMessage** parameter.\\n\\n>  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 19488A00-4AF5-55E1-A689-98BA9F5E7441
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * *   `true`: The request was successful. 
   * *  `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GetImportFileUrlResponseBodyData,
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetImportFileUrlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetImportFileUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetImportFileUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKubernetesSourceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-c5d1aadb7df646cfb7065fbf75c1****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * Specifies whether to obtain the information about all Kubernetes clusters. If you set the value to false, only the information about unassociated clusters is obtained.
   */
  isAll?: boolean;
  /**
   * @remarks
   * The ID of the virtual private cloud (VPC).
   * 
   * @example
   * vpc-bp1t50e045b5g7i3p****
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      isAll: 'IsAll',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      isAll: 'boolean',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKubernetesSourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data returned.
   */
  data?: GetKubernetesSourceResponseBodyData[];
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 1085A66C-DEF1-58EE-A0A4-31E00C9FC0D5
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': GetKubernetesSourceResponseBodyData },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKubernetesSourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetKubernetesSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetKubernetesSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLosslessRuleByAppRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the application.
   * 
   * @example
   * hkhon1po62@c3df23522baa***
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * example-app
   */
  appName?: string;
  /**
   * @remarks
   * The name of the MSE namespace.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      namespace: 'Namespace',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      namespace: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLosslessRuleByAppResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data returned.
   */
  data?: GetLosslessRuleByAppResponseBodyData;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Success
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DC34E4A3-5F1C-4E40-86EA-02EDF967****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true: The request was successful.
   * *   false: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GetLosslessRuleByAppResponseBodyData,
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLosslessRuleByAppResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetLosslessRuleByAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetLosslessRuleByAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMseFeatureSwitchRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMseFeatureSwitchResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * NoPermission
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6B4653A3-8D9C-5FDC-BB0C-936D40E9794B
   */
  requestId?: string;
  /**
   * @remarks
   * The returned result.
   * 
   * @example
   * {\\"nacos_config_encrypt\\": False}
   */
  result?: { [key: string]: any };
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      result: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMseFeatureSwitchResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMseFeatureSwitchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMseFeatureSwitchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMseSourceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-7ea3da97b96543e19f6c597cd4a9****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The MSE engine type. Valid values:
   * 
   * *   NACOS
   * *   ZOOKEEPER
   * 
   * @example
   * NACOS
   */
  type?: string;
  /**
   * @remarks
   * VPC ID
   * 
   * @example
   * vpc-bp1t50e045b5g7i3p****
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      type: 'Type',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      type: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMseSourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 1
   */
  code?: number;
  /**
   * @remarks
   * The data structure.
   */
  data?: GetMseSourceResponseBodyData[];
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * *   If the request is successful, a success message is returned.
   * *   If the request fails, an error message is returned, such as the "TaskId not found" message.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 5EB2D865-B43F-5526-8F92-857718CF73A2
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': GetMseSourceResponseBodyData },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMseSourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMseSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMseSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNacosConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to perform a beta release. Valid values:
   * 
   * *   `true`: yes
   * *   `false`: no
   * 
   * @example
   * true
   */
  beta?: boolean;
  /**
   * @remarks
   * The ID of the data.
   * 
   * This parameter is required.
   * 
   * @example
   * halvie-mp-item****
   */
  dataId?: string;
  /**
   * @remarks
   * The name of the configuration group.
   * 
   * This parameter is required.
   * 
   * @example
   * common
   */
  group?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse-cn-i7m2h0****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * ddaf8f12-****-b1c1-86e7c72e266b
   */
  namespaceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      beta: 'Beta',
      dataId: 'DataId',
      group: 'Group',
      instanceId: 'InstanceId',
      namespaceId: 'NamespaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      beta: 'boolean',
      dataId: 'string',
      group: 'string',
      instanceId: 'string',
      namespaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNacosConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The configuration information.
   */
  configuration?: GetNacosConfigResponseBodyConfiguration;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * B4EAB48C-BB4B-5B8D-B33B-35D69606C5AD
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: GetNacosConfigResponseBodyConfiguration,
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNacosConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetNacosConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetNacosConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNacosHistoryConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the data.
   * 
   * This parameter is required.
   * 
   * @example
   * msg-center.main.yaml
   */
  dataId?: string;
  /**
   * @remarks
   * The name of the group.
   * 
   * This parameter is required.
   * 
   * @example
   * DEFAULT_GROUP
   */
  group?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse_prepaid_public_cn-st220g9ka02
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 6cf708a5-****-89f2-3ba62c5ee9ba
   */
  namespaceId?: string;
  /**
   * @remarks
   * The version ID of the configuration.
   * 
   * This parameter is required.
   * 
   * @example
   * 40****
   */
  nid?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      dataId: 'DataId',
      group: 'Group',
      instanceId: 'InstanceId',
      namespaceId: 'NamespaceId',
      nid: 'Nid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      dataId: 'string',
      group: 'string',
      instanceId: 'string',
      namespaceId: 'string',
      nid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNacosHistoryConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The configuration information.
   */
  configuration?: GetNacosHistoryConfigResponseBodyConfiguration;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * NoPermission
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 69AD2AA7-DB47-449B-941B-B14409DF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: GetNacosHistoryConfigResponseBodyConfiguration,
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNacosHistoryConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetNacosHistoryConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetNacosHistoryConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOverviewRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The query time. Unit: days. For example, if you set this parameter to 30, the governance rules within the last 30 days are queried.
   * 
   * @example
   * 1
   */
  period?: number;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      period: 'Period',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      period: 'number',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOverviewResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 1
   */
  code?: number;
  /**
   * @remarks
   * The details of the data.
   * 
   * @example
   * data
   */
  data?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 52BA6DA6-A702-4362-A32F-DFF79655****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOverviewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOverviewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOverviewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPluginConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * zh: Chinese en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-ubuwqygbq4783gqb2y3f87q****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the gateway plug-in.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  pluginId?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      pluginId: 'PluginId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      pluginId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPluginConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   */
  data?: GetPluginConfigResponseBodyData;
  /**
   * @remarks
   * The dynamic error code.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic error message.
   * 
   * @example
   * message
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * 500
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 03A3E2F4-6804-5663-9D5D-2EC47A1*****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GetPluginConfigResponseBodyData,
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPluginConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPluginConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPluginConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPluginsRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * zh: Chinese en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The type of the plug-in. Valid values:
   * 
   * *   0: custom
   * *   1: permission authorization
   * *   2: security protection
   * *   3: transmission protocol
   * *   4: traffic control
   * *   5: traffic observation
   * 
   * @example
   * 1
   */
  category?: number;
  /**
   * @remarks
   * Specifies whether to enable the plug-in.
   * 
   * @example
   * true
   */
  enableOnly?: boolean;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-0adf3ad751284cc69fcf9669fba*****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The name of the plug-in.
   * 
   * @example
   * key-auth
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      category: 'Category',
      enableOnly: 'EnableOnly',
      gatewayUniqueId: 'GatewayUniqueId',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      category: 'number',
      enableOnly: 'boolean',
      gatewayUniqueId: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPluginsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned code.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data entries returned.
   */
  data?: GetPluginsResponseBodyData[];
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic error message.
   * 
   * @example
   * message
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * 500
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 03A3E2F4-6804-5663-9D5D-2EC47A1*****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': GetPluginsResponseBodyData },
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPluginsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPluginsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPluginsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceListRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * xxx@xxx
   */
  appId?: string;
  /**
   * @remarks
   * The IP address.
   * 
   * @example
   * 127.0.0.1
   */
  ip?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-zhangjiakou
   */
  region?: string;
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * com.alibaba.xxx
   */
  serviceName?: string;
  /**
   * @remarks
   * The type of the framework.
   * 
   * @example
   * dubbo
   */
  serviceType?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      ip: 'Ip',
      region: 'Region',
      serviceName: 'ServiceName',
      serviceType: 'ServiceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      ip: 'string',
      region: 'string',
      serviceName: 'string',
      serviceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data entries returned.
   */
  data?: GetServiceListResponseBodyData[];
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * xxx-xxx-xxx
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': GetServiceListResponseBodyData },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetServiceListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetServiceListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceListPageRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values: zh and en. Default value: zh. The value zh indicates Chinese, and the value en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * dez4xxxxx@f3f75ed8ffxxxxx
   */
  appId?: string;
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * example-app
   */
  appName?: string;
  /**
   * @remarks
   * The IP address from which the query is initiated.
   * 
   * @example
   * 223.5.5.5
   */
  ip?: string;
  /**
   * @remarks
   * The name of the MSE namespace.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The service name.
   * 
   * @example
   * sc-A
   */
  serviceName?: string;
  /**
   * @remarks
   * The service type.
   * 
   * @example
   * springCloud
   */
  serviceType?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      ip: 'Ip',
      namespace: 'Namespace',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      region: 'Region',
      serviceName: 'ServiceName',
      serviceType: 'ServiceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      ip: 'string',
      namespace: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      region: 'string',
      serviceName: 'string',
      serviceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceListPageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response to the request.
   */
  data?: GetServiceListPageResponseBodyData;
  /**
   * @remarks
   * The request information.
   * 
   * @example
   * OK
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * A2F946FB-F2E3-5BF4-8CBE-xxxxxxxx
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetServiceListPageResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceListPageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetServiceListPageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetServiceListPageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceListenersRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the MSE instance to which the service belongs.
   * 
   * >  You must specify InstanceId or ClusterId.
   * 
   * @example
   * mse-09k1q11****
   * 
   * @deprecated
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the cluster to which the service belongs.
   * 
   * > The cluster is a concept for Nacos services and is not equivalent to a Microservices Engine (MSE) instance.
   * 
   * @example
   * DEFAULT
   */
  clusterName?: string;
  /**
   * @remarks
   * The group to which the service belongs.
   * 
   * @example
   * WEB_GROUP
   */
  groupName?: string;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * none
   */
  hasIpCount?: string;
  /**
   * @remarks
   * The ID of the instance to which the service belongs.
   * 
   * > You must specify InstanceId or ClusterId.
   * 
   * @example
   * mse_prepaid_public_cn-tl32odtt20j
   */
  instanceId?: string;
  /**
   * @remarks
   * The namespace to which the service belongs.
   * 
   * @example
   * ddaf8f12-****-b1c1-86e7c72e266b
   */
  namespaceId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  /**
   * @remarks
   * The name of the service whose listeners you want to query.
   * 
   * @example
   * zeekr-orderboss
   */
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      groupName: 'GroupName',
      hasIpCount: 'HasIpCount',
      instanceId: 'InstanceId',
      namespaceId: 'NamespaceId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      requestPars: 'RequestPars',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      clusterName: 'string',
      groupName: 'string',
      hasIpCount: 'string',
      instanceId: 'string',
      namespaceId: 'string',
      pageNum: 'number',
      pageSize: 'number',
      regionId: 'string',
      requestPars: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceListenersResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data.
   */
  data?: GetServiceListenersResponseBodyData[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 202
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * *   If the request is successful, a success message is returned.
   * *   If the request fails, an error message is returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 54973C90-F379-4372-9AA5-053A3F7****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The number of listeners that are queried.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': GetServiceListenersResponseBodyData },
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceListenersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetServiceListenersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetServiceListenersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceMethodPageRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @example
   * hkhonxxxxx@f3f75ed8ffxxxxx
   */
  appId?: string;
  /**
   * @example
   * example-app
   */
  appName?: string;
  /**
   * @example
   * 223.5.5.5
   */
  ip?: string;
  /**
   * @example
   * com.alibabacloud.mse.demo.a.AController
   */
  methodController?: string;
  /**
   * @example
   * aMethod
   */
  name?: string;
  /**
   * @example
   * default
   */
  namespace?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * /a
   */
  path?: string;
  /**
   * @example
   * cn-hangzhou
   */
  region?: string;
  serviceGroup?: string;
  /**
   * @example
   * sc-A
   */
  serviceName?: string;
  /**
   * @example
   * springCloud
   */
  serviceType?: string;
  /**
   * @example
   * 1.0.0
   */
  serviceVersion?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      ip: 'Ip',
      methodController: 'MethodController',
      name: 'Name',
      namespace: 'Namespace',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      path: 'Path',
      region: 'Region',
      serviceGroup: 'ServiceGroup',
      serviceName: 'ServiceName',
      serviceType: 'ServiceType',
      serviceVersion: 'ServiceVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      ip: 'string',
      methodController: 'string',
      name: 'string',
      namespace: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      path: 'string',
      region: 'string',
      serviceGroup: 'string',
      serviceName: 'string',
      serviceType: 'string',
      serviceVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceMethodPageResponseBody extends $tea.Model {
  data?: GetServiceMethodPageResponseBodyData;
  /**
   * @example
   * OK
   */
  message?: string;
  /**
   * @example
   * 2DD5A212-C77B-3XXF-9XXE-XXX9XXXE5XX1
   */
  requestId?: string;
  /**
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetServiceMethodPageResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceMethodPageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetServiceMethodPageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetServiceMethodPageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTagsBySwimmingLaneGroupIdRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the lane group.
   * 
   * This parameter is required.
   * 
   * @example
   * 154
   */
  groupId?: number;
  /**
   * @remarks
   * The name of the Microservices Engine (MSE) namespace that you want to query.
   * 
   * @example
   * default
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      groupId: 'GroupId',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      groupId: 'number',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTagsBySwimmingLaneGroupIdResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data of the tag.
   * 
   * @example
   * ["gray"]
   */
  data?: string[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 69AD2AA7-DB47-449B-941B-B14409DF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': 'string' },
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTagsBySwimmingLaneGroupIdResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTagsBySwimmingLaneGroupIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTagsBySwimmingLaneGroupIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetZookeeperDataImportUrlRequest extends $tea.Model {
  /**
   * @remarks
   * RestResult
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zip
   */
  contentType?: string;
  /**
   * @remarks
   * The type of the file.
   * 
   * @example
   * mse_prepaid_public_cn-zvp2xzzkk06
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      contentType: 'ContentType',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      contentType: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetZookeeperDataImportUrlResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The URL that is used to upload the configuration file.
   */
  data?: GetZookeeperDataImportUrlResponseBodyData;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the \\*\\*%s\\*\\* variable in the **ErrMessage** parameter.
   * 
   * >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The returned data.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request was successfully processed.
   * 
   * @example
   * The dynamic part in the error message.
   */
  message?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * E4E2058F-C524-5C29-9BC7-5874EA8D7CE2
   */
  requestId?: string;
  /**
   * @remarks
   * The status code. A value of 200 is returned if the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GetZookeeperDataImportUrlResponseBodyData,
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetZookeeperDataImportUrlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetZookeeperDataImportUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetZookeeperDataImportUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportNacosConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * This parameter is required.
   * 
   * @example
   * http://mse-shared.oss-xxx.aliyuncs.com/cfg/import/xxxx/2021/01/11/xxxx.zip
   */
  fileUrl?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * This parameter is required.
   * 
   * @example
   * mse_prepaid_public_cn-****
   */
  instanceId?: string;
  /**
   * @remarks
   * The policy.
   * 
   * @example
   * f5cdc80a-****-8094-282f5650fc00
   */
  namespaceId?: string;
  /**
   * @remarks
   * The policy.
   * 
   * Valid values:
   * 
   * *   ABORT
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   OVERWRITE
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   SKIP
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * @example
   * overwrite
   */
  policy?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      fileUrl: 'FileUrl',
      instanceId: 'InstanceId',
      namespaceId: 'NamespaceId',
      policy: 'Policy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      fileUrl: 'string',
      instanceId: 'string',
      namespaceId: 'string',
      policy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportNacosConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * 1
   */
  code?: number;
  /**
   * @remarks
   * The number of configurations that are imported.
   */
  data?: ImportNacosConfigResponseBodyData;
  /**
   * @remarks
   * The details of the data.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The code returned.
   * 
   * @example
   * mse-100-100
   */
  errorCode?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request is successfully processed.
   * 
   * @example
   * The dynamic part in the error message. This parameter is used to replace the **%s** variable in the **ErrMessage** parameter.
   * 
   * >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   */
  message?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * AF21683A-29C7-4853-AC0F-B5ADEE4****
   */
  requestId?: string;
  /**
   * @remarks
   * The error code that is returned.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: ImportNacosConfigResponseBodyData,
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportNacosConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ImportNacosConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ImportNacosConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportServicesRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  fcAlias?: string;
  fcServiceName?: string;
  fcVersion?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-77e1153db6e14c0a8b1fae20bcb89ca5
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The information about services.
   * 
   * @example
   * DNS
   */
  serviceList?: ImportServicesRequestServiceList[];
  /**
   * @remarks
   * The service source. Valid values:
   * 
   * *   MSE: MSE Nacos instance
   * *   K8s: ACK cluster
   * *   VIP: fixed address
   * *   DNS: DNS domain
   * 
   * @example
   * DNS
   */
  sourceType?: string;
  /**
   * @remarks
   * The Transport Layer Security (TLS) settings. Valid values:
   * 
   * *   mode: TLS mode
   * *   certId: certificate ID
   * *   caCertId: CA certificate ID
   * *   caCertContent: CA certificate public key
   * *   sni: service name identification
   * 
   * @example
   * {
   *       "mode": "MUTUAL",
   *       "certId": "1*****-cn-hangzhou",
   *       "caCertContent": "123",
   *       "sni": "ceshi"
   * }
   */
  tlsSetting?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      fcAlias: 'FcAlias',
      fcServiceName: 'FcServiceName',
      fcVersion: 'FcVersion',
      gatewayUniqueId: 'GatewayUniqueId',
      serviceList: 'ServiceList',
      sourceType: 'SourceType',
      tlsSetting: 'TlsSetting',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      fcAlias: 'string',
      fcServiceName: 'string',
      fcVersion: 'string',
      gatewayUniqueId: 'string',
      serviceList: { 'type': 'array', 'itemType': ImportServicesRequestServiceList },
      sourceType: 'string',
      tlsSetting: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportServicesShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  fcAlias?: string;
  fcServiceName?: string;
  fcVersion?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-77e1153db6e14c0a8b1fae20bcb89ca5
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The information about services.
   * 
   * @example
   * DNS
   */
  serviceListShrink?: string;
  /**
   * @remarks
   * The service source. Valid values:
   * 
   * *   MSE: MSE Nacos instance
   * *   K8s: ACK cluster
   * *   VIP: fixed address
   * *   DNS: DNS domain
   * 
   * @example
   * DNS
   */
  sourceType?: string;
  /**
   * @remarks
   * The Transport Layer Security (TLS) settings. Valid values:
   * 
   * *   mode: TLS mode
   * *   certId: certificate ID
   * *   caCertId: CA certificate ID
   * *   caCertContent: CA certificate public key
   * *   sni: service name identification
   * 
   * @example
   * {
   *       "mode": "MUTUAL",
   *       "certId": "1*****-cn-hangzhou",
   *       "caCertContent": "123",
   *       "sni": "ceshi"
   * }
   */
  tlsSetting?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      fcAlias: 'FcAlias',
      fcServiceName: 'FcServiceName',
      fcVersion: 'FcVersion',
      gatewayUniqueId: 'GatewayUniqueId',
      serviceListShrink: 'ServiceList',
      sourceType: 'SourceType',
      tlsSetting: 'TlsSetting',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      fcAlias: 'string',
      fcServiceName: 'string',
      fcVersion: 'string',
      gatewayUniqueId: 'string',
      serviceListShrink: 'string',
      sourceType: 'string',
      tlsSetting: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportServicesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The result returned.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0F0FBA7D-5AC5-5DC4-A1E9-E9656BFAE1B9
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportServicesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ImportServicesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ImportServicesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportZookeeperDataRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the file that you want to import.
   * 
   * @example
   * snapshot.5
   */
  fileName?: string;
  /**
   * @remarks
   * The URL of the source data.
   * 
   * > You must set this parameter to the URL that is generated by calling the GetZookeeperDataImportUrl operation.
   * 
   * @example
   * http://xxxxxxxxxx
   */
  fileUrl?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse_prepaid_public_cn-u0t2xzvxa06
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      fileName: 'FileName',
      fileUrl: 'FileUrl',
      instanceId: 'InstanceId',
      regionId: 'RegionId',
      requestPars: 'RequestPars',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      fileName: 'string',
      fileUrl: 'string',
      instanceId: 'string',
      regionId: 'string',
      requestPars: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportZookeeperDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   * 
   * @example
   * null
   */
  data?: any;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 202
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 52BA6DA6-A702-4362-A32F-DFF79655****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'any',
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportZookeeperDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ImportZookeeperDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ImportZookeeperDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnsInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the Nacos instance.
   * 
   * > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
   * 
   * @example
   * mse-09k1q11****
   * 
   * @deprecated
   */
  clusterId?: string;
  /**
   * @remarks
   * The alias of the Nacos instance.
   * 
   * @example
   * mse-7413****
   */
  clusterName?: string;
  /**
   * @remarks
   * The name of the contact group.
   * 
   * @example
   * test
   */
  groupName?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
   * 
   * @example
   * mse_prepaid_public_cn-tl327w****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 12233****
   */
  namespaceId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  /**
   * @remarks
   * The name of the service.
   * 
   * This parameter is required.
   * 
   * @example
   * name
   */
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      groupName: 'GroupName',
      instanceId: 'InstanceId',
      namespaceId: 'NamespaceId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      requestPars: 'RequestPars',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      clusterName: 'string',
      groupName: 'string',
      instanceId: 'string',
      namespaceId: 'string',
      pageNum: 'number',
      pageSize: 'number',
      requestPars: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnsInstancesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   */
  data?: ListAnsInstancesResponseBodyData[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 202
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 52BA6DA6-A702-4362-A32F-DFF79655****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of returned instances.
   * 
   * @example
   * 7
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListAnsInstancesResponseBodyData },
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnsInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListAnsInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAnsInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnsServiceClustersRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the MSE cluster.
   * 
   * >  The MSE cluster is different from the cluster of the Nacos service.
   * 
   * @example
   * mse-09k1q110q01
   * 
   * @deprecated
   */
  clusterId?: string;
  /**
   * @remarks
   * The alias of the cluster.
   * 
   * @example
   * mse-7413****
   */
  clusterName?: string;
  /**
   * @remarks
   * The name of the group.
   * 
   * @example
   * DEFAULT_GROUP
   */
  groupName?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse_prepaid_public_cn-tl32a6****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 12233****
   */
  namespaceId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * nacos.test.3
   */
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      groupName: 'GroupName',
      instanceId: 'InstanceId',
      namespaceId: 'NamespaceId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      clusterName: 'string',
      groupName: 'string',
      instanceId: 'string',
      namespaceId: 'string',
      pageNum: 'number',
      pageSize: 'number',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnsServiceClustersResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned.
   */
  data?: ListAnsServiceClustersResponseBodyData;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 52BA6DA6-A702-4362-A32F-DFF79655****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListAnsServiceClustersResponseBodyData,
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnsServiceClustersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListAnsServiceClustersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAnsServiceClustersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnsServicesRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
   * 
   * @example
   * mse-09k1q11****
   * 
   * @deprecated
   */
  clusterId?: string;
  /**
   * @remarks
   * 查询服务下某个集群的实例列表是所需要的参数
   */
  clusterName?: string;
  /**
   * @remarks
   * The name of the contact group.
   * 
   * @example
   * name
   */
  groupName?: string;
  /**
   * @remarks
   * Specifies whether to query the number of instances that are used for the service.
   * 
   * @example
   * true
   */
  hasIpCount?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
   * 
   * @example
   * mse-cn-st21v5****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 12233****
   */
  namespaceId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  regionId?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * name
   */
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      groupName: 'GroupName',
      hasIpCount: 'HasIpCount',
      instanceId: 'InstanceId',
      namespaceId: 'NamespaceId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      requestPars: 'RequestPars',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      clusterName: 'string',
      groupName: 'string',
      hasIpCount: 'string',
      instanceId: 'string',
      namespaceId: 'string',
      pageNum: 'number',
      pageSize: 'number',
      regionId: 'string',
      requestPars: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnsServicesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   */
  data?: ListAnsServicesResponseBodyData[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 202
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 52BA6DA6-A702-4362-A32F-DFF79655****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of instances returned.
   * 
   * @example
   * 7
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListAnsServicesResponseBodyData },
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnsServicesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListAnsServicesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAnsServicesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAppBySwimmingLaneGroupTagRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the lane group.
   * 
   * This parameter is required.
   * 
   * @example
   * 119
   */
  groupId?: number;
  /**
   * @remarks
   * The name of the Microservices Engine (MSE) namespace that you want to query.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The tag.
   * 
   * This parameter is required.
   * 
   * @example
   * gray
   */
  tag?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      groupId: 'GroupId',
      namespace: 'Namespace',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      groupId: 'number',
      namespace: 'string',
      tag: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAppBySwimmingLaneGroupTagResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   * 
   * @example
   * [{appName:"test",appId:"hkhon1po62@958bba95910341f
   * "}]
   */
  data?: any;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7466566F-F30F-4A29-965D-3E0AF21D****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'any',
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAppBySwimmingLaneGroupTagResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListAppBySwimmingLaneGroupTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAppBySwimmingLaneGroupTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAppBySwimmingLaneGroupTagsRequest extends $tea.Model {
  /**
   * @remarks
   * The language in which you want to display the results. Valid values: zh and en. zh indicates Chinese, which is the default value. en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the lane group.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  groupId?: number;
  /**
   * @remarks
   * The name of the MSE namespace that you want to query.
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The tag based on which you want to list applications.
   */
  tags?: string[];
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      groupId: 'GroupId',
      namespace: 'Namespace',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      groupId: 'number',
      namespace: 'string',
      tags: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAppBySwimmingLaneGroupTagsShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language in which you want to display the results. Valid values: zh and en. zh indicates Chinese, which is the default value. en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the lane group.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  groupId?: number;
  /**
   * @remarks
   * The name of the MSE namespace that you want to query.
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The tag based on which you want to list applications.
   */
  tagsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      groupId: 'GroupId',
      namespace: 'Namespace',
      tagsShrink: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      groupId: 'number',
      namespace: 'string',
      tagsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAppBySwimmingLaneGroupTagsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data.
   */
  data?: { [key: string]: DataValue[] };
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Success
   */
  errorCode?: string;
  /**
   * @remarks
   * The additional request information.
   * 
   * @example
   * OK
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6832e76b-bb5f-4dea-****-************
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DataValue } },
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAppBySwimmingLaneGroupTagsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListAppBySwimmingLaneGroupTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAppBySwimmingLaneGroupTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsWithTagRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the application.
   * 
   * @example
   * xjpc0h9h4d@xxx
   * 
   * @deprecated
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * test
   */
  appName?: string;
  /**
   * @remarks
   * The MSE namespace to which the application belongs.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The source of the routing rule. Default value: edasmsc.
   * 
   * @example
   * edasmsc
   */
  source?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      namespace: 'Namespace',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      region: 'Region',
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      namespace: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      region: 'string',
      source: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsWithTagRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response parameters.
   */
  data?: ListApplicationsWithTagRulesResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * *   If the request is successful, a success message is returned.
   * *   If the request fails, an error message is returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7466566F-F30F-4A29-965D-3E0AF21D****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListApplicationsWithTagRulesResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsWithTagRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListApplicationsWithTagRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListApplicationsWithTagRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAuthPolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values: zh-CN and en-US. Default value: zh-CN. The value zh-CN indicates Chinese and the value en-US indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * jgy4cadmqo@***
   */
  appId?: string;
  /**
   * @remarks
   * The name of the authentication rule.
   * 
   * @example
   * auto-rule-**
   */
  name?: string;
  /**
   * @remarks
   * The name of the Microservices Engine (MSE) namespace.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The page number.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: string;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: string;
  /**
   * @remarks
   * The protocol type. Valid values:
   * 
   * *   **SPRING_CLOUD**
   * *   **DUBBO**
   * *   **istio**
   * 
   * @example
   * SPRING_CLOUD
   */
  protocol?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-shanghai
   */
  region?: string;
  /**
   * @remarks
   * The service source.
   * 
   * This parameter is required.
   * 
   * @example
   * edasmsc
   */
  source?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      name: 'Name',
      namespace: 'Namespace',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      protocol: 'Protocol',
      region: 'Region',
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      name: 'string',
      namespace: 'string',
      pageNumber: 'string',
      pageSize: 'string',
      protocol: 'string',
      region: 'string',
      source: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAuthPolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The details of the data.
   */
  data?: ListAuthPolicyResponseBodyData;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The returned message.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 05A5A150-4A5F-5A8C-97D6-710776CC8408
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: ListAuthPolicyResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAuthPolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListAuthPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAuthPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCircuitBreakerRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values: zh-CN and en-US. Default value: zh-CN. The value zh-CN indicates Chinese, and the value en-US indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the application.
   * 
   * @example
   * hkhon1po62@c3df23522bXXXXX
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * The microservice namespace to which the application belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The start page of the returned pages. Default value: 1.
   * 
   * @example
   * 1
   */
  pageIndex?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 6.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * This parameter is used for exact match of circuit breaking rules.
   * 
   * @example
   * /a
   */
  resource?: string;
  /**
   * @remarks
   * This parameter is used for fuzzy match of circuit breaking rules.
   * 
   * @example
   * a
   */
  resourceSearchKey?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      namespace: 'Namespace',
      pageIndex: 'PageIndex',
      pageSize: 'PageSize',
      resource: 'Resource',
      resourceSearchKey: 'ResourceSearchKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      namespace: 'string',
      pageIndex: 'number',
      pageSize: 'number',
      resource: 'string',
      resourceSearchKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCircuitBreakerRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The details of the rule.
   */
  data?: ListCircuitBreakerRulesResponseBodyData;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * OK
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4E9FDCFE-0738-493B-B801-82BDFBCB****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: ListCircuitBreakerRulesResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCircuitBreakerRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCircuitBreakerRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCircuitBreakerRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterConnectionTypesRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterConnectionTypesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The details of the data.
   */
  data?: ListClusterConnectionTypesResponseBodyData[];
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the **%s** variable in the **ErrMessage** parameter.
   * 
   * >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 8625467C-27DD-5711-878E-6857E3074937
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': ListClusterConnectionTypesResponseBodyData },
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterConnectionTypesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListClusterConnectionTypesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListClusterConnectionTypesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHealthCheckTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse_prepaid_public_cn-7pp2o4wfx01
   */
  instanceId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 0
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The region in which the instance resides.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      instanceId: 'InstanceId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      requestPars: 'RequestPars',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      instanceId: 'string',
      pageNum: 'number',
      pageSize: 'number',
      regionId: 'string',
      requestPars: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHealthCheckTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. A value of 200 is returned if the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The details of the data.
   */
  data?: ListClusterHealthCheckTaskResponseBodyData;
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the \\*\\*%s\\*\\* variable in the **ErrMessage** parameter.
   * 
   * > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code returned if the request failed. Take note of the following rules:
   * 
   * *   The **ErrorCode** parameter is not returned if the request is successful.
   * *   The **ErrorCode** parameter is returned if the request fails. For more information, see the **Error codes** section in this topic.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4E9FDCFE-0738-493B-B801-82BDFBCB****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: ListClusterHealthCheckTaskResponseBodyData,
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHealthCheckTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListClusterHealthCheckTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListClusterHealthCheckTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterTypesRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The network type. Valid values:
   * 
   * *   slb
   * *   eni
   * 
   * @example
   * slb
   */
  connectType?: string;
  /**
   * @remarks
   * The edition of the MSE instance that you want to purchase.
   * 
   * *   mse_pro: Professional Edition
   * *   mse_dev: Developer Edition
   * 
   * @example
   * mse_pro
   */
  mseVersion?: string;
  /**
   * @remarks
   * The ID of the region in which the instance resides. The region is supported by Microservices Engine (MSE).
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      connectType: 'ConnectType',
      mseVersion: 'MseVersion',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      connectType: 'string',
      mseVersion: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterTypesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data entries returned.
   */
  data?: ListClusterTypesResponseBodyData[];
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the \\*\\*%s\\*\\* variable in the **ErrMessage** parameter.
   * 
   * > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 821B5B05-8919-5FBB-BA75-417BFC093EB8
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': ListClusterTypesResponseBodyData },
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterTypesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListClusterTypesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListClusterTypesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterVersionsRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The type of the instance. Valid values: ZooKeeper, Nacos-Ans, and Eureka.
   * 
   * @example
   * Nacos-Ans
   */
  clusterType?: string;
  /**
   * @remarks
   * The instance edition. Valid values:
   * 
   * *   `mse_dev`: Developer Edition.
   * *   `mse_pro`: Professional Edition. This is the default value.
   * 
   * @example
   * mse_pro
   */
  mseVersion?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterType: 'ClusterType',
      mseVersion: 'MseVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterType: 'string',
      mseVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterVersionsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The details of the data.
   */
  data?: ListClusterVersionsResponseBodyData[];
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7717BE5B-C958-5F87-BF49-464AA276EDD1
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': ListClusterVersionsResponseBodyData },
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterVersionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListClusterVersionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListClusterVersionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The alias of the instance. Fuzzy match is supported.
   * 
   * @example
   * cluster
   */
  clusterAliasName?: string;
  keyId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the region in which the instance resides. The region is supported by MSE.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  /**
   * @remarks
   * The ID of the resource group. For more information about resource groups, see the topic "View basic information of a resource group."
   * 
   * @example
   * rg-acfmxbzafebvvfa
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The list of tags. A maximum number of 20 tags are supported.
   */
  tag?: ListClustersRequestTag[];
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterAliasName: 'ClusterAliasName',
      keyId: 'KeyId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      requestPars: 'RequestPars',
      resourceGroupId: 'ResourceGroupId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterAliasName: 'string',
      keyId: 'string',
      pageNum: 'number',
      pageSize: 'number',
      regionId: 'string',
      requestPars: 'string',
      resourceGroupId: 'string',
      tag: { 'type': 'array', 'itemType': ListClustersRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   */
  data?: ListClustersResponseBodyData[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 202
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 69AD2AA7-DB47-449B-941B-B14409DF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of returned instances.
   * 
   * @example
   * 7
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListClustersResponseBodyData },
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListClustersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListClustersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListConfigTrackRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the configuration.
   * 
   * @example
   * ballot
   */
  dataId?: string;
  /**
   * @remarks
   * The end timestamp. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1657178373
   */
  endTs?: number;
  /**
   * @remarks
   * The name of the configuration group.
   * 
   * @example
   * DEFAULT_GROUP
   */
  group?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse_prepaid_public_cn-i7m2ne****
   */
  instanceId?: string;
  /**
   * @remarks
   * The IP address of the listener.
   * 
   * @example
   * 192.168.22.2
   */
  ip?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * f3a510e2-df52-4fad-9815-42d8bc40****
   */
  namespaceId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  /**
   * @remarks
   * Specifies whether to enable reverse ordering. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  reverse?: boolean;
  /**
   * @remarks
   * The start timestamp. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1671010148
   */
  startTs?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      dataId: 'DataId',
      endTs: 'EndTs',
      group: 'Group',
      instanceId: 'InstanceId',
      ip: 'Ip',
      namespaceId: 'NamespaceId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      requestPars: 'RequestPars',
      reverse: 'Reverse',
      startTs: 'StartTs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      dataId: 'string',
      endTs: 'number',
      group: 'string',
      instanceId: 'string',
      ip: 'string',
      namespaceId: 'string',
      pageNum: 'number',
      pageSize: 'number',
      requestPars: 'string',
      reverse: 'boolean',
      startTs: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListConfigTrackResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0CE3ABD2-1E04-561F-A9B4-0423D50****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 3
   */
  totalCount?: number;
  /**
   * @remarks
   * The track data.
   */
  traces?: ListConfigTrackResponseBodyTraces[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
      traces: 'Traces',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
      traces: { 'type': 'array', 'itemType': ListConfigTrackResponseBodyTraces },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListConfigTrackResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListConfigTrackResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListConfigTrackResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEngineNamespacesRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-cn-st21ri2****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEngineNamespacesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   */
  data?: ListEngineNamespacesResponseBodyData[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 202
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 062D13C5-DEA3-4921-8918-C49A0F1B****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of returned instances.
   * 
   * @example
   * 7
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListEngineNamespacesResponseBodyData },
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEngineNamespacesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEngineNamespacesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEngineNamespacesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEurekaInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-09k1q11****
   */
  clusterId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  /**
   * @remarks
   * The name of the service.
   * 
   * This parameter is required.
   * 
   * @example
   * name
   */
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      requestPars: 'RequestPars',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      pageNum: 'number',
      pageSize: 'number',
      requestPars: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEurekaInstancesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   */
  data?: ListEurekaInstancesResponseBodyData[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 202
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 316F5F64-F73D-42DC-8632-01E308B6****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of returned instances.
   * 
   * @example
   * 7
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListEurekaInstancesResponseBodyData },
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEurekaInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEurekaInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEurekaInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEurekaServicesRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse-09k1q11****
   */
  clusterId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      requestPars: 'RequestPars',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      pageNum: 'number',
      pageSize: 'number',
      regionId: 'string',
      requestPars: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEurekaServicesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   */
  data?: ListEurekaServicesResponseBodyData[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 202
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 316F5F64-F73D-42DC-8632-01E308B6****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of returned instances.
   * 
   * @example
   * 7
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListEurekaServicesResponseBodyData },
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEurekaServicesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEurekaServicesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEurekaServicesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListExportZookeeperDataRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-cn-7pp2d1****
   */
  instanceId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 0
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListExportZookeeperDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   */
  data?: ListExportZookeeperDataResponseBodyData[];
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the \\*\\*%s\\*\\* variable in the **ErrMessage** parameter.
   * 
   * > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 8BD1E58D-0755-42AC-A599-E6B55112****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListExportZookeeperDataResponseBodyData },
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListExportZookeeperDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListExportZookeeperDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListExportZookeeperDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the application.
   * 
   * @example
   * hkhon1po62@c3df23522******
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * xx-demo
   */
  appName?: string;
  /**
   * @remarks
   * The namespace.
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The page number. Default value: 1.
   * 
   * @example
   * 1
   */
  pageIndex?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The name of the resource.
   * 
   * @example
   * /a
   */
  resource?: string;
  /**
   * @remarks
   * The keyword that is used for the search.
   * 
   * @example
   * /a
   */
  resourceSearchKey?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      namespace: 'Namespace',
      pageIndex: 'PageIndex',
      pageSize: 'PageSize',
      resource: 'Resource',
      resourceSearchKey: 'ResourceSearchKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      namespace: 'string',
      pageIndex: 'number',
      pageSize: 'number',
      resource: 'string',
      resourceSearchKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The details of the data.
   */
  data?: ListFlowRulesResponseBodyData;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The returned message.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 316F5F64-F73D-42DC-8632-01E308B6****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * Valid values:
   * 
   * *   true
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     The request was successful.
   * 
   *     <!-- -->
   * 
   * *   false
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     The request failed.
   * 
   *     <!-- -->
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: ListFlowRulesResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListFlowRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListFlowRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to enable the sorting feature. This feature is not available.
   * 
   * @example
   * false
   */
  descSort?: boolean;
  /**
   * @remarks
   * The details of parameters.
   */
  filterParams?: ListGatewayRequestFilterParams;
  /**
   * @remarks
   * The order information.
   * 
   * @example
   * {}
   */
  orderItem?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      descSort: 'DescSort',
      filterParams: 'FilterParams',
      orderItem: 'OrderItem',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      descSort: 'boolean',
      filterParams: ListGatewayRequestFilterParams,
      orderItem: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to enable the sorting feature. This feature is not available.
   * 
   * @example
   * false
   */
  descSort?: boolean;
  /**
   * @remarks
   * The details of parameters.
   */
  filterParamsShrink?: string;
  /**
   * @remarks
   * The order information.
   * 
   * @example
   * {}
   */
  orderItem?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      descSort: 'DescSort',
      filterParamsShrink: 'FilterParams',
      orderItem: 'OrderItem',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      descSort: 'boolean',
      filterParamsShrink: 'string',
      orderItem: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayResponseBody extends $tea.Model {
  /**
   * @remarks
   * The return value.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data returned.
   */
  data?: ListGatewayResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * You are not authorized to perform this operation. Action: mse:ListGateway, Resource: acs:mse:cn-hangzhou:102123:*
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 34300B3-52EC-5049-8C96-914098CF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: ListGatewayResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListGatewayResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListGatewayResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayAuthConsumerRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The status of the consumer. Valid values:
   * 
   * *   true: enabled
   * *   false: disabled
   * 
   * @example
   * true
   */
  consumerStatus?: boolean;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-0fe488252dc44d55a9dd57875193****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The name of the consumer.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNum?: string;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: string;
  /**
   * @remarks
   * The authentication type. Valid values:
   * 
   * *   JWT
   * 
   * @example
   * JWT
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      consumerStatus: 'ConsumerStatus',
      gatewayUniqueId: 'GatewayUniqueId',
      name: 'Name',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      consumerStatus: 'boolean',
      gatewayUniqueId: 'string',
      name: 'string',
      pageNum: 'string',
      pageSize: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayAuthConsumerResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. A value of 200 is returned if the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data structure.
   */
  data?: ListGatewayAuthConsumerResponseBodyData;
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the **%s** variable in the **ErrMessage** parameter.
   * 
   * >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code that is returned.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * dc63-465d-8ef5-20dc18af****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: ListGatewayAuthConsumerResponseBodyData,
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayAuthConsumerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListGatewayAuthConsumerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListGatewayAuthConsumerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayAuthConsumerResourceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the consumer.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  consumerId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-3f97e2989c344f35ab3fd62b19f1****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNum?: string;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: string;
  /**
   * @remarks
   * The resource authorization status. Valid values:
   * 
   * *   true: enabled
   * *   false: disabled
   * 
   * @example
   * true
   */
  resourceStatus?: boolean;
  /**
   * @remarks
   * The name of the route.
   * 
   * @example
   * test
   */
  routeName?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      consumerId: 'ConsumerId',
      gatewayUniqueId: 'GatewayUniqueId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      resourceStatus: 'ResourceStatus',
      routeName: 'RouteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      consumerId: 'number',
      gatewayUniqueId: 'string',
      pageNum: 'string',
      pageSize: 'string',
      resourceStatus: 'boolean',
      routeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayAuthConsumerResourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. A value of 200 is returned if the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned result.
   */
  data?: ListGatewayAuthConsumerResourceResponseBodyData;
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the \\*\\*%s\\*\\* variable in the **ErrMessage** parameter.
   * 
   * >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code that is returned.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A73AC37C-C617-4E3A-8049-372CF49C****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: ListGatewayAuthConsumerResourceResponseBodyData,
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayAuthConsumerResourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListGatewayAuthConsumerResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListGatewayAuthConsumerResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayCircuitBreakerRuleRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * just for POP
   * 
   * This parameter is required.
   * 
   * @example
   * param
   */
  filterParams?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      filterParams: 'FilterParams',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      filterParams: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayCircuitBreakerRuleResponseBody extends $tea.Model {
  data?: ListGatewayCircuitBreakerRuleResponseBodyData;
  /**
   * @example
   * DC34E4A3-5F1C-4E40-86EA-02EDF967****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListGatewayCircuitBreakerRuleResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayCircuitBreakerRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListGatewayCircuitBreakerRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListGatewayCircuitBreakerRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-c9bc5afd61014165bd58f621b491****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The type of the domain name.
   * 
   * @example
   * All
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      domainName: 'DomainName',
      gatewayUniqueId: 'GatewayUniqueId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      domainName: 'string',
      gatewayUniqueId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The details of the data.
   */
  data?: ListGatewayDomainResponseBodyData[];
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3F5D8E93-CA66-57F1-8BCF-A223E11B6B91
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': ListGatewayDomainResponseBodyData },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListGatewayDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListGatewayDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayFlowRuleRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * just for POP
   * 
   * This parameter is required.
   * 
   * @example
   * param
   */
  filterParams?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      filterParams: 'FilterParams',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      filterParams: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayFlowRuleResponseBody extends $tea.Model {
  data?: ListGatewayFlowRuleResponseBodyData;
  /**
   * @example
   * 0951EBF0-798E-5E0B-8D38-460A14AD****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListGatewayFlowRuleResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayFlowRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListGatewayFlowRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListGatewayFlowRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayIsolationRuleRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * just for POP
   * 
   * This parameter is required.
   * 
   * @example
   * param
   */
  filterParams?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      filterParams: 'FilterParams',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      filterParams: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayIsolationRuleResponseBody extends $tea.Model {
  data?: ListGatewayIsolationRuleResponseBodyData;
  /**
   * @example
   * 6F025D43-8632-5716-AE9B-7EDDF16C****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListGatewayIsolationRuleResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayIsolationRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListGatewayIsolationRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListGatewayIsolationRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to enable sorting. This parameter is unavailable.
   * 
   * @example
   * false
   */
  descSort?: boolean;
  /**
   * @remarks
   * The parameters that specify filter conditions. The parameters are in the format of {"key1":"value1"}.
   */
  filterParams?: ListGatewayRouteRequestFilterParams;
  /**
   * @remarks
   * The item based on which entries are sorted.
   * 
   * @example
   * GmtCreate
   */
  orderItem?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      descSort: 'DescSort',
      filterParams: 'FilterParams',
      orderItem: 'OrderItem',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      descSort: 'boolean',
      filterParams: ListGatewayRouteRequestFilterParams,
      orderItem: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to enable sorting. This parameter is unavailable.
   * 
   * @example
   * false
   */
  descSort?: boolean;
  /**
   * @remarks
   * The parameters that specify filter conditions. The parameters are in the format of {"key1":"value1"}.
   */
  filterParamsShrink?: string;
  /**
   * @remarks
   * The item based on which entries are sorted.
   * 
   * @example
   * GmtCreate
   */
  orderItem?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      descSort: 'DescSort',
      filterParamsShrink: 'FilterParams',
      orderItem: 'OrderItem',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      descSort: 'boolean',
      filterParamsShrink: 'string',
      orderItem: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteResponseBody extends $tea.Model {
  /**
   * @remarks
   * The code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data returned.
   */
  data?: ListGatewayRouteResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 83F02EAB-ECDF-55C6-B332-8649E5E7AF2C
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: ListGatewayRouteResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListGatewayRouteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListGatewayRouteResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteOnAuthRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-c9bc5afd61014165bd58f621b491****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The authentication method. Valid values:
   * 
   * *   JWT
   * 
   * This parameter is required.
   * 
   * @example
   * JWT
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteOnAuthResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The details of the data.
   */
  data?: ListGatewayRouteOnAuthResponseBodyData[];
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 58E06A0A-BD2C-47A0-99C2-B100F353****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': ListGatewayRouteOnAuthResponseBodyData },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteOnAuthResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListGatewayRouteOnAuthResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListGatewayRouteOnAuthResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayServiceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to enable sorting.
   * 
   * @example
   * false
   */
  descSort?: boolean;
  /**
   * @remarks
   * The parameters that are used to specify filter conditions. The values of the parameters are in the format of {"key1":"value1"}.
   */
  filterParams?: ListGatewayServiceRequestFilterParams;
  /**
   * @remarks
   * The item based on which entries are sorted.
   * 
   * @example
   * GmtCreate
   */
  orderItem?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      descSort: 'DescSort',
      filterParams: 'FilterParams',
      orderItem: 'OrderItem',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      descSort: 'boolean',
      filterParams: ListGatewayServiceRequestFilterParams,
      orderItem: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayServiceShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to enable sorting.
   * 
   * @example
   * false
   */
  descSort?: boolean;
  /**
   * @remarks
   * The parameters that are used to specify filter conditions. The values of the parameters are in the format of {"key1":"value1"}.
   */
  filterParamsShrink?: string;
  /**
   * @remarks
   * The item based on which entries are sorted.
   * 
   * @example
   * GmtCreate
   */
  orderItem?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      descSort: 'DescSort',
      filterParamsShrink: 'FilterParams',
      orderItem: 'OrderItem',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      descSort: 'boolean',
      filterParamsShrink: 'string',
      orderItem: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayServiceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The return value.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   */
  data?: ListGatewayServiceResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F46CDBA4-B1EE-5C94-8A48-51C10177****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: ListGatewayServiceResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayServiceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListGatewayServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListGatewayServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewaySlbRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-1cef5440bf2d484db419fb264d4f****
   */
  gatewayUniqueId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewaySlbResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data entries returned.
   */
  data?: ListGatewaySlbResponseBodyData[];
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EAB345F4-3AC3-560C-B653-65717703****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': ListGatewaySlbResponseBodyData },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewaySlbResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListGatewaySlbResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListGatewaySlbResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayZoneRequest extends $tea.Model {
  /**
   * @remarks
   * The language in which you want to display the results. Valid values: zh and en. zh indicates Chinese, which is the default value. en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayZoneResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The queried zones.
   */
  data?: ListGatewayZoneResponseBodyData[];
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace %s in **ErrMessage**.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The status code.
   * 
   * @example
   * NO_PERMISSION
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * OK
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE5C32A1-BC0E-4B79-817C-103E4EDF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': ListGatewayZoneResponseBodyData },
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayZoneResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListGatewayZoneResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListGatewayZoneResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceCountRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The type of the instance. Valid values: ZooKeeper and Nacos-Ans.
   * 
   * @example
   * Nacos-Ans
   */
  clusterType?: string;
  /**
   * @remarks
   * The edition type of the instance. Valid values:
   * 
   * *   `mse_dev`: Developer Edition
   * *   `mse_pro`: Professional Edition
   * 
   * @example
   * mse_pro
   */
  mseVersion?: string;
  /**
   * @remarks
   * The ID of the region where the instance resides. Examples:
   * 
   * *   cn-hangzhou: China (Hangzhou)
   * *   cn-beijing: China (Beijing)
   * *   cn-shanghai: China (Shanghai)
   * *   cn-zhangjiakou: China (Zhangjiakou)
   * *   cn-shenzhen: China (Shenzhen)
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterType: 'ClusterType',
      mseVersion: 'MseVersion',
      regionId: 'RegionId',
      requestPars: 'RequestPars',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterType: 'string',
      mseVersion: 'string',
      regionId: 'string',
      requestPars: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceCountResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. A value of 200 is returned if the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data entries returned.
   */
  data?: number[];
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * %s
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace `%s` in the `ErrMessage` parameter.
   * 
   * >  If the return value of the `ErrMessage` parameter is `The Value of Input Parameter %s is not valid` and the return value of the `DynamicMessage` parameter is `DtsJobId`, the specified `DtsJobId` parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code returned if the request failed. If the request failed, the ErrorCode parameter is returned. For more information, see the [Error codes](https://help.aliyun.com/document_detail/456441.html) section of this topic.
   * 
   * @example
   * mse-100-100
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The returned message. If the request is successful, a success message is returned. If the request fails, an error message is returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 316F5F64-F73D-42DC-8632-01E308B6****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': 'number' },
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceCountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListInstanceCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInstanceCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListIsolationRulesRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @example
   * hkhon1po62@c3df23522bXXXXX
   */
  appId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @example
   * 1
   */
  pageIndex?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * /a
   */
  resource?: string;
  /**
   * @example
   * a
   */
  resourceSearchKey?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      namespace: 'Namespace',
      pageIndex: 'PageIndex',
      pageSize: 'PageSize',
      resource: 'Resource',
      resourceSearchKey: 'ResourceSearchKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      namespace: 'string',
      pageIndex: 'number',
      pageSize: 'number',
      resource: 'string',
      resourceSearchKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListIsolationRulesResponseBody extends $tea.Model {
  /**
   * @example
   * 200
   */
  code?: number;
  data?: ListIsolationRulesResponseBodyData;
  /**
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @example
   * OK
   */
  message?: string;
  /**
   * @example
   * 4E9FDCFE-0738-493B-B801-82BDFBCB****
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: ListIsolationRulesResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListIsolationRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListIsolationRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListIsolationRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListListenersByConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the data.
   * 
   * This parameter is required.
   * 
   * @example
   * zeekr-clueboss.yml
   */
  dataId?: string;
  /**
   * @remarks
   * The name of the group.
   * 
   * This parameter is required.
   * 
   * @example
   * prod
   */
  group?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse-cn-m7r1yurp00e
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * aaeb4d28-c9eb-4fa2-85f5-d03ce7ee8df1
   */
  namespaceId?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {\\\\"appGroup\\\\":\\\\"emas-zfive_prehost\\\\",\\\\"appName\\\\":\\\\"emas-zfive\\\\",\\\\"appStage\\\\":\\\\"PRE_PUBLISH\\\\",\\\\"appUnit\\\\":\\\\"\\\\",\\\\"bucId\\\\":\\\\"225902\\\\",\\\\"bucName\\\\":\\\\"Wireless\\\\",\\\\"provider\\\\":\\\\"aliyun\\\\"}
   */
  requestPars?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      dataId: 'DataId',
      group: 'Group',
      instanceId: 'InstanceId',
      namespaceId: 'NamespaceId',
      requestPars: 'RequestPars',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      dataId: 'string',
      group: 'string',
      instanceId: 'string',
      namespaceId: 'string',
      requestPars: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListListenersByConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 202
   */
  httpCode?: string;
  /**
   * @remarks
   * The information about listeners.
   */
  listeners?: ListListenersByConfigResponseBodyListeners[];
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 2
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 75E1442F-11EC-567A-9CF0-5A36F7904F39
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 7
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      listeners: 'Listeners',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      httpCode: 'string',
      listeners: { 'type': 'array', 'itemType': ListListenersByConfigResponseBodyListeners },
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListListenersByConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListListenersByConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListListenersByConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListListenersByIpRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse_prepaid_public_cn-i7m2cecji09
   */
  instanceId?: string;
  /**
   * @remarks
   * The IP address of the listener.
   * 
   * This parameter is required.
   * 
   * @example
   * 172.22.0.240
   */
  ip?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * ea02a522-9482-4255-bb65-dc0636d783f2
   */
  namespaceId?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      instanceId: 'InstanceId',
      ip: 'Ip',
      namespaceId: 'NamespaceId',
      requestPars: 'RequestPars',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      instanceId: 'string',
      ip: 'string',
      namespaceId: 'string',
      requestPars: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListListenersByIpResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * MSE-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 202
   */
  httpCode?: string;
  /**
   * @remarks
   * The information about listeners.
   */
  listeners?: ListListenersByIpResponseBodyListeners[];
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 54973C90-F379-4372-9AA5-053A3F7****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * True
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of returned instances.
   * 
   * @example
   * 6
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      listeners: 'Listeners',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      httpCode: 'string',
      listeners: { 'type': 'array', 'itemType': ListListenersByIpResponseBodyListeners },
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListListenersByIpResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListListenersByIpResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListListenersByIpResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMigrationTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the source instance.
   * 
   * @example
   * whdc
   */
  originInstanceName?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      originInstanceName: 'OriginInstanceName',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      requestPars: 'RequestPars',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      originInstanceName: 'string',
      pageNum: 'number',
      pageSize: 'number',
      requestPars: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMigrationTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The array structure.
   */
  data?: ListMigrationTaskResponseBodyData[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 451EBE59-5F33-5B15-83C1-78593B9*****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of entries.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListMigrationTaskResponseBodyData },
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMigrationTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListMigrationTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListMigrationTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNacosConfigsRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * fpx-pds-pns
   */
  appName?: string;
  /**
   * @remarks
   * The ID of the data.
   * 
   * @example
   * zeekr-*
   */
  dataId?: string;
  /**
   * @remarks
   * The name of the group. Default value: `default`
   * 
   * @example
   * crm
   */
  group?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse-cn-7mz2fj****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * fad732a7-ff1a-4f21-8126-4edd4****
   */
  namespaceId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 5
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 200
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the region in which the instance resides. The region is supported by Microservices Engine (MSE).
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The extended request parameters. The JSON format is supported.
   * 
   * @example
   * {\\\\"appGroup\\\\":\\\\"sm_zk_asi_na610\\\\",\\\\"appName\\\\":\\\\"sm-zk\\\\",\\\\"appStage\\\\":\\\\"PUBLISH\\\\",\\\\"appUnit\\\\":\\\\"center\\\\",\\\\"bucId\\\\":\\\\"193554\\\\",\\\\"bucName\\\\":\\\\"Alibaba Mobile Business Group-UC\\\\",\\\\"provider\\\\":\\\\"aliyun\\\\"}
   */
  requestPars?: string;
  /**
   * @remarks
   * The tags.
   * 
   * @example
   * billing
   */
  tags?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appName: 'AppName',
      dataId: 'DataId',
      group: 'Group',
      instanceId: 'InstanceId',
      namespaceId: 'NamespaceId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      requestPars: 'RequestPars',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appName: 'string',
      dataId: 'string',
      group: 'string',
      instanceId: 'string',
      namespaceId: 'string',
      pageNum: 'number',
      pageSize: 'number',
      regionId: 'string',
      requestPars: 'string',
      tags: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNacosConfigsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The configurations.
   */
  configurations?: ListNacosConfigsResponseBodyConfigurations[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4081087F-3429-5873-A1E7-D4B5479D0B84
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of returned instances.
   * 
   * @example
   * 12
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      configurations: 'Configurations',
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      configurations: { 'type': 'array', 'itemType': ListNacosConfigsResponseBodyConfigurations },
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNacosConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListNacosConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListNacosConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNacosHistoryConfigsRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the data.
   * 
   * @example
   * user-prod.yaml
   */
  dataId?: string;
  /**
   * @remarks
   * The name of the configuration group.
   * 
   * @example
   * fc-dev-cluster-1
   */
  group?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse-cn-2r42e3bk20n
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * fc0f6e40-****-946b-45e3af313707
   */
  namespaceId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the region in which the instance resides. The region is supported by MSE.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {\\\\"appGroup\\\\":\\\\"aliyun-phecda-service-staging\\\\",\\\\"appName\\\\":\\\\"aliyun-phecda-service\\\\",\\\\"appStage\\\\":\\\\"DAILY\\\\",\\\\"appUnit\\\\":\\\\"center\\\\",\\\\"bucId\\\\":\\\\"250858\\\\",\\\\"bucName\\\\":\\\\"Alibaba Cloud\\\\",\\\\"provider\\\\":\\\\"aliyun\\\\"}
   */
  requestPars?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      dataId: 'DataId',
      group: 'Group',
      instanceId: 'InstanceId',
      namespaceId: 'NamespaceId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      requestPars: 'RequestPars',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      dataId: 'string',
      group: 'string',
      instanceId: 'string',
      namespaceId: 'string',
      pageNum: 'number',
      pageSize: 'number',
      regionId: 'string',
      requestPars: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNacosHistoryConfigsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The configuration items.
   */
  historyItems?: ListNacosHistoryConfigsResponseBodyHistoryItems[];
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 53338ECA-F880-54D8-A9B3-5606355A1B89
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 7
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      historyItems: 'HistoryItems',
      httpCode: 'HttpCode',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      historyItems: { 'type': 'array', 'itemType': ListNacosHistoryConfigsResponseBodyHistoryItems },
      httpCode: 'string',
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNacosHistoryConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListNacosHistoryConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListNacosHistoryConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNamingTrackRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The end timestamp. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1665299698
   */
  endTs?: number;
  /**
   * @remarks
   * The group.
   * 
   * @example
   * group
   */
  group?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse_prepaid_public_cn-tl32d*****
   */
  instanceId?: string;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 172.16.183.232
   */
  ip?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * cd4d3703-e2a6-46b5-85c6-4447e4f****
   */
  namespaceId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  /**
   * @remarks
   * Specifies whether to sort the query results in chronological order or reverse chronological order. Default value: `false`.
   * 
   * *   `true`: sorts the query results in reverse chronological order.
   * *   `false`: sorts the query results in chronological order.
   * 
   * @example
   * false
   */
  reverse?: boolean;
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * fpx-xms-baseinfo
   */
  serviceName?: string;
  /**
   * @remarks
   * The start timestamp. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1660238450
   */
  startTs?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      endTs: 'EndTs',
      group: 'Group',
      instanceId: 'InstanceId',
      ip: 'Ip',
      namespaceId: 'NamespaceId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      requestPars: 'RequestPars',
      reverse: 'Reverse',
      serviceName: 'ServiceName',
      startTs: 'StartTs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      endTs: 'number',
      group: 'string',
      instanceId: 'string',
      ip: 'string',
      namespaceId: 'string',
      pageNum: 'number',
      pageSize: 'number',
      requestPars: 'string',
      reverse: 'boolean',
      serviceName: 'string',
      startTs: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNamingTrackResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9916CBED-B2D5-5685-9129-4592FE1*****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 7
   */
  totalCount?: number;
  /**
   * @remarks
   * The data information.
   */
  traces?: ListNamingTrackResponseBodyTraces[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
      traces: 'Traces',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
      traces: { 'type': 'array', 'itemType': ListNamingTrackResponseBodyTraces },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNamingTrackResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListNamingTrackResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListNamingTrackResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSSLCertRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @example
   * certabc
   */
  certName?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-3f97e2989c344f35ab3fd62b19f1****
   */
  gatewayUniqueId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      certName: 'CertName',
      gatewayUniqueId: 'GatewayUniqueId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      certName: 'string',
      gatewayUniqueId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSSLCertResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned. A value of 200 indicates that the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   */
  data?: ListSSLCertResponseBodyData[];
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CAA9A229-141D-5FBA-AC5C-516C02026A11
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': ListSSLCertResponseBodyData },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSSLCertResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSSLCertResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSSLCertResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSecurityGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-e98e40675aaf49bda082137d158e1585
   */
  gatewayUniqueId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSecurityGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data structure.
   */
  data?: ListSecurityGroupResponseBodyData[];
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 316F5F64-F73D-42DC-8632-01E308B6****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': ListSecurityGroupResponseBodyData },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSecurityGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSecurityGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSecurityGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSecurityGroupRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-83b0ddb569434f82b9fe8e4c60c40f7c
   */
  gatewayUniqueId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSecurityGroupRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned result.
   */
  data?: ListSecurityGroupRuleResponseBodyData[];
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9EC7BDBF-3C38-5C9C-95DD-61E298CD43E8
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': ListSecurityGroupRuleResponseBodyData },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSecurityGroupRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSecurityGroupRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSecurityGroupRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSentinelBlockFallbackDefinitionsRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  classificationSet?: number[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * default
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appName: 'AppName',
      classificationSet: 'ClassificationSet',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appName: 'string',
      classificationSet: { 'type': 'array', 'itemType': 'number' },
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSentinelBlockFallbackDefinitionsShrinkRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  classificationSetShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * default
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appName: 'AppName',
      classificationSetShrink: 'ClassificationSet',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appName: 'string',
      classificationSetShrink: 'string',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSentinelBlockFallbackDefinitionsResponseBody extends $tea.Model {
  data?: ListSentinelBlockFallbackDefinitionsResponseBodyData[];
  /**
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @example
   * OK
   */
  message?: string;
  /**
   * @example
   * 4E9FDCFE-0738-493B-B801-82BDFBCB****
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListSentinelBlockFallbackDefinitionsResponseBodyData },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSentinelBlockFallbackDefinitionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSentinelBlockFallbackDefinitionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSentinelBlockFallbackDefinitionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceSourceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-c51a15c7ee934a4fb945ccf35fe1****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * Specifies the type of the returned service source. If this parameter is not specified, service sources of all types are returned. Valid values:
   * 
   * *   K8s
   * *   MSE
   * *   MSE_ZK
   * *   SAE
   * *   EDAS
   * 
   * @example
   * MSE
   */
  source?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      source: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceSourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   */
  data?: ListServiceSourceResponseBodyData[];
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * B8C4B0D8-EBB9-5F20-8295-04224FBE5529
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': ListServiceSourceResponseBodyData },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceSourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListServiceSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListServiceSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The token used to start the next query.
   * 
   * @example
   * AAAAAV3MpHK1AP0pfERHZN5pu6kywps2Ezza3n8HAAzCCqsi
   */
  nextToken?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The resource IDs. You can specify a maximum of 50 resource IDs.
   */
  resourceId?: string[];
  /**
   * @remarks
   * The type of the resource. Valid values:
   * 
   * *   CLUSTER: MSE instance
   * *   GATEWAY: cloud-native gateway
   * 
   * This parameter is required.
   * 
   * @example
   * CLUSTER
   */
  resourceType?: string;
  /**
   * @remarks
   * The list of tags. A maximum number of 20 tags are supported.
   */
  tag?: ListTagResourcesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      nextToken: 'NextToken',
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      nextToken: 'string',
      regionId: 'string',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tag: { 'type': 'array', 'itemType': ListTagResourcesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The token that is required for the next query. If the NextToken parameter is empty, no subsequent query is required.
   * 
   * @example
   * AAAAAV3MpHK1AP0pfERHZN5pu6ng3BeUyo2zbY5wgL1DBa2T
   */
  nextToken?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 92ED7C9C-84A2-595F-87FE-354F84C0F739
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The list of resources.
   */
  tagResources?: ListTagResourcesResponseBodyTagResources;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      message: 'Message',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      success: 'Success',
      tagResources: 'TagResources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      message: 'string',
      nextToken: 'string',
      requestId: 'string',
      success: 'boolean',
      tagResources: ListTagResourcesResponseBodyTagResources,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListZkTrackRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The end timestamp. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1669619383
   */
  endTs?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse-cn-0ju2yq****
   */
  instanceId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The path.
   * 
   * @example
   * /path
   */
  path?: string;
  /**
   * @remarks
   * The request parameters.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  /**
   * @remarks
   * Specifies whether to enable reverse ordering.
   * 
   * @example
   * false
   */
  reverse?: boolean;
  /**
   * @remarks
   * The session ID.
   * 
   * @example
   * 0x301fdfbdbf00***
   */
  sessionId?: string;
  /**
   * @remarks
   * The start timestamp. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1669618483
   */
  startTs?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      endTs: 'EndTs',
      instanceId: 'InstanceId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      path: 'Path',
      requestPars: 'RequestPars',
      reverse: 'Reverse',
      sessionId: 'SessionId',
      startTs: 'StartTs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      endTs: 'number',
      instanceId: 'string',
      pageNum: 'number',
      pageSize: 'number',
      path: 'string',
      requestPars: 'string',
      reverse: 'boolean',
      sessionId: 'string',
      startTs: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListZkTrackResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * ok
   */
  message?: string;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * DC34E4A3-5F1C-4E40-86EA-02EDF967****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true: The request was successful.
   * *   false: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  /**
   * @remarks
   * The track data.
   */
  traces?: ListZkTrackResponseBodyTraces[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
      traces: 'Traces',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
      traces: { 'type': 'array', 'itemType': ListZkTrackResponseBodyTraces },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListZkTrackResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListZkTrackResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListZkTrackResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListZnodeChildrenRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse-09k1q11****
   */
  clusterId?: string;
  /**
   * @remarks
   * The path of the node.
   * 
   * This parameter is required.
   * 
   * @example
   * /zookeeper
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListZnodeChildrenResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   */
  data?: ListZnodeChildrenResponseBodyData[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * BDB6CE0B-9CAF-41B5-9FEA-E08BE8E2****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListZnodeChildrenResponseBodyData },
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListZnodeChildrenResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListZnodeChildrenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListZnodeChildrenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyGovernanceKubernetesClusterRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cd23228b3c80c4d4f9ad87cc3****
   */
  clusterId?: string;
  /**
   * @remarks
   * The information about the namespace for which Microservices Engine(MSE) Microservices Governance is enabled.
   */
  namespaceInfos?: ModifyGovernanceKubernetesClusterRequestNamespaceInfos[];
  /**
   * @remarks
   * The ID of the region in which the instance resides. The region is supported by MSE.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      namespaceInfos: 'NamespaceInfos',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      namespaceInfos: { 'type': 'array', 'itemType': ModifyGovernanceKubernetesClusterRequestNamespaceInfos },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyGovernanceKubernetesClusterShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cd23228b3c80c4d4f9ad87cc3****
   */
  clusterId?: string;
  /**
   * @remarks
   * The information about the namespace for which Microservices Engine(MSE) Microservices Governance is enabled.
   */
  namespaceInfosShrink?: string;
  /**
   * @remarks
   * The ID of the region in which the instance resides. The region is supported by MSE.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      namespaceInfosShrink: 'NamespaceInfos',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      namespaceInfosShrink: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyGovernanceKubernetesClusterResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The deletion result.
   * 
   * @example
   * True
   */
  data?: boolean;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F9849E97-2455-54B0-A3B4-3F6E4E9FFEB1
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyGovernanceKubernetesClusterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyGovernanceKubernetesClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyGovernanceKubernetesClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLosslessRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to align the lifecycle of the application in the Kubernetes cluster with that of the microservice.
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  aligned?: boolean;
  /**
   * @remarks
   * The ID of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * c644n5frmc@3e75f25fd4*****
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * wx-work-api
   */
  appName?: string;
  /**
   * @remarks
   * The registration latency.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  delayTime?: number;
  /**
   * @remarks
   * Specifies whether to enable the alert rule. Valid values:
   * 
   * *   `true`: enables the rule.
   * *   `false`: disables the rule.
   * 
   * This parameter is required.
   * 
   * @example
   * false
   */
  enable?: boolean;
  /**
   * @remarks
   * The slope of the prefetching curve.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  funcType?: number;
  /**
   * @remarks
   * Specifies whether to display online and offline processing details.
   * 
   * @example
   * false
   */
  lossLessDetail?: boolean;
  /**
   * @remarks
   * The microservice namespace to which the rule applies.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * Specifies whether to enable notification.
   * 
   * @example
   * false
   */
  notice?: boolean;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-beijing
   */
  regionId?: string;
  /**
   * @remarks
   * Specifies whether to associate with service prefetching.
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  related?: boolean;
  /**
   * @remarks
   * The prefetching duration.
   * 
   * This parameter is required.
   * 
   * @example
   * 60
   */
  warmupTime?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      aligned: 'Aligned',
      appId: 'AppId',
      appName: 'AppName',
      delayTime: 'DelayTime',
      enable: 'Enable',
      funcType: 'FuncType',
      lossLessDetail: 'LossLessDetail',
      namespace: 'Namespace',
      notice: 'Notice',
      regionId: 'RegionId',
      related: 'Related',
      warmupTime: 'WarmupTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      aligned: 'boolean',
      appId: 'string',
      appName: 'string',
      delayTime: 'number',
      enable: 'boolean',
      funcType: 'number',
      lossLessDetail: 'boolean',
      namespace: 'string',
      notice: 'boolean',
      regionId: 'string',
      related: 'boolean',
      warmupTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLosslessRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * 响应码。
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * 返回数据。
   * 
   * @example
   * null
   */
  data?: any;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * HTTP状态码。
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * modifyLosslessRule success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3369AD10-F1A6-4E6F-B99E-20F51826****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'any',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLosslessRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyLosslessRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyLosslessRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OfflineGatewayRouteRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-77e1153db6e14c0a8b1fae20bcb89ca5
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the route.
   * 
   * @example
   * 645
   */
  routeId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      routeId: 'RouteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      routeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OfflineGatewayRouteResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the route is unpublished.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 8EB24742-AB15-5953-BEFB-1FA18E770EEE
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OfflineGatewayRouteResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: OfflineGatewayRouteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OfflineGatewayRouteResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OrderClusterHealthCheckRiskNoticeRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-cn-st21ri2****
   */
  instanceId?: string;
  /**
   * @remarks
   * Specifies whether to disable the notification feature if the risk item occurs.
   * 
   * *   true: disabled
   * *   false: enabled
   * 
   * @example
   * false
   */
  mute?: boolean;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * null
   */
  noticeType?: string;
  /**
   * @remarks
   * The region in which the cluster resides.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  /**
   * @remarks
   * The ID of the risk item.
   * 
   * @example
   * 30010010001
   */
  riskCode?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      instanceId: 'InstanceId',
      mute: 'Mute',
      noticeType: 'NoticeType',
      regionId: 'RegionId',
      requestPars: 'RequestPars',
      riskCode: 'RiskCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      instanceId: 'string',
      mute: 'boolean',
      noticeType: 'string',
      regionId: 'string',
      requestPars: 'string',
      riskCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OrderClusterHealthCheckRiskNoticeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. A value of 200 is returned if the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the subscription was successful.
   * 
   * @example
   * null
   */
  data?: boolean;
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the \\*\\*%s\\*\\* variable in the **ErrMessage** parameter.
   * 
   * > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * *   If the request is successful, a success message is returned.
   * *   If the request fails, an error message is returned, such as the "TaskId not found" message.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * AF21683A-29C7-4853-AC0F-B5ADEE4D****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OrderClusterHealthCheckRiskNoticeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: OrderClusterHealthCheckRiskNoticeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OrderClusterHealthCheckRiskNoticeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreserveHeaderFormatRequest extends $tea.Model {
  /**
   * @remarks
   * The language in which you want to display the results. Valid values: zh and en. zh indicates Chinese, which is the default value. en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-3f97e2989c344f35ab3fd62b19f1****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * Specifies whether the request header is case-sensitive. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  preserveHeaderFormat?: boolean;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      preserveHeaderFormat: 'PreserveHeaderFormat',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      preserveHeaderFormat: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreserveHeaderFormatResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. A value of 200 is returned if the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the \\*\\*%s\\*\\* variable in the **ErrMessage** parameter.
   * 
   * >  The request parameter **DtsJobId** is invalid if **The Value of Input Parameter %s is not valid** is returned for **ErrMessage** and **DtsJobId** is returned for **DynamicMessage**.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The status code.
   * 
   * @example
   * Success
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * OK
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 69AD2AA7-DB47-449B-941B-B14409DF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreserveHeaderFormatResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PreserveHeaderFormatResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PreserveHeaderFormatResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PullServicesRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-eccf313e2224438ba53d95d039e5****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * public
   */
  namespace?: string;
  /**
   * @remarks
   * The type of the service source.
   * 
   * @example
   * K8s
   */
  sourceType?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      namespace: 'Namespace',
      sourceType: 'SourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      namespace: 'string',
      sourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PullServicesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   */
  data?: PullServicesResponseBodyData[];
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * You are not authorized to perform this operation. Action: mse:PullServices, Resource: acs:mse:cn-shenzhen:1228932054837788:*
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EC0A99B9-8BA3-5FE3-8FE7-D7C719CF7BD2
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': PullServicesResponseBodyData },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PullServicesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PullServicesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PullServicesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutClusterHealthCheckTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse_prepaid_public_cn-2r42o83h506
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutClusterHealthCheckTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. A value of 200 is returned if the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data returned.
   * 
   * @example
   * null
   */
  data?: boolean;
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the \\*\\*%s\\*\\* variable in the **ErrMessage** parameter.
   * 
   * > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * *   If the request is successful, a success message is returned.
   * *   If the request fails, an error message is returned, such as the "TaskId not found" message.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 5B170A0D-2C5D-4CF8-B808-03966B86****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutClusterHealthCheckTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutClusterHealthCheckTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutClusterHealthCheckTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAllSwimmingLaneRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the lane group.
   * 
   * This parameter is required.
   * 
   * @example
   * 186
   */
  groupId?: number;
  /**
   * @remarks
   * The name of the MSE namespace.
   * 
   * @example
   * default
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      groupId: 'GroupId',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      groupId: 'number',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAllSwimmingLaneResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   * 
   * @example
   * [{id:100,name:"test"}]
   */
  data?: QueryAllSwimmingLaneResponseBodyData[];
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * DC34E4A3-5F1C-4E40-86EA-02EDF967****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': QueryAllSwimmingLaneResponseBodyData },
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAllSwimmingLaneResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryAllSwimmingLaneResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryAllSwimmingLaneResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAllSwimmingLaneGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the Microservices Engine (MSE) namespace that you want to query.
   * 
   * @example
   * default
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAllSwimmingLaneGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. A value of 200 is returned if the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The details of the data.
   * 
   * @example
   * [{id:100,name:"test"}]
   */
  data?: QueryAllSwimmingLaneGroupResponseBodyData[];
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * *   If the request is successful, a success message is returned.
   * *   If the request fails, an error message is returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 54973C90-F379-4372-9AA5-053A3F7****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': QueryAllSwimmingLaneGroupResponseBodyData },
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAllSwimmingLaneGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryAllSwimmingLaneGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryAllSwimmingLaneGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBusinessLocationsRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBusinessLocationsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   */
  data?: QueryBusinessLocationsResponseBodyData[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The parameter is invalid.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3369AD10-F1A6-4E6F-B99E-20F51826****
   */
  requestId?: string;
  /**
   * @remarks
   * The result of the request.
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': QueryBusinessLocationsResponseBodyData },
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBusinessLocationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryBusinessLocationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryBusinessLocationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClusterDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to query access control lists (ACLs).
   * 
   * @example
   * false
   */
  aclSwitch?: boolean;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-cn-st21ri2****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the order.
   * 
   * @example
   * 20576750143****
   */
  orderId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      aclSwitch: 'AclSwitch',
      instanceId: 'InstanceId',
      orderId: 'OrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      aclSwitch: 'boolean',
      instanceId: 'string',
      orderId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClusterDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   */
  data?: QueryClusterDetailResponseBodyData;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9515ACA4-E94D-440D-989E-C379FCED****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: QueryClusterDetailResponseBodyData,
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClusterDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryClusterDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryClusterDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClusterDiskSpecificationRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The type of the instance. Valid values: ZooKeeper, Nacos-Ans, and Eureka.
   * 
   * @example
   * ZooKeeper
   */
  clusterType?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterType: 'ClusterType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClusterDiskSpecificationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The details of the data.
   */
  data?: QueryClusterDiskSpecificationResponseBodyData;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the \\*\\*%s\\*\\* variable in the **ErrMessage** parameter.
   * 
   * >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E13A3A34-7201-50C4-B2D0-0D7DB891811E
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: QueryClusterDiskSpecificationResponseBodyData,
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClusterDiskSpecificationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryClusterDiskSpecificationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryClusterDiskSpecificationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClusterInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to query the configuration of a public IP address whitelist.
   * 
   * @example
   * false
   */
  aclSwitch?: boolean;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-09k1q11****
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse_prepaid_public_cn-7mz2t63ci03
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the order.
   * 
   * @example
   * 20574710974****
   */
  orderId?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      aclSwitch: 'AclSwitch',
      clusterId: 'ClusterId',
      instanceId: 'InstanceId',
      orderId: 'OrderId',
      regionId: 'RegionId',
      requestPars: 'RequestPars',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      aclSwitch: 'boolean',
      clusterId: 'string',
      instanceId: 'string',
      orderId: 'string',
      regionId: 'string',
      requestPars: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClusterInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   */
  data?: QueryClusterInfoResponseBodyData;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * *   If the request is successful, a success message is returned.
   * *   If the request fails, an error message is returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 415088B3-A7BE-56F6-9CD9-C42DE895CD41
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: QueryClusterInfoResponseBodyData,
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClusterInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryClusterInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryClusterInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClusterSpecificationRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The network type. Valid values:
   * 
   * *   slb
   * *   eni
   * 
   * @example
   * slb
   */
  connectType?: string;
  /**
   * @remarks
   * The edition of the MSE instance that you want to purchase.
   * 
   * *   mse_pro: Professional Edition
   * *   mse_dev: Developer Edition
   * 
   * @example
   * mse_pro
   */
  mseVersion?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      connectType: 'ConnectType',
      mseVersion: 'MseVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      connectType: 'string',
      mseVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClusterSpecificationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The return value.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The details of the data.
   */
  data?: QueryClusterSpecificationResponseBodyData[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE5C32A1-BC0E-4B79-817C-103E4EDF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': QueryClusterSpecificationResponseBodyData },
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClusterSpecificationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryClusterSpecificationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryClusterSpecificationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * @example
   * mse-09k1q11****
   */
  clusterId?: string;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * null
   */
  configType?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse_prepaid_public_cn-st2212****
   */
  instanceId?: string;
  /**
   * @remarks
   * Specifies whether runtime configurations are required.
   * 
   * @example
   * true
   */
  needRunningConf?: boolean;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      configType: 'ConfigType',
      instanceId: 'InstanceId',
      needRunningConf: 'NeedRunningConf',
      requestPars: 'RequestPars',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      configType: 'string',
      instanceId: 'string',
      needRunningConf: 'boolean',
      requestPars: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data returned.
   */
  data?: QueryConfigResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 8BD1E58D-0755-42AC-A599-E6B55112EC53
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: QueryConfigResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryGatewayRegionRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryGatewayRegionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   */
  data?: string[];
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9e78a671-4b9b-4dd4-99c1-0b9da87d3dec
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': 'string' },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryGatewayRegionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryGatewayRegionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryGatewayRegionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryGatewayTypeRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryGatewayTypeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned. The value 200 indicates that the request was successful. Other values indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The information about the gateway type. The data type of this parameter is List.
   */
  data?: string[];
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned. If the request is successful, a success message is returned. If the request fails, an error message is returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 52BA6DA6-A702-4362-A32F-DFF79655****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': 'string' },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryGatewayTypeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryGatewayTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryGatewayTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryGovernanceKubernetesClusterRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the Kubernetes cluster.
   * 
   * @example
   * c24c9354acxxxxxxx
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the Kubernetes cluster.
   * 
   * @example
   * example-cluster
   */
  clusterName?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      clusterName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryGovernanceKubernetesClusterResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned.
   */
  data?: QueryGovernanceKubernetesClusterResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * DE34D413-2B79-5E77-9696-36D875E822AD
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: QueryGovernanceKubernetesClusterResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryGovernanceKubernetesClusterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryGovernanceKubernetesClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryGovernanceKubernetesClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryInstancesInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * @example
   * mse-09k1q11****
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse_prepaid_public_cn-tl32g1u9k01
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the order.
   * 
   * @example
   * 20574710974****
   */
  orderId?: string;
  /**
   * @remarks
   * The ID of the region where the instance resides.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      instanceId: 'InstanceId',
      orderId: 'OrderId',
      regionId: 'RegionId',
      requestPars: 'RequestPars',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      instanceId: 'string',
      orderId: 'string',
      regionId: 'string',
      requestPars: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryInstancesInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   */
  data?: QueryInstancesInfoResponseBodyData[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 202
   */
  httpCode?: string;
  /**
   * @remarks
   * The message that is returned.
   * 
   * *   If the request is successful, a success message is returned.
   * *   If the request fails, an error message is returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 54973C90-F379-4372-9AA5-053A3F7****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': QueryInstancesInfoResponseBodyData },
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryInstancesInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryInstancesInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryInstancesInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMonitorRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The timestamp when the monitoring ends.
   * 
   * This parameter is required.
   * 
   * @example
   * 1666678376
   */
  endTime?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-cn-****
   */
  instanceId?: string;
  /**
   * @remarks
   * The metric type. The following metric types are supported:
   * 
   * [Basic system metrics]
   * 
   * *   cpuUsage
   * *   memoryUsage
   * *   diskUsage
   * *   gcCount
   * *   gcTime
   * 
   * [Nacos registry]
   * 
   * *   serviceCount
   * *   writeCostTime
   * *   readCostTime
   * *   TPS regCenterTps
   * *   QPS regCenterQps
   * 
   * [Nacos configuration center]
   * 
   * *   publish
   * *   getConfig
   * 
   * [zookeeper]
   * 
   * *   TPS zk_TpsCount
   * *   QPS zk_QpsCount
   * *   zookeeper_AvgRequestLatency
   * 
   * This parameter is required.
   * 
   * @example
   * regCenterQps
   */
  monitorType?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  /**
   * @remarks
   * The timestamp when the monitoring starts.
   * 
   * This parameter is required.
   * 
   * @example
   * 1666678376
   */
  startTime?: number;
  /**
   * @remarks
   * The interval between data points. Unit: seconds.
   * 
   * @example
   * 7
   */
  step?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      monitorType: 'MonitorType',
      requestPars: 'RequestPars',
      startTime: 'StartTime',
      step: 'Step',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      endTime: 'number',
      instanceId: 'string',
      monitorType: 'string',
      requestPars: 'string',
      startTime: 'number',
      step: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMonitorResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   * 
   * @example
   * 6
   */
  data?: QueryMonitorResponseBodyData[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * ADDD8AB7-8D1C-4697-A83E-410D2607****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': QueryMonitorResponseBodyData },
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMonitorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryNamespaceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values: zh and en. Default value: zh. The value zh which indicates Chinese, and the value en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @example
   * default
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      name: 'Name',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      name: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryNamespaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned.
   */
  data?: QueryNamespaceResponseBodyData[];
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Success
   */
  errorCode?: string;
  message?: string;
  /**
   * @example
   * abcde-fg
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': QueryNamespaceResponseBodyData },
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryNamespaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryNamespaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryNamespaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySlbSpecRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySlbSpecResponseBody extends $tea.Model {
  /**
   * @remarks
   * The return value.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data entries returned.
   */
  data?: QuerySlbSpecResponseBodyData[];
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned. If the request is successful, a success message is returned. If the request fails, an error message is returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 316F5F64-F73D-42DC-8632-01E308B6****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': QuerySlbSpecResponseBodyData },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySlbSpecResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QuerySlbSpecResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySlbSpecResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySwimmingLaneByIdRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the lane.
   * 
   * This parameter is required.
   * 
   * @example
   * 250
   */
  laneId?: number;
  /**
   * @remarks
   * The name of the Microservices Engine (MSE) namespace.
   * 
   * @example
   * default
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      laneId: 'LaneId',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      laneId: 'number',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySwimmingLaneByIdResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   * 
   * @example
   * {id:102,name:"test"}
   */
  data?: QuerySwimmingLaneByIdResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 69AD2AA7-DB47-449B-941B-B14409DF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: QuerySwimmingLaneByIdResponseBodyData,
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySwimmingLaneByIdResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QuerySwimmingLaneByIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySwimmingLaneByIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryZnodeDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * @example
   * mse-09k1q11****
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-cn-5bffa4e8630
   */
  instanceId?: string;
  /**
   * @remarks
   * The path of the node.
   * 
   * This parameter is required.
   * 
   * @example
   * /zookeeper
   */
  path?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      instanceId: 'InstanceId',
      path: 'Path',
      requestPars: 'RequestPars',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      instanceId: 'string',
      path: 'string',
      requestPars: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryZnodeDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   */
  data?: QueryZnodeDetailResponseBodyData;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 58E06A0A-BD2C-47A0-99C2-B100F353****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: QueryZnodeDetailResponseBodyData,
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryZnodeDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryZnodeDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryZnodeDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveApplicationRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @example
   * abcde@12345
   */
  appId?: string;
  /**
   * @example
   * example-app
   */
  appName?: string;
  /**
   * @example
   * prod
   */
  namespace?: string;
  /**
   * @example
   * cn-hangzhou
   */
  region?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      namespace: 'Namespace',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      namespace: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveApplicationResponseBody extends $tea.Model {
  /**
   * @example
   * success
   */
  data?: string;
  /**
   * @example
   * NoPermission
   */
  errorCode?: string;
  /**
   * @example
   * success
   */
  message?: string;
  /**
   * @example
   * abcde-12345
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveApplicationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemoveApplicationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveApplicationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAuthPolicyRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 259
   */
  policyId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      policyId: 'PolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      policyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAuthPolicyResponseBody extends $tea.Model {
  /**
   * @example
   * 500
   */
  code?: number;
  /**
   * @example
   * true
   */
  data?: string;
  /**
   * @example
   * 200
   */
  httpStatusCode?: number;
  message?: string;
  /**
   * @example
   * 9515ACA4-E94D-440D-989E-C379FCED****
   */
  requestId?: string;
  /**
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAuthPolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemoveAuthPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveAuthPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RestartClusterRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * @example
   * mse-09k1q11****
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-cn-78v1l83****
   */
  instanceId?: string;
  /**
   * @remarks
   * The names of pods. You can specify the names of multiple pods at a time. Separate multiple pod names with commas (,). Example: mse-a8aba010-1629719288255-reg-center-0-1,mse-a8aba010-1629719288255-reg-center-0-2.
   * 
   * The specified pods must belong to the current cluster and be associated with the specified instance. Otherwise, a restart exception occurs.
   * 
   * @example
   * mse-a8aba010-1629719288255-reg-center-0-1
   */
  podNameList?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      instanceId: 'InstanceId',
      podNameList: 'PodNameList',
      requestPars: 'RequestPars',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      instanceId: 'string',
      podNameList: 'string',
      requestPars: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RestartClusterResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 5B170A0D-2C5D-4CF8-B808-03966B86****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RestartClusterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RestartClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RestartClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryClusterRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-cn-st21ri2****
   */
  instanceId?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      instanceId: 'InstanceId',
      requestPars: 'RequestPars',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      instanceId: 'string',
      requestPars: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryClusterResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * NoPermission
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * DC34E4A3-5F1C-4E40-86EA-02EDF967****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryClusterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RetryClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RetryClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SelectGatewaySlbRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-492af9b04bb4474cae9d645be850****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The name of the SLB instance.
   * 
   * @example
   * test-slb
   */
  name?: string;
  /**
   * @remarks
   * The type of the SLB instance.
   * 
   * @example
   * PUB_NET
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      name: 'Name',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      name: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SelectGatewaySlbResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data structure.
   */
  data?: SelectGatewaySlbResponseBodyData[];
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E00C6D90-A28A-5813-8981-0459AA436F46
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': SelectGatewaySlbResponseBodyData },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SelectGatewaySlbResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SelectGatewaySlbResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SelectGatewaySlbResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The instance ID.
   * 
   * > This parameter specifies the instance ID that is passed. Examples:
   * 
   * - ResourceId.0 specifies the first instance ID that is passed.
   * - ResourceId.1 specifies the second instance ID that is passed.
   */
  resourceId?: string[];
  /**
   * @remarks
   * The type of the resources. Valid values:
   * 
   * *   CLUSTER: Microservices Engine (MSE) instance
   * *   GATEWAY: cloud-native gateway
   * 
   * This parameter is required.
   * 
   * @example
   * CLUSTER
   */
  resourceType?: string;
  /**
   * @remarks
   * The list of tags. You can specify a maximum of 20 tags.
   * 
   * This parameter is required.
   */
  tag?: TagResourcesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      regionId: 'string',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tag: { 'type': 'array', 'itemType': TagResourcesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E0A79810-9396-521C-A09D-E757B3E2BAF4
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: TagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to delete all tags. This parameter takes effect only when the TagKey.N parameter is not specified. Valid values:
   * 
   * *   true
   * *   false
   * 
   * Default value: false.
   * 
   * @example
   * true
   */
  all?: boolean;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The resource IDs. A maximum of 50 resource IDs can be specified.
   * 
   * This parameter is required.
   */
  resourceId?: string[];
  /**
   * @remarks
   * The type of the resource. Valid values:
   * 
   * *   CLUSTER: MSE instance
   * *   GATEWAY: cloud-native gateway
   * 
   * This parameter is required.
   * 
   * @example
   * CLUSTER
   */
  resourceType?: string;
  /**
   * @remarks
   * The tag keys. A maximum of 20 tag keys are supported.
   */
  tagKey?: string[];
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      all: 'All',
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      all: 'boolean',
      regionId: 'string',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tagKey: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 58E06A0A-BD2C-47A0-99C2-B100F353****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UntagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UntagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAclRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The IP addresses or CIDR blocks in the IP address whitelist.
   * 
   * @example
   * 192.168.0.0/XX,192.168.0.0/XX
   */
  aclEntryList?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-cn-78v1l83****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      aclEntryList: 'AclEntryList',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      aclEntryList: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAclResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-100
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7466566F-F30F-4A29-965D-3E0AF21D****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAclResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateAclResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateAclResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAuthPolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values: zh-CN and en-US. Default value: zh-CN. The value zh-CN indicates Chinese, and the value en-US indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * abcde@12345
   */
  appId?: string;
  /**
   * @remarks
   * The content of the service authentication rule.
   * 
   * @example
   * [{\\"all\\":true,\\"appIds\\":[\\"f6xqzbao96@4adfaf3c92c947a\\"],\\"black\\":false}]
   */
  authRule?: string;
  /**
   * @remarks
   * Specifies whether to enable the rule.
   * 
   * @example
   * true
   */
  enable?: string;
  /**
   * @remarks
   * The rule ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 432
   */
  id?: string;
  /**
   * @remarks
   * The ID of the ACK cluster namespace.
   * 
   * @example
   * c19c6c500e1ff4d7abc7bed9b8236***
   */
  k8sNamespace?: string;
  /**
   * @remarks
   * The name of the rule.
   * 
   * @example
   * demo-test
   */
  name?: string;
  /**
   * @remarks
   * The protocol type. Valid values:
   * 
   * *   **SPRING_CLOUD**
   * *   **DUBBO**
   * *   **istio**
   * 
   * @example
   * SPRING_CLOUD
   */
  protocol?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The source for application access.
   * 
   * @example
   * edasmsc
   */
  source?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      authRule: 'AuthRule',
      enable: 'Enable',
      id: 'Id',
      k8sNamespace: 'K8sNamespace',
      name: 'Name',
      protocol: 'Protocol',
      region: 'Region',
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      authRule: 'string',
      enable: 'string',
      id: 'string',
      k8sNamespace: 'string',
      name: 'string',
      protocol: 'string',
      region: 'string',
      source: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAuthPolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * @example
   * 500
   */
  code?: number;
  /**
   * @remarks
   * The details of the data.
   * 
   * @example
   * {}
   */
  data?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The returned message.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 83E3909D-D26F-5D97-B73B-407A26***
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: true: The request was successful. false: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAuthPolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateAuthPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateAuthPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateBlackWhiteListRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The content of the blacklist.
   * 
   * @example
   * 127.0.2.11
   */
  content?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-c70622ff52fe49beb29bea9a6f52****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the blacklist.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * Specifies whether to enable the whitelist.
   * 
   * @example
   * true
   */
  isWhite?: boolean;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * name
   */
  name?: string;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * this is a note
   */
  note?: string;
  /**
   * @remarks
   * The resource IDs in the JSON format.
   * 
   * @example
   * [123]
   */
  resourceIdJsonList?: string;
  /**
   * @remarks
   * The type of the resource.
   * 
   * @example
   * GATEWAY
   */
  resourceType?: string;
  /**
   * @remarks
   * Specifies whether to enable the blacklist or whitelist.
   * 
   * @example
   * on
   */
  status?: string;
  /**
   * @remarks
   * The type of the blacklist or whitelist.
   * 
   * @example
   * IP
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      content: 'Content',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      isWhite: 'IsWhite',
      name: 'Name',
      note: 'Note',
      resourceIdJsonList: 'ResourceIdJsonList',
      resourceType: 'ResourceType',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      content: 'string',
      gatewayUniqueId: 'string',
      id: 'number',
      isWhite: 'boolean',
      name: 'string',
      note: 'string',
      resourceIdJsonList: 'string',
      resourceType: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateBlackWhiteListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The return value.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The ID of the record.
   * 
   * @example
   * 13
   */
  data?: number;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * AD5DEDA0-C82A-50D9-AF54-BD3576CCFB4C
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateBlackWhiteListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateBlackWhiteListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateBlackWhiteListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCircuitBreakerRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values: zh-CN and en-US. Default value: zh-CN. The value zh-CN indicates Chinese, and the value en-US indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the application.
   * 
   * @example
   * hkhon1po62@c3df23522bXXXXX
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * Specifies whether to enable the rule.
   * 
   * Valid values:
   * 
   * *   true
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   false
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The minimum number of requests that can be passed in each step after circuit breaking recovers. Default value: 1.
   * 
   * @example
   * 5
   */
  halfOpenBaseAmountPerStep?: number;
  /**
   * @remarks
   * The number of circuit breaking recovery steps. Default value: 1.
   * 
   * @example
   * 1
   */
  halfOpenRecoveryStepNum?: number;
  /**
   * @remarks
   * The maximum response time (RT). Unit: milliseconds. If the RT of a request is greater than the value of this parameter, a slow call is counted. If you set Strategy to 0, you must specify this parameter.
   * 
   * @example
   * 200
   */
  maxAllowedRtMs?: number;
  /**
   * @remarks
   * The minimum number of requests to trigger circuit breaking. If the number of requests in the current time window is less than the value of this parameter, circuit breaking is not triggered even if the circuit breaking rule is met. Default value: 10.
   * 
   * @example
   * 10
   */
  minRequestAmount?: number;
  /**
   * @remarks
   * The microservice namespace to which the application belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The period in which circuit breaking is implemented. Unit: milliseconds. If circuit breaking is implemented on the requests for the route, the calls to all the requests for the route fail in the configured circuit breaking period. The value must be an integral multiple of 1,000. Default value: 10000. This value indicates 10 seconds.
   * 
   * @example
   * 10000
   */
  retryTimeoutMs?: number;
  /**
   * @remarks
   * The rule ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  ruleId?: number;
  /**
   * @remarks
   * The length of the time window. Unit: milliseconds. The valid range is from 1 second to 120 minutes. The default value is 20000. This value indicates 20 seconds.
   * 
   * @example
   * 20000
   */
  statIntervalMs?: number;
  /**
   * @remarks
   * The threshold type.
   * 
   * Valid values:
   * 
   * *   0
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     slow call proportion
   * 
   *     <!-- -->
   * 
   * *   1
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     abnormal proportion
   * 
   *     <!-- -->
   * 
   * @example
   * 0
   */
  strategy?: number;
  /**
   * @remarks
   * A percentage threshold for triggering circuit breaking. Valid values: 0-1. These values represent 0% to 100%.
   * 
   * @example
   * 0.8
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      enable: 'Enable',
      halfOpenBaseAmountPerStep: 'HalfOpenBaseAmountPerStep',
      halfOpenRecoveryStepNum: 'HalfOpenRecoveryStepNum',
      maxAllowedRtMs: 'MaxAllowedRtMs',
      minRequestAmount: 'MinRequestAmount',
      namespace: 'Namespace',
      retryTimeoutMs: 'RetryTimeoutMs',
      ruleId: 'RuleId',
      statIntervalMs: 'StatIntervalMs',
      strategy: 'Strategy',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      enable: 'boolean',
      halfOpenBaseAmountPerStep: 'number',
      halfOpenRecoveryStepNum: 'number',
      maxAllowedRtMs: 'number',
      minRequestAmount: 'number',
      namespace: 'string',
      retryTimeoutMs: 'number',
      ruleId: 'number',
      statIntervalMs: 'number',
      strategy: 'number',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCircuitBreakerRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The details of the rule.
   */
  data?: UpdateCircuitBreakerRuleResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * OK
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE5C32A1-BC0E-4B79-817C-103E4EDF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * Valid values:
   * 
   * *   true
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     The request was successful.
   * 
   *     <!-- -->
   * 
   * *   false
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     The request failed.
   * 
   *     <!-- -->
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: UpdateCircuitBreakerRuleResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCircuitBreakerRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCircuitBreakerRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCircuitBreakerRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateClusterRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The alias of the instance.
   * 
   * @example
   * cluster-1
   */
  clusterAliasName?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-cn-78v1l83****
   */
  instanceId?: string;
  /**
   * @remarks
   * The end time of the O\\&M window.
   * 
   * @example
   * 06:00
   */
  maintenanceEndTime?: string;
  /**
   * @remarks
   * The start time of the O\\&M window.
   * 
   * @example
   * 02:00
   */
  maintenanceStartTime?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterAliasName: 'ClusterAliasName',
      instanceId: 'InstanceId',
      maintenanceEndTime: 'MaintenanceEndTime',
      maintenanceStartTime: 'MaintenanceStartTime',
      requestPars: 'RequestPars',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterAliasName: 'string',
      instanceId: 'string',
      maintenanceEndTime: 'string',
      maintenanceStartTime: 'string',
      requestPars: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateClusterResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-100
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 5B170A0D-2C5D-4CF8-B808-03966B86****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateClusterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateClusterSpecRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  autoPay?: boolean;
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * @example
   * mse-09k1q11****
   */
  clusterId?: string;
  /**
   * @remarks
   * The destination engine specifications.
   * 
   * @example
   * MSE_SC_2_4_200_c
   */
  clusterSpecification?: string;
  /**
   * @remarks
   * The number of destination nodes.
   * 
   * @example
   * 3
   */
  instanceCount?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse-cn-st21ri2****
   */
  instanceId?: string;
  /**
   * @remarks
   * The MSE version.
   * 
   * @example
   * mse_pro
   */
  mseVersion?: string;
  pubNetworkFlow?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      autoPay: 'AutoPay',
      clusterId: 'ClusterId',
      clusterSpecification: 'ClusterSpecification',
      instanceCount: 'InstanceCount',
      instanceId: 'InstanceId',
      mseVersion: 'MseVersion',
      pubNetworkFlow: 'PubNetworkFlow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      autoPay: 'boolean',
      clusterId: 'string',
      clusterSpecification: 'string',
      instanceCount: 'number',
      instanceId: 'string',
      mseVersion: 'string',
      pubNetworkFlow: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateClusterSpecResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * null
   */
  data?: string;
  /**
   * @remarks
   * The error code returned if the request failed. Take note of the following rules:
   * 
   * *   The **ErrorCode** parameter is not returned if the request succeeds.
   * *   The **ErrorCode** parameter is returned if the request fails. For more information, see the **Error codes** section in this topic.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 5B170A0D-2C5D-4CF8-B808-03966B86****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateClusterSpecResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateClusterSpecResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateClusterSpecResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  authEnabled?: boolean;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * none
   */
  autopurgePurgeInterval?: string;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * none
   */
  autopurgeSnapRetainCount?: string;
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * @example
   * mse-09k1q11****
   */
  clusterId?: string;
  /**
   * @remarks
   * Specifies whether to enable Resource Access Management (RAM) authentication for a configuration center. This parameter is valid for Nacos instances. Valid values:
   * 
   * *   `true`: enabled.
   * *   `false`: disabled.
   * 
   * > Before you configure this parameter, you must call the QueryConfig operation to obtain the ConfigAuthSupported parameter value to check whether the instance supports the RAM authentication feature.
   * 
   * @example
   * true
   */
  configAuthEnabled?: boolean;
  /**
   * @remarks
   * Specifies whether to enable configuration encryption for a configuration center. This parameter is valid for Nacos instances. Valid values:
   * 
   * *   `true`: enabled.
   * *   `false`: disabled.
   * 
   * > Before you configure this parameter, you must call the QueryConfig operation to obtain the ConfigSecretSupported parameter value to check whether the instance supports configuration encryption.
   * 
   * @example
   * true
   */
  configSecretEnabled?: boolean;
  /**
   * @remarks
   * The format of the configuration. Supported formats include TEXT, JSON, XML, and HTML.
   * 
   * @example
   * TEXT
   */
  configType?: string;
  consoleUIEnabled?: boolean;
  enable4lw?: boolean;
  /**
   * @example
   * true
   */
  eurekaSupported?: boolean;
  /**
   * @remarks
   * Specifies whether to enable the time to live (TTL) configuration. This parameter is valid for ZooKeeper instances.
   * 
   * @example
   * true
   */
  extendedTypesEnable?: string;
  /**
   * @remarks
   * The maximum connection duration of the instance. This parameter is valid for ZooKeeper instances. Unit: seconds.
   * 
   * @example
   * 100
   */
  initLimit?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse_prepaid_public_cn-st2212****
   */
  instanceId?: string;
  /**
   * @remarks
   * The maximum amount of data on each node. This parameter is valid for ZooKeeper instances. The default maximum data amount on each node is 1 megabyte. Unit: bytes.
   * 
   * @example
   * 1048575
   */
  juteMaxbuffer?: string;
  /**
   * @remarks
   * Specifies whether to enable Mesh Configuration Protocol (MCP). This parameter is valid for Nacos instances. Valid values:
   * 
   * *   `true`: enabled.
   * *   `false`: disabled.
   * 
   * > Before you configure this parameter, you must call the QueryConfig operation to obtain the MCPSupported parameter value to check whether the instance supports MCP.
   * 
   * @example
   * true
   */
  MCPEnabled?: boolean;
  /**
   * @remarks
   * The number of connections between a client and a server. This parameter is valid for ZooKeeper instances.\\
   * If this parameter is set to 0, no limits are imposed on the number of connections.
   * 
   * @example
   * 0
   */
  maxClientCnxns?: string;
  /**
   * @remarks
   * The maximum timeout period. This parameter is valid for ZooKeeper instances. Unit: seconds.
   * 
   * @example
   * 1000
   */
  maxSessionTimeout?: string;
  /**
   * @remarks
   * The minimum timeout period. This parameter is valid for ZooKeeper instances. Unit: seconds.
   * 
   * @example
   * 10
   */
  minSessionTimeout?: string;
  /**
   * @remarks
   * Specifies whether to enable RAM authentication for a registry. This parameter is valid for Nacos instances. Valid values:
   * 
   * *   `true`: enabled.
   * *   `false`: disabled.
   * 
   * > Before you configure this parameter, you must call the QueryConfig operation to obtain the NamingAuthSupporte parameter value to check whether the instance supports the RAM authentication feature.
   * 
   * @example
   * true
   */
  namingAuthEnabled?: boolean;
  /**
   * @remarks
   * Specifies whether to enable super permissions. This parameter is valid for ZooKeeper instances. Valid values:
   * 
   * *   `true`: enabled
   * *   `false`: disabled
   * 
   * @example
   * true
   */
  openSuperAcl?: string;
  /**
   * @remarks
   * The password that corresponds to the username.
   * 
   * > You must specify this parameter if OpenSuperAcl is set to true.
   * 
   * @example
   * password
   */
  passWord?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  /**
   * @remarks
   * The frequency for generating snapshots. This parameter is valid for ZooKeeper instances.
   * 
   * @example
   * 100000
   */
  snapshotCount?: string;
  /**
   * @remarks
   * The connection timeout period of the instance. This parameter is valid for ZooKeeper instances. Unit: seconds.
   * 
   * @example
   * 10
   */
  syncLimit?: string;
  /**
   * @example
   * true
   */
  TLSEnabled?: boolean;
  /**
   * @remarks
   * The time unit. This parameter is valid for ZooKeeper instances. Default value: 2000. Unit: milliseconds.
   * 
   * @example
   * 2000
   */
  tickTime?: string;
  /**
   * @remarks
   * The name of the user.
   * 
   * > You must specify this parameter if OpenSuperAcl is set to true.
   * 
   * @example
   * name
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      authEnabled: 'AuthEnabled',
      autopurgePurgeInterval: 'AutopurgePurgeInterval',
      autopurgeSnapRetainCount: 'AutopurgeSnapRetainCount',
      clusterId: 'ClusterId',
      configAuthEnabled: 'ConfigAuthEnabled',
      configSecretEnabled: 'ConfigSecretEnabled',
      configType: 'ConfigType',
      consoleUIEnabled: 'ConsoleUIEnabled',
      enable4lw: 'Enable4lw',
      eurekaSupported: 'EurekaSupported',
      extendedTypesEnable: 'ExtendedTypesEnable',
      initLimit: 'InitLimit',
      instanceId: 'InstanceId',
      juteMaxbuffer: 'JuteMaxbuffer',
      MCPEnabled: 'MCPEnabled',
      maxClientCnxns: 'MaxClientCnxns',
      maxSessionTimeout: 'MaxSessionTimeout',
      minSessionTimeout: 'MinSessionTimeout',
      namingAuthEnabled: 'NamingAuthEnabled',
      openSuperAcl: 'OpenSuperAcl',
      passWord: 'PassWord',
      requestPars: 'RequestPars',
      snapshotCount: 'SnapshotCount',
      syncLimit: 'SyncLimit',
      TLSEnabled: 'TLSEnabled',
      tickTime: 'TickTime',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      authEnabled: 'boolean',
      autopurgePurgeInterval: 'string',
      autopurgeSnapRetainCount: 'string',
      clusterId: 'string',
      configAuthEnabled: 'boolean',
      configSecretEnabled: 'boolean',
      configType: 'string',
      consoleUIEnabled: 'boolean',
      enable4lw: 'boolean',
      eurekaSupported: 'boolean',
      extendedTypesEnable: 'string',
      initLimit: 'string',
      instanceId: 'string',
      juteMaxbuffer: 'string',
      MCPEnabled: 'boolean',
      maxClientCnxns: 'string',
      maxSessionTimeout: 'string',
      minSessionTimeout: 'string',
      namingAuthEnabled: 'boolean',
      openSuperAcl: 'string',
      passWord: 'string',
      requestPars: 'string',
      snapshotCount: 'string',
      syncLimit: 'string',
      TLSEnabled: 'boolean',
      tickTime: 'string',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 8BD1E58D-0755-42AC-A599-E6B55112****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEngineNamespaceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * @example
   * mse-09k1q11****
   */
  clusterId?: string;
  /**
   * @remarks
   * The description of the cluster.
   * 
   * @example
   * public
   */
  desc?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * This parameter is required.
   * 
   * @example
   * 33ff74b6-d21e-4f9b-91a8-bc1ea4ef****
   */
  id?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-cn-st21ri2****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * name
   */
  name?: string;
  /**
   * @remarks
   * The number of active services.
   * 
   * @example
   * 3
   */
  serviceCount?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      desc: 'Desc',
      id: 'Id',
      instanceId: 'InstanceId',
      name: 'Name',
      serviceCount: 'ServiceCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      desc: 'string',
      id: 'string',
      instanceId: 'string',
      name: 'string',
      serviceCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEngineNamespaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data.
   */
  data?: UpdateEngineNamespaceResponseBodyData;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4E9FDCFE-0738-493B-B801-82BDFBCB****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: UpdateEngineNamespaceResponseBodyData,
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEngineNamespaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateEngineNamespaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateEngineNamespaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFlowRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * hkhon1po62@c3df23522******
   */
  appId?: string;
  /**
   * @remarks
   * The application name.
   * 
   * This parameter is required.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * The throttling effect.
   * 
   * Valid values:
   * 
   * *   0
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     fast failure
   * 
   *     <!-- -->
   * 
   * *   2
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     in queue
   * 
   *     <!-- -->
   * 
   * @example
   * 0
   */
  controlBehavior?: number;
  /**
   * @remarks
   * Specifies whether to enable the rule.
   * 
   * Valid values:
   * 
   * *   true
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   false
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The timeout period. Unit: milliseconds. This parameter is required when the value of ControlBehavior is set to 2.
   * 
   * @example
   * 500
   */
  maxQueueingTimeMs?: number;
  /**
   * @remarks
   * The namespace.
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The rule ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 13
   */
  ruleId?: number;
  /**
   * @remarks
   * The throttling threshold.
   * 
   * @example
   * 30
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      controlBehavior: 'ControlBehavior',
      enable: 'Enable',
      maxQueueingTimeMs: 'MaxQueueingTimeMs',
      namespace: 'Namespace',
      ruleId: 'RuleId',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      controlBehavior: 'number',
      enable: 'boolean',
      maxQueueingTimeMs: 'number',
      namespace: 'string',
      ruleId: 'number',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFlowRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The data of the node.
   */
  data?: UpdateFlowRuleResponseBodyData;
  /**
   * @remarks
   * The returned message.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 52BA6DA6-A702-4362-A32F-DFF79655****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * Valid values:
   * 
   * *   true
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     The request was successful.
   * 
   *     <!-- -->
   * 
   * *   false
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     The request failed.
   * 
   *     <!-- -->
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: UpdateFlowRuleResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFlowRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateFlowRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateFlowRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayAuthConsumerRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The description of the consumer.
   * 
   * @example
   * Description
   */
  description?: string;
  /**
   * @remarks
   * The encryption type. Valid values:
   * 
   * *   RSA
   * *   OCT
   * 
   * @example
   * RSA
   */
  encodeType?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-90392d768a3847a7b804c505254d****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the consumer.
   * 
   * This parameter is required.
   * 
   * @example
   * 63
   */
  id?: number;
  /**
   * @remarks
   * The JWT public key. The JSON format is supported.
   * 
   * @example
   * {"keys":[{"e":"AQAB","kid":"DHFbpoIUqrY8t2zpA2qXfCmr5VO5ZEr4RzHU_-envvQ","kty":"RSA","n":"xAE7eB6qugXyCAG3yhh7pkDkT65pHymX-P7KfIupjf59vsdo91bSP9C8H07pSAGQO1MV_xFj9VswgsCg4R6otmg5PV2He95lZdHtOcU5DXIg_pbhLdKXbi66GlVeK6ABZOUW3WYtnNHD-91gVuoeJT_DwtGGcp4ignkgXfkiEm4sw-4sfb4qdt5oLbyVpmW6x9cfa7vs2WTfURiCrBoUqgBo_-4WTiULmmHSGZHOjzwa8WtrtOQGsAFjIbno85jp6MnGGGZPYZbDAa_b3y5u-YpW7ypZrvD8BgtKVjgtQgZhLAGezMt0ua3DRrWnKqTZ0BJ_EyxOGuHJrLsn00fnMQ"}]}
   */
  jwks?: string;
  /**
   * @remarks
   * The name of the key used for JWT-based identity authentication.
   * 
   * @example
   * iss
   */
  keyName?: string;
  /**
   * @remarks
   * The value of the key used for JWT-based identity authentication.
   * 
   * @example
   * abcd
   */
  keyValue?: string;
  /**
   * @remarks
   * The names of the parameters that are required to verify each token. By default, each token is prefixed with Bearer and stored in the Authorization header, such as `Authorization: Bearer <Content of a token>`.
   * 
   * @example
   * Authorization
   */
  tokenName?: string;
  /**
   * @remarks
   * Specifies whether to enable pass-through.
   * 
   * @example
   * true
   */
  tokenPass?: boolean;
  /**
   * @remarks
   * The positions of the parameters that are required to verify each token. By default, each token is prefixed with Bearer and stored in the Authorization header, such as `Authorization: Bearer <Content of a token>`.
   * 
   * @example
   * HEADER
   */
  tokenPosition?: string;
  /**
   * @remarks
   * The prefixes of the parameters that are required to verify each token. By default, each token is prefixed with Bearer and stored in the Authorization header, such as `Authorization: Bearer <Content of a token>`.
   * 
   * @example
   * Bearer
   */
  tokenPrefix?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      description: 'Description',
      encodeType: 'EncodeType',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      jwks: 'Jwks',
      keyName: 'KeyName',
      keyValue: 'KeyValue',
      tokenName: 'TokenName',
      tokenPass: 'TokenPass',
      tokenPosition: 'TokenPosition',
      tokenPrefix: 'TokenPrefix',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      description: 'string',
      encodeType: 'string',
      gatewayUniqueId: 'string',
      id: 'number',
      jwks: 'string',
      keyName: 'string',
      keyValue: 'string',
      tokenName: 'string',
      tokenPass: 'boolean',
      tokenPosition: 'string',
      tokenPrefix: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayAuthConsumerResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. A value of 200 is returned if the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The ID of the consumer.
   * 
   * @example
   * 2
   */
  data?: number;
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the \\*\\*%s\\*\\* variable in the **ErrMessage** parameter.
   * 
   * >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code that is returned.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE5C32A1-BC0E-4B79-817C-103E4EDF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayAuthConsumerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewayAuthConsumerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewayAuthConsumerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayAuthConsumerResourceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The gateway authentication consumer ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  consumerId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-3f97e2989c344f35ab3fd62b19f1****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The gateway authentication consumer ID.
   */
  resourceList?: UpdateGatewayAuthConsumerResourceRequestResourceList[];
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      consumerId: 'ConsumerId',
      gatewayUniqueId: 'GatewayUniqueId',
      resourceList: 'ResourceList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      consumerId: 'number',
      gatewayUniqueId: 'string',
      resourceList: { 'type': 'array', 'itemType': UpdateGatewayAuthConsumerResourceRequestResourceList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayAuthConsumerResourceShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The gateway authentication consumer ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  consumerId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-3f97e2989c344f35ab3fd62b19f1****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The gateway authentication consumer ID.
   */
  resourceListShrink?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      consumerId: 'ConsumerId',
      gatewayUniqueId: 'GatewayUniqueId',
      resourceListShrink: 'ResourceList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      consumerId: 'number',
      gatewayUniqueId: 'string',
      resourceListShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayAuthConsumerResourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. A value of 200 is returned if the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the list of the resources was updated. Valid values:
   * 
   * *   true: The list of the resources was updated.
   * *   false: The list of the resources was not updated.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the **%s** variable in the **ErrMessage** parameter.
   * 
   * >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 316F5F64-F73D-42DC-8632-01E308B6****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayAuthConsumerResourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewayAuthConsumerResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewayAuthConsumerResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayAuthConsumerResourceStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the consumer.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  consumerId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-2a99625886d54722be94d92e9a69****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The list of IDs of the authorized resources that a user wants to update.
   * 
   * This parameter is required.
   * 
   * @example
   * 1,2,3,4
   */
  idList?: string;
  /**
   * @remarks
   * The resource authorization status. Valid values:
   * 
   * *   true: enabled
   * *   false: disabled
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  resourceStatus?: boolean;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      consumerId: 'ConsumerId',
      gatewayUniqueId: 'GatewayUniqueId',
      idList: 'IdList',
      resourceStatus: 'ResourceStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      consumerId: 'number',
      gatewayUniqueId: 'string',
      idList: 'string',
      resourceStatus: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayAuthConsumerResourceStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. A value of 200 is returned if the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the execution was successful. Valid values:
   * 
   * *   true: The execution was successful.
   * *   false: The execution failed.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the `%s` variable in the `ErrMessage` parameter.
   * 
   * >  If the return value of the `ErrMessage` parameter is `The Value of Input Parameter %s is not valid` and the return value of the `DynamicMessage` parameter is `DtsJobId`, the specified `DtsJobId` parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code that is returned.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 316F5F64-F73D-42DC-8632-01E308B6****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayAuthConsumerResourceStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewayAuthConsumerResourceStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewayAuthConsumerResourceStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayAuthConsumerStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The status of the consumer. Valid values:
   * 
   * *   true: The consumer is enabled.
   * *   false: The consumer is disabled.
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  consumerStatus?: boolean;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-685f661467b54f48b7b7a76605ce****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The consumer ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      consumerStatus: 'ConsumerStatus',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      consumerStatus: 'boolean',
      gatewayUniqueId: 'string',
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayAuthConsumerStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the \\*\\*%s\\*\\* variable in the **ErrMessage** parameter.
   * 
   * > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 56D9E600-6348-4260-B35F-583413F****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayAuthConsumerStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewayAuthConsumerStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewayAuthConsumerStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayCircuitBreakerRuleRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 0
   */
  behaviorType?: number;
  /**
   * @example
   * 0
   */
  bodyEncoding?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 0
   */
  enable?: number;
  /**
   * @example
   * 14407
   */
  gatewayId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * gw-c9bc5afd61014165bd58f621b491****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 369
   */
  id?: number;
  /**
   * @example
   * 10
   */
  maxAllowedMs?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 10
   */
  minRequestAmount?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 12
   */
  recoveryTimeoutSec?: number;
  /**
   * @example
   * text
   */
  responseContentBody?: string;
  /**
   * @example
   * www.******.com
   */
  responseRedirectUrl?: string;
  /**
   * @example
   * 429
   */
  responseStatusCode?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 645
   */
  routeId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * routeName
   */
  routeName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 11
   */
  statDurationSec?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 0
   */
  strategy?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 10
   */
  triggerRatio?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      behaviorType: 'BehaviorType',
      bodyEncoding: 'BodyEncoding',
      enable: 'Enable',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      maxAllowedMs: 'MaxAllowedMs',
      minRequestAmount: 'MinRequestAmount',
      recoveryTimeoutSec: 'RecoveryTimeoutSec',
      responseContentBody: 'ResponseContentBody',
      responseRedirectUrl: 'ResponseRedirectUrl',
      responseStatusCode: 'ResponseStatusCode',
      routeId: 'RouteId',
      routeName: 'RouteName',
      statDurationSec: 'StatDurationSec',
      strategy: 'Strategy',
      triggerRatio: 'TriggerRatio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      behaviorType: 'number',
      bodyEncoding: 'number',
      enable: 'number',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
      maxAllowedMs: 'number',
      minRequestAmount: 'number',
      recoveryTimeoutSec: 'number',
      responseContentBody: 'string',
      responseRedirectUrl: 'string',
      responseStatusCode: 'number',
      routeId: 'number',
      routeName: 'string',
      statDurationSec: 'number',
      strategy: 'number',
      triggerRatio: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayCircuitBreakerRuleResponseBody extends $tea.Model {
  data?: UpdateGatewayCircuitBreakerRuleResponseBodyData;
  /**
   * @example
   * DC34E4A3-5F1C-4E40-86EA-02EDF967****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: UpdateGatewayCircuitBreakerRuleResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayCircuitBreakerRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewayCircuitBreakerRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewayCircuitBreakerRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the certificate.
   * 
   * @example
   * 6209108-cn-hangzhou
   */
  certIdentifier?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-86575c0bc9f04ecfbacb92b8e392****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * Specifies whether to enable `HTTP/2`.
   * 
   * *   `open`: `HTTP/2` is enabled.
   * *   `close`: `HTTP/2` is disabled.
   * *   `globalConfig`: Global configurations are used.
   * 
   * @example
   * close
   */
  http2?: string;
  /**
   * @remarks
   * The ID of the domain name that you want to update.
   * 
   * @example
   * 94
   */
  id?: number;
  /**
   * @remarks
   * Specifies whether to forcibly use HTTPS.
   * 
   * @example
   * false
   */
  mustHttps?: boolean;
  /**
   * @remarks
   * The type of the protocol. Valid values:
   * 
   * *   HTTPS
   * *   HTTP
   * 
   * @example
   * HTTPS
   */
  protocol?: string;
  /**
   * @remarks
   * The maximum version of Transport Layer Security (TLS).
   * 
   * @example
   * TLS 1.3
   */
  tlsMax?: string;
  /**
   * @remarks
   * The minimum version of TLS.
   * 
   * @example
   * TLS 1.0
   */
  tlsMin?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      certIdentifier: 'CertIdentifier',
      gatewayUniqueId: 'GatewayUniqueId',
      http2: 'Http2',
      id: 'Id',
      mustHttps: 'MustHttps',
      protocol: 'Protocol',
      tlsMax: 'TlsMax',
      tlsMin: 'TlsMin',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      certIdentifier: 'string',
      gatewayUniqueId: 'string',
      http2: 'string',
      id: 'number',
      mustHttps: 'boolean',
      protocol: 'string',
      tlsMax: 'string',
      tlsMin: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 403
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   * 
   * @example
   * 94
   */
  data?: number;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6F6C6DE4-DB33-5791-B210-ED2E6FEFFE6F
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewayDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewayDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayFlowRuleRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 0
   */
  behaviorType?: number;
  /**
   * @example
   * 0
   */
  bodyEncoding?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 0
   */
  enable?: number;
  /**
   * @example
   * 14407
   */
  gatewayId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * gw-e2d226bba4b2445c9e29fa7f8216****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 549
   */
  id?: number;
  /**
   * @example
   * text
   */
  responseContentBody?: string;
  /**
   * @example
   * www.******.com
   */
  responseRedirectUrl?: string;
  /**
   * @example
   * 429
   */
  responseStatusCode?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 48811
   */
  routeId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * routeA
   */
  routeName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 10
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      behaviorType: 'BehaviorType',
      bodyEncoding: 'BodyEncoding',
      enable: 'Enable',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      responseContentBody: 'ResponseContentBody',
      responseRedirectUrl: 'ResponseRedirectUrl',
      responseStatusCode: 'ResponseStatusCode',
      routeId: 'RouteId',
      routeName: 'RouteName',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      behaviorType: 'number',
      bodyEncoding: 'number',
      enable: 'number',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
      responseContentBody: 'string',
      responseRedirectUrl: 'string',
      responseStatusCode: 'number',
      routeId: 'number',
      routeName: 'string',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayFlowRuleResponseBody extends $tea.Model {
  data?: UpdateGatewayFlowRuleResponseBodyData;
  /**
   * @example
   * 2B74E7F7-DF54-5AB1-B8F2-67391B83****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: UpdateGatewayFlowRuleResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayFlowRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewayFlowRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewayFlowRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayIsolationRuleRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 0
   */
  behaviorType?: number;
  /**
   * @example
   * 0
   */
  bodyEncoding?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 0
   */
  enable?: number;
  /**
   * @example
   * 14407
   */
  gatewayId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * gw-e2d226bba4b2445c9e29fa7f8216****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 358
   */
  id?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 100
   */
  maxConcurrency?: number;
  /**
   * @example
   * text
   */
  responseContentBody?: string;
  /**
   * @example
   * www.******.com
   */
  responseRedirectUrl?: string;
  /**
   * @example
   * 429
   */
  responseStatusCode?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 52853
   */
  routeId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * routeName
   */
  routeName?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      behaviorType: 'BehaviorType',
      bodyEncoding: 'BodyEncoding',
      enable: 'Enable',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      maxConcurrency: 'MaxConcurrency',
      responseContentBody: 'ResponseContentBody',
      responseRedirectUrl: 'ResponseRedirectUrl',
      responseStatusCode: 'ResponseStatusCode',
      routeId: 'RouteId',
      routeName: 'RouteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      behaviorType: 'number',
      bodyEncoding: 'number',
      enable: 'number',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
      maxConcurrency: 'number',
      responseContentBody: 'string',
      responseRedirectUrl: 'string',
      responseStatusCode: 'number',
      routeId: 'number',
      routeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayIsolationRuleResponseBody extends $tea.Model {
  data?: UpdateGatewayIsolationRuleResponseBodyData;
  /**
   * @example
   * 94B12406-E44D-57C9-BF93-A8B35BFF****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: UpdateGatewayIsolationRuleResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayIsolationRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewayIsolationRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewayIsolationRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayNameRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-1cef54brvecdb419fb264d4f9b8c
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The name of the gateway.
   * 
   * @example
   * demo-test
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayNameResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   * 
   * @example
   * true
   */
  data?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * *   If the request is successful, a success message is returned.
   * *   If the request fails, an error message is returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 8C95711F-E702-5395-BFAA-21BA946CDE47
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayNameResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewayNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewayNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayOptionRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 421
   */
  gatewayId?: number;
  /**
   * @remarks
   * The detailed configurations of the gateway.
   * 
   * *   **TraceDetails**: the sampling description of Managed Service for OpenTelemetry. Content: TraceEnabled indicates whether Managed Service for OpenTelemetry is activated. Sample indicates the sampling rate of Managed Service for OpenTelemetry.
   * *   **LogConfigDetails**: the description of Simple Log Service. Content: LogEnabled indicates whether Simple Log Service is activated. ProjectName indicates the Simple Log Service project to which logs are delivered. LogStoreName indicates the name of the Logstore.
   * *   **EnableHardwareAcceleration**: indicates whether hardware acceleration is enabled.
   * *   **DisableHttp2Alpn**: indicates whether the HTTP/2 protocol is disabled.
   * *   **EnableWaf**: indicates whether Web Application Firewall (WAF) is enabled.
   */
  gatewayOption?: GatewayOption;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-83b0ddb569434f82b9fe8e4c60c4****
   */
  gatewayUniqueId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayId: 'GatewayId',
      gatewayOption: 'GatewayOption',
      gatewayUniqueId: 'GatewayUniqueId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayId: 'number',
      gatewayOption: GatewayOption,
      gatewayUniqueId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayOptionShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 421
   */
  gatewayId?: number;
  /**
   * @remarks
   * The detailed configurations of the gateway.
   * 
   * *   **TraceDetails**: the sampling description of Managed Service for OpenTelemetry. Content: TraceEnabled indicates whether Managed Service for OpenTelemetry is activated. Sample indicates the sampling rate of Managed Service for OpenTelemetry.
   * *   **LogConfigDetails**: the description of Simple Log Service. Content: LogEnabled indicates whether Simple Log Service is activated. ProjectName indicates the Simple Log Service project to which logs are delivered. LogStoreName indicates the name of the Logstore.
   * *   **EnableHardwareAcceleration**: indicates whether hardware acceleration is enabled.
   * *   **DisableHttp2Alpn**: indicates whether the HTTP/2 protocol is disabled.
   * *   **EnableWaf**: indicates whether Web Application Firewall (WAF) is enabled.
   */
  gatewayOptionShrink?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-83b0ddb569434f82b9fe8e4c60c4****
   */
  gatewayUniqueId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayId: 'GatewayId',
      gatewayOptionShrink: 'GatewayOption',
      gatewayUniqueId: 'GatewayUniqueId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayId: 'number',
      gatewayOptionShrink: 'string',
      gatewayUniqueId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayOptionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data returned.
   * 
   * @example
   * {\\"LogConfigDetails\\": {\\"LogEnabled\\": True}, \\"TraceDetails\\": {\\"Sample\\": 17, \\"TraceEnabled\\": True}}
   */
  data?: GatewayOption;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * *   If the request is successful, a success message is returned.
   * *   If the request fails, an error message is returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 124D02EB-DBDD-534D-A701-B4A95D3D****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GatewayOption,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayOptionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewayOptionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewayOptionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @example
   * a route for xxx
   */
  description?: string;
  /**
   * @remarks
   * The destination service type.
   * 
   * @example
   * Mock
   */
  destinationType?: string;
  /**
   * @remarks
   * The information about service mocking.
   */
  directResponseJSON?: UpdateGatewayRouteRequestDirectResponseJSON;
  /**
   * @remarks
   * The associated domain name.
   * 
   * @example
   * [90]
   */
  domainIdListJSON?: string;
  /**
   * @remarks
   * Specifies whether to activate Web Application Firewall (WAF).
   * 
   * @example
   * false
   */
  enableWaf?: boolean;
  /**
   * @remarks
   * Specifies whether to enable the Fallback service.
   * 
   * @example
   * true
   */
  fallback?: boolean;
  /**
   * @remarks
   * The information about the Fallback service.
   */
  fallbackServices?: UpdateGatewayRouteRequestFallbackServices[];
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 501
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-86575c0bc9f04ecfbacb92b8e392a2c4
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the route.
   * 
   * @example
   * 139
   */
  id?: number;
  /**
   * @remarks
   * The name of the route.
   * 
   * @example
   * route-web
   * 
   * @deprecated
   */
  name?: string;
  /**
   * @remarks
   * The route matching conditions.
   */
  predicates?: UpdateGatewayRouteRequestPredicates;
  /**
   * @remarks
   * The information about redirection.
   */
  redirectJSON?: UpdateGatewayRouteRequestRedirectJSON;
  /**
   * @remarks
   * The sequence number of the route.
   * 
   * @example
   * 1
   */
  routeOrder?: number;
  /**
   * @remarks
   * The information about destination services.
   */
  services?: UpdateGatewayRouteRequestServices[];
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      description: 'Description',
      destinationType: 'DestinationType',
      directResponseJSON: 'DirectResponseJSON',
      domainIdListJSON: 'DomainIdListJSON',
      enableWaf: 'EnableWaf',
      fallback: 'Fallback',
      fallbackServices: 'FallbackServices',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      name: 'Name',
      predicates: 'Predicates',
      redirectJSON: 'RedirectJSON',
      routeOrder: 'RouteOrder',
      services: 'Services',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      description: 'string',
      destinationType: 'string',
      directResponseJSON: UpdateGatewayRouteRequestDirectResponseJSON,
      domainIdListJSON: 'string',
      enableWaf: 'boolean',
      fallback: 'boolean',
      fallbackServices: { 'type': 'array', 'itemType': UpdateGatewayRouteRequestFallbackServices },
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
      name: 'string',
      predicates: UpdateGatewayRouteRequestPredicates,
      redirectJSON: UpdateGatewayRouteRequestRedirectJSON,
      routeOrder: 'number',
      services: { 'type': 'array', 'itemType': UpdateGatewayRouteRequestServices },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @example
   * a route for xxx
   */
  description?: string;
  /**
   * @remarks
   * The destination service type.
   * 
   * @example
   * Mock
   */
  destinationType?: string;
  /**
   * @remarks
   * The information about service mocking.
   */
  directResponseJSONShrink?: string;
  /**
   * @remarks
   * The associated domain name.
   * 
   * @example
   * [90]
   */
  domainIdListJSON?: string;
  /**
   * @remarks
   * Specifies whether to activate Web Application Firewall (WAF).
   * 
   * @example
   * false
   */
  enableWaf?: boolean;
  /**
   * @remarks
   * Specifies whether to enable the Fallback service.
   * 
   * @example
   * true
   */
  fallback?: boolean;
  /**
   * @remarks
   * The information about the Fallback service.
   */
  fallbackServicesShrink?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 501
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-86575c0bc9f04ecfbacb92b8e392a2c4
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the route.
   * 
   * @example
   * 139
   */
  id?: number;
  /**
   * @remarks
   * The name of the route.
   * 
   * @example
   * route-web
   * 
   * @deprecated
   */
  name?: string;
  /**
   * @remarks
   * The route matching conditions.
   */
  predicatesShrink?: string;
  /**
   * @remarks
   * The information about redirection.
   */
  redirectJSONShrink?: string;
  /**
   * @remarks
   * The sequence number of the route.
   * 
   * @example
   * 1
   */
  routeOrder?: number;
  /**
   * @remarks
   * The information about destination services.
   */
  servicesShrink?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      description: 'Description',
      destinationType: 'DestinationType',
      directResponseJSONShrink: 'DirectResponseJSON',
      domainIdListJSON: 'DomainIdListJSON',
      enableWaf: 'EnableWaf',
      fallback: 'Fallback',
      fallbackServicesShrink: 'FallbackServices',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      name: 'Name',
      predicatesShrink: 'Predicates',
      redirectJSONShrink: 'RedirectJSON',
      routeOrder: 'RouteOrder',
      servicesShrink: 'Services',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      description: 'string',
      destinationType: 'string',
      directResponseJSONShrink: 'string',
      domainIdListJSON: 'string',
      enableWaf: 'boolean',
      fallback: 'boolean',
      fallbackServicesShrink: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
      name: 'string',
      predicatesShrink: 'string',
      redirectJSONShrink: 'string',
      routeOrder: 'number',
      servicesShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data returned.
   * 
   * @example
   * 337
   */
  data?: number;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * NoPermission
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 73785414-2C5B-5E28-BD91-B2C742269C48
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewayRouteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewayRouteResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteAuthRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The authentication configurations.
   * 
   * This parameter is required.
   */
  authJSON?: UpdateGatewayRouteAuthRequestAuthJSON;
  /**
   * @remarks
   * The gateway ID.
   * 
   * @example
   * 102
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-0adf3ad751284cc69fcf9669fba*****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The route ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 109
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      authJSON: 'AuthJSON',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      authJSON: UpdateGatewayRouteAuthRequestAuthJSON,
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteAuthShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The authentication configurations.
   * 
   * This parameter is required.
   */
  authJSONShrink?: string;
  /**
   * @remarks
   * The gateway ID.
   * 
   * @example
   * 102
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-0adf3ad751284cc69fcf9669fba*****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The route ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 109
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      authJSONShrink: 'AuthJSON',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      authJSONShrink: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteAuthResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The route ID.
   * 
   * @example
   * 123
   */
  data?: number;
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * code
   */
  dynamicCode?: string;
  /**
   * @remarks
   * The dynamic part in the error message. This parameter is used to replace the \\*\\*%s\\*\\* variable in the **ErrMessage** parameter.
   * 
   * > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
   * 
   * @example
   * The specified parameter is invalid.
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 54973C90-F379-4372-9AA5-053A3F7****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteAuthResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewayRouteAuthResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewayRouteAuthResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteCORSRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. In compliance with [RFC 7231](https://tools.ietf.org/html/rfc7231), the backend service must return a response based on the language used by the user.
   * 
   * *   No default value.
   * *   zh-CN: Chinese
   * *   en-US: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The information about the CORS policy.
   */
  corsJSON?: UpdateGatewayRouteCORSRequestCorsJSON;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 85
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-f70a6ddf2f0941a2bb997b2d16028f37
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the associated record.
   * 
   * @example
   * 55
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      corsJSON: 'CorsJSON',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      corsJSON: UpdateGatewayRouteCORSRequestCorsJSON,
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteCORSShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. In compliance with [RFC 7231](https://tools.ietf.org/html/rfc7231), the backend service must return a response based on the language used by the user.
   * 
   * *   No default value.
   * *   zh-CN: Chinese
   * *   en-US: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The information about the CORS policy.
   */
  corsJSONShrink?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 85
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-f70a6ddf2f0941a2bb997b2d16028f37
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the associated record.
   * 
   * @example
   * 55
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      corsJSONShrink: 'CorsJSON',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      corsJSONShrink: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteCORSResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data structure.
   * 
   * @example
   * 618
   */
  data?: number;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 41BE990E-44E4-5ED3-AEEB-A276941B1854
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteCORSResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewayRouteCORSResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewayRouteCORSResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteHTTPRewriteRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 430
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-90392d768a3847a7b804c505254da96d
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The information about the rewrite policy. The JSON format is supported.
   * 
   * @example
   * {"pathType":"PRE","path":"/","status":"off"}
   */
  httpRewriteJSON?: string;
  /**
   * @remarks
   * The ID of the route.
   * 
   * @example
   * 238
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      httpRewriteJSON: 'HttpRewriteJSON',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      httpRewriteJSON: 'string',
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteHTTPRewriteResponseBody extends $tea.Model {
  /**
   * @remarks
   * The return value.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   * 
   * @example
   * 411
   */
  data?: number;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * AE60DA1E-B234-5105-897B-68372453A5A2
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteHTTPRewriteResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewayRouteHTTPRewriteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewayRouteHTTPRewriteResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteHeaderOpRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 324
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-6bdc977deda44bf589c49d063b4c2d1d
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The description of user header settings.
   * 
   * @example
   * {\\"status\\":\\"on\\",\\"headerOpItems\\":[{\\"directionType\\":\\"Request\\",\\"opType\\":\\"Update\\",\\"key\\":\\"hosts\\",\\"value\\":\\"test.com\\"}]}
   */
  headerOpJSON?: string;
  /**
   * @remarks
   * The ID of the record.
   * 
   * @example
   * 411
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      headerOpJSON: 'HeaderOpJSON',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      headerOpJSON: 'string',
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteHeaderOpResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned. A value of 200 indicates that the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   * 
   * @example
   * 666
   */
  data?: number;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7C8CB294-BED8-5F32-A416-7517725E8F27
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteHeaderOpResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewayRouteHeaderOpResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewayRouteHeaderOpResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteRetryRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 501
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-3f97e2989c344f35ab3fd62b19f1d10a
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the associated record.
   * 
   * @example
   * 508
   */
  id?: number;
  /**
   * @remarks
   * The information about the retry policy.
   */
  retryJSON?: UpdateGatewayRouteRetryRequestRetryJSON;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      retryJSON: 'RetryJSON',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
      retryJSON: UpdateGatewayRouteRetryRequestRetryJSON,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteRetryShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 501
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-3f97e2989c344f35ab3fd62b19f1d10a
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the associated record.
   * 
   * @example
   * 508
   */
  id?: number;
  /**
   * @remarks
   * The information about the retry policy.
   */
  retryJSONShrink?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      retryJSONShrink: 'RetryJSON',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
      retryJSONShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteRetryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   * 
   * @example
   * 640
   */
  data?: number;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9297B27D-D932-5E9F-93B9-99D6C5F3A879
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteRetryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewayRouteRetryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewayRouteRetryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteTimeoutRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 85
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-533290d279c1405f9628c64f7c8272ee
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the associated record.
   * 
   * @example
   * 567
   */
  id?: number;
  /**
   * @remarks
   * The timeout period.
   */
  timeoutJSON?: UpdateGatewayRouteTimeoutRequestTimeoutJSON;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      timeoutJSON: 'TimeoutJSON',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
      timeoutJSON: UpdateGatewayRouteTimeoutRequestTimeoutJSON,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteTimeoutShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 85
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-533290d279c1405f9628c64f7c8272ee
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the associated record.
   * 
   * @example
   * 567
   */
  id?: number;
  /**
   * @remarks
   * The timeout period.
   */
  timeoutJSONShrink?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      timeoutJSONShrink: 'TimeoutJSON',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
      timeoutJSONShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteTimeoutResponseBody extends $tea.Model {
  /**
   * @remarks
   * The return value.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data of the node.
   * 
   * @example
   * 400
   */
  data?: number;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 5359729E-A059-5942-98AF-E981E89C99FA
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. true: The request was successful. false: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteTimeoutResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewayRouteTimeoutResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewayRouteTimeoutResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteWafStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to activate Web Application Firewall (WAF).
   * 
   * @example
   * true
   */
  enableWaf?: boolean;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-86575c0bc9f04ecfbacb92b8e392****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the route.
   * 
   * @example
   * 645
   */
  routeId?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      enableWaf: 'EnableWaf',
      gatewayUniqueId: 'GatewayUniqueId',
      routeId: 'RouteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      enableWaf: 'boolean',
      gatewayUniqueId: 'string',
      routeId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteWafStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned. A value of 200 indicates that the request is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   */
  data?: UpdateGatewayRouteWafStatusResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7466566F-F30F-4A29-965D-3E0AF21D****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: UpdateGatewayRouteWafStatusResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteWafStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewayRouteWafStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewayRouteWafStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayServiceCheckRequest extends $tea.Model {
  /**
   * @remarks
   * The language in which you want to display the results. Valid values: zh and en. zh indicates Chinese, which is the default value. en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to enable the health check.
   * 
   * @example
   * true
   */
  check?: boolean;
  /**
   * @remarks
   * The expected status code, which is required if the health check protocol is HTTP.
   */
  expectedStatuses?: number[];
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-8d410698bd7f4628ab76b*****72dd1d
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The healthy threshold of the health check.
   * 
   * @example
   * 2
   */
  healthyThreshold?: number;
  /**
   * @remarks
   * The health check domain name, which is optional if the health check protocol is HTTP.
   * 
   * @example
   * example.com
   */
  httpHost?: string;
  /**
   * @remarks
   * The health check path, which is required if the health check protocol is HTTP.
   * 
   * @example
   * /healthz
   */
  httpPath?: string;
  /**
   * @remarks
   * The interval at which the health check is performed.
   * 
   * @example
   * 2
   */
  interval?: number;
  /**
   * @remarks
   * The health check protocol. Valid values:
   * 
   * *   HTTP
   * *   TCP
   * 
   * @example
   * HTTP
   */
  protocol?: string;
  /**
   * @remarks
   * The ID of the service.
   * 
   * @example
   * 12
   */
  serviceId?: string;
  /**
   * @remarks
   * The timeout period of responses to the health check. Unit: seconds.
   * 
   * @example
   * 5
   */
  timeout?: number;
  /**
   * @remarks
   * The unhealthy threshold of the health check.
   * 
   * @example
   * 2
   */
  unhealthyThreshold?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      check: 'Check',
      expectedStatuses: 'ExpectedStatuses',
      gatewayUniqueId: 'GatewayUniqueId',
      healthyThreshold: 'HealthyThreshold',
      httpHost: 'HttpHost',
      httpPath: 'HttpPath',
      interval: 'Interval',
      protocol: 'Protocol',
      serviceId: 'ServiceId',
      timeout: 'Timeout',
      unhealthyThreshold: 'UnhealthyThreshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      check: 'boolean',
      expectedStatuses: { 'type': 'array', 'itemType': 'number' },
      gatewayUniqueId: 'string',
      healthyThreshold: 'number',
      httpHost: 'string',
      httpPath: 'string',
      interval: 'number',
      protocol: 'string',
      serviceId: 'string',
      timeout: 'number',
      unhealthyThreshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayServiceCheckShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language in which you want to display the results. Valid values: zh and en. zh indicates Chinese, which is the default value. en indicates English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * Specifies whether to enable the health check.
   * 
   * @example
   * true
   */
  check?: boolean;
  /**
   * @remarks
   * The expected status code, which is required if the health check protocol is HTTP.
   */
  expectedStatusesShrink?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-8d410698bd7f4628ab76b*****72dd1d
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The healthy threshold of the health check.
   * 
   * @example
   * 2
   */
  healthyThreshold?: number;
  /**
   * @remarks
   * The health check domain name, which is optional if the health check protocol is HTTP.
   * 
   * @example
   * example.com
   */
  httpHost?: string;
  /**
   * @remarks
   * The health check path, which is required if the health check protocol is HTTP.
   * 
   * @example
   * /healthz
   */
  httpPath?: string;
  /**
   * @remarks
   * The interval at which the health check is performed.
   * 
   * @example
   * 2
   */
  interval?: number;
  /**
   * @remarks
   * The health check protocol. Valid values:
   * 
   * *   HTTP
   * *   TCP
   * 
   * @example
   * HTTP
   */
  protocol?: string;
  /**
   * @remarks
   * The ID of the service.
   * 
   * @example
   * 12
   */
  serviceId?: string;
  /**
   * @remarks
   * The timeout period of responses to the health check. Unit: seconds.
   * 
   * @example
   * 5
   */
  timeout?: number;
  /**
   * @remarks
   * The unhealthy threshold of the health check.
   * 
   * @example
   * 2
   */
  unhealthyThreshold?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      check: 'Check',
      expectedStatusesShrink: 'ExpectedStatuses',
      gatewayUniqueId: 'GatewayUniqueId',
      healthyThreshold: 'HealthyThreshold',
      httpHost: 'HttpHost',
      httpPath: 'HttpPath',
      interval: 'Interval',
      protocol: 'Protocol',
      serviceId: 'ServiceId',
      timeout: 'Timeout',
      unhealthyThreshold: 'UnhealthyThreshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      check: 'boolean',
      expectedStatusesShrink: 'string',
      gatewayUniqueId: 'string',
      healthyThreshold: 'number',
      httpHost: 'string',
      httpPath: 'string',
      interval: 'number',
      protocol: 'string',
      serviceId: 'string',
      timeout: 'number',
      unhealthyThreshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayServiceCheckResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The service ID of the operation.
   * 
   * @example
   * 12
   */
  data?: number;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * OK
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 62CBFCB8-DDC6-588C-BF1B-88828AF*****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: true and false.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayServiceCheckResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewayServiceCheckResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewayServiceCheckResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayServiceTrafficPolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   **zh-CN** (default): Chinese
   * *   **en-US**: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 429
   */
  gatewayId?: number;
  /**
   * @remarks
   * The traffic policy of the gateway.
   * 
   * This parameter is required.
   */
  gatewayTrafficPolicy?: TrafficPolicy;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-75c5036c083e4f89ba8ef9fafff2e902
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the service.
   * 
   * @example
   * 411
   */
  serviceId?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayId: 'GatewayId',
      gatewayTrafficPolicy: 'GatewayTrafficPolicy',
      gatewayUniqueId: 'GatewayUniqueId',
      serviceId: 'ServiceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayId: 'number',
      gatewayTrafficPolicy: TrafficPolicy,
      gatewayUniqueId: 'string',
      serviceId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayServiceTrafficPolicyShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   **zh-CN** (default): Chinese
   * *   **en-US**: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 429
   */
  gatewayId?: number;
  /**
   * @remarks
   * The traffic policy of the gateway.
   * 
   * This parameter is required.
   */
  gatewayTrafficPolicyShrink?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-75c5036c083e4f89ba8ef9fafff2e902
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the service.
   * 
   * @example
   * 411
   */
  serviceId?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayId: 'GatewayId',
      gatewayTrafficPolicyShrink: 'GatewayTrafficPolicy',
      gatewayUniqueId: 'GatewayUniqueId',
      serviceId: 'ServiceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayId: 'number',
      gatewayTrafficPolicyShrink: 'string',
      gatewayUniqueId: 'string',
      serviceId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayServiceTrafficPolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The details of the data.
   * 
   * @example
   * {\\"GatewayUniqueId\\": \\"gw-2b8ebd75dc554c37a4279ba9917379f2\\", \\"Id\\": 417, \\"GatewayTrafficPolicy\\": {\\"LoadBalancerSettings\\": {\\"LoadbalancerType\\": \\"ROUND_ROBIN\\"}, \\"TlsSetting\\": {\\"TlsMode\\": \\"DISABLE\\"}}}
   */
  data?: GatewayService;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 11A61389-F896-5231-A4FB-074D9E2E0055
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GatewayService,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayServiceTrafficPolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewayServiceTrafficPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewayServiceTrafficPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayServiceVersionRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-eccf313e2224438ba53d95d039e5****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the service.
   * 
   * @example
   * 575
   */
  serviceId?: number;
  /**
   * @remarks
   * The version of the service.
   * 
   * @example
   * {\\"name\\":\\"v3\\",\\"labels\\":[{\\"key\\":\\"version\\",\\"value\\":\\"v3\\"}]}
   */
  serviceVersion?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      serviceId: 'ServiceId',
      serviceVersion: 'ServiceVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      serviceId: 'number',
      serviceVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayServiceVersionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 1
   */
  code?: number;
  /**
   * @remarks
   * The data of the node.
   * 
   * @example
   * 614
   */
  data?: number;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D6580AA6-E285-58D2-B00B-12C051B3B7BF
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayServiceVersionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewayServiceVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewayServiceVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewaySpecRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-c70622ff52fe49beb29bea9a6f52****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The number of nodes.
   * 
   * This parameter is required.
   * 
   * @example
   * 3
   */
  replica?: number;
  /**
   * @remarks
   * The node specifications of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * MSE_GTW_4_8_200_c
   */
  spec?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      gatewayUniqueId: 'GatewayUniqueId',
      replica: 'Replica',
      spec: 'Spec',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      gatewayUniqueId: 'string',
      replica: 'number',
      spec: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewaySpecResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * gw-892ehbv7gg56******
   */
  data?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 316F5F64-F73D-42DC-8632-01E308B6****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewaySpecResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGatewaySpecResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGatewaySpecResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateImageRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the destination cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * mse-8e8e9060
   */
  clusterId?: string;
  /**
   * @remarks
   * The destination version number.
   * 
   * > You must call the GetImage operation to obtain the maximum destination version number that corresponds to MaxVersionCode.
   * 
   * This parameter is required.
   * 
   * @example
   * ZooKeeper_3_5_5
   */
  versionCode?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      versionCode: 'VersionCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      versionCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateImageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3855D475-2B66-5CFF-9A51-3D698E52C472
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateImageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateImageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateImageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateIsolationRuleRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @example
   * hkhon1po62@c3df23522******
   */
  appId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1
   */
  ruleId?: number;
  /**
   * @example
   * 3
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      enable: 'Enable',
      namespace: 'Namespace',
      ruleId: 'RuleId',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      enable: 'boolean',
      namespace: 'string',
      ruleId: 'number',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateIsolationRuleResponseBody extends $tea.Model {
  /**
   * @example
   * 200
   */
  code?: string;
  data?: UpdateIsolationRuleResponseBodyData;
  /**
   * @example
   * OK
   */
  message?: string;
  /**
   * @example
   * 4E9FDCFE-0738-493B-B801-82BDFBCB****
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: UpdateIsolationRuleResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateIsolationRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateIsolationRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateIsolationRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMessageQueueRouteRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * hkhon1po62@c3df23522baa898
   */
  appId?: string;
  /**
   * @example
   * example-app
   */
  appName?: string;
  /**
   * @remarks
   * Specifies whether the canary release for messaging feature is enabled for the application. Valid values:
   * 
   * *   `true`: enabled
   * *   `false`: disabled
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The side for message filtering when the canary release for messaging feature is enabled.
   * 
   * @example
   * Server
   */
  filterSide?: string;
  /**
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The tag that is negligible for the untagged environment of the application.
   */
  tags?: string[];
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      enable: 'Enable',
      filterSide: 'FilterSide',
      namespace: 'Namespace',
      region: 'Region',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      enable: 'boolean',
      filterSide: 'string',
      namespace: 'string',
      region: 'string',
      tags: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMessageQueueRouteShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * hkhon1po62@c3df23522baa898
   */
  appId?: string;
  /**
   * @example
   * example-app
   */
  appName?: string;
  /**
   * @remarks
   * Specifies whether the canary release for messaging feature is enabled for the application. Valid values:
   * 
   * *   `true`: enabled
   * *   `false`: disabled
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The side for message filtering when the canary release for messaging feature is enabled.
   * 
   * @example
   * Server
   */
  filterSide?: string;
  /**
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The tag that is negligible for the untagged environment of the application.
   */
  tagsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appId: 'AppId',
      appName: 'AppName',
      enable: 'Enable',
      filterSide: 'FilterSide',
      namespace: 'Namespace',
      region: 'Region',
      tagsShrink: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appId: 'string',
      appName: 'string',
      enable: 'boolean',
      filterSide: 'string',
      namespace: 'string',
      region: 'string',
      tagsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMessageQueueRouteResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned. The value 200 indicates that the request was successful. Other values indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The data of the node.
   * 
   * @example
   * True
   */
  data?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E3919C62-876A-5926-A0BC-18351A24FA35
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMessageQueueRouteResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateMessageQueueRouteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateMessageQueueRouteResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMigrationTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The type of the instance. Valid values:
   * 
   * *   Nacos-Ans
   * *   ZooKeeper
   * *   Eureka
   * 
   * @example
   * Nacos-Ans
   */
  clusterType?: string;
  /**
   * @remarks
   * The ID of the task.
   * 
   * @example
   * 1
   */
  id?: string;
  /**
   * @remarks
   * The address of the source instance node.
   * 
   * @example
   * 192.168.1.1:8848
   */
  originInstanceAddress?: string;
  /**
   * @remarks
   * The name of the source instance.
   * 
   * @example
   * Source instance
   */
  originInstanceName?: string;
  /**
   * @remarks
   * The list of namespaces. This parameter is optional if you want to migrate applications from a Nacos instance.
   * 
   * @example
   * namesapceId1,namesapceId2
   */
  originInstanceNamespace?: string;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * This is a description.
   */
  projectDesc?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  syncType?: string;
  /**
   * @remarks
   * The name of the destination instance.
   * 
   * @example
   * Destination instance
   */
  targetClusterName?: string;
  /**
   * @remarks
   * The URL of the destination instance.
   * 
   * @example
   * mse-66*****-nacos-ans.mse.aliyuncs.com:8848
   */
  targetClusterUrl?: string;
  /**
   * @remarks
   * The ID of the destination instance.
   * 
   * @example
   * mse-cn-ud82*****
   */
  targetInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterType: 'ClusterType',
      id: 'Id',
      originInstanceAddress: 'OriginInstanceAddress',
      originInstanceName: 'OriginInstanceName',
      originInstanceNamespace: 'OriginInstanceNamespace',
      projectDesc: 'ProjectDesc',
      requestPars: 'RequestPars',
      syncType: 'SyncType',
      targetClusterName: 'TargetClusterName',
      targetClusterUrl: 'TargetClusterUrl',
      targetInstanceId: 'TargetInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterType: 'string',
      id: 'string',
      originInstanceAddress: 'string',
      originInstanceName: 'string',
      originInstanceNamespace: 'string',
      projectDesc: 'string',
      requestPars: 'string',
      syncType: 'string',
      targetClusterName: 'string',
      targetClusterUrl: 'string',
      targetInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMigrationTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data structure.
   */
  data?: UpdateMigrationTaskResponseBodyData;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * AF21683A-29C7-4853-AC0F-B5ADEE4****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: UpdateMigrationTaskResponseBodyData,
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMigrationTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateMigrationTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateMigrationTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNacosClusterRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The port used for health checks.
   * 
   * @example
   * 80
   */
  checkPort?: number;
  /**
   * @remarks
   * The name of the Nacos cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * DEFAULT
   */
  clusterName?: string;
  /**
   * @remarks
   * The name of the group.
   * 
   * This parameter is required.
   * 
   * @example
   * DEFAULT_GROUP
   */
  groupName?: string;
  /**
   * @remarks
   * The type of the health check.
   * 
   * @example
   * {"type":"none"}
   */
  healthChecker?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse-cn-123456
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 9e78a671-4b9b-4dd4-99c1-0b9da87d3dec
   */
  namespaceId?: string;
  /**
   * @remarks
   * The name of the service.
   * 
   * This parameter is required.
   * 
   * @example
   * hello_service
   */
  serviceName?: string;
  /**
   * @remarks
   * Specifies whether to use the port of the instance for a health check.
   * 
   * @example
   * false
   */
  useInstancePortForCheck?: boolean;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      checkPort: 'CheckPort',
      clusterName: 'ClusterName',
      groupName: 'GroupName',
      healthChecker: 'HealthChecker',
      instanceId: 'InstanceId',
      namespaceId: 'NamespaceId',
      serviceName: 'ServiceName',
      useInstancePortForCheck: 'UseInstancePortForCheck',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      checkPort: 'number',
      clusterName: 'string',
      groupName: 'string',
      healthChecker: 'string',
      instanceId: 'string',
      namespaceId: 'string',
      serviceName: 'string',
      useInstancePortForCheck: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNacosClusterResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The result returned.
   * 
   * @example
   * ok
   */
  data?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9e78a671-4b9b-4dd4-99c1-0b9da87d3dec
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNacosClusterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateNacosClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateNacosClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNacosConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * postoffice
   */
  appName?: string;
  /**
   * @remarks
   * The list of IP addresses where the beta release of the configuration is performed.
   * 
   * @example
   * 196.168.XX.XX
   */
  betaIps?: string;
  /**
   * @remarks
   * The content of the configuration.
   * 
   * @example
   * attribute1=1221111\\r\\nattribute2=Chinese\\r\\nattribute3=abc11\\r\\nattribute4=1.00111
   */
  content?: string;
  /**
   * @remarks
   * The ID of the configuration.
   * 
   * This parameter is required.
   * 
   * @example
   * ky-check-****.yml
   */
  dataId?: string;
  /**
   * @remarks
   * The description of the configuration.
   * 
   * @example
   * Basic configurations
   */
  desc?: string;
  /**
   * @remarks
   * The encryption key.
   * 
   * @example
   * 122wdwe****
   */
  encryptedDataKey?: string;
  /**
   * @remarks
   * The name of the group.
   * 
   * This parameter is required.
   * 
   * @example
   * resource
   */
  group?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse-cn-7pp2a****
   */
  instanceId?: string;
  /**
   * @remarks
   * The MD5 value of the configuration.
   * 
   * @example
   * 045439703a273a94306422b****
   */
  md5?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 78b7af66-d15f-4541-b886-11ed81ecb6c0
   */
  namespaceId?: string;
  /**
   * @remarks
   * The list of tags.
   * 
   * @example
   * 2021-10-20
   */
  tags?: string;
  /**
   * @remarks
   * The format of the configuration. Supported formats include TEXT, JSON, XML, and HTML.
   * 
   * @example
   * text
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appName: 'AppName',
      betaIps: 'BetaIps',
      content: 'Content',
      dataId: 'DataId',
      desc: 'Desc',
      encryptedDataKey: 'EncryptedDataKey',
      group: 'Group',
      instanceId: 'InstanceId',
      md5: 'Md5',
      namespaceId: 'NamespaceId',
      tags: 'Tags',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appName: 'string',
      betaIps: 'string',
      content: 'string',
      dataId: 'string',
      desc: 'string',
      encryptedDataKey: 'string',
      group: 'string',
      instanceId: 'string',
      md5: 'string',
      namespaceId: 'string',
      tags: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNacosConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * NoPermission
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request was successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 69AD2AA7-DB47-449B-941B-B14409DF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNacosConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateNacosConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateNacosConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNacosGrayConfigRequest extends $tea.Model {
  /**
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @example
   * asdf
   */
  content?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test
   */
  dataId?: string;
  /**
   * @example
   * key=value1,value2
   */
  grayRule?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Tags
   */
  grayType?: string;
  /**
   * @example
   * DEFAULT_GROUP
   */
  group?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * mse_prepaid_public_cn-st2212****
   */
  instanceId?: string;
  /**
   * @example
   * 6cf708a5-****-89f2-3ba62c5ee9ba
   */
  namespaceId?: string;
  /**
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @example
   * {}
   */
  requestPars?: string;
  /**
   * @example
   * true
   */
  stopGray?: boolean;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      appName: 'AppName',
      content: 'Content',
      dataId: 'DataId',
      grayRule: 'GrayRule',
      grayType: 'GrayType',
      group: 'Group',
      instanceId: 'InstanceId',
      namespaceId: 'NamespaceId',
      regionId: 'RegionId',
      requestPars: 'RequestPars',
      stopGray: 'StopGray',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      appName: 'string',
      content: 'string',
      dataId: 'string',
      grayRule: 'string',
      grayType: 'string',
      group: 'string',
      instanceId: 'string',
      namespaceId: 'string',
      regionId: 'string',
      requestPars: 'string',
      stopGray: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNacosGrayConfigResponseBody extends $tea.Model {
  /**
   * @example
   * true
   */
  data?: boolean;
  /**
   * @example
   * 316F5F64-F73D-42DC-8632-01E308B6****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNacosGrayConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateNacosGrayConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateNacosGrayConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNacosInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the Nacos instance.
   * 
   * @example
   * DEFAULT
   */
  clusterName?: string;
  /**
   * @remarks
   * Specifies whether to disable this service. Valid values:
   * 
   * *   `true`: yes.
   * *   `false`: no.
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  enabled?: boolean;
  /**
   * @remarks
   * Specifies whether the node is a non-persistent node. Valid values:
   * 
   * *   `true`: yes.
   * *   `false`: no.
   * 
   * This parameter is required.
   * 
   * @example
   * false
   */
  ephemeral?: boolean;
  /**
   * @remarks
   * The name of the group.
   * 
   * This parameter is required.
   * 
   * @example
   * DEFAULT_GROUP
   */
  groupName?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse-cn-123456
   */
  instanceId?: string;
  /**
   * @remarks
   * The IP address of the Nacos instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 1.2.X.X
   */
  ip?: string;
  /**
   * @remarks
   * The metadata of the instance.
   * 
   * @example
   * [int]
   */
  metadata?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 9e78a671-4b9b-4dd4-99c1-0****
   */
  namespaceId?: string;
  /**
   * @remarks
   * The port number of the Nacos instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 12281
   */
  port?: number;
  /**
   * @remarks
   * The name of the service.
   * 
   * This parameter is required.
   * 
   * @example
   * hello_service
   */
  serviceName?: string;
  /**
   * @remarks
   * The weight. Valid values: 0 to 10000. The value must be an integer. A larger value indicates a higher frequency at which the instance is accessed.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  weight?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterName: 'ClusterName',
      enabled: 'Enabled',
      ephemeral: 'Ephemeral',
      groupName: 'GroupName',
      instanceId: 'InstanceId',
      ip: 'Ip',
      metadata: 'Metadata',
      namespaceId: 'NamespaceId',
      port: 'Port',
      serviceName: 'ServiceName',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterName: 'string',
      enabled: 'boolean',
      ephemeral: 'boolean',
      groupName: 'string',
      instanceId: 'string',
      ip: 'string',
      metadata: 'string',
      namespaceId: 'string',
      port: 'number',
      serviceName: 'string',
      weight: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNacosInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The result of the modification.
   * 
   * @example
   * ok
   */
  data?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9e78a671-4b9b-4dd4-99c1-0b9da87d3dec
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNacosInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateNacosInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateNacosInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNacosServiceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
   * 
   * @example
   * mse-09k1q11****
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the group.
   * 
   * @example
   * DEFAULT_GROUP
   */
  groupName?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
   * 
   * @example
   * mse-cn-st21ri2****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 5e3ee449-b5c0-4aee-b857-32c0acbebf26
   */
  namespaceId?: string;
  /**
   * @remarks
   * The protection threshold.
   * 
   * @example
   * 0
   */
  protectThreshold?: string;
  /**
   * @remarks
   * The name of the service.
   * 
   * This parameter is required.
   * 
   * @example
   * com.dingtalk.doc.thumbnails.pdf.ThumbnailService
   */
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      groupName: 'GroupName',
      instanceId: 'InstanceId',
      namespaceId: 'NamespaceId',
      protectThreshold: 'ProtectThreshold',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      groupName: 'string',
      instanceId: 'string',
      namespaceId: 'string',
      protectThreshold: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNacosServiceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 1
   */
  code?: number;
  /**
   * @remarks
   * The details of the data.
   * 
   * @example
   * 6
   */
  data?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4E9FDCFE-0738-493B-B801-82BDFBCB****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNacosServiceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateNacosServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateNacosServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePluginConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * zh: Chinese en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The plug-in configuration. Configurations of WebAssembly plug-ins are in the YAML format, and configurations of Lua plug-ins are in the Lua code.
   * 
   * @example
   * \\# Configure a check for the required fields of the plug-in, such as name, age, and friends. Sample configuration: name: John age: 18 friends: - David - Anne
   */
  config?: string;
  /**
   * @remarks
   * The application scope of the plug-in.
   * 
   * *   0: global
   * *   1: route
   * *   2: domain name
   * 
   * @example
   * 0
   */
  configLevel?: number;
  /**
   * @remarks
   * Specifies whether to enable the plug-in.
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 1
   * 
   * @deprecated
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-ubuwqygbq4783gqb2y3f87q****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 1667309705000
   * 
   * @deprecated
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The update time.
   * 
   * @example
   * 1667309705000
   * 
   * @deprecated
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the plug-in configuration.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The ID of the gateway plug-in.
   * 
   * @example
   * 2
   */
  pluginId?: number;
  resourceIdList?: number[];
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      config: 'Config',
      configLevel: 'ConfigLevel',
      enable: 'Enable',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      pluginId: 'PluginId',
      resourceIdList: 'ResourceIdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      config: 'string',
      configLevel: 'number',
      enable: 'boolean',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      pluginId: 'number',
      resourceIdList: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePluginConfigShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * zh: Chinese en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The plug-in configuration. Configurations of WebAssembly plug-ins are in the YAML format, and configurations of Lua plug-ins are in the Lua code.
   * 
   * @example
   * \\# Configure a check for the required fields of the plug-in, such as name, age, and friends. Sample configuration: name: John age: 18 friends: - David - Anne
   */
  config?: string;
  /**
   * @remarks
   * The application scope of the plug-in.
   * 
   * *   0: global
   * *   1: route
   * *   2: domain name
   * 
   * @example
   * 0
   */
  configLevel?: number;
  /**
   * @remarks
   * Specifies whether to enable the plug-in.
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 1
   * 
   * @deprecated
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-ubuwqygbq4783gqb2y3f87q****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 1667309705000
   * 
   * @deprecated
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The update time.
   * 
   * @example
   * 1667309705000
   * 
   * @deprecated
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the plug-in configuration.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The ID of the gateway plug-in.
   * 
   * @example
   * 2
   */
  pluginId?: number;
  resourceIdListShrink?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      config: 'Config',
      configLevel: 'ConfigLevel',
      enable: 'Enable',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      pluginId: 'PluginId',
      resourceIdListShrink: 'ResourceIdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      config: 'string',
      configLevel: 'number',
      enable: 'boolean',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      pluginId: 'number',
      resourceIdListShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePluginConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The ID of the plug-in configuration.
   * 
   * @example
   * 1
   */
  data?: number;
  /**
   * @remarks
   * The dynamic part in the error message.
   * 
   * @example
   * code
   */
  dynamicMessage?: string;
  /**
   * @remarks
   * The error code that is returned.
   * 
   * @example
   * 500
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 03A3E2F4-6804-5663-9D5D-2EC47A1*****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      dynamicMessage: 'string',
      errorCode: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePluginConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdatePluginConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdatePluginConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSSLCertRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the certificate.
   * 
   * @example
   * 5951436-cn-hangzhou
   */
  certIdentifier?: string;
  /**
   * @remarks
   * The ID of the domain name.
   * 
   * @example
   * 210
   */
  domainId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-2a99625886d54722be94d92e9a69****
   */
  gatewayUniqueId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      certIdentifier: 'CertIdentifier',
      domainId: 'DomainId',
      gatewayUniqueId: 'GatewayUniqueId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      certIdentifier: 'string',
      domainId: 'number',
      gatewayUniqueId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSSLCertResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the update is successful.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CA689BED-08F3-54C2-A206-A0924E2ACA0A
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSSLCertResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateSSLCertResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSSLCertResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateServiceSourceRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese.
   * *   en: English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The address.
   * 
   * @example
   * c9ad2a0717032427e920754e25b49e3b5
   */
  address?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 429
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-cdd1bb9bfb8341e9805f931a3ba1f4c6
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the service source.
   * 
   * @example
   * 63
   */
  id?: number;
  /**
   * @remarks
   * The configurations of Ingress resources.
   * 
   * @example
   * zh
   */
  ingressOptionsRequest?: UpdateServiceSourceRequestIngressOptionsRequest;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * istio
   */
  name?: string;
  /**
   * @remarks
   * An array of service root paths.
   */
  pathList?: string[];
  /**
   * @remarks
   * The service source. Valid values:
   * 
   * *   K8s: ACK cluster.
   * *   MSE: Nacos instance.
   * 
   * @example
   * K8s
   */
  source?: string;
  /**
   * @remarks
   * The type of the service source. Valid values:
   * 
   * *   K8s: ACK cluster.
   * *   NACOS: Nacos instance.
   * 
   * @example
   * K8s
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      address: 'Address',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      ingressOptionsRequest: 'IngressOptionsRequest',
      name: 'Name',
      pathList: 'PathList',
      source: 'Source',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      address: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
      ingressOptionsRequest: UpdateServiceSourceRequestIngressOptionsRequest,
      name: 'string',
      pathList: { 'type': 'array', 'itemType': 'string' },
      source: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateServiceSourceShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese.
   * *   en: English.
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The address.
   * 
   * @example
   * c9ad2a0717032427e920754e25b49e3b5
   */
  address?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 429
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-cdd1bb9bfb8341e9805f931a3ba1f4c6
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the service source.
   * 
   * @example
   * 63
   */
  id?: number;
  /**
   * @remarks
   * The configurations of Ingress resources.
   * 
   * @example
   * zh
   */
  ingressOptionsRequestShrink?: string;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * istio
   */
  name?: string;
  /**
   * @remarks
   * An array of service root paths.
   */
  pathListShrink?: string;
  /**
   * @remarks
   * The service source. Valid values:
   * 
   * *   K8s: ACK cluster.
   * *   MSE: Nacos instance.
   * 
   * @example
   * K8s
   */
  source?: string;
  /**
   * @remarks
   * The type of the service source. Valid values:
   * 
   * *   K8s: ACK cluster.
   * *   NACOS: Nacos instance.
   * 
   * @example
   * K8s
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      address: 'Address',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      ingressOptionsRequestShrink: 'IngressOptionsRequest',
      name: 'Name',
      pathListShrink: 'PathList',
      source: 'Source',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      address: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
      ingressOptionsRequestShrink: 'string',
      name: 'string',
      pathListShrink: 'string',
      source: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateServiceSourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   * 
   * @example
   * 63
   */
  data?: number;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6AB2B0B6-4A86-54E2-A340-FC47A22EE659
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateServiceSourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateServiceSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateServiceSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateZnodeRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse-09k1q11****
   */
  clusterId?: string;
  /**
   * @remarks
   * The data of the node.
   * 
   * This parameter is required.
   * 
   * @example
   * data
   */
  data?: string;
  /**
   * @remarks
   * The path of the node.
   * 
   * This parameter is required.
   * 
   * @example
   * /zookeeper
   */
  path?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clusterId: 'ClusterId',
      data: 'Data',
      path: 'Path',
      requestPars: 'RequestPars',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clusterId: 'string',
      data: 'string',
      path: 'string',
      requestPars: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateZnodeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 316F5F64-F73D-42DC-8632-01E308B6****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateZnodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateZnodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateZnodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpgradeClusterRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mse-cn-nif1w51wi0c
   */
  instanceId?: string;
  /**
   * @remarks
   * The extended request parameters in the JSON format.
   * 
   * @example
   * {}
   */
  requestPars?: string;
  /**
   * @remarks
   * The destination version.
   * 
   * This parameter is required.
   * 
   * @example
   * 1.2.1
   */
  upgradeVersion?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      instanceId: 'InstanceId',
      requestPars: 'RequestPars',
      upgradeVersion: 'UpgradeVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      instanceId: 'string',
      requestPars: 'string',
      upgradeVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpgradeClusterResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * mse-100-000
   */
  errorCode?: string;
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 202
   */
  httpCode?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * *   If the request is successful, a success message is returned.
   * *   If the request fails, an error message is returned.
   * 
   * @example
   * The request is successfully processed.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 8D855418-177B-5FF8-A021-75B930AD890A
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      httpCode: 'HttpCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      httpCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpgradeClusterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpgradeClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpgradeClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GatewayOptionLogConfigDetails extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  logEnabled?: boolean;
  logStoreName?: string;
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      logEnabled: 'LogEnabled',
      logStoreName: 'LogStoreName',
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logEnabled: 'boolean',
      logStoreName: 'string',
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GatewayOptionTraceDetails extends $tea.Model {
  sample?: number;
  serviceId?: number;
  servicePort?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  traceEnabled?: boolean;
  /**
   * @example
   * XTRACE
   */
  traceType?: string;
  static names(): { [key: string]: string } {
    return {
      sample: 'Sample',
      serviceId: 'ServiceId',
      servicePort: 'ServicePort',
      traceEnabled: 'TraceEnabled',
      traceType: 'TraceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sample: 'number',
      serviceId: 'number',
      servicePort: 'string',
      traceEnabled: 'boolean',
      traceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie extends $tea.Model {
  name?: string;
  path?: string;
  /**
   * @example
   * 0s
   */
  TTL?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      path: 'Path',
      TTL: 'TTL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      path: 'string',
      TTL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig extends $tea.Model {
  consistentHashLBType?: string;
  httpCookie?: TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie;
  parameterName?: string;
  static names(): { [key: string]: string } {
    return {
      consistentHashLBType: 'ConsistentHashLBType',
      httpCookie: 'HttpCookie',
      parameterName: 'ParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consistentHashLBType: 'string',
      httpCookie: TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie,
      parameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TrafficPolicyLoadBalancerSettings extends $tea.Model {
  consistentHashLBConfig?: TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig;
  /**
   * @example
   * RANDOM
   */
  loadbalancerType?: string;
  warmupDuration?: number;
  static names(): { [key: string]: string } {
    return {
      consistentHashLBConfig: 'ConsistentHashLBConfig',
      loadbalancerType: 'LoadbalancerType',
      warmupDuration: 'WarmupDuration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consistentHashLBConfig: TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig,
      loadbalancerType: 'string',
      warmupDuration: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TrafficPolicyTlsSetting extends $tea.Model {
  caCertContent?: string;
  certId?: string;
  sni?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * SIMPLE
   */
  tlsMode?: string;
  static names(): { [key: string]: string } {
    return {
      caCertContent: 'CaCertContent',
      certId: 'CertId',
      sni: 'Sni',
      tlsMode: 'TlsMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      caCertContent: 'string',
      certId: 'string',
      sni: 'string',
      tlsMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RulesValueRulesSpringcloudRestItems extends $tea.Model {
  datum?: string;
  operator?: string;
  nameList?: string[];
  cond?: string;
  divisor?: number;
  remainder?: number;
  /**
   * @example
   * 20
   */
  rate?: number;
  type?: string;
  name?: string;
  value?: any;
  static names(): { [key: string]: string } {
    return {
      datum: 'datum',
      operator: 'operator',
      nameList: 'nameList',
      cond: 'cond',
      divisor: 'divisor',
      remainder: 'remainder',
      rate: 'rate',
      type: 'type',
      name: 'name',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datum: 'string',
      operator: 'string',
      nameList: { 'type': 'array', 'itemType': 'string' },
      cond: 'string',
      divisor: 'number',
      remainder: 'number',
      rate: 'number',
      type: 'string',
      name: 'string',
      value: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RulesValueRulesSpringcloud extends $tea.Model {
  condition?: string;
  restItems?: RulesValueRulesSpringcloudRestItems[];
  triggerPolicy?: string;
  enable?: boolean;
  appId?: string;
  priority?: number;
  tags?: string[];
  paths?: string[];
  path?: string;
  static names(): { [key: string]: string } {
    return {
      condition: 'condition',
      restItems: 'restItems',
      triggerPolicy: 'triggerPolicy',
      enable: 'enable',
      appId: 'appId',
      priority: 'priority',
      tags: 'tags',
      paths: 'paths',
      path: 'path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      condition: 'string',
      restItems: { 'type': 'array', 'itemType': RulesValueRulesSpringcloudRestItems },
      triggerPolicy: 'string',
      enable: 'boolean',
      appId: 'string',
      priority: 'number',
      tags: { 'type': 'array', 'itemType': 'string' },
      paths: { 'type': 'array', 'itemType': 'string' },
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RulesValueRulesDubboArgumentItems extends $tea.Model {
  operator?: string;
  nameList?: string[];
  datum?: string;
  cond?: string;
  divisor?: number;
  remainder?: number;
  rate?: number;
  index?: number;
  expr?: string;
  value?: any;
  static names(): { [key: string]: string } {
    return {
      operator: 'operator',
      nameList: 'nameList',
      datum: 'datum',
      cond: 'cond',
      divisor: 'divisor',
      remainder: 'remainder',
      rate: 'rate',
      index: 'index',
      expr: 'expr',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operator: 'string',
      nameList: { 'type': 'array', 'itemType': 'string' },
      datum: 'string',
      cond: 'string',
      divisor: 'number',
      remainder: 'number',
      rate: 'number',
      index: 'number',
      expr: 'string',
      value: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RulesValueRulesDubbo extends $tea.Model {
  appId?: string;
  tags?: string[];
  triggerPolicy?: string;
  serviceName?: string;
  group?: string;
  version?: string;
  methodName?: string;
  paramTypes?: string[];
  /**
   * @example
   * AND
   */
  condition?: string;
  argumentItems?: RulesValueRulesDubboArgumentItems[];
  static names(): { [key: string]: string } {
    return {
      appId: 'appId',
      tags: 'tags',
      triggerPolicy: 'triggerPolicy',
      serviceName: 'serviceName',
      group: 'group',
      version: 'version',
      methodName: 'methodName',
      paramTypes: 'paramTypes',
      condition: 'condition',
      argumentItems: 'argumentItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      tags: { 'type': 'array', 'itemType': 'string' },
      triggerPolicy: 'string',
      serviceName: 'string',
      group: 'string',
      version: 'string',
      methodName: 'string',
      paramTypes: { 'type': 'array', 'itemType': 'string' },
      condition: 'string',
      argumentItems: { 'type': 'array', 'itemType': RulesValueRulesDubboArgumentItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RulesValueRules extends $tea.Model {
  springcloud?: RulesValueRulesSpringcloud[];
  dubbo?: RulesValueRulesDubbo[];
  static names(): { [key: string]: string } {
    return {
      springcloud: 'springcloud',
      dubbo: 'dubbo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      springcloud: { 'type': 'array', 'itemType': RulesValueRulesSpringcloud },
      dubbo: { 'type': 'array', 'itemType': RulesValueRulesDubbo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAuthResourceRequestAuthResourceHeaderList extends $tea.Model {
  /**
   * @remarks
   * The parameter of the HTTP header.
   * 
   * @example
   * Access-Control-Allow-Origin
   */
  headerKey?: string;
  /**
   * @remarks
   * The header matching mode.
   * 
   * Valid values:
   * 
   * *   SUFFIX
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   EXIST
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   PREFIX
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   EQUAL
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   EXCLUDE
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   NOT_EQUAL
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   NOT_EXIST
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   REGREX
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   INCLUDE
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * @example
   * EQUAL
   */
  headerMethod?: string;
  /**
   * @remarks
   * The parameter value of the HTTP header.
   * 
   * @example
   * *
   */
  headerValue?: string;
  static names(): { [key: string]: string } {
    return {
      headerKey: 'HeaderKey',
      headerMethod: 'HeaderMethod',
      headerValue: 'HeaderValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headerKey: 'string',
      headerMethod: 'string',
      headerValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayRequestTag extends $tea.Model {
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * key
   */
  key?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayRequestZoneInfo extends $tea.Model {
  /**
   * @remarks
   * The vSwitch ID.
   * 
   * @example
   * vsw-bp*****
   */
  vSwitchId?: string;
  /**
   * @remarks
   * The zone ID.
   * 
   * @example
   * cn-shenzhen-e
   */
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      vSwitchId: 'VSwitchId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      vSwitchId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayShrinkRequestTag extends $tea.Model {
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * key
   */
  key?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * code
   * 
   * @example
   * gw-5017305290e14cebbrvec4a5****
   */
  gatewayUniqueId?: string;
  static names(): { [key: string]: string } {
    return {
      gatewayUniqueId: 'GatewayUniqueId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gatewayUniqueId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayAuthRequestAuthResourceListAuthResourceHeaderList extends $tea.Model {
  /**
   * @example
   * x-req
   */
  headerKey?: string;
  /**
   * @example
   * EQUAL
   */
  headerMethod?: string;
  /**
   * @example
   * 123
   */
  headerValue?: string;
  static names(): { [key: string]: string } {
    return {
      headerKey: 'HeaderKey',
      headerMethod: 'HeaderMethod',
      headerValue: 'HeaderValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headerKey: 'string',
      headerMethod: 'string',
      headerValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayAuthRequestAuthResourceList extends $tea.Model {
  authResourceHeaderList?: AddGatewayAuthRequestAuthResourceListAuthResourceHeaderList[];
  /**
   * @remarks
   * The domain ID.
   * 
   * @example
   * 1
   */
  domainId?: number;
  /**
   * @example
   * true
   */
  ignoreCase?: boolean;
  /**
   * @example
   * EQUAL
   */
  matchType?: string;
  /**
   * @remarks
   * The request path.
   * 
   * @example
   * /test
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      authResourceHeaderList: 'AuthResourceHeaderList',
      domainId: 'DomainId',
      ignoreCase: 'IgnoreCase',
      matchType: 'MatchType',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authResourceHeaderList: { 'type': 'array', 'itemType': AddGatewayAuthRequestAuthResourceListAuthResourceHeaderList },
      domainId: 'number',
      ignoreCase: 'boolean',
      matchType: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayAuthRequestExternalAuthZJSON extends $tea.Model {
  /**
   * @remarks
   * The header that can be carried in an authentication request.
   */
  allowRequestHeaders?: string[];
  /**
   * @remarks
   * The header that can be retained in an authentication response.
   */
  allowUpstreamHeaders?: string[];
  /**
   * @example
   * 4000000
   */
  bodyMaxBytes?: number;
  /**
   * @remarks
   * Specifies whether the gateway allows a client request when the authentication server is unavailable. If a connection to the authentication server fails to be established or a 5xx error code is returned, the authentication server is unavailable.
   * 
   * @example
   * true
   */
  isRestrict?: boolean;
  /**
   * @remarks
   * The path of the authentication API provided by the authentication service. The path supports the prefix match method.
   * 
   * @example
   * /auth
   */
  prefixPath?: string;
  /**
   * @remarks
   * The ID of the service.
   * 
   * @example
   * 1
   */
  serviceId?: number;
  /**
   * @remarks
   * The timeout period. Unit: seconds.
   * 
   * @example
   * 100
   */
  timeout?: number;
  /**
   * @remarks
   * The header that stores a token in an authentication request. In most cases, a token is stored in the Authorization or Cookie header.
   * 
   * @example
   * Authorization
   */
  tokenKey?: string;
  /**
   * @example
   * true
   */
  withRequestBody?: boolean;
  static names(): { [key: string]: string } {
    return {
      allowRequestHeaders: 'AllowRequestHeaders',
      allowUpstreamHeaders: 'AllowUpstreamHeaders',
      bodyMaxBytes: 'BodyMaxBytes',
      isRestrict: 'IsRestrict',
      prefixPath: 'PrefixPath',
      serviceId: 'ServiceId',
      timeout: 'Timeout',
      tokenKey: 'TokenKey',
      withRequestBody: 'WithRequestBody',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowRequestHeaders: { 'type': 'array', 'itemType': 'string' },
      allowUpstreamHeaders: { 'type': 'array', 'itemType': 'string' },
      bodyMaxBytes: 'number',
      isRestrict: 'boolean',
      prefixPath: 'string',
      serviceId: 'number',
      timeout: 'number',
      tokenKey: 'string',
      withRequestBody: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayRouteRequestDirectResponseJSON extends $tea.Model {
  /**
   * @remarks
   * The mock return value.
   * 
   * @example
   * hello
   */
  body?: string;
  /**
   * @remarks
   * The mock return code.
   * 
   * @example
   * 403
   */
  code?: number;
  static names(): { [key: string]: string } {
    return {
      body: 'Body',
      code: 'Code',
    };
  }

  static types(): { [key: string]: any } {
    return {
      body: 'string',
      code: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayRouteRequestFallbackServices extends $tea.Model {
  /**
   * @remarks
   * The type of the protocol.
   * 
   * @example
   * DUBBO
   */
  agreementType?: string;
  /**
   * @remarks
   * The name of the group to which the service belongs.
   * 
   * @example
   * test
   */
  groupName?: string;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * user
   */
  name?: string;
  /**
   * @remarks
   * The namespace to which the service belongs.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The weight in the form of a percentage value.
   * 
   * @example
   * 80
   */
  percent?: number;
  /**
   * @remarks
   * The ID of the service.
   * 
   * @example
   * 353
   */
  serviceId?: number;
  /**
   * @remarks
   * The service port number.
   * 
   * @example
   * 443
   */
  servicePort?: number;
  /**
   * @remarks
   * The source type.
   * 
   * @example
   * MSE
   */
  sourceType?: string;
  /**
   * @remarks
   * The version of the service.
   * 
   * @example
   * v1
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      agreementType: 'AgreementType',
      groupName: 'GroupName',
      name: 'Name',
      namespace: 'Namespace',
      percent: 'Percent',
      serviceId: 'ServiceId',
      servicePort: 'ServicePort',
      sourceType: 'SourceType',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      agreementType: 'string',
      groupName: 'string',
      name: 'string',
      namespace: 'string',
      percent: 'number',
      serviceId: 'number',
      servicePort: 'number',
      sourceType: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayRouteRequestPredicatesHeaderPredicates extends $tea.Model {
  /**
   * @remarks
   * The key of the request header.
   * 
   * @example
   * debug
   */
  key?: string;
  /**
   * @remarks
   * The matching type.
   * 
   * @example
   * PRE
   */
  type?: string;
  /**
   * @remarks
   * The value of the request header.
   * 
   * @example
   * test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayRouteRequestPredicatesPathPredicates extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to ignore case sensitivity.
   * 
   * @example
   * true
   */
  ignoreCase?: boolean;
  /**
   * @remarks
   * The path.
   * 
   * @example
   * /test
   */
  path?: string;
  /**
   * @remarks
   * The route matching type. Valid values:
   * 
   * *   PRE: prefix matching
   * *   EQUAL: exact matching
   * *   ERGULAR: regular expression matching
   * 
   * @example
   * PRE
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      ignoreCase: 'IgnoreCase',
      path: 'Path',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ignoreCase: 'boolean',
      path: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayRouteRequestPredicatesQueryPredicates extends $tea.Model {
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * userid
   */
  key?: string;
  /**
   * @remarks
   * The matching type.
   * 
   * @example
   * PRE
   */
  type?: string;
  /**
   * @remarks
   * The value of the parameter.
   * 
   * @example
   * test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayRouteRequestPredicates extends $tea.Model {
  /**
   * @remarks
   * The information about header matching.
   */
  headerPredicates?: AddGatewayRouteRequestPredicatesHeaderPredicates[];
  /**
   * @remarks
   * The information about method matching.
   */
  methodPredicates?: string[];
  /**
   * @remarks
   * The information about route matching.
   */
  pathPredicates?: AddGatewayRouteRequestPredicatesPathPredicates;
  /**
   * @remarks
   * The information about URL parameter matching.
   */
  queryPredicates?: AddGatewayRouteRequestPredicatesQueryPredicates[];
  static names(): { [key: string]: string } {
    return {
      headerPredicates: 'HeaderPredicates',
      methodPredicates: 'MethodPredicates',
      pathPredicates: 'PathPredicates',
      queryPredicates: 'QueryPredicates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headerPredicates: { 'type': 'array', 'itemType': AddGatewayRouteRequestPredicatesHeaderPredicates },
      methodPredicates: { 'type': 'array', 'itemType': 'string' },
      pathPredicates: AddGatewayRouteRequestPredicatesPathPredicates,
      queryPredicates: { 'type': 'array', 'itemType': AddGatewayRouteRequestPredicatesQueryPredicates },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayRouteRequestRedirectJSON extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 302
   */
  code?: number;
  /**
   * @remarks
   * The hostname to be redirected to.
   * 
   * @example
   * test.com
   */
  host?: string;
  /**
   * @remarks
   * The path to be redirected to.
   * 
   * @example
   * /test
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      host: 'Host',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      host: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList extends $tea.Model {
  /**
   * @remarks
   * The key extracted from the input parameter.
   * 
   * @example
   * name
   */
  extractKey?: string;
  /**
   * @remarks
   * The position of the input parameter.
   * 
   * > Valid values:
   * 
   * *   `ALL_QUERY_PARAMETER`: request parameter
   * 
   * *   `ALL_HEADER`: request header
   * *   `ALL_PATH`: request path
   * *   `ALL_BODY`: request body
   * 
   * @example
   * ALL_QUERY_PARAMETER
   */
  extractKeySpec?: string;
  /**
   * @remarks
   * The type of the backend service parameter.
   * 
   * @example
   * java.lang.String
   */
  mappingType?: string;
  static names(): { [key: string]: string } {
    return {
      extractKey: 'ExtractKey',
      extractKeySpec: 'ExtractKeySpec',
      mappingType: 'MappingType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extractKey: 'string',
      extractKeySpec: 'string',
      mappingType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList extends $tea.Model {
  /**
   * @remarks
   * The method name of the Dubbo service.
   * 
   * @example
   * sayHello
   */
  dubboMothedName?: string;
  /**
   * @remarks
   * The HTTP method.
   * 
   * > Valid values:
   * 
   * *   ALL_GET
   * 
   * *   ALL_POST
   * 
   * *   ALL_PUT
   * 
   * *   ALL_DELETE
   * 
   * *   ALL_PATCH
   * 
   * @example
   * ALL_GET
   */
  httpMothed?: string;
  /**
   * @remarks
   * The path used for method matching.
   * 
   * @example
   * /mytestzbk/sayhello
   */
  mothedpath?: string;
  /**
   * @remarks
   * The information about parameter mappings.
   */
  paramMapsList?: AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList[];
  /**
   * @remarks
   * The pass-through type of the header.
   * 
   * > Valid values:
   * 
   * *   PASS_ALL: All headers are passed through.
   * 
   * *   PASS_NOT: All headers are not passed through.
   * 
   * *   PASS_ASSIGN: Specified headers are passed through.
   * 
   * @example
   * PASS_NOT
   */
  passThroughAllHeaders?: string;
  /**
   * @remarks
   * The list of headers to be passed through.
   */
  passThroughList?: string[];
  static names(): { [key: string]: string } {
    return {
      dubboMothedName: 'DubboMothedName',
      httpMothed: 'HttpMothed',
      mothedpath: 'Mothedpath',
      paramMapsList: 'ParamMapsList',
      passThroughAllHeaders: 'PassThroughAllHeaders',
      passThroughList: 'PassThroughList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dubboMothedName: 'string',
      httpMothed: 'string',
      mothedpath: 'string',
      paramMapsList: { 'type': 'array', 'itemType': AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList },
      passThroughAllHeaders: 'string',
      passThroughList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayRouteRequestServicesHttpDubboTranscoder extends $tea.Model {
  /**
   * @remarks
   * The name of the service group.
   * 
   * @example
   * None
   */
  dubboServiceGroup?: string;
  /**
   * @remarks
   * The name of the Dubbo service.
   * 
   * @example
   * org.apache.dubbo.samples.basic.api.DemoService
   */
  dubboServiceName?: string;
  /**
   * @remarks
   * The version of the Dubbo service.
   * 
   * @example
   * 0.0.0
   */
  dubboServiceVersion?: string;
  /**
   * @remarks
   * The forwarding rules of the Dubbo service.
   */
  mothedMapList?: AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList[];
  static names(): { [key: string]: string } {
    return {
      dubboServiceGroup: 'DubboServiceGroup',
      dubboServiceName: 'DubboServiceName',
      dubboServiceVersion: 'DubboServiceVersion',
      mothedMapList: 'MothedMapList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dubboServiceGroup: 'string',
      dubboServiceName: 'string',
      dubboServiceVersion: 'string',
      mothedMapList: { 'type': 'array', 'itemType': AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewayRouteRequestServices extends $tea.Model {
  /**
   * @remarks
   * The type of the protocol.
   * 
   * @example
   * DUBBO
   */
  agreementType?: string;
  /**
   * @remarks
   * The name of the group to which the service belongs.
   * 
   * @example
   * test
   */
  groupName?: string;
  /**
   * @remarks
   * The transcoder of the Dubbo protocol.
   */
  httpDubboTranscoder?: AddGatewayRouteRequestServicesHttpDubboTranscoder;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * user
   */
  name?: string;
  /**
   * @remarks
   * The namespace to which the service belongs.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The weight in the form of a percentage value.
   * 
   * @example
   * 80
   */
  percent?: number;
  /**
   * @remarks
   * The ID of the service.
   * 
   * @example
   * 353
   */
  serviceId?: number;
  /**
   * @remarks
   * The service port number.
   * 
   * @example
   * 443
   */
  servicePort?: number;
  /**
   * @remarks
   * The source type.
   * 
   * @example
   * MSE
   */
  sourceType?: string;
  /**
   * @remarks
   * The version of the service.
   * 
   * @example
   * v1
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      agreementType: 'AgreementType',
      groupName: 'GroupName',
      httpDubboTranscoder: 'HttpDubboTranscoder',
      name: 'Name',
      namespace: 'Namespace',
      percent: 'Percent',
      serviceId: 'ServiceId',
      servicePort: 'ServicePort',
      sourceType: 'SourceType',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      agreementType: 'string',
      groupName: 'string',
      httpDubboTranscoder: AddGatewayRouteRequestServicesHttpDubboTranscoder,
      name: 'string',
      namespace: 'string',
      percent: 'number',
      serviceId: 'number',
      servicePort: 'number',
      sourceType: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGatewaySlbRequestVServiceList extends $tea.Model {
  /**
   * @remarks
   * The port number.
   * 
   * @example
   * 443
   */
  port?: number;
  /**
   * @remarks
   * The protocol type. Valid values:
   * 
   * *   HTTP
   * *   HTTPS
   * 
   * @example
   * HTTPS
   */
  protocol?: string;
  /**
   * @remarks
   * The ID of the virtual server group.
   * 
   * @example
   * rsp-bp1j**t0fyl**
   */
  VServerGroupId?: string;
  /**
   * @remarks
   * The name of the virtual server group.
   */
  VServerGroupName?: string;
  static names(): { [key: string]: string } {
    return {
      port: 'Port',
      protocol: 'Protocol',
      VServerGroupId: 'VServerGroupId',
      VServerGroupName: 'VServerGroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      port: 'number',
      protocol: 'string',
      VServerGroupId: 'string',
      VServerGroupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMigrationTaskResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The type of the instance. Valid values:
   * 
   * *   Nacos-Ans
   * *   ZooKeeper
   * *   Eureka
   * 
   * @example
   * Nacos-Ans
   */
  clusterType?: string;
  /**
   * @remarks
   * The ID of the task.
   * 
   * @example
   * 12
   */
  id?: string;
  /**
   * @remarks
   * The endpoint of the source instance node.
   * 
   * @example
   * 192.168.1.1:8848
   */
  originInstanceAddress?: string;
  /**
   * @remarks
   * The name of the source instance.
   * 
   * @example
   * Source instance
   */
  originInstanceName?: string;
  /**
   * @remarks
   * The list of namespaces. This parameter is optional if applications are migrated from a Nacos instance.
   * 
   * @example
   * namesapceId1,namesapceId2
   */
  originInstanceNamespace?: string;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * testsdfsdfsd
   */
  projectDesc?: string;
  syncType?: string;
  /**
   * @remarks
   * The name of the destination instance.
   * 
   * @example
   * Destination instance
   */
  targetClusterName?: string;
  /**
   * @remarks
   * The URL of the destination instance.
   * 
   * @example
   * mse-94d****-nacos-ans.mse.aliyuncs.com:8848
   */
  targetClusterUrl?: string;
  /**
   * @remarks
   * The ID of the destination instance.
   * 
   * @example
   * mse-cn-7pp2w*****
   */
  targetInstanceId?: string;
  /**
   * @remarks
   * The ID of the user.
   * 
   * @example
   * 183876217*****
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterType: 'ClusterType',
      id: 'Id',
      originInstanceAddress: 'OriginInstanceAddress',
      originInstanceName: 'OriginInstanceName',
      originInstanceNamespace: 'OriginInstanceNamespace',
      projectDesc: 'ProjectDesc',
      syncType: 'SyncType',
      targetClusterName: 'TargetClusterName',
      targetClusterUrl: 'TargetClusterUrl',
      targetInstanceId: 'TargetInstanceId',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterType: 'string',
      id: 'string',
      originInstanceAddress: 'string',
      originInstanceName: 'string',
      originInstanceNamespace: 'string',
      projectDesc: 'string',
      syncType: 'string',
      targetClusterName: 'string',
      targetClusterUrl: 'string',
      targetInstanceId: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMockRuleResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 178432728867xxxx
   */
  accountId?: string;
  /**
   * @remarks
   * The ID of the consumer application.
   * 
   * @example
   * hkhon1po62@a000601b265xxxx
   */
  consumerAppId?: string;
  /**
   * @remarks
   * The name of the consumer application.
   * 
   * @example
   * demo-xxxx
   */
  consumerAppName?: string;
  /**
   * @remarks
   * Indicates whether the mock rule is enabled.
   * 
   * *   `true`: enabled
   * *   `false`: disabled
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * desc
   */
  extraJson?: string;
  /**
   * @remarks
   * The ID of the rule.
   * 
   * @example
   * 275
   */
  id?: number;
  /**
   * @remarks
   * The mock type. Valid values:
   * 
   * *   \\- `[unk]0[unk]`: desktop client
   * *   \\- `[unk]1[unk]`: mobile client
   * 
   * @example
   * 0
   */
  mockType?: number;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * mse-bc1a29b0-160230875****-reg-center-0-1
   */
  name?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * cn-shanghai
   */
  namespaceId?: string;
  /**
   * @remarks
   * The ID of the service provider application.
   * 
   * @example
   * hkhon1po62@a000601b265xxxx
   */
  providerAppId?: string;
  /**
   * @remarks
   * The name of the service provider application.
   * 
   * @example
   * demo-xxxx
   */
  providerAppName?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-shanghai
   */
  region?: string;
  /**
   * @remarks
   * The HTTP mock rule.
   * 
   * @example
   * [{"oper":"return+json","Path":"/mock","Value":"{\\n \\"date\\": \\"2021-09-10T07:45:12.357+0000\\",\\n \\"name\\": \\"name\\",\\n \\"id\\": \\"1\\"\\n}","Method":"GET","Condition":"AND","Timeout":1,"ArgumentMockItems":[{"type":"param","name":"id","value":"1","cond":"==","operator":"rawvalue"},{"type":"param","name":"name","value":"aliyun","cond":"==","operator":"rawvalue"}]}]
   */
  scMockItemJson?: string;
  /**
   * @remarks
   * The service source.
   * 
   * @example
   * edasmsc
   */
  source?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'AccountId',
      consumerAppId: 'ConsumerAppId',
      consumerAppName: 'ConsumerAppName',
      enable: 'Enable',
      extraJson: 'ExtraJson',
      id: 'Id',
      mockType: 'MockType',
      name: 'Name',
      namespaceId: 'NamespaceId',
      providerAppId: 'ProviderAppId',
      providerAppName: 'ProviderAppName',
      region: 'Region',
      scMockItemJson: 'ScMockItemJson',
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
      consumerAppId: 'string',
      consumerAppName: 'string',
      enable: 'boolean',
      extraJson: 'string',
      id: 'number',
      mockType: 'number',
      name: 'string',
      namespaceId: 'string',
      providerAppId: 'string',
      providerAppName: 'string',
      region: 'string',
      scMockItemJson: 'string',
      source: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddServiceSourceRequestIngressOptionsRequest extends $tea.Model {
  /**
   * @remarks
   * The group to which the service belongs.
   * 
   * @example
   * true
   */
  enableIngress?: boolean;
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh-CN: Chinese. This is the default value.
   * *   en-US: English.
   * *   ja: Japanese.
   * 
   * @example
   * true
   */
  enableStatus?: boolean;
  /**
   * @remarks
   * An array of service root paths.
   * 
   * @example
   * com.test.xxx
   */
  ingressClass?: string;
  /**
   * @remarks
   * The root path of the service.
   * 
   * @example
   * default
   */
  watchNamespace?: string;
  static names(): { [key: string]: string } {
    return {
      enableIngress: 'EnableIngress',
      enableStatus: 'EnableStatus',
      ingressClass: 'IngressClass',
      watchNamespace: 'WatchNamespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableIngress: 'boolean',
      enableStatus: 'boolean',
      ingressClass: 'string',
      watchNamespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddServiceSourceRequestToAuthorizeSecurityGroups extends $tea.Model {
  /**
   * @remarks
   * The description of the authorization record.
   * 
   * @example
   * rule for xxx
   */
  description?: string;
  /**
   * @remarks
   * The authorized port range of the security group. You can select multiple port ranges. Separate each port range with a comma (,).
   * 
   * @example
   * 8080/8080,9000/10000
   */
  portRange?: string;
  /**
   * @remarks
   * The ID of the security group.
   * 
   * @example
   * sg-bp1acepclex0vmi1****
   */
  securityGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      portRange: 'PortRange',
      securityGroupId: 'SecurityGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      portRange: 'string',
      securityGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyTagPoliciesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the field is the primary key.
   * 
   * @example
   * true
   */
  carryData?: boolean;
  /**
   * @remarks
   * Indicates whether the rule is enabled. Valid values:
   * 
   * *   `true`: The rule is enabled.
   * *   `false`: The rule is disabled.
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The ID of the primary key.
   * 
   * @example
   * 12
   */
  id?: number;
  /**
   * @remarks
   * The number of instances.
   * 
   * @example
   * 1
   */
  instanceNum?: number;
  /**
   * @remarks
   * The policy name.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The rate.
   * 
   * @example
   * 10
   */
  rate?: number;
  /**
   * @remarks
   * Indicates whether the routing rule was deleted.
   */
  remove?: boolean;
  /**
   * @remarks
   * The details of the routing rule.
   * 
   * @example
   * {\\"_base\\": {\\"rate\\": 100, \\"remove\\": true}, \\"blue\\": {\\"rate\\": 0}}
   */
  rules?: string;
  /**
   * @remarks
   * The status.
   * 
   * @example
   * 1
   */
  status?: number;
  /**
   * @remarks
   * The tag.
   * 
   * @example
   * gray
   */
  tag?: string;
  static names(): { [key: string]: string } {
    return {
      carryData: 'CarryData',
      enable: 'Enable',
      id: 'Id',
      instanceNum: 'InstanceNum',
      name: 'Name',
      rate: 'Rate',
      remove: 'Remove',
      rules: 'Rules',
      status: 'Status',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      carryData: 'boolean',
      enable: 'boolean',
      id: 'number',
      instanceNum: 'number',
      name: 'string',
      rate: 'number',
      remove: 'boolean',
      rules: 'string',
      status: 'number',
      tag: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloneNacosConfigResponseBodyDataFailData extends $tea.Model {
  /**
   * @remarks
   * mse-200-105
   * 
   * @example
   * test2.yaml
   */
  dataId?: string;
  /**
   * @remarks
   * duplicatedClusterAliasName
   * 
   * @example
   * test
   */
  group?: string;
  reason?: string;
  static names(): { [key: string]: string } {
    return {
      dataId: 'DataId',
      group: 'Group',
      reason: 'Reason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataId: 'string',
      group: 'string',
      reason: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloneNacosConfigResponseBodyDataSkipData extends $tea.Model {
  /**
   * @remarks
   * The details of the failed configurations.
   * 
   * @example
   * test.yaml
   */
  dataId?: string;
  /**
   * @remarks
   * The data structure.
   * 
   * @example
   * public
   */
  group?: string;
  static names(): { [key: string]: string } {
    return {
      dataId: 'DataId',
      group: 'Group',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataId: 'string',
      group: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloneNacosConfigResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The details of the failed configurations.
   */
  failData?: CloneNacosConfigResponseBodyDataFailData[];
  /**
   * @remarks
   * The data structure.
   * 
   * @example
   * 1
   */
  skipCount?: number;
  /**
   * @remarks
   * The ID of the data.
   */
  skipData?: CloneNacosConfigResponseBodyDataSkipData[];
  /**
   * @remarks
   * The details of the skipped configurations.
   * 
   * @example
   * 100
   */
  succCount?: number;
  static names(): { [key: string]: string } {
    return {
      failData: 'FailData',
      skipCount: 'SkipCount',
      skipData: 'SkipData',
      succCount: 'SuccCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failData: { 'type': 'array', 'itemType': CloneNacosConfigResponseBodyDataFailData },
      skipCount: 'number',
      skipData: { 'type': 'array', 'itemType': CloneNacosConfigResponseBodyDataSkipData },
      succCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateApplicationResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the application.
   * 
   * @example
   * xxxxxxxx@xxxxxxxxxx
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 1631001140913
   */
  createTime?: number;
  /**
   * @remarks
   * The additional information.
   * 
   * @example
   * {\\"rpcTypes\\":[\\"dubbo\\",\\"springCloud\\"]}
   */
  extraInfo?: string;
  /**
   * @remarks
   * The programming language of the application.
   * 
   * @example
   * JAVA
   */
  language?: string;
  /**
   * @remarks
   * The license key in use.
   * 
   * @example
   * xxxxxxxx@xxxxxxxxxx
   */
  licenseKey?: string;
  /**
   * @remarks
   * MSE命名空间名字。
   * 
   * @example
   * prod
   */
  namespace?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The service where the application is deployed. Valid values:
   * 
   * *   \\- ACK: Container Service for Kubernetes
   * *   \\- Normal: another service
   * 
   * @example
   * ACK
   */
  source?: string;
  /**
   * @remarks
   * The status of the application. A value of 1 indicates that the application is in a normal state.
   * 
   * @example
   * 1
   */
  status?: number;
  /**
   * @remarks
   * The update time.
   * 
   * @example
   * 1632979237663
   */
  updateTime?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 1888888888
   */
  userId?: string;
  /**
   * @remarks
   * 版本号。
   * 
   * @example
   * 1.0.0
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      createTime: 'CreateTime',
      extraInfo: 'ExtraInfo',
      language: 'Language',
      licenseKey: 'LicenseKey',
      namespace: 'Namespace',
      regionId: 'RegionId',
      source: 'Source',
      status: 'Status',
      updateTime: 'UpdateTime',
      userId: 'UserId',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appName: 'string',
      createTime: 'number',
      extraInfo: 'string',
      language: 'string',
      licenseKey: 'string',
      namespace: 'string',
      regionId: 'string',
      source: 'string',
      status: 'number',
      updateTime: 'number',
      userId: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCircuitBreakerRuleResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the application.
   * 
   * @example
   * hkhon1po62@c3df23522bXXXXX
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * Indicates whether the rule is enabled.
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The minimum number of requests that can be passed in each step after circuit breaking recovers.
   * 
   * @example
   * 5
   */
  halfOpenBaseAmountPerStep?: number;
  /**
   * @remarks
   * The number of circuit breaking recovery steps.
   * 
   * @example
   * 1
   */
  halfOpenRecoveryStepNum?: number;
  /**
   * @remarks
   * The ID of the rule.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The maximum response time (RT). Unit: milliseconds. If the RT of a request is greater than the value of this parameter, a slow call is counted. If you set Strategy to 0, you must specify this parameter.
   * 
   * @example
   * 200
   */
  maxAllowedRtMs?: number;
  /**
   * @remarks
   * The minimum number of requests to trigger circuit breaking. If the number of requests in the current time window is less than the value of this parameter, circuit breaking is not triggered even if the circuit breaking rule is met.
   * 
   * @example
   * 10
   */
  minRequestAmount?: number;
  /**
   * @remarks
   * The microservice namespace to which the application belongs.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The region in which the instance resides.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the interface to which the rule is applicable. The interface name must be the same as the name on the interface details page in the console.
   * 
   * @example
   * /a
   */
  resource?: string;
  /**
   * @remarks
   * The period in which circuit breaking is implemented. Unit: milliseconds. If circuit breaking is implemented on the requests for the route, the calls to all the requests for the route fail in the configured circuit breaking period.
   * 
   * @example
   * 10000
   */
  retryTimeoutMs?: number;
  /**
   * @remarks
   * The length of the time window. Unit: milliseconds. The valid range is from 1 second to 120 minutes.
   * 
   * @example
   * 20000
   */
  statIntervalMs?: number;
  /**
   * @remarks
   * The threshold type.
   * 
   * Valid values:
   * 
   * *   0
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     Slow call ratio
   * 
   *     <!-- -->
   * 
   * *   1
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     Abnormal proportion
   * 
   *     <!-- -->
   * 
   * @example
   * 0
   */
  strategy?: number;
  /**
   * @remarks
   * A percentage threshold for triggering circuit breaking. Valid values: 0-1. These values represent 0% to 100%.
   * 
   * @example
   * 0.8
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      enable: 'Enable',
      halfOpenBaseAmountPerStep: 'HalfOpenBaseAmountPerStep',
      halfOpenRecoveryStepNum: 'HalfOpenRecoveryStepNum',
      id: 'Id',
      maxAllowedRtMs: 'MaxAllowedRtMs',
      minRequestAmount: 'MinRequestAmount',
      namespace: 'Namespace',
      regionId: 'RegionId',
      resource: 'Resource',
      retryTimeoutMs: 'RetryTimeoutMs',
      statIntervalMs: 'StatIntervalMs',
      strategy: 'Strategy',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appName: 'string',
      enable: 'boolean',
      halfOpenBaseAmountPerStep: 'number',
      halfOpenRecoveryStepNum: 'number',
      id: 'number',
      maxAllowedRtMs: 'number',
      minRequestAmount: 'number',
      namespace: 'string',
      regionId: 'string',
      resource: 'string',
      retryTimeoutMs: 'number',
      statIntervalMs: 'number',
      strategy: 'number',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of tag N to add to the resource.
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The value of tag N to add to the resource.
   * 
   * @example
   * prd
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEngineNamespaceResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The number of configurations.
   * 
   * @example
   * 1
   */
  configCount?: number;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * f4fa5b81-2f26-4900-833a-7516b315ebb2
   */
  namespace?: string;
  /**
   * @remarks
   * The description of the namespace.
   * 
   * @example
   * mytest
   */
  namespaceDesc?: string;
  /**
   * @remarks
   * The display name of the namespace.
   * 
   * @example
   * dev
   */
  namespaceShowName?: string;
  /**
   * @remarks
   * The quota of configurations.
   * 
   * @example
   * 1
   */
  quota?: number;
  /**
   * @remarks
   * The number of active services.
   * 
   * @example
   * 3
   */
  serviceCount?: number;
  /**
   * @remarks
   * The type of the namespace. Valid values:
   * 
   * *   `0`: global configuration
   * *   `1`: default namespace
   * *   `2`: custom namespace
   * 
   * @example
   * 1
   */
  type?: number;
  static names(): { [key: string]: string } {
    return {
      configCount: 'ConfigCount',
      namespace: 'Namespace',
      namespaceDesc: 'NamespaceDesc',
      namespaceShowName: 'NamespaceShowName',
      quota: 'Quota',
      serviceCount: 'ServiceCount',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configCount: 'number',
      namespace: 'string',
      namespaceDesc: 'string',
      namespaceShowName: 'string',
      quota: 'number',
      serviceCount: 'number',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowRuleResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * hkhon1po62@54e1f42f3******
   */
  appId?: string;
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * The throttling effect.
   * 
   * Valid values:
   * 
   * *   0
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     fast failure
   * 
   *     <!-- -->
   * 
   * *   2
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     in queue
   * 
   *     <!-- -->
   * 
   * @example
   * 0
   */
  controlBehavior?: number;
  /**
   * @remarks
   * Indicates whether the rule is enabled.
   * 
   * Valid values:
   * 
   * *   true
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   false
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The ID.
   * 
   * @example
   * 12
   */
  id?: number;
  /**
   * @remarks
   * The timeout period for queuing when the value of ControlBehavior is set to 2. Unit: milliseconds.
   * 
   * @example
   * 500
   */
  maxQueueingTimeMs?: number;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the API resource.
   * 
   * @example
   * app
   */
  resource?: string;
  /**
   * @remarks
   * The throttling threshold.
   * 
   * @example
   * 200
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      controlBehavior: 'ControlBehavior',
      enable: 'Enable',
      id: 'Id',
      maxQueueingTimeMs: 'MaxQueueingTimeMs',
      namespace: 'Namespace',
      regionId: 'RegionId',
      resource: 'Resource',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appName: 'string',
      controlBehavior: 'number',
      enable: 'boolean',
      id: 'number',
      maxQueueingTimeMs: 'number',
      namespace: 'string',
      regionId: 'string',
      resource: 'string',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateIsolationRuleResponseBodyData extends $tea.Model {
  /**
   * @example
   * hpn9ac29kz@e31a4b871******
   */
  appId?: string;
  /**
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @example
   * 1
   */
  id?: number;
  /**
   * @example
   * default
   */
  namespace?: string;
  /**
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @example
   * /a
   */
  resource?: string;
  /**
   * @example
   * 3
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      enable: 'Enable',
      id: 'Id',
      namespace: 'Namespace',
      regionId: 'RegionId',
      resource: 'Resource',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appName: 'string',
      enable: 'boolean',
      id: 'number',
      namespace: 'string',
      regionId: 'string',
      resource: 'string',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMseServiceApplicationResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * xxxxxxxx@xxxxxxxxxx
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 1631001140913
   */
  createTime?: number;
  /**
   * @remarks
   * The additional information.
   * 
   * @example
   * {}
   */
  extraInfo?: string;
  /**
   * @remarks
   * The programming language of the application.
   * 
   * @example
   * JAVA
   */
  language?: string;
  /**
   * @remarks
   * The license key in use.
   * 
   * @example
   * xxxxxxxx@xxxxxxxxxx
   */
  licenseKey?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The source type.
   * 
   * @example
   * edasmsc
   */
  source?: string;
  /**
   * @remarks
   * The status. Valid values: 1: available; 2: deleted.
   * 
   * @example
   * 1
   */
  status?: number;
  /**
   * @remarks
   * The last modification time.
   * 
   * @example
   * 1632979237663
   */
  updateTime?: number;
  /**
   * @remarks
   * The ID of the user.
   * 
   * @example
   * 1234567890
   */
  userId?: string;
  /**
   * @remarks
   * The version information.
   * 
   * @example
   * 1.0.0
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      createTime: 'CreateTime',
      extraInfo: 'ExtraInfo',
      language: 'Language',
      licenseKey: 'LicenseKey',
      regionId: 'RegionId',
      source: 'Source',
      status: 'Status',
      updateTime: 'UpdateTime',
      userId: 'UserId',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appName: 'string',
      createTime: 'number',
      extraInfo: 'string',
      language: 'string',
      licenseKey: 'string',
      regionId: 'string',
      source: 'string',
      status: 'number',
      updateTime: 'number',
      userId: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems extends $tea.Model {
  cond?: string;
  datum?: string;
  divisor?: number;
  name?: string;
  nameList?: string[];
  operator?: string;
  rate?: number;
  remainder?: number;
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      cond: 'Cond',
      datum: 'Datum',
      divisor: 'Divisor',
      name: 'Name',
      nameList: 'NameList',
      operator: 'Operator',
      rate: 'Rate',
      remainder: 'Remainder',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cond: 'string',
      datum: 'string',
      divisor: 'number',
      name: 'string',
      nameList: { 'type': 'array', 'itemType': 'string' },
      operator: 'string',
      rate: 'number',
      remainder: 'number',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSwimmingLaneRequestEntryRules extends $tea.Model {
  /**
   * @example
   * AND
   */
  condition?: string;
  paths?: string[];
  priority?: number;
  restItems?: CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems[];
  static names(): { [key: string]: string } {
    return {
      condition: 'Condition',
      paths: 'Paths',
      priority: 'Priority',
      restItems: 'RestItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      condition: 'string',
      paths: { 'type': 'array', 'itemType': 'string' },
      priority: 'number',
      restItems: { 'type': 'array', 'itemType': CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions extends $tea.Model {
  /**
   * @remarks
   * The matching condition. Valid values:
   * 
   * *   PRE: prefix matching
   * *   EQUAL: exact matching
   * *   ERGULAR: regular expression matching
   * 
   * @example
   * PRE
   */
  cond?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * name
   */
  name?: string;
  /**
   * @remarks
   * The type of the parameter. Valid values:
   * 
   * *   header
   * *   param
   * 
   * @example
   * header
   */
  type?: string;
  /**
   * @remarks
   * The value of the parameter.
   * 
   * @example
   * xiaoming
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      cond: 'Cond',
      name: 'Name',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cond: 'string',
      name: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonRouteIndependentPercentageList extends $tea.Model {
  percentage?: number;
  routeId?: number;
  static names(): { [key: string]: string } {
    return {
      percentage: 'Percentage',
      routeId: 'RouteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      percentage: 'number',
      routeId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson extends $tea.Model {
  /**
   * @example
   * 0
   */
  canaryModel?: number;
  condition?: string;
  /**
   * @remarks
   * The matching conditions.
   */
  conditions?: CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions[];
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 1
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-84efde2ee1464260bdb17a5b****
   */
  gatewayUniqueId?: string;
  /**
   * @example
   * 20
   */
  percentage?: number;
  /**
   * @remarks
   * The route IDs.
   */
  routeIdList?: number[];
  routeIndependentPercentageEnable?: boolean;
  routeIndependentPercentageList?: CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonRouteIndependentPercentageList[];
  static names(): { [key: string]: string } {
    return {
      canaryModel: 'CanaryModel',
      condition: 'Condition',
      conditions: 'Conditions',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      percentage: 'Percentage',
      routeIdList: 'RouteIdList',
      routeIndependentPercentageEnable: 'RouteIndependentPercentageEnable',
      routeIndependentPercentageList: 'RouteIndependentPercentageList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canaryModel: 'number',
      condition: 'string',
      conditions: { 'type': 'array', 'itemType': CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions },
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      percentage: 'number',
      routeIdList: { 'type': 'array', 'itemType': 'number' },
      routeIndependentPercentageEnable: 'boolean',
      routeIndependentPercentageList: { 'type': 'array', 'itemType': CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonRouteIndependentPercentageList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems extends $tea.Model {
  cond?: string;
  datum?: string;
  divisor?: number;
  name?: string;
  nameList?: string[];
  operator?: string;
  rate?: number;
  remainder?: number;
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      cond: 'Cond',
      datum: 'Datum',
      divisor: 'Divisor',
      name: 'Name',
      nameList: 'NameList',
      operator: 'Operator',
      rate: 'Rate',
      remainder: 'Remainder',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cond: 'string',
      datum: 'string',
      divisor: 'number',
      name: 'string',
      nameList: { 'type': 'array', 'itemType': 'string' },
      operator: 'string',
      rate: 'number',
      remainder: 'number',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSwimmingLaneShrinkRequestEntryRules extends $tea.Model {
  /**
   * @example
   * AND
   */
  condition?: string;
  paths?: string[];
  priority?: number;
  restItems?: CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems[];
  static names(): { [key: string]: string } {
    return {
      condition: 'Condition',
      paths: 'Paths',
      priority: 'Priority',
      restItems: 'RestItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      condition: 'string',
      paths: { 'type': 'array', 'itemType': 'string' },
      priority: 'number',
      restItems: { 'type': 'array', 'itemType': CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems extends $tea.Model {
  cond?: string;
  datum?: string;
  divisor?: number;
  name?: string;
  nameList?: string[];
  operator?: string;
  rate?: number;
  remainder?: number;
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      cond: 'cond',
      datum: 'datum',
      divisor: 'divisor',
      name: 'name',
      nameList: 'nameList',
      operator: 'operator',
      rate: 'rate',
      remainder: 'remainder',
      type: 'type',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cond: 'string',
      datum: 'string',
      divisor: 'number',
      name: 'string',
      nameList: { 'type': 'array', 'itemType': 'string' },
      operator: 'string',
      rate: 'number',
      remainder: 'number',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules extends $tea.Model {
  condition?: string;
  path?: string;
  paths?: string[];
  restItems?: CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems[];
  static names(): { [key: string]: string } {
    return {
      condition: 'condition',
      path: 'path',
      paths: 'paths',
      restItems: 'restItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      condition: 'string',
      path: 'string',
      paths: { 'type': 'array', 'itemType': 'string' },
      restItems: { 'type': 'array', 'itemType': CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSwimmingLaneResponseBodyData extends $tea.Model {
  enable?: boolean;
  enableRules?: boolean;
  entryRule?: string;
  entryRules?: CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules[];
  gatewaySwimmingLaneRouteJson?: string;
  gmtCreate?: string;
  gmtModified?: string;
  groupId?: number;
  id?: number;
  name?: string;
  pathIndependentPercentageEnable?: boolean;
  regionId?: string;
  status?: number;
  tag?: string;
  static names(): { [key: string]: string } {
    return {
      enable: 'enable',
      enableRules: 'enableRules',
      entryRule: 'entryRule',
      entryRules: 'entryRules',
      gatewaySwimmingLaneRouteJson: 'gatewaySwimmingLaneRouteJson',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      groupId: 'groupId',
      id: 'id',
      name: 'name',
      pathIndependentPercentageEnable: 'pathIndependentPercentageEnable',
      regionId: 'regionId',
      status: 'status',
      tag: 'tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
      enableRules: 'boolean',
      entryRule: 'string',
      entryRules: { 'type': 'array', 'itemType': CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules },
      gatewaySwimmingLaneRouteJson: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      groupId: 'number',
      id: 'number',
      name: 'string',
      pathIndependentPercentageEnable: 'boolean',
      regionId: 'string',
      status: 'number',
      tag: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSwimmingLaneGroupResponseBodyData extends $tea.Model {
  /**
   * @example
   * abcd1@abcde123,abcd1@abcde124
   */
  appIds?: string;
  canaryModel?: number;
  /**
   * @example
   * true
   */
  dbGrayEnable?: string;
  /**
   * @example
   * mse:abcd1@a2345
   */
  entryApp?: string;
  id?: number;
  /**
   * @example
   * Client
   */
  messageQueueFilterSide?: string;
  messageQueueGrayEnable?: boolean;
  /**
   * @example
   * example-app
   */
  name?: string;
  /**
   * @example
   * prod
   */
  namespace?: string;
  paths?: string;
  recordCanaryDetail?: boolean;
  /**
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @example
   * 12345
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      appIds: 'AppIds',
      canaryModel: 'CanaryModel',
      dbGrayEnable: 'DbGrayEnable',
      entryApp: 'EntryApp',
      id: 'Id',
      messageQueueFilterSide: 'MessageQueueFilterSide',
      messageQueueGrayEnable: 'MessageQueueGrayEnable',
      name: 'Name',
      namespace: 'Namespace',
      paths: 'Paths',
      recordCanaryDetail: 'RecordCanaryDetail',
      region: 'Region',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appIds: 'string',
      canaryModel: 'number',
      dbGrayEnable: 'string',
      entryApp: 'string',
      id: 'number',
      messageQueueFilterSide: 'string',
      messageQueueGrayEnable: 'boolean',
      name: 'string',
      namespace: 'string',
      paths: 'string',
      recordCanaryDetail: 'boolean',
      region: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateZnodeResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The data of the node.
   * 
   * @example
   * cluster
   */
  data?: string;
  /**
   * @remarks
   * Indicates whether the node information was returned. Valid values:
   * 
   * *   `true`: The node information was returned.
   * *   `false`: The node information failed to be returned.
   * 
   * @example
   * true
   */
  dir?: boolean;
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * mse-bc1a29b0-160230875****-reg-center-0-1
   */
  name?: string;
  /**
   * @remarks
   * The path of the node.
   * 
   * @example
   * /
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      dir: 'Dir',
      name: 'Name',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      dir: 'boolean',
      name: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAuthResourceResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The authentication ID.
   * 
   * @example
   * 253
   */
  authId?: number;
  /**
   * @remarks
   * The ID of the domain name.
   * 
   * @example
   * 235
   */
  domainId?: number;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * name
   */
  domainName?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * gw-7ea3da97b96543e19f6c597cd4a9****
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-7ea3da97b96543e19f6c597cd4a9****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2022-01-07T10:07:57.000+0000
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The modification time.
   * 
   * @example
   * 2022-01-07T10:07:57.000+0000
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the primary key.
   * 
   * @example
   * 12
   */
  id?: number;
  /**
   * @remarks
   * Indicates whether the whitelist mode is enabled.
   * 
   * @example
   * true
   */
  isWhite?: boolean;
  /**
   * @remarks
   * The path.
   * 
   * @example
   * /zookeeper
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      authId: 'AuthId',
      domainId: 'DomainId',
      domainName: 'DomainName',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      isWhite: 'IsWhite',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authId: 'number',
      domainId: 'number',
      domainName: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      isWhite: 'boolean',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The unique ID of the gateway. The ID is automatically generated by the system.
   * 
   * @example
   * gw-7ea3da97b96543e19f6c597c****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2022-01-07T10:07:57.000+0000
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the gateway was last updated.
   * 
   * @example
   * 2022-01-07T10:07:57.000+0000
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the primary key.
   * 
   * @example
   * 12
   */
  id?: number;
  /**
   * @remarks
   * The name of the gateway.
   * 
   * @example
   * mse-bc1a29b0-reg-center-0-1
   */
  name?: string;
  /**
   * @remarks
   * The information about the user.
   * 
   * @example
   * 1231254
   */
  primaryUser?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The number of gateway replicas.
   * 
   * @example
   * 2
   */
  replica?: number;
  /**
   * @remarks
   * The ID of the security group.
   * 
   * @example
   * sg-bp11ufzqn6mmb8dtzz82
   */
  securityGroup?: string;
  /**
   * @remarks
   * The specifications of the gateway.
   * 
   * @example
   * MSE_GTW_16_32_200_c
   */
  spec?: string;
  /**
   * @remarks
   * The status of the gateway. Valid values: 0: The gateway is being created. 1: The gateway fails to be created. 2: The gateway is running. 3: The gateway is changing. 4: The gateway is scaling down. 6: The gateway is scaling up. 8: The gateway is being deleted. 10: The gateway is restarting. 11: The gateway is being rebuilt. 12: The gateway is updating. 13: The gateway fails to be updated.
   * 
   * @example
   * 1
   */
  status?: number;
  /**
   * @remarks
   * The ID of the virtual private cloud (VPC) where the gateway resides.
   * 
   * @example
   * vpc-bp1328cm01m6uel42b5zb
   */
  vpc?: string;
  /**
   * @remarks
   * The ID of the vSwitch.
   * 
   * @example
   * vsw-bp18zeqxx6mpuq843z4n5
   */
  vswitch?: string;
  static names(): { [key: string]: string } {
    return {
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      name: 'Name',
      primaryUser: 'PrimaryUser',
      region: 'Region',
      replica: 'Replica',
      securityGroup: 'SecurityGroup',
      spec: 'Spec',
      status: 'Status',
      vpc: 'Vpc',
      vswitch: 'Vswitch',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      name: 'string',
      primaryUser: 'string',
      region: 'string',
      replica: 'number',
      securityGroup: 'string',
      spec: 'string',
      status: 'number',
      vpc: 'string',
      vswitch: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayDomainResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the certificate.
   * 
   * @example
   * 243
   */
  certIdentifier?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 253
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-7ea3da97b96543e19f6c597c****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The time when the domain name was added.
   * 
   * @example
   * 2022-01-07T10:07:57.000+0000
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The last modification time.
   * 
   * @example
   * 2022-01-07T10:07:57.000+0000
   */
  gmtModified?: string;
  /**
   * @remarks
   * The domain ID.
   * 
   * @example
   * 2
   */
  id?: number;
  /**
   * @remarks
   * Indicates whether HTTP probing is allowed.
   * 
   * @example
   * true
   */
  mustHttps?: boolean;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * CONTACTINFO
   */
  name?: string;
  /**
   * @remarks
   * The protocol.
   * 
   * @example
   * HTTP
   */
  protocol?: string;
  static names(): { [key: string]: string } {
    return {
      certIdentifier: 'CertIdentifier',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      mustHttps: 'MustHttps',
      name: 'Name',
      protocol: 'Protocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certIdentifier: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      mustHttps: 'boolean',
      name: 'string',
      protocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayRouteResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The default service ID.
   * 
   * @example
   * 1
   */
  defaultServiceId?: number;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 125
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-5017305290e14cebbrvec4a5****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2022-01-07 18:07:57
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The modification time.
   * 
   * @example
   * 2021-12-30T06:41:52.000+0000
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID.
   * 
   * @example
   * 12
   */
  id?: number;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The matching rules.
   * 
   * @example
   * {\\"PathPredicates\\":{\\"Path\\":\\"/metas\\",\\"Type\\":\\"PRE\\",\\"IgnoreCase\\":false}}
   */
  predicates?: string;
  /**
   * @remarks
   * The sequence number of the route.
   * 
   * @example
   * 1
   */
  routeOrder?: number;
  /**
   * @remarks
   * The status of the route. Valid values:
   * 
   * *   0: unpublished
   * *   2: publishing
   * *   3: published
   * *   4: editing (updated but not published)
   * *   5: unpublishing
   * *   6: unavailable
   * 
   * @example
   * 2
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      defaultServiceId: 'DefaultServiceId',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      name: 'Name',
      predicates: 'Predicates',
      routeOrder: 'RouteOrder',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultServiceId: 'number',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      name: 'string',
      predicates: 'string',
      routeOrder: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGatewayServiceResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 1
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-7ea3da97b96543e19f6c597c****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The time when the service was created.
   * 
   * @example
   * 2022-01-14 14:39:16
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The last modification time.
   * 
   * @example
   * 2022-01-07T10:07:57.000+0000
   */
  gmtModified?: string;
  /**
   * @remarks
   * The name of the group.
   * 
   * @example
   * DEFAULT_GROUP
   */
  groupName?: string;
  /**
   * @remarks
   * The ID of the service.
   * 
   * @example
   * 190
   */
  id?: number;
  /**
   * @remarks
   * IP
   */
  ips?: string[];
  /**
   * @remarks
   * The basic information about the service.
   * 
   * @example
   * {}
   */
  metaInfo?: string;
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The name of the service registered with the service registry.
   * 
   * @example
   * test
   */
  serviceNameInRegistry?: string;
  /**
   * @remarks
   * The ID of the service source.
   * 
   * @example
   * 1
   */
  sourceId?: number;
  /**
   * @remarks
   * The source type of the service.
   * 
   * @example
   * MSE
   */
  sourceType?: string;
  static names(): { [key: string]: string } {
    return {
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      groupName: 'GroupName',
      id: 'Id',
      ips: 'Ips',
      metaInfo: 'MetaInfo',
      name: 'Name',
      namespace: 'Namespace',
      serviceNameInRegistry: 'ServiceNameInRegistry',
      sourceId: 'SourceId',
      sourceType: 'SourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      groupName: 'string',
      id: 'number',
      ips: { 'type': 'array', 'itemType': 'string' },
      metaInfo: 'string',
      name: 'string',
      namespace: 'string',
      serviceNameInRegistry: 'string',
      sourceId: 'number',
      sourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSecurityGroupRuleResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The description.
   * 
   * @example
   * auto-description1
   */
  description?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 103
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-7ea3da97b96543e19f6c597c****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2022-01-07 18:07:57
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The modification time.
   * 
   * @example
   * 2022-01-11T14:12:55.000+0000
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID.
   * 
   * @example
   * 2
   */
  id?: number;
  /**
   * @remarks
   * The transport layer protocol. The value of this parameter is case-insensitive. Valid values:
   * 
   * *   icmp
   * *   gre
   * *   tcp
   * *   udp
   * *   all: All protocols are supported.
   * 
   * @example
   * tcp
   */
  ipProtocol?: string;
  /**
   * @remarks
   * The range of ports for the transport layer protocol in the destination security group. Valid values:
   * 
   * *   When the IpProtocol parameter is set to tcp or udp, the port number range is 1 to 65535. The start port number and the end port number are separated by a forward slash (/). Example: 1/200.
   * *   If the IpProtocol parameter is set to icmp, the port number range is -1/-1, which indicates all ports.
   * *   If the IpProtocol parameter is set to gre, the port number range is -1/-1, which indicates all ports.
   * *   If the IpProtocol parameter is set to all, the port number range is -1/-1, which indicates all ports.
   * 
   * @example
   * 8443/8443
   */
  portRange?: string;
  /**
   * @remarks
   * The ID of the security group.
   * 
   * @example
   * sg-uf6hgwe067prhg68agfa
   */
  securityGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      ipProtocol: 'IpProtocol',
      portRange: 'PortRange',
      securityGroupId: 'SecurityGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      ipProtocol: 'string',
      portRange: 'string',
      securityGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteZnodeResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The data of the node.
   * 
   * @example
   * cluster
   */
  data?: string;
  /**
   * @remarks
   * Indicates whether the node information was returned. Valid values:
   * 
   * *   `true`: The node information was returned.
   * *   `false`: The node information failed to be returned.
   * 
   * @example
   * true
   */
  dir?: boolean;
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * mse-bc1a29b0-160230875****-reg-center-0-1
   */
  name?: string;
  /**
   * @remarks
   * The path of the node.
   * 
   * @example
   * /
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      dir: 'Dir',
      name: 'Name',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      dir: 'boolean',
      name: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportNacosConfigResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The URL that is used to download the exported configurations.
   * 
   * @example
   * http://xxxxxxxxx
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportZookeeperDataResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The content of a task.
   */
  contentMap?: { [key: string]: any };
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 1631001140913
   */
  createTime?: number;
  /**
   * @remarks
   * The type of the object that is exported. Valid values:
   * 
   * *   transactionLog: transaction logs
   * *   snapshot: snapshots
   * 
   * @example
   * snapshot
   */
  exportType?: string;
  /**
   * @remarks
   * The extended information.
   * 
   * @example
   * {}
   */
  extend?: string;
  /**
   * @remarks
   * The ID of the task.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The ID of the instance
   * 
   * @example
   * mse-cn-st21ri2****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the associated task at the underlying layer. This parameter is used only to troubleshoot failures.
   * 
   * @example
   * 10
   */
  kubeoneTaskIds?: string;
  /**
   * @remarks
   * The status of the task. Valid values:
   * 
   * *   CREATE: The object is being created.
   * *   RUNNING: The task is running.
   * *   FINISH: The task is completed.
   * *   FAILED: The task fails.
   * *   EXPIRE: The task has expired.
   * 
   * @example
   * FINISH
   */
  status?: string;
  /**
   * @remarks
   * The last update time.
   * 
   * @example
   * 1632979237663
   */
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      contentMap: 'ContentMap',
      createTime: 'CreateTime',
      exportType: 'ExportType',
      extend: 'Extend',
      id: 'Id',
      instanceId: 'InstanceId',
      kubeoneTaskIds: 'KubeoneTaskIds',
      status: 'Status',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      createTime: 'number',
      exportType: 'string',
      extend: 'string',
      id: 'number',
      instanceId: 'string',
      kubeoneTaskIds: 'string',
      status: 'string',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FetchLosslessRuleListResponseBodyDataResults extends $tea.Model {
  /**
   * @remarks
   * Indicates whether service registration is complete before readiness probe.
   * 
   * @example
   * true
   */
  aligned?: boolean;
  /**
   * @remarks
   * The ID of the application.
   * 
   * @example
   * hkhon1po62@24810bf4364aea1
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * echo-demo
   */
  appName?: string;
  /**
   * @remarks
   * The number of instances.
   * 
   * @example
   * 3
   */
  count?: number;
  /**
   * @remarks
   * The registration latency. Unit: seconds.
   * 
   * @example
   * 60
   */
  delayTime?: number;
  /**
   * @remarks
   * Indicates whether graceful start is enabled. Valid values:
   * 
   * *   `true`: enabled
   * *   `false`: disabled
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The slope of the prefetching curve.
   * 
   * @example
   * 2
   */
  funcType?: number;
  /**
   * @remarks
   * Indicates whether online and offline processing details are displayed.
   * 
   * @example
   * false
   */
  lossLessDetail?: boolean;
  /**
   * @remarks
   * Indicates whether notification is enabled.
   * 
   * @example
   * true
   */
  notice?: boolean;
  /**
   * @remarks
   * Indicates whether service prefetching is complete before readiness probe.
   * 
   * @example
   * false
   */
  related?: boolean;
  /**
   * @remarks
   * The prefetching duration. Unit: seconds.
   * 
   * @example
   * 60
   */
  warmupTime?: number;
  static names(): { [key: string]: string } {
    return {
      aligned: 'Aligned',
      appId: 'AppId',
      appName: 'AppName',
      count: 'Count',
      delayTime: 'DelayTime',
      enable: 'Enable',
      funcType: 'FuncType',
      lossLessDetail: 'LossLessDetail',
      notice: 'Notice',
      related: 'Related',
      warmupTime: 'WarmupTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aligned: 'boolean',
      appId: 'string',
      appName: 'string',
      count: 'number',
      delayTime: 'number',
      enable: 'boolean',
      funcType: 'number',
      lossLessDetail: 'boolean',
      notice: 'boolean',
      related: 'boolean',
      warmupTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FetchLosslessRuleListResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The returned data.
   */
  results?: FetchLosslessRuleListResponseBodyDataResults[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 36
   */
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      results: 'Results',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      results: { 'type': 'array', 'itemType': FetchLosslessRuleListResponseBodyDataResults },
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GatewayBlackWhiteListRequestFilterParams extends $tea.Model {
  /**
   * @remarks
   * The gateway ID.
   * 
   * @example
   * 81
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway. If this parameter is used together with the GatewayId parameter, the value of the GatewayId parameter is used.
   * 
   * @example
   * gw-5017305290e14centbrveca****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * This parameter is unavailable for public use.
   * 
   * @example
   * ""
   */
  isWhite?: boolean;
  /**
   * @remarks
   * This parameter is unavailable for public use.
   * 
   * @example
   * ""
   */
  resourceType?: string;
  /**
   * @remarks
   * The content that you want to query.
   * 
   * @example
   * 1.1.1.1
   */
  searchContent?: string;
  /**
   * @remarks
   * The query type. Valid values:
   * 
   * *   ROUTE: The list is queried by route. If the value of this parameter is ROUTE, set the SearchContent parameter to the route name.
   * *   DOMAIN: The list is queried by domain name. If the value of this parameter is DOMAIN, set the SearchContent parameter to the domain name.
   * *   IP: The list is queried by specified IP address. If the value of this parameter is IP, set the SearchContent parameter to the IP address.
   * 
   * @example
   * IP
   */
  searchType?: string;
  /**
   * @remarks
   * This parameter is unavailable for public use.
   * 
   * @example
   * ""
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      isWhite: 'IsWhite',
      resourceType: 'ResourceType',
      searchContent: 'SearchContent',
      searchType: 'SearchType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      isWhite: 'boolean',
      resourceType: 'string',
      searchContent: 'string',
      searchType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GatewayBlackWhiteListResponseBodyDataResult extends $tea.Model {
  /**
   * @remarks
   * The content of the blacklist.
   * 
   * @example
   * 1.1.1.1
   */
  content?: string;
  /**
   * @remarks
   * The gateway ID.
   * 
   * @example
   * 81
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-5017305290e14centbrveca****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The time when the blacklist or whitelist was created.
   * 
   * @example
   * 2024-08-02T02:43:40.000+0000
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the rule was modified.
   * 
   * @example
   * 2024-08-02T02:43:40.000+0000
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the blacklist and whitelist.
   * 
   * @example
   * 549
   */
  id?: number;
  /**
   * @remarks
   * Specifies whether to enable the whitelist feature.
   * 
   * @example
   * true
   */
  isWhite?: boolean;
  /**
   * @remarks
   * The name of the blacklist.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The comment.
   */
  note?: string;
  /**
   * @remarks
   * The resource ID.
   * 
   * @example
   * 549
   */
  resourceId?: number;
  /**
   * @remarks
   * The list of resource IDs in the JSON format.
   * 
   * *   If the value of the ResourceType parameter is ROUTE, the value of this parameter is the list of route IDs.
   * *   If the value of the ResourceType parameter is DOMAIN, the value of this parameter is the list of domain names.
   * 
   * @example
   * [234]
   */
  resourceIdJsonList?: string;
  /**
   * @remarks
   * The description of the resource name.
   * 
   * @example
   * {}
   */
  resourceIdNameJson?: string;
  /**
   * @remarks
   * The effective scope of the blacklist or whitelist. Valid values:
   * 
   * *   GATEWAY
   * *   DOMAIN
   * *   ROUTE
   * 
   * @example
   * GATEWAY
   */
  resourceType?: string;
  /**
   * @remarks
   * The status of the blacklist or whitelist.
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  status?: string;
  /**
   * @remarks
   * The type of the blacklist and whitelist. The value is fixed to IP address blacklist and whitelist.
   * 
   * @example
   * IP
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      isWhite: 'IsWhite',
      name: 'Name',
      note: 'Note',
      resourceId: 'ResourceId',
      resourceIdJsonList: 'ResourceIdJsonList',
      resourceIdNameJson: 'ResourceIdNameJson',
      resourceType: 'ResourceType',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      isWhite: 'boolean',
      name: 'string',
      note: 'string',
      resourceId: 'number',
      resourceIdJsonList: 'string',
      resourceIdNameJson: 'string',
      resourceType: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GatewayBlackWhiteListResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 1
   */
  pageSize?: number;
  /**
   * @remarks
   * The returned information.
   */
  result?: GatewayBlackWhiteListResponseBodyDataResult[];
  /**
   * @remarks
   * The total number of instances returned.
   * 
   * @example
   * 1
   */
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      result: 'Result',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      result: { 'type': 'array', 'itemType': GatewayBlackWhiteListResponseBodyDataResult },
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppMessageQueueRouteResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the application.
   * 
   * @example
   * hkhon1po62@54e1f42f37cd65a
   */
  appId?: string;
  /**
   * @remarks
   * Indicates whether the canary release for messaging feature is enabled.
   * 
   * *   `true`: enabled
   * *   `false`: disabled
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The side for message filtering when the canary release for messaging feature is enabled.
   * 
   * @example
   * Server
   */
  filterSide?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The tags used to ignore message consumption for nodes in untagged environments.
   */
  tags?: string[];
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      enable: 'Enable',
      filterSide: 'FilterSide',
      region: 'Region',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      enable: 'boolean',
      filterSide: 'string',
      region: 'string',
      tags: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationInstanceListResponseBodyDataResultTags extends $tea.Model {
  /**
   * @remarks
   * 标签值。
   * 
   * @example
   * gray
   */
  tag?: string;
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationInstanceListResponseBodyDataResult extends $tea.Model {
  /**
   * @remarks
   * The node IP address.
   * 
   * @example
   * 10.1.2.3
   */
  ip?: string;
  /**
   * @remarks
   * The application port.
   * 
   * @example
   * 8080
   */
  port?: string;
  /**
   * @remarks
   * The node tags.
   */
  tags?: GetApplicationInstanceListResponseBodyDataResultTags[];
  static names(): { [key: string]: string } {
    return {
      ip: 'Ip',
      port: 'Port',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ip: 'string',
      port: 'string',
      tags: { 'type': 'array', 'itemType': GetApplicationInstanceListResponseBodyDataResultTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationInstanceListResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number. Pages start from page 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The queried nodes.
   */
  result?: GetApplicationInstanceListResponseBodyDataResult[];
  /**
   * @remarks
   * The total number of nodes.
   * 
   * @example
   * 100
   */
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      result: 'Result',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      result: { 'type': 'array', 'itemType': GetApplicationInstanceListResponseBodyDataResult },
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationListResponseBodyDataResult extends $tea.Model {
  /**
   * @remarks
   * The ID of the application.
   * 
   * @example
   * hkhon1po62@5f1b08becb*****
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * finance
   */
  appName?: string;
  /**
   * @remarks
   * The additional information.
   * 
   * @example
   * {}
   */
  extraInfo?: string;
  /**
   * @remarks
   * The number of instances.
   * 
   * @example
   * 1
   */
  instancesNumber?: number;
  /**
   * @remarks
   * The programming language of the application.
   * 
   * @example
   * JAVA
   */
  language?: string;
  /**
   * @remarks
   * The microservice namespace to which the application belongs.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The source of the application.
   * 
   * @example
   * edasmsc
   */
  source?: string;
  /**
   * @remarks
   * The status.
   * 
   * @example
   * 0
   */
  status?: number;
  /**
   * @remarks
   * The user ID.
   * 
   * @example
   * 1234567890
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      extraInfo: 'ExtraInfo',
      instancesNumber: 'InstancesNumber',
      language: 'Language',
      namespace: 'Namespace',
      regionId: 'RegionId',
      source: 'Source',
      status: 'Status',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appName: 'string',
      extraInfo: 'string',
      instancesNumber: 'number',
      language: 'string',
      namespace: 'string',
      regionId: 'string',
      source: 'string',
      status: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationListResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The data returned.
   */
  result?: GetApplicationListResponseBodyDataResult[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 11
   */
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      result: 'Result',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      result: { 'type': 'array', 'itemType': GetApplicationListResponseBodyDataResult },
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBlackWhiteListResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The content of the blacklist.
   * 
   * @example
   * text
   */
  content?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 1
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-7ea3da97b96543e19f6c597c****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2022-01-07T10:07:57.000+0000
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The modification time.
   * 
   * @example
   * 2022-01-07T10:07:57.000+0000
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID.
   * 
   * @example
   * 275
   */
  id?: number;
  /**
   * @remarks
   * Indicates whether the whitelist is enabled.
   * 
   * @example
   * true
   */
  isWhite?: boolean;
  /**
   * @remarks
   * The ID of the resource.
   * 
   * @example
   * 1
   */
  resourceId?: number;
  /**
   * @remarks
   * The type of a resource.
   * 
   * @example
   * GATEWAY
   */
  resourceType?: string;
  /**
   * @remarks
   * The status of the blacklist or whitelist.
   * 
   * @example
   * on
   */
  status?: string;
  /**
   * @remarks
   * The type.
   * 
   * @example
   * IP
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      isWhite: 'IsWhite',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      isWhite: 'boolean',
      resourceId: 'number',
      resourceType: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayResponseBodyDataElasticPolicyTimePolicyList extends $tea.Model {
  /**
   * @remarks
   * The number of expected replicas.
   * 
   * @example
   * 2
   */
  desiredReplica?: number;
  /**
   * @remarks
   * The end time of auto scale-out.
   * 
   * @example
   * 18:00
   */
  endTime?: string;
  /**
   * @remarks
   * The start time of auto scale-out.
   * 
   * @example
   * 16:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      desiredReplica: 'DesiredReplica',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desiredReplica: 'number',
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayResponseBodyDataElasticPolicy extends $tea.Model {
  /**
   * @remarks
   * The type of auto scale-out. Valid value:
   * 
   * *   CronHPA: scale-out by time
   * 
   * @example
   * CronHPA
   */
  elasticType?: string;
  /**
   * @remarks
   * The maximum number of instances that are automatically scaled out. This parameter is used for horizontal scale-out.
   * 
   * @example
   * 5
   */
  maxReplica?: number;
  /**
   * @remarks
   * The policy of scale-out by time.
   */
  timePolicyList?: GetGatewayResponseBodyDataElasticPolicyTimePolicyList[];
  static names(): { [key: string]: string } {
    return {
      elasticType: 'ElasticType',
      maxReplica: 'MaxReplica',
      timePolicyList: 'TimePolicyList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      elasticType: 'string',
      maxReplica: 'number',
      timePolicyList: { 'type': 'array', 'itemType': GetGatewayResponseBodyDataElasticPolicyTimePolicyList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayResponseBodyDataLogConfigDetails extends $tea.Model {
  /**
   * @remarks
   * Indicates whether Log Service is activated.
   * 
   * @example
   * true
   */
  logEnabled?: boolean;
  /**
   * @remarks
   * The name of the Logstore.
   * 
   * @example
   * mse_access_log
   */
  logStoreName?: string;
  /**
   * @remarks
   * The name of the project.
   * 
   * @example
   * k8s-log-c173117256e934a96b7fefdf2ef8a8057
   */
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      logEnabled: 'LogEnabled',
      logStoreName: 'LogStoreName',
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logEnabled: 'boolean',
      logStoreName: 'string',
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayResponseBodyDataXtraceDetails extends $tea.Model {
  /**
   * @remarks
   * The sampling rate of Tracing Analysis.
   * 
   * @example
   * 10
   */
  sample?: number;
  /**
   * @remarks
   * Indicates whether sampling by using Tracing Analysis is enabled.
   * 
   * @example
   * true
   */
  traceOn?: boolean;
  static names(): { [key: string]: string } {
    return {
      sample: 'Sample',
      traceOn: 'TraceOn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sample: 'number',
      traceOn: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The billing method, such as subscription or pay-as-you-go.
   * 
   * @example
   * POSTPAY
   */
  chargeType?: string;
  /**
   * @remarks
   * Indicates whether auto scale-out is enabled.
   * 
   * @example
   * true
   */
  elastic?: boolean;
  /**
   * @remarks
   * The auto scale-out policy.
   */
  elasticPolicy?: GetGatewayResponseBodyDataElasticPolicy;
  /**
   * @remarks
   * The number of replicas that are automatically scaled out.
   * 
   * @example
   * 1
   */
  elasticReplica?: number;
  /**
   * @remarks
   * The type of auto scale-out. Valid value:
   * 
   * *   CronHPA: scale-out by time
   * 
   * @example
   * CronHPA
   */
  elasticType?: string;
  /**
   * @remarks
   * The time when the gateway expires.
   * 
   * @example
   * 2021-08-01 00:00:00
   */
  endDate?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-7ea3da97b96543e19f6c597cd4a9****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The time when the gateway was created. The time is displayed in GMT. The time is the local time of the region in which the gateway resides.
   * 
   * @example
   * 2022-01-07T10:07:57.000+0000
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the gateway was last modified.
   * 
   * @example
   * 2022-01-07T10:07:57.000+0000
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 12
   */
  id?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-cn-st21ri2****
   */
  instanceId?: string;
  /**
   * @remarks
   * The log configuration.
   */
  logConfigDetails?: GetGatewayResponseBodyDataLogConfigDetails;
  /**
   * @remarks
   * The tag of the resource.
   * 
   * @example
   * {"TagKey":"TagValue"}
   */
  mseTag?: string;
  /**
   * @remarks
   * The name of the gateway.
   * 
   * @example
   * DEFAULT
   */
  name?: string;
  /**
   * @remarks
   * The Alibaba Cloud account ID of the user who created the gateway.
   * 
   * @example
   * 1231254
   */
  primaryUser?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The number of gateway replicas.
   * 
   * @example
   * 2
   */
  replica?: number;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfm34x43l*****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The ID of the security group.
   * 
   * @example
   * sg-bp11ufzqn6mmb8dtzz82
   */
  securityGroup?: string;
  /**
   * @remarks
   * The specifications of the gateway.
   * 
   * @example
   * MSE_GTW_16_32_200_c
   */
  spec?: string;
  /**
   * @remarks
   * The status of the gateway. Valid values:
   * 
   * *   0: The gateway is being created.
   * *   1: The gateway fails to be created.
   * *   2: The gateway is running.
   * *   3: The gateway is changing.
   * *   4: The gateway is scaling in.
   * *   6: The gateway is scaling out.
   * *   8: The gateway is being deleted.
   * *   10: The gateway is restarting.
   * *   11: The gateway is being rebuilt.
   * *   12: The gateway is updating.
   * *   13: The gateway fails to be updated.
   * 
   * @example
   * 0
   */
  status?: number;
  /**
   * @remarks
   * The description of the status.
   * 
   * @example
   * Restarting
   */
  statusDesc?: string;
  /**
   * @remarks
   * The total number of replicas, including the number of replicas that are automatically scaled out.
   * 
   * @example
   * 3
   */
  totalReplica?: number;
  /**
   * @remarks
   * The ID of the VPC.
   * 
   * @example
   * vpc-bp1328cm01m6uel42b5zb
   */
  vpc?: string;
  /**
   * @remarks
   * The ID of the vSwitch.
   * 
   * @example
   * vsw-bp18zeqxx6mpuq843z4n5
   */
  vswitch?: string;
  /**
   * @remarks
   * The ID of the secondary vSwitch.
   * 
   * @example
   * vpc-bp1j6ivhav15ve7q54kq2
   */
  vswitch2?: string;
  /**
   * @remarks
   * The details of Tracing Analysis.
   */
  xtraceDetails?: GetGatewayResponseBodyDataXtraceDetails;
  static names(): { [key: string]: string } {
    return {
      chargeType: 'ChargeType',
      elastic: 'Elastic',
      elasticPolicy: 'ElasticPolicy',
      elasticReplica: 'ElasticReplica',
      elasticType: 'ElasticType',
      endDate: 'EndDate',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      instanceId: 'InstanceId',
      logConfigDetails: 'LogConfigDetails',
      mseTag: 'MseTag',
      name: 'Name',
      primaryUser: 'PrimaryUser',
      region: 'Region',
      replica: 'Replica',
      resourceGroupId: 'ResourceGroupId',
      securityGroup: 'SecurityGroup',
      spec: 'Spec',
      status: 'Status',
      statusDesc: 'StatusDesc',
      totalReplica: 'TotalReplica',
      vpc: 'Vpc',
      vswitch: 'Vswitch',
      vswitch2: 'Vswitch2',
      xtraceDetails: 'XtraceDetails',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chargeType: 'string',
      elastic: 'boolean',
      elasticPolicy: GetGatewayResponseBodyDataElasticPolicy,
      elasticReplica: 'number',
      elasticType: 'string',
      endDate: 'string',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      instanceId: 'string',
      logConfigDetails: GetGatewayResponseBodyDataLogConfigDetails,
      mseTag: 'string',
      name: 'string',
      primaryUser: 'string',
      region: 'string',
      replica: 'number',
      resourceGroupId: 'string',
      securityGroup: 'string',
      spec: 'string',
      status: 'number',
      statusDesc: 'string',
      totalReplica: 'number',
      vpc: 'string',
      vswitch: 'string',
      vswitch2: 'string',
      xtraceDetails: GetGatewayResponseBodyDataXtraceDetails,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayAuthConsumerDetailResponseBodyDataResourceList extends $tea.Model {
  /**
   * @remarks
   * The consumer ID.
   * 
   * @example
   * 123
   */
  consumerId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-4822033a8513496fa10f05c934f*****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The time when the resource associated with the consumer authentication record was created.
   * 
   * @example
   * 2022-12-06 01:38:03
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the resource associated with the consumer authentication record was modified.
   * 
   * @example
   * 2022-12-06 01:38:03
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the authorized resource for the consumer.
   * 
   * @example
   * 16
   */
  id?: number;
  /**
   * @remarks
   * The resource authorization state. Valid values:
   * 
   * *   true: Resource authorization is enabled.
   * *   false: Resource authorization is disabled.
   * 
   * @example
   * true
   */
  resourceStatus?: boolean;
  /**
   * @remarks
   * The ID of the route.
   * 
   * @example
   * 3458
   */
  routeId?: number;
  /**
   * @remarks
   * The name of the route.
   * 
   * @example
   * test
   */
  routeName?: string;
  static names(): { [key: string]: string } {
    return {
      consumerId: 'ConsumerId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      resourceStatus: 'ResourceStatus',
      routeId: 'RouteId',
      routeName: 'RouteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerId: 'number',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      resourceStatus: 'boolean',
      routeId: 'number',
      routeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayAuthConsumerDetailResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The status of the consumer. Valid values:
   * 
   * *   true: enabled
   * *   false: disabled
   * 
   * @example
   * true
   */
  consumerStatus?: boolean;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * Description
   */
  description?: string;
  /**
   * @remarks
   * The encryption type. Valid values:
   * 
   * *   RSA
   * *   OCT
   * 
   * @example
   * RSA
   */
  encodeType?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-7ea3da97b96543e19f6c597cd4a9****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The time when the consumer authentication record was created.
   * 
   * @example
   * 2031-03-30 02:35:12
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the consumer authentication record was modified.
   * 
   * @example
   * 2023-02-01 14:17:57
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the consumer.
   * 
   * @example
   * 12
   */
  id?: number;
  /**
   * @remarks
   * The JWT public key. The JSON format is supported.
   * 
   * @example
   * {
   *       "keys": [
   *             {
   *                   "e": "AQAB",
   *                   "kid": "DHFbpoIUqrY8t2zpA2qXfCmr5VO5ZEr4RzHU_-envvQ",
   *                   "kty": "RSA",
   *                   "n": "xAE7eB6qugXyCAG3yhh7pkDkT65pHymX-P7KfIupjf59vsdo91bSP9C8H07pSAGQO1MV_xFj9VswgsCg4R6otmg5PV2He95lZdHtOcU5DXIg_pbhLdKXbi66GlVeK6ABZOUW3WYtnNHD-91gVuoeJT_DwtGGcp4ignkgXfkiEm4sw-4sfb4qdt5oLbyVpmW6x9cfa7vs2WTfURiCrBoUqgBo_-4WTiULmmHSGZHOjzwa8WtrtOQGsAFjIbno85jp6MnGGGZPYZbDAa_b3y5u-YpW7ypZrvD8BgtKVjgtQgZhLAGezMt0ua3DRrWnKqTZ0BJ_EyxOGuHJrLsn00fnMQ"
   *             }
   *       ]
   * }
   */
  jwks?: string;
  /**
   * @remarks
   * The name of the key used for JWT-based identity authentication.
   * 
   * @example
   * iss
   */
  keyName?: string;
  /**
   * @remarks
   * The value of the key used for JWT-based identity authentication.
   * 
   * @example
   * abcd
   */
  keyValue?: string;
  /**
   * @remarks
   * The name of the consumer.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The creator.
   * 
   * @example
   * 123
   */
  primaryUser?: string;
  /**
   * @remarks
   * The resource list.
   */
  resourceList?: GetGatewayAuthConsumerDetailResponseBodyDataResourceList[];
  /**
   * @remarks
   * The names of the parameters that are required to verify each token. By default, each token is prefixed with Bearer and stored in the Authorization header, such as `Authorization: Bearer <Content of a token>`.
   * 
   * @example
   * Authorization
   */
  tokenName?: string;
  /**
   * @remarks
   * Specifies whether to enable pass-through.
   * 
   * @example
   * true
   */
  tokenPass?: boolean;
  /**
   * @remarks
   * The positions of the parameters that are required to verify each token. By default, each token is prefixed with Bearer and stored in the Authorization header, such as `Authorization: Bearer <Content of a token>`.
   * 
   * @example
   * HEADER
   */
  tokenPosition?: string;
  /**
   * @remarks
   * The prefixes of the parameters that are required to verify each token. By default, each token is prefixed with Bearer and stored in the Authorization header, such as `Authorization: Bearer <Content of a token>`.
   * 
   * @example
   * Bearer
   */
  tokenPrefix?: string;
  /**
   * @remarks
   * The authentication type. Valid values:
   * 
   * *   JWT
   * 
   * @example
   * JWT
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      consumerStatus: 'ConsumerStatus',
      description: 'Description',
      encodeType: 'EncodeType',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      jwks: 'Jwks',
      keyName: 'KeyName',
      keyValue: 'KeyValue',
      name: 'Name',
      primaryUser: 'PrimaryUser',
      resourceList: 'ResourceList',
      tokenName: 'TokenName',
      tokenPass: 'TokenPass',
      tokenPosition: 'TokenPosition',
      tokenPrefix: 'TokenPrefix',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerStatus: 'boolean',
      description: 'string',
      encodeType: 'string',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      jwks: 'string',
      keyName: 'string',
      keyValue: 'string',
      name: 'string',
      primaryUser: 'string',
      resourceList: { 'type': 'array', 'itemType': GetGatewayAuthConsumerDetailResponseBodyDataResourceList },
      tokenName: 'string',
      tokenPass: 'boolean',
      tokenPosition: 'string',
      tokenPrefix: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayAuthDetailResponseBodyDataExternalAuthZService extends $tea.Model {
  /**
   * @example
   * test
   */
  groupName?: string;
  /**
   * @example
   * httpbin-auth-service
   */
  name?: string;
  /**
   * @example
   * default
   */
  namespace?: string;
  /**
   * @example
   * K8S
   */
  sourceType?: string;
  static names(): { [key: string]: string } {
    return {
      groupName: 'GroupName',
      name: 'Name',
      namespace: 'Namespace',
      sourceType: 'SourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupName: 'string',
      name: 'string',
      namespace: 'string',
      sourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayAuthDetailResponseBodyDataExternalAuthZ extends $tea.Model {
  allowRequestHeaders?: string[];
  allowUpstreamHeaders?: string[];
  /**
   * @example
   * 4000000
   */
  bodyMaxBytes?: number;
  /**
   * @example
   * true
   */
  isRestrict?: boolean;
  /**
   * @example
   * /auth
   */
  prefixPath?: string;
  service?: GetGatewayAuthDetailResponseBodyDataExternalAuthZService;
  /**
   * @example
   * 15300
   */
  serviceId?: number;
  /**
   * @example
   * 10
   */
  timeout?: number;
  /**
   * @example
   * Authorization
   */
  tokenKey?: string;
  /**
   * @example
   * true
   */
  withRequestBody?: boolean;
  static names(): { [key: string]: string } {
    return {
      allowRequestHeaders: 'AllowRequestHeaders',
      allowUpstreamHeaders: 'AllowUpstreamHeaders',
      bodyMaxBytes: 'BodyMaxBytes',
      isRestrict: 'IsRestrict',
      prefixPath: 'PrefixPath',
      service: 'Service',
      serviceId: 'ServiceId',
      timeout: 'Timeout',
      tokenKey: 'TokenKey',
      withRequestBody: 'WithRequestBody',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowRequestHeaders: { 'type': 'array', 'itemType': 'string' },
      allowUpstreamHeaders: { 'type': 'array', 'itemType': 'string' },
      bodyMaxBytes: 'number',
      isRestrict: 'boolean',
      prefixPath: 'string',
      service: GetGatewayAuthDetailResponseBodyDataExternalAuthZService,
      serviceId: 'number',
      timeout: 'number',
      tokenKey: 'string',
      withRequestBody: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayAuthDetailResponseBodyDataResourceListAuthResourceHeaderList extends $tea.Model {
  /**
   * @example
   * x-req
   */
  headerKey?: string;
  /**
   * @example
   * EQUAL
   */
  headerMethod?: string;
  /**
   * @example
   * 123
   */
  headerValue?: string;
  static names(): { [key: string]: string } {
    return {
      headerKey: 'HeaderKey',
      headerMethod: 'HeaderMethod',
      headerValue: 'HeaderValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headerKey: 'string',
      headerMethod: 'string',
      headerValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayAuthDetailResponseBodyDataResourceList extends $tea.Model {
  /**
   * @example
   * 2274
   */
  authId?: number;
  authResourceHeaderList?: GetGatewayAuthDetailResponseBodyDataResourceListAuthResourceHeaderList[];
  /**
   * @example
   * 1765
   */
  domainId?: number;
  /**
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @example
   * 2274
   */
  gatewayId?: number;
  /**
   * @example
   * gw-6f0dbd108a0249d2b675b3ef50b*****
   */
  gatewayUniqueId?: string;
  /**
   * @example
   * 2024-02-19T03:32:38.000+0000
   */
  gmtCreate?: string;
  /**
   * @example
   * 2024-02-19T03:32:38.000+0000
   */
  gmtModified?: string;
  /**
   * @example
   * 1303
   */
  id?: number;
  /**
   * @example
   * true
   */
  ignoreCase?: boolean;
  /**
   * @example
   * true
   */
  isWhite?: boolean;
  /**
   * @example
   * EQUAL
   */
  matchType?: string;
  /**
   * @example
   * /test
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      authId: 'AuthId',
      authResourceHeaderList: 'AuthResourceHeaderList',
      domainId: 'DomainId',
      domainName: 'DomainName',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      ignoreCase: 'IgnoreCase',
      isWhite: 'IsWhite',
      matchType: 'MatchType',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authId: 'number',
      authResourceHeaderList: { 'type': 'array', 'itemType': GetGatewayAuthDetailResponseBodyDataResourceListAuthResourceHeaderList },
      domainId: 'number',
      domainName: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      ignoreCase: 'boolean',
      isWhite: 'boolean',
      matchType: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayAuthDetailResponseBodyData extends $tea.Model {
  authResourceConfig?: string;
  /**
   * @example
   * 0
   */
  authResourceMode?: number;
  /**
   * @example
   * example-app
   */
  clientId?: string;
  /**
   * @example
   * xxxxx
   */
  clientSecret?: string;
  /**
   * @example
   * hello.com
   */
  cookieDomain?: string;
  externalAuthZ?: GetGatewayAuthDetailResponseBodyDataExternalAuthZ;
  /**
   * @example
   * 2274
   */
  gatewayId?: number;
  /**
   * @example
   * gw-6f0dbd108a0249d2b675b3ef50b*****
   */
  gatewayUniqueId?: string;
  /**
   * @example
   * 2024-02-19T02:41:03.000+0000
   */
  gmtCreate?: string;
  /**
   * @example
   * 2024-02-19T02:41:03.000+0000
   */
  gmtModified?: string;
  /**
   * @example
   * 1100
   */
  id?: number;
  /**
   * @example
   * true
   */
  isWhite?: boolean;
  /**
   * @example
   * https://example.com/auth
   */
  issuer?: string;
  /**
   * @example
   * {\\n  \\"keys\\":[\\n    {\\n      \\"kty\\": \\"RSA\\",\\n      \\"e\\": \\"AQAB\\",\\n      \\"use\\": \\"sig\\",\\n      \\"kid\\": \\"1rGufmH1YN8rqM9ZOLgo7eEST3AnL89Y-m-XGFioLoA\\",\\n      \\"alg\\": \\"RS256\\",\\n      \\"n\\": \\"rM2GIc0YTMqwNCwXnjKbW5QndkCEZgyLu3uQUnyZF7HvMTekiTvQg_39mg3dV1eaYYkYfZBogyroJBqAQXhk6VVCxlBjFVp2xstJPVWngMOOlcafwN_BKdN-EQ06O_Uu__e7gNKI3DunkNk0cNaFETE7d4meRYyTlgEzYgsrW05_ufR0BKoddL3E5JsCpUxRjH9ICbodBx0U74W6Dcci-R2EA1DBrEcboE6n90uoJs6UJNriAK_71nAsYonihU5aQFFnyPTkJHfRwHK6JlME6rn-b-rpLSpdyc6U1nOFZP2DEpz8U5FrYoLYSZIU-MQGxDhCnGc_rxl2IyP9B2qcCQ\\"\\n    }\\n  ]\\n}\\n
   */
  jwks?: string;
  /**
   * @example
   * https://daxxxxcn.aliyunidaas.com/
   */
  loginUrl?: string;
  /**
   * @example
   * test
   */
  name?: string;
  /**
   * @example
   * https://yourdomain/path
   */
  redirectUrl?: string;
  resourceList?: GetGatewayAuthDetailResponseBodyDataResourceList[];
  /**
   * @example
   * ["openid","email"]
   */
  scopesList?: string;
  /**
   * @example
   * false
   */
  status?: boolean;
  /**
   * @example
   * https://example.com/auth
   */
  sub?: string;
  /**
   * @example
   * Authorization
   */
  tokenName?: string;
  /**
   * @example
   * Bearer
   */
  tokenNamePrefix?: string;
  /**
   * @example
   * true
   */
  tokenPass?: boolean;
  /**
   * @example
   * HEADER
   */
  tokenPosition?: string;
  /**
   * @example
   * JWT
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      authResourceConfig: 'AuthResourceConfig',
      authResourceMode: 'AuthResourceMode',
      clientId: 'ClientId',
      clientSecret: 'ClientSecret',
      cookieDomain: 'CookieDomain',
      externalAuthZ: 'ExternalAuthZ',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      isWhite: 'IsWhite',
      issuer: 'Issuer',
      jwks: 'Jwks',
      loginUrl: 'LoginUrl',
      name: 'Name',
      redirectUrl: 'RedirectUrl',
      resourceList: 'ResourceList',
      scopesList: 'ScopesList',
      status: 'Status',
      sub: 'Sub',
      tokenName: 'TokenName',
      tokenNamePrefix: 'TokenNamePrefix',
      tokenPass: 'TokenPass',
      tokenPosition: 'TokenPosition',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authResourceConfig: 'string',
      authResourceMode: 'number',
      clientId: 'string',
      clientSecret: 'string',
      cookieDomain: 'string',
      externalAuthZ: GetGatewayAuthDetailResponseBodyDataExternalAuthZ,
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      isWhite: 'boolean',
      issuer: 'string',
      jwks: 'string',
      loginUrl: 'string',
      name: 'string',
      redirectUrl: 'string',
      resourceList: { 'type': 'array', 'itemType': GetGatewayAuthDetailResponseBodyDataResourceList },
      scopesList: 'string',
      status: 'boolean',
      sub: 'string',
      tokenName: 'string',
      tokenNamePrefix: 'string',
      tokenPass: 'boolean',
      tokenPosition: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayConfigResponseBodyDataSlsConfigDetails extends $tea.Model {
  /**
   * @example
   * 500
   */
  gatewayId?: number;
  /**
   * @example
   * gw-61f465fa2dd044069e2208c4912*****
   */
  gatewayUniqueId?: string;
  /**
   * @example
   * ""
   */
  gmtCreate?: string;
  /**
   * @example
   * ""
   */
  gmtModified?: string;
  /**
   * @example
   * 0
   */
  id?: number;
  /**
   * @example
   * true
   */
  logOn?: boolean;
  /**
   * @example
   * mse_gw_access_log
   */
  logStoreName?: string;
  /**
   * @example
   * false
   */
  nginxCompatible?: boolean;
  /**
   * @example
   * test
   */
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      logOn: 'LogOn',
      logStoreName: 'LogStoreName',
      nginxCompatible: 'NginxCompatible',
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      logOn: 'boolean',
      logStoreName: 'string',
      nginxCompatible: 'boolean',
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayConfigResponseBodyDataXtraceDetails extends $tea.Model {
  /**
   * @example
   * 500
   */
  gatewayId?: number;
  /**
   * @example
   * gw-61f465fa2dd044069e2208c4912*****
   */
  gatewayUniqueId?: string;
  /**
   * @example
   * 2024-08-12T09:39:07.000+0000
   */
  gmtCreate?: string;
  /**
   * @example
   * 2024-08-12T09:39:07.000+0000
   */
  gmtModified?: string;
  /**
   * @example
   * 255
   */
  id?: number;
  /**
   * @example
   * 100
   */
  sample?: number;
  /**
   * @example
   * 333
   */
  serviceId?: number;
  /**
   * @example
   * 8888
   */
  servicePort?: string;
  /**
   * @example
   * true
   */
  traceOn?: boolean;
  /**
   * @example
   * OPENTELEMETRY
   */
  traceType?: string;
  static names(): { [key: string]: string } {
    return {
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      sample: 'Sample',
      serviceId: 'ServiceId',
      servicePort: 'ServicePort',
      traceOn: 'TraceOn',
      traceType: 'TraceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      sample: 'number',
      serviceId: 'number',
      servicePort: 'string',
      traceOn: 'boolean',
      traceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayConfigResponseBodyData extends $tea.Model {
  /**
   * @example
   * {"requestMetadata":[],"responseHeaders":[],"requestHeaders":["x-test"],"responseMetadata":[]}
   */
  accessLogHeader?: string;
  /**
   * @example
   * 32768
   */
  downstreamConnectionBufferLimits?: number;
  /**
   * @example
   * 100
   */
  downstreamHttp2MaxConcurrentStream?: number;
  /**
   * @example
   * 180
   */
  downstreamIdleTime?: number;
  /**
   * @example
   * false
   */
  enableCustomAuthConfigPush?: string;
  /**
   * @example
   * true
   */
  enableGenerateRequestId?: boolean;
  /**
   * @example
   * false
   */
  enableGzip?: boolean;
  /**
   * @example
   * true
   */
  enableHardwareAccelerate?: boolean;
  /**
   * @example
   * false
   */
  enableHttp2?: boolean;
  /**
   * @example
   * false
   */
  enableHttp3?: boolean;
  /**
   * @example
   * true
   */
  enableProxyProtocol?: boolean;
  /**
   * @example
   * true
   */
  enableSlashMerge?: boolean;
  /**
   * @example
   * true
   */
  enableWaf?: boolean;
  /**
   * @example
   * gw-61f465fa2dd044069e2208c4912*****
   */
  gatewayUniqueId?: string;
  /**
   * @example
   * 1048576
   */
  initialConnectionWindowSize?: number;
  /**
   * @example
   * 65535
   */
  initialStreamWindowSize?: number;
  /**
   * @example
   * 0
   */
  keepaliveHeaderTimeout?: number;
  /**
   * @example
   * ""
   */
  logFilterConfig?: string;
  /**
   * @example
   * "EnableProxyProtocol,EnableCustomAuthConfigPush"
   */
  noSupportedConfigList?: string;
  /**
   * @example
   * KEEP_UNCHANGED
   */
  pathWithEscapedSlashes?: string;
  /**
   * @example
   * true
   */
  preserveHeaderFormat?: boolean;
  slsConfigDetails?: GetGatewayConfigResponseBodyDataSlsConfigDetails;
  /**
   * @example
   * true
   */
  supportWaf?: boolean;
  /**
   * @example
   * 30
   */
  upstreamIdleTimeout?: number;
  /**
   * @example
   * 30
   */
  websocketTermGracePeriod?: number;
  /**
   * @example
   * 0
   */
  xffTrustedNum?: number;
  xtraceDetails?: GetGatewayConfigResponseBodyDataXtraceDetails;
  /**
   * @example
   * ["gzip"]
   */
  zipAlgorithm?: string;
  static names(): { [key: string]: string } {
    return {
      accessLogHeader: 'AccessLogHeader',
      downstreamConnectionBufferLimits: 'DownstreamConnectionBufferLimits',
      downstreamHttp2MaxConcurrentStream: 'DownstreamHttp2MaxConcurrentStream',
      downstreamIdleTime: 'DownstreamIdleTime',
      enableCustomAuthConfigPush: 'EnableCustomAuthConfigPush',
      enableGenerateRequestId: 'EnableGenerateRequestId',
      enableGzip: 'EnableGzip',
      enableHardwareAccelerate: 'EnableHardwareAccelerate',
      enableHttp2: 'EnableHttp2',
      enableHttp3: 'EnableHttp3',
      enableProxyProtocol: 'EnableProxyProtocol',
      enableSlashMerge: 'EnableSlashMerge',
      enableWaf: 'EnableWaf',
      gatewayUniqueId: 'GatewayUniqueId',
      initialConnectionWindowSize: 'InitialConnectionWindowSize',
      initialStreamWindowSize: 'InitialStreamWindowSize',
      keepaliveHeaderTimeout: 'KeepaliveHeaderTimeout',
      logFilterConfig: 'LogFilterConfig',
      noSupportedConfigList: 'NoSupportedConfigList',
      pathWithEscapedSlashes: 'PathWithEscapedSlashes',
      preserveHeaderFormat: 'PreserveHeaderFormat',
      slsConfigDetails: 'SlsConfigDetails',
      supportWaf: 'SupportWaf',
      upstreamIdleTimeout: 'UpstreamIdleTimeout',
      websocketTermGracePeriod: 'WebsocketTermGracePeriod',
      xffTrustedNum: 'XffTrustedNum',
      xtraceDetails: 'XtraceDetails',
      zipAlgorithm: 'ZipAlgorithm',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLogHeader: 'string',
      downstreamConnectionBufferLimits: 'number',
      downstreamHttp2MaxConcurrentStream: 'number',
      downstreamIdleTime: 'number',
      enableCustomAuthConfigPush: 'string',
      enableGenerateRequestId: 'boolean',
      enableGzip: 'boolean',
      enableHardwareAccelerate: 'boolean',
      enableHttp2: 'boolean',
      enableHttp3: 'boolean',
      enableProxyProtocol: 'boolean',
      enableSlashMerge: 'boolean',
      enableWaf: 'boolean',
      gatewayUniqueId: 'string',
      initialConnectionWindowSize: 'number',
      initialStreamWindowSize: 'number',
      keepaliveHeaderTimeout: 'number',
      logFilterConfig: 'string',
      noSupportedConfigList: 'string',
      pathWithEscapedSlashes: 'string',
      preserveHeaderFormat: 'boolean',
      slsConfigDetails: GetGatewayConfigResponseBodyDataSlsConfigDetails,
      supportWaf: 'boolean',
      upstreamIdleTimeout: 'number',
      websocketTermGracePeriod: 'number',
      xffTrustedNum: 'number',
      xtraceDetails: GetGatewayConfigResponseBodyDataXtraceDetails,
      zipAlgorithm: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayDomainDetailResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The start time.
   * 
   * @example
   * 2021-04-01 02:35:12
   */
  afterDate?: number;
  /**
   * @remarks
   * The algorithm.
   * 
   * @example
   * RSA
   */
  algorithm?: string;
  /**
   * @remarks
   * The expiration time.
   * 
   * @example
   * 2021-04-01 02:35:12
   */
  beforeDate?: number;
  /**
   * @remarks
   * The ID of the certificate.
   * 
   * @example
   * 234-cn-hangzhou
   */
  certIdentifier?: string;
  /**
   * @remarks
   * The name of the certificate.
   * 
   * @example
   * test
   */
  certName?: string;
  /**
   * @remarks
   * The public domain name.
   * 
   * @example
   * name
   */
  commonName?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 1
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-7ea3da97b96543e19f6c597cd4a9****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The start time.
   * 
   * @example
   * 2021-04-01 02:35:12
   */
  gmtAfter?: string;
  /**
   * @remarks
   * The expiration time.
   * 
   * @example
   * 2021-04-01 02:35:12
   */
  gmtBefore?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2022-01-07T10:07:57.000+0000
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The update time.
   * 
   * @example
   * 2022-01-07T10:07:57.000+0000
   */
  gmtModified?: string;
  /**
   * @remarks
   * Indicates whether `HTTP/2` is enabled.
   * 
   * *   `open`: `HTTP/2` is enabled.
   * *   `close`: `HTTP/2` is disabled.
   * *   `globalConfig`: Global configurations are used.
   * 
   * @example
   * close
   */
  http2?: string;
  /**
   * @remarks
   * The ID.
   * 
   * @example
   * 12
   */
  id?: number;
  /**
   * @remarks
   * The issuer.
   * 
   * @example
   * Istio
   */
  issuer?: string;
  /**
   * @remarks
   * Indicates whether HTTPS is forcibly used.
   * 
   * @example
   * true
   */
  mustHttps?: boolean;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * test.com
   */
  name?: string;
  /**
   * @remarks
   * The protocol of the gateway.
   * 
   * @example
   * HTTP
   */
  protocol?: string;
  /**
   * @remarks
   * The name of the extended field.
   * 
   * @example
   * test.com
   */
  sans?: string;
  /**
   * @remarks
   * The maximum version of Transport Layer Security (TLS).
   * 
   * @example
   * TLS 1.3
   */
  tlsMax?: string;
  /**
   * @remarks
   * The minimum version of TLS.
   * 
   * @example
   * TLS 1.0
   */
  tlsMin?: string;
  static names(): { [key: string]: string } {
    return {
      afterDate: 'AfterDate',
      algorithm: 'Algorithm',
      beforeDate: 'BeforeDate',
      certIdentifier: 'CertIdentifier',
      certName: 'CertName',
      commonName: 'CommonName',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtAfter: 'GmtAfter',
      gmtBefore: 'GmtBefore',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      http2: 'Http2',
      id: 'Id',
      issuer: 'Issuer',
      mustHttps: 'MustHttps',
      name: 'Name',
      protocol: 'Protocol',
      sans: 'Sans',
      tlsMax: 'TlsMax',
      tlsMin: 'TlsMin',
    };
  }

  static types(): { [key: string]: any } {
    return {
      afterDate: 'number',
      algorithm: 'string',
      beforeDate: 'number',
      certIdentifier: 'string',
      certName: 'string',
      commonName: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      gmtAfter: 'string',
      gmtBefore: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      http2: 'string',
      id: 'number',
      issuer: 'string',
      mustHttps: 'boolean',
      name: 'string',
      protocol: 'string',
      sans: 'string',
      tlsMax: 'string',
      tlsMin: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailResponseBodyDataCors extends $tea.Model {
  /**
   * @remarks
   * The credentials allowed.
   * 
   * @example
   * true
   */
  allowCredentials?: boolean;
  /**
   * @remarks
   * The headers allowed.
   * 
   * @example
   * *
   */
  allowHeaders?: string;
  /**
   * @remarks
   * The methods allowed.
   * 
   * @example
   * GET,POST,PUT,DELETE,HEAD,OPTIONS,PATCH
   */
  allowMethods?: string;
  /**
   * @remarks
   * The origins allowed.
   * 
   * @example
   * *
   */
  allowOrigins?: string;
  /**
   * @remarks
   * The response headers.
   * 
   * @example
   * *
   */
  exposeHeaders?: string;
  /**
   * @remarks
   * The status.
   * 
   * @example
   * off
   */
  status?: string;
  /**
   * @remarks
   * The time unit.
   * 
   * @example
   * h
   */
  timeUnit?: string;
  /**
   * @remarks
   * The unit number.
   * 
   * @example
   * 24
   */
  unitNum?: number;
  static names(): { [key: string]: string } {
    return {
      allowCredentials: 'AllowCredentials',
      allowHeaders: 'AllowHeaders',
      allowMethods: 'AllowMethods',
      allowOrigins: 'AllowOrigins',
      exposeHeaders: 'ExposeHeaders',
      status: 'Status',
      timeUnit: 'TimeUnit',
      unitNum: 'UnitNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowCredentials: 'boolean',
      allowHeaders: 'string',
      allowMethods: 'string',
      allowOrigins: 'string',
      exposeHeaders: 'string',
      status: 'string',
      timeUnit: 'string',
      unitNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailResponseBodyDataDirectResponse extends $tea.Model {
  /**
   * @remarks
   * The mock return value.
   * 
   * @example
   * {}
   */
  body?: string;
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  static names(): { [key: string]: string } {
    return {
      body: 'Body',
      code: 'Code',
    };
  }

  static types(): { [key: string]: any } {
    return {
      body: 'string',
      code: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailResponseBodyDataFallbackServices extends $tea.Model {
  /**
   * @remarks
   * The protocol type.
   * 
   * @example
   * DUBBO
   */
  agreementType?: string;
  /**
   * @remarks
   * The name of the group to which the service belongs.
   * 
   * @example
   * test
   */
  groupName?: string;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * name
   */
  name?: string;
  /**
   * @remarks
   * The namespace to which the service belongs.
   * 
   * @example
   * namespace
   */
  namespace?: string;
  /**
   * @remarks
   * The weight in the form of a percentage value.
   * 
   * @example
   * 80
   */
  percent?: number;
  /**
   * @remarks
   * The service ID.
   * 
   * @example
   * 1
   */
  serviceId?: number;
  /**
   * @remarks
   * The service name.
   * 
   * @example
   * name
   */
  serviceName?: string;
  /**
   * @remarks
   * The port number of the service.
   * 
   * @example
   * 8848
   */
  servicePort?: number;
  /**
   * @remarks
   * The source type of the service.
   * 
   * @example
   * MSE
   */
  sourceType?: string;
  /**
   * @remarks
   * The service version.
   * 
   * @example
   * v1
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      agreementType: 'AgreementType',
      groupName: 'GroupName',
      name: 'Name',
      namespace: 'Namespace',
      percent: 'Percent',
      serviceId: 'ServiceId',
      serviceName: 'ServiceName',
      servicePort: 'ServicePort',
      sourceType: 'SourceType',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      agreementType: 'string',
      groupName: 'string',
      name: 'string',
      namespace: 'string',
      percent: 'number',
      serviceId: 'number',
      serviceName: 'string',
      servicePort: 'number',
      sourceType: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailResponseBodyDataFlowMirror extends $tea.Model {
  /**
   * @remarks
   * 流量复制比例（%），取值0-100。
   * 
   * @example
   * 90
   */
  percentage?: number;
  /**
   * @remarks
   * 目标服务端口。
   * 
   * @example
   * 8790
   */
  port?: number;
  /**
   * @remarks
   * 开启状态，取值：
   * 
   * - on：开启
   * - off：关闭
   * 
   * @example
   * on
   */
  status?: string;
  /**
   * @remarks
   * 目标服务ID。
   * 
   * @example
   * 21
   */
  targetServiceId?: number;
  /**
   * @remarks
   * 目标服务名称。
   * 
   * @example
   * test
   */
  targetServiceName?: string;
  static names(): { [key: string]: string } {
    return {
      percentage: 'Percentage',
      port: 'Port',
      status: 'Status',
      targetServiceId: 'TargetServiceId',
      targetServiceName: 'TargetServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      percentage: 'number',
      port: 'number',
      status: 'string',
      targetServiceId: 'number',
      targetServiceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailResponseBodyDataHTTPRewrite extends $tea.Model {
  /**
   * @remarks
   * The hostname of the gateway.
   * 
   * @example
   * aliyuncs.com
   */
  host?: string;
  /**
   * @remarks
   * The path of the node.
   * 
   * @example
   * /test/client
   */
  path?: string;
  /**
   * @remarks
   * The rewrite type.
   * 
   * @example
   * PRE
   */
  pathType?: string;
  /**
   * @remarks
   * The matching pattern.
   * 
   * @example
   * /test
   */
  pattern?: string;
  /**
   * @remarks
   * The status of the policy.
   * 
   * @example
   * off
   */
  status?: string;
  /**
   * @remarks
   * The replacement.
   * 
   * @example
   * test
   */
  substitution?: string;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      path: 'Path',
      pathType: 'PathType',
      pattern: 'Pattern',
      status: 'Status',
      substitution: 'Substitution',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      path: 'string',
      pathType: 'string',
      pattern: 'string',
      status: 'string',
      substitution: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems extends $tea.Model {
  /**
   * @remarks
   * The request or response.
   * 
   * @example
   * Response
   */
  directionType?: string;
  /**
   * @remarks
   * The header key.
   * 
   * @example
   * debug
   */
  key?: string;
  /**
   * @remarks
   * The type of the operation.
   * 
   * @example
   * Add
   */
  opType?: string;
  /**
   * @remarks
   * The header value.
   * 
   * @example
   * test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      directionType: 'DirectionType',
      key: 'Key',
      opType: 'OpType',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      directionType: 'string',
      key: 'string',
      opType: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailResponseBodyDataHeaderOp extends $tea.Model {
  /**
   * @remarks
   * The information about headers.
   */
  headerOpItems?: GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems[];
  /**
   * @remarks
   * The status.
   * 
   * @example
   * off
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      headerOpItems: 'HeaderOpItems',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headerOpItems: { 'type': 'array', 'itemType': GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems },
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailResponseBodyDataRedirect extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The hostname.
   * 
   * @example
   * 16
   */
  host?: string;
  /**
   * @remarks
   * The path.
   * 
   * @example
   * 10111
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      host: 'Host',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      host: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailResponseBodyDataRetry extends $tea.Model {
  /**
   * @remarks
   * The number of retries allowed.
   * 
   * @example
   * 1
   */
  attempts?: number;
  /**
   * @remarks
   * The HTTP status codes.
   */
  httpCodes?: string[];
  /**
   * @remarks
   * The retry condition.
   */
  retryOn?: string[];
  /**
   * @remarks
   * The retry status.
   * 
   * @example
   * on
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      attempts: 'Attempts',
      httpCodes: 'HttpCodes',
      retryOn: 'RetryOn',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attempts: 'number',
      httpCodes: { 'type': 'array', 'itemType': 'string' },
      retryOn: { 'type': 'array', 'itemType': 'string' },
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates extends $tea.Model {
  /**
   * @remarks
   * The key of the request header.
   * 
   * @example
   * id
   */
  key?: string;
  /**
   * @remarks
   * The route type.
   * 
   * @example
   * PRE
   */
  type?: string;
  /**
   * @remarks
   * The value of the request header.
   * 
   * @example
   * 200
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates extends $tea.Model {
  /**
   * @remarks
   * Indicates whether case sensitivity is ignored.
   * 
   * @example
   * true
   */
  ignoreCase?: boolean;
  /**
   * @remarks
   * The path.
   * 
   * @example
   * /api
   */
  path?: string;
  /**
   * @remarks
   * The matching type.
   * 
   * @example
   * PRE
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      ignoreCase: 'IgnoreCase',
      path: 'Path',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ignoreCase: 'boolean',
      path: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates extends $tea.Model {
  /**
   * @remarks
   * The parameter name.
   * 
   * @example
   * userid
   */
  key?: string;
  /**
   * @remarks
   * The route type.
   * 
   * @example
   * PRE
   */
  type?: string;
  /**
   * @remarks
   * The value of the parameter.
   * 
   * @example
   * test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailResponseBodyDataRoutePredicates extends $tea.Model {
  /**
   * @remarks
   * The information about header matching.
   */
  headerPredicates?: GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates[];
  /**
   * @remarks
   * The information about method matching.
   */
  methodPredicates?: string[];
  /**
   * @remarks
   * The information about route matching.
   */
  pathPredicates?: GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates;
  /**
   * @remarks
   * The information about parameter matching.
   */
  queryPredicates?: GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates[];
  static names(): { [key: string]: string } {
    return {
      headerPredicates: 'HeaderPredicates',
      methodPredicates: 'MethodPredicates',
      pathPredicates: 'PathPredicates',
      queryPredicates: 'QueryPredicates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headerPredicates: { 'type': 'array', 'itemType': GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates },
      methodPredicates: { 'type': 'array', 'itemType': 'string' },
      pathPredicates: GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates,
      queryPredicates: { 'type': 'array', 'itemType': GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailResponseBodyDataRouteServicesHttpDubboTranscoderMothedMapListParamMapsList extends $tea.Model {
  extractKey?: string;
  extractKeySpec?: string;
  mappingType?: string;
  static names(): { [key: string]: string } {
    return {
      extractKey: 'ExtractKey',
      extractKeySpec: 'ExtractKeySpec',
      mappingType: 'MappingType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extractKey: 'string',
      extractKeySpec: 'string',
      mappingType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailResponseBodyDataRouteServicesHttpDubboTranscoderMothedMapList extends $tea.Model {
  dubboMothedName?: string;
  httpMothed?: string;
  mothedpath?: string;
  paramMapsList?: GetGatewayRouteDetailResponseBodyDataRouteServicesHttpDubboTranscoderMothedMapListParamMapsList[];
  passThroughAllHeaders?: string;
  passThroughList?: string[];
  static names(): { [key: string]: string } {
    return {
      dubboMothedName: 'DubboMothedName',
      httpMothed: 'HttpMothed',
      mothedpath: 'Mothedpath',
      paramMapsList: 'ParamMapsList',
      passThroughAllHeaders: 'PassThroughAllHeaders',
      passThroughList: 'PassThroughList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dubboMothedName: 'string',
      httpMothed: 'string',
      mothedpath: 'string',
      paramMapsList: { 'type': 'array', 'itemType': GetGatewayRouteDetailResponseBodyDataRouteServicesHttpDubboTranscoderMothedMapListParamMapsList },
      passThroughAllHeaders: 'string',
      passThroughList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailResponseBodyDataRouteServicesHttpDubboTranscoder extends $tea.Model {
  dubboServiceGroup?: string;
  dubboServiceName?: string;
  dubboServiceVersion?: string;
  mothedMapList?: GetGatewayRouteDetailResponseBodyDataRouteServicesHttpDubboTranscoderMothedMapList[];
  static names(): { [key: string]: string } {
    return {
      dubboServiceGroup: 'DubboServiceGroup',
      dubboServiceName: 'DubboServiceName',
      dubboServiceVersion: 'DubboServiceVersion',
      mothedMapList: 'MothedMapList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dubboServiceGroup: 'string',
      dubboServiceName: 'string',
      dubboServiceVersion: 'string',
      mothedMapList: { 'type': 'array', 'itemType': GetGatewayRouteDetailResponseBodyDataRouteServicesHttpDubboTranscoderMothedMapList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailResponseBodyDataRouteServices extends $tea.Model {
  /**
   * @remarks
   * The protocol type.
   * 
   * @example
   * DUBBO
   */
  agreementType?: string;
  /**
   * @remarks
   * The name of the group to which the service belongs.
   * 
   * @example
   * api
   */
  groupName?: string;
  /**
   * @example
   * Health
   */
  healthStatus?: string;
  httpDubboTranscoder?: GetGatewayRouteDetailResponseBodyDataRouteServicesHttpDubboTranscoder;
  /**
   * @remarks
   * The service name.
   * 
   * @example
   * dubbo4
   */
  name?: string;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The weight.
   * 
   * @example
   * 80
   */
  percent?: number;
  /**
   * @remarks
   * The service ID.
   * 
   * @example
   * 782
   */
  serviceId?: number;
  /**
   * @remarks
   * The service name.
   * 
   * @example
   * xkc-crm
   */
  serviceName?: string;
  /**
   * @remarks
   * The port number of the service.
   * 
   * @example
   * 20880
   */
  servicePort?: number;
  /**
   * @remarks
   * The source type of the service.
   * 
   * @example
   * MSE
   */
  sourceType?: string;
  unhealthyEndpoints?: string[];
  /**
   * @remarks
   * The service version.
   * 
   * @example
   * v1
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      agreementType: 'AgreementType',
      groupName: 'GroupName',
      healthStatus: 'HealthStatus',
      httpDubboTranscoder: 'HttpDubboTranscoder',
      name: 'Name',
      namespace: 'Namespace',
      percent: 'Percent',
      serviceId: 'ServiceId',
      serviceName: 'ServiceName',
      servicePort: 'ServicePort',
      sourceType: 'SourceType',
      unhealthyEndpoints: 'UnhealthyEndpoints',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      agreementType: 'string',
      groupName: 'string',
      healthStatus: 'string',
      httpDubboTranscoder: GetGatewayRouteDetailResponseBodyDataRouteServicesHttpDubboTranscoder,
      name: 'string',
      namespace: 'string',
      percent: 'number',
      serviceId: 'number',
      serviceName: 'string',
      servicePort: 'number',
      sourceType: 'string',
      unhealthyEndpoints: { 'type': 'array', 'itemType': 'string' },
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailResponseBodyDataTimeout extends $tea.Model {
  /**
   * @remarks
   * The status.
   * 
   * @example
   * off
   */
  status?: string;
  /**
   * @remarks
   * The time unit.
   * 
   * @example
   * s
   */
  timeUnit?: string;
  /**
   * @remarks
   * The unit number.
   * 
   * @example
   * 10
   */
  unitNum?: number;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      timeUnit: 'TimeUnit',
      unitNum: 'UnitNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      timeUnit: 'string',
      unitNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayRouteDetailResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The status of Application High Availability Service (AHAS).
   * 
   * @example
   * 1
   */
  ahasStatus?: number;
  /**
   * @remarks
   * The configuration for cross-origin resource sharing (CORS).
   */
  cors?: GetGatewayRouteDetailResponseBodyDataCors;
  /**
   * @remarks
   * The default service ID.
   * 
   * @example
   * 3
   */
  defaultServiceId?: number;
  /**
   * @remarks
   * The default service name.
   * 
   * @example
   * test
   */
  defaultServiceName?: string;
  /**
   * @example
   * a route for xxx
   */
  description?: string;
  /**
   * @remarks
   * The destination service type.
   * 
   * @example
   * Single
   */
  destinationType?: string;
  /**
   * @remarks
   * The information about service mocking.
   */
  directResponse?: GetGatewayRouteDetailResponseBodyDataDirectResponse;
  /**
   * @remarks
   * The domain ID.
   * 
   * @example
   * 235
   */
  domainId?: number;
  /**
   * @remarks
   * The IDs of domains.
   */
  domainIdList?: number[];
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * 123.com
   */
  domainName?: string;
  /**
   * @remarks
   * The list of domain names.
   */
  domainNameList?: string[];
  /**
   * @remarks
   * Indicates whether Web Application Firewall (WAF) is activated.
   * 
   * @example
   * true
   */
  enableWaf?: boolean;
  /**
   * @remarks
   * Indicates whether the Fallback service is enabled.
   * 
   * @example
   * true
   */
  fallback?: boolean;
  /**
   * @remarks
   * The information of the Fallback service.
   */
  fallbackServices?: GetGatewayRouteDetailResponseBodyDataFallbackServices[];
  /**
   * @remarks
   * 流量镜像配置。
   */
  flowMirror?: GetGatewayRouteDetailResponseBodyDataFlowMirror;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 1
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-7ea3da97b96543e19f6c597c****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2022-01-07 18:07:57
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The last modification time.
   * 
   * @example
   * 2022-01-07T10:07:57.000+0000
   */
  gmtModified?: string;
  /**
   * @remarks
   * The information about the rewrite policy.
   */
  HTTPRewrite?: GetGatewayRouteDetailResponseBodyDataHTTPRewrite;
  /**
   * @remarks
   * The header settings.
   */
  headerOp?: GetGatewayRouteDetailResponseBodyDataHeaderOp;
  /**
   * @remarks
   * The ID.
   * 
   * @example
   * 1050
   */
  id?: number;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The routing policy in a JSON string.
   * 
   * @example
   * {
   *       "CORS": "{\\"allowMethods\\":\\"GET,POST,PUT,DELETE,HEAD,OPTIONS,PATCH\\",\\"allowHeaders\\":\\"*\\",\\"exposeHeaders\\":\\"*\\",\\"unitNum\\":12,\\"allowCredentials\\":true,\\"status\\":\\"off\\",\\"allowOrigins\\":\\"*\\",\\"timeUnit\\":\\"h\\"}",
   *       "Timeout": "{\\"unitNum\\":10,\\"timeUnit\\":\\"s\\",\\"status\\":\\"off\\"}",
   *       "Retry": "{\\"attempts\\":2,\\"retryOn\\":[\\"5xx\\"],\\"status\\":\\"off\\"}",
   *       "HTTPRewrite": "{\\"pathType\\":\\"EQUAL\\",\\"path\\":\\"/o\\",\\"status\\":\\"off\\"}",
   *       "Waf": "{\\"enabled\\":false}",
   *       "HeaderOp": "{\\"status\\":\\"off\\",\\"headerOpItems\\":[{\\"directionType\\":\\"Request\\",\\"opType\\":\\"Add\\",\\"key\\":\\"kkk\\",\\"value\\":\\"ll\\"}]}"
   * }
   */
  policies?: string;
  /**
   * @remarks
   * The matching conditions.
   * 
   * @example
   * {}
   */
  predicates?: string;
  /**
   * @remarks
   * The configuration of the redirection.
   */
  redirect?: GetGatewayRouteDetailResponseBodyDataRedirect;
  /**
   * @remarks
   * The retry configuration.
   */
  retry?: GetGatewayRouteDetailResponseBodyDataRetry;
  /**
   * @remarks
   * The sequence number of the route.
   * 
   * @example
   * 1
   */
  routeOrder?: number;
  /**
   * @remarks
   * The information about route matching.
   */
  routePredicates?: GetGatewayRouteDetailResponseBodyDataRoutePredicates;
  /**
   * @remarks
   * The services.
   */
  routeServices?: GetGatewayRouteDetailResponseBodyDataRouteServices[];
  /**
   * @remarks
   * The configurations of services.
   * 
   * @example
   * [{\\"Percent\\":100,\\"ServiceId\\":126}]
   */
  services?: string;
  /**
   * @remarks
   * The status of the route. Valid values:
   * 
   * *   0: unpublished
   * *   2: publishing
   * *   3: published
   * *   4: editing (updated but not published)
   * *   5: unpublishing
   * *   6: unavailable
   * 
   * @example
   * 0
   */
  status?: number;
  /**
   * @remarks
   * The timeout configuration.
   */
  timeout?: GetGatewayRouteDetailResponseBodyDataTimeout;
  static names(): { [key: string]: string } {
    return {
      ahasStatus: 'AhasStatus',
      cors: 'Cors',
      defaultServiceId: 'DefaultServiceId',
      defaultServiceName: 'DefaultServiceName',
      description: 'Description',
      destinationType: 'DestinationType',
      directResponse: 'DirectResponse',
      domainId: 'DomainId',
      domainIdList: 'DomainIdList',
      domainName: 'DomainName',
      domainNameList: 'DomainNameList',
      enableWaf: 'EnableWaf',
      fallback: 'Fallback',
      fallbackServices: 'FallbackServices',
      flowMirror: 'FlowMirror',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      HTTPRewrite: 'HTTPRewrite',
      headerOp: 'HeaderOp',
      id: 'Id',
      name: 'Name',
      policies: 'Policies',
      predicates: 'Predicates',
      redirect: 'Redirect',
      retry: 'Retry',
      routeOrder: 'RouteOrder',
      routePredicates: 'RoutePredicates',
      routeServices: 'RouteServices',
      services: 'Services',
      status: 'Status',
      timeout: 'Timeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ahasStatus: 'number',
      cors: GetGatewayRouteDetailResponseBodyDataCors,
      defaultServiceId: 'number',
      defaultServiceName: 'string',
      description: 'string',
      destinationType: 'string',
      directResponse: GetGatewayRouteDetailResponseBodyDataDirectResponse,
      domainId: 'number',
      domainIdList: { 'type': 'array', 'itemType': 'number' },
      domainName: 'string',
      domainNameList: { 'type': 'array', 'itemType': 'string' },
      enableWaf: 'boolean',
      fallback: 'boolean',
      fallbackServices: { 'type': 'array', 'itemType': GetGatewayRouteDetailResponseBodyDataFallbackServices },
      flowMirror: GetGatewayRouteDetailResponseBodyDataFlowMirror,
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      HTTPRewrite: GetGatewayRouteDetailResponseBodyDataHTTPRewrite,
      headerOp: GetGatewayRouteDetailResponseBodyDataHeaderOp,
      id: 'number',
      name: 'string',
      policies: 'string',
      predicates: 'string',
      redirect: GetGatewayRouteDetailResponseBodyDataRedirect,
      retry: GetGatewayRouteDetailResponseBodyDataRetry,
      routeOrder: 'number',
      routePredicates: GetGatewayRouteDetailResponseBodyDataRoutePredicates,
      routeServices: { 'type': 'array', 'itemType': GetGatewayRouteDetailResponseBodyDataRouteServices },
      services: 'string',
      status: 'number',
      timeout: GetGatewayRouteDetailResponseBodyDataTimeout,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayServiceDetailResponseBodyDataLabelDetails extends $tea.Model {
  /**
   * @remarks
   * The tag.
   * 
   * @example
   * label
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   */
  values?: string[];
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      values: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList extends $tea.Model {
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-2837hfd91h34dbg87364g*****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 1667460287386
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The modification time.
   * 
   * @example
   * 1667460287386
   */
  gmtModified?: string;
  /**
   * @remarks
   * The port ID.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The service ID.
   * 
   * @example
   * 1
   */
  serviceId?: number;
  /**
   * @remarks
   * The service port number.
   * 
   * @example
   * 8080
   */
  servicePort?: number;
  /**
   * @remarks
   * The traffic policy.
   */
  trafficPolicy?: TrafficPolicy;
  static names(): { [key: string]: string } {
    return {
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      serviceId: 'ServiceId',
      servicePort: 'ServicePort',
      trafficPolicy: 'TrafficPolicy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      serviceId: 'number',
      servicePort: 'number',
      trafficPolicy: TrafficPolicy,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels extends $tea.Model {
  /**
   * @remarks
   * The tag.
   * 
   * @example
   * version
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * v2
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion extends $tea.Model {
  /**
   * @remarks
   * The tag.
   */
  labels?: GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels[];
  /**
   * @remarks
   * The version number.
   * 
   * @example
   * v2
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      labels: 'Labels',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      labels: { 'type': 'array', 'itemType': GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels },
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayServiceDetailResponseBodyDataVersionDetails extends $tea.Model {
  /**
   * @remarks
   * The number of instances.
   * 
   * @example
   * 1
   */
  endpointNum?: number;
  /**
   * @remarks
   * The percentage of instances.
   * 
   * @example
   * 20%
   */
  endpointNumPercent?: string;
  /**
   * @remarks
   * The service version.
   */
  serviceVersion?: GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion;
  static names(): { [key: string]: string } {
    return {
      endpointNum: 'EndpointNum',
      endpointNumPercent: 'EndpointNumPercent',
      serviceVersion: 'ServiceVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endpointNum: 'number',
      endpointNumPercent: 'string',
      serviceVersion: GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayServiceDetailResponseBodyDataVersions extends $tea.Model {
  /**
   * @remarks
   * The tag.
   * 
   * @example
   * version
   */
  label?: string;
  /**
   * @remarks
   * The type.
   * 
   * @example
   * test
   */
  type?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * v1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      label: 'Label',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      label: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayServiceDetailResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 1
   */
  gatewayId?: number;
  /**
   * @remarks
   * The traffic policy of the service.
   * 
   * @example
   * {}
   */
  gatewayTrafficPolicy?: TrafficPolicy;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-7ea3da97b96543e19f6c597c****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2022-01-07 18:07:57
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The last modification time.
   * 
   * @example
   * 2022-01-07T10:07:57.000+0000
   */
  gmtModified?: string;
  /**
   * @remarks
   * The name of the group.
   * 
   * @example
   * test
   */
  groupName?: string;
  /**
   * @remarks
   * Indicates whether the health check is enabled.
   * 
   * @example
   * true
   */
  healthCheck?: string;
  /**
   * @remarks
   * The status of the health check. Valid values:
   * 
   * @example
   * true
   */
  healthStatus?: string;
  /**
   * @remarks
   * The ID of the service.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The IP address of the service.
   */
  ips?: string[];
  /**
   * @remarks
   * The details of the tag.
   */
  labelDetails?: GetGatewayServiceDetailResponseBodyDataLabelDetails[];
  /**
   * @remarks
   * The basic information about the service.
   * 
   * @example
   * {}
   */
  metaInfo?: string;
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The traffic policy of service ports.
   */
  portTrafficPolicyList?: GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList[];
  /**
   * @remarks
   * The array of service ports.
   */
  ports?: number[];
  serviceFQDN?: string;
  /**
   * @remarks
   * The name of the service registered with the service registry.
   * 
   * @example
   * test
   */
  serviceNameInRegistry?: string;
  servicePort?: number;
  /**
   * @remarks
   * The protocol of the service.
   * 
   * @example
   * HTTP
   */
  serviceProtocol?: string;
  /**
   * @remarks
   * The ID of the service source.
   * 
   * @example
   * 1
   */
  sourceId?: number;
  /**
   * @remarks
   * The source type of the service.
   * 
   * @example
   * MSE
   */
  sourceType?: string;
  /**
   * @remarks
   * The details of versions.
   */
  versionDetails?: GetGatewayServiceDetailResponseBodyDataVersionDetails[];
  /**
   * @remarks
   * The service version. This parameter is deprecated.
   */
  versions?: GetGatewayServiceDetailResponseBodyDataVersions[];
  static names(): { [key: string]: string } {
    return {
      gatewayId: 'GatewayId',
      gatewayTrafficPolicy: 'GatewayTrafficPolicy',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      groupName: 'GroupName',
      healthCheck: 'HealthCheck',
      healthStatus: 'HealthStatus',
      id: 'Id',
      ips: 'Ips',
      labelDetails: 'LabelDetails',
      metaInfo: 'MetaInfo',
      name: 'Name',
      namespace: 'Namespace',
      portTrafficPolicyList: 'PortTrafficPolicyList',
      ports: 'Ports',
      serviceFQDN: 'ServiceFQDN',
      serviceNameInRegistry: 'ServiceNameInRegistry',
      servicePort: 'ServicePort',
      serviceProtocol: 'ServiceProtocol',
      sourceId: 'SourceId',
      sourceType: 'SourceType',
      versionDetails: 'VersionDetails',
      versions: 'Versions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gatewayId: 'number',
      gatewayTrafficPolicy: TrafficPolicy,
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      groupName: 'string',
      healthCheck: 'string',
      healthStatus: 'string',
      id: 'number',
      ips: { 'type': 'array', 'itemType': 'string' },
      labelDetails: { 'type': 'array', 'itemType': GetGatewayServiceDetailResponseBodyDataLabelDetails },
      metaInfo: 'string',
      name: 'string',
      namespace: 'string',
      portTrafficPolicyList: { 'type': 'array', 'itemType': GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList },
      ports: { 'type': 'array', 'itemType': 'number' },
      serviceFQDN: 'string',
      serviceNameInRegistry: 'string',
      servicePort: 'number',
      serviceProtocol: 'string',
      sourceId: 'number',
      sourceType: 'string',
      versionDetails: { 'type': 'array', 'itemType': GetGatewayServiceDetailResponseBodyDataVersionDetails },
      versions: { 'type': 'array', 'itemType': GetGatewayServiceDetailResponseBodyDataVersions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGovernanceKubernetesClusterResponseBodyDataNamespaces extends $tea.Model {
  /**
   * @remarks
   * The name of the MSE namespace that you want to access.
   * 
   * @example
   * default
   */
  mseNamespace?: string;
  /**
   * @remarks
   * The name of the namespace in the ACK cluster.
   * 
   * @example
   * default
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      mseNamespace: 'MseNamespace',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mseNamespace: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGovernanceKubernetesClusterResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * cd23228b3c80c4d4f9ad7af1d87cc30d5
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the instance.
   * 
   * @example
   * myCluster
   */
  clusterName?: string;
  /**
   * @remarks
   * The version of Kubernetes.
   * 
   * @example
   * 1.20.11-aliyun.1
   */
  k8sVersion?: string;
  /**
   * @remarks
   * The information of the namespace.
   * 
   * @example
   * [{\\"Name\\":\\"ack-onepilot\\",\\"Tags\\":null},{\\"Name\\":\\"default\\",\\"Tags\\":{\\"mse-enable\\":\\"enabled\\"}},{\\"Name\\":\\"kube-node-lease\\",\\"Tags\\":null},{\\"Name\\":\\"kube-public\\",\\"Tags\\":null},{\\"Name\\":\\"kube-system\\",\\"Tags\\":null}]
   */
  namespaceInfos?: string;
  /**
   * @remarks
   * The queried namespaces.
   */
  namespaces?: GetGovernanceKubernetesClusterResponseBodyDataNamespaces[];
  /**
   * @remarks
   * The time when the pilot component was started.
   * 
   * @example
   * 2022-01-11T11:50:38.000+0000
   */
  pilotStartTime?: string;
  /**
   * @remarks
   * The ID of the region in which the instance resides. The region is supported by MSE.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The time of the last modification.
   * 
   * @example
   * 2022-01-12T05:24:31.000+0000
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      k8sVersion: 'K8sVersion',
      namespaceInfos: 'NamespaceInfos',
      namespaces: 'Namespaces',
      pilotStartTime: 'PilotStartTime',
      region: 'Region',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterName: 'string',
      k8sVersion: 'string',
      namespaceInfos: 'string',
      namespaces: { 'type': 'array', 'itemType': GetGovernanceKubernetesClusterResponseBodyDataNamespaces },
      pilotStartTime: 'string',
      region: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetImageResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The full version number of the current instance image. The parameter is in the X.X.X.X format.
   * 
   * @example
   * 3.5.5.0
   */
  currentVersionFullShowName?: string;
  /**
   * @remarks
   * The URL of the changelog for the maximum version to which the current version can be upgraded.
   * 
   * @example
   * https://xxxxx
   */
  maxVersionChangelogUrl?: string;
  /**
   * @remarks
   * The code of the maximum version to which the current version can be upgraded.
   * 
   * @example
   * ZooKeeper_3_6_3
   */
  maxVersionCode?: string;
  /**
   * @remarks
   * The full number of the maximum version to which the current version can be upgraded.
   * 
   * @example
   * 3.6.3.0
   */
  maxVersionFullShowName?: string;
  static names(): { [key: string]: string } {
    return {
      currentVersionFullShowName: 'CurrentVersionFullShowName',
      maxVersionChangelogUrl: 'MaxVersionChangelogUrl',
      maxVersionCode: 'MaxVersionCode',
      maxVersionFullShowName: 'MaxVersionFullShowName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentVersionFullShowName: 'string',
      maxVersionChangelogUrl: 'string',
      maxVersionCode: 'string',
      maxVersionFullShowName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetImportFileUrlResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The URL that is used to upload the configuration file.
   * 
   * @example
   * http://xxxxxxx
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKubernetesSourceResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the ACK cluster.
   * 
   * @example
   * cbc1efca895a64af097ff00b26f3f****
   */
  cluster?: string;
  /**
   * @remarks
   * The name of the ACK cluster.
   * 
   * @example
   * k8s-demo
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      cluster: 'Cluster',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cluster: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLosslessRuleByAppResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Indicates whether service registration is complete before readiness probe.
   * 
   * @example
   * true
   */
  aligned?: boolean;
  /**
   * @remarks
   * The ID of the application.
   * 
   * @example
   * hkhon1po62@24810bf4364a***
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * The number of instances.
   * 
   * @example
   * 1
   */
  count?: number;
  /**
   * @remarks
   * The registration latency. Unit: seconds.
   * 
   * @example
   * 60
   */
  delayTime?: number;
  /**
   * @remarks
   * Indicates whether graceful start is enabled. Valid values:
   * 
   * *   `true`: enabled
   * *   `false`: disabled
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The slope of the prefetching curve.
   * 
   * @example
   * 2
   */
  funcType?: number;
  /**
   * @remarks
   * Indicates whether online and offline processing details are displayed.
   * 
   * @example
   * true
   */
  lossLessDetail?: boolean;
  /**
   * @remarks
   * Indicates whether notification is enabled.
   * 
   * @example
   * false
   */
  notice?: boolean;
  /**
   * @remarks
   * Indicates whether service prefetching is complete before readiness probe.
   * 
   * @example
   * false
   */
  related?: boolean;
  /**
   * @remarks
   * The prefetching duration. Unit: seconds.
   * 
   * @example
   * 120
   */
  warmupTime?: number;
  static names(): { [key: string]: string } {
    return {
      aligned: 'Aligned',
      appId: 'AppId',
      appName: 'AppName',
      count: 'Count',
      delayTime: 'DelayTime',
      enable: 'Enable',
      funcType: 'FuncType',
      lossLessDetail: 'LossLessDetail',
      notice: 'Notice',
      related: 'Related',
      warmupTime: 'WarmupTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aligned: 'boolean',
      appId: 'string',
      appName: 'string',
      count: 'number',
      delayTime: 'number',
      enable: 'boolean',
      funcType: 'number',
      lossLessDetail: 'boolean',
      notice: 'boolean',
      related: 'boolean',
      warmupTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMseSourceResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The endpoint of the instance.
   * 
   * @example
   * mse-af1****-nacos-ans.mse.aliyuncs.com:8848
   */
  address?: string;
  /**
   * @remarks
   * The ID of cluster.
   * 
   * @example
   * mse_
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the instance
   * 
   * @example
   * mse_prepaid_public_cn-7pp2eec****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The type.
   * 
   * @example
   * Nacos
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      clusterId: 'ClusterId',
      instanceId: 'InstanceId',
      name: 'Name',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      clusterId: 'string',
      instanceId: 'string',
      name: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNacosConfigResponseBodyConfiguration extends $tea.Model {
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * test
   */
  appName?: string;
  /**
   * @remarks
   * The list of IP addresses where the beta release of the configuration is performed.
   * 
   * @example
   * 1.1.XX.XX,2.2.XX.XX
   */
  betaIps?: string;
  /**
   * @remarks
   * The content of the configuration.
   * 
   * @example
   * log.level=error
   */
  content?: string;
  /**
   * @remarks
   * The ID of the configuration.
   * 
   * @example
   * log.yaml
   */
  dataId?: string;
  /**
   * @remarks
   * The description of the configuration.
   * 
   * @example
   * For testing
   */
  desc?: string;
  /**
   * @remarks
   * The encryption key.
   * 
   * @example
   * key
   */
  encryptedDataKey?: string;
  /**
   * @remarks
   * The name of the configuration group.
   * 
   * @example
   * test
   */
  group?: string;
  /**
   * @remarks
   * The message digest of the configuration.
   * 
   * @example
   * 123rfsdf3
   */
  md5?: string;
  /**
   * @remarks
   * The tags of the configuration.
   * 
   * @example
   * context
   */
  tags?: string;
  /**
   * @remarks
   * The format of the configuration.
   * 
   * @example
   * text
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      betaIps: 'BetaIps',
      content: 'Content',
      dataId: 'DataId',
      desc: 'Desc',
      encryptedDataKey: 'EncryptedDataKey',
      group: 'Group',
      md5: 'Md5',
      tags: 'Tags',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      betaIps: 'string',
      content: 'string',
      dataId: 'string',
      desc: 'string',
      encryptedDataKey: 'string',
      group: 'string',
      md5: 'string',
      tags: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNacosHistoryConfigResponseBodyConfiguration extends $tea.Model {
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * test
   */
  appName?: string;
  /**
   * @remarks
   * The content of the configuration.
   * 
   * @example
   * test
   */
  content?: string;
  /**
   * @remarks
   * The ID of the configuration.
   * 
   * @example
   * test.yaml
   */
  dataId?: string;
  /**
   * @remarks
   * The encryption key.
   * 
   * @example
   * 23fds****
   */
  encryptedDataKey?: string;
  /**
   * @remarks
   * The name of the configuration group.
   * 
   * @example
   * public
   */
  group?: string;
  /**
   * @remarks
   * The MD5 value of the configuration.
   * 
   * @example
   * 23sdf32f****
   */
  md5?: string;
  /**
   * @remarks
   * The configuration type.
   * 
   * @example
   * text
   */
  opType?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      content: 'Content',
      dataId: 'DataId',
      encryptedDataKey: 'EncryptedDataKey',
      group: 'Group',
      md5: 'Md5',
      opType: 'OpType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      content: 'string',
      dataId: 'string',
      encryptedDataKey: 'string',
      group: 'string',
      md5: 'string',
      opType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPluginConfigResponseBodyDataGatewayConfigListResourceList extends $tea.Model {
  id?: number;
  /**
   * @example
   * test-route
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPluginConfigResponseBodyDataGatewayConfigList extends $tea.Model {
  /**
   * @remarks
   * The plug-in configuration.
   * 
   * @example
   * \\# Configure a check for the required fields of the plug-in, such as name, age, and friends. Sample configuration: name: John age: 18 friends: - David - Anne
   */
  config?: string;
  /**
   * @remarks
   * The application scope of the plug-in. Valid values:
   * 
   * 0: global
   * 
   * 1: domain names
   * 
   * 2: routes
   * 
   * @example
   * 0
   */
  configLevel?: number;
  /**
   * @remarks
   * Indicates whether the plug-in is enabled.
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 1
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-ubuwqygbq4783gqb2y3f87q****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 1667309705000
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The update time.
   * 
   * @example
   * 1667309705000
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the plug-in configuration.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The ID of the gateway plug-in.
   * 
   * @example
   * 1
   */
  pluginId?: number;
  resourceList?: GetPluginConfigResponseBodyDataGatewayConfigListResourceList[];
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      configLevel: 'ConfigLevel',
      enable: 'Enable',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      pluginId: 'PluginId',
      resourceList: 'ResourceList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      configLevel: 'number',
      enable: 'boolean',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      pluginId: 'number',
      resourceList: { 'type': 'array', 'itemType': GetPluginConfigResponseBodyDataGatewayConfigListResourceList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPluginConfigResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The category of the plug-in. Valid values:
   * 
   * 0: user-defined
   * 
   * 1: permission authentication
   * 
   * 2: security protection
   * 
   * 3: transmission protocol
   * 
   * 4: traffic control
   * 
   * 5: traffic observation
   * 
   * @example
   * 0
   */
  category?: number;
  /**
   * @remarks
   * The information about the plug-in configuration used for checking.
   * 
   * @example
   * \\# The configuration includes the fields required for checking, such as name, age, and friends. Sample configuration: name: John age: 18 friends: - David - Anne
   */
  configCheck?: string;
  configExample?: string;
  /**
   * @example
   * 5
   */
  domainConfigStartIndex?: number;
  /**
   * @remarks
   * The list of gateway plug-in configurations.
   */
  gatewayConfigList?: GetPluginConfigResponseBodyDataGatewayConfigList[];
  /**
   * @example
   * 7
   */
  gatewayConfigStartIndex?: number;
  /**
   * @remarks
   * The ID of the plug-in.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The name of the image.
   * 
   * @example
   * name
   */
  imageName?: string;
  /**
   * @remarks
   * The mode.
   * 
   * @example
   * 0
   */
  mode?: number;
  /**
   * @remarks
   * The name of the plug-in.
   * 
   * @example
   * name
   */
  name?: string;
  /**
   * @remarks
   * The execution stage of the plug-in. Valid values:
   * 
   * 0: default stage
   * 
   * 1: authorization stage
   * 
   * 2: authentication stage
   * 
   * 3: statistics stage
   * 
   * @example
   * 0
   */
  phase?: number;
  /**
   * @remarks
   * The ID of the creator.
   * 
   * @example
   * 123
   */
  primaryUser?: string;
  /**
   * @remarks
   * The execution priority of the plug-in. A larger value indicates a higher priority.
   * 
   * @example
   * 1
   */
  priority?: number;
  /**
   * @remarks
   * The publish status.
   * 
   * @example
   * 1
   */
  publishState?: number;
  /**
   * @remarks
   * The description of the README file.
   * 
   * @example
   * read me
   */
  readme?: string;
  /**
   * @remarks
   * The description of the README file that is edited in English.
   * 
   * @example
   * read me
   */
  readmeEn?: string;
  /**
   * @example
   * 0
   */
  routeConfigStartIndex?: number;
  /**
   * @remarks
   * Indicates whether the plug-in is enabled. Valid values:
   * 
   * 0: disabled
   * 
   * 1: enabled
   * 
   * @example
   * 1
   */
  status?: string;
  /**
   * @remarks
   * The summary of the plug-in.
   * 
   * @example
   * This is a plug-in.
   */
  summary?: string;
  /**
   * @remarks
   * The type.
   * 
   * @example
   * 0
   */
  type?: number;
  /**
   * @remarks
   * The version of the plug-in.
   * 
   * @example
   * v1
   */
  version?: string;
  versionJson?: string;
  /**
   * @remarks
   * The WebAssembly language. Valid values:
   * 
   * 0: C++
   * 
   * 1: TinyGo
   * 
   * 2: Rust
   * 
   * 3: AssemblyScript
   * 
   * 4: Zig
   * 
   * @example
   * 0
   */
  wasmLang?: number;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      configCheck: 'ConfigCheck',
      configExample: 'ConfigExample',
      domainConfigStartIndex: 'DomainConfigStartIndex',
      gatewayConfigList: 'GatewayConfigList',
      gatewayConfigStartIndex: 'GatewayConfigStartIndex',
      id: 'Id',
      imageName: 'ImageName',
      mode: 'Mode',
      name: 'Name',
      phase: 'Phase',
      primaryUser: 'PrimaryUser',
      priority: 'Priority',
      publishState: 'PublishState',
      readme: 'Readme',
      readmeEn: 'ReadmeEn',
      routeConfigStartIndex: 'RouteConfigStartIndex',
      status: 'Status',
      summary: 'Summary',
      type: 'Type',
      version: 'Version',
      versionJson: 'VersionJson',
      wasmLang: 'WasmLang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'number',
      configCheck: 'string',
      configExample: 'string',
      domainConfigStartIndex: 'number',
      gatewayConfigList: { 'type': 'array', 'itemType': GetPluginConfigResponseBodyDataGatewayConfigList },
      gatewayConfigStartIndex: 'number',
      id: 'number',
      imageName: 'string',
      mode: 'number',
      name: 'string',
      phase: 'number',
      primaryUser: 'string',
      priority: 'number',
      publishState: 'number',
      readme: 'string',
      readmeEn: 'string',
      routeConfigStartIndex: 'number',
      status: 'string',
      summary: 'string',
      type: 'number',
      version: 'string',
      versionJson: 'string',
      wasmLang: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPluginsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The type of the plug-in. Valid values:
   * 
   * 0: custom
   * 
   * 1: permission authorization
   * 
   * 2: security protection
   * 
   * 3: transmission protocol
   * 
   * 4: traffic control
   * 
   * 5: traffic observation
   * 
   * @example
   * 0
   */
  category?: number;
  /**
   * @remarks
   * The information about the plug-in configuration used for checking.
   * 
   * @example
   * \\# The configuration includes the fields required for checking, such as name, age, and friends. Sample configuration: name: John age: 18 friends: - David - Anne
   */
  configCheck?: string;
  /**
   * @remarks
   * The ID of the plug-in.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @example
   * 1.0.0
   */
  maxVersion?: string;
  /**
   * @example
   * 0
   */
  mode?: number;
  /**
   * @remarks
   * The name of the plug-in.
   * 
   * @example
   * key-auth
   */
  name?: string;
  /**
   * @example
   * false
   */
  newVersionPublishingFlag?: boolean;
  /**
   * @remarks
   * The execution stage of the plug-in.
   * 
   * *   0: default stage
   * *   1: authorization stage
   * *   2: authentication stage
   * *   3: statistics stage
   * 
   * @example
   * 1
   */
  phase?: number;
  /**
   * @remarks
   * The ID of the creator.
   * 
   * @example
   * 123
   */
  primaryUser?: string;
  /**
   * @remarks
   * The execution priority of the plug-in. A larger value indicates a higher priority.
   * 
   * @example
   * 1
   */
  priority?: number;
  /**
   * @remarks
   * The publish status.
   * 
   * @example
   * 1
   */
  publishState?: number;
  /**
   * @remarks
   * Indicates whether the plug-in is enabled.
   * 
   * *   0: disabled
   * *   1: enabled
   * 
   * @example
   * 1
   */
  status?: string;
  /**
   * @remarks
   * The summary of the plug-in.
   * 
   * @example
   * This is a plug-in.
   */
  summary?: string;
  /**
   * @remarks
   * The version of the plug-in.
   * 
   * @example
   * v1
   */
  version?: string;
  /**
   * @remarks
   * The URL of the Object Storage Service (OSS) bucket that stores the WebAssembly plug-in.
   */
  wasmFile?: string;
  /**
   * @remarks
   * The WebAssembly language. Valid values:
   * 
   * *   0: C++
   * *   1: TinyGo
   * *   2: Rust
   * *   3: AssemblyScript
   * *   4: Zig
   * 
   * @example
   * 0
   */
  wasmLang?: number;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      configCheck: 'ConfigCheck',
      id: 'Id',
      maxVersion: 'MaxVersion',
      mode: 'Mode',
      name: 'Name',
      newVersionPublishingFlag: 'NewVersionPublishingFlag',
      phase: 'Phase',
      primaryUser: 'PrimaryUser',
      priority: 'Priority',
      publishState: 'PublishState',
      status: 'Status',
      summary: 'Summary',
      version: 'Version',
      wasmFile: 'WasmFile',
      wasmLang: 'WasmLang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'number',
      configCheck: 'string',
      id: 'number',
      maxVersion: 'string',
      mode: 'number',
      name: 'string',
      newVersionPublishingFlag: 'boolean',
      phase: 'number',
      primaryUser: 'string',
      priority: 'number',
      publishState: 'number',
      status: 'string',
      summary: 'string',
      version: 'string',
      wasmFile: 'string',
      wasmLang: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceListResponseBodyDataMethods extends $tea.Model {
  /**
   * @remarks
   * The controller of the method.
   * 
   * @example
   * com.alibaba.SayHelloController
   */
  methodController?: string;
  /**
   * @remarks
   * The name of the method.
   * 
   * @example
   * sayHello
   */
  name?: string;
  /**
   * @remarks
   * The data types of the parameters.
   */
  parameterTypes?: string[];
  /**
   * @remarks
   * The paths.
   */
  paths?: string[];
  /**
   * @remarks
   * The methods.
   */
  requestMethods?: string[];
  /**
   * @remarks
   * The type of the return value.
   * 
   * @example
   * int
   */
  returnType?: string;
  static names(): { [key: string]: string } {
    return {
      methodController: 'MethodController',
      name: 'Name',
      parameterTypes: 'ParameterTypes',
      paths: 'Paths',
      requestMethods: 'RequestMethods',
      returnType: 'ReturnType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      methodController: 'string',
      name: 'string',
      parameterTypes: { 'type': 'array', 'itemType': 'string' },
      paths: { 'type': 'array', 'itemType': 'string' },
      requestMethods: { 'type': 'array', 'itemType': 'string' },
      returnType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceListResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The name of the Dubbo application.
   * 
   * @example
   * dubbo-application
   */
  dubboApplicationName?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * test
   */
  edasAppName?: string;
  /**
   * @remarks
   * The group.
   * 
   * @example
   * dubbo
   */
  group?: string;
  /**
   * @remarks
   * The metadata.
   * 
   * @example
   * {}
   */
  metadata?: { [key: string]: any };
  /**
   * @remarks
   * The methods.
   */
  methods?: GetServiceListResponseBodyDataMethods[];
  /**
   * @remarks
   * The type of the service registry.
   * 
   * @example
   * nacos
   */
  registryType?: string;
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * com.alibaba.xxx
   */
  serviceName?: string;
  /**
   * @remarks
   * The type of the service.
   * 
   * @example
   * dubbo
   */
  serviceType?: string;
  /**
   * @remarks
   * The name of the Spring application.
   * 
   * @example
   * spring-application
   */
  springApplicationName?: string;
  /**
   * @remarks
   * The version information.
   * 
   * @example
   * 1.0.0
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      dubboApplicationName: 'DubboApplicationName',
      edasAppName: 'EdasAppName',
      group: 'Group',
      metadata: 'Metadata',
      methods: 'Methods',
      registryType: 'RegistryType',
      serviceName: 'ServiceName',
      serviceType: 'ServiceType',
      springApplicationName: 'SpringApplicationName',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dubboApplicationName: 'string',
      edasAppName: 'string',
      group: 'string',
      metadata: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      methods: { 'type': 'array', 'itemType': GetServiceListResponseBodyDataMethods },
      registryType: 'string',
      serviceName: 'string',
      serviceType: 'string',
      springApplicationName: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceListPageResponseBodyDataResult extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * dez4xxxxx@f3f75ed8ffxxxxx
   */
  appId?: string;
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * example-app
   */
  appName?: string;
  /**
   * @remarks
   * The time when the service was last updated.
   * 
   * @example
   * 123456
   */
  gmtModifyTime?: string;
  /**
   * @remarks
   * The group to which the service belongs.
   * 
   * @example
   * DEFAULT_GROUP
   */
  group?: string;
  /**
   * @remarks
   * The number of service nodes.
   * 
   * @example
   * 1
   */
  instanceNum?: number;
  /**
   * @remarks
   * The service name.
   * 
   * @example
   * sc-A
   */
  serviceName?: string;
  /**
   * @remarks
   * The service version.
   * 
   * @example
   * 1
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      gmtModifyTime: 'GmtModifyTime',
      group: 'Group',
      instanceNum: 'InstanceNum',
      serviceName: 'ServiceName',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appName: 'string',
      gmtModifyTime: 'string',
      group: 'string',
      instanceNum: 'number',
      serviceName: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceListPageResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: string;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: string;
  /**
   * @remarks
   * The data on the current page.
   */
  result?: GetServiceListPageResponseBodyDataResult[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 100
   */
  totalSize?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      result: 'Result',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'string',
      pageSize: 'string',
      result: { 'type': 'array', 'itemType': GetServiceListPageResponseBodyDataResult },
      totalSize: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceListenersResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The IP address of the listener.
   * 
   * @example
   * 119.23.84.102
   */
  addr?: string;
  /**
   * @remarks
   * The listener client version.
   * 
   * @example
   * Nacos-Java-Client:v2.1.1
   */
  agent?: string;
  /**
   * @remarks
   * The application name of the listener.
   * 
   * @example
   * app
   */
  app?: string;
  /**
   * @remarks
   * The name of the cluster to which the monitored service belongs.
   * 
   * @example
   * DEFAULT
   */
  cluster?: string;
  /**
   * @remarks
   * The IP address of the monitored service.
   * 
   * @example
   * 172.16.1.5
   */
  IP?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 0ba53825-b183-414f-a6a0-288e4f1c467e
   */
  namespaceId?: string;
  /**
   * @remarks
   * The port number of the monitored service.
   * 
   * @example
   * 8080
   */
  port?: string;
  /**
   * @remarks
   * The name of the monitored service.
   * 
   * @example
   * zeekr-orderboss
   */
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      addr: 'Addr',
      agent: 'Agent',
      app: 'App',
      cluster: 'Cluster',
      IP: 'IP',
      namespaceId: 'NamespaceId',
      port: 'Port',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addr: 'string',
      agent: 'string',
      app: 'string',
      cluster: 'string',
      IP: 'string',
      namespaceId: 'string',
      port: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceMethodPageResponseBodyDataResultParameterDefinitions extends $tea.Model {
  /**
   * @example
   * 参数描述示例
   */
  description?: string;
  /**
   * @example
   * aParam
   */
  name?: string;
  /**
   * @example
   * java.lang.String
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceMethodPageResponseBodyDataResult extends $tea.Model {
  /**
   * @example
   * com.alibabacloud.mse.demo.a.AController
   */
  methodController?: string;
  /**
   * @example
   * aMethod
   */
  name?: string;
  /**
   * @example
   * 示例接口描述信息。
   */
  nameDetail?: string;
  parameterDefinitions?: GetServiceMethodPageResponseBodyDataResultParameterDefinitions[];
  parameterDetails?: string[];
  parameterTypes?: string[];
  paths?: string[];
  requestMethods?: string[];
  /**
   * @example
   * java.lang.String
   */
  returnDetails?: string;
  /**
   * @example
   * java.lang.String
   */
  returnType?: string;
  static names(): { [key: string]: string } {
    return {
      methodController: 'MethodController',
      name: 'Name',
      nameDetail: 'NameDetail',
      parameterDefinitions: 'ParameterDefinitions',
      parameterDetails: 'ParameterDetails',
      parameterTypes: 'ParameterTypes',
      paths: 'Paths',
      requestMethods: 'RequestMethods',
      returnDetails: 'ReturnDetails',
      returnType: 'ReturnType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      methodController: 'string',
      name: 'string',
      nameDetail: 'string',
      parameterDefinitions: { 'type': 'array', 'itemType': GetServiceMethodPageResponseBodyDataResultParameterDefinitions },
      parameterDetails: { 'type': 'array', 'itemType': 'string' },
      parameterTypes: { 'type': 'array', 'itemType': 'string' },
      paths: { 'type': 'array', 'itemType': 'string' },
      requestMethods: { 'type': 'array', 'itemType': 'string' },
      returnDetails: 'string',
      returnType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceMethodPageResponseBodyData extends $tea.Model {
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  result?: GetServiceMethodPageResponseBodyDataResult[];
  /**
   * @example
   * 100
   */
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      result: 'Result',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      result: { 'type': 'array', 'itemType': GetServiceMethodPageResponseBodyDataResult },
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetZookeeperDataImportUrlResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * code
   * 
   * @example
   * 250000
   */
  maxSize?: string;
  /**
   * @remarks
   * The maximum size of a file that can be uploaded each time. Unit: MB.
   * 
   * @example
   * http://xxxxxxxxx
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      maxSize: 'MaxSize',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxSize: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportNacosConfigResponseBodyDataFailData extends $tea.Model {
  /**
   * @remarks
   * The ID of the group.
   * 
   * @example
   * test2.yaml
   */
  dataId?: string;
  /**
   * @example
   * test
   */
  group?: string;
  reason?: string;
  static names(): { [key: string]: string } {
    return {
      dataId: 'DataId',
      group: 'Group',
      reason: 'Reason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataId: 'string',
      group: 'string',
      reason: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportNacosConfigResponseBodyDataSkipData extends $tea.Model {
  /**
   * @remarks
   * The ID of the group.
   * 
   * @example
   * test.yaml
   */
  dataId?: string;
  /**
   * @remarks
   * The information about configurations that are failed to be imported.
   * 
   * @example
   * public
   */
  group?: string;
  static names(): { [key: string]: string } {
    return {
      dataId: 'DataId',
      group: 'Group',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataId: 'string',
      group: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportNacosConfigResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The data structure.
   */
  failData?: ImportNacosConfigResponseBodyDataFailData[];
  /**
   * @remarks
   * The information about skipped configurations.
   * 
   * @example
   * 10
   */
  skipCount?: number;
  /**
   * @remarks
   * The data structure.
   */
  skipData?: ImportNacosConfigResponseBodyDataSkipData[];
  /**
   * @remarks
   * The number of configurations that are skipped.
   * 
   * @example
   * 100
   */
  succCount?: number;
  static names(): { [key: string]: string } {
    return {
      failData: 'FailData',
      skipCount: 'SkipCount',
      skipData: 'SkipData',
      succCount: 'SuccCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failData: { 'type': 'array', 'itemType': ImportNacosConfigResponseBodyDataFailData },
      skipCount: 'number',
      skipData: { 'type': 'array', 'itemType': ImportNacosConfigResponseBodyDataSkipData },
      succCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportServicesRequestServiceList extends $tea.Model {
  /**
   * @remarks
   * The group.
   * 
   * @example
   * test
   */
  groupName?: string;
  /**
   * @remarks
   * The IP addresses of the service.
   */
  ips?: string[];
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * public
   */
  namespace?: string;
  /**
   * @remarks
   * The port of the service.
   * 
   * @example
   * 8080
   */
  servicePort?: number;
  /**
   * @remarks
   * The protocol of the service.
   * 
   * @example
   * GRPC, HTTP
   */
  serviceProtocol?: string;
  static names(): { [key: string]: string } {
    return {
      groupName: 'GroupName',
      ips: 'Ips',
      name: 'Name',
      namespace: 'Namespace',
      servicePort: 'ServicePort',
      serviceProtocol: 'ServiceProtocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupName: 'string',
      ips: { 'type': 'array', 'itemType': 'string' },
      name: 'string',
      namespace: 'string',
      servicePort: 'number',
      serviceProtocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnsInstancesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * app
   */
  app?: string;
  /**
   * @remarks
   * The name of the cluster.
   * 
   * @example
   * DEFAULT
   */
  clusterName?: string;
  /**
   * @remarks
   * The reference key.
   * 
   * @example
   * 30.5.XX.XX:unknown:DEFAULT
   */
  datumKey?: string;
  /**
   * @remarks
   * The default key.
   * 
   * @example
   * 30.5.XX.XX:unknown
   */
  defaultKey?: string;
  /**
   * @remarks
   * The effective status of the instance. Valid values:
   * 
   * *   `true`: The instance takes effect.
   * *   `false`: The instance does not take effect.
   * 
   * @example
   * true
   */
  enabled?: boolean;
  /**
   * @remarks
   * Indicates whether the information about the ephemeral node is obtained. Valid values:
   * 
   * *   `true`: yes
   * *   `false`: no
   * 
   * @example
   * true
   */
  ephemeral?: boolean;
  /**
   * @remarks
   * The number of counted failures.
   * 
   * @example
   * 0
   */
  failCount?: number;
  /**
   * @remarks
   * The health status of the instance. Valid values:
   * 
   * *   `true`: The instance is healthy.
   * *   `false`: The instance is unhealthy.
   * 
   * @example
   * true
   */
  healthy?: boolean;
  /**
   * @remarks
   * The heartbeat interval of the instance. Unit: seconds.
   * 
   * @example
   * 5000
   */
  instanceHeartBeatInterval?: number;
  /**
   * @remarks
   * The timeout period of the instance heartbeat.
   * 
   * @example
   * 15000
   */
  instanceHeartBeatTimeOut?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * 30.5.XX.XX#0#DEFAULT#DEFAULT_GROUP@@consumers:com.alibaba.edas.IHelloService
   */
  instanceId?: string;
  /**
   * @remarks
   * The public IP address.
   * 
   * @example
   * 30.5.XX.XX
   */
  ip?: string;
  /**
   * @remarks
   * The timeout period for removing an IP address.
   * 
   * @example
   * 30000
   */
  ipDeleteTimeout?: number;
  /**
   * @remarks
   * The last heartbeat time.
   * 
   * @example
   * 20201010
   */
  lastBeat?: number;
  /**
   * @remarks
   * Indicates whether the instance was marked. Valid values:
   * 
   * *   `true`: The instance marking was successful.
   * *   `false`: The instance marking failed.
   * 
   * @example
   * true
   */
  marked?: boolean;
  /**
   * @remarks
   * The metadata.
   * 
   * @example
   * [int]
   */
  metadata?: { [key: string]: any };
  /**
   * @remarks
   * The number of counted successes.
   * 
   * @example
   * 0
   */
  okCount?: number;
  /**
   * @remarks
   * The port number.
   * 
   * @example
   * 8080
   */
  port?: number;
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * DEFAULT_GROUP@@consumers:com.alibaba.edas.IHelloService::
   */
  serviceName?: string;
  /**
   * @remarks
   * The weight.
   * 
   * @example
   * 1
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      clusterName: 'ClusterName',
      datumKey: 'DatumKey',
      defaultKey: 'DefaultKey',
      enabled: 'Enabled',
      ephemeral: 'Ephemeral',
      failCount: 'FailCount',
      healthy: 'Healthy',
      instanceHeartBeatInterval: 'InstanceHeartBeatInterval',
      instanceHeartBeatTimeOut: 'InstanceHeartBeatTimeOut',
      instanceId: 'InstanceId',
      ip: 'Ip',
      ipDeleteTimeout: 'IpDeleteTimeout',
      lastBeat: 'LastBeat',
      marked: 'Marked',
      metadata: 'Metadata',
      okCount: 'OkCount',
      port: 'Port',
      serviceName: 'ServiceName',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      clusterName: 'string',
      datumKey: 'string',
      defaultKey: 'string',
      enabled: 'boolean',
      ephemeral: 'boolean',
      failCount: 'number',
      healthy: 'boolean',
      instanceHeartBeatInterval: 'number',
      instanceHeartBeatTimeOut: 'number',
      instanceId: 'string',
      ip: 'string',
      ipDeleteTimeout: 'number',
      lastBeat: 'number',
      marked: 'boolean',
      metadata: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      okCount: 'number',
      port: 'number',
      serviceName: 'string',
      weight: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnsServiceClustersResponseBodyDataAppDetail extends $tea.Model {
  /**
   * @remarks
   * The ID of the application for which Microservices Governance is enabled.
   * 
   * @example
   * hkhon1po62@904cba2c0xxxxxx
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application for which Microservices Governance is enabled.
   * 
   * @example
   * spring-cloud-b
   */
  appName?: string;
  /**
   * @remarks
   * The health check interval. Unit: seconds.
   * 
   * @example
   * 2
   */
  checkInternal?: number;
  /**
   * @remarks
   * The path of the health check. This parameter is required only when the CheckType parameter is set to http.
   * 
   * @example
   * /health
   */
  checkPath?: string;
  /**
   * @remarks
   * The timeout period of the health check response. Unit: seconds.
   * 
   * @example
   * 5
   */
  checkTimeout?: number;
  /**
   * @remarks
   * The type of the health check. Valid values:
   * 
   * *   connection: connection status check
   * *   tcp: TCP connection check
   * *   http: HTTP connection check
   * 
   * @example
   * connection
   */
  checkType?: string;
  /**
   * @remarks
   * The maximum number of health check retries when the instance state changes from unhealthy to healthy.
   * 
   * @example
   * 2
   */
  healthyCheckTimes?: number;
  /**
   * @remarks
   * The port number of the application for which Microservices Governance is enabled.
   * 
   * @example
   * 6001
   */
  port?: number;
  /**
   * @remarks
   * The maximum number of health check retries when the instance state changes from healthy to unhealthy.
   * 
   * @example
   * 2
   */
  unhealthyCheckTimes?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      checkInternal: 'CheckInternal',
      checkPath: 'CheckPath',
      checkTimeout: 'CheckTimeout',
      checkType: 'CheckType',
      healthyCheckTimes: 'HealthyCheckTimes',
      port: 'Port',
      unhealthyCheckTimes: 'UnhealthyCheckTimes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appName: 'string',
      checkInternal: 'number',
      checkPath: 'string',
      checkTimeout: 'number',
      checkType: 'string',
      healthyCheckTimes: 'number',
      port: 'number',
      unhealthyCheckTimes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnsServiceClustersResponseBodyDataClusters extends $tea.Model {
  /**
   * @remarks
   * The default port used for a health check.
   * 
   * @example
   * 80
   */
  defaultCheckPort?: number;
  /**
   * @remarks
   * The default port.
   * 
   * @example
   * 80
   */
  defaultPort?: number;
  /**
   * @remarks
   * The type of the health check.
   * 
   * @example
   * Heartbeat Reporting
   */
  healthCheckerType?: string;
  /**
   * @remarks
   * The metadata of the cluster.
   * 
   * @example
   * 111
   */
  metadata?: { [key: string]: any };
  /**
   * @remarks
   * The cluster name.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The full name of the service.
   * 
   * @example
   * DEFAULT_GROUP@@nacos.test.3
   */
  serviceName?: string;
  /**
   * @remarks
   * Indicates whether an end-to-end health check was initiated by the server. This parameter is valid only if the service is not a temporary service.
   * 
   * @example
   * true
   */
  useIPPort4Check?: boolean;
  static names(): { [key: string]: string } {
    return {
      defaultCheckPort: 'DefaultCheckPort',
      defaultPort: 'DefaultPort',
      healthCheckerType: 'HealthCheckerType',
      metadata: 'Metadata',
      name: 'Name',
      serviceName: 'ServiceName',
      useIPPort4Check: 'UseIPPort4Check',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultCheckPort: 'number',
      defaultPort: 'number',
      healthCheckerType: 'string',
      metadata: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      name: 'string',
      serviceName: 'string',
      useIPPort4Check: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnsServiceClustersResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The information about the associated application for which Microservices Governance is enabled when the Source parameter is set to governance.
   */
  appDetail?: ListAnsServiceClustersResponseBodyDataAppDetail;
  /**
   * @remarks
   * The cluster information.
   */
  clusters?: ListAnsServiceClustersResponseBodyDataClusters[];
  /**
   * @remarks
   * Indicates whether the service is a temporary service. Valid values:
   * 
   * *   `true`: yes
   * *   `false`: no
   * 
   * @example
   * true
   */
  ephemeral?: boolean;
  /**
   * @remarks
   * The service group to which the service belongs.
   * 
   * @example
   * DEFAULT_GROUP
   */
  groupName?: string;
  /**
   * @remarks
   * The metadata of the service.
   * 
   * @example
   * 111
   */
  metadata?: { [key: string]: any };
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * nacos.test.3
   */
  name?: string;
  /**
   * @remarks
   * The protection threshold.
   * 
   * @example
   * 0
   */
  protectThreshold?: number;
  /**
   * @remarks
   * The election mode.
   * 
   * @example
   * none
   */
  selectorType?: string;
  /**
   * @remarks
   * The source type of the service. Valid values:
   * 
   * *   console: The service was registered in the console.
   * *   sdk: The service was registered by using the SDK.
   * *   governance: The service was registered on Microservices Governance.
   * 
   * @example
   * console
   */
  source?: string;
  static names(): { [key: string]: string } {
    return {
      appDetail: 'AppDetail',
      clusters: 'Clusters',
      ephemeral: 'Ephemeral',
      groupName: 'GroupName',
      metadata: 'Metadata',
      name: 'Name',
      protectThreshold: 'ProtectThreshold',
      selectorType: 'SelectorType',
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appDetail: ListAnsServiceClustersResponseBodyDataAppDetail,
      clusters: { 'type': 'array', 'itemType': ListAnsServiceClustersResponseBodyDataClusters },
      ephemeral: 'boolean',
      groupName: 'string',
      metadata: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      name: 'string',
      protectThreshold: 'number',
      selectorType: 'string',
      source: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnsServicesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The total number of clusters.
   * 
   * @example
   * 1
   */
  clusterCount?: number;
  /**
   * @remarks
   * The name of the contact group.
   * 
   * @example
   * name
   */
  groupName?: string;
  /**
   * @remarks
   * The total number of instances with healthy heartbeats.
   * 
   * @example
   * 1
   */
  healthyInstanceCount?: number;
  /**
   * @remarks
   * The total number of instances that are used for the current service.
   * 
   * @example
   * 1
   */
  ipCount?: number;
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * name
   */
  name?: string;
  source?: string;
  static names(): { [key: string]: string } {
    return {
      clusterCount: 'ClusterCount',
      groupName: 'GroupName',
      healthyInstanceCount: 'HealthyInstanceCount',
      ipCount: 'IpCount',
      name: 'Name',
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterCount: 'number',
      groupName: 'string',
      healthyInstanceCount: 'number',
      ipCount: 'number',
      name: 'string',
      source: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems extends $tea.Model {
  cond?: string;
  datum?: string;
  divisor?: number;
  expr?: string;
  index?: number;
  nameList?: string[];
  operator?: string;
  rate?: number;
  remainder?: number;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      cond: 'cond',
      datum: 'datum',
      divisor: 'divisor',
      expr: 'expr',
      index: 'index',
      nameList: 'nameList',
      operator: 'operator',
      rate: 'rate',
      remainder: 'remainder',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cond: 'string',
      datum: 'string',
      divisor: 'number',
      expr: 'string',
      index: 'number',
      nameList: { 'type': 'array', 'itemType': 'string' },
      operator: 'string',
      rate: 'number',
      remainder: 'number',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo extends $tea.Model {
  appId?: string;
  argumentItems?: ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems[];
  condition?: string;
  group?: string;
  methodName?: string;
  paramTypes?: string[];
  serviceName?: string;
  tags?: string[];
  triggerPolicy?: string;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'appId',
      argumentItems: 'argumentItems',
      condition: 'condition',
      group: 'group',
      methodName: 'methodName',
      paramTypes: 'paramTypes',
      serviceName: 'serviceName',
      tags: 'tags',
      triggerPolicy: 'triggerPolicy',
      version: 'version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      argumentItems: { 'type': 'array', 'itemType': ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems },
      condition: 'string',
      group: 'string',
      methodName: 'string',
      paramTypes: { 'type': 'array', 'itemType': 'string' },
      serviceName: 'string',
      tags: { 'type': 'array', 'itemType': 'string' },
      triggerPolicy: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems extends $tea.Model {
  cond?: string;
  datum?: string;
  divisor?: number;
  name?: string;
  nameList?: string[];
  operator?: string;
  rate?: number;
  remainder?: number;
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      cond: 'cond',
      datum: 'datum',
      divisor: 'divisor',
      name: 'name',
      nameList: 'nameList',
      operator: 'operator',
      rate: 'rate',
      remainder: 'remainder',
      type: 'type',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cond: 'string',
      datum: 'string',
      divisor: 'number',
      name: 'string',
      nameList: { 'type': 'array', 'itemType': 'string' },
      operator: 'string',
      rate: 'number',
      remainder: 'number',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud extends $tea.Model {
  appId?: string;
  condition?: string;
  enable?: boolean;
  path?: string;
  paths?: string[];
  priority?: number;
  restItems?: ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems[];
  tags?: string[];
  triggerPolicy?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'appId',
      condition: 'condition',
      enable: 'enable',
      path: 'path',
      paths: 'paths',
      priority: 'priority',
      restItems: 'restItems',
      tags: 'tags',
      triggerPolicy: 'triggerPolicy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      condition: 'string',
      enable: 'boolean',
      path: 'string',
      paths: { 'type': 'array', 'itemType': 'string' },
      priority: 'number',
      restItems: { 'type': 'array', 'itemType': ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems },
      tags: { 'type': 'array', 'itemType': 'string' },
      triggerPolicy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRules extends $tea.Model {
  dubbo?: ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo[];
  springcloud?: ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud[];
  static names(): { [key: string]: string } {
    return {
      dubbo: 'dubbo',
      springcloud: 'springcloud',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dubbo: { 'type': 'array', 'itemType': ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo },
      springcloud: { 'type': 'array', 'itemType': ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsWithTagRulesResponseBodyDataResultRouteRules extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the alert rule is enabled. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The rule ID.
   * 
   * @example
   * 653
   */
  id?: number;
  /**
   * @remarks
   * The number of instances.
   * 
   * @example
   * 1
   */
  instanceNum?: number;
  /**
   * @remarks
   * The rule name.
   * 
   * @example
   * dubbo
   */
  name?: string;
  /**
   * @remarks
   * The rate.
   * 
   * @example
   * 10
   */
  rate?: number;
  /**
   * @remarks
   * The details of the routing rule.
   * 
   * @example
   * {
   *   	"dubbo": [{
   *     "serviceName": "com.taobao.hsf.common.DemoService",
   *     "group": "",
   *     "version": "",
   *     "methodName": "sayHello",
   *     "condition": "AND",
   *     "argumentItems": [{
   *     	"index": 0,
   *     	"expr": "",
   *     	"operator": "rawvalue",
   *     	"value": "jim",
   *     	"cond": "=="
   *     }]
   *   	}]
   *   }
   */
  rules?: ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRules;
  /**
   * @remarks
   * The status.
   * 
   * @example
   * 1
   */
  status?: number;
  /**
   * @remarks
   * The tag.
   * 
   * @example
   * gray
   */
  tag?: string;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      id: 'Id',
      instanceNum: 'InstanceNum',
      name: 'Name',
      rate: 'Rate',
      rules: 'Rules',
      status: 'Status',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
      id: 'number',
      instanceNum: 'number',
      name: 'string',
      rate: 'number',
      rules: ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRules,
      status: 'number',
      tag: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsWithTagRulesResponseBodyDataResult extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * daqijp6c31@xxx
   */
  appId?: string;
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * service-lottery-core
   */
  appName?: string;
  /**
   * @remarks
   * The MSE namespace to which the application belongs.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The queried rules.
   */
  routeRules?: ListApplicationsWithTagRulesResponseBodyDataResultRouteRules[];
  /**
   * @remarks
   * The route state. Valid values:
   * 
   * *   0: disabled
   * *   1: enabled
   * 
   * @example
   * 1
   */
  routeStatus?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      namespace: 'Namespace',
      routeRules: 'RouteRules',
      routeStatus: 'RouteStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appName: 'string',
      namespace: 'string',
      routeRules: { 'type': 'array', 'itemType': ListApplicationsWithTagRulesResponseBodyDataResultRouteRules },
      routeStatus: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsWithTagRulesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The returned data.
   */
  result?: ListApplicationsWithTagRulesResponseBodyDataResult[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      result: 'Result',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      result: { 'type': 'array', 'itemType': ListApplicationsWithTagRulesResponseBodyDataResult },
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAuthPolicyResponseBodyDataResultAuthRuleMethod extends $tea.Model {
  /**
   * @remarks
   * The group.
   * 
   * @example
   * default
   */
  group?: string;
  /**
   * @remarks
   * The method name.
   * 
   * @example
   * hello
   */
  name?: string;
  /**
   * @remarks
   * The types of request parameters.
   */
  parameterTypes?: string[];
  /**
   * @remarks
   * The type of the return value.
   * 
   * @example
   * Boolean
   */
  returnType?: string;
  /**
   * @remarks
   * The service name.
   * 
   * @example
   * spring-cloud-a
   */
  serviceName?: string;
  /**
   * @remarks
   * The method version.
   * 
   * @example
   * 0.0.1
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      group: 'Group',
      name: 'Name',
      parameterTypes: 'ParameterTypes',
      returnType: 'ReturnType',
      serviceName: 'ServiceName',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      group: 'string',
      name: 'string',
      parameterTypes: { 'type': 'array', 'itemType': 'string' },
      returnType: 'string',
      serviceName: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAuthPolicyResponseBodyDataResultAuthRule extends $tea.Model {
  /**
   * @remarks
   * The IDs of applications.
   */
  appIds?: string[];
  /**
   * @remarks
   * The rule type. Valid values:
   * 
   * *   0: by application
   * *   1: by namespace
   * 
   * @example
   * 0
   */
  authType?: number;
  /**
   * @remarks
   * Indicates whether the rule is a blacklist rule.
   * 
   * @example
   * false
   */
  black?: boolean;
  /**
   * @remarks
   * The queried namespaces.
   */
  k8sNamespaces?: string[];
  /**
   * @remarks
   * The request method.
   */
  method?: ListAuthPolicyResponseBodyDataResultAuthRuleMethod;
  /**
   * @remarks
   * The service path.
   * 
   * @example
   * /a
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      appIds: 'AppIds',
      authType: 'AuthType',
      black: 'Black',
      k8sNamespaces: 'K8sNamespaces',
      method: 'Method',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appIds: { 'type': 'array', 'itemType': 'string' },
      authType: 'number',
      black: 'boolean',
      k8sNamespaces: { 'type': 'array', 'itemType': 'string' },
      method: ListAuthPolicyResponseBodyDataResultAuthRuleMethod,
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAuthPolicyResponseBodyDataResult extends $tea.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account to which the resource belongs.
   * 
   * @example
   * 19039813784***
   */
  accountId?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * hkhon1po62@5f1b08becb*****
   */
  appId?: string;
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * The content of the service authentication rule.
   */
  authRule?: ListAuthPolicyResponseBodyDataResultAuthRule[];
  /**
   * @remarks
   * The rule type. Valid values:
   * 
   * *   0: by application
   * *   1: by namespace
   * 
   * @example
   * 0
   */
  authType?: number;
  /**
   * @remarks
   * Indicates whether the rule was enabled or disabled. Valid values:
   * 
   * *   `true`: enabled
   * *   `false`: disabled
   * 
   * @example
   * false
   */
  enable?: boolean;
  /**
   * @remarks
   * The rule ID.
   * 
   * @example
   * 204
   */
  id?: number;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * c19c6c500e1ff4d7abc7bed9b8236***
   */
  k8sNamespace?: string;
  /**
   * @remarks
   * The name of the authentication rule.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The namespace ID.
   * 
   * @example
   * ced54a95-4e33-4bda-be7e-37e95868***
   */
  namespaceId?: string;
  /**
   * @remarks
   * The protocol type. Valid values:
   * 
   * *   **SPRING_CLOUD**
   * *   **DUBBO**
   * *   **istio**
   * 
   * @example
   * SPRING_CLOUD
   */
  protocol?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The source of the application.
   * 
   * @example
   * edasmsc
   */
  source?: string;
  /**
   * @remarks
   * The status.
   * 
   * @example
   * 1
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      accountId: 'AccountId',
      appId: 'AppId',
      appName: 'AppName',
      authRule: 'AuthRule',
      authType: 'AuthType',
      enable: 'Enable',
      id: 'Id',
      k8sNamespace: 'K8sNamespace',
      name: 'Name',
      namespaceId: 'NamespaceId',
      protocol: 'Protocol',
      regionId: 'RegionId',
      source: 'Source',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
      appId: 'string',
      appName: 'string',
      authRule: { 'type': 'array', 'itemType': ListAuthPolicyResponseBodyDataResultAuthRule },
      authType: 'number',
      enable: 'boolean',
      id: 'number',
      k8sNamespace: 'string',
      name: 'string',
      namespaceId: 'string',
      protocol: 'string',
      regionId: 'string',
      source: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAuthPolicyResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The data returned.
   */
  result?: ListAuthPolicyResponseBodyDataResult[];
  /**
   * @remarks
   * The total number of entries.
   * 
   * @example
   * 11
   */
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      result: 'Result',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      result: { 'type': 'array', 'itemType': ListAuthPolicyResponseBodyDataResult },
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCircuitBreakerRulesResponseBodyDataResult extends $tea.Model {
  /**
   * @remarks
   * The ID of the application.
   * 
   * @example
   * hkhon1po62@c3df23522bXXXXX
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * Indicates whether the rule was enabled.
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The behavior that was bound to the rule.
   * 
   * @example
   * "{\\"appName\\":\\"spring-cloud-a\\",\\"fallbackBehavior\\":{\\"webFallbackMode\\":0,\\"webRespContentType\\":0,\\"webRespMessage\\":\\"Blocked\\",\\"webRespStatusCode\\":429},\\"id\\":977,\\"name\\":\\"Fallback\\",\\"namespace\\":\\"default\\",\\"resourceClassification\\":1}"
   */
  fallbackObject?: string;
  /**
   * @remarks
   * The minimum number of requests that can be passed in each step after circuit breaking recovers.
   * 
   * @example
   * 5
   */
  halfOpenBaseAmountPerStep?: number;
  /**
   * @remarks
   * The number of circuit breaking recovery steps.
   * 
   * @example
   * 1
   */
  halfOpenRecoveryStepNum?: number;
  /**
   * @remarks
   * The maximum RT. Unit: milliseconds. If the RT of a request is greater than the value of this parameter, a slow call is counted. If you set Strategy to 0, you must specify this parameter.
   * 
   * @example
   * 200
   */
  maxAllowedRtMs?: number;
  /**
   * @remarks
   * The minimum number of requests to trigger circuit breaking. If the number of requests in the current time window is less than the value of this parameter, circuit breaking is not triggered even if the circuit breaking rule is met.
   * 
   * @example
   * 10
   */
  minRequestAmount?: number;
  /**
   * @remarks
   * The microservice namespace to which the application belongs.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The region in which the instance resides.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the interface to which the rule is applicable. The interface name must be the same as the name on the interface details page in the console.
   * 
   * @example
   * /a
   */
  resource?: string;
  resourceType?: number;
  /**
   * @remarks
   * The period in which circuit breaking is implemented. Unit: milliseconds. If circuit breaking is implemented on the requests for the route, the calls to all the requests for the route fail in the configured circuit breaking period.
   * 
   * @example
   * 10000
   */
  retryTimeoutMs?: number;
  /**
   * @remarks
   * The ID of the rule.
   * 
   * @example
   * 1
   */
  ruleId?: number;
  /**
   * @remarks
   * The length of the time window. Unit: milliseconds. The valid range is from 1 second to 120 minutes.
   * 
   * @example
   * 20000
   */
  statIntervalMs?: number;
  /**
   * @remarks
   * The threshold type.
   * 
   * Valid values:
   * 
   * *   0
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     slow call proportion
   * 
   *     <!-- -->
   * 
   * *   1
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     abnormal proportion
   * 
   *     <!-- -->
   * 
   * @example
   * 0
   */
  strategy?: number;
  /**
   * @remarks
   * A percentage threshold for triggering circuit breaking. Valid values: 0-1. These values represent 0% to 100%.
   * 
   * @example
   * 0.8
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      enable: 'Enable',
      fallbackObject: 'FallbackObject',
      halfOpenBaseAmountPerStep: 'HalfOpenBaseAmountPerStep',
      halfOpenRecoveryStepNum: 'HalfOpenRecoveryStepNum',
      maxAllowedRtMs: 'MaxAllowedRtMs',
      minRequestAmount: 'MinRequestAmount',
      namespace: 'Namespace',
      regionId: 'RegionId',
      resource: 'Resource',
      resourceType: 'ResourceType',
      retryTimeoutMs: 'RetryTimeoutMs',
      ruleId: 'RuleId',
      statIntervalMs: 'StatIntervalMs',
      strategy: 'Strategy',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appName: 'string',
      enable: 'boolean',
      fallbackObject: 'string',
      halfOpenBaseAmountPerStep: 'number',
      halfOpenRecoveryStepNum: 'number',
      maxAllowedRtMs: 'number',
      minRequestAmount: 'number',
      namespace: 'string',
      regionId: 'string',
      resource: 'string',
      resourceType: 'number',
      retryTimeoutMs: 'number',
      ruleId: 'number',
      statIntervalMs: 'number',
      strategy: 'number',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCircuitBreakerRulesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The returned result.
   */
  result?: ListCircuitBreakerRulesResponseBodyDataResult[];
  /**
   * @remarks
   * The total number of pages.
   * 
   * @example
   * 3
   */
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      result: 'Result',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      result: { 'type': 'array', 'itemType': ListCircuitBreakerRulesResponseBodyDataResult },
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterConnectionTypesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The connection type.
   * 
   * @example
   * slb
   */
  showName?: string;
  static names(): { [key: string]: string } {
    return {
      showName: 'ShowName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      showName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHealthCheckTaskResponseBodyDataResultRiskList extends $tea.Model {
  /**
   * @remarks
   * The description.
   * 
   * @example
   * {\\\\"desc\\\\":\\\\"The engine version is outdated and a large number of features are not supported. Upgrade the engine to the latest version at the earliest opportunity. \\\\"}
   */
  description?: string;
  /**
   * @remarks
   * The ID.
   * 
   * @example
   * 3426
   */
  id?: number;
  /**
   * @remarks
   * A redundant parameter.
   * 
   * @example
   * null
   */
  module?: string;
  /**
   * @remarks
   * Indicates whether the risk item notification feature is disabled.
   * 
   * *   true: disabled
   * *   false: enabled
   * 
   * @example
   * false
   */
  mute?: boolean;
  /**
   * @remarks
   * A redundant parameter.
   * 
   * @example
   * null
   */
  noticeFeature?: boolean;
  /**
   * @remarks
   * The ID of the user to which the cluster belongs.
   * 
   * @example
   * 123456
   */
  primaryUser?: string;
  /**
   * @remarks
   * The risk code.
   * 
   * @example
   * 22020010001
   */
  riskCode?: string;
  /**
   * @remarks
   * The severity of the risk. Valid values:
   * 
   * *   HIGH: high risk
   * *   MID: medium risk
   * *   LOW: low risk
   * 
   * @example
   * MID
   */
  riskLevel?: string;
  /**
   * @remarks
   * The name of the risk.
   * 
   * @example
   * The engine version is outdated.
   */
  riskName?: string;
  /**
   * @remarks
   * The type of the risk.
   * 
   * @example
   * Version risk
   */
  riskType?: string;
  /**
   * @remarks
   * The situation.
   * 
   * @example
   * {\\\\"desc\\\\":\\\\"The engine version is outdated and a large number of features are not supported.\\\\",\\\\"links\\\\":[{\\\\"type\\\\":\\\\"url\\\\",\\\\"value\\\\":\\\\"https://xxxx"\\\\",\\\\"desc\\\\":\\\\"Release notes\\\\"}]}
   */
  situation?: string;
  /**
   * @remarks
   * The suggestion.
   * 
   * @example
   * {"desc": "Upgrade to the latest version at the earliest opportunity.", "links":[{"type": "upgrade", "desc": "Click to upgrade"}]}
   */
  suggestion?: string;
  /**
   * @remarks
   * The ID of the associated parent task.
   * 
   * @example
   * 1
   */
  taskId?: number;
  /**
   * @remarks
   * A redundant parameter.
   * 
   * @example
   * null
   */
  type?: number;
  /**
   * @remarks
   * A redundant parameter.
   * 
   * @example
   * null
   */
  values?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      id: 'Id',
      module: 'Module',
      mute: 'Mute',
      noticeFeature: 'NoticeFeature',
      primaryUser: 'PrimaryUser',
      riskCode: 'RiskCode',
      riskLevel: 'RiskLevel',
      riskName: 'RiskName',
      riskType: 'RiskType',
      situation: 'Situation',
      suggestion: 'Suggestion',
      taskId: 'TaskId',
      type: 'Type',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      id: 'number',
      module: 'string',
      mute: 'boolean',
      noticeFeature: 'boolean',
      primaryUser: 'string',
      riskCode: 'string',
      riskLevel: 'string',
      riskName: 'string',
      riskType: 'string',
      situation: 'string',
      suggestion: 'string',
      taskId: 'number',
      type: 'number',
      values: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHealthCheckTaskResponseBodyDataResult extends $tea.Model {
  /**
   * @remarks
   * The complete version number.
   * 
   * @example
   * 1.2.1
   */
  appVersion?: string;
  /**
   * @remarks
   * The billing method.
   * 
   * @example
   * PREPAY
   */
  chargeType?: string;
  /**
   * @remarks
   * The type of the cluster.
   * 
   * @example
   * Nacos-Ans
   */
  clusterType?: string;
  /**
   * @remarks
   * The time when the task was created.
   * 
   * @example
   * 2022-06-20T06:51:46Z
   */
  createTime?: string;
  /**
   * @remarks
   * The ID.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * A redundant parameter.
   * 
   * @example
   * null
   */
  imageVersion?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse_ingresspost-cn-0jbvrcex****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the user to which the instance belongs.
   * 
   * @example
   * 123456
   */
  primaryUser?: string;
  /**
   * @remarks
   * The number of nodes in the instance.
   * 
   * @example
   * 3
   */
  replica?: string;
  /**
   * @remarks
   * The list of risk items.
   */
  riskList?: ListClusterHealthCheckTaskResponseBodyDataResultRiskList[];
  /**
   * @remarks
   * The total score.
   * 
   * @example
   * 60
   */
  score?: number;
  /**
   * @remarks
   * The specifications.
   * 
   * @example
   * MSE_SC_2_4_200_c
   */
  spec?: string;
  /**
   * @remarks
   * The status of the task.
   * 
   * @example
   * FINISH
   */
  status?: string;
  /**
   * @remarks
   * The total number of check items.
   * 
   * @example
   * 10
   */
  totalItem?: number;
  /**
   * @remarks
   * The total number of risk items.
   * 
   * @example
   * 3
   */
  totalRisk?: number;
  /**
   * @remarks
   * A redundant parameter.
   * 
   * @example
   * null
   */
  type?: string;
  /**
   * @remarks
   * The last update time.
   * 
   * @example
   * 2022-11-12 15:07:55
   */
  updateTime?: string;
  /**
   * @remarks
   * The version number.
   * 
   * @example
   * NACOS_ANS_1_2_1_3
   */
  versionCode?: string;
  static names(): { [key: string]: string } {
    return {
      appVersion: 'AppVersion',
      chargeType: 'ChargeType',
      clusterType: 'ClusterType',
      createTime: 'CreateTime',
      id: 'Id',
      imageVersion: 'ImageVersion',
      instanceId: 'InstanceId',
      primaryUser: 'PrimaryUser',
      replica: 'Replica',
      riskList: 'RiskList',
      score: 'Score',
      spec: 'Spec',
      status: 'Status',
      totalItem: 'TotalItem',
      totalRisk: 'TotalRisk',
      type: 'Type',
      updateTime: 'UpdateTime',
      versionCode: 'VersionCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appVersion: 'string',
      chargeType: 'string',
      clusterType: 'string',
      createTime: 'string',
      id: 'number',
      imageVersion: 'string',
      instanceId: 'string',
      primaryUser: 'string',
      replica: 'string',
      riskList: { 'type': 'array', 'itemType': ListClusterHealthCheckTaskResponseBodyDataResultRiskList },
      score: 'number',
      spec: 'string',
      status: 'string',
      totalItem: 'number',
      totalRisk: 'number',
      type: 'string',
      updateTime: 'string',
      versionCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHealthCheckTaskResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 0
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The list of health check tasks.
   */
  result?: ListClusterHealthCheckTaskResponseBodyDataResult[];
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 9
   */
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      result: 'Result',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      result: { 'type': 'array', 'itemType': ListClusterHealthCheckTaskResponseBodyDataResult },
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterTypesResponseBodyData extends $tea.Model {
  code?: string;
  /**
   * @remarks
   * The type of the MSE engine that can be activated.
   * 
   * @example
   * Zookeeper
   */
  showName?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      showName: 'ShowName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      showName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterVersionsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The type of the instance.
   * 
   * @example
   * Nacos-Ans
   */
  clusterType?: string;
  /**
   * @remarks
   * The code of the instance type.
   * 
   * @example
   * NACOS_2_0_0
   */
  code?: string;
  /**
   * @remarks
   * The version of the instance.
   * 
   * @example
   * 2.1.0
   */
  showName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterType: 'ClusterType',
      code: 'Code',
      showName: 'ShowName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterType: 'string',
      code: 'string',
      showName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * prd
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersResponseBodyDataMaintenancePeriod extends $tea.Model {
  endTime?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The application version.
   * 
   * @example
   * 1.9.3
   */
  appVersion?: string;
  /**
   * @remarks
   * Indicates whether the instance can be upgraded.
   * 
   * @example
   * true
   */
  canUpdate?: boolean;
  /**
   * @remarks
   * The billing method, such as subscription or pay-as-you-go.
   * 
   * @example
   * Pay-as-you-go
   */
  chargeType?: string;
  /**
   * @remarks
   * The alias of the cluster.
   * 
   * @example
   * mse-7413****
   */
  clusterAliasName?: string;
  /**
   * @remarks
   * The name of the cluster.
   * 
   * @example
   * mse-cn-st21ri2****
   */
  clusterName?: string;
  /**
   * @remarks
   * The type of the cluster. Valid values: ZooKeeper, Nacos-Ans, and Eureka.
   * 
   * @example
   * Eureka
   */
  clusterType?: string;
  /**
   * @remarks
   * The time when the cluster was created.
   * 
   * @example
   * 2020-07-31 11:36:08
   */
  createTime?: string;
  /**
   * @remarks
   * The time when the cluster expires.
   * 
   * @example
   * 2021-08-01 00:00:00
   */
  endDate?: string;
  /**
   * @remarks
   * The initialization status of the instance.
   * 
   * @example
   * RESTART_SUCCESS
   */
  initStatus?: string;
  /**
   * @remarks
   * The number of clusters.
   * 
   * @example
   * 2
   */
  instanceCount?: number;
  /**
   * @remarks
   * The instance ID.
   * 
   * @example
   * mse-cn-st21ri2****
   */
  instanceId?: string;
  /**
   * @remarks
   * The public IP address.
   * 
   * @example
   * 47.98.XX.XX
   */
  internetAddress?: string;
  /**
   * @remarks
   * The public endpoint.
   * 
   * @example
   * mse-7413****-p.eureka.mse.aliyuncs.com
   */
  internetDomain?: string;
  /**
   * @remarks
   * The internal IP address.
   * 
   * @example
   * 192.168.XX.XX
   */
  intranetAddress?: string;
  /**
   * @remarks
   * The internal endpoint.
   * 
   * @example
   * mse-7413****-eureka.mse.aliyuncs.com
   */
  intranetDomain?: string;
  maintenancePeriod?: ListClustersResponseBodyDataMaintenancePeriod;
  /**
   * @remarks
   * The edition of the cluster.
   * 
   * @example
   * mse_pro
   */
  mseVersion?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs.
   * 
   * @example
   * rg-acfmv7jiavm4uxa
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The tags that are attached to the instance.
   */
  tags?: { [key: string]: any };
  /**
   * @remarks
   * The version information.
   * 
   * @example
   * EUREKA_1_9_3
   */
  versionCode?: string;
  /**
   * @example
   * vpc-bp1hcg467ekqsv0zr****
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      appVersion: 'AppVersion',
      canUpdate: 'CanUpdate',
      chargeType: 'ChargeType',
      clusterAliasName: 'ClusterAliasName',
      clusterName: 'ClusterName',
      clusterType: 'ClusterType',
      createTime: 'CreateTime',
      endDate: 'EndDate',
      initStatus: 'InitStatus',
      instanceCount: 'InstanceCount',
      instanceId: 'InstanceId',
      internetAddress: 'InternetAddress',
      internetDomain: 'InternetDomain',
      intranetAddress: 'IntranetAddress',
      intranetDomain: 'IntranetDomain',
      maintenancePeriod: 'MaintenancePeriod',
      mseVersion: 'MseVersion',
      resourceGroupId: 'ResourceGroupId',
      tags: 'Tags',
      versionCode: 'VersionCode',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appVersion: 'string',
      canUpdate: 'boolean',
      chargeType: 'string',
      clusterAliasName: 'string',
      clusterName: 'string',
      clusterType: 'string',
      createTime: 'string',
      endDate: 'string',
      initStatus: 'string',
      instanceCount: 'number',
      instanceId: 'string',
      internetAddress: 'string',
      internetDomain: 'string',
      intranetAddress: 'string',
      intranetDomain: 'string',
      maintenancePeriod: ListClustersResponseBodyDataMaintenancePeriod,
      mseVersion: 'string',
      resourceGroupId: 'string',
      tags: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      versionCode: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListConfigTrackResponseBodyTraces extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the request is sent from the client. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * false
   */
  client?: boolean;
  /**
   * @remarks
   * The ID of the configuration.
   * 
   * @example
   * eir-server.properties
   */
  dataId?: string;
  /**
   * @remarks
   * The response latency. Unit: milliseconds.
   * 
   * @example
   * 0
   */
  delay?: string;
  /**
   * @remarks
   * The event. Valid values:
   * 
   * *   pull: configuration acquisition events
   * *   persist: persistence events
   * 
   * @example
   * pull
   */
  event?: string;
  /**
   * @remarks
   * The name of the configuration group.
   * 
   * @example
   * DEFAULT_GROUP
   */
  group?: string;
  /**
   * @remarks
   * The logging time.
   * 
   * @example
   * 2022-11-28 15:09:15
   */
  logDate?: string;
  /**
   * @remarks
   * The MD5 value.
   * 
   * @example
   * d21c9091c60daa0ff7ee2f420141e5a0
   */
  md5?: string;
  /**
   * @remarks
   * Indicates whether messages are pushed by a server. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * false
   */
  push?: boolean;
  /**
   * @remarks
   * The source IP address of the request.
   * 
   * @example
   * 192.168.1.2
   */
  requestIp?: string;
  /**
   * @remarks
   * The response node.
   * 
   * @example
   * mse-1973b9a0-1670834*****-reg-center-0-2
   */
  responseIp?: string;
  /**
   * @remarks
   * The result.
   * 
   * @example
   * ok
   */
  result?: string;
  /**
   * @remarks
   * The timestamp that indicates the time when the metric value is collected.
   * 
   * Unit: seconds.
   * 
   * @example
   * 1659666529
   */
  ts?: string;
  /**
   * @remarks
   * The release type. Valid values:
   * 
   * *   beta: beta release
   * *   tag: canary release
   * *   batch: batch release
   * 
   * @example
   * beta
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      client: 'Client',
      dataId: 'DataId',
      delay: 'Delay',
      event: 'Event',
      group: 'Group',
      logDate: 'LogDate',
      md5: 'Md5',
      push: 'Push',
      requestIp: 'RequestIp',
      responseIp: 'ResponseIp',
      result: 'Result',
      ts: 'Ts',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      client: 'boolean',
      dataId: 'string',
      delay: 'string',
      event: 'string',
      group: 'string',
      logDate: 'string',
      md5: 'string',
      push: 'boolean',
      requestIp: 'string',
      responseIp: 'string',
      result: 'string',
      ts: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEngineNamespacesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The quota value.
   * 
   * @example
   * 1
   */
  configCount?: number;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * DEFAULT
   */
  namespace?: string;
  /**
   * @remarks
   * The description of the namespace.
   * 
   * @example
   * mytest
   */
  namespaceDesc?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * @example
   * public
   */
  namespaceShowName?: string;
  /**
   * @remarks
   * The quota.
   * 
   * @example
   * 200
   */
  quota?: number;
  /**
   * @remarks
   * The number of active services.
   * 
   * @example
   * 3
   */
  serviceCount?: string;
  /**
   * @remarks
   * The source from which the namespace was created.
   * 
   * @example
   * mse
   */
  sourceType?: string;
  /**
   * @remarks
   * The type of the namespace. Valid values:
   * 
   * *   `0`: global configuration
   * *   `1`: default namespace
   * *   `2`: custom namespace
   * 
   * @example
   * 0
   */
  type?: number;
  static names(): { [key: string]: string } {
    return {
      configCount: 'ConfigCount',
      namespace: 'Namespace',
      namespaceDesc: 'NamespaceDesc',
      namespaceShowName: 'NamespaceShowName',
      quota: 'Quota',
      serviceCount: 'ServiceCount',
      sourceType: 'SourceType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configCount: 'number',
      namespace: 'string',
      namespaceDesc: 'string',
      namespaceShowName: 'string',
      quota: 'number',
      serviceCount: 'string',
      sourceType: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEurekaInstancesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * CONTACTINFO
   */
  app?: string;
  /**
   * @remarks
   * The timeout period of the instance.\\
   * After the specified timeout period expires, the service is unavailable by default and is deleted.
   * 
   * @example
   * 90
   */
  durationInSecs?: number;
  /**
   * @remarks
   * The URL of the homepage.
   * 
   * @example
   * http://30.5.XX.XX:8091/
   */
  homePageUrl?: string;
  /**
   * @remarks
   * The hostname.
   * 
   * @example
   * 30.5.XX.XX
   */
  hostName?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * L-PC1A6A28-****.hz.ali.com:contactinfo:8091
   */
  instanceId?: string;
  /**
   * @remarks
   * The IP address.
   * 
   * @example
   * 30.5.XX.XX
   */
  ipAddr?: string;
  /**
   * @remarks
   * The time when the instance was last modified.
   * 
   * @example
   * 20201009115543
   */
  lastDirtyTimestamp?: number;
  /**
   * @remarks
   * The time when the instance heartbeat was last checked.
   * 
   * @example
   * 20201010071203
   */
  lastUpdatedTimestamp?: number;
  /**
   * @remarks
   * The metadata.
   * 
   * @example
   * [string]
   */
  metadata?: { [key: string]: any };
  /**
   * @remarks
   * The service port number.
   * 
   * @example
   * 8091
   */
  port?: number;
  /**
   * @remarks
   * The maximum interval between two heartbeat checks after a heartbeat check times out.\\
   * Default value: 10.
   * 
   * @example
   * 10
   */
  renewalIntervalInSecs?: number;
  /**
   * @remarks
   * The security port.
   * 
   * @example
   * 443
   */
  securePort?: number;
  /**
   * @remarks
   * The number of service providers. The value is in the following format: Number of healthy instances/Total number of instances.
   * 
   * @example
   * 1/1
   */
  status?: string;
  /**
   * @remarks
   * The virtual IP address (VIP).
   * 
   * @example
   * contactinfo
   */
  vipAddress?: string;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      durationInSecs: 'DurationInSecs',
      homePageUrl: 'HomePageUrl',
      hostName: 'HostName',
      instanceId: 'InstanceId',
      ipAddr: 'IpAddr',
      lastDirtyTimestamp: 'LastDirtyTimestamp',
      lastUpdatedTimestamp: 'LastUpdatedTimestamp',
      metadata: 'Metadata',
      port: 'Port',
      renewalIntervalInSecs: 'RenewalIntervalInSecs',
      securePort: 'SecurePort',
      status: 'Status',
      vipAddress: 'VipAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: 'string',
      durationInSecs: 'number',
      homePageUrl: 'string',
      hostName: 'string',
      instanceId: 'string',
      ipAddr: 'string',
      lastDirtyTimestamp: 'number',
      lastUpdatedTimestamp: 'number',
      metadata: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      port: 'number',
      renewalIntervalInSecs: 'number',
      securePort: 'number',
      status: 'string',
      vipAddress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEurekaServicesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The details of the instance.
   */
  instancesId?: string[];
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * CONTACTINFO
   */
  name?: string;
  /**
   * @remarks
   * The number of service providers. The value is in the following format: Number of healthy instances/Total number of instances.
   * 
   * @example
   * 1/1
   */
  upStatus?: string;
  static names(): { [key: string]: string } {
    return {
      instancesId: 'InstancesId',
      name: 'Name',
      upStatus: 'UpStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instancesId: { 'type': 'array', 'itemType': 'string' },
      name: 'string',
      upStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListExportZookeeperDataResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The details of the task.
   * 
   * @example
   * {}
   */
  contentMap?: string;
  /**
   * @remarks
   * The time when the task was created.
   * 
   * @example
   * 1631001140913
   */
  createTime?: number;
  /**
   * @remarks
   * The type of the object that is exported. Valid values:
   * 
   * *   transactionLog: transaction logs
   * *   snapshot: snapshots
   * 
   * @example
   * snapshot
   */
  exportType?: string;
  /**
   * @remarks
   * The extension information that is in the JSON format. The extension information facilitates addition of parameters.
   * 
   * @example
   * {}
   */
  extend?: string;
  /**
   * @remarks
   * The ID of the task.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The ID of the instance
   * 
   * @example
   * mse-cn-st21ri2****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the associated task at the underlying layer. This parameter is used only to troubleshoot failures.
   * 
   * @example
   * 10
   */
  kubeoneTaskIds?: string;
  /**
   * @remarks
   * The status of the task. Valid values:
   * 
   * *   CREATE: The task is being created.
   * *   RUNNING: The task is being executed.
   * *   FINISH: The task is completed.
   * *   FAILED: The task failed.
   * *   EXPIRE: The task has expired.
   * 
   * @example
   * FINISH
   */
  status?: string;
  /**
   * @remarks
   * The time when the task was updated.
   * 
   * @example
   * 1632979237663
   */
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      contentMap: 'ContentMap',
      createTime: 'CreateTime',
      exportType: 'ExportType',
      extend: 'Extend',
      id: 'Id',
      instanceId: 'InstanceId',
      kubeoneTaskIds: 'KubeoneTaskIds',
      status: 'Status',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentMap: 'string',
      createTime: 'number',
      exportType: 'string',
      extend: 'string',
      id: 'number',
      instanceId: 'string',
      kubeoneTaskIds: 'string',
      status: 'string',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowRulesResponseBodyDataResult extends $tea.Model {
  /**
   * @remarks
   * The ID of the application.
   * 
   * @example
   * hkhon1po62@5f1b08becb*****
   */
  appId?: string;
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * finance
   */
  appName?: string;
  /**
   * @remarks
   * The throttling effect.
   * 
   * Valid values:
   * 
   * *   0
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     fast failure
   * 
   *     <!-- -->
   * 
   * *   2
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     in queue
   * 
   *     <!-- -->
   * 
   * @example
   * 0
   */
  controlBehavior?: number;
  /**
   * @remarks
   * Indicates whether the throttling rule was enabled.
   * 
   * Valid values:
   * 
   * *   true
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   false
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The throttling behavior.
   * 
   * @example
   * "{\\"appName\\":\\"spring-cloud-a\\",\\"fallbackBehavior\\":{\\"webFallbackMode\\":0,\\"webRespContentType\\":0,\\"webRespMessage\\":\\"Blocked\\",\\"webRespStatusCode\\":429},\\"id\\":977,\\"name\\":\\"Fallback\\",\\"namespace\\":\\"default\\",\\"resourceClassification\\":1}"
   */
  fallbackObject?: string;
  /**
   * @remarks
   * The timeout period for queuing when the value of ControlBehavior is set to 2. Unit: milliseconds.
   * 
   * @example
   * 500
   */
  maxQueueingTimeMs?: number;
  /**
   * @remarks
   * The statistical dimension. The value 1 indicates that the number of accepted requests is used for statistics.
   * 
   * @example
   * 1
   */
  metricType?: number;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The ID of the region in which the instance resides.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the interface resource.
   * 
   * @example
   * /a
   */
  resource?: string;
  resourceType?: number;
  /**
   * @remarks
   * The rule ID.
   * 
   * @example
   * 2
   */
  ruleId?: number;
  /**
   * @remarks
   * The throttling threshold.
   * 
   * @example
   * 10
   */
  threshold?: number;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * {\\"origin\\":\\"default\\"}
   */
  trafficTags?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      controlBehavior: 'ControlBehavior',
      enable: 'Enable',
      fallbackObject: 'FallbackObject',
      maxQueueingTimeMs: 'MaxQueueingTimeMs',
      metricType: 'MetricType',
      namespace: 'Namespace',
      regionId: 'RegionId',
      resource: 'Resource',
      resourceType: 'ResourceType',
      ruleId: 'RuleId',
      threshold: 'Threshold',
      trafficTags: 'TrafficTags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appName: 'string',
      controlBehavior: 'number',
      enable: 'boolean',
      fallbackObject: 'string',
      maxQueueingTimeMs: 'number',
      metricType: 'number',
      namespace: 'string',
      regionId: 'string',
      resource: 'string',
      resourceType: 'number',
      ruleId: 'number',
      threshold: 'number',
      trafficTags: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowRulesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The data returned.
   */
  result?: ListFlowRulesResponseBodyDataResult[];
  /**
   * @remarks
   * The total number of entries.
   * 
   * @example
   * 11
   */
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      result: 'Result',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      result: { 'type': 'array', 'itemType': ListFlowRulesResponseBodyDataResult },
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRequestFilterParams extends $tea.Model {
  /**
   * @remarks
   * The type of the gateway.
   * 
   * @example
   * Ingress
   */
  gatewayType?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-5017305290e14centbrveca****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse_ingresspre-cn-****
   */
  instanceId?: string;
  /**
   * @remarks
   * The tag of the instance.
   * 
   * @example
   * [{"key":"tagkey","value":"tagvalue"}]
   */
  mseTag?: string;
  /**
   * @remarks
   * The name of the gateway.
   * 
   * @example
   * rutain-test
   */
  name?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-7y2uye*****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The ID of the virtual private cloud (VPC).
   * 
   * @example
   * vpc-bp13hhyjntbab7w****
   */
  vpc?: string;
  static names(): { [key: string]: string } {
    return {
      gatewayType: 'GatewayType',
      gatewayUniqueId: 'GatewayUniqueId',
      instanceId: 'InstanceId',
      mseTag: 'MseTag',
      name: 'Name',
      resourceGroupId: 'ResourceGroupId',
      vpc: 'Vpc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gatewayType: 'string',
      gatewayUniqueId: 'string',
      instanceId: 'string',
      mseTag: 'string',
      name: 'string',
      resourceGroupId: 'string',
      vpc: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayResponseBodyDataResultElasticPolicyEnableScaleTimePolicyList extends $tea.Model {
  endTime?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList extends $tea.Model {
  /**
   * @remarks
   * The expected number of replicas for auto scale-out.
   * 
   * @example
   * 4
   */
  desiredReplica?: number;
  /**
   * @remarks
   * The end time of auto scale-out.
   * 
   * @example
   * 09:00
   */
  endTime?: string;
  /**
   * @remarks
   * The start time of auto scale-out.
   * 
   * @example
   * 07:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      desiredReplica: 'DesiredReplica',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desiredReplica: 'number',
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayResponseBodyDataResultElasticPolicy extends $tea.Model {
  /**
   * @remarks
   * Indicates whether auto scale-out is enabled.
   * 
   * @example
   * true
   */
  elastic?: boolean;
  /**
   * @remarks
   * The type of auto scale-out. Valid value:
   * 
   * *   CronHPA: scale-out by time
   * 
   * @example
   * CronHPA
   */
  elasticType?: string;
  enableScaleTimePolicyList?: ListGatewayResponseBodyDataResultElasticPolicyEnableScaleTimePolicyList[];
  loadWarningThreshold?: boolean;
  /**
   * @remarks
   * The maximum number of instances that are automatically scaled out. This parameter is used for horizontal scale-out.
   * 
   * @example
   * 10
   */
  maxReplica?: number;
  /**
   * @remarks
   * The time policy list for auto scale-out.
   */
  timePolicyList?: ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList[];
  static names(): { [key: string]: string } {
    return {
      elastic: 'Elastic',
      elasticType: 'ElasticType',
      enableScaleTimePolicyList: 'EnableScaleTimePolicyList',
      loadWarningThreshold: 'LoadWarningThreshold',
      maxReplica: 'MaxReplica',
      timePolicyList: 'TimePolicyList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      elastic: 'boolean',
      elasticType: 'string',
      enableScaleTimePolicyList: { 'type': 'array', 'itemType': ListGatewayResponseBodyDataResultElasticPolicyEnableScaleTimePolicyList },
      loadWarningThreshold: 'boolean',
      maxReplica: 'number',
      timePolicyList: { 'type': 'array', 'itemType': ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayResponseBodyDataResultInitConfig extends $tea.Model {
  /**
   * @remarks
   * Indicates whether Web Application Firewall (WAF) is enabled.
   * 
   * @example
   * true
   */
  enableWaf?: boolean;
  /**
   * @remarks
   * Indicates whether WAF is supported.
   * 
   * @example
   * true
   */
  supportWaf?: boolean;
  static names(): { [key: string]: string } {
    return {
      enableWaf: 'EnableWaf',
      supportWaf: 'SupportWaf',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableWaf: 'boolean',
      supportWaf: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayResponseBodyDataResultInternetSlb extends $tea.Model {
  /**
   * @remarks
   * The mode of the SLB instance.
   * 
   * @example
   * UserHost
   */
  gatewaySlbMode?: string;
  /**
   * @remarks
   * The state of the SLB instance.
   * 
   * @example
   * Ready
   */
  gatewaySlbStatus?: string;
  /**
   * @remarks
   * The traffic of the gateway.
   * 
   * @example
   * 20
   */
  internetNetworkFlow?: string;
  /**
   * @remarks
   * The ID of the SLB instance.
   * 
   * @example
   * lb-bp1ut8asdfgucjk****
   */
  slbId?: string;
  /**
   * @remarks
   * The IP address of the SLB instance.
   * 
   * @example
   * 153.12.XX.XX
   */
  slbIp?: string;
  /**
   * @remarks
   * The port number of the SLB instance.
   * 
   * @example
   * slb.s2.small
   */
  slbPort?: string;
  /**
   * @remarks
   * The specifications of the SLB instance.
   * 
   * @example
   * slb.s2.small
   */
  slbSpec?: string;
  /**
   * @remarks
   * The description of the state.
   * 
   * @example
   * Creating
   */
  statusDesc?: string;
  /**
   * @remarks
   * The type of the SLB instance.
   * 
   * @example
   * PUB_NET
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      gatewaySlbMode: 'GatewaySlbMode',
      gatewaySlbStatus: 'GatewaySlbStatus',
      internetNetworkFlow: 'InternetNetworkFlow',
      slbId: 'SlbId',
      slbIp: 'SlbIp',
      slbPort: 'SlbPort',
      slbSpec: 'SlbSpec',
      statusDesc: 'StatusDesc',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gatewaySlbMode: 'string',
      gatewaySlbStatus: 'string',
      internetNetworkFlow: 'string',
      slbId: 'string',
      slbIp: 'string',
      slbPort: 'string',
      slbSpec: 'string',
      statusDesc: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayResponseBodyDataResultMaintenancePeriod extends $tea.Model {
  endTime?: string;
  startTime?: string;
  timeZone?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
      timeZone: 'TimeZone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'string',
      timeZone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayResponseBodyDataResultSlb extends $tea.Model {
  /**
   * @remarks
   * The mode of the SLB instance.
   * 
   * @example
   * UserHost
   */
  gatewaySlbMode?: string;
  /**
   * @remarks
   * The state of the SLB instance.
   * 
   * @example
   * Ready
   */
  gatewaySlbStatus?: string;
  /**
   * @remarks
   * The ID of the SLB instance.
   * 
   * @example
   * lb-bp1ut8asdfgucjk****
   */
  slbId?: string;
  /**
   * @remarks
   * The IP address of the SLB instance.
   * 
   * @example
   * 153.12.XX.XX
   */
  slbIp?: string;
  /**
   * @remarks
   * The port number of the SLB instance.
   * 
   * @example
   * 80
   */
  slbPort?: string;
  /**
   * @remarks
   * The specifications of the SLB instance.
   * 
   * @example
   * slb.s2.small
   */
  slbSpec?: string;
  /**
   * @remarks
   * The description of the state.
   * 
   * @example
   * Creating
   */
  statusDesc?: string;
  /**
   * @remarks
   * The network type. Valid values:
   * 
   * *   PUB_NET
   * *   PRIVATE_NET
   * 
   * @example
   * PUB_NET
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      gatewaySlbMode: 'GatewaySlbMode',
      gatewaySlbStatus: 'GatewaySlbStatus',
      slbId: 'SlbId',
      slbIp: 'SlbIp',
      slbPort: 'SlbPort',
      slbSpec: 'SlbSpec',
      statusDesc: 'StatusDesc',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gatewaySlbMode: 'string',
      gatewaySlbStatus: 'string',
      slbId: 'string',
      slbIp: 'string',
      slbPort: 'string',
      slbSpec: 'string',
      statusDesc: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayResponseBodyDataResult extends $tea.Model {
  /**
   * @remarks
   * Indicates whether Application High Availability Service (AHAS) is activated.
   * 
   * @example
   * false
   */
  ahasOn?: boolean;
  /**
   * @remarks
   * The version of the application.
   * 
   * @example
   * 1.0.1.0
   */
  appVersion?: string;
  /**
   * @remarks
   * Indicates whether Application Real-Time Monitoring Service (ARMS) is activated.
   * 
   * @example
   * false
   */
  armsOn?: boolean;
  /**
   * @remarks
   * The billing method.
   * 
   * @example
   * POSTPAY
   */
  chargeType?: string;
  /**
   * @remarks
   * The current version of the gateway.
   * 
   * @example
   * 0.1.0-mse-gw
   */
  currentVersion?: string;
  /**
   * @remarks
   * Indicates whether auto scale-out is enabled.
   * 
   * @example
   * true
   */
  elastic?: boolean;
  /**
   * @remarks
   * The ID of the elastic gateway. This parameter is returned if auto scale-out is used.
   * 
   * @example
   * mse_ingresselastic_public_cn-uqm3d0*****
   */
  elasticInstanceId?: string;
  /**
   * @remarks
   * The auto scale-out policy.
   */
  elasticPolicy?: ListGatewayResponseBodyDataResultElasticPolicy;
  /**
   * @remarks
   * The number of replicas that are automatically scaled out.
   * 
   * @example
   * 2
   */
  elasticReplica?: number;
  /**
   * @remarks
   * The type of auto scale-out. Valid value:
   * 
   * *   CronHPA: scale-out by time
   * 
   * @example
   * CronHPA
   */
  elasticType?: string;
  /**
   * @remarks
   * The time when the instance expires.
   * 
   * @example
   * 4792060800000
   */
  endDate?: string;
  /**
   * @remarks
   * The gateway type.
   * 
   * @example
   * Ingress
   */
  gatewayType?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-5017305290e14cebb8ce5cb6a4****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The version of the gateway.
   * 
   * @example
   * 1.2.9
   */
  gatewayVersion?: string;
  /**
   * @remarks
   * The time when the gateway was created.
   * 
   * @example
   * 2021-09-13 19:24:23
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the gateway was modified.
   * 
   * @example
   * 2021-09-13 19:24:23
   */
  gmtModified?: string;
  /**
   * @remarks
   * The gateway ID.
   * 
   * @example
   * 153
   */
  id?: number;
  /**
   * @remarks
   * The configurations.
   */
  initConfig?: ListGatewayResponseBodyDataResultInitConfig;
  /**
   * @remarks
   * The instance ID.
   * 
   * @example
   * mse_ingresspost-cn-0jbvrcex****
   */
  instanceId?: string;
  /**
   * @remarks
   * The details of the Internet-facing SLB instances.
   */
  internetSlb?: ListGatewayResponseBodyDataResultInternetSlb[];
  /**
   * @remarks
   * The latest version of the gateway.
   * 
   * @example
   * 0.1.0-mse-gw
   */
  latestVersion?: string;
  maintenancePeriod?: ListGatewayResponseBodyDataResultMaintenancePeriod;
  /**
   * @remarks
   * The resource tag.
   * 
   * @example
   * {"tagKey":"tagValue"}
   */
  mseTag?: string;
  mseVersion?: string;
  /**
   * @remarks
   * Indicates whether the instance was forcefully upgraded.
   * 
   * @example
   * false
   */
  mustUpgrade?: boolean;
  /**
   * @remarks
   * The gateway name.
   * 
   * @example
   * tesa-test
   */
  name?: string;
  /**
   * @remarks
   * The user information.
   * 
   * @example
   * 18278117654342
   */
  primaryUser?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The number of replicas.
   * 
   * @example
   * 2
   */
  replica?: number;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-97hg87vi****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * Indicates whether rollbacks are allowed.
   * 
   * @example
   * false
   */
  rollBack?: boolean;
  /**
   * @remarks
   * The details of Server Load Balancer (SLB) instances.
   */
  slb?: ListGatewayResponseBodyDataResultSlb[];
  /**
   * @remarks
   * The specifications of the gateway.
   * 
   * @example
   * MSE_GTW_1_2_200_c
   */
  spec?: string;
  /**
   * @remarks
   * The gateway state. Valid values:
   * 
   * *   0: The gateway is being created.
   * *   1: The gateway failed to be created.
   * *   2: The gateway is running.
   * *   3: The gateway is being changed.
   * *   4: The gateway is scaling in.
   * *   6: The gateway is scaling out.
   * *   8: The gateway is being deleted.
   * *   9: The gateway is suspended and is to be released.
   * *   10: The gateway is restarting.
   * *   11: The gateway is being rebuilt.
   * *   12: The gateway is being upgraded.
   * *   13: The gateway failed to be upgraded.
   * 
   * @example
   * 2
   */
  status?: number;
  /**
   * @remarks
   * The description of the gateway state.
   * 
   * @example
   * Restarting
   */
  statusDesc?: string;
  /**
   * @remarks
   * Indicates whether WebAssembly (Wasm) is supported.
   * 
   * @example
   * true
   */
  supportWasm?: boolean;
  /**
   * @remarks
   * The tag.
   * 
   * @example
   * test
   */
  tag?: string;
  /**
   * @remarks
   * The total number of replicas, including the number of replicas that are automatically scaled out.
   * 
   * @example
   * 4
   */
  totalReplica?: number;
  /**
   * @remarks
   * Indicates whether the instance was upgraded.
   * 
   * @example
   * false
   */
  upgrade?: boolean;
  /**
   * @remarks
   * The ID of the virtual private cloud (VPC) to which the gateway belongs.
   * 
   * @example
   * vpc-uf6heojei217tv14*****
   */
  vpcId?: string;
  /**
   * @remarks
   * The ID of the secondary vSwitch.
   * 
   * @example
   * vsw-bpbrveck45nf****
   */
  vswitch2?: string;
  static names(): { [key: string]: string } {
    return {
      ahasOn: 'AhasOn',
      appVersion: 'AppVersion',
      armsOn: 'ArmsOn',
      chargeType: 'ChargeType',
      currentVersion: 'CurrentVersion',
      elastic: 'Elastic',
      elasticInstanceId: 'ElasticInstanceId',
      elasticPolicy: 'ElasticPolicy',
      elasticReplica: 'ElasticReplica',
      elasticType: 'ElasticType',
      endDate: 'EndDate',
      gatewayType: 'GatewayType',
      gatewayUniqueId: 'GatewayUniqueId',
      gatewayVersion: 'GatewayVersion',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      initConfig: 'InitConfig',
      instanceId: 'InstanceId',
      internetSlb: 'InternetSlb',
      latestVersion: 'LatestVersion',
      maintenancePeriod: 'MaintenancePeriod',
      mseTag: 'MseTag',
      mseVersion: 'MseVersion',
      mustUpgrade: 'MustUpgrade',
      name: 'Name',
      primaryUser: 'PrimaryUser',
      region: 'Region',
      replica: 'Replica',
      resourceGroupId: 'ResourceGroupId',
      rollBack: 'RollBack',
      slb: 'Slb',
      spec: 'Spec',
      status: 'Status',
      statusDesc: 'StatusDesc',
      supportWasm: 'SupportWasm',
      tag: 'Tag',
      totalReplica: 'TotalReplica',
      upgrade: 'Upgrade',
      vpcId: 'VpcId',
      vswitch2: 'Vswitch2',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ahasOn: 'boolean',
      appVersion: 'string',
      armsOn: 'boolean',
      chargeType: 'string',
      currentVersion: 'string',
      elastic: 'boolean',
      elasticInstanceId: 'string',
      elasticPolicy: ListGatewayResponseBodyDataResultElasticPolicy,
      elasticReplica: 'number',
      elasticType: 'string',
      endDate: 'string',
      gatewayType: 'string',
      gatewayUniqueId: 'string',
      gatewayVersion: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      initConfig: ListGatewayResponseBodyDataResultInitConfig,
      instanceId: 'string',
      internetSlb: { 'type': 'array', 'itemType': ListGatewayResponseBodyDataResultInternetSlb },
      latestVersion: 'string',
      maintenancePeriod: ListGatewayResponseBodyDataResultMaintenancePeriod,
      mseTag: 'string',
      mseVersion: 'string',
      mustUpgrade: 'boolean',
      name: 'string',
      primaryUser: 'string',
      region: 'string',
      replica: 'number',
      resourceGroupId: 'string',
      rollBack: 'boolean',
      slb: { 'type': 'array', 'itemType': ListGatewayResponseBodyDataResultSlb },
      spec: 'string',
      status: 'number',
      statusDesc: 'string',
      supportWasm: 'boolean',
      tag: 'string',
      totalReplica: 'number',
      upgrade: 'boolean',
      vpcId: 'string',
      vswitch2: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The data returned.
   */
  result?: ListGatewayResponseBodyDataResult[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 9
   */
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      result: 'Result',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      result: { 'type': 'array', 'itemType': ListGatewayResponseBodyDataResult },
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayAuthConsumerResponseBodyDataResult extends $tea.Model {
  /**
   * @remarks
   * The status of the consumer. Valid values:
   * 
   * *   true: enabled
   * *   false: disabled
   * 
   * @example
   * true
   */
  consumerStatus?: boolean;
  /**
   * @remarks
   * The description of the consumer.
   * 
   * @example
   * Description
   */
  description?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-5017305290e14centbrveca****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2021-09-13 19:24:23
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The modification time.
   * 
   * @example
   * 2022-01-07 18:07:57
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the consumer.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The name of the consumer.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The creator.
   * 
   * @example
   * 123
   */
  primaryUser?: string;
  /**
   * @remarks
   * The authentication type. Valid values:
   * 
   * *   JWT
   * 
   * @example
   * JWT
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      consumerStatus: 'ConsumerStatus',
      description: 'Description',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      name: 'Name',
      primaryUser: 'PrimaryUser',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerStatus: 'boolean',
      description: 'string',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      name: 'string',
      primaryUser: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayAuthConsumerResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The returned information.
   */
  result?: ListGatewayAuthConsumerResponseBodyDataResult[];
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 9
   */
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      result: 'Result',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      result: { 'type': 'array', 'itemType': ListGatewayAuthConsumerResponseBodyDataResult },
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayAuthConsumerResourceResponseBodyDataResult extends $tea.Model {
  /**
   * @remarks
   * The ID of the consumer.
   * 
   * @example
   * 2
   */
  consumerId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-5017305290e14centbrveca****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2022-01-07 18:07:57
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The modification time.
   * 
   * @example
   * 2022-01-07 18:07:57
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the authorized resource for the consumer.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The resource authorization status. Valid values:
   * 
   * *   true: enabled
   * *   false: disabled
   * 
   * @example
   * true
   */
  resourceStatus?: boolean;
  /**
   * @remarks
   * The ID of the route.
   * 
   * @example
   * 3091
   */
  routeId?: number;
  /**
   * @remarks
   * The name of the route.
   * 
   * @example
   * test
   */
  routeName?: string;
  static names(): { [key: string]: string } {
    return {
      consumerId: 'ConsumerId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      resourceStatus: 'ResourceStatus',
      routeId: 'RouteId',
      routeName: 'RouteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerId: 'number',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      resourceStatus: 'boolean',
      routeId: 'number',
      routeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayAuthConsumerResourceResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The data structure.
   */
  result?: ListGatewayAuthConsumerResourceResponseBodyDataResult[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 11
   */
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      result: 'Result',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      result: { 'type': 'array', 'itemType': ListGatewayAuthConsumerResourceResponseBodyDataResult },
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayCircuitBreakerRuleResponseBodyDataResult extends $tea.Model {
  /**
   * @example
   * 0
   */
  behaviorType?: number;
  /**
   * @example
   * 0
   */
  bodyEncoding?: number;
  /**
   * @example
   * 0
   */
  enable?: number;
  /**
   * @example
   * 11919
   */
  gatewayId?: number;
  /**
   * @example
   * gw-5017305290e14centbrveca****
   */
  gatewayUniqueId?: string;
  /**
   * @example
   * 467
   */
  id?: number;
  idList?: number[];
  /**
   * @example
   * 0
   */
  limitMode?: number;
  /**
   * @example
   * 14
   */
  maxAllowedMs?: number;
  /**
   * @example
   * 10
   */
  minRequestAmount?: number;
  /**
   * @example
   * 12
   */
  recoveryTimeoutSec?: number;
  /**
   * @example
   * key=value
   */
  responseAdditionalHeaders?: string;
  /**
   * @example
   * text
   */
  responseContentBody?: string;
  /**
   * @example
   * www.******.com
   */
  responseRedirectUrl?: string;
  /**
   * @example
   * 204
   */
  responseStatusCode?: number;
  /**
   * @example
   * 3091
   */
  routeId?: number;
  /**
   * @example
   * routeName
   */
  routeName?: string;
  /**
   * @example
   * 11
   */
  statDurationSec?: number;
  /**
   * @example
   * 0
   */
  strategy?: number;
  /**
   * @example
   * 10
   */
  triggerRatio?: number;
  static names(): { [key: string]: string } {
    return {
      behaviorType: 'BehaviorType',
      bodyEncoding: 'BodyEncoding',
      enable: 'Enable',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      idList: 'IdList',
      limitMode: 'LimitMode',
      maxAllowedMs: 'MaxAllowedMs',
      minRequestAmount: 'MinRequestAmount',
      recoveryTimeoutSec: 'RecoveryTimeoutSec',
      responseAdditionalHeaders: 'ResponseAdditionalHeaders',
      responseContentBody: 'ResponseContentBody',
      responseRedirectUrl: 'ResponseRedirectUrl',
      responseStatusCode: 'ResponseStatusCode',
      routeId: 'RouteId',
      routeName: 'RouteName',
      statDurationSec: 'StatDurationSec',
      strategy: 'Strategy',
      triggerRatio: 'TriggerRatio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      behaviorType: 'number',
      bodyEncoding: 'number',
      enable: 'number',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
      idList: { 'type': 'array', 'itemType': 'number' },
      limitMode: 'number',
      maxAllowedMs: 'number',
      minRequestAmount: 'number',
      recoveryTimeoutSec: 'number',
      responseAdditionalHeaders: 'string',
      responseContentBody: 'string',
      responseRedirectUrl: 'string',
      responseStatusCode: 'number',
      routeId: 'number',
      routeName: 'string',
      statDurationSec: 'number',
      strategy: 'number',
      triggerRatio: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayCircuitBreakerRuleResponseBodyDataResults extends $tea.Model {
  /**
   * @example
   * 0
   */
  behaviorType?: number;
  /**
   * @example
   * 0
   */
  bodyEncoding?: number;
  /**
   * @example
   * 0
   */
  enable?: number;
  /**
   * @example
   * 11919
   */
  gatewayId?: number;
  /**
   * @example
   * gw-1ee34548c68f4778a25c05abd657****
   */
  gatewayUniqueId?: string;
  /**
   * @example
   * 467
   */
  id?: number;
  idList?: number[];
  /**
   * @example
   * 0
   */
  limitMode?: number;
  /**
   * @example
   * 10
   */
  maxAllowedMs?: number;
  /**
   * @example
   * 10
   */
  minRequestAmount?: number;
  /**
   * @example
   * 12
   */
  recoveryTimeoutSec?: number;
  /**
   * @example
   * key=value
   */
  responseAdditionalHeaders?: string;
  /**
   * @example
   * text
   */
  responseContentBody?: string;
  /**
   * @example
   * www.******.com
   */
  responseRedirectUrl?: string;
  /**
   * @example
   * 204
   */
  responseStatusCode?: number;
  /**
   * @example
   * 3450
   */
  routeId?: number;
  /**
   * @example
   * routeName
   */
  routeName?: string;
  /**
   * @example
   * 11
   */
  statDurationSec?: number;
  /**
   * @example
   * 0
   */
  strategy?: number;
  /**
   * @example
   * 10
   */
  triggerRatio?: number;
  static names(): { [key: string]: string } {
    return {
      behaviorType: 'BehaviorType',
      bodyEncoding: 'BodyEncoding',
      enable: 'Enable',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      idList: 'IdList',
      limitMode: 'LimitMode',
      maxAllowedMs: 'MaxAllowedMs',
      minRequestAmount: 'MinRequestAmount',
      recoveryTimeoutSec: 'RecoveryTimeoutSec',
      responseAdditionalHeaders: 'ResponseAdditionalHeaders',
      responseContentBody: 'ResponseContentBody',
      responseRedirectUrl: 'ResponseRedirectUrl',
      responseStatusCode: 'ResponseStatusCode',
      routeId: 'RouteId',
      routeName: 'RouteName',
      statDurationSec: 'StatDurationSec',
      strategy: 'Strategy',
      triggerRatio: 'TriggerRatio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      behaviorType: 'number',
      bodyEncoding: 'number',
      enable: 'number',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
      idList: { 'type': 'array', 'itemType': 'number' },
      limitMode: 'number',
      maxAllowedMs: 'number',
      minRequestAmount: 'number',
      recoveryTimeoutSec: 'number',
      responseAdditionalHeaders: 'string',
      responseContentBody: 'string',
      responseRedirectUrl: 'string',
      responseStatusCode: 'number',
      routeId: 'number',
      routeName: 'string',
      statDurationSec: 'number',
      strategy: 'number',
      triggerRatio: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayCircuitBreakerRuleResponseBodyData extends $tea.Model {
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 100
   */
  pageSize?: number;
  result?: ListGatewayCircuitBreakerRuleResponseBodyDataResult[];
  results?: ListGatewayCircuitBreakerRuleResponseBodyDataResults[];
  /**
   * @example
   * 11
   */
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      result: 'Result',
      results: 'Results',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      result: { 'type': 'array', 'itemType': ListGatewayCircuitBreakerRuleResponseBodyDataResult },
      results: { 'type': 'array', 'itemType': ListGatewayCircuitBreakerRuleResponseBodyDataResults },
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayDomainResponseBodyDataComment extends $tea.Model {
  /**
   * @remarks
   * The route status.
   * 
   * @example
   * Error
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayDomainResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The time when the certificate expires.
   * 
   * @example
   * 2031-03-30 02:35:12
   */
  certBeforeDate?: string;
  /**
   * @remarks
   * The certificate ID.
   * 
   * @example
   * 3452-cn-hangzhou
   */
  certIdentifier?: string;
  /**
   * @remarks
   * The route comment. This parameter is returned only in ingress scenarios.
   */
  comment?: ListGatewayDomainResponseBodyDataComment;
  /**
   * @remarks
   * The gateway ID.
   * 
   * @example
   * 12
   */
  gatewayId?: number;
  /**
   * @remarks
   * The time when the domain name was created.
   * 
   * @example
   * 2031-03-30 02:35:12
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the domain name was updated.
   * 
   * @example
   * 2031-03-30 02:35:12
   */
  gmtModified?: string;
  /**
   * @remarks
   * Indicates whether `HTTP/2` is enabled.
   * 
   * *   `open`: `HTTP/2` is enabled.
   * *   `close`: `HTTP/2` is disabled.
   * *   `globalConfig`: Global configurations are used.
   * 
   * @example
   * close
   */
  http2?: string;
  /**
   * @remarks
   * The ID of the domain name.
   * 
   * @example
   * 243
   */
  id?: number;
  /**
   * @remarks
   * Indicates whether HTTPS is forcefully used.
   * 
   * @example
   * true
   */
  mustHttps?: boolean;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * test.com
   */
  name?: string;
  /**
   * @remarks
   * The protocol.
   * 
   * @example
   * HTTP
   */
  protocol?: string;
  /**
   * @remarks
   * The state of the domain name. Valid values:
   * 
   * *   0: unpublished
   * *   2: publishing
   * *   3: published
   * *   4: editing
   * *   5: unpublishing
   * *   6: unavailable
   * 
   * @example
   * 3
   */
  status?: number;
  /**
   * @remarks
   * The maximum version of Transport Layer Security (TLS).
   * 
   * @example
   * TLS 1.3
   */
  tlsMax?: string;
  /**
   * @remarks
   * The minimum version of TLS.
   * 
   * @example
   * TLS 1.0
   */
  tlsMin?: string;
  /**
   * @remarks
   * The type of the domain name source. Valid values:
   * 
   * *   Op: console
   * *   Ingress: MSE Ingress
   * 
   * @example
   * Op
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      certBeforeDate: 'CertBeforeDate',
      certIdentifier: 'CertIdentifier',
      comment: 'Comment',
      gatewayId: 'GatewayId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      http2: 'Http2',
      id: 'Id',
      mustHttps: 'MustHttps',
      name: 'Name',
      protocol: 'Protocol',
      status: 'Status',
      tlsMax: 'TlsMax',
      tlsMin: 'TlsMin',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certBeforeDate: 'string',
      certIdentifier: 'string',
      comment: ListGatewayDomainResponseBodyDataComment,
      gatewayId: 'number',
      gmtCreate: 'string',
      gmtModified: 'string',
      http2: 'string',
      id: 'number',
      mustHttps: 'boolean',
      name: 'string',
      protocol: 'string',
      status: 'number',
      tlsMax: 'string',
      tlsMin: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayFlowRuleResponseBodyDataResult extends $tea.Model {
  /**
   * @example
   * 0
   */
  behaviorType?: number;
  /**
   * @example
   * 0
   */
  bodyEncoding?: number;
  /**
   * @example
   * 0
   */
  enable?: number;
  /**
   * @example
   * 14407
   */
  gatewayId?: number;
  /**
   * @example
   * gw-e2d226bba4b2445c9e29fa7f8216****
   */
  gatewayUniqueId?: string;
  /**
   * @example
   * 549
   */
  id?: number;
  /**
   * @example
   * text
   */
  responseContentBody?: string;
  /**
   * @example
   * www.******.com
   */
  responseRedirectUrl?: string;
  /**
   * @example
   * 429
   */
  responseStatusCode?: number;
  /**
   * @example
   * 48811
   */
  routeId?: number;
  /**
   * @example
   * routeA
   */
  routeName?: string;
  /**
   * @example
   * 10
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      behaviorType: 'BehaviorType',
      bodyEncoding: 'BodyEncoding',
      enable: 'Enable',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      responseContentBody: 'ResponseContentBody',
      responseRedirectUrl: 'ResponseRedirectUrl',
      responseStatusCode: 'ResponseStatusCode',
      routeId: 'RouteId',
      routeName: 'RouteName',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      behaviorType: 'number',
      bodyEncoding: 'number',
      enable: 'number',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
      responseContentBody: 'string',
      responseRedirectUrl: 'string',
      responseStatusCode: 'number',
      routeId: 'number',
      routeName: 'string',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayFlowRuleResponseBodyDataResults extends $tea.Model {
  /**
   * @example
   * 0
   */
  behaviorType?: number;
  /**
   * @example
   * 0
   */
  bodyEncoding?: number;
  /**
   * @example
   * 0
   */
  enable?: number;
  /**
   * @example
   * 14407
   */
  gatewayId?: number;
  /**
   * @example
   * gw-e2d226bba4b2445c9e29fa7f8216****
   */
  gatewayUniqueId?: string;
  /**
   * @example
   * 549
   */
  id?: number;
  idList?: number[];
  /**
   * @example
   * 0
   */
  limitMode?: number;
  /**
   * @example
   * key=value
   */
  responseAdditionalHeaders?: string;
  /**
   * @example
   * text
   */
  responseContentBody?: string;
  /**
   * @example
   * www.******.com
   */
  responseRedirectUrl?: string;
  /**
   * @example
   * 429
   */
  responseStatusCode?: number;
  /**
   * @example
   * 48811
   */
  routeId?: number;
  /**
   * @example
   * routeA
   */
  routeName?: string;
  /**
   * @example
   * 10
   */
  statDurationMs?: number;
  /**
   * @example
   * 10
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      behaviorType: 'BehaviorType',
      bodyEncoding: 'BodyEncoding',
      enable: 'Enable',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      idList: 'IdList',
      limitMode: 'LimitMode',
      responseAdditionalHeaders: 'ResponseAdditionalHeaders',
      responseContentBody: 'ResponseContentBody',
      responseRedirectUrl: 'ResponseRedirectUrl',
      responseStatusCode: 'ResponseStatusCode',
      routeId: 'RouteId',
      routeName: 'RouteName',
      statDurationMs: 'StatDurationMs',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      behaviorType: 'number',
      bodyEncoding: 'number',
      enable: 'number',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
      idList: { 'type': 'array', 'itemType': 'number' },
      limitMode: 'number',
      responseAdditionalHeaders: 'string',
      responseContentBody: 'string',
      responseRedirectUrl: 'string',
      responseStatusCode: 'number',
      routeId: 'number',
      routeName: 'string',
      statDurationMs: 'number',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayFlowRuleResponseBodyData extends $tea.Model {
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 100
   */
  pageSize?: number;
  result?: ListGatewayFlowRuleResponseBodyDataResult[];
  results?: ListGatewayFlowRuleResponseBodyDataResults[];
  /**
   * @example
   * 1
   */
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      result: 'Result',
      results: 'Results',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      result: { 'type': 'array', 'itemType': ListGatewayFlowRuleResponseBodyDataResult },
      results: { 'type': 'array', 'itemType': ListGatewayFlowRuleResponseBodyDataResults },
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayIsolationRuleResponseBodyDataResult extends $tea.Model {
  /**
   * @example
   * 0
   */
  behaviorType?: number;
  /**
   * @example
   * 0
   */
  bodyEncoding?: number;
  /**
   * @example
   * 0
   */
  enable?: number;
  /**
   * @example
   * 14407
   */
  gatewayId?: number;
  /**
   * @example
   * gw-e2d226bba4b2445c9e29fa7f8216****
   */
  gatewayUniqueId?: string;
  /**
   * @example
   * 358
   */
  id?: number;
  idList?: number[];
  /**
   * @example
   * 0
   */
  limitMode?: number;
  /**
   * @example
   * 100
   */
  maxConcurrency?: number;
  /**
   * @example
   * key:value
   */
  responseAdditionalHeaders?: string;
  /**
   * @example
   * text
   */
  responseContentBody?: string;
  /**
   * @example
   * www.******.com
   */
  responseRedirectUrl?: string;
  /**
   * @example
   * 429
   */
  responseStatusCode?: number;
  /**
   * @example
   * 52853
   */
  routeId?: number;
  /**
   * @example
   * routeName
   */
  routeName?: string;
  static names(): { [key: string]: string } {
    return {
      behaviorType: 'BehaviorType',
      bodyEncoding: 'BodyEncoding',
      enable: 'Enable',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      idList: 'IdList',
      limitMode: 'LimitMode',
      maxConcurrency: 'MaxConcurrency',
      responseAdditionalHeaders: 'ResponseAdditionalHeaders',
      responseContentBody: 'ResponseContentBody',
      responseRedirectUrl: 'ResponseRedirectUrl',
      responseStatusCode: 'ResponseStatusCode',
      routeId: 'RouteId',
      routeName: 'RouteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      behaviorType: 'number',
      bodyEncoding: 'number',
      enable: 'number',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
      idList: { 'type': 'array', 'itemType': 'number' },
      limitMode: 'number',
      maxConcurrency: 'number',
      responseAdditionalHeaders: 'string',
      responseContentBody: 'string',
      responseRedirectUrl: 'string',
      responseStatusCode: 'number',
      routeId: 'number',
      routeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayIsolationRuleResponseBodyDataResults extends $tea.Model {
  /**
   * @example
   * 0
   */
  behaviorType?: number;
  /**
   * @example
   * 0
   */
  bodyEncoding?: number;
  /**
   * @example
   * 0
   */
  enable?: number;
  /**
   * @example
   * 14407
   */
  gatewayId?: number;
  /**
   * @example
   * gw-e2d226bba4b2445c9e29fa7f8216****
   */
  gatewayUniqueId?: string;
  /**
   * @example
   * 358
   */
  id?: number;
  idList?: number[];
  /**
   * @example
   * 1
   */
  limitMode?: number;
  /**
   * @example
   * 100
   */
  maxConcurrency?: number;
  /**
   * @example
   * key=value
   */
  responseAdditionalHeaders?: string;
  /**
   * @example
   * text
   */
  responseContentBody?: string;
  /**
   * @example
   * www.******.com
   */
  responseRedirectUrl?: string;
  /**
   * @example
   * 429
   */
  responseStatusCode?: number;
  /**
   * @example
   * 52853
   */
  routeId?: number;
  /**
   * @example
   * routeName
   */
  routeName?: string;
  static names(): { [key: string]: string } {
    return {
      behaviorType: 'BehaviorType',
      bodyEncoding: 'BodyEncoding',
      enable: 'Enable',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      idList: 'IdList',
      limitMode: 'LimitMode',
      maxConcurrency: 'MaxConcurrency',
      responseAdditionalHeaders: 'ResponseAdditionalHeaders',
      responseContentBody: 'ResponseContentBody',
      responseRedirectUrl: 'ResponseRedirectUrl',
      responseStatusCode: 'ResponseStatusCode',
      routeId: 'RouteId',
      routeName: 'RouteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      behaviorType: 'number',
      bodyEncoding: 'number',
      enable: 'number',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
      idList: { 'type': 'array', 'itemType': 'number' },
      limitMode: 'number',
      maxConcurrency: 'number',
      responseAdditionalHeaders: 'string',
      responseContentBody: 'string',
      responseRedirectUrl: 'string',
      responseStatusCode: 'number',
      routeId: 'number',
      routeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayIsolationRuleResponseBodyData extends $tea.Model {
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 100
   */
  pageSize?: number;
  result?: ListGatewayIsolationRuleResponseBodyDataResult[];
  results?: ListGatewayIsolationRuleResponseBodyDataResults[];
  /**
   * @example
   * 1
   */
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      result: 'Result',
      results: 'Results',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      result: { 'type': 'array', 'itemType': ListGatewayIsolationRuleResponseBodyDataResult },
      results: { 'type': 'array', 'itemType': ListGatewayIsolationRuleResponseBodyDataResults },
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteRequestFilterParams extends $tea.Model {
  /**
   * @remarks
   * The default service ID.
   * 
   * @example
   * 1
   * 
   * @deprecated
   */
  defaultServiceId?: number;
  /**
   * @remarks
   * The domain ID.
   * 
   * @example
   * 284
   */
  domainId?: number;
  /**
   * @remarks
   * The associated domain name.
   * 
   * @example
   * *.alites.com
   */
  domainName?: string;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 81
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * gw-30a0106924c94bca8712ec4e79fc5acc
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The name of the gateway.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @example
   * /test
   */
  path?: string;
  /**
   * @remarks
   * The order.
   * 
   * @example
   * 1
   */
  routeOrder?: number;
  /**
   * @remarks
   * The status.
   * 
   * @example
   * 1
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      defaultServiceId: 'DefaultServiceId',
      domainId: 'DomainId',
      domainName: 'DomainName',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      name: 'Name',
      path: 'Path',
      routeOrder: 'RouteOrder',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultServiceId: 'number',
      domainId: 'number',
      domainName: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      name: 'string',
      path: 'string',
      routeOrder: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteResponseBodyDataResultComment extends $tea.Model {
  /**
   * @remarks
   * The status.
   * 
   * @example
   * error
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteResponseBodyDataResultDirectResponse extends $tea.Model {
  /**
   * @remarks
   * The return value for service mocking.
   * 
   * @example
   * hello
   */
  body?: string;
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  static names(): { [key: string]: string } {
    return {
      body: 'Body',
      code: 'Code',
    };
  }

  static types(): { [key: string]: any } {
    return {
      body: 'string',
      code: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteResponseBodyDataResultFallbackServices extends $tea.Model {
  /**
   * @remarks
   * The type of the protocol.
   * 
   * @example
   * DUBBO
   */
  agreementType?: string;
  /**
   * @remarks
   * The name of the group to which the service belongs.
   * 
   * @example
   * test
   */
  groupName?: string;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * name
   */
  name?: string;
  /**
   * @remarks
   * The namespace to which the service belongs.
   * 
   * @example
   * Namespace
   */
  namespace?: string;
  /**
   * @remarks
   * The weight in the form of a percentage value.
   * 
   * @example
   * 100
   */
  percent?: number;
  /**
   * @remarks
   * The ID of the service.
   * 
   * @example
   * 353
   */
  serviceId?: number;
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * service name
   */
  serviceName?: string;
  /**
   * @remarks
   * The service port number.
   * 
   * @example
   * 8848
   */
  servicePort?: number;
  /**
   * @remarks
   * The source type.
   * 
   * @example
   * MSE
   */
  sourceType?: string;
  /**
   * @remarks
   * The version of the service.
   * 
   * @example
   * v1
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      agreementType: 'AgreementType',
      groupName: 'GroupName',
      name: 'Name',
      namespace: 'Namespace',
      percent: 'Percent',
      serviceId: 'ServiceId',
      serviceName: 'ServiceName',
      servicePort: 'ServicePort',
      sourceType: 'SourceType',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      agreementType: 'string',
      groupName: 'string',
      name: 'string',
      namespace: 'string',
      percent: 'number',
      serviceId: 'number',
      serviceName: 'string',
      servicePort: 'number',
      sourceType: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteResponseBodyDataResultRedirect extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The hostname to be redirected to.
   * 
   * @example
   * test.com
   */
  host?: string;
  /**
   * @remarks
   * The path.
   * 
   * @example
   * /test
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      host: 'Host',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      host: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates extends $tea.Model {
  /**
   * @remarks
   * The header key.
   * 
   * @example
   * userid
   */
  key?: string;
  /**
   * @remarks
   * The matching type.
   * 
   * @example
   * PRE
   */
  type?: string;
  /**
   * @remarks
   * The value.
   * 
   * @example
   * test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates extends $tea.Model {
  /**
   * @remarks
   * Indicates whether case sensitivity is ignored.
   * 
   * @example
   * true
   */
  ignoreCase?: boolean;
  /**
   * @remarks
   * The path of the node.
   * 
   * @example
   * /getIp
   */
  path?: string;
  /**
   * @remarks
   * The matching type.
   * 
   * @example
   * PRE
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      ignoreCase: 'IgnoreCase',
      path: 'Path',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ignoreCase: 'boolean',
      path: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates extends $tea.Model {
  /**
   * @remarks
   * The key.
   * 
   * @example
   * userid
   */
  key?: string;
  /**
   * @remarks
   * The matching type.
   * 
   * @example
   * PRE
   */
  type?: string;
  /**
   * @remarks
   * The value.
   * 
   * @example
   * test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteResponseBodyDataResultRoutePredicates extends $tea.Model {
  /**
   * @remarks
   * The headers used for route matching.
   */
  headerPredicates?: ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates[];
  /**
   * @remarks
   * The HTTP methods used for route matching.
   */
  methodPredicates?: string[];
  /**
   * @remarks
   * The path used for route matching.
   */
  pathPredicates?: ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates;
  /**
   * @remarks
   * The parameters used for route matching.
   */
  queryPredicates?: ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates[];
  static names(): { [key: string]: string } {
    return {
      headerPredicates: 'HeaderPredicates',
      methodPredicates: 'MethodPredicates',
      pathPredicates: 'PathPredicates',
      queryPredicates: 'QueryPredicates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headerPredicates: { 'type': 'array', 'itemType': ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates },
      methodPredicates: { 'type': 'array', 'itemType': 'string' },
      pathPredicates: ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates,
      queryPredicates: { 'type': 'array', 'itemType': ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList extends $tea.Model {
  /**
   * @remarks
   * The key extracted from the input parameter.
   * 
   * @example
   * name
   */
  extractKey?: string;
  /**
   * @remarks
   * The position of the input parameter.
   * 
   * > Valid values:
   * 
   * *   `ALL_QUERY_PARAMETER`: request parameter
   * 
   * *   `ALL_HEADER`: request header
   * 
   * *   `ALL_PATH`: request path
   * 
   * *   `ALL_BODY`: request body
   * 
   * @example
   * ALL_QUERY_PARAMETER
   */
  extractKeySpec?: string;
  /**
   * @remarks
   * The type of the backend service parameter.
   * 
   * @example
   * java.lang.String
   */
  mappingType?: string;
  static names(): { [key: string]: string } {
    return {
      extractKey: 'ExtractKey',
      extractKeySpec: 'ExtractKeySpec',
      mappingType: 'MappingType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extractKey: 'string',
      extractKeySpec: 'string',
      mappingType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList extends $tea.Model {
  /**
   * @remarks
   * The method name of the Dubbo service.
   * 
   * @example
   * sayHello
   */
  dubboMothedName?: string;
  /**
   * @remarks
   * The HTTP method.
   * 
   * > Valid values:
   * 
   * *   ALL_GET
   * 
   * *   ALL_POST
   * 
   * *   ALL_PUT
   * 
   * *   ALL_DELETE
   * 
   * *   ALL_PATCH
   * 
   * @example
   * ALL_GET
   */
  httpMothed?: string;
  /**
   * @remarks
   * The path used for method matching.
   * 
   * @example
   * /mytestzbk/sayhello
   */
  mothedpath?: string;
  /**
   * @remarks
   * The information about parameter mappings.
   */
  paramMapsList?: ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList[];
  /**
   * @remarks
   * The pass-through type of the header.
   * 
   * > Valid values:
   * 
   * *   PASS_ALL: All headers are passed through.
   * 
   * *   PASS_NOT: All headers are not passed through.
   * 
   * *   PASS_ASSIGN: Specified headers are passed through.
   * 
   * @example
   * PASS_NOT
   */
  passThroughAllHeaders?: string;
  /**
   * @remarks
   * The list of headers to be passed through.
   */
  passThroughList?: string[];
  static names(): { [key: string]: string } {
    return {
      dubboMothedName: 'DubboMothedName',
      httpMothed: 'HttpMothed',
      mothedpath: 'Mothedpath',
      paramMapsList: 'ParamMapsList',
      passThroughAllHeaders: 'PassThroughAllHeaders',
      passThroughList: 'PassThroughList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dubboMothedName: 'string',
      httpMothed: 'string',
      mothedpath: 'string',
      paramMapsList: { 'type': 'array', 'itemType': ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList },
      passThroughAllHeaders: 'string',
      passThroughList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder extends $tea.Model {
  /**
   * @remarks
   * The Dubbo service group.
   * 
   * @example
   * service group
   */
  dubboServiceGroup?: string;
  /**
   * @remarks
   * The name of the Dubbo service.
   * 
   * @example
   * org.apache.dubbo.samples.basic.api.DemoService
   */
  dubboServiceName?: string;
  /**
   * @remarks
   * The version of the Dubbo service.
   * 
   * @example
   * 0.0.0
   */
  dubboServiceVersion?: string;
  /**
   * @remarks
   * The forwarding rules of the Dubbo service.
   */
  mothedMapList?: ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList[];
  static names(): { [key: string]: string } {
    return {
      dubboServiceGroup: 'DubboServiceGroup',
      dubboServiceName: 'DubboServiceName',
      dubboServiceVersion: 'DubboServiceVersion',
      mothedMapList: 'MothedMapList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dubboServiceGroup: 'string',
      dubboServiceName: 'string',
      dubboServiceVersion: 'string',
      mothedMapList: { 'type': 'array', 'itemType': ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteResponseBodyDataResultRouteServices extends $tea.Model {
  /**
   * @remarks
   * The type of the protocol.
   * 
   * @example
   * DUBBO
   */
  agreementType?: string;
  /**
   * @remarks
   * The name of the group to which the service belongs.
   * 
   * @example
   * api
   */
  groupName?: string;
  /**
   * @example
   * Health
   */
  healthStatus?: string;
  /**
   * @remarks
   * The transcoder of the Dubbo protocol.
   */
  httpDubboTranscoder?: ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The weight in the form of a percentage value.
   * 
   * @example
   * 11
   */
  percent?: number;
  /**
   * @remarks
   * The ID of the service.
   * 
   * @example
   * 1563
   */
  serviceId?: number;
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * hu
   */
  serviceName?: string;
  /**
   * @remarks
   * The Dubbo port number.
   * 
   * @example
   * 20880
   */
  servicePort?: number;
  /**
   * @remarks
   * The source type.
   * 
   * @example
   * MSE
   */
  sourceType?: string;
  unhealthyEndpoints?: string[];
  /**
   * @remarks
   * The version of the service.
   * 
   * @example
   * v1
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      agreementType: 'AgreementType',
      groupName: 'GroupName',
      healthStatus: 'HealthStatus',
      httpDubboTranscoder: 'HttpDubboTranscoder',
      name: 'Name',
      namespace: 'Namespace',
      percent: 'Percent',
      serviceId: 'ServiceId',
      serviceName: 'ServiceName',
      servicePort: 'ServicePort',
      sourceType: 'SourceType',
      unhealthyEndpoints: 'UnhealthyEndpoints',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      agreementType: 'string',
      groupName: 'string',
      healthStatus: 'string',
      httpDubboTranscoder: ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder,
      name: 'string',
      namespace: 'string',
      percent: 'number',
      serviceId: 'number',
      serviceName: 'string',
      servicePort: 'number',
      sourceType: 'string',
      unhealthyEndpoints: { 'type': 'array', 'itemType': 'string' },
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteResponseBodyDataResult extends $tea.Model {
  /**
   * @remarks
   * The route comment (ingress).
   */
  comment?: ListGatewayRouteResponseBodyDataResultComment;
  /**
   * @remarks
   * The default service ID.
   * 
   * @example
   * 1
   */
  defaultServiceId?: number;
  /**
   * @remarks
   * The default service name.
   * 
   * @example
   * test
   */
  defaultServiceName?: string;
  /**
   * @remarks
   * The destination service type.
   * 
   * @example
   * Single
   */
  destinationType?: string;
  /**
   * @remarks
   * The information about service mocking.
   */
  directResponse?: ListGatewayRouteResponseBodyDataResultDirectResponse;
  /**
   * @remarks
   * The domain ID.
   * 
   * @example
   * 265
   */
  domainId?: number;
  /**
   * @remarks
   * The domain IDs.
   */
  domainIdList?: number[];
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * y.com
   */
  domainName?: string;
  /**
   * @remarks
   * The domain names.
   */
  domainNameList?: string[];
  dynamicRoute?: boolean;
  /**
   * @remarks
   * Indicates whether Web Application Firewall (WAF) is activated.
   * 
   * @example
   * false
   */
  enableWaf?: string;
  /**
   * @remarks
   * Indicates whether the Fallback service is enabled.
   * 
   * @example
   * true
   */
  fallback?: boolean;
  /**
   * @remarks
   * The information about the Fallback service.
   */
  fallbackServices?: ListGatewayRouteResponseBodyDataResultFallbackServices[];
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 496
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-cf0e7f52ecc7429dbc7ba4d5e3656100
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2022-01-25T07:14:01.817+0000
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The modification time.
   * 
   * @example
   * 2022-01-07 18:07:57
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID.
   * 
   * @example
   * 47
   */
  id?: number;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The matching rules.
   * 
   * @example
   * {\\"PathPredicates\\":{\\"Path\\":\\"/rpc/compute \\",\\"Type\\":\\"PRE\\",\\"IgnoreCase\\":true}}
   */
  predicates?: string;
  /**
   * @remarks
   * The information about redirection.
   */
  redirect?: ListGatewayRouteResponseBodyDataResultRedirect;
  /**
   * @remarks
   * The order.
   * 
   * @example
   * 1
   */
  routeOrder?: number;
  /**
   * @remarks
   * The matching rules.
   */
  routePredicates?: ListGatewayRouteResponseBodyDataResultRoutePredicates;
  /**
   * @remarks
   * The information about services.
   */
  routeServices?: ListGatewayRouteResponseBodyDataResultRouteServices[];
  /**
   * @remarks
   * The information about services.
   * 
   * @example
   * []
   */
  services?: string;
  /**
   * @remarks
   * The status.
   * 
   * @example
   * 2
   */
  status?: number;
  /**
   * @remarks
   * The route type.
   * 
   * @example
   * Op
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      defaultServiceId: 'DefaultServiceId',
      defaultServiceName: 'DefaultServiceName',
      destinationType: 'DestinationType',
      directResponse: 'DirectResponse',
      domainId: 'DomainId',
      domainIdList: 'DomainIdList',
      domainName: 'DomainName',
      domainNameList: 'DomainNameList',
      dynamicRoute: 'DynamicRoute',
      enableWaf: 'EnableWaf',
      fallback: 'Fallback',
      fallbackServices: 'FallbackServices',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      name: 'Name',
      predicates: 'Predicates',
      redirect: 'Redirect',
      routeOrder: 'RouteOrder',
      routePredicates: 'RoutePredicates',
      routeServices: 'RouteServices',
      services: 'Services',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: ListGatewayRouteResponseBodyDataResultComment,
      defaultServiceId: 'number',
      defaultServiceName: 'string',
      destinationType: 'string',
      directResponse: ListGatewayRouteResponseBodyDataResultDirectResponse,
      domainId: 'number',
      domainIdList: { 'type': 'array', 'itemType': 'number' },
      domainName: 'string',
      domainNameList: { 'type': 'array', 'itemType': 'string' },
      dynamicRoute: 'boolean',
      enableWaf: 'string',
      fallback: 'boolean',
      fallbackServices: { 'type': 'array', 'itemType': ListGatewayRouteResponseBodyDataResultFallbackServices },
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      name: 'string',
      predicates: 'string',
      redirect: ListGatewayRouteResponseBodyDataResultRedirect,
      routeOrder: 'number',
      routePredicates: ListGatewayRouteResponseBodyDataResultRoutePredicates,
      routeServices: { 'type': 'array', 'itemType': ListGatewayRouteResponseBodyDataResultRouteServices },
      services: 'string',
      status: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 11
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The data structure.
   */
  result?: ListGatewayRouteResponseBodyDataResult[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 36
   */
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      result: 'Result',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      result: { 'type': 'array', 'itemType': ListGatewayRouteResponseBodyDataResult },
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteOnAuthResponseBodyDataRoutePredicatesPathPredicates extends $tea.Model {
  /**
   * @remarks
   * The path.
   * 
   * @example
   * /api
   */
  path?: string;
  /**
   * @remarks
   * The matching type.
   * 
   * @example
   * PRE
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      path: 'Path',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      path: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteOnAuthResponseBodyDataRoutePredicates extends $tea.Model {
  /**
   * @remarks
   * The information about route matching.
   */
  pathPredicates?: ListGatewayRouteOnAuthResponseBodyDataRoutePredicatesPathPredicates;
  static names(): { [key: string]: string } {
    return {
      pathPredicates: 'PathPredicates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pathPredicates: ListGatewayRouteOnAuthResponseBodyDataRoutePredicatesPathPredicates,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayRouteOnAuthResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The domain ID.
   * 
   * @example
   * 235
   */
  domainId?: number;
  /**
   * @remarks
   * The domain IDs.
   */
  domainIdList?: number[];
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * 123.com
   */
  domainName?: string;
  /**
   * @remarks
   * The domain names.
   */
  domainNameList?: string[];
  /**
   * @remarks
   * The gateway ID.
   * 
   * @example
   * 399
   */
  gatewayId?: string;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-7ea3da97b96543e19f6c597c****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The route ID.
   * 
   * @example
   * 12
   */
  id?: number;
  /**
   * @remarks
   * The name of the route.
   * 
   * @example
   * ceshi
   */
  name?: string;
  /**
   * @remarks
   * The information about route matching.
   */
  routePredicates?: ListGatewayRouteOnAuthResponseBodyDataRoutePredicates;
  static names(): { [key: string]: string } {
    return {
      domainId: 'DomainId',
      domainIdList: 'DomainIdList',
      domainName: 'DomainName',
      domainNameList: 'DomainNameList',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      name: 'Name',
      routePredicates: 'RoutePredicates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainId: 'number',
      domainIdList: { 'type': 'array', 'itemType': 'number' },
      domainName: 'string',
      domainNameList: { 'type': 'array', 'itemType': 'string' },
      gatewayId: 'string',
      gatewayUniqueId: 'string',
      id: 'number',
      name: 'string',
      routePredicates: ListGatewayRouteOnAuthResponseBodyDataRoutePredicates,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayServiceRequestFilterParams extends $tea.Model {
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-5017305290e14centbrveca****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The group.
   * 
   * @example
   * test
   */
  groupName?: string;
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The namespace to which the service belongs.
   * 
   * @example
   * public
   */
  namespace?: string;
  /**
   * @remarks
   * The protocol of the service.
   * 
   * *   HTTP
   * *   HTTPS
   * *   HTTP2
   * *   GRPC
   * *   DUBBO
   * 
   * @example
   * HTTP
   */
  serviceProtocol?: string;
  /**
   * @remarks
   * The type of the source.
   * 
   * @example
   * MSE
   */
  sourceType?: string;
  static names(): { [key: string]: string } {
    return {
      gatewayUniqueId: 'GatewayUniqueId',
      groupName: 'GroupName',
      name: 'Name',
      namespace: 'Namespace',
      serviceProtocol: 'ServiceProtocol',
      sourceType: 'SourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gatewayUniqueId: 'string',
      groupName: 'string',
      name: 'string',
      namespace: 'string',
      serviceProtocol: 'string',
      sourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie extends $tea.Model {
  /**
   * @remarks
   * The name of the cookie.
   * 
   * @example
   * name
   */
  name?: string;
  /**
   * @remarks
   * The path of the cookie.
   * 
   * @example
   * /path
   */
  path?: string;
  /**
   * @remarks
   * The lifecycle of the cookie.
   * 
   * @example
   * 360
   */
  ttl?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      path: 'Path',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      path: 'string',
      ttl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig extends $tea.Model {
  /**
   * @remarks
   * The type based on which consistent hashing load balancing is performed.
   * 
   * *   HEADER
   * *   COOKIE
   * *   SOURCE_IP
   * *   QUERY_PARAMETER
   * 
   * @example
   * HEADER
   */
  consistentHashLBType?: string;
  /**
   * @remarks
   * The cookie-based load balancing parameters.
   */
  httpCookie?: ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie;
  /**
   * @remarks
   * The minimum value of the hash ring.
   * 
   * @example
   * 10000
   */
  minimumRingSize?: number;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * param
   */
  parameterName?: string;
  static names(): { [key: string]: string } {
    return {
      consistentHashLBType: 'ConsistentHashLBType',
      httpCookie: 'HttpCookie',
      minimumRingSize: 'MinimumRingSize',
      parameterName: 'ParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consistentHashLBType: 'string',
      httpCookie: ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie,
      minimumRingSize: 'number',
      parameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings extends $tea.Model {
  /**
   * @remarks
   * The consistent hashing settings.
   */
  consistentHashLBConfig?: ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig;
  /**
   * @remarks
   * The load balancing type.
   * 
   * *   ROUND_ROBIN
   * *   LEAST_CONN
   * *   RANDOM
   * *   CONSISTENT_HASH
   * 
   * @example
   * RANDOM
   */
  loadbalancerType?: string;
  /**
   * @remarks
   * The prefetch time of the least connection load balancing.
   * 
   * @example
   * 10
   */
  warmupDuration?: number;
  static names(): { [key: string]: string } {
    return {
      consistentHashLBConfig: 'ConsistentHashLBConfig',
      loadbalancerType: 'LoadbalancerType',
      warmupDuration: 'WarmupDuration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consistentHashLBConfig: ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig,
      loadbalancerType: 'string',
      warmupDuration: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls extends $tea.Model {
  /**
   * @remarks
   * The public key of the CA certificate .
   * 
   * @example
   * content
   */
  caCertContent?: string;
  /**
   * @remarks
   * The ID of the certification authority (CA) certificate.
   * 
   * @example
   * 5******-cn-hangzhou
   */
  caCertId?: string;
  /**
   * @remarks
   * The ID of the certificate.
   * 
   * @example
   * 5******-cn-hangzhou
   */
  certId?: string;
  /**
   * @remarks
   * The TLS mode.
   * 
   * *   DISABLE
   * *   SIMPLE
   * *   MUTUAL
   * *   ISTIO_MUTUAL
   * 
   * @example
   * SIMPLE
   */
  mode?: string;
  /**
   * @remarks
   * The Server Name Indication (SNI) value.
   * 
   * @example
   * name-sni
   */
  sni?: string;
  /**
   * @remarks
   * The array of subject aliases.
   */
  subjectAltNames?: string[];
  static names(): { [key: string]: string } {
    return {
      caCertContent: 'CaCertContent',
      caCertId: 'CaCertId',
      certId: 'CertId',
      mode: 'Mode',
      sni: 'Sni',
      subjectAltNames: 'SubjectAltNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      caCertContent: 'string',
      caCertId: 'string',
      certId: 'string',
      mode: 'string',
      sni: 'string',
      subjectAltNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy extends $tea.Model {
  /**
   * @remarks
   * The load balancing settings.
   */
  loadBalancerSettings?: ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings;
  /**
   * @remarks
   * The Transport Layer Security (TLS).
   */
  tls?: ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls;
  static names(): { [key: string]: string } {
    return {
      loadBalancerSettings: 'LoadBalancerSettings',
      tls: 'Tls',
    };
  }

  static types(): { [key: string]: any } {
    return {
      loadBalancerSettings: ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings,
      tls: ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayServiceResponseBodyDataResultHealthCheckInfo extends $tea.Model {
  /**
   * @remarks
   * Indicates whether checks are performed.
   * 
   * @example
   * true
   */
  check?: boolean;
  /**
   * @remarks
   * The expected status of the health check.
   */
  expectedStatuses?: number[];
  /**
   * @remarks
   * The threshold for healthy instances.
   * 
   * @example
   * 2
   */
  healthyThreshold?: number;
  /**
   * @remarks
   * The endpoint of the HTTP request for the health check.
   * 
   * @example
   * http://172.168.0.1
   */
  httpHost?: string;
  /**
   * @remarks
   * The path to which the HTTP request for the health check is sent.
   * 
   * @example
   * /health
   */
  httpPath?: string;
  /**
   * @remarks
   * The health check interval.
   * 
   * @example
   * 2
   */
  interval?: number;
  /**
   * @remarks
   * The network protocol.
   * 
   * @example
   * TCP
   */
  protocol?: string;
  /**
   * @remarks
   * The timeout period.
   * 
   * @example
   * 2
   */
  timeout?: number;
  /**
   * @remarks
   * The threshold for unhealthy instances.
   * 
   * @example
   * 2
   */
  unhealthyThreshold?: number;
  static names(): { [key: string]: string } {
    return {
      check: 'Check',
      expectedStatuses: 'ExpectedStatuses',
      healthyThreshold: 'HealthyThreshold',
      httpHost: 'HttpHost',
      httpPath: 'HttpPath',
      interval: 'Interval',
      protocol: 'Protocol',
      timeout: 'Timeout',
      unhealthyThreshold: 'UnhealthyThreshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      check: 'boolean',
      expectedStatuses: { 'type': 'array', 'itemType': 'number' },
      healthyThreshold: 'number',
      httpHost: 'string',
      httpPath: 'string',
      interval: 'number',
      protocol: 'string',
      timeout: 'number',
      unhealthyThreshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayServiceResponseBodyDataResultVersions extends $tea.Model {
  /**
   * @remarks
   * The version number.
   * 
   * @example
   * v1
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayServiceResponseBodyDataResult extends $tea.Model {
  /**
   * @remarks
   * The gateway ID.
   * 
   * @example
   * 1
   */
  gatewayId?: number;
  /**
   * @remarks
   * The traffic management policy.
   */
  gatewayTrafficPolicy?: ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-5017305290e14centbrveca****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2022-01-07 18:07:57
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The modification time.
   * 
   * @example
   * 2022-01-07 18:07:57
   */
  gmtModified?: string;
  /**
   * @remarks
   * The group.
   * 
   * @example
   * test
   */
  groupName?: string;
  /**
   * @remarks
   * The health status.
   * 
   * *   Health
   * *   Unhealthy
   * *   Unknown
   * 
   * @example
   * Unhealthy
   */
  healehStatus?: string;
  /**
   * @remarks
   * Indicates whether health checks are performed.
   * 
   * @example
   * true
   */
  healthCheck?: boolean;
  /**
   * @remarks
   * The information about health checks.
   */
  healthCheckInfo?: ListGatewayServiceResponseBodyDataResultHealthCheckInfo;
  /**
   * @remarks
   * The health status.
   * 
   * *   Health
   * *   Unhealthy
   * *   Unknown
   * 
   * @example
   * Unhealthy
   */
  healthStatus?: string;
  /**
   * @remarks
   * The ID.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The list of IP addresses.
   */
  ips?: string[];
  /**
   * @remarks
   * The metadata or IP addresses of the service.
   * 
   * @example
   * {}
   */
  metaInfo?: string;
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * public
   */
  namespace?: string;
  /**
   * @remarks
   * The port array.
   */
  ports?: number[];
  serviceFQDN?: string;
  /**
   * @remarks
   * The name of the service that is registered with the service registry.
   * 
   * @example
   * test
   */
  serviceNameInRegistry?: string;
  /**
   * @remarks
   * The service port number.
   * 
   * @example
   * 80
   */
  servicePort?: number;
  /**
   * @remarks
   * The protocol of the service.
   * 
   * @example
   * HTTP
   */
  serviceProtocol?: string;
  /**
   * @remarks
   * The ID of the service source.
   * 
   * @example
   * 2
   */
  sourceId?: number;
  /**
   * @remarks
   * The source type.
   * 
   * @example
   * MSE
   */
  sourceType?: string;
  /**
   * @remarks
   * The array of endpoints of unhealthy instances.
   */
  unhealthyEndpoints?: string[];
  /**
   * @remarks
   * The service version.
   */
  versions?: ListGatewayServiceResponseBodyDataResultVersions[];
  static names(): { [key: string]: string } {
    return {
      gatewayId: 'GatewayId',
      gatewayTrafficPolicy: 'GatewayTrafficPolicy',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      groupName: 'GroupName',
      healehStatus: 'HealehStatus',
      healthCheck: 'HealthCheck',
      healthCheckInfo: 'HealthCheckInfo',
      healthStatus: 'HealthStatus',
      id: 'Id',
      ips: 'Ips',
      metaInfo: 'MetaInfo',
      name: 'Name',
      namespace: 'Namespace',
      ports: 'Ports',
      serviceFQDN: 'ServiceFQDN',
      serviceNameInRegistry: 'ServiceNameInRegistry',
      servicePort: 'ServicePort',
      serviceProtocol: 'ServiceProtocol',
      sourceId: 'SourceId',
      sourceType: 'SourceType',
      unhealthyEndpoints: 'UnhealthyEndpoints',
      versions: 'Versions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gatewayId: 'number',
      gatewayTrafficPolicy: ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy,
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      groupName: 'string',
      healehStatus: 'string',
      healthCheck: 'boolean',
      healthCheckInfo: ListGatewayServiceResponseBodyDataResultHealthCheckInfo,
      healthStatus: 'string',
      id: 'number',
      ips: { 'type': 'array', 'itemType': 'string' },
      metaInfo: 'string',
      name: 'string',
      namespace: 'string',
      ports: { 'type': 'array', 'itemType': 'number' },
      serviceFQDN: 'string',
      serviceNameInRegistry: 'string',
      servicePort: 'number',
      serviceProtocol: 'string',
      sourceId: 'number',
      sourceType: 'string',
      unhealthyEndpoints: { 'type': 'array', 'itemType': 'string' },
      versions: { 'type': 'array', 'itemType': ListGatewayServiceResponseBodyDataResultVersions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayServiceResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The data returned.
   */
  result?: ListGatewayServiceResponseBodyDataResult[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 9
   */
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      result: 'Result',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      result: { 'type': 'array', 'itemType': ListGatewayServiceResponseBodyDataResult },
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewaySlbResponseBodyDataVServiceList extends $tea.Model {
  port?: string;
  protocol?: string;
  VServerGroupId?: string;
  VServerGroupName?: string;
  static names(): { [key: string]: string } {
    return {
      port: 'Port',
      protocol: 'Protocol',
      VServerGroupId: 'VServerGroupId',
      VServerGroupName: 'VServerGroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      port: 'string',
      protocol: 'string',
      VServerGroupId: 'string',
      VServerGroupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewaySlbResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the edit operation is supported.
   * 
   * @example
   * false
   */
  editEnable?: boolean;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 1
   */
  gatewayId?: string;
  /**
   * @remarks
   * The mode of the SLB instance.
   * 
   * @example
   * UserSelect
   */
  gatewaySlbMode?: string;
  /**
   * @remarks
   * The association status.
   * 
   * @example
   * Ready
   */
  gatewaySlbStatus?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2022-01-14 14:39:16
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The port number of the HTTP virtual service group.
   * 
   * @example
   * 80
   */
  httpPort?: number;
  /**
   * @remarks
   * The port number of the HTTPS virtual service group.
   * 
   * @example
   * 443
   */
  httpsPort?: number;
  /**
   * @remarks
   * The ID of the HTTPS virtual service group.
   * 
   * @example
   * 353
   */
  httpsVServerGroupId?: string;
  /**
   * @remarks
   * The ID.
   * 
   * @example
   * ID
   */
  id?: string;
  /**
   * @remarks
   * The service weight.
   * 
   * @example
   * 80
   */
  serviceWeight?: number;
  /**
   * @remarks
   * The ID of the SLB instance.
   * 
   * @example
   * lb-bp1kmnli3hdpreptw2ah3
   */
  slbId?: string;
  /**
   * @remarks
   * The IP address of the SLB instance.
   * 
   * @example
   * 121.199.XX.XX
   */
  slbIp?: string;
  /**
   * @remarks
   * The port number of the SLB instance.
   * 
   * @example
   * 80,443
   */
  slbPort?: string;
  slbType?: string;
  /**
   * @remarks
   * The description of the status.
   * 
   * @example
   * Associating
   */
  statusDesc?: string;
  /**
   * @remarks
   * The type.
   * 
   * @example
   * PUB_NET
   */
  type?: string;
  /**
   * @remarks
   * The ID of the HTTP virtual service group.
   * 
   * @example
   * 353
   */
  VServerGroupId?: string;
  VServiceList?: ListGatewaySlbResponseBodyDataVServiceList[];
  vsMetaInfo?: string;
  static names(): { [key: string]: string } {
    return {
      editEnable: 'EditEnable',
      gatewayId: 'GatewayId',
      gatewaySlbMode: 'GatewaySlbMode',
      gatewaySlbStatus: 'GatewaySlbStatus',
      gmtCreate: 'GmtCreate',
      httpPort: 'HttpPort',
      httpsPort: 'HttpsPort',
      httpsVServerGroupId: 'HttpsVServerGroupId',
      id: 'Id',
      serviceWeight: 'ServiceWeight',
      slbId: 'SlbId',
      slbIp: 'SlbIp',
      slbPort: 'SlbPort',
      slbType: 'SlbType',
      statusDesc: 'StatusDesc',
      type: 'Type',
      VServerGroupId: 'VServerGroupId',
      VServiceList: 'VServiceList',
      vsMetaInfo: 'VsMetaInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      editEnable: 'boolean',
      gatewayId: 'string',
      gatewaySlbMode: 'string',
      gatewaySlbStatus: 'string',
      gmtCreate: 'string',
      httpPort: 'number',
      httpsPort: 'number',
      httpsVServerGroupId: 'string',
      id: 'string',
      serviceWeight: 'number',
      slbId: 'string',
      slbIp: 'string',
      slbPort: 'string',
      slbType: 'string',
      statusDesc: 'string',
      type: 'string',
      VServerGroupId: 'string',
      VServiceList: { 'type': 'array', 'itemType': ListGatewaySlbResponseBodyDataVServiceList },
      vsMetaInfo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGatewayZoneResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The local name of the zone.
   * 
   * @example
   * I
   */
  localName?: string;
  /**
   * @remarks
   * The zone ID.
   * 
   * @example
   * cn-hangzhou-i
   */
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      localName: 'LocalName',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      localName: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListIsolationRulesResponseBodyDataResult extends $tea.Model {
  /**
   * @example
   * hkhon1po62@c3df23522bXXXXX
   */
  appId?: string;
  /**
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @example
   * "{\\"appName\\":\\"spring-cloud-a\\",\\"fallbackBehavior\\":{\\"webFallbackMode\\":0,\\"webRespContentType\\":0,\\"webRespMessage\\":\\"Blocked\\",\\"webRespStatusCode\\":429},\\"id\\":977,\\"name\\":\\"Fallback\\",\\"namespace\\":\\"default\\",\\"resourceClassification\\":1}"
   */
  fallbackObject?: string;
  /**
   * @example
   * default
   */
  namespace?: string;
  /**
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @example
   * /a
   */
  resource?: string;
  /**
   * @example
   * 1
   */
  ruleId?: number;
  /**
   * @example
   * 3
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      enable: 'Enable',
      fallbackObject: 'FallbackObject',
      namespace: 'Namespace',
      regionId: 'RegionId',
      resource: 'Resource',
      ruleId: 'RuleId',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appName: 'string',
      enable: 'boolean',
      fallbackObject: 'string',
      namespace: 'string',
      regionId: 'string',
      resource: 'string',
      ruleId: 'number',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListIsolationRulesResponseBodyData extends $tea.Model {
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  result?: ListIsolationRulesResponseBodyDataResult[];
  /**
   * @example
   * 3
   */
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      result: 'Result',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      result: { 'type': 'array', 'itemType': ListIsolationRulesResponseBodyDataResult },
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListListenersByConfigResponseBodyListeners extends $tea.Model {
  /**
   * @remarks
   * The IP address.
   * 
   * @example
   * 1.1.1.1
   */
  ip?: string;
  /**
   * @remarks
   * The label of the listener.
   */
  labels?: { [key: string]: string };
  /**
   * @remarks
   * The verification string.
   * 
   * @example
   * 23sdfdf
   */
  md5?: string;
  /**
   * @remarks
   * The status.
   * 
   * @example
   * beta
   */
  status?: string;
  /**
   * @remarks
   * The current version of the listener. Valid values: gray and normal.
   * 
   * @example
   * gray
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      ip: 'Ip',
      labels: 'Labels',
      md5: 'Md5',
      status: 'Status',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ip: 'string',
      labels: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      md5: 'string',
      status: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListListenersByIpResponseBodyListeners extends $tea.Model {
  /**
   * @remarks
   * The ID of the data.
   * 
   * @example
   * test.yaml
   */
  dataId?: string;
  /**
   * @remarks
   * The group.
   * 
   * @example
   * default
   */
  group?: string;
  /**
   * @remarks
   * The verification string.
   * 
   * @example
   * 23sdfdf
   */
  md5?: string;
  namespaceId?: string;
  static names(): { [key: string]: string } {
    return {
      dataId: 'DataId',
      group: 'Group',
      md5: 'Md5',
      namespaceId: 'NamespaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataId: 'string',
      group: 'string',
      md5: 'string',
      namespaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMigrationTaskResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The type of the instance.
   * 
   * *   Nacos-Ans
   * *   ZooKeeper
   * *   Eureka
   * 
   * @example
   * Nacos-Ans
   */
  clusterType?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2022-01-07T10:07:57.000+0000
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The update time.
   * 
   * @example
   * 2021-12-30T06:41:52.000+0000
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the job.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The address of the source instance node.
   * 
   * @example
   * 192.168.1.1:8848
   */
  originInstanceAddress?: string;
  /**
   * @remarks
   * The name of the source instance.
   * 
   * @example
   * test
   */
  originInstanceName?: string;
  /**
   * @remarks
   * The list of namespaces. This parameter is optional if applications are migrated from a Nacos instance.
   * 
   * @example
   * fsdfsdfdsf
   */
  originInstanceNamespace?: string;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * test
   */
  projectDesc?: string;
  syncType?: string;
  /**
   * @remarks
   * The name of the destination instance.
   * 
   * @example
   * multiple-nacos
   */
  targetClusterName?: string;
  /**
   * @remarks
   * The URL of the destination instance.
   * 
   * @example
   * mse-f1******-nacos-ans.mse.aliyuncs.com:8848
   */
  targetClusterUrl?: string;
  /**
   * @remarks
   * The ID of the destination instance.
   * 
   * @example
   * mse-cn-zv*****
   */
  targetInstanceId?: string;
  /**
   * @remarks
   * The ID of the user.
   * 
   * @example
   * 2
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterType: 'ClusterType',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      originInstanceAddress: 'OriginInstanceAddress',
      originInstanceName: 'OriginInstanceName',
      originInstanceNamespace: 'OriginInstanceNamespace',
      projectDesc: 'ProjectDesc',
      syncType: 'SyncType',
      targetClusterName: 'TargetClusterName',
      targetClusterUrl: 'TargetClusterUrl',
      targetInstanceId: 'TargetInstanceId',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterType: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      originInstanceAddress: 'string',
      originInstanceName: 'string',
      originInstanceNamespace: 'string',
      projectDesc: 'string',
      syncType: 'string',
      targetClusterName: 'string',
      targetClusterUrl: 'string',
      targetInstanceId: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNacosConfigsResponseBodyConfigurations extends $tea.Model {
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * test
   */
  appName?: string;
  /**
   * @remarks
   * The ID of the configuration.
   * 
   * @example
   * log.yaml
   */
  dataId?: string;
  /**
   * @remarks
   * The ID of the group.
   * 
   * @example
   * public
   */
  group?: string;
  /**
   * @remarks
   * The ID of the application.
   * 
   * @example
   * 132****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      dataId: 'DataId',
      group: 'Group',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      dataId: 'string',
      group: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNacosHistoryConfigsResponseBodyHistoryItems extends $tea.Model {
  /**
   * @remarks
   * The application tag.
   * 
   * @example
   * gateway
   */
  appName?: string;
  /**
   * @remarks
   * The ID of the data.
   * 
   * @example
   * test.yaml
   */
  dataId?: string;
  /**
   * @remarks
   * The name of the group.
   * 
   * @example
   * default
   */
  group?: string;
  /**
   * @remarks
   * The ID of the configuration.
   * 
   * @example
   * 23fdsf
   */
  id?: number;
  /**
   * @remarks
   * The timestamp when the configuration was last modified.
   * 
   * @example
   * 16434400
   */
  lastModifiedTime?: number;
  /**
   * @remarks
   * The format of the configuration file.
   * 
   * @example
   * yaml
   */
  opType?: string;
  srcUser?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      dataId: 'DataId',
      group: 'Group',
      id: 'Id',
      lastModifiedTime: 'LastModifiedTime',
      opType: 'OpType',
      srcUser: 'SrcUser',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      dataId: 'string',
      group: 'string',
      id: 'number',
      lastModifiedTime: 'number',
      opType: 'string',
      srcUser: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNamingTrackResponseBodyTraces extends $tea.Model {
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 120.40.32.235
   */
  clientIp?: string;
  /**
   * @remarks
   * The group.
   * 
   * @example
   * prod
   */
  group?: string;
  /**
   * @remarks
   * The number of instances.
   * 
   * @example
   * 1
   */
  instanceSize?: string;
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * mse-197*****-167083******-reg-center-0-0
   */
  nodeName?: string;
  /**
   * @remarks
   * The push time.
   * 
   * @example
   * 2022-12-16 11:48:07
   */
  pushTime?: string;
  /**
   * @remarks
   * The total push time.
   * 
   * @example
   * 628ms
   */
  pushTimeAll?: string;
  /**
   * @remarks
   * The push time for the network.
   * 
   * @example
   * 37ms
   */
  pushTimeNetwork?: string;
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * fpx-xms-baseinfo
   */
  serverName?: string;
  /**
   * @remarks
   * The duration that is specified in the service-level agreement (SLA).
   * 
   * @example
   * 628ms
   */
  slaTime?: string;
  static names(): { [key: string]: string } {
    return {
      clientIp: 'ClientIp',
      group: 'Group',
      instanceSize: 'InstanceSize',
      nodeName: 'NodeName',
      pushTime: 'PushTime',
      pushTimeAll: 'PushTimeAll',
      pushTimeNetwork: 'PushTimeNetwork',
      serverName: 'ServerName',
      slaTime: 'SlaTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientIp: 'string',
      group: 'string',
      instanceSize: 'string',
      nodeName: 'string',
      pushTime: 'string',
      pushTimeAll: 'string',
      pushTimeNetwork: 'string',
      serverName: 'string',
      slaTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSSLCertResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The time when the certificate expires. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 2021-04-01 02:35:12
   */
  afterDate?: string;
  /**
   * @remarks
   * The algorithm.
   * 
   * @example
   * test
   */
  algorithm?: string;
  /**
   * @remarks
   * The time when the certificate took effect. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 2031-03-30 02:35:12
   */
  beforeDate?: string;
  /**
   * @remarks
   * The ID of the certificate.
   * 
   * @example
   * 1234
   */
  certIdentifier?: string;
  /**
   * @remarks
   * The name of the certificate.
   * 
   * @example
   * test.com
   */
  certName?: string;
  /**
   * @remarks
   * The domain name with which the certificate is associated.
   * 
   * @example
   * *.test.com
   */
  commonName?: string;
  /**
   * @remarks
   * The time when the certificate expires. This value is a GMT timestamp.
   * 
   * @example
   * 2021-04-01 02:35:12
   */
  gmtAfter?: string;
  /**
   * @remarks
   * The time when the certificate took effect. This value is a GMT timestamp.
   * 
   * @example
   * 2031-03-30 02:35:12
   */
  gmtBefore?: string;
  /**
   * @remarks
   * The issuer of the certificate.
   * 
   * @example
   * test
   */
  issuer?: string;
  /**
   * @remarks
   * The SSL certificate.
   * 
   * @example
   * SSL
   */
  sans?: string;
  static names(): { [key: string]: string } {
    return {
      afterDate: 'AfterDate',
      algorithm: 'Algorithm',
      beforeDate: 'BeforeDate',
      certIdentifier: 'CertIdentifier',
      certName: 'CertName',
      commonName: 'CommonName',
      gmtAfter: 'GmtAfter',
      gmtBefore: 'GmtBefore',
      issuer: 'Issuer',
      sans: 'Sans',
    };
  }

  static types(): { [key: string]: any } {
    return {
      afterDate: 'string',
      algorithm: 'string',
      beforeDate: 'string',
      certIdentifier: 'string',
      certName: 'string',
      commonName: 'string',
      gmtAfter: 'string',
      gmtBefore: 'string',
      issuer: 'string',
      sans: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSecurityGroupResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the security group.
   * 
   * @example
   * sg-8vb8gsmrqyc35k645rk6
   */
  securityGroupId?: string;
  /**
   * @remarks
   * The name of the security group.
   * 
   * @example
   * sg2
   */
  securityGroupName?: string;
  /**
   * @remarks
   * The type of the security group. Valid values:
   * 
   * *   normal: basic security group
   * *   enterprise: advanced security group For more information, see [Advanced security groups](https://help.aliyun.com/document_detail/120621.html).
   * 
   * @example
   * enterprise
   */
  securityGroupType?: string;
  /**
   * @remarks
   * The ID of the virtual private cloud (VPC).
   * 
   * @example
   * vpc-bp1b
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      securityGroupId: 'SecurityGroupId',
      securityGroupName: 'SecurityGroupName',
      securityGroupType: 'SecurityGroupType',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityGroupId: 'string',
      securityGroupName: 'string',
      securityGroupType: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSecurityGroupRuleResponseBodyData extends $tea.Model {
  authCidrs?: string[];
  /**
   * @remarks
   * The rule description.
   * 
   * @example
   * Test
   */
  description?: string;
  /**
   * @remarks
   * The gateway ID.
   * 
   * @example
   * 81
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-12a432a1f5da423997d8880bd32c304d
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2022-01-07T10:07:57.000+0000
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The last modification time.
   * 
   * @example
   * 2022-01-07T10:07:57.000+0000
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the security group authorization record.
   * 
   * @example
   * 21
   */
  id?: string;
  /**
   * @remarks
   * The protocol type.
   * 
   * @example
   * tcp
   */
  ipProtocol?: string;
  /**
   * @remarks
   * The port range.
   * 
   * @example
   * 8000/8000
   */
  portRange?: string;
  /**
   * @remarks
   * The ID of the security group.
   * 
   * @example
   * sg-bp1cg6qlyjepj0y6cf2c
   */
  securityGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      authCidrs: 'AuthCidrs',
      description: 'Description',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      ipProtocol: 'IpProtocol',
      portRange: 'PortRange',
      securityGroupId: 'SecurityGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authCidrs: { 'type': 'array', 'itemType': 'string' },
      description: 'string',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'string',
      ipProtocol: 'string',
      portRange: 'string',
      securityGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSentinelBlockFallbackDefinitionsResponseBodyData extends $tea.Model {
  /**
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @example
   * {"webRespStatusCode":429,"webRespMessage":"test","webFallbackMode":0,"webRespContentType":0}
   */
  fallbackBehavior?: { [key: string]: any };
  /**
   * @example
   * 12
   */
  id?: string;
  /**
   * @example
   * defaultFallback
   */
  name?: string;
  /**
   * @example
   * default
   */
  namespace?: string;
  /**
   * @example
   * 1
   */
  resourceClassification?: string;
  /**
   * @example
   * {"/params/{hot}":[1]}
   */
  targetMap?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      fallbackBehavior: 'FallbackBehavior',
      id: 'Id',
      name: 'Name',
      namespace: 'Namespace',
      resourceClassification: 'ResourceClassification',
      targetMap: 'TargetMap',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      fallbackBehavior: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      id: 'string',
      name: 'string',
      namespace: 'string',
      resourceClassification: 'string',
      targetMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceSourceResponseBodyDataIngressOptions extends $tea.Model {
  /**
   * @remarks
   * Indicates whether Ingresses are enabled.
   * 
   * @example
   * true
   */
  enableIngress?: boolean;
  /**
   * @remarks
   * Indicates whether the Ingress status is updated.
   * 
   * @example
   * true
   */
  enableStatus?: boolean;
  /**
   * @remarks
   * The Ingress class.
   * 
   * @example
   * com.test.xxx
   */
  ingressClass?: string;
  /**
   * @remarks
   * The namespace that you want to monitor.
   * 
   * @example
   * default
   */
  watchNamespace?: string;
  static names(): { [key: string]: string } {
    return {
      enableIngress: 'EnableIngress',
      enableStatus: 'EnableStatus',
      ingressClass: 'IngressClass',
      watchNamespace: 'WatchNamespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableIngress: 'boolean',
      enableStatus: 'boolean',
      ingressClass: 'string',
      watchNamespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListServiceSourceResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the Container Service for Kubernetes (ACK) cluster or the endpoint of the Microservices Engine (MSE) instance.
   * 
   * @example
   * ***
   */
  address?: string;
  /**
   * @remarks
   * Indicates whether the service source is associated with the gateway. The value 1 indicates that the service source is associated with the gateway.
   * 
   * @example
   * 1
   */
  bindingWithGateway?: number;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 1
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-2u9uhd9283hd92hgd39g239dg2*****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2022-01-07 18:07:57
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The update time.
   * 
   * @example
   * 2022-01-07 18:07:57
   */
  gmtModified?: string;
  /**
   * @remarks
   * The array of service groups.
   */
  groupList?: string[];
  /**
   * @remarks
   * The ID.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The information about the support for Ingresses by applications.
   */
  ingressOptions?: ListServiceSourceResponseBodyDataIngressOptions;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The array of root paths of service lists.
   */
  pathList?: string[];
  /**
   * @remarks
   * The type of the service source.
   * 
   * @example
   * MSE
   */
  source?: string;
  /**
   * @remarks
   * The unique ID of the service source.
   * 
   * @example
   * mse-cn-***
   */
  sourceUniqueId?: string;
  /**
   * @remarks
   * The type.
   * 
   * @example
   * NACOS
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      bindingWithGateway: 'BindingWithGateway',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      groupList: 'GroupList',
      id: 'Id',
      ingressOptions: 'IngressOptions',
      name: 'Name',
      pathList: 'PathList',
      source: 'Source',
      sourceUniqueId: 'SourceUniqueId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      bindingWithGateway: 'number',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      groupList: { 'type': 'array', 'itemType': 'string' },
      id: 'number',
      ingressOptions: ListServiceSourceResponseBodyDataIngressOptions,
      name: 'string',
      pathList: { 'type': 'array', 'itemType': 'string' },
      source: 'string',
      sourceUniqueId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * prd
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponseBodyTagResourcesTagResource extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource.
   * 
   * @example
   * mse-cn-7pp2st29t16
   */
  resourceId?: string;
  /**
   * @remarks
   * The type of the resource.
   * 
   * @example
   * cluster
   */
  resourceType?: string;
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * env
   */
  tagKey?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * prd
   */
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: 'string',
      resourceType: 'string',
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponseBodyTagResources extends $tea.Model {
  tagResource?: ListTagResourcesResponseBodyTagResourcesTagResource[];
  static names(): { [key: string]: string } {
    return {
      tagResource: 'TagResource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagResource: { 'type': 'array', 'itemType': ListTagResourcesResponseBodyTagResourcesTagResource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListZkTrackResponseBodyTraces extends $tea.Model {
  /**
   * @remarks
   * The access control list (ACL).
   * 
   * @example
   * world:anyone:cdrwa
   */
  acl?: string;
  /**
   * @remarks
   * The data type. Valid values:
   * 
   * *   persist
   * *   ephemeral
   * 
   * @example
   * persist
   */
  dataType?: string;
  /**
   * @remarks
   * The type of the event. For trajectory of the Notify type:
   * 
   * *   NodeCreated
   * *   NodeDeleted
   * *   NodeDataChanged
   * *   NodeChildrenChanged
   * 
   * @example
   * NodeCreated
   */
  eventType?: string;
  /**
   * @remarks
   * Indicates whether the transaction ended.
   * 
   * @example
   * true
   */
  finished?: boolean;
  /**
   * @remarks
   * The logging time.
   * 
   * @example
   * 2022-11-28 15:09:15,606
   */
  logDate?: string;
  /**
   * @remarks
   * The transaction size.
   * 
   * @example
   * 3
   */
  multiSize?: number;
  /**
   * @remarks
   * The type of the operation. For trajectory of the Push type:
   * 
   * *   Create
   * *   Update
   * *   Delete
   * *   SetAcl
   * *   Multi
   * 
   * For trajectory of the Pull type:
   * 
   * *   GetData
   * *   GetChild
   * *   GetStat
   * 
   * @example
   * Create
   */
  opType?: string;
  /**
   * @remarks
   * The path.
   * 
   * @example
   * /path
   */
  path?: string;
  /**
   * @remarks
   * The returned result.
   * 
   * @example
   * success
   */
  result?: string;
  /**
   * @remarks
   * The session ID.
   * 
   * @example
   * 0x301fdfbdbf00***
   */
  sessionId?: string;
  /**
   * @remarks
   * The timestamp. It is not available.
   * 
   * @example
   * 1669619383000
   */
  timestamp?: string;
  /**
   * @remarks
   * The type of the trajectory. Valid values:
   * 
   * *   Push
   * *   Pull
   * *   Notify
   * 
   * @example
   * Push
   */
  traceType?: string;
  /**
   * @remarks
   * The time to live (TTL).
   * 
   * @example
   * 0
   */
  ttl?: number;
  /**
   * @remarks
   * Indicates whether the monitoring feature is enabled.
   * 
   * @example
   * true
   */
  watch?: boolean;
  static names(): { [key: string]: string } {
    return {
      acl: 'Acl',
      dataType: 'DataType',
      eventType: 'EventType',
      finished: 'Finished',
      logDate: 'LogDate',
      multiSize: 'MultiSize',
      opType: 'OpType',
      path: 'Path',
      result: 'Result',
      sessionId: 'SessionId',
      timestamp: 'Timestamp',
      traceType: 'TraceType',
      ttl: 'Ttl',
      watch: 'Watch',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acl: 'string',
      dataType: 'string',
      eventType: 'string',
      finished: 'boolean',
      logDate: 'string',
      multiSize: 'number',
      opType: 'string',
      path: 'string',
      result: 'string',
      sessionId: 'string',
      timestamp: 'string',
      traceType: 'string',
      ttl: 'number',
      watch: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListZnodeChildrenResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The data of the node.
   * 
   * @example
   * cluster
   */
  data?: string;
  /**
   * @remarks
   * Indicates whether the node information was returned. Valid values:
   * 
   * *   `true`: The node information was returned.
   * *   `false`: The node information failed to be returned.
   * 
   * @example
   * true
   */
  dir?: boolean;
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * mse-bc1a29b0-160230875****-reg-center-0-1
   */
  name?: string;
  /**
   * @remarks
   * The path of the node.
   * 
   * @example
   * /zookeeper
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      dir: 'Dir',
      name: 'Name',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      dir: 'boolean',
      name: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyGovernanceKubernetesClusterRequestNamespaceInfos extends $tea.Model {
  /**
   * @remarks
   * The microservice namespace. If you do not specify this parameter, Microservice Governance is not enabled for the namespace.
   * 
   * @example
   * default
   */
  mseNamespace?: string;
  /**
   * @remarks
   * The name of the Kubernetes namespace.
   * 
   * @example
   * default
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      mseNamespace: 'MseNamespace',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mseNamespace: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PullServicesResponseBodyDataServices extends $tea.Model {
  /**
   * @remarks
   * The name of the group.
   * 
   * @example
   * test
   */
  groupName?: string;
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * public
   */
  namespace?: string;
  /**
   * @remarks
   * The ID of the service source.
   * 
   * @example
   * 1
   */
  sourceId?: string;
  /**
   * @remarks
   * The type of the service source.
   * 
   * @example
   * MSE
   */
  sourceType?: string;
  static names(): { [key: string]: string } {
    return {
      groupName: 'GroupName',
      name: 'Name',
      namespace: 'Namespace',
      sourceId: 'SourceId',
      sourceType: 'SourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupName: 'string',
      name: 'string',
      namespace: 'string',
      sourceId: 'string',
      sourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PullServicesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The name of the group.
   * 
   * @example
   * test
   */
  groupName?: string;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The alias of the namespace.
   * 
   * @example
   * public
   */
  namespaceShowName?: string;
  /**
   * @remarks
   * The information about services.
   */
  services?: PullServicesResponseBodyDataServices[];
  static names(): { [key: string]: string } {
    return {
      groupName: 'GroupName',
      namespace: 'Namespace',
      namespaceShowName: 'NamespaceShowName',
      services: 'Services',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupName: 'string',
      namespace: 'string',
      namespaceShowName: 'string',
      services: { 'type': 'array', 'itemType': PullServicesResponseBodyDataServices },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems extends $tea.Model {
  cond?: string;
  datum?: string;
  divisor?: number;
  name?: string;
  nameList?: string[];
  operator?: string;
  rate?: number;
  remainder?: number;
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      cond: 'cond',
      datum: 'datum',
      divisor: 'divisor',
      name: 'name',
      nameList: 'nameList',
      operator: 'operator',
      rate: 'rate',
      remainder: 'remainder',
      type: 'type',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cond: 'string',
      datum: 'string',
      divisor: 'number',
      name: 'string',
      nameList: { 'type': 'array', 'itemType': 'string' },
      operator: 'string',
      rate: 'number',
      remainder: 'number',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAllSwimmingLaneResponseBodyDataEntryRules extends $tea.Model {
  condition?: string;
  path?: string;
  paths?: string[];
  restItems?: QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems[];
  static names(): { [key: string]: string } {
    return {
      condition: 'condition',
      path: 'path',
      paths: 'paths',
      restItems: 'restItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      condition: 'string',
      path: 'string',
      paths: { 'type': 'array', 'itemType': 'string' },
      restItems: { 'type': 'array', 'itemType': QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAllSwimmingLaneResponseBodyDataGatewaySwimmingLaneRouteConditions extends $tea.Model {
  /**
   * @example
   * PRE
   */
  cond?: string;
  /**
   * @example
   * name
   */
  name?: string;
  nameList?: string[];
  /**
   * @example
   * header
   */
  type?: string;
  /**
   * @example
   * xiaoming
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      cond: 'Cond',
      name: 'Name',
      nameList: 'NameList',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cond: 'string',
      name: 'string',
      nameList: { 'type': 'array', 'itemType': 'string' },
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAllSwimmingLaneResponseBodyDataGatewaySwimmingLaneRouteRouteIndependentPercentageList extends $tea.Model {
  percentage?: string;
  routeId?: string;
  static names(): { [key: string]: string } {
    return {
      percentage: 'Percentage',
      routeId: 'RouteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      percentage: 'string',
      routeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAllSwimmingLaneResponseBodyDataGatewaySwimmingLaneRoute extends $tea.Model {
  /**
   * @example
   * 0
   */
  canaryModel?: number;
  conditions?: QueryAllSwimmingLaneResponseBodyDataGatewaySwimmingLaneRouteConditions[];
  /**
   * @example
   * 1
   */
  gatewayId?: number;
  /**
   * @example
   * gw-84efde2ee1464260bdb17a5b****
   */
  gatewayUniqueId?: string;
  /**
   * @example
   * 20
   */
  percentage?: number;
  routeIdList?: number[];
  routeIndependentPercentageEnable?: string;
  routeIndependentPercentageList?: QueryAllSwimmingLaneResponseBodyDataGatewaySwimmingLaneRouteRouteIndependentPercentageList[];
  static names(): { [key: string]: string } {
    return {
      canaryModel: 'CanaryModel',
      conditions: 'Conditions',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      percentage: 'Percentage',
      routeIdList: 'RouteIdList',
      routeIndependentPercentageEnable: 'RouteIndependentPercentageEnable',
      routeIndependentPercentageList: 'RouteIndependentPercentageList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canaryModel: 'number',
      conditions: { 'type': 'array', 'itemType': QueryAllSwimmingLaneResponseBodyDataGatewaySwimmingLaneRouteConditions },
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      percentage: 'number',
      routeIdList: { 'type': 'array', 'itemType': 'number' },
      routeIndependentPercentageEnable: 'string',
      routeIndependentPercentageList: { 'type': 'array', 'itemType': QueryAllSwimmingLaneResponseBodyDataGatewaySwimmingLaneRouteRouteIndependentPercentageList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAllSwimmingLaneResponseBodyData extends $tea.Model {
  entryRules?: QueryAllSwimmingLaneResponseBodyDataEntryRules[];
  gatewaySwimmingLaneRoute?: QueryAllSwimmingLaneResponseBodyDataGatewaySwimmingLaneRoute;
  groupId?: string;
  /**
   * @example
   * 123
   */
  id?: number;
  /**
   * @example
   * Client
   */
  messageQueueFilterSide?: string;
  messageQueueGrayEnable?: boolean;
  /**
   * @example
   * swimmingGroup
   */
  name?: string;
  /**
   * @example
   * default
   */
  namespace?: string;
  pathIndependentPercentageEnable?: boolean;
  recordCanaryDetail?: boolean;
  /**
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  tag?: string;
  /**
   * @example
   * 12345
   */
  userId?: string;
  enableRules?: boolean;
  gmtCreate?: string;
  gmtModified?: string;
  static names(): { [key: string]: string } {
    return {
      entryRules: 'EntryRules',
      gatewaySwimmingLaneRoute: 'GatewaySwimmingLaneRoute',
      groupId: 'GroupId',
      id: 'Id',
      messageQueueFilterSide: 'MessageQueueFilterSide',
      messageQueueGrayEnable: 'MessageQueueGrayEnable',
      name: 'Name',
      namespace: 'Namespace',
      pathIndependentPercentageEnable: 'PathIndependentPercentageEnable',
      recordCanaryDetail: 'RecordCanaryDetail',
      regionId: 'RegionId',
      tag: 'Tag',
      userId: 'UserId',
      enableRules: 'enableRules',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      entryRules: { 'type': 'array', 'itemType': QueryAllSwimmingLaneResponseBodyDataEntryRules },
      gatewaySwimmingLaneRoute: QueryAllSwimmingLaneResponseBodyDataGatewaySwimmingLaneRoute,
      groupId: 'string',
      id: 'number',
      messageQueueFilterSide: 'string',
      messageQueueGrayEnable: 'boolean',
      name: 'string',
      namespace: 'string',
      pathIndependentPercentageEnable: 'boolean',
      recordCanaryDetail: 'boolean',
      regionId: 'string',
      tag: 'string',
      userId: 'string',
      enableRules: 'boolean',
      gmtCreate: 'string',
      gmtModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAllSwimmingLaneGroupResponseBodyData extends $tea.Model {
  /**
   * @example
   * abcde@abcde,abcde@abcde
   */
  appIds?: string;
  canaryModel?: number;
  /**
   * @example
   * mse:abcde@abcde
   */
  entryApp?: string;
  /**
   * @example
   * 123
   */
  id?: number;
  /**
   * @example
   * Client
   */
  messageQueueFilterSide?: string;
  messageQueueGrayEnable?: boolean;
  /**
   * @example
   * swimmingGroup
   */
  name?: string;
  /**
   * @example
   * default
   */
  namespace?: string;
  paths?: string;
  recordCanaryDetail?: boolean;
  /**
   * @example
   * cn-hangzhou
   */
  region?: string;
  swimVersion?: number;
  /**
   * @example
   * 12345
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      appIds: 'AppIds',
      canaryModel: 'CanaryModel',
      entryApp: 'EntryApp',
      id: 'Id',
      messageQueueFilterSide: 'MessageQueueFilterSide',
      messageQueueGrayEnable: 'MessageQueueGrayEnable',
      name: 'Name',
      namespace: 'Namespace',
      paths: 'Paths',
      recordCanaryDetail: 'RecordCanaryDetail',
      region: 'Region',
      swimVersion: 'SwimVersion',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appIds: 'string',
      canaryModel: 'number',
      entryApp: 'string',
      id: 'number',
      messageQueueFilterSide: 'string',
      messageQueueGrayEnable: 'boolean',
      name: 'string',
      namespace: 'string',
      paths: 'string',
      recordCanaryDetail: 'boolean',
      region: 'string',
      swimVersion: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBusinessLocationsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The Chinese name of the region.
   * 
   * @example
   * China (Shanghai)
   */
  cnName?: string;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * China (Shanghai)
   */
  description?: string;
  /**
   * @remarks
   * The Chinese name of the district.
   * 
   * @example
   * Asia Pacific
   */
  districtCnName?: string;
  /**
   * @remarks
   * The English name of the district.
   * 
   * @example
   * Asia Pacific
   */
  districtEnName?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * asia-pacific
   */
  districtId?: string;
  /**
   * @remarks
   * The ordering information of the district.
   * 
   * @example
   * 101
   */
  districtOrdering?: number;
  /**
   * @remarks
   * The display name of the district.
   * 
   * @example
   * Asia Pacific
   */
  districtShowName?: string;
  /**
   * @remarks
   * The complete description of the region.
   * 
   * @example
   * China East 2 (Shanghai)
   */
  enDescription?: string;
  /**
   * @remarks
   * The English name of the region.
   * 
   * @example
   * China (Shanghai)
   */
  enName?: string;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * cn-shanghai
   */
  name?: string;
  /**
   * @remarks
   * The ordering information.
   * 
   * @example
   * 6
   */
  ordering?: number;
  /**
   * @remarks
   * The display name.
   * 
   * @example
   * China (Shanghai)
   */
  showName?: string;
  /**
   * @remarks
   * The type.
   * 
   * @example
   * region
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      cnName: 'CnName',
      description: 'Description',
      districtCnName: 'DistrictCnName',
      districtEnName: 'DistrictEnName',
      districtId: 'DistrictId',
      districtOrdering: 'DistrictOrdering',
      districtShowName: 'DistrictShowName',
      enDescription: 'EnDescription',
      enName: 'EnName',
      name: 'Name',
      ordering: 'Ordering',
      showName: 'ShowName',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cnName: 'string',
      description: 'string',
      districtCnName: 'string',
      districtEnName: 'string',
      districtId: 'string',
      districtOrdering: 'number',
      districtShowName: 'string',
      enDescription: 'string',
      enName: 'string',
      name: 'string',
      ordering: 'number',
      showName: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClusterDetailResponseBodyDataInstanceModels extends $tea.Model {
  /**
   * @remarks
   * The timestamp when the instance was created.
   * 
   * @example
   * 1578575377732
   */
  creationTimestamp?: string;
  /**
   * @remarks
   * The health status of the instance.
   * 
   * @example
   * Running
   */
  healthStatus?: string;
  /**
   * @remarks
   * The public IP address.
   * 
   * @example
   * 47.98.XX.XX
   */
  internetIp?: string;
  /**
   * @remarks
   * The IP address of the instance.
   * 
   * @example
   * 10.12.XX.XX
   */
  ip?: string;
  /**
   * @remarks
   * The name of the pod.
   * 
   * @example
   * mse-7413****-159616656****-reg-center-0-0
   */
  podName?: string;
  /**
   * @remarks
   * The role.
   * 
   * @example
   * Peer
   */
  role?: string;
  /**
   * @remarks
   * The single-thread IP address.
   * 
   * @example
   * 192.168.XX.XX
   */
  singleTunnelVip?: string;
  /**
   * @remarks
   * The zone ID.
   * 
   * @example
   * cn-shanghai-f
   */
  zone?: string;
  static names(): { [key: string]: string } {
    return {
      creationTimestamp: 'CreationTimestamp',
      healthStatus: 'HealthStatus',
      internetIp: 'InternetIp',
      ip: 'Ip',
      podName: 'PodName',
      role: 'Role',
      singleTunnelVip: 'SingleTunnelVip',
      zone: 'Zone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTimestamp: 'string',
      healthStatus: 'string',
      internetIp: 'string',
      ip: 'string',
      podName: 'string',
      role: 'string',
      singleTunnelVip: 'string',
      zone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClusterDetailResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The whitelist.
   * 
   * @example
   * []
   */
  aclEntryList?: string;
  /**
   * @remarks
   * The ID of the whitelist.
   * 
   * @example
   * acl-bp17020kiqvzutwwj****
   */
  aclId?: string;
  /**
   * @remarks
   * The application version.
   * 
   * @example
   * 1.2.1
   */
  appVersion?: string;
  /**
   * @remarks
   * The billing method, such as subscription or pay-as-you-go.
   * 
   * @example
   * Pay-as-you-go
   */
  chargeType?: string;
  /**
   * @remarks
   * The alias of the instance.
   * 
   * @example
   * mse-7413****
   */
  clusterAliasName?: string;
  /**
   * @remarks
   * The name of the instance.
   * 
   * @example
   * mse-bc1a29b0-160230875****
   */
  clusterName?: string;
  /**
   * @remarks
   * The engine specifications.
   * 
   * @example
   * MSE_SC_1_2_200_c
   */
  clusterSpecification?: string;
  /**
   * @remarks
   * The type of the instance. Valid values: ZooKeeper, Nacos-Ans, and Eureka.
   * 
   * @example
   * Nacos-Ans
   */
  clusterType?: string;
  /**
   * @remarks
   * The version of the instance.
   * 
   * @example
   * 1.2.1
   */
  clusterVersion?: string;
  /**
   * @remarks
   * The network connection type. Valid values:
   * 
   * *   slb
   * *   eni
   * 
   * @example
   * slb
   */
  connectionType?: string;
  /**
   * @remarks
   * The number of vCPUs.
   * 
   * @example
   * 1
   */
  cpu?: number;
  /**
   * @remarks
   * The time when the instance was created.
   * 
   * @example
   * 2020-07-31 11:36:08
   */
  createTime?: string;
  /**
   * @remarks
   * The capacity of the disk. Unit: GB.
   * 
   * @example
   * 60
   */
  diskCapacity?: number;
  /**
   * @remarks
   * The type of the disk.
   * 
   * @example
   * alicloud-disk-ssd-multi-zone
   */
  diskType?: string;
  /**
   * @remarks
   * The health status of the instance.
   * 
   * @example
   * RESTART_SUCCESS
   */
  healthStatus?: string;
  /**
   * @remarks
   * The amount of time taken to create the instance. Unit: milliseconds.
   * 
   * @example
   * 98408
   */
  initCostTime?: number;
  /**
   * @remarks
   * The creation status of the instance.
   * 
   * @example
   * RESTART_SUCCESS
   */
  initStatus?: string;
  /**
   * @remarks
   * The number of instance nodes.
   * 
   * @example
   * 3
   */
  instanceCount?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * mse-cn-st21ri2****
   */
  instanceId?: string;
  /**
   * @remarks
   * The list of instance nodes.
   */
  instanceModels?: QueryClusterDetailResponseBodyDataInstanceModels[];
  /**
   * @remarks
   * The public IP address of the instance.
   * 
   * @example
   * 47.98.XX.XX
   */
  internetAddress?: string;
  /**
   * @remarks
   * The public endpoint of the instance.
   * 
   * @example
   * mse-7413****-p.eureka.mse.aliyuncs.com
   */
  internetDomain?: string;
  /**
   * @remarks
   * The private port number.
   * 
   * @example
   * 8761
   */
  internetPort?: string;
  /**
   * @remarks
   * The internal IP address.
   * 
   * @example
   * 192.168.XX.XX
   */
  intranetAddress?: string;
  /**
   * @remarks
   * The internal endpoint of the instance.
   * 
   * @example
   * mse-7413****-eureka.mse.aliyuncs.com
   */
  intranetDomain?: string;
  /**
   * @remarks
   * The private port number.
   * 
   * @example
   * 8761
   */
  intranetPort?: string;
  /**
   * @remarks
   * The size of the memory. Unit: GB.
   * 
   * @example
   * 2
   */
  memoryCapacity?: number;
  /**
   * @remarks
   * The edition of Microservices Engine (MSE).
   * 
   * @example
   * mse_basic
   */
  mseVersion?: string;
  /**
   * @remarks
   * The network type of the instance. Valid values:
   * 
   * *   `privatenet`: VPC
   * *   `pubnet`: Internet
   * 
   * @example
   * privatenet
   */
  netType?: string;
  /**
   * @remarks
   * The version number of the original order.
   * 
   * @example
   * 1.2.0
   */
  orderClusterVersion?: string;
  /**
   * @remarks
   * The billing method, such as subscription or pay-as-you-go.
   * 
   * @example
   * Pay-as-you-go
   */
  payInfo?: string;
  /**
   * @remarks
   * The public bandwidth. Unit: Mbit/s.\\
   * Valid values: 0 to 5000. The value 0 indicates no access to the Internet.
   * 
   * @example
   * 3
   */
  pubNetworkFlow?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-aek2dhgysj*****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The tags that are attached to the instance.
   */
  tags?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the vSwitch.
   * 
   * @example
   * vsw-xxx-xxxx
   */
  vSwitchId?: string;
  /**
   * @remarks
   * The ID of the virtual private cloud (VPC).
   * 
   * @example
   * vpc-bp1hcg467ekqsv0zr****
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      aclEntryList: 'AclEntryList',
      aclId: 'AclId',
      appVersion: 'AppVersion',
      chargeType: 'ChargeType',
      clusterAliasName: 'ClusterAliasName',
      clusterName: 'ClusterName',
      clusterSpecification: 'ClusterSpecification',
      clusterType: 'ClusterType',
      clusterVersion: 'ClusterVersion',
      connectionType: 'ConnectionType',
      cpu: 'Cpu',
      createTime: 'CreateTime',
      diskCapacity: 'DiskCapacity',
      diskType: 'DiskType',
      healthStatus: 'HealthStatus',
      initCostTime: 'InitCostTime',
      initStatus: 'InitStatus',
      instanceCount: 'InstanceCount',
      instanceId: 'InstanceId',
      instanceModels: 'InstanceModels',
      internetAddress: 'InternetAddress',
      internetDomain: 'InternetDomain',
      internetPort: 'InternetPort',
      intranetAddress: 'IntranetAddress',
      intranetDomain: 'IntranetDomain',
      intranetPort: 'IntranetPort',
      memoryCapacity: 'MemoryCapacity',
      mseVersion: 'MseVersion',
      netType: 'NetType',
      orderClusterVersion: 'OrderClusterVersion',
      payInfo: 'PayInfo',
      pubNetworkFlow: 'PubNetworkFlow',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tags: 'Tags',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aclEntryList: 'string',
      aclId: 'string',
      appVersion: 'string',
      chargeType: 'string',
      clusterAliasName: 'string',
      clusterName: 'string',
      clusterSpecification: 'string',
      clusterType: 'string',
      clusterVersion: 'string',
      connectionType: 'string',
      cpu: 'number',
      createTime: 'string',
      diskCapacity: 'number',
      diskType: 'string',
      healthStatus: 'string',
      initCostTime: 'number',
      initStatus: 'string',
      instanceCount: 'number',
      instanceId: 'string',
      instanceModels: { 'type': 'array', 'itemType': QueryClusterDetailResponseBodyDataInstanceModels },
      internetAddress: 'string',
      internetDomain: 'string',
      internetPort: 'string',
      intranetAddress: 'string',
      intranetDomain: 'string',
      intranetPort: 'string',
      memoryCapacity: 'number',
      mseVersion: 'string',
      netType: 'string',
      orderClusterVersion: 'string',
      payInfo: 'string',
      pubNetworkFlow: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      tags: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      vSwitchId: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClusterDiskSpecificationResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The maximum disk capacity. Unit: GB.
   * 
   * @example
   * 500
   */
  max?: number;
  /**
   * @remarks
   * The minimum disk capacity. Unit: GB.
   * 
   * @example
   * 1
   */
  min?: number;
  /**
   * @remarks
   * The step size of the disk capacity.
   * 
   * @example
   * 2
   */
  step?: number;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
      step: 'Step',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'number',
      min: 'number',
      step: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClusterInfoResponseBodyDataInstanceModels extends $tea.Model {
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * null
   */
  creationTimestamp?: string;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * null
   */
  healthStatus?: string;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * null
   */
  internetIp?: string;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * null
   */
  ip?: string;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * null
   */
  podName?: string;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * null
   */
  role?: string;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * null
   */
  singleTunnelVip?: string;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * null
   */
  zone?: string;
  static names(): { [key: string]: string } {
    return {
      creationTimestamp: 'CreationTimestamp',
      healthStatus: 'HealthStatus',
      internetIp: 'InternetIp',
      ip: 'Ip',
      podName: 'PodName',
      role: 'Role',
      singleTunnelVip: 'SingleTunnelVip',
      zone: 'Zone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTimestamp: 'string',
      healthStatus: 'string',
      internetIp: 'string',
      ip: 'string',
      podName: 'string',
      role: 'string',
      singleTunnelVip: 'string',
      zone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClusterInfoResponseBodyDataMaintenancePeriod extends $tea.Model {
  /**
   * @remarks
   * The start time of the O\\&M time window.
   * 
   * @example
   * 02:00
   */
  endTime?: string;
  /**
   * @remarks
   * The end time of the O\\&M time window.
   * 
   * @example
   * 06:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClusterInfoResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The public IP address whitelist.
   * 
   * @example
   * ["127.0.0.0/32"]
   */
  aclEntryList?: string;
  /**
   * @remarks
   * The ID of the instance in the public IP address whitelist.
   * 
   * @example
   * acl-bp144q24cgqvzckmxxxx
   */
  aclId?: string;
  /**
   * @remarks
   * The version of the instance.
   * 
   * @example
   * 2.1.0
   */
  appVersion?: string;
  canUpdate?: boolean;
  /**
   * @remarks
   * The billing method, such as subscription or pay-as-you-go.
   * 
   * @example
   * POSTPAY
   */
  chargeType?: string;
  /**
   * @remarks
   * The alias of the instance.
   * 
   * @example
   * Development environment
   */
  clusterAliasName?: string;
  /**
   * @remarks
   * The full name of the instance.
   * 
   * @example
   * mse-74355150-xxxxxxx
   */
  clusterName?: string;
  /**
   * @remarks
   * The engine specifications.
   * 
   * @example
   * MSE_SC_2_4_60_c
   */
  clusterSpecification?: string;
  /**
   * @remarks
   * The type of the instance. Valid values: ZooKeeper, Nacos-Ans, and Eureka.
   * 
   * @example
   * Nacos-Ans
   */
  clusterType?: string;
  /**
   * @remarks
   * The version of the order.
   * 
   * @example
   * NACOS_2_0_0
   */
  clusterVersion?: string;
  /**
   * @remarks
   * A deprecated parameter.
   * 
   * @example
   * null
   */
  connectionType?: string;
  /**
   * @remarks
   * A deprecated parameter.
   * 
   * @example
   * null
   */
  cpu?: number;
  /**
   * @remarks
   * The time when the instance was created.
   * 
   * @example
   * 2022-12-15 10:02:07
   */
  createTime?: string;
  /**
   * @remarks
   * A deprecated parameter.
   * 
   * @example
   * null
   */
  diskCapacity?: number;
  /**
   * @remarks
   * A deprecated parameter.
   * 
   * @example
   * null
   */
  diskType?: string;
  /**
   * @remarks
   * The ID of the instance that is associated with the Elastic IP Address (EIP).
   * 
   * @example
   * eip-bp1uujshd5funmyy8rcl9
   */
  eipInstanceId?: string;
  /**
   * @remarks
   * The time when the subscription instance expires.
   * 
   * @example
   * 2021-08-01 00:00:00
   */
  endDate?: string;
  /**
   * @remarks
   * The zones to which the current cluster can be distributed.
   */
  expectZones?: string[];
  /**
   * @remarks
   * The status of the instance.
   * 
   * @example
   * INIT_SUCCESS
   */
  healthStatus?: string;
  /**
   * @remarks
   * The time that is required to initialize the instance. Unit: milliseconds.
   * 
   * @example
   * 53353
   */
  initCostTime?: number;
  /**
   * @remarks
   * The initial status of the instance.
   * 
   * @example
   * INIT_SUCCESS
   */
  initStatus?: string;
  /**
   * @remarks
   * The number of instance nodes.
   * 
   * @example
   * 3
   */
  instanceCount?: number;
  /**
   * @remarks
   * The ID of the instance
   * 
   * @example
   * mse-cn-st21ri2****
   */
  instanceId?: string;
  /**
   * @remarks
   * The reserved structure.
   */
  instanceModels?: QueryClusterInfoResponseBodyDataInstanceModels[];
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * null
   */
  internetAddress?: string;
  /**
   * @remarks
   * The public endpoint.
   * 
   * @example
   * mse-xxxxxx-p.nacos-ans.mse.aliyuncs.com
   */
  internetDomain?: string;
  /**
   * @remarks
   * The instance ports that are accessible over the Internet.
   * 
   * @example
   * 8848,6443,9848,8761
   */
  internetPort?: string;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * null
   */
  intranetAddress?: string;
  /**
   * @remarks
   * The internal endpoint.
   * 
   * @example
   * mse-xxxxx-nacos-ans.mse.aliyuncs.com
   */
  intranetDomain?: string;
  /**
   * @remarks
   * The instance ports that are accessible over an internal network.
   * 
   * @example
   * 8848,6443,9848,8761
   */
  intranetPort?: string;
  /**
   * @remarks
   * The O\\&M time window.
   */
  maintenancePeriod?: QueryClusterInfoResponseBodyDataMaintenancePeriod;
  /**
   * @remarks
   * A deprecated parameter.
   * 
   * @example
   * null
   */
  memoryCapacity?: number;
  /**
   * @remarks
   * The version of the instance.
   * 
   * @example
   * mse_pro
   */
  mseVersion?: string;
  /**
   * @remarks
   * The network connection type of the instance.
   * 
   * @example
   * privatenet
   */
  netType?: string;
  /**
   * @remarks
   * The billing method.
   * 
   * @example
   * Pay-as-you-go
   */
  payInfo?: string;
  /**
   * @remarks
   * The public bandwidth. Unit: Mbit/s.\\
   * Valid values: 0 to 5000. The value 0 indicates no access to the Internet.
   * 
   * @example
   * 1
   */
  pubNetworkFlow?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the security group to which the elastic network interface (ENI) is connected.
   * 
   * @example
   * sg-uf6hgwe067prhg68agfa
   */
  securityGroupId?: string;
  /**
   * @remarks
   * The type of the security group to which the ENI is connected.
   * 
   * @example
   * enterprise
   */
  securityGroupType?: string;
  /**
   * @remarks
   * The tag.
   */
  tags?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the vSwitch.
   * 
   * @example
   * vsw-bp1egfakxxxxx
   */
  vSwitchId?: string;
  versionCode?: string;
  /**
   * @remarks
   * The ID of the VPC where the instance resides.
   * 
   * @example
   * vpc-bp1v5nbauzh8xxxxxxx
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      aclEntryList: 'AclEntryList',
      aclId: 'AclId',
      appVersion: 'AppVersion',
      canUpdate: 'CanUpdate',
      chargeType: 'ChargeType',
      clusterAliasName: 'ClusterAliasName',
      clusterName: 'ClusterName',
      clusterSpecification: 'ClusterSpecification',
      clusterType: 'ClusterType',
      clusterVersion: 'ClusterVersion',
      connectionType: 'ConnectionType',
      cpu: 'Cpu',
      createTime: 'CreateTime',
      diskCapacity: 'DiskCapacity',
      diskType: 'DiskType',
      eipInstanceId: 'EipInstanceId',
      endDate: 'EndDate',
      expectZones: 'ExpectZones',
      healthStatus: 'HealthStatus',
      initCostTime: 'InitCostTime',
      initStatus: 'InitStatus',
      instanceCount: 'InstanceCount',
      instanceId: 'InstanceId',
      instanceModels: 'InstanceModels',
      internetAddress: 'InternetAddress',
      internetDomain: 'InternetDomain',
      internetPort: 'InternetPort',
      intranetAddress: 'IntranetAddress',
      intranetDomain: 'IntranetDomain',
      intranetPort: 'IntranetPort',
      maintenancePeriod: 'MaintenancePeriod',
      memoryCapacity: 'MemoryCapacity',
      mseVersion: 'MseVersion',
      netType: 'NetType',
      payInfo: 'PayInfo',
      pubNetworkFlow: 'PubNetworkFlow',
      regionId: 'RegionId',
      securityGroupId: 'SecurityGroupId',
      securityGroupType: 'SecurityGroupType',
      tags: 'Tags',
      vSwitchId: 'VSwitchId',
      versionCode: 'VersionCode',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aclEntryList: 'string',
      aclId: 'string',
      appVersion: 'string',
      canUpdate: 'boolean',
      chargeType: 'string',
      clusterAliasName: 'string',
      clusterName: 'string',
      clusterSpecification: 'string',
      clusterType: 'string',
      clusterVersion: 'string',
      connectionType: 'string',
      cpu: 'number',
      createTime: 'string',
      diskCapacity: 'number',
      diskType: 'string',
      eipInstanceId: 'string',
      endDate: 'string',
      expectZones: { 'type': 'array', 'itemType': 'string' },
      healthStatus: 'string',
      initCostTime: 'number',
      initStatus: 'string',
      instanceCount: 'number',
      instanceId: 'string',
      instanceModels: { 'type': 'array', 'itemType': QueryClusterInfoResponseBodyDataInstanceModels },
      internetAddress: 'string',
      internetDomain: 'string',
      internetPort: 'string',
      intranetAddress: 'string',
      intranetDomain: 'string',
      intranetPort: 'string',
      maintenancePeriod: QueryClusterInfoResponseBodyDataMaintenancePeriod,
      memoryCapacity: 'number',
      mseVersion: 'string',
      netType: 'string',
      payInfo: 'string',
      pubNetworkFlow: 'string',
      regionId: 'string',
      securityGroupId: 'string',
      securityGroupType: 'string',
      tags: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      vSwitchId: 'string',
      versionCode: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClusterSpecificationResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The engine specifications that can be used.
   * 
   * @example
   * MSE_SC_1_2_200_c
   */
  clusterSpecificationName?: string;
  /**
   * @remarks
   * The number of vCPUs in the specifications.
   * 
   * @example
   * 1
   */
  cpuCapacity?: string;
  /**
   * @remarks
   * The memory size in the specifications. Unit: GB.
   * 
   * @example
   * 2
   */
  memoryCapacity?: string;
  static names(): { [key: string]: string } {
    return {
      clusterSpecificationName: 'ClusterSpecificationName',
      cpuCapacity: 'CpuCapacity',
      memoryCapacity: 'MemoryCapacity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterSpecificationName: 'string',
      cpuCapacity: 'string',
      memoryCapacity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConfigResponseBodyDataNacosRunningEnv extends $tea.Model {
  /**
   * @remarks
   * Indicates whether empty list protection is enabled.
   * 
   * @example
   * true
   */
  emptyProtect?: boolean;
  static names(): { [key: string]: string } {
    return {
      emptyProtect: 'emptyProtect',
    };
  }

  static types(): { [key: string]: any } {
    return {
      emptyProtect: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConfigResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Indicates whether Simple Authentication and Security Layer (SASL) forced identity authentication is enabled for the ZooKeeper instance.
   */
  authEnabled?: boolean;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * none
   */
  autopurgePurgeInterval?: string;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * none
   */
  autopurgeSnapRetainCount?: string;
  /**
   * @remarks
   * The name of the instance.
   * 
   * @example
   * name
   */
  clusterName?: string;
  /**
   * @remarks
   * Indicates whether RAM authentication of a configuration center is enabled. This parameter is valid for Nacos instances. Valid values:
   * 
   * *   `true`: enabled.
   * *   `false`: disabled.
   * 
   * @example
   * true
   */
  configAuthEnabled?: boolean;
  /**
   * @remarks
   * Indicates whether RAM authentication is supported by a configuration center of the instance. This parameter is valid for Nacos instances. Valid values:
   * 
   * *   `true`: supported.
   * *   `false`: not supported.
   * 
   * @example
   * true
   */
  configAuthSupported?: boolean;
  /**
   * @remarks
   * The maximum size of contents in a configuration. Unit: KB.
   * 
   * @example
   * 100
   */
  configContentLimit?: number;
  /**
   * @remarks
   * Indicates whether configuration encryption of a configuration center is enabled by the instance. This parameter is valid for Nacos instances. Valid values:
   * 
   * *   `true`: enabled.
   * *   `false`: disabled.
   * 
   * @example
   * true
   */
  configSecretEnabled?: boolean;
  /**
   * @remarks
   * Indicates whether configuration encryption of a configuration center is supported by the instance. This parameter is valid for Nacos instances. Valid values:
   * 
   * *   `true`: supported.
   * *   `false`: not supported.
   * 
   * @example
   * true
   */
  configSecretSupported?: boolean;
  /**
   * @remarks
   * Indicates whether the Nacos open source console is enabled.
   * 
   * @example
   * true
   */
  consoleUIEnabled?: boolean;
  enable4lw?: boolean;
  /**
   * @remarks
   * Indicates whether access port 8761 was enabled for Eureka. If this port is disabled, applications cannot use the Eureka protocol for service registration and discovery.
   * 
   * @example
   * true
   */
  eurekaSupported?: boolean;
  /**
   * @remarks
   * Indicates whether the time to live (TTL) configuration is enabled. This parameter is valid for ZooKeeper instances.
   * 
   * @example
   * true
   */
  extendedTypesEnable?: boolean;
  /**
   * @remarks
   * The maximum connection duration of the instance. Unit: seconds. This parameter is valid for ZooKeeper instances.
   * 
   * @example
   * 100
   */
  initLimit?: string;
  /**
   * @remarks
   * The maximum amount of data on each node. This parameter is valid for ZooKeeper instances. Unit: bytes.
   * 
   * @example
   * 1
   */
  juteMaxbuffer?: string;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * none
   */
  jvmFlagsCustom?: string;
  /**
   * @remarks
   * Indicates whether Mesh Configuration Protocol (MCP) is enabled. This parameter is valid for Nacos instances. Valid values:
   * 
   * *   `true`: enabled.
   * *   `false`: disabled.
   * 
   * @example
   * true
   */
  MCPEnabled?: boolean;
  /**
   * @remarks
   * Indicates whether MCP is supported. This parameter is valid for Nacos instances. Valid values:
   * 
   * *   `true`: supported.
   * *   `false`: not supported.
   * 
   * @example
   * true
   */
  MCPSupported?: boolean;
  /**
   * @remarks
   * The number of connections between a client and a server. This parameter is valid for ZooKeeper instances.\\
   * If this parameter is set to 0, no limits are imposed on the number of connections.
   * 
   * @example
   * 0
   */
  maxClientCnxns?: string;
  /**
   * @remarks
   * The maximum timeout period. This parameter is valid for ZooKeeper instances.
   * 
   * @example
   * -1
   */
  maxSessionTimeout?: string;
  /**
   * @remarks
   * The minimum timeout period. This parameter is valid for ZooKeeper instances.
   * 
   * @example
   * -1
   */
  minSessionTimeout?: string;
  /**
   * @remarks
   * The runtime configuration of the Nacos instance.
   */
  nacosRunningEnv?: QueryConfigResponseBodyDataNacosRunningEnv;
  /**
   * @remarks
   * Indicates whether RAM authentication of a registry is enabled. This parameter is valid for Nacos instances. Valid values:
   * 
   * *   `true`: enabled.
   * *   `false`: disabled.
   * 
   * @example
   * false
   */
  namingAuthEnabled?: boolean;
  /**
   * @remarks
   * Indicates whether RAM authentication of services is supported by the instance. This parameter is valid for Nacos instances. Valid values:
   * 
   * *   `true`: supported.
   * *   `false`: not supported.
   * 
   * @example
   * true
   */
  namingAuthSupported?: boolean;
  /**
   * @remarks
   * Indicates whether service creation is supported for the instance. This parameter is valid for Nacos instances. Valid values:
   * 
   * *   `true`: supported.
   * *   `false`: not supported.
   * 
   * @example
   * true
   */
  namingCreateServiceSupported?: boolean;
  /**
   * @remarks
   * Indicates whether super permissions are enabled. This parameter is valid for ZooKeeper instances. Valid values:
   * 
   * *   `true`: enabled.
   * *   `false`: disabled.
   * 
   * @example
   * true
   */
  openSuperAcl?: boolean;
  /**
   * @remarks
   * The password that corresponds to the username. This parameter is valid only if OpenSuperAcl is set to true.
   * 
   * @example
   * password
   */
  passWord?: string;
  /**
   * @remarks
   * Indicates whether the instance was restarted and new configurations have taken effect. Valid values:
   * 
   * *   `true`: The restart was successful.
   * *   `false`: The restart failed.
   * 
   * @example
   * true
   */
  restartFlag?: boolean;
  /**
   * @remarks
   * The frequency for generating snapshots. This parameter is valid for ZooKeeper instances.
   * 
   * @example
   * 100000
   */
  snapshotCount?: string;
  /**
   * @remarks
   * The connection timeout period of the instance. This parameter is valid for ZooKeeper instances. Unit: seconds.
   * 
   * @example
   * 10
   */
  syncLimit?: string;
  /**
   * @remarks
   * MSE Nacos supports TLS transmission link encryption since version 2.1.2.1. Nacos clients must be upgraded to version 2.2.1 or later. After TLS is enabled, the system performance will decrease by about 10%. You must evaluate the system capacity. For more information about the relevant operations, see Nacos TLS transmission encryption.
   * 
   * @example
   * true
   */
  TLSEnabled?: boolean;
  /**
   * @remarks
   * The time unit of the engine. This parameter is valid for ZooKeeper instances. Default value: 2000. Unit: milliseconds.
   * 
   * @example
   * 2000
   */
  tickTime?: string;
  /**
   * @remarks
   * The username of the user. This parameter is valid only if OpenSuperAcl is set to true.
   * 
   * @example
   * name
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      authEnabled: 'AuthEnabled',
      autopurgePurgeInterval: 'AutopurgePurgeInterval',
      autopurgeSnapRetainCount: 'AutopurgeSnapRetainCount',
      clusterName: 'ClusterName',
      configAuthEnabled: 'ConfigAuthEnabled',
      configAuthSupported: 'ConfigAuthSupported',
      configContentLimit: 'ConfigContentLimit',
      configSecretEnabled: 'ConfigSecretEnabled',
      configSecretSupported: 'ConfigSecretSupported',
      consoleUIEnabled: 'ConsoleUIEnabled',
      enable4lw: 'Enable4lw',
      eurekaSupported: 'EurekaSupported',
      extendedTypesEnable: 'ExtendedTypesEnable',
      initLimit: 'InitLimit',
      juteMaxbuffer: 'JuteMaxbuffer',
      jvmFlagsCustom: 'JvmFlagsCustom',
      MCPEnabled: 'MCPEnabled',
      MCPSupported: 'MCPSupported',
      maxClientCnxns: 'MaxClientCnxns',
      maxSessionTimeout: 'MaxSessionTimeout',
      minSessionTimeout: 'MinSessionTimeout',
      nacosRunningEnv: 'NacosRunningEnv',
      namingAuthEnabled: 'NamingAuthEnabled',
      namingAuthSupported: 'NamingAuthSupported',
      namingCreateServiceSupported: 'NamingCreateServiceSupported',
      openSuperAcl: 'OpenSuperAcl',
      passWord: 'PassWord',
      restartFlag: 'RestartFlag',
      snapshotCount: 'SnapshotCount',
      syncLimit: 'SyncLimit',
      TLSEnabled: 'TLSEnabled',
      tickTime: 'TickTime',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authEnabled: 'boolean',
      autopurgePurgeInterval: 'string',
      autopurgeSnapRetainCount: 'string',
      clusterName: 'string',
      configAuthEnabled: 'boolean',
      configAuthSupported: 'boolean',
      configContentLimit: 'number',
      configSecretEnabled: 'boolean',
      configSecretSupported: 'boolean',
      consoleUIEnabled: 'boolean',
      enable4lw: 'boolean',
      eurekaSupported: 'boolean',
      extendedTypesEnable: 'boolean',
      initLimit: 'string',
      juteMaxbuffer: 'string',
      jvmFlagsCustom: 'string',
      MCPEnabled: 'boolean',
      MCPSupported: 'boolean',
      maxClientCnxns: 'string',
      maxSessionTimeout: 'string',
      minSessionTimeout: 'string',
      nacosRunningEnv: QueryConfigResponseBodyDataNacosRunningEnv,
      namingAuthEnabled: 'boolean',
      namingAuthSupported: 'boolean',
      namingCreateServiceSupported: 'boolean',
      openSuperAcl: 'boolean',
      passWord: 'string',
      restartFlag: 'boolean',
      snapshotCount: 'string',
      syncLimit: 'string',
      TLSEnabled: 'boolean',
      tickTime: 'string',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryGovernanceKubernetesClusterResponseBodyDataResult extends $tea.Model {
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * @example
   * abcdef123456789
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the cluster.
   * 
   * @example
   * example-cluster
   */
  clusterName?: string;
  /**
   * @remarks
   * The version of the cluster.
   * 
   * @example
   * 1.22
   */
  k8sVersion?: string;
  /**
   * @remarks
   * The information about the namespace.
   * 
   * @example
   * [{"Name":"ack-onepilot","Tags":{"name":"ack-onepilot"}}]
   */
  namespaceInfos?: string;
  /**
   * @remarks
   * The time when the pilot component was started.
   * 
   * @example
   * 2022-05-17T05:39:43.000+0000
   */
  pilotStartTime?: string;
  /**
   * @remarks
   * The region where the cluster resides.
   * 
   * @example
   * cn-shanghai
   */
  region?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      k8sVersion: 'K8sVersion',
      namespaceInfos: 'NamespaceInfos',
      pilotStartTime: 'PilotStartTime',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterName: 'string',
      k8sVersion: 'string',
      namespaceInfos: 'string',
      pilotStartTime: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryGovernanceKubernetesClusterResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The details of the data.
   */
  result?: QueryGovernanceKubernetesClusterResponseBodyDataResult[];
  /**
   * @remarks
   * The total number of clusters.
   * 
   * @example
   * 3
   */
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      result: 'Result',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      result: { 'type': 'array', 'itemType': QueryGovernanceKubernetesClusterResponseBodyDataResult },
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryInstancesInfoResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The enabled port.
   * 
   * @example
   * 8848
   */
  clientPort?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2022-12-15T02:02:15Z
   */
  creationTimestamp?: string;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * null
   */
  healthStatus?: string;
  /**
   * @remarks
   * The public IP address.
   * 
   * @example
   * 120.55.71.x
   */
  internetIp?: string;
  /**
   * @remarks
   * The IP address of the pod.
   * 
   * @example
   * 25.24.91.x
   */
  ip?: string;
  /**
   * @remarks
   * The pod name.
   * 
   * @example
   * mse-xxxxx-xxxxx-reg-center-0-1
   */
  podName?: string;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * null
   */
  role?: string;
  /**
   * @remarks
   * The internal IP address.
   * 
   * @example
   * 172.16.66.x
   */
  singleTunnelVip?: string;
  /**
   * @remarks
   * The zone ID.
   * 
   * @example
   * cn-hangzhou-k
   */
  zone?: string;
  /**
   * @remarks
   * Indicates whether all pods in the cluster are distributed in the specified zones.
   * 
   * @example
   * true
   */
  zoneDistributed?: boolean;
  static names(): { [key: string]: string } {
    return {
      clientPort: 'ClientPort',
      creationTimestamp: 'CreationTimestamp',
      healthStatus: 'HealthStatus',
      internetIp: 'InternetIp',
      ip: 'Ip',
      podName: 'PodName',
      role: 'Role',
      singleTunnelVip: 'SingleTunnelVip',
      zone: 'Zone',
      zoneDistributed: 'ZoneDistributed',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientPort: 'string',
      creationTimestamp: 'string',
      healthStatus: 'string',
      internetIp: 'string',
      ip: 'string',
      podName: 'string',
      role: 'string',
      singleTunnelVip: 'string',
      zone: 'string',
      zoneDistributed: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMonitorResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The prefix of the name.
   * 
   * @example
   * mse-xxxx-xxxxxx
   */
  clusterNamePrefix?: string;
  /**
   * @remarks
   * The name of the pod.
   * 
   * @example
   * mse-xxxxxx-xxxxxx-reg-center-0-0
   */
  podName?: string;
  /**
   * @remarks
   * The details of the data.
   */
  values?: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      clusterNamePrefix: 'clusterNamePrefix',
      podName: 'podName',
      values: 'values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterNamePrefix: 'string',
      podName: 'string',
      values: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryNamespaceResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The name of the namespace.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The region to which the namespace belongs.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySlbSpecResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the returned data.
   * 
   * @example
   * 2
   */
  id?: number;
  /**
   * @remarks
   * The maximum number of connections.
   * 
   * @example
   * 50,000
   */
  maxConnection?: string;
  /**
   * @remarks
   * The name of the instance.
   * 
   * @example
   * Standard I
   */
  name?: string;
  /**
   * @remarks
   * The number of connections per second.
   * 
   * @example
   * 50,000
   */
  newConnectionPerSecond?: string;
  /**
   * @remarks
   * The number of queries per second (QPS).
   * 
   * @example
   * 50,000
   */
  qps?: string;
  /**
   * @remarks
   * The specification of the instance.
   * 
   * @example
   * slb.s2.small
   */
  spec?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      maxConnection: 'MaxConnection',
      name: 'Name',
      newConnectionPerSecond: 'NewConnectionPerSecond',
      qps: 'Qps',
      spec: 'Spec',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      maxConnection: 'string',
      name: 'string',
      newConnectionPerSecond: 'string',
      qps: 'string',
      spec: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems extends $tea.Model {
  cond?: string;
  datum?: string;
  divisor?: number;
  name?: string;
  nameList?: string[];
  operator?: string;
  rate?: number;
  remainder?: number;
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      cond: 'cond',
      datum: 'datum',
      divisor: 'divisor',
      name: 'name',
      nameList: 'nameList',
      operator: 'operator',
      rate: 'rate',
      remainder: 'remainder',
      type: 'type',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cond: 'string',
      datum: 'string',
      divisor: 'number',
      name: 'string',
      nameList: { 'type': 'array', 'itemType': 'string' },
      operator: 'string',
      rate: 'number',
      remainder: 'number',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySwimmingLaneByIdResponseBodyDataEntryRules extends $tea.Model {
  condition?: string;
  path?: string;
  paths?: string[];
  restItems?: QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems[];
  static names(): { [key: string]: string } {
    return {
      condition: 'condition',
      path: 'path',
      paths: 'paths',
      restItems: 'restItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      condition: 'string',
      path: 'string',
      paths: { 'type': 'array', 'itemType': 'string' },
      restItems: { 'type': 'array', 'itemType': QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySwimmingLaneByIdResponseBodyData extends $tea.Model {
  pathIndependentPercentageEnable?: boolean;
  enable?: boolean;
  enableRules?: boolean;
  entryRule?: string;
  entryRules?: QuerySwimmingLaneByIdResponseBodyDataEntryRules[];
  gatewaySwimmingLaneRouteJson?: string;
  gmtCreate?: string;
  gmtModified?: string;
  groupId?: number;
  id?: number;
  name?: string;
  regionId?: string;
  status?: number;
  tag?: string;
  static names(): { [key: string]: string } {
    return {
      pathIndependentPercentageEnable: 'PathIndependentPercentageEnable',
      enable: 'enable',
      enableRules: 'enableRules',
      entryRule: 'entryRule',
      entryRules: 'entryRules',
      gatewaySwimmingLaneRouteJson: 'gatewaySwimmingLaneRouteJson',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      groupId: 'groupId',
      id: 'id',
      name: 'name',
      regionId: 'regionId',
      status: 'status',
      tag: 'tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pathIndependentPercentageEnable: 'boolean',
      enable: 'boolean',
      enableRules: 'boolean',
      entryRule: 'string',
      entryRules: { 'type': 'array', 'itemType': QuerySwimmingLaneByIdResponseBodyDataEntryRules },
      gatewaySwimmingLaneRouteJson: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      groupId: 'number',
      id: 'number',
      name: 'string',
      regionId: 'string',
      status: 'number',
      tag: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryZnodeDetailResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The data of the node.
   * 
   * @example
   * cluster
   */
  data?: string;
  /**
   * @remarks
   * Indicates whether the node information was returned. Valid values:
   * 
   * *   `true`: The node information was returned.
   * *   `false`: The node information failed to be returned.
   * 
   * @example
   * true
   */
  dir?: boolean;
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * zookeeper
   */
  name?: string;
  /**
   * @remarks
   * The path of the node.
   * 
   * @example
   * /zookeeper
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      dir: 'Dir',
      name: 'Name',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      dir: 'boolean',
      name: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SelectGatewaySlbResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the SLB instance.
   * 
   * @example
   * lb-bp14lqiw5n96hq2****
   */
  slbId?: string;
  /**
   * @remarks
   * The name of the SLB instance.
   * 
   * @example
   * MseGatewaySlb-gw
   */
  slbName?: string;
  static names(): { [key: string]: string } {
    return {
      slbId: 'SlbId',
      slbName: 'SlbName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      slbId: 'string',
      slbName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesRequestTag extends $tea.Model {
  /**
   * @remarks
   * The tag key. Valid values of N: 1 to 20. The tag key cannot be an empty string. The tag key must be 1 to 128 characters in length. The tag key cannot start with acs: or aliyun or contain [http:// or https://.](http://https://。)
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * prd
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCircuitBreakerRuleResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the application.
   * 
   * @example
   * hkhon1po62@c3df23522bXXXXX
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * Indicates whether the rule is enabled.
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The minimum number of requests that can be passed in each step after circuit breaking recovers.
   * 
   * @example
   * 5
   */
  halfOpenBaseAmountPerStep?: number;
  /**
   * @remarks
   * The number of circuit breaking recovery steps.
   * 
   * @example
   * 1
   */
  halfOpenRecoveryStepNum?: number;
  /**
   * @remarks
   * The ID of the rule.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The maximum RT. Unit: milliseconds. If the RT of a request is greater than the value of this parameter, a slow call is counted. If you set Strategy to 0, you must specify this parameter.
   * 
   * @example
   * 200
   */
  maxAllowedRtMs?: number;
  /**
   * @remarks
   * The minimum number of requests to trigger circuit breaking. If the number of requests in the current time window is less than the value of this parameter, circuit breaking is not triggered even if the circuit breaking rule is met.
   * 
   * @example
   * 10
   */
  minRequestAmount?: number;
  /**
   * @remarks
   * The microservice namespace to which the application belongs.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The name of the interface to which the rule is applicable. The interface name must be the same as the name on the interface details page in the console.
   * 
   * @example
   * /a
   */
  resource?: string;
  /**
   * @remarks
   * The period in which circuit breaking is implemented. Unit: milliseconds. If circuit breaking is implemented on the requests for the route, the calls to all the requests for the route fail in the configured circuit breaking period.
   * 
   * @example
   * 10000
   */
  retryTimeoutMs?: number;
  /**
   * @remarks
   * The length of the time window. Unit: milliseconds. The valid range is from 1 second to 120 minutes.
   * 
   * @example
   * 20000
   */
  statIntervalMs?: number;
  /**
   * @remarks
   * The threshold type.
   * 
   * Valid values:
   * 
   * *   0
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     slow call proportion
   * 
   *     <!-- -->
   * 
   * *   1
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     abnormal proportion
   * 
   *     <!-- -->
   * 
   * @example
   * 0
   */
  strategy?: number;
  /**
   * @remarks
   * A percentage threshold for triggering circuit breaking. Valid values: 0-1. These values represent 0% to 100%.
   * 
   * @example
   * 0.8
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      enable: 'Enable',
      halfOpenBaseAmountPerStep: 'HalfOpenBaseAmountPerStep',
      halfOpenRecoveryStepNum: 'HalfOpenRecoveryStepNum',
      id: 'Id',
      maxAllowedRtMs: 'MaxAllowedRtMs',
      minRequestAmount: 'MinRequestAmount',
      namespace: 'Namespace',
      resource: 'Resource',
      retryTimeoutMs: 'RetryTimeoutMs',
      statIntervalMs: 'StatIntervalMs',
      strategy: 'Strategy',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appName: 'string',
      enable: 'boolean',
      halfOpenBaseAmountPerStep: 'number',
      halfOpenRecoveryStepNum: 'number',
      id: 'number',
      maxAllowedRtMs: 'number',
      minRequestAmount: 'number',
      namespace: 'string',
      resource: 'string',
      retryTimeoutMs: 'number',
      statIntervalMs: 'number',
      strategy: 'number',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEngineNamespaceResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The quota value.
   * 
   * @example
   * 1
   */
  configCount?: number;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * public
   */
  namespace?: string;
  /**
   * @remarks
   * The description of the namespace.
   * 
   * @example
   * mytest
   */
  namespaceDesc?: string;
  /**
   * @remarks
   * The display name of the namespace.
   * 
   * @example
   * mytestshowname
   */
  namespaceShowName?: string;
  /**
   * @remarks
   * The quota of configurations.
   * 
   * @example
   * 1
   */
  quota?: number;
  /**
   * @remarks
   * The type of the namespace. Valid values:
   * 
   * *   `0`: global configuration
   * *   `1`: default namespace
   * *   `2`: custom namespace
   * 
   * @example
   * 1
   */
  type?: number;
  static names(): { [key: string]: string } {
    return {
      configCount: 'ConfigCount',
      namespace: 'Namespace',
      namespaceDesc: 'NamespaceDesc',
      namespaceShowName: 'NamespaceShowName',
      quota: 'Quota',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configCount: 'number',
      namespace: 'string',
      namespaceDesc: 'string',
      namespaceShowName: 'string',
      quota: 'number',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFlowRuleResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * hpn9ac29kz@e31a4b871******
   */
  appId?: string;
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @remarks
   * The throttling effect.
   * 
   * Valid values:
   * 
   * *   0
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     fast failure
   * 
   *     <!-- -->
   * 
   * *   2
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     in queue
   * 
   *     <!-- -->
   * 
   * @example
   * 0
   */
  controlBehavior?: number;
  /**
   * @remarks
   * Indicates whether the rule was enabled.
   * 
   * Valid value:
   * 
   * *   true
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   false
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The rule ID.
   * 
   * @example
   * 12
   */
  id?: number;
  /**
   * @remarks
   * The timeout period for queuing when the value of ControlBehavior is set to 2. Unit: milliseconds.
   * 
   * @example
   * 500
   */
  maxQueueingTimeMs?: number;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The name of the API resource.
   * 
   * @example
   * /c
   */
  resource?: string;
  /**
   * @remarks
   * The throttling threshold.
   * 
   * @example
   * 5
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      controlBehavior: 'ControlBehavior',
      enable: 'Enable',
      id: 'Id',
      maxQueueingTimeMs: 'MaxQueueingTimeMs',
      namespace: 'Namespace',
      resource: 'Resource',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appName: 'string',
      controlBehavior: 'number',
      enable: 'boolean',
      id: 'number',
      maxQueueingTimeMs: 'number',
      namespace: 'string',
      resource: 'string',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayAuthConsumerResourceRequestResourceList extends $tea.Model {
  /**
   * @remarks
   * The route ID.
   * 
   * @example
   * 7816
   */
  routeId?: number;
  /**
   * @remarks
   * The name of the route.
   * 
   * @example
   * helo
   */
  routeName?: string;
  static names(): { [key: string]: string } {
    return {
      routeId: 'RouteId',
      routeName: 'RouteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      routeId: 'number',
      routeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayCircuitBreakerRuleResponseBodyData extends $tea.Model {
  /**
   * @example
   * 0
   */
  behaviorType?: number;
  /**
   * @example
   * 0
   */
  bodyEncoding?: number;
  /**
   * @example
   * 0
   */
  enable?: number;
  /**
   * @example
   * 14407
   */
  gatewayId?: number;
  /**
   * @example
   * gw-c9bc5afd61014165bd58f621b491****
   */
  gatewayUniqueId?: string;
  /**
   * @example
   * 369
   */
  id?: number;
  idList?: number[];
  /**
   * @example
   * 0
   */
  limitMode?: number;
  /**
   * @example
   * 10
   */
  maxAllowedMs?: number;
  /**
   * @example
   * 10
   */
  minRequestAmount?: number;
  /**
   * @example
   * 12
   */
  recoveryTimeoutSec?: number;
  /**
   * @example
   * key=value
   */
  responseAdditionalHeaders?: string;
  /**
   * @example
   * text
   */
  responseContentBody?: string;
  /**
   * @example
   * www.******.com
   */
  responseRedirectUrl?: string;
  /**
   * @example
   * 201
   */
  responseStatusCode?: number;
  /**
   * @example
   * 645
   */
  routeId?: number;
  /**
   * @example
   * routeName
   */
  routeName?: string;
  /**
   * @example
   * 11
   */
  statDurationSec?: number;
  /**
   * @example
   * 0
   */
  strategy?: number;
  /**
   * @example
   * 10
   */
  triggerRatio?: number;
  static names(): { [key: string]: string } {
    return {
      behaviorType: 'BehaviorType',
      bodyEncoding: 'BodyEncoding',
      enable: 'Enable',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      idList: 'IdList',
      limitMode: 'LimitMode',
      maxAllowedMs: 'MaxAllowedMs',
      minRequestAmount: 'MinRequestAmount',
      recoveryTimeoutSec: 'RecoveryTimeoutSec',
      responseAdditionalHeaders: 'ResponseAdditionalHeaders',
      responseContentBody: 'ResponseContentBody',
      responseRedirectUrl: 'ResponseRedirectUrl',
      responseStatusCode: 'ResponseStatusCode',
      routeId: 'RouteId',
      routeName: 'RouteName',
      statDurationSec: 'StatDurationSec',
      strategy: 'Strategy',
      triggerRatio: 'TriggerRatio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      behaviorType: 'number',
      bodyEncoding: 'number',
      enable: 'number',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
      idList: { 'type': 'array', 'itemType': 'number' },
      limitMode: 'number',
      maxAllowedMs: 'number',
      minRequestAmount: 'number',
      recoveryTimeoutSec: 'number',
      responseAdditionalHeaders: 'string',
      responseContentBody: 'string',
      responseRedirectUrl: 'string',
      responseStatusCode: 'number',
      routeId: 'number',
      routeName: 'string',
      statDurationSec: 'number',
      strategy: 'number',
      triggerRatio: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayFlowRuleResponseBodyData extends $tea.Model {
  /**
   * @example
   * 0
   */
  behaviorType?: number;
  /**
   * @example
   * 0
   */
  bodyEncoding?: number;
  /**
   * @example
   * 0
   */
  enable?: number;
  /**
   * @example
   * 14407
   */
  gatewayId?: number;
  /**
   * @example
   * gw-e2d226bba4b2445c9e29fa7f8216****
   */
  gatewayUniqueId?: string;
  /**
   * @example
   * 549
   */
  id?: number;
  idList?: number[];
  /**
   * @example
   * 0
   */
  limitMode?: number;
  /**
   * @example
   * key=value
   */
  responseAdditionalHeaders?: string;
  /**
   * @example
   * Text
   */
  responseContentBody?: string;
  /**
   * @example
   * www.******.com
   */
  responseRedirectUrl?: string;
  /**
   * @example
   * 429
   */
  responseStatusCode?: number;
  /**
   * @example
   * 48811
   */
  routeId?: number;
  /**
   * @example
   * routeA
   */
  routeName?: string;
  /**
   * @example
   * 10
   */
  statDurationMs?: number;
  /**
   * @example
   * 10
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      behaviorType: 'BehaviorType',
      bodyEncoding: 'BodyEncoding',
      enable: 'Enable',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      idList: 'IdList',
      limitMode: 'LimitMode',
      responseAdditionalHeaders: 'ResponseAdditionalHeaders',
      responseContentBody: 'ResponseContentBody',
      responseRedirectUrl: 'ResponseRedirectUrl',
      responseStatusCode: 'ResponseStatusCode',
      routeId: 'RouteId',
      routeName: 'RouteName',
      statDurationMs: 'StatDurationMs',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      behaviorType: 'number',
      bodyEncoding: 'number',
      enable: 'number',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
      idList: { 'type': 'array', 'itemType': 'number' },
      limitMode: 'number',
      responseAdditionalHeaders: 'string',
      responseContentBody: 'string',
      responseRedirectUrl: 'string',
      responseStatusCode: 'number',
      routeId: 'number',
      routeName: 'string',
      statDurationMs: 'number',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayIsolationRuleResponseBodyData extends $tea.Model {
  /**
   * @example
   * 0
   */
  behaviorType?: number;
  /**
   * @example
   * 0
   */
  bodyEncoding?: number;
  /**
   * @example
   * 0
   */
  enable?: number;
  /**
   * @example
   * 14407
   */
  gatewayId?: number;
  /**
   * @example
   * gw-e2d226bba4b2445c9e29fa7f8216****
   */
  gatewayUniqueId?: string;
  /**
   * @example
   * 358
   */
  id?: number;
  idList?: number[];
  /**
   * @example
   * 0
   */
  limitMode?: number;
  /**
   * @example
   * 100
   */
  maxConcurrency?: number;
  /**
   * @example
   * key=value
   */
  responseAdditionalHeaders?: string;
  /**
   * @example
   * text
   */
  responseContentBody?: string;
  /**
   * @example
   * www.******.com
   */
  responseRedirectUrl?: string;
  /**
   * @example
   * 429
   */
  responseStatusCode?: number;
  /**
   * @example
   * 52853
   */
  routeId?: number;
  /**
   * @example
   * routeName
   */
  routeName?: string;
  static names(): { [key: string]: string } {
    return {
      behaviorType: 'BehaviorType',
      bodyEncoding: 'BodyEncoding',
      enable: 'Enable',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      id: 'Id',
      idList: 'IdList',
      limitMode: 'LimitMode',
      maxConcurrency: 'MaxConcurrency',
      responseAdditionalHeaders: 'ResponseAdditionalHeaders',
      responseContentBody: 'ResponseContentBody',
      responseRedirectUrl: 'ResponseRedirectUrl',
      responseStatusCode: 'ResponseStatusCode',
      routeId: 'RouteId',
      routeName: 'RouteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      behaviorType: 'number',
      bodyEncoding: 'number',
      enable: 'number',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      id: 'number',
      idList: { 'type': 'array', 'itemType': 'number' },
      limitMode: 'number',
      maxConcurrency: 'number',
      responseAdditionalHeaders: 'string',
      responseContentBody: 'string',
      responseRedirectUrl: 'string',
      responseStatusCode: 'number',
      routeId: 'number',
      routeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteRequestDirectResponseJSON extends $tea.Model {
  /**
   * @remarks
   * The mock return value.
   * 
   * @example
   * hello
   */
  body?: string;
  /**
   * @remarks
   * The mock return code.
   * 
   * @example
   * 200
   */
  code?: number;
  static names(): { [key: string]: string } {
    return {
      body: 'Body',
      code: 'Code',
    };
  }

  static types(): { [key: string]: any } {
    return {
      body: 'string',
      code: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteRequestFallbackServices extends $tea.Model {
  /**
   * @remarks
   * The type of the protocol. Valid values:
   * 
   * @example
   * DUBBO
   */
  agreementType?: string;
  /**
   * @remarks
   * The name of the group to which the service belongs.
   * 
   * @example
   * test
   */
  groupName?: string;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * name
   */
  name?: string;
  /**
   * @remarks
   * The namespace in which the service resides.
   * 
   * @example
   * Namespace
   */
  namespace?: string;
  /**
   * @remarks
   * The weight in the form of a percentage value.
   * 
   * @example
   * 80
   */
  percent?: number;
  /**
   * @remarks
   * The ID of the service.
   * 
   * @example
   * 1
   */
  serviceId?: number;
  /**
   * @remarks
   * The service port number.
   * 
   * @example
   * 8848
   */
  servicePort?: number;
  /**
   * @remarks
   * The source type.
   * 
   * @example
   * MSE
   */
  sourceType?: string;
  /**
   * @remarks
   * The version of the service.
   * 
   * @example
   * v1
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      agreementType: 'AgreementType',
      groupName: 'GroupName',
      name: 'Name',
      namespace: 'Namespace',
      percent: 'Percent',
      serviceId: 'ServiceId',
      servicePort: 'ServicePort',
      sourceType: 'SourceType',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      agreementType: 'string',
      groupName: 'string',
      name: 'string',
      namespace: 'string',
      percent: 'number',
      serviceId: 'number',
      servicePort: 'number',
      sourceType: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteRequestPredicatesHeaderPredicates extends $tea.Model {
  /**
   * @remarks
   * The key of the request header.
   * 
   * @example
   * debug
   */
  key?: string;
  /**
   * @remarks
   * The matching type.
   * 
   * @example
   * PRE
   */
  type?: string;
  /**
   * @remarks
   * The value of the request header.
   * 
   * @example
   * on
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteRequestPredicatesPathPredicates extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to perform case-insensitive matching.
   * 
   * @example
   * true
   */
  ignoreCase?: boolean;
  /**
   * @remarks
   * The path used for route matching.
   * 
   * @example
   * /test
   */
  path?: string;
  /**
   * @remarks
   * The matching type.
   * 
   * @example
   * PRE
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      ignoreCase: 'IgnoreCase',
      path: 'Path',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ignoreCase: 'boolean',
      path: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteRequestPredicatesQueryPredicates extends $tea.Model {
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * userid
   */
  key?: string;
  /**
   * @remarks
   * The matching type.
   * 
   * @example
   * PRE
   */
  type?: string;
  /**
   * @remarks
   * The value of the parameter.
   * 
   * @example
   * test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteRequestPredicates extends $tea.Model {
  /**
   * @remarks
   * The information about header matching.
   */
  headerPredicates?: UpdateGatewayRouteRequestPredicatesHeaderPredicates[];
  /**
   * @remarks
   * The information about method matching.
   */
  methodPredicates?: string[];
  /**
   * @remarks
   * The information about path matching.
   */
  pathPredicates?: UpdateGatewayRouteRequestPredicatesPathPredicates;
  /**
   * @remarks
   * The information about parameter matching.
   */
  queryPredicates?: UpdateGatewayRouteRequestPredicatesQueryPredicates[];
  static names(): { [key: string]: string } {
    return {
      headerPredicates: 'HeaderPredicates',
      methodPredicates: 'MethodPredicates',
      pathPredicates: 'PathPredicates',
      queryPredicates: 'QueryPredicates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headerPredicates: { 'type': 'array', 'itemType': UpdateGatewayRouteRequestPredicatesHeaderPredicates },
      methodPredicates: { 'type': 'array', 'itemType': 'string' },
      pathPredicates: UpdateGatewayRouteRequestPredicatesPathPredicates,
      queryPredicates: { 'type': 'array', 'itemType': UpdateGatewayRouteRequestPredicatesQueryPredicates },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteRequestRedirectJSON extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 302
   */
  code?: number;
  /**
   * @remarks
   * The hostname to be redirected to.
   * 
   * @example
   * test.com
   */
  host?: string;
  /**
   * @remarks
   * The path to be redirected to.
   * 
   * @example
   * /test
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      host: 'Host',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      host: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList extends $tea.Model {
  /**
   * @remarks
   * The key extracted from the input parameter.
   * 
   * @example
   * name
   */
  extractKey?: string;
  /**
   * @remarks
   * The position of the input parameter.
   * 
   * > Valid values:
   * 
   * *   `ALL_QUERY_PARAMETER`: request parameter
   * 
   * *   `ALL_HEADER`: request header
   * 
   * *   `ALL_PATH`: request path
   * 
   * *   `ALL_BODY`: request body
   * 
   * @example
   * ALL_QUERY_PARAMETER
   */
  extractKeySpec?: string;
  /**
   * @remarks
   * The type of the backend service parameter.
   * 
   * @example
   * java.lang.String
   */
  mappingType?: string;
  static names(): { [key: string]: string } {
    return {
      extractKey: 'ExtractKey',
      extractKeySpec: 'ExtractKeySpec',
      mappingType: 'MappingType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extractKey: 'string',
      extractKeySpec: 'string',
      mappingType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList extends $tea.Model {
  /**
   * @remarks
   * The method name of the Dubbo service.
   * 
   * @example
   * sayHello
   */
  dubboMothedName?: string;
  /**
   * @remarks
   * The HTTP method.
   * 
   * > Valid values:
   * 
   * *   ALL_GET
   * 
   * *   ALL_POST
   * 
   * *   ALL_PUT
   * 
   * *   ALL_DELETE
   * 
   * *   ALL_PATCH
   * 
   * @example
   * ALL_GET
   */
  httpMothed?: string;
  /**
   * @remarks
   * The path that is used to match a method.
   * 
   * @example
   * /mytestzbk/sayhello
   */
  mothedpath?: string;
  /**
   * @remarks
   * The information of parameter mappings.
   */
  paramMapsList?: UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList[];
  /**
   * @remarks
   * The pass-through type of the header.
   * 
   * > Valid values:
   * 
   * *   PASS_ALL: All headers are passed through.
   * 
   * *   PASS_NOT: All headers are not passed through.
   * 
   * *   PASS_ASSIGN: Specified headers are passed through.
   * 
   * @example
   * PASS_NOT
   */
  passThroughAllHeaders?: string;
  /**
   * @remarks
   * The list of headers to be passed through.
   */
  passThroughList?: string[];
  static names(): { [key: string]: string } {
    return {
      dubboMothedName: 'DubboMothedName',
      httpMothed: 'HttpMothed',
      mothedpath: 'Mothedpath',
      paramMapsList: 'ParamMapsList',
      passThroughAllHeaders: 'PassThroughAllHeaders',
      passThroughList: 'PassThroughList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dubboMothedName: 'string',
      httpMothed: 'string',
      mothedpath: 'string',
      paramMapsList: { 'type': 'array', 'itemType': UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList },
      passThroughAllHeaders: 'string',
      passThroughList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteRequestServicesHttpDubboTranscoder extends $tea.Model {
  /**
   * @remarks
   * The Dubbo service group.
   * 
   * @example
   * service name
   */
  dubboServiceGroup?: string;
  /**
   * @remarks
   * The name of the Dubbo service.
   * 
   * @example
   * org.apache.dubbo.samples.basic.api.DemoService
   */
  dubboServiceName?: string;
  /**
   * @remarks
   * The version of the Dubbo service.
   * 
   * @example
   * 0.0.0
   */
  dubboServiceVersion?: string;
  /**
   * @remarks
   * The forwarding rules of the Dubbo service.
   */
  mothedMapList?: UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList[];
  static names(): { [key: string]: string } {
    return {
      dubboServiceGroup: 'DubboServiceGroup',
      dubboServiceName: 'DubboServiceName',
      dubboServiceVersion: 'DubboServiceVersion',
      mothedMapList: 'MothedMapList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dubboServiceGroup: 'string',
      dubboServiceName: 'string',
      dubboServiceVersion: 'string',
      mothedMapList: { 'type': 'array', 'itemType': UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteRequestServices extends $tea.Model {
  /**
   * @remarks
   * The type of the protocol. Valid values:
   * 
   * @example
   * DUBBO
   */
  agreementType?: string;
  /**
   * @remarks
   * The name of the group to which the service belongs.
   * 
   * @example
   * test
   */
  groupName?: string;
  /**
   * @remarks
   * The transcoder of the Dubbo protocol.
   */
  httpDubboTranscoder?: UpdateGatewayRouteRequestServicesHttpDubboTranscoder;
  /**
   * @remarks
   * The name.
   * 
   * @example
   * web
   */
  name?: string;
  /**
   * @remarks
   * The namespace in which the service resides.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The percentage.
   * 
   * @example
   * 80
   */
  percent?: number;
  /**
   * @remarks
   * The ID of the service.
   * 
   * @example
   * 1
   */
  serviceId?: number;
  /**
   * @remarks
   * The Dubbo port number.
   * 
   * @example
   * 20880
   */
  servicePort?: number;
  /**
   * @remarks
   * The source type.
   * 
   * @example
   * MSE
   */
  sourceType?: string;
  /**
   * @remarks
   * The version of the service.
   * 
   * @example
   * v1
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      agreementType: 'AgreementType',
      groupName: 'GroupName',
      httpDubboTranscoder: 'HttpDubboTranscoder',
      name: 'Name',
      namespace: 'Namespace',
      percent: 'Percent',
      serviceId: 'ServiceId',
      servicePort: 'ServicePort',
      sourceType: 'SourceType',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      agreementType: 'string',
      groupName: 'string',
      httpDubboTranscoder: UpdateGatewayRouteRequestServicesHttpDubboTranscoder,
      name: 'string',
      namespace: 'string',
      percent: 'number',
      serviceId: 'number',
      servicePort: 'number',
      sourceType: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteAuthRequestAuthJSON extends $tea.Model {
  /**
   * @remarks
   * The authentication type. If an empty string is passed, no authentication type is available. Valid values:
   * 
   * *   JWT
   * 
   * @example
   * JWT
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteCORSRequestCorsJSON extends $tea.Model {
  /**
   * @remarks
   * The credentials allowed.
   * 
   * @example
   * true
   */
  allowCredentials?: boolean;
  /**
   * @remarks
   * The request headers allowed.
   * 
   * @example
   * content-type
   */
  allowHeaders?: string;
  /**
   * @remarks
   * The HTTP methods allowed.
   * 
   * @example
   * GET,POST
   */
  allowMethods?: string;
  /**
   * @remarks
   * The origins from which access is allowed.
   * 
   * @example
   * https://api.aliyun-inc.com/
   */
  allowOrigins?: string;
  /**
   * @remarks
   * The response headers allowed.
   * 
   * @example
   * *
   */
  exposeHeaders?: string;
  /**
   * @remarks
   * The status of the policy.
   * 
   * @example
   * off
   */
  status?: string;
  /**
   * @remarks
   * The unit of time.
   * 
   * @example
   * h
   */
  timeUnit?: string;
  /**
   * @remarks
   * The value of time.
   * 
   * @example
   * 24
   */
  unitNum?: number;
  static names(): { [key: string]: string } {
    return {
      allowCredentials: 'AllowCredentials',
      allowHeaders: 'AllowHeaders',
      allowMethods: 'AllowMethods',
      allowOrigins: 'AllowOrigins',
      exposeHeaders: 'ExposeHeaders',
      status: 'Status',
      timeUnit: 'TimeUnit',
      unitNum: 'UnitNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowCredentials: 'boolean',
      allowHeaders: 'string',
      allowMethods: 'string',
      allowOrigins: 'string',
      exposeHeaders: 'string',
      status: 'string',
      timeUnit: 'string',
      unitNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteRetryRequestRetryJSON extends $tea.Model {
  /**
   * @remarks
   * The number of retries.
   * 
   * @example
   * 2
   */
  attempts?: number;
  /**
   * @remarks
   * The HTTP status codes.
   */
  httpCodes?: string[];
  /**
   * @remarks
   * The retry conditions.
   */
  retryOn?: string[];
  /**
   * @remarks
   * The status of the policy.
   * 
   * @example
   * off
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      attempts: 'Attempts',
      httpCodes: 'HttpCodes',
      retryOn: 'RetryOn',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attempts: 'number',
      httpCodes: { 'type': 'array', 'itemType': 'string' },
      retryOn: { 'type': 'array', 'itemType': 'string' },
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteTimeoutRequestTimeoutJSON extends $tea.Model {
  /**
   * @remarks
   * The status of the policy.
   * 
   * @example
   * off
   */
  status?: string;
  /**
   * @remarks
   * The unit of time. A value of s indicates seconds.
   * 
   * @example
   * s
   */
  timeUnit?: string;
  /**
   * @remarks
   * The value of the timeout period.
   * 
   * @example
   * 1
   */
  unitNum?: number;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      timeUnit: 'TimeUnit',
      unitNum: 'UnitNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      timeUnit: 'string',
      unitNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteWafStatusResponseBodyDataCors extends $tea.Model {
  /**
   * @remarks
   * The credentials allowed.
   * 
   * @example
   * true
   */
  allowCredentials?: boolean;
  /**
   * @remarks
   * The headers allowed.
   * 
   * @example
   * *
   */
  allowHeaders?: string;
  /**
   * @remarks
   * The methods allowed.
   * 
   * @example
   * GET,POST,PUT,DELETE,HEAD,OPTIONS,PATCH
   */
  allowMethods?: string;
  /**
   * @remarks
   * The origins allowed.
   * 
   * @example
   * *
   */
  allowOrigins?: string;
  /**
   * @remarks
   * The response headers.
   * 
   * @example
   * *
   */
  exposeHeaders?: string;
  /**
   * @remarks
   * The status.
   * 
   * @example
   * off
   */
  status?: string;
  /**
   * @remarks
   * The time unit.
   * 
   * @example
   * s
   */
  timeUnit?: string;
  /**
   * @remarks
   * The unit number.
   * 
   * @example
   * 1
   */
  unitNum?: number;
  static names(): { [key: string]: string } {
    return {
      allowCredentials: 'AllowCredentials',
      allowHeaders: 'AllowHeaders',
      allowMethods: 'AllowMethods',
      allowOrigins: 'AllowOrigins',
      exposeHeaders: 'ExposeHeaders',
      status: 'Status',
      timeUnit: 'TimeUnit',
      unitNum: 'UnitNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowCredentials: 'boolean',
      allowHeaders: 'string',
      allowMethods: 'string',
      allowOrigins: 'string',
      exposeHeaders: 'string',
      status: 'string',
      timeUnit: 'string',
      unitNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse extends $tea.Model {
  /**
   * @remarks
   * The mock return value.
   * 
   * @example
   * [{\\"key\\":\\"h68d13466.sqa.eu95\\",\\"dims\\":\\"groupName=All}]
   */
  body?: string;
  /**
   * @remarks
   * The return value.
   * 
   * @example
   * 200
   */
  code?: number;
  static names(): { [key: string]: string } {
    return {
      body: 'Body',
      code: 'Code',
    };
  }

  static types(): { [key: string]: any } {
    return {
      body: 'string',
      code: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * aliyuncs.com
   */
  host?: string;
  /**
   * @remarks
   * The HTTP request path.
   * 
   * @example
   * /test/client
   */
  path?: string;
  /**
   * @remarks
   * The path type of the HTTP request.
   * 
   * @example
   * PRE
   */
  pathType?: string;
  /**
   * @remarks
   * The matching pattern.
   * 
   * @example
   * /test
   */
  pattern?: string;
  /**
   * @remarks
   * The HTTP status.
   * 
   * @example
   * off
   */
  status?: string;
  /**
   * @remarks
   * The replacement.
   * 
   * @example
   * test
   */
  substitution?: string;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      path: 'Path',
      pathType: 'PathType',
      pattern: 'Pattern',
      status: 'Status',
      substitution: 'Substitution',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      path: 'string',
      pathType: 'string',
      pattern: 'string',
      status: 'string',
      substitution: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems extends $tea.Model {
  /**
   * @remarks
   * The request or response.
   * 
   * @example
   * Response
   */
  directionType?: string;
  /**
   * @remarks
   * The header key.
   * 
   * @example
   * debug
   */
  key?: string;
  /**
   * @remarks
   * The operation type.
   * 
   * @example
   * Add
   */
  opType?: string;
  /**
   * @remarks
   * The header value.
   * 
   * @example
   * test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      directionType: 'DirectionType',
      key: 'Key',
      opType: 'OpType',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      directionType: 'string',
      key: 'string',
      opType: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp extends $tea.Model {
  /**
   * @remarks
   * The policy.
   */
  headerOpItems?: UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems[];
  /**
   * @remarks
   * The status.
   * 
   * @example
   * off
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      headerOpItems: 'HeaderOpItems',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headerOpItems: { 'type': 'array', 'itemType': UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems },
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteWafStatusResponseBodyDataRedirect extends $tea.Model {
  /**
   * @remarks
   * The response code returned.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The hostname.
   * 
   * @example
   * ww.al.c
   */
  host?: string;
  /**
   * @remarks
   * The path.
   * 
   * @example
   * /
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      host: 'Host',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      host: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteWafStatusResponseBodyDataRetry extends $tea.Model {
  /**
   * @remarks
   * The number of retries allowed for a request.
   * 
   * @example
   * 1
   */
  attempts?: number;
  /**
   * @remarks
   * The HTTP status code.
   */
  httpCodes?: string[];
  /**
   * @remarks
   * The retry condition.
   */
  retryOn?: string[];
  /**
   * @remarks
   * The retry status.
   * 
   * @example
   * on
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      attempts: 'Attempts',
      httpCodes: 'HttpCodes',
      retryOn: 'RetryOn',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attempts: 'number',
      httpCodes: { 'type': 'array', 'itemType': 'string' },
      retryOn: { 'type': 'array', 'itemType': 'string' },
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates extends $tea.Model {
  /**
   * @remarks
   * The key of the request header.
   * 
   * @example
   * alibo
   */
  key?: string;
  /**
   * @remarks
   * The matching type.
   * 
   * @example
   * PRE
   */
  type?: string;
  /**
   * @remarks
   * The value of the request header.
   * 
   * @example
   * 200
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates extends $tea.Model {
  /**
   * @remarks
   * Indicates whether case sensitivity is ignored.
   * 
   * @example
   * true
   */
  ignoreCase?: boolean;
  /**
   * @remarks
   * The path.
   * 
   * @example
   * /zookeeper/mmgw/unlogined/common.getBu
   */
  path?: string;
  /**
   * @remarks
   * The matching type.
   * 
   * @example
   * PRE
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      ignoreCase: 'IgnoreCase',
      path: 'Path',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ignoreCase: 'boolean',
      path: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates extends $tea.Model {
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * instanceId
   */
  key?: string;
  /**
   * @remarks
   * The type.
   * 
   * @example
   * PRE
   */
  type?: string;
  /**
   * @remarks
   * The value of the parameter.
   * 
   * @example
   * test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates extends $tea.Model {
  /**
   * @remarks
   * The information about matching based on request headers.
   */
  headerPredicates?: UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates[];
  /**
   * @remarks
   * The information about method matching.
   */
  methodPredicates?: string[];
  /**
   * @remarks
   * The information about route matching.
   */
  pathPredicates?: UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates;
  /**
   * @remarks
   * The parameter matching rules.
   */
  queryPredicates?: UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates[];
  static names(): { [key: string]: string } {
    return {
      headerPredicates: 'HeaderPredicates',
      methodPredicates: 'MethodPredicates',
      pathPredicates: 'PathPredicates',
      queryPredicates: 'QueryPredicates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headerPredicates: { 'type': 'array', 'itemType': UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates },
      methodPredicates: { 'type': 'array', 'itemType': 'string' },
      pathPredicates: UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates,
      queryPredicates: { 'type': 'array', 'itemType': UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteWafStatusResponseBodyDataRouteServices extends $tea.Model {
  /**
   * @remarks
   * The name of the group to which the service belongs.
   * 
   * @example
   * DEFAULT_GROUP
   */
  groupName?: string;
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * test-aixue-gray
   */
  name?: string;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The weight.
   * 
   * @example
   * 80
   */
  percent?: number;
  /**
   * @remarks
   * The ID of the service.
   * 
   * @example
   * 547
   */
  serviceId?: number;
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * b-service
   */
  serviceName?: string;
  /**
   * @remarks
   * The source type of the service.
   * 
   * @example
   * K8s
   */
  sourceType?: string;
  /**
   * @remarks
   * The version of the service.
   * 
   * @example
   * v1
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      groupName: 'GroupName',
      name: 'Name',
      namespace: 'Namespace',
      percent: 'Percent',
      serviceId: 'ServiceId',
      serviceName: 'ServiceName',
      sourceType: 'SourceType',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupName: 'string',
      name: 'string',
      namespace: 'string',
      percent: 'number',
      serviceId: 'number',
      serviceName: 'string',
      sourceType: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteWafStatusResponseBodyDataTimeout extends $tea.Model {
  /**
   * @remarks
   * The status.
   * 
   * @example
   * off
   */
  status?: string;
  /**
   * @remarks
   * The time unit.
   * 
   * @example
   * s
   */
  timeUnit?: string;
  /**
   * @remarks
   * The unit number.
   * 
   * @example
   * 10
   */
  unitNum?: number;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      timeUnit: 'TimeUnit',
      unitNum: 'UnitNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      timeUnit: 'string',
      unitNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGatewayRouteWafStatusResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The configuration for cross-origin resource sharing (CORS).
   */
  cors?: UpdateGatewayRouteWafStatusResponseBodyDataCors;
  /**
   * @remarks
   * The default service ID.
   * 
   * @example
   * 1
   */
  defaultServiceId?: number;
  /**
   * @remarks
   * The default service name.
   * 
   * @example
   * test
   */
  defaultServiceName?: string;
  /**
   * @remarks
   * The destination service type.
   * 
   * @example
   * Single
   */
  destinationType?: string;
  /**
   * @remarks
   * The information about service mocking.
   */
  directResponse?: UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse;
  /**
   * @remarks
   * The domain ID.
   * 
   * @example
   * 235
   */
  domainId?: number;
  /**
   * @remarks
   * The list of domain IDs.
   */
  domainIdList?: number[];
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * nbhamster.com
   */
  domainName?: string;
  /**
   * @remarks
   * The domain names.
   */
  domainNameList?: string[];
  /**
   * @remarks
   * Indicates whether WAF is activated.
   * 
   * @example
   * 0
   */
  enableWaf?: boolean;
  /**
   * @remarks
   * The ID of the gateway.
   * 
   * @example
   * 102
   */
  gatewayId?: number;
  /**
   * @remarks
   * The unique ID of the gateway.
   * 
   * @example
   * gw-7ea3da97b96543e19f6c597cd4a9****
   */
  gatewayUniqueId?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2022-01-26T09:52:41.000+0000
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The modification time.
   * 
   * @example
   * 2022-02-24T06:08:29.230+0000
   */
  gmtModified?: string;
  /**
   * @remarks
   * The information about the rewrite policy.
   */
  HTTPRewrite?: UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite;
  /**
   * @remarks
   * The header settings.
   */
  headerOp?: UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp;
  /**
   * @remarks
   * The ID of the route.
   * 
   * @example
   * 12
   */
  id?: number;
  /**
   * @remarks
   * The name of the route.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The matching rule.
   * 
   * @example
   * {\\"PathPredicates\\":{\\"Path\\":\\"/metas\\",\\"Type\\":\\"PRE\\",\\"IgnoreCase\\":false}}
   */
  predicates?: string;
  /**
   * @remarks
   * The configuration of the redirection.
   */
  redirect?: UpdateGatewayRouteWafStatusResponseBodyDataRedirect;
  /**
   * @remarks
   * The retry configuration.
   */
  retry?: UpdateGatewayRouteWafStatusResponseBodyDataRetry;
  /**
   * @remarks
   * The sequence number of the route.
   * 
   * @example
   * 1
   */
  routeOrder?: number;
  /**
   * @remarks
   * The information about route matching.
   */
  routePredicates?: UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates;
  /**
   * @remarks
   * The information about services.
   */
  routeServices?: UpdateGatewayRouteWafStatusResponseBodyDataRouteServices[];
  /**
   * @remarks
   * The information about services.
   * 
   * @example
   * [{\\"Percent\\":100,\\"ServiceId\\":126}]
   */
  services?: string;
  /**
   * @remarks
   * The status of the route.
   * 
   * @example
   * 1
   */
  status?: number;
  /**
   * @remarks
   * The timeout configuration.
   */
  timeout?: UpdateGatewayRouteWafStatusResponseBodyDataTimeout;
  static names(): { [key: string]: string } {
    return {
      cors: 'Cors',
      defaultServiceId: 'DefaultServiceId',
      defaultServiceName: 'DefaultServiceName',
      destinationType: 'DestinationType',
      directResponse: 'DirectResponse',
      domainId: 'DomainId',
      domainIdList: 'DomainIdList',
      domainName: 'DomainName',
      domainNameList: 'DomainNameList',
      enableWaf: 'EnableWaf',
      gatewayId: 'GatewayId',
      gatewayUniqueId: 'GatewayUniqueId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      HTTPRewrite: 'HTTPRewrite',
      headerOp: 'HeaderOp',
      id: 'Id',
      name: 'Name',
      predicates: 'Predicates',
      redirect: 'Redirect',
      retry: 'Retry',
      routeOrder: 'RouteOrder',
      routePredicates: 'RoutePredicates',
      routeServices: 'RouteServices',
      services: 'Services',
      status: 'Status',
      timeout: 'Timeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cors: UpdateGatewayRouteWafStatusResponseBodyDataCors,
      defaultServiceId: 'number',
      defaultServiceName: 'string',
      destinationType: 'string',
      directResponse: UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse,
      domainId: 'number',
      domainIdList: { 'type': 'array', 'itemType': 'number' },
      domainName: 'string',
      domainNameList: { 'type': 'array', 'itemType': 'string' },
      enableWaf: 'boolean',
      gatewayId: 'number',
      gatewayUniqueId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      HTTPRewrite: UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite,
      headerOp: UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp,
      id: 'number',
      name: 'string',
      predicates: 'string',
      redirect: UpdateGatewayRouteWafStatusResponseBodyDataRedirect,
      retry: UpdateGatewayRouteWafStatusResponseBodyDataRetry,
      routeOrder: 'number',
      routePredicates: UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates,
      routeServices: { 'type': 'array', 'itemType': UpdateGatewayRouteWafStatusResponseBodyDataRouteServices },
      services: 'string',
      status: 'number',
      timeout: UpdateGatewayRouteWafStatusResponseBodyDataTimeout,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateIsolationRuleResponseBodyData extends $tea.Model {
  /**
   * @example
   * hkhon1po62@c3df23522bXXXXX
   */
  appId?: string;
  /**
   * @example
   * spring-cloud-a
   */
  appName?: string;
  /**
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @example
   * 1
   */
  id?: number;
  /**
   * @example
   * default
   */
  namespace?: string;
  /**
   * @example
   * /a
   */
  resource?: string;
  /**
   * @example
   * 3
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      enable: 'Enable',
      id: 'Id',
      namespace: 'Namespace',
      resource: 'Resource',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appName: 'string',
      enable: 'boolean',
      id: 'number',
      namespace: 'string',
      resource: 'string',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMigrationTaskResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The type of the instance.
   * 
   * *   Nacos-Ans
   * *   ZooKeeper
   * *   Eureka
   * 
   * @example
   * Nacos-Ans
   */
  clusterType?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2022-01-07T10:07:57.000+0000
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The modification time.
   * 
   * @example
   * 2022-01-07T10:07:57.000+0000
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the task.
   * 
   * @example
   * 1
   */
  id?: string;
  /**
   * @remarks
   * The address of the source instance node.
   * 
   * @example
   * 192.168.100.2:2181
   */
  originInstanceAddress?: string;
  /**
   * @remarks
   * The name of the source instance.
   * 
   * @example
   * src
   */
  originInstanceName?: string;
  /**
   * @remarks
   * The list of namespaces. This parameter is optional if applications are migrated from a Nacos instance.
   * 
   * @example
   * fsdfsdfdsf
   */
  originInstanceNamespace?: string;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * 1232345
   */
  projectDesc?: string;
  syncType?: string;
  /**
   * @remarks
   * The name of the destination instance.
   * 
   * @example
   * multiple-nacos
   */
  targetClusterName?: string;
  /**
   * @remarks
   * The URL of the destination instance.
   * 
   * @example
   * mse-0b*****-nacos-ans.mse.aliyuncs.com:8848
   */
  targetClusterUrl?: string;
  /**
   * @remarks
   * The ID of the destination instance.
   * 
   * @example
   * mse-cn-zvp2u*****
   */
  targetInstanceId?: string;
  /**
   * @remarks
   * The ID of the user.
   * 
   * @example
   * 183876217*****
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterType: 'ClusterType',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      originInstanceAddress: 'OriginInstanceAddress',
      originInstanceName: 'OriginInstanceName',
      originInstanceNamespace: 'OriginInstanceNamespace',
      projectDesc: 'ProjectDesc',
      syncType: 'SyncType',
      targetClusterName: 'TargetClusterName',
      targetClusterUrl: 'TargetClusterUrl',
      targetInstanceId: 'TargetInstanceId',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterType: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'string',
      originInstanceAddress: 'string',
      originInstanceName: 'string',
      originInstanceNamespace: 'string',
      projectDesc: 'string',
      syncType: 'string',
      targetClusterName: 'string',
      targetClusterUrl: 'string',
      targetInstanceId: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateServiceSourceRequestIngressOptionsRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to enable Ingress.
   * 
   * @example
   * true
   */
  enableIngress?: boolean;
  /**
   * @remarks
   * Specifies whether to update the Ingress status.
   * 
   * @example
   * true
   */
  enableStatus?: boolean;
  /**
   * @remarks
   * Specifies whether to monitor Ingress classes.
   * 
   * @example
   * com.test.xxx
   */
  ingressClass?: string;
  /**
   * @remarks
   * The namespace whose resources you want to monitor.
   * 
   * @example
   * default
   */
  watchNamespace?: string;
  static names(): { [key: string]: string } {
    return {
      enableIngress: 'EnableIngress',
      enableStatus: 'EnableStatus',
      ingressClass: 'IngressClass',
      watchNamespace: 'WatchNamespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableIngress: 'boolean',
      enableStatus: 'boolean',
      ingressClass: 'string',
      watchNamespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._signatureAlgorithm = "v2";
    this._endpointRule = "regional";
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("mse", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  /**
   * 新增服务鉴权规则
   * 
   * @param request - AddAuthPolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddAuthPolicyResponse
   */
  async addAuthPolicyWithOptions(request: AddAuthPolicyRequest, runtime: $Util.RuntimeOptions): Promise<AddAuthPolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.authRule)) {
      query["AuthRule"] = request.authRule;
    }

    if (!Util.isUnset(request.authType)) {
      query["AuthType"] = request.authType;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.k8sNamespace)) {
      query["K8sNamespace"] = request.k8sNamespace;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.protocol)) {
      query["Protocol"] = request.protocol;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddAuthPolicy",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddAuthPolicyResponse>(await this.callApi(params, req, runtime), new AddAuthPolicyResponse({}));
  }

  /**
   * 新增服务鉴权规则
   * 
   * @param request - AddAuthPolicyRequest
   * @returns AddAuthPolicyResponse
   */
  async addAuthPolicy(request: AddAuthPolicyRequest): Promise<AddAuthPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addAuthPolicyWithOptions(request, runtime);
  }

  /**
   * Creates authorization information for a gateway.
   * 
   * @param tmpReq - AddAuthResourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddAuthResourceResponse
   */
  async addAuthResourceWithOptions(tmpReq: AddAuthResourceRequest, runtime: $Util.RuntimeOptions): Promise<AddAuthResourceResponse> {
    Util.validateModel(tmpReq);
    let request = new AddAuthResourceShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.authResourceHeaderList)) {
      request.authResourceHeaderListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.authResourceHeaderList, "AuthResourceHeaderList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.authId)) {
      query["AuthId"] = request.authId;
    }

    if (!Util.isUnset(request.authResourceHeaderListShrink)) {
      query["AuthResourceHeaderList"] = request.authResourceHeaderListShrink;
    }

    if (!Util.isUnset(request.domainId)) {
      query["DomainId"] = request.domainId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.ignoreCase)) {
      query["IgnoreCase"] = request.ignoreCase;
    }

    if (!Util.isUnset(request.matchType)) {
      query["MatchType"] = request.matchType;
    }

    if (!Util.isUnset(request.path)) {
      query["Path"] = request.path;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddAuthResource",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddAuthResourceResponse>(await this.callApi(params, req, runtime), new AddAuthResourceResponse({}));
  }

  /**
   * Creates authorization information for a gateway.
   * 
   * @param request - AddAuthResourceRequest
   * @returns AddAuthResourceResponse
   */
  async addAuthResource(request: AddAuthResourceRequest): Promise<AddAuthResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addAuthResourceWithOptions(request, runtime);
  }

  /**
   * Creates a blacklist or a whitelist.
   * 
   * @param request - AddBlackWhiteListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddBlackWhiteListResponse
   */
  async addBlackWhiteListWithOptions(request: AddBlackWhiteListRequest, runtime: $Util.RuntimeOptions): Promise<AddBlackWhiteListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.content)) {
      query["Content"] = request.content;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.isWhite)) {
      query["IsWhite"] = request.isWhite;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.note)) {
      query["Note"] = request.note;
    }

    if (!Util.isUnset(request.resourceIdJsonList)) {
      query["ResourceIdJsonList"] = request.resourceIdJsonList;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddBlackWhiteList",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddBlackWhiteListResponse>(await this.callApi(params, req, runtime), new AddBlackWhiteListResponse({}));
  }

  /**
   * Creates a blacklist or a whitelist.
   * 
   * @param request - AddBlackWhiteListRequest
   * @returns AddBlackWhiteListResponse
   */
  async addBlackWhiteList(request: AddBlackWhiteListRequest): Promise<AddBlackWhiteListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addBlackWhiteListWithOptions(request, runtime);
  }

  /**
   * Adds a gateway.
   * 
   * @param tmpReq - AddGatewayRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddGatewayResponse
   */
  async addGatewayWithOptions(tmpReq: AddGatewayRequest, runtime: $Util.RuntimeOptions): Promise<AddGatewayResponse> {
    Util.validateModel(tmpReq);
    let request = new AddGatewayShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.zoneInfo)) {
      request.zoneInfoShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.zoneInfo, "ZoneInfo", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.chargeType)) {
      query["ChargeType"] = request.chargeType;
    }

    if (!Util.isUnset(request.clbNetworkType)) {
      query["ClbNetworkType"] = request.clbNetworkType;
    }

    if (!Util.isUnset(request.enableHardwareAcceleration)) {
      query["EnableHardwareAcceleration"] = request.enableHardwareAcceleration;
    }

    if (!Util.isUnset(request.enableSls)) {
      query["EnableSls"] = request.enableSls;
    }

    if (!Util.isUnset(request.enableXtrace)) {
      query["EnableXtrace"] = request.enableXtrace;
    }

    if (!Util.isUnset(request.enterpriseSecurityGroup)) {
      query["EnterpriseSecurityGroup"] = request.enterpriseSecurityGroup;
    }

    if (!Util.isUnset(request.internetSlbSpec)) {
      query["InternetSlbSpec"] = request.internetSlbSpec;
    }

    if (!Util.isUnset(request.mserVersion)) {
      query["MserVersion"] = request.mserVersion;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.nlbNetworkType)) {
      query["NlbNetworkType"] = request.nlbNetworkType;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.replica)) {
      query["Replica"] = request.replica;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.slbSpec)) {
      query["SlbSpec"] = request.slbSpec;
    }

    if (!Util.isUnset(request.spec)) {
      query["Spec"] = request.spec;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    if (!Util.isUnset(request.vSwitchId2)) {
      query["VSwitchId2"] = request.vSwitchId2;
    }

    if (!Util.isUnset(request.vpc)) {
      query["Vpc"] = request.vpc;
    }

    if (!Util.isUnset(request.xtraceRatio)) {
      query["XtraceRatio"] = request.xtraceRatio;
    }

    if (!Util.isUnset(request.zoneInfoShrink)) {
      query["ZoneInfo"] = request.zoneInfoShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddGateway",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddGatewayResponse>(await this.callApi(params, req, runtime), new AddGatewayResponse({}));
  }

  /**
   * Adds a gateway.
   * 
   * @param request - AddGatewayRequest
   * @returns AddGatewayResponse
   */
  async addGateway(request: AddGatewayRequest): Promise<AddGatewayResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addGatewayWithOptions(request, runtime);
  }

  /**
   * Adds an authentication configuration for a gateway.
   * 
   * @param tmpReq - AddGatewayAuthRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddGatewayAuthResponse
   */
  async addGatewayAuthWithOptions(tmpReq: AddGatewayAuthRequest, runtime: $Util.RuntimeOptions): Promise<AddGatewayAuthResponse> {
    Util.validateModel(tmpReq);
    let request = new AddGatewayAuthShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.authResourceList)) {
      request.authResourceListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.authResourceList, "AuthResourceList", "json");
    }

    if (!Util.isUnset(tmpReq.externalAuthZJSON)) {
      request.externalAuthZJSONShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.externalAuthZJSON, "ExternalAuthZJSON", "json");
    }

    if (!Util.isUnset(tmpReq.scopesList)) {
      request.scopesListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scopesList, "ScopesList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.authResourceConfig)) {
      query["AuthResourceConfig"] = request.authResourceConfig;
    }

    if (!Util.isUnset(request.authResourceListShrink)) {
      query["AuthResourceList"] = request.authResourceListShrink;
    }

    if (!Util.isUnset(request.authResourceMode)) {
      query["AuthResourceMode"] = request.authResourceMode;
    }

    if (!Util.isUnset(request.clientId)) {
      query["ClientId"] = request.clientId;
    }

    if (!Util.isUnset(request.clientSecret)) {
      query["ClientSecret"] = request.clientSecret;
    }

    if (!Util.isUnset(request.cookieDomain)) {
      query["CookieDomain"] = request.cookieDomain;
    }

    if (!Util.isUnset(request.externalAuthZJSONShrink)) {
      query["ExternalAuthZJSON"] = request.externalAuthZJSONShrink;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.isWhite)) {
      query["IsWhite"] = request.isWhite;
    }

    if (!Util.isUnset(request.issuer)) {
      query["Issuer"] = request.issuer;
    }

    if (!Util.isUnset(request.jwks)) {
      query["Jwks"] = request.jwks;
    }

    if (!Util.isUnset(request.loginUrl)) {
      query["LoginUrl"] = request.loginUrl;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.redirectUrl)) {
      query["RedirectUrl"] = request.redirectUrl;
    }

    if (!Util.isUnset(request.scopesListShrink)) {
      query["ScopesList"] = request.scopesListShrink;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.sub)) {
      query["Sub"] = request.sub;
    }

    if (!Util.isUnset(request.tokenName)) {
      query["TokenName"] = request.tokenName;
    }

    if (!Util.isUnset(request.tokenNamePrefix)) {
      query["TokenNamePrefix"] = request.tokenNamePrefix;
    }

    if (!Util.isUnset(request.tokenPass)) {
      query["TokenPass"] = request.tokenPass;
    }

    if (!Util.isUnset(request.tokenPosition)) {
      query["TokenPosition"] = request.tokenPosition;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddGatewayAuth",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddGatewayAuthResponse>(await this.callApi(params, req, runtime), new AddGatewayAuthResponse({}));
  }

  /**
   * Adds an authentication configuration for a gateway.
   * 
   * @param request - AddGatewayAuthRequest
   * @returns AddGatewayAuthResponse
   */
  async addGatewayAuth(request: AddGatewayAuthRequest): Promise<AddGatewayAuthResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addGatewayAuthWithOptions(request, runtime);
  }

  /**
   * Adds a consumer on which a gateway performs authentication operations.
   * 
   * @param request - AddGatewayAuthConsumerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddGatewayAuthConsumerResponse
   */
  async addGatewayAuthConsumerWithOptions(request: AddGatewayAuthConsumerRequest, runtime: $Util.RuntimeOptions): Promise<AddGatewayAuthConsumerResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.encodeType)) {
      query["EncodeType"] = request.encodeType;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.jwks)) {
      query["Jwks"] = request.jwks;
    }

    if (!Util.isUnset(request.keyName)) {
      query["KeyName"] = request.keyName;
    }

    if (!Util.isUnset(request.keyValue)) {
      query["KeyValue"] = request.keyValue;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.tokenName)) {
      query["TokenName"] = request.tokenName;
    }

    if (!Util.isUnset(request.tokenPass)) {
      query["TokenPass"] = request.tokenPass;
    }

    if (!Util.isUnset(request.tokenPosition)) {
      query["TokenPosition"] = request.tokenPosition;
    }

    if (!Util.isUnset(request.tokenPrefix)) {
      query["TokenPrefix"] = request.tokenPrefix;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddGatewayAuthConsumer",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddGatewayAuthConsumerResponse>(await this.callApi(params, req, runtime), new AddGatewayAuthConsumerResponse({}));
  }

  /**
   * Adds a consumer on which a gateway performs authentication operations.
   * 
   * @param request - AddGatewayAuthConsumerRequest
   * @returns AddGatewayAuthConsumerResponse
   */
  async addGatewayAuthConsumer(request: AddGatewayAuthConsumerRequest): Promise<AddGatewayAuthConsumerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addGatewayAuthConsumerWithOptions(request, runtime);
  }

  /**
   * Associates a domain name with a gateway.
   * 
   * @param request - AddGatewayDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddGatewayDomainResponse
   */
  async addGatewayDomainWithOptions(request: AddGatewayDomainRequest, runtime: $Util.RuntimeOptions): Promise<AddGatewayDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.certIdentifier)) {
      query["CertIdentifier"] = request.certIdentifier;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.http2)) {
      query["Http2"] = request.http2;
    }

    if (!Util.isUnset(request.mustHttps)) {
      query["MustHttps"] = request.mustHttps;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.protocol)) {
      query["Protocol"] = request.protocol;
    }

    if (!Util.isUnset(request.tlsMax)) {
      query["TlsMax"] = request.tlsMax;
    }

    if (!Util.isUnset(request.tlsMin)) {
      query["TlsMin"] = request.tlsMin;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddGatewayDomain",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddGatewayDomainResponse>(await this.callApi(params, req, runtime), new AddGatewayDomainResponse({}));
  }

  /**
   * Associates a domain name with a gateway.
   * 
   * @param request - AddGatewayDomainRequest
   * @returns AddGatewayDomainResponse
   */
  async addGatewayDomain(request: AddGatewayDomainRequest): Promise<AddGatewayDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addGatewayDomainWithOptions(request, runtime);
  }

  /**
   * Adds a gateway route.
   * 
   * @param tmpReq - AddGatewayRouteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddGatewayRouteResponse
   */
  async addGatewayRouteWithOptions(tmpReq: AddGatewayRouteRequest, runtime: $Util.RuntimeOptions): Promise<AddGatewayRouteResponse> {
    Util.validateModel(tmpReq);
    let request = new AddGatewayRouteShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.directResponseJSON)) {
      request.directResponseJSONShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.directResponseJSON, "DirectResponseJSON", "json");
    }

    if (!Util.isUnset(tmpReq.fallbackServices)) {
      request.fallbackServicesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fallbackServices, "FallbackServices", "json");
    }

    if (!Util.isUnset(tmpReq.predicates)) {
      request.predicatesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.predicates, "Predicates", "json");
    }

    if (!Util.isUnset(tmpReq.redirectJSON)) {
      request.redirectJSONShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.redirectJSON, "RedirectJSON", "json");
    }

    if (!Util.isUnset(tmpReq.services)) {
      request.servicesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.services, "Services", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.destinationType)) {
      query["DestinationType"] = request.destinationType;
    }

    if (!Util.isUnset(request.directResponseJSONShrink)) {
      query["DirectResponseJSON"] = request.directResponseJSONShrink;
    }

    if (!Util.isUnset(request.domainId)) {
      query["DomainId"] = request.domainId;
    }

    if (!Util.isUnset(request.domainIdListJSON)) {
      query["DomainIdListJSON"] = request.domainIdListJSON;
    }

    if (!Util.isUnset(request.enableWaf)) {
      query["EnableWaf"] = request.enableWaf;
    }

    if (!Util.isUnset(request.fallback)) {
      query["Fallback"] = request.fallback;
    }

    if (!Util.isUnset(request.fallbackServicesShrink)) {
      query["FallbackServices"] = request.fallbackServicesShrink;
    }

    if (!Util.isUnset(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.policies)) {
      query["Policies"] = request.policies;
    }

    if (!Util.isUnset(request.predicatesShrink)) {
      query["Predicates"] = request.predicatesShrink;
    }

    if (!Util.isUnset(request.redirectJSONShrink)) {
      query["RedirectJSON"] = request.redirectJSONShrink;
    }

    if (!Util.isUnset(request.routeOrder)) {
      query["RouteOrder"] = request.routeOrder;
    }

    if (!Util.isUnset(request.routeType)) {
      query["RouteType"] = request.routeType;
    }

    if (!Util.isUnset(request.servicesShrink)) {
      query["Services"] = request.servicesShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddGatewayRoute",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddGatewayRouteResponse>(await this.callApi(params, req, runtime), new AddGatewayRouteResponse({}));
  }

  /**
   * Adds a gateway route.
   * 
   * @param request - AddGatewayRouteRequest
   * @returns AddGatewayRouteResponse
   */
  async addGatewayRoute(request: AddGatewayRouteRequest): Promise<AddGatewayRouteResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addGatewayRouteWithOptions(request, runtime);
  }

  /**
   * Adds a service version.
   * 
   * @param request - AddGatewayServiceVersionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddGatewayServiceVersionResponse
   */
  async addGatewayServiceVersionWithOptions(request: AddGatewayServiceVersionRequest, runtime: $Util.RuntimeOptions): Promise<AddGatewayServiceVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.serviceId)) {
      query["ServiceId"] = request.serviceId;
    }

    if (!Util.isUnset(request.serviceVersion)) {
      query["ServiceVersion"] = request.serviceVersion;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddGatewayServiceVersion",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddGatewayServiceVersionResponse>(await this.callApi(params, req, runtime), new AddGatewayServiceVersionResponse({}));
  }

  /**
   * Adds a service version.
   * 
   * @param request - AddGatewayServiceVersionRequest
   * @returns AddGatewayServiceVersionResponse
   */
  async addGatewayServiceVersion(request: AddGatewayServiceVersionRequest): Promise<AddGatewayServiceVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addGatewayServiceVersionWithOptions(request, runtime);
  }

  /**
   * Associates a Server Load Balancer (SLB) instance with a gateway.
   * 
   * @param tmpReq - AddGatewaySlbRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddGatewaySlbResponse
   */
  async addGatewaySlbWithOptions(tmpReq: AddGatewaySlbRequest, runtime: $Util.RuntimeOptions): Promise<AddGatewaySlbResponse> {
    Util.validateModel(tmpReq);
    let request = new AddGatewaySlbShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.VServiceList)) {
      request.VServiceListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.VServiceList, "VServiceList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.httpPort)) {
      query["HttpPort"] = request.httpPort;
    }

    if (!Util.isUnset(request.httpsPort)) {
      query["HttpsPort"] = request.httpsPort;
    }

    if (!Util.isUnset(request.httpsVServerGroupId)) {
      query["HttpsVServerGroupId"] = request.httpsVServerGroupId;
    }

    if (!Util.isUnset(request.serviceWeight)) {
      query["ServiceWeight"] = request.serviceWeight;
    }

    if (!Util.isUnset(request.slbId)) {
      query["SlbId"] = request.slbId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.VServerGroupId)) {
      query["VServerGroupId"] = request.VServerGroupId;
    }

    if (!Util.isUnset(request.VServiceListShrink)) {
      query["VServiceList"] = request.VServiceListShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddGatewaySlb",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddGatewaySlbResponse>(await this.callApi(params, req, runtime), new AddGatewaySlbResponse({}));
  }

  /**
   * Associates a Server Load Balancer (SLB) instance with a gateway.
   * 
   * @param request - AddGatewaySlbRequest
   * @returns AddGatewaySlbResponse
   */
  async addGatewaySlb(request: AddGatewaySlbRequest): Promise<AddGatewaySlbResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addGatewaySlbWithOptions(request, runtime);
  }

  /**
   * Adds a migration task.
   * 
   * @param request - AddMigrationTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddMigrationTaskResponse
   */
  async addMigrationTaskWithOptions(request: AddMigrationTaskRequest, runtime: $Util.RuntimeOptions): Promise<AddMigrationTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterType)) {
      query["ClusterType"] = request.clusterType;
    }

    if (!Util.isUnset(request.originInstanceAddress)) {
      query["OriginInstanceAddress"] = request.originInstanceAddress;
    }

    if (!Util.isUnset(request.originInstanceName)) {
      query["OriginInstanceName"] = request.originInstanceName;
    }

    if (!Util.isUnset(request.originInstanceNamespace)) {
      query["OriginInstanceNamespace"] = request.originInstanceNamespace;
    }

    if (!Util.isUnset(request.projectDesc)) {
      query["ProjectDesc"] = request.projectDesc;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    if (!Util.isUnset(request.syncType)) {
      query["SyncType"] = request.syncType;
    }

    if (!Util.isUnset(request.targetClusterName)) {
      query["TargetClusterName"] = request.targetClusterName;
    }

    if (!Util.isUnset(request.targetClusterUrl)) {
      query["TargetClusterUrl"] = request.targetClusterUrl;
    }

    if (!Util.isUnset(request.targetInstanceId)) {
      query["TargetInstanceId"] = request.targetInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddMigrationTask",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddMigrationTaskResponse>(await this.callApi(params, req, runtime), new AddMigrationTaskResponse({}));
  }

  /**
   * Adds a migration task.
   * 
   * @param request - AddMigrationTaskRequest
   * @returns AddMigrationTaskResponse
   */
  async addMigrationTask(request: AddMigrationTaskRequest): Promise<AddMigrationTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addMigrationTaskWithOptions(request, runtime);
  }

  /**
   * Creates a mock rule.
   * 
   * @param request - AddMockRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddMockRuleResponse
   */
  async addMockRuleWithOptions(request: AddMockRuleRequest, runtime: $Util.RuntimeOptions): Promise<AddMockRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.consumerAppIds)) {
      query["ConsumerAppIds"] = request.consumerAppIds;
    }

    if (!Util.isUnset(request.dubboMockItems)) {
      query["DubboMockItems"] = request.dubboMockItems;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.extraJson)) {
      query["ExtraJson"] = request.extraJson;
    }

    if (!Util.isUnset(request.mockType)) {
      query["MockType"] = request.mockType;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.providerAppId)) {
      query["ProviderAppId"] = request.providerAppId;
    }

    if (!Util.isUnset(request.providerAppName)) {
      query["ProviderAppName"] = request.providerAppName;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.scMockItems)) {
      query["ScMockItems"] = request.scMockItems;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddMockRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddMockRuleResponse>(await this.callApi(params, req, runtime), new AddMockRuleResponse({}));
  }

  /**
   * Creates a mock rule.
   * 
   * @param request - AddMockRuleRequest
   * @returns AddMockRuleResponse
   */
  async addMockRule(request: AddMockRuleRequest): Promise<AddMockRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addMockRuleWithOptions(request, runtime);
  }

  /**
   * Associates a certificate with a domain name of a gateway. You can specify a certificate that is hosted in Alibaba Cloud Security.
   * 
   * @param request - AddSSLCertRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddSSLCertResponse
   */
  async addSSLCertWithOptions(request: AddSSLCertRequest, runtime: $Util.RuntimeOptions): Promise<AddSSLCertResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.certIdentifier)) {
      query["CertIdentifier"] = request.certIdentifier;
    }

    if (!Util.isUnset(request.domainId)) {
      query["DomainId"] = request.domainId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddSSLCert",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddSSLCertResponse>(await this.callApi(params, req, runtime), new AddSSLCertResponse({}));
  }

  /**
   * Associates a certificate with a domain name of a gateway. You can specify a certificate that is hosted in Alibaba Cloud Security.
   * 
   * @param request - AddSSLCertRequest
   * @returns AddSSLCertResponse
   */
  async addSSLCert(request: AddSSLCertRequest): Promise<AddSSLCertResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addSSLCertWithOptions(request, runtime);
  }

  /**
   * Creates a security group rule for a gateway.
   * 
   * @param request - AddSecurityGroupRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddSecurityGroupRuleResponse
   */
  async addSecurityGroupRuleWithOptions(request: AddSecurityGroupRuleRequest, runtime: $Util.RuntimeOptions): Promise<AddSecurityGroupRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.portRange)) {
      query["PortRange"] = request.portRange;
    }

    if (!Util.isUnset(request.securityGroupId)) {
      query["SecurityGroupId"] = request.securityGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddSecurityGroupRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddSecurityGroupRuleResponse>(await this.callApi(params, req, runtime), new AddSecurityGroupRuleResponse({}));
  }

  /**
   * Creates a security group rule for a gateway.
   * 
   * @param request - AddSecurityGroupRuleRequest
   * @returns AddSecurityGroupRuleResponse
   */
  async addSecurityGroupRule(request: AddSecurityGroupRuleRequest): Promise<AddSecurityGroupRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addSecurityGroupRuleWithOptions(request, runtime);
  }

  /**
   * Adds a Nacos service source.
   * 
   * @param tmpReq - AddServiceSourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddServiceSourceResponse
   */
  async addServiceSourceWithOptions(tmpReq: AddServiceSourceRequest, runtime: $Util.RuntimeOptions): Promise<AddServiceSourceResponse> {
    Util.validateModel(tmpReq);
    let request = new AddServiceSourceShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.groupList)) {
      request.groupListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.groupList, "GroupList", "json");
    }

    if (!Util.isUnset(tmpReq.ingressOptionsRequest)) {
      request.ingressOptionsRequestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ingressOptionsRequest, "IngressOptionsRequest", "json");
    }

    if (!Util.isUnset(tmpReq.pathList)) {
      request.pathListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.pathList, "PathList", "json");
    }

    if (!Util.isUnset(tmpReq.toAuthorizeSecurityGroups)) {
      request.toAuthorizeSecurityGroupsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.toAuthorizeSecurityGroups, "ToAuthorizeSecurityGroups", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.address)) {
      query["Address"] = request.address;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.groupListShrink)) {
      query["GroupList"] = request.groupListShrink;
    }

    if (!Util.isUnset(request.ingressOptionsRequestShrink)) {
      query["IngressOptionsRequest"] = request.ingressOptionsRequestShrink;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.pathListShrink)) {
      query["PathList"] = request.pathListShrink;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.toAuthorizeSecurityGroupsShrink)) {
      query["ToAuthorizeSecurityGroups"] = request.toAuthorizeSecurityGroupsShrink;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddServiceSource",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddServiceSourceResponse>(await this.callApi(params, req, runtime), new AddServiceSourceResponse({}));
  }

  /**
   * Adds a Nacos service source.
   * 
   * @param request - AddServiceSourceRequest
   * @returns AddServiceSourceResponse
   */
  async addServiceSource(request: AddServiceSourceRequest): Promise<AddServiceSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addServiceSourceWithOptions(request, runtime);
  }

  /**
   * Publishes a route for a gateway.
   * 
   * @param request - ApplyGatewayRouteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ApplyGatewayRouteResponse
   */
  async applyGatewayRouteWithOptions(request: ApplyGatewayRouteRequest, runtime: $Util.RuntimeOptions): Promise<ApplyGatewayRouteResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.routeId)) {
      query["RouteId"] = request.routeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ApplyGatewayRoute",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ApplyGatewayRouteResponse>(await this.callApi(params, req, runtime), new ApplyGatewayRouteResponse({}));
  }

  /**
   * Publishes a route for a gateway.
   * 
   * @param request - ApplyGatewayRouteRequest
   * @returns ApplyGatewayRouteResponse
   */
  async applyGatewayRoute(request: ApplyGatewayRouteRequest): Promise<ApplyGatewayRouteResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.applyGatewayRouteWithOptions(request, runtime);
  }

  /**
   * Modifies a tag-based routing rule.
   * 
   * @param tmpReq - ApplyTagPoliciesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ApplyTagPoliciesResponse
   */
  async applyTagPoliciesWithOptions(tmpReq: ApplyTagPoliciesRequest, runtime: $Util.RuntimeOptions): Promise<ApplyTagPoliciesResponse> {
    Util.validateModel(tmpReq);
    let request = new ApplyTagPoliciesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.rules)) {
      request.rulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.rules, "Rules", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.rulesShrink)) {
      query["Rules"] = request.rulesShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ApplyTagPolicies",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ApplyTagPoliciesResponse>(await this.callApi(params, req, runtime), new ApplyTagPoliciesResponse({}));
  }

  /**
   * Modifies a tag-based routing rule.
   * 
   * @param request - ApplyTagPoliciesRequest
   * @returns ApplyTagPoliciesResponse
   */
  async applyTagPolicies(request: ApplyTagPoliciesRequest): Promise<ApplyTagPoliciesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.applyTagPoliciesWithOptions(request, runtime);
  }

  /**
   * 绑定流量防护行为
   * 
   * @param request - BindSentinelBlockFallbackDefinitionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BindSentinelBlockFallbackDefinitionResponse
   */
  async bindSentinelBlockFallbackDefinitionWithOptions(request: BindSentinelBlockFallbackDefinitionRequest, runtime: $Util.RuntimeOptions): Promise<BindSentinelBlockFallbackDefinitionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.fallbackId)) {
      query["FallbackId"] = request.fallbackId;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.resource)) {
      query["Resource"] = request.resource;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BindSentinelBlockFallbackDefinition",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BindSentinelBlockFallbackDefinitionResponse>(await this.callApi(params, req, runtime), new BindSentinelBlockFallbackDefinitionResponse({}));
  }

  /**
   * 绑定流量防护行为
   * 
   * @param request - BindSentinelBlockFallbackDefinitionRequest
   * @returns BindSentinelBlockFallbackDefinitionResponse
   */
  async bindSentinelBlockFallbackDefinition(request: BindSentinelBlockFallbackDefinitionRequest): Promise<BindSentinelBlockFallbackDefinitionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindSentinelBlockFallbackDefinitionWithOptions(request, runtime);
  }

  /**
   * 资源转组
   * 
   * @param request - ChangeResourceGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ChangeResourceGroupResponse
   */
  async changeResourceGroupWithOptions(request: ChangeResourceGroupRequest, runtime: $Util.RuntimeOptions): Promise<ChangeResourceGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceRegionId)) {
      query["ResourceRegionId"] = request.resourceRegionId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ChangeResourceGroup",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ChangeResourceGroupResponse>(await this.callApi(params, req, runtime), new ChangeResourceGroupResponse({}));
  }

  /**
   * 资源转组
   * 
   * @param request - ChangeResourceGroupRequest
   * @returns ChangeResourceGroupResponse
   */
  async changeResourceGroup(request: ChangeResourceGroupRequest): Promise<ChangeResourceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.changeResourceGroupWithOptions(request, runtime);
  }

  /**
   * Clones an existing Nacos configuration from a namespace to another namespace.
   * 
   * @remarks
   * mse-200-105
   * 
   * @param request - CloneNacosConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CloneNacosConfigResponse
   */
  async cloneNacosConfigWithOptions(request: CloneNacosConfigRequest, runtime: $Util.RuntimeOptions): Promise<CloneNacosConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.dataIds)) {
      query["DataIds"] = request.dataIds;
    }

    if (!Util.isUnset(request.ids)) {
      query["Ids"] = request.ids;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.originNamespaceId)) {
      query["OriginNamespaceId"] = request.originNamespaceId;
    }

    if (!Util.isUnset(request.policy)) {
      query["Policy"] = request.policy;
    }

    if (!Util.isUnset(request.targetNamespaceId)) {
      query["TargetNamespaceId"] = request.targetNamespaceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CloneNacosConfig",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CloneNacosConfigResponse>(await this.callApi(params, req, runtime), new CloneNacosConfigResponse({}));
  }

  /**
   * Clones an existing Nacos configuration from a namespace to another namespace.
   * 
   * @remarks
   * mse-200-105
   * 
   * @param request - CloneNacosConfigRequest
   * @returns CloneNacosConfigResponse
   */
  async cloneNacosConfig(request: CloneNacosConfigRequest): Promise<CloneNacosConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cloneNacosConfigWithOptions(request, runtime);
  }

  /**
   * 从AHAS侧复制规则
   * 
   * @param request - CloneSentinelRuleFromAhasRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CloneSentinelRuleFromAhasResponse
   */
  async cloneSentinelRuleFromAhasWithOptions(request: CloneSentinelRuleFromAhasRequest, runtime: $Util.RuntimeOptions): Promise<CloneSentinelRuleFromAhasResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.ahasNamespace)) {
      query["AhasNamespace"] = request.ahasNamespace;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.isAHASPublicRegion)) {
      query["IsAHASPublicRegion"] = request.isAHASPublicRegion;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CloneSentinelRuleFromAhas",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CloneSentinelRuleFromAhasResponse>(await this.callApi(params, req, runtime), new CloneSentinelRuleFromAhasResponse({}));
  }

  /**
   * 从AHAS侧复制规则
   * 
   * @param request - CloneSentinelRuleFromAhasRequest
   * @returns CloneSentinelRuleFromAhasResponse
   */
  async cloneSentinelRuleFromAhas(request: CloneSentinelRuleFromAhasRequest): Promise<CloneSentinelRuleFromAhasResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cloneSentinelRuleFromAhasWithOptions(request, runtime);
  }

  /**
   * Creates an application.
   * 
   * @param request - CreateApplicationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateApplicationResponse
   */
  async createApplicationWithOptions(request: CreateApplicationRequest, runtime: $Util.RuntimeOptions): Promise<CreateApplicationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.language)) {
      query["Language"] = request.language;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.sentinelEnable)) {
      query["SentinelEnable"] = request.sentinelEnable;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.switchEnable)) {
      query["SwitchEnable"] = request.switchEnable;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateApplication",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateApplicationResponse>(await this.callApi(params, req, runtime), new CreateApplicationResponse({}));
  }

  /**
   * Creates an application.
   * 
   * @param request - CreateApplicationRequest
   * @returns CreateApplicationResponse
   */
  async createApplication(request: CreateApplicationRequest): Promise<CreateApplicationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createApplicationWithOptions(request, runtime);
  }

  /**
   * Creates a circuit breaking rule.
   * 
   * @param request - CreateCircuitBreakerRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateCircuitBreakerRuleResponse
   */
  async createCircuitBreakerRuleWithOptions(request: CreateCircuitBreakerRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateCircuitBreakerRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.halfOpenBaseAmountPerStep)) {
      query["HalfOpenBaseAmountPerStep"] = request.halfOpenBaseAmountPerStep;
    }

    if (!Util.isUnset(request.halfOpenRecoveryStepNum)) {
      query["HalfOpenRecoveryStepNum"] = request.halfOpenRecoveryStepNum;
    }

    if (!Util.isUnset(request.maxAllowedRtMs)) {
      query["MaxAllowedRtMs"] = request.maxAllowedRtMs;
    }

    if (!Util.isUnset(request.minRequestAmount)) {
      query["MinRequestAmount"] = request.minRequestAmount;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resource)) {
      query["Resource"] = request.resource;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.retryTimeoutMs)) {
      query["RetryTimeoutMs"] = request.retryTimeoutMs;
    }

    if (!Util.isUnset(request.statIntervalMs)) {
      query["StatIntervalMs"] = request.statIntervalMs;
    }

    if (!Util.isUnset(request.strategy)) {
      query["Strategy"] = request.strategy;
    }

    if (!Util.isUnset(request.threshold)) {
      query["Threshold"] = request.threshold;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateCircuitBreakerRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateCircuitBreakerRuleResponse>(await this.callApi(params, req, runtime), new CreateCircuitBreakerRuleResponse({}));
  }

  /**
   * Creates a circuit breaking rule.
   * 
   * @param request - CreateCircuitBreakerRuleRequest
   * @returns CreateCircuitBreakerRuleResponse
   */
  async createCircuitBreakerRule(request: CreateCircuitBreakerRuleRequest): Promise<CreateCircuitBreakerRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createCircuitBreakerRuleWithOptions(request, runtime);
  }

  /**
   * Creates a Microservices Engine (MSE) instance, such as an MSE ZooKeeper instance or an MSE Nacos instance.
   * 
   * @remarks
   * Before you call this API operation, you must make sure that you fully understand the billing methods and pricing of MSE.
   * 
   * @param request - CreateClusterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateClusterResponse
   */
  async createClusterWithOptions(request: CreateClusterRequest, runtime: $Util.RuntimeOptions): Promise<CreateClusterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.chargeType)) {
      query["ChargeType"] = request.chargeType;
    }

    if (!Util.isUnset(request.clusterSpecification)) {
      query["ClusterSpecification"] = request.clusterSpecification;
    }

    if (!Util.isUnset(request.clusterType)) {
      query["ClusterType"] = request.clusterType;
    }

    if (!Util.isUnset(request.clusterVersion)) {
      query["ClusterVersion"] = request.clusterVersion;
    }

    if (!Util.isUnset(request.connectionType)) {
      query["ConnectionType"] = request.connectionType;
    }

    if (!Util.isUnset(request.diskType)) {
      query["DiskType"] = request.diskType;
    }

    if (!Util.isUnset(request.eipEnabled)) {
      query["EipEnabled"] = request.eipEnabled;
    }

    if (!Util.isUnset(request.instanceCount)) {
      query["InstanceCount"] = request.instanceCount;
    }

    if (!Util.isUnset(request.instanceName)) {
      query["InstanceName"] = request.instanceName;
    }

    if (!Util.isUnset(request.mseVersion)) {
      query["MseVersion"] = request.mseVersion;
    }

    if (!Util.isUnset(request.netType)) {
      query["NetType"] = request.netType;
    }

    if (!Util.isUnset(request.privateSlbSpecification)) {
      query["PrivateSlbSpecification"] = request.privateSlbSpecification;
    }

    if (!Util.isUnset(request.pubNetworkFlow)) {
      query["PubNetworkFlow"] = request.pubNetworkFlow;
    }

    if (!Util.isUnset(request.pubSlbSpecification)) {
      query["PubSlbSpecification"] = request.pubSlbSpecification;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.securityGroupType)) {
      query["SecurityGroupType"] = request.securityGroupType;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateCluster",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateClusterResponse>(await this.callApi(params, req, runtime), new CreateClusterResponse({}));
  }

  /**
   * Creates a Microservices Engine (MSE) instance, such as an MSE ZooKeeper instance or an MSE Nacos instance.
   * 
   * @remarks
   * Before you call this API operation, you must make sure that you fully understand the billing methods and pricing of MSE.
   * 
   * @param request - CreateClusterRequest
   * @returns CreateClusterResponse
   */
  async createCluster(request: CreateClusterRequest): Promise<CreateClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createClusterWithOptions(request, runtime);
  }

  /**
   * Creates a namespace in a Nacos instance.
   * 
   * @param request - CreateEngineNamespaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateEngineNamespaceResponse
   */
  async createEngineNamespaceWithOptions(request: CreateEngineNamespaceRequest, runtime: $Util.RuntimeOptions): Promise<CreateEngineNamespaceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.desc)) {
      query["Desc"] = request.desc;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.serviceCount)) {
      query["ServiceCount"] = request.serviceCount;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateEngineNamespace",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEngineNamespaceResponse>(await this.callApi(params, req, runtime), new CreateEngineNamespaceResponse({}));
  }

  /**
   * Creates a namespace in a Nacos instance.
   * 
   * @param request - CreateEngineNamespaceRequest
   * @returns CreateEngineNamespaceResponse
   */
  async createEngineNamespace(request: CreateEngineNamespaceRequest): Promise<CreateEngineNamespaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEngineNamespaceWithOptions(request, runtime);
  }

  /**
   * Creates a throttling rule.
   * 
   * @param request - CreateFlowRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateFlowRuleResponse
   */
  async createFlowRuleWithOptions(request: CreateFlowRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateFlowRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.controlBehavior)) {
      query["ControlBehavior"] = request.controlBehavior;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.maxQueueingTimeMs)) {
      query["MaxQueueingTimeMs"] = request.maxQueueingTimeMs;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resource)) {
      query["Resource"] = request.resource;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.threshold)) {
      query["Threshold"] = request.threshold;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateFlowRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateFlowRuleResponse>(await this.callApi(params, req, runtime), new CreateFlowRuleResponse({}));
  }

  /**
   * Creates a throttling rule.
   * 
   * @param request - CreateFlowRuleRequest
   * @returns CreateFlowRuleResponse
   */
  async createFlowRule(request: CreateFlowRuleRequest): Promise<CreateFlowRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createFlowRuleWithOptions(request, runtime);
  }

  /**
   * 创建网关路由熔断规则
   * 
   * @param request - CreateGatewayCircuitBreakerRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateGatewayCircuitBreakerRuleResponse
   */
  async createGatewayCircuitBreakerRuleWithOptions(request: CreateGatewayCircuitBreakerRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateGatewayCircuitBreakerRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.behaviorType)) {
      query["BehaviorType"] = request.behaviorType;
    }

    if (!Util.isUnset(request.bodyEncoding)) {
      query["BodyEncoding"] = request.bodyEncoding;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.maxAllowedMs)) {
      query["MaxAllowedMs"] = request.maxAllowedMs;
    }

    if (!Util.isUnset(request.minRequestAmount)) {
      query["MinRequestAmount"] = request.minRequestAmount;
    }

    if (!Util.isUnset(request.recoveryTimeoutSec)) {
      query["RecoveryTimeoutSec"] = request.recoveryTimeoutSec;
    }

    if (!Util.isUnset(request.responseContentBody)) {
      query["ResponseContentBody"] = request.responseContentBody;
    }

    if (!Util.isUnset(request.responseRedirectUrl)) {
      query["ResponseRedirectUrl"] = request.responseRedirectUrl;
    }

    if (!Util.isUnset(request.responseStatusCode)) {
      query["ResponseStatusCode"] = request.responseStatusCode;
    }

    if (!Util.isUnset(request.routeId)) {
      query["RouteId"] = request.routeId;
    }

    if (!Util.isUnset(request.routeName)) {
      query["RouteName"] = request.routeName;
    }

    if (!Util.isUnset(request.statDurationSec)) {
      query["StatDurationSec"] = request.statDurationSec;
    }

    if (!Util.isUnset(request.strategy)) {
      query["Strategy"] = request.strategy;
    }

    if (!Util.isUnset(request.triggerRatio)) {
      query["TriggerRatio"] = request.triggerRatio;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateGatewayCircuitBreakerRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateGatewayCircuitBreakerRuleResponse>(await this.callApi(params, req, runtime), new CreateGatewayCircuitBreakerRuleResponse({}));
  }

  /**
   * 创建网关路由熔断规则
   * 
   * @param request - CreateGatewayCircuitBreakerRuleRequest
   * @returns CreateGatewayCircuitBreakerRuleResponse
   */
  async createGatewayCircuitBreakerRule(request: CreateGatewayCircuitBreakerRuleRequest): Promise<CreateGatewayCircuitBreakerRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createGatewayCircuitBreakerRuleWithOptions(request, runtime);
  }

  /**
   * Creates a throttling rule for a gateway.
   * 
   * @param request - CreateGatewayFlowRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateGatewayFlowRuleResponse
   */
  async createGatewayFlowRuleWithOptions(request: CreateGatewayFlowRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateGatewayFlowRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.behaviorType)) {
      query["BehaviorType"] = request.behaviorType;
    }

    if (!Util.isUnset(request.bodyEncoding)) {
      query["BodyEncoding"] = request.bodyEncoding;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.responseContentBody)) {
      query["ResponseContentBody"] = request.responseContentBody;
    }

    if (!Util.isUnset(request.responseRedirectUrl)) {
      query["ResponseRedirectUrl"] = request.responseRedirectUrl;
    }

    if (!Util.isUnset(request.responseStatusCode)) {
      query["ResponseStatusCode"] = request.responseStatusCode;
    }

    if (!Util.isUnset(request.routeId)) {
      query["RouteId"] = request.routeId;
    }

    if (!Util.isUnset(request.routeName)) {
      query["RouteName"] = request.routeName;
    }

    if (!Util.isUnset(request.threshold)) {
      query["Threshold"] = request.threshold;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateGatewayFlowRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateGatewayFlowRuleResponse>(await this.callApi(params, req, runtime), new CreateGatewayFlowRuleResponse({}));
  }

  /**
   * Creates a throttling rule for a gateway.
   * 
   * @param request - CreateGatewayFlowRuleRequest
   * @returns CreateGatewayFlowRuleResponse
   */
  async createGatewayFlowRule(request: CreateGatewayFlowRuleRequest): Promise<CreateGatewayFlowRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createGatewayFlowRuleWithOptions(request, runtime);
  }

  /**
   * 创建网关路由隔离规则
   * 
   * @param request - CreateGatewayIsolationRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateGatewayIsolationRuleResponse
   */
  async createGatewayIsolationRuleWithOptions(request: CreateGatewayIsolationRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateGatewayIsolationRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.behaviorType)) {
      query["BehaviorType"] = request.behaviorType;
    }

    if (!Util.isUnset(request.bodyEncoding)) {
      query["BodyEncoding"] = request.bodyEncoding;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.maxConcurrency)) {
      query["MaxConcurrency"] = request.maxConcurrency;
    }

    if (!Util.isUnset(request.responseContentBody)) {
      query["ResponseContentBody"] = request.responseContentBody;
    }

    if (!Util.isUnset(request.responseRedirectUrl)) {
      query["ResponseRedirectUrl"] = request.responseRedirectUrl;
    }

    if (!Util.isUnset(request.responseStatusCode)) {
      query["ResponseStatusCode"] = request.responseStatusCode;
    }

    if (!Util.isUnset(request.routeId)) {
      query["RouteId"] = request.routeId;
    }

    if (!Util.isUnset(request.routeName)) {
      query["RouteName"] = request.routeName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateGatewayIsolationRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateGatewayIsolationRuleResponse>(await this.callApi(params, req, runtime), new CreateGatewayIsolationRuleResponse({}));
  }

  /**
   * 创建网关路由隔离规则
   * 
   * @param request - CreateGatewayIsolationRuleRequest
   * @returns CreateGatewayIsolationRuleResponse
   */
  async createGatewayIsolationRule(request: CreateGatewayIsolationRuleRequest): Promise<CreateGatewayIsolationRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createGatewayIsolationRuleWithOptions(request, runtime);
  }

  /**
   * 创建隔离规则
   * 
   * @param request - CreateIsolationRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateIsolationRuleResponse
   */
  async createIsolationRuleWithOptions(request: CreateIsolationRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateIsolationRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resource)) {
      query["Resource"] = request.resource;
    }

    if (!Util.isUnset(request.threshold)) {
      query["Threshold"] = request.threshold;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateIsolationRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateIsolationRuleResponse>(await this.callApi(params, req, runtime), new CreateIsolationRuleResponse({}));
  }

  /**
   * 创建隔离规则
   * 
   * @param request - CreateIsolationRuleRequest
   * @returns CreateIsolationRuleResponse
   */
  async createIsolationRule(request: CreateIsolationRuleRequest): Promise<CreateIsolationRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createIsolationRuleWithOptions(request, runtime);
  }

  /**
   * Creates an application.
   * 
   * @deprecated OpenAPI CreateMseServiceApplication is deprecated, please use mse::2019-05-31::CreateApplication instead.
   * 
   * @param request - CreateMseServiceApplicationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateMseServiceApplicationResponse
   */
  // Deprecated
  async createMseServiceApplicationWithOptions(request: CreateMseServiceApplicationRequest, runtime: $Util.RuntimeOptions): Promise<CreateMseServiceApplicationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.extraInfo)) {
      query["ExtraInfo"] = request.extraInfo;
    }

    if (!Util.isUnset(request.language)) {
      query["Language"] = request.language;
    }

    if (!Util.isUnset(request.mseVersion)) {
      query["MseVersion"] = request.mseVersion;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.sentinelEnable)) {
      query["SentinelEnable"] = request.sentinelEnable;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.switchEnable)) {
      query["SwitchEnable"] = request.switchEnable;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateMseServiceApplication",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateMseServiceApplicationResponse>(await this.callApi(params, req, runtime), new CreateMseServiceApplicationResponse({}));
  }

  /**
   * Creates an application.
   * 
   * @deprecated OpenAPI CreateMseServiceApplication is deprecated, please use mse::2019-05-31::CreateApplication instead.
   * 
   * @param request - CreateMseServiceApplicationRequest
   * @returns CreateMseServiceApplicationResponse
   */
  // Deprecated
  async createMseServiceApplication(request: CreateMseServiceApplicationRequest): Promise<CreateMseServiceApplicationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createMseServiceApplicationWithOptions(request, runtime);
  }

  /**
   * Creates a Nacos configuration.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - CreateNacosConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateNacosConfigResponse
   */
  async createNacosConfigWithOptions(request: CreateNacosConfigRequest, runtime: $Util.RuntimeOptions): Promise<CreateNacosConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.betaIps)) {
      query["BetaIps"] = request.betaIps;
    }

    if (!Util.isUnset(request.content)) {
      query["Content"] = request.content;
    }

    if (!Util.isUnset(request.dataId)) {
      query["DataId"] = request.dataId;
    }

    if (!Util.isUnset(request.desc)) {
      query["Desc"] = request.desc;
    }

    if (!Util.isUnset(request.group)) {
      query["Group"] = request.group;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateNacosConfig",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateNacosConfigResponse>(await this.callApi(params, req, runtime), new CreateNacosConfigResponse({}));
  }

  /**
   * Creates a Nacos configuration.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - CreateNacosConfigRequest
   * @returns CreateNacosConfigResponse
   */
  async createNacosConfig(request: CreateNacosConfigRequest): Promise<CreateNacosConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createNacosConfigWithOptions(request, runtime);
  }

  /**
   * Creates a Nacos instance.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - CreateNacosInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateNacosInstanceResponse
   */
  async createNacosInstanceWithOptions(request: CreateNacosInstanceRequest, runtime: $Util.RuntimeOptions): Promise<CreateNacosInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterName)) {
      query["ClusterName"] = request.clusterName;
    }

    if (!Util.isUnset(request.enabled)) {
      query["Enabled"] = request.enabled;
    }

    if (!Util.isUnset(request.ephemeral)) {
      query["Ephemeral"] = request.ephemeral;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.serviceName)) {
      query["ServiceName"] = request.serviceName;
    }

    if (!Util.isUnset(request.weight)) {
      query["Weight"] = request.weight;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.metadata)) {
      body["Metadata"] = request.metadata;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateNacosInstance",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateNacosInstanceResponse>(await this.callApi(params, req, runtime), new CreateNacosInstanceResponse({}));
  }

  /**
   * Creates a Nacos instance.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - CreateNacosInstanceRequest
   * @returns CreateNacosInstanceResponse
   */
  async createNacosInstance(request: CreateNacosInstanceRequest): Promise<CreateNacosInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createNacosInstanceWithOptions(request, runtime);
  }

  /**
   * Creates a Nacos service.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - CreateNacosServiceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateNacosServiceResponse
   */
  async createNacosServiceWithOptions(request: CreateNacosServiceRequest, runtime: $Util.RuntimeOptions): Promise<CreateNacosServiceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.ephemeral)) {
      query["Ephemeral"] = request.ephemeral;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.protectThreshold)) {
      query["ProtectThreshold"] = request.protectThreshold;
    }

    if (!Util.isUnset(request.serviceName)) {
      query["ServiceName"] = request.serviceName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateNacosService",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateNacosServiceResponse>(await this.callApi(params, req, runtime), new CreateNacosServiceResponse({}));
  }

  /**
   * Creates a Nacos service.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - CreateNacosServiceRequest
   * @returns CreateNacosServiceResponse
   */
  async createNacosService(request: CreateNacosServiceRequest): Promise<CreateNacosServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createNacosServiceWithOptions(request, runtime);
  }

  /**
   * Creates or updates a lane for end-to-end canary release.
   * 
   * @param tmpReq - CreateOrUpdateSwimmingLaneRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateOrUpdateSwimmingLaneResponse
   */
  async createOrUpdateSwimmingLaneWithOptions(tmpReq: CreateOrUpdateSwimmingLaneRequest, runtime: $Util.RuntimeOptions): Promise<CreateOrUpdateSwimmingLaneResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateOrUpdateSwimmingLaneShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.gatewaySwimmingLaneRouteJson)) {
      request.gatewaySwimmingLaneRouteJsonShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.gatewaySwimmingLaneRouteJson, "GatewaySwimmingLaneRouteJson", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.enableRules)) {
      query["EnableRules"] = request.enableRules;
    }

    if (!Util.isUnset(request.entryRule)) {
      query["EntryRule"] = request.entryRule;
    }

    if (!Util.isUnset(request.gatewaySwimmingLaneRouteJsonShrink)) {
      query["GatewaySwimmingLaneRouteJson"] = request.gatewaySwimmingLaneRouteJsonShrink;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pathIndependentPercentageEnable)) {
      query["PathIndependentPercentageEnable"] = request.pathIndependentPercentageEnable;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.entryRules)) {
      body["EntryRules"] = request.entryRules;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateOrUpdateSwimmingLane",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOrUpdateSwimmingLaneResponse>(await this.callApi(params, req, runtime), new CreateOrUpdateSwimmingLaneResponse({}));
  }

  /**
   * Creates or updates a lane for end-to-end canary release.
   * 
   * @param request - CreateOrUpdateSwimmingLaneRequest
   * @returns CreateOrUpdateSwimmingLaneResponse
   */
  async createOrUpdateSwimmingLane(request: CreateOrUpdateSwimmingLaneRequest): Promise<CreateOrUpdateSwimmingLaneResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOrUpdateSwimmingLaneWithOptions(request, runtime);
  }

  /**
   * Creates or updates a lane group for end-to-end canary release.
   * 
   * @param tmpReq - CreateOrUpdateSwimmingLaneGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateOrUpdateSwimmingLaneGroupResponse
   */
  async createOrUpdateSwimmingLaneGroupWithOptions(tmpReq: CreateOrUpdateSwimmingLaneGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateOrUpdateSwimmingLaneGroupResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateOrUpdateSwimmingLaneGroupShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.paths)) {
      request.pathsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.paths, "Paths", "json");
    }

    if (!Util.isUnset(tmpReq.routeIds)) {
      request.routeIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.routeIds, "RouteIds", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appIds)) {
      query["AppIds"] = request.appIds;
    }

    if (!Util.isUnset(request.canaryModel)) {
      query["CanaryModel"] = request.canaryModel;
    }

    if (!Util.isUnset(request.dbGrayEnable)) {
      query["DbGrayEnable"] = request.dbGrayEnable;
    }

    if (!Util.isUnset(request.entryApp)) {
      query["EntryApp"] = request.entryApp;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.messageQueueFilterSide)) {
      query["MessageQueueFilterSide"] = request.messageQueueFilterSide;
    }

    if (!Util.isUnset(request.messageQueueGrayEnable)) {
      query["MessageQueueGrayEnable"] = request.messageQueueGrayEnable;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pathsShrink)) {
      query["Paths"] = request.pathsShrink;
    }

    if (!Util.isUnset(request.recordCanaryDetail)) {
      query["RecordCanaryDetail"] = request.recordCanaryDetail;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.routeIdsShrink)) {
      query["RouteIds"] = request.routeIdsShrink;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.swimVersion)) {
      query["SwimVersion"] = request.swimVersion;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateOrUpdateSwimmingLaneGroup",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOrUpdateSwimmingLaneGroupResponse>(await this.callApi(params, req, runtime), new CreateOrUpdateSwimmingLaneGroupResponse({}));
  }

  /**
   * Creates or updates a lane group for end-to-end canary release.
   * 
   * @param request - CreateOrUpdateSwimmingLaneGroupRequest
   * @returns CreateOrUpdateSwimmingLaneGroupResponse
   */
  async createOrUpdateSwimmingLaneGroup(request: CreateOrUpdateSwimmingLaneGroupRequest): Promise<CreateOrUpdateSwimmingLaneGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOrUpdateSwimmingLaneGroupWithOptions(request, runtime);
  }

  /**
   * Creates a plug-in configuration.
   * 
   * @param tmpReq - CreatePluginConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreatePluginConfigResponse
   */
  async createPluginConfigWithOptions(tmpReq: CreatePluginConfigRequest, runtime: $Util.RuntimeOptions): Promise<CreatePluginConfigResponse> {
    Util.validateModel(tmpReq);
    let request = new CreatePluginConfigShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.resourceIdList)) {
      request.resourceIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceIdList, "ResourceIdList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.configLevel)) {
      query["ConfigLevel"] = request.configLevel;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.pluginId)) {
      query["PluginId"] = request.pluginId;
    }

    if (!Util.isUnset(request.resourceIdListShrink)) {
      query["ResourceIdList"] = request.resourceIdListShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreatePluginConfig",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreatePluginConfigResponse>(await this.callApi(params, req, runtime), new CreatePluginConfigResponse({}));
  }

  /**
   * Creates a plug-in configuration.
   * 
   * @param request - CreatePluginConfigRequest
   * @returns CreatePluginConfigResponse
   */
  async createPluginConfig(request: CreatePluginConfigRequest): Promise<CreatePluginConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createPluginConfigWithOptions(request, runtime);
  }

  /**
   * Creates a znode.
   * 
   * @param request - CreateZnodeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateZnodeResponse
   */
  async createZnodeWithOptions(request: CreateZnodeRequest, runtime: $Util.RuntimeOptions): Promise<CreateZnodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.data)) {
      query["Data"] = request.data;
    }

    if (!Util.isUnset(request.path)) {
      query["Path"] = request.path;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateZnode",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateZnodeResponse>(await this.callApi(params, req, runtime), new CreateZnodeResponse({}));
  }

  /**
   * Creates a znode.
   * 
   * @param request - CreateZnodeRequest
   * @returns CreateZnodeResponse
   */
  async createZnode(request: CreateZnodeRequest): Promise<CreateZnodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createZnodeWithOptions(request, runtime);
  }

  /**
   * Deletes an authorized resource.
   * 
   * @param request - DeleteAuthResourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteAuthResourceResponse
   */
  async deleteAuthResourceWithOptions(request: DeleteAuthResourceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAuthResourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAuthResource",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteAuthResourceResponse>(await this.callApi(params, req, runtime), new DeleteAuthResourceResponse({}));
  }

  /**
   * Deletes an authorized resource.
   * 
   * @param request - DeleteAuthResourceRequest
   * @returns DeleteAuthResourceResponse
   */
  async deleteAuthResource(request: DeleteAuthResourceRequest): Promise<DeleteAuthResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAuthResourceWithOptions(request, runtime);
  }

  /**
   * Deletes circuit breaking rules.
   * 
   * @param tmpReq - DeleteCircuitBreakerRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteCircuitBreakerRulesResponse
   */
  async deleteCircuitBreakerRulesWithOptions(tmpReq: DeleteCircuitBreakerRulesRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCircuitBreakerRulesResponse> {
    Util.validateModel(tmpReq);
    let request = new DeleteCircuitBreakerRulesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.ids)) {
      request.idsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ids, "Ids", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.idsShrink)) {
      query["Ids"] = request.idsShrink;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCircuitBreakerRules",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteCircuitBreakerRulesResponse>(await this.callApi(params, req, runtime), new DeleteCircuitBreakerRulesResponse({}));
  }

  /**
   * Deletes circuit breaking rules.
   * 
   * @param request - DeleteCircuitBreakerRulesRequest
   * @returns DeleteCircuitBreakerRulesResponse
   */
  async deleteCircuitBreakerRules(request: DeleteCircuitBreakerRulesRequest): Promise<DeleteCircuitBreakerRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCircuitBreakerRulesWithOptions(request, runtime);
  }

  /**
   * Deletes a Microservices Engine (MSE) instance.
   * 
   * @param request - DeleteClusterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteClusterResponse
   */
  async deleteClusterWithOptions(request: DeleteClusterRequest, runtime: $Util.RuntimeOptions): Promise<DeleteClusterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCluster",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteClusterResponse>(await this.callApi(params, req, runtime), new DeleteClusterResponse({}));
  }

  /**
   * Deletes a Microservices Engine (MSE) instance.
   * 
   * @param request - DeleteClusterRequest
   * @returns DeleteClusterResponse
   */
  async deleteCluster(request: DeleteClusterRequest): Promise<DeleteClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteClusterWithOptions(request, runtime);
  }

  /**
   * Deletes a namespace from a Nacos instance.
   * 
   * @param request - DeleteEngineNamespaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteEngineNamespaceResponse
   */
  async deleteEngineNamespaceWithOptions(request: DeleteEngineNamespaceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEngineNamespaceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEngineNamespace",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteEngineNamespaceResponse>(await this.callApi(params, req, runtime), new DeleteEngineNamespaceResponse({}));
  }

  /**
   * Deletes a namespace from a Nacos instance.
   * 
   * @param request - DeleteEngineNamespaceRequest
   * @returns DeleteEngineNamespaceResponse
   */
  async deleteEngineNamespace(request: DeleteEngineNamespaceRequest): Promise<DeleteEngineNamespaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEngineNamespaceWithOptions(request, runtime);
  }

  /**
   * Deletes throttling rules.
   * 
   * @param tmpReq - DeleteFlowRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteFlowRulesResponse
   */
  async deleteFlowRulesWithOptions(tmpReq: DeleteFlowRulesRequest, runtime: $Util.RuntimeOptions): Promise<DeleteFlowRulesResponse> {
    Util.validateModel(tmpReq);
    let request = new DeleteFlowRulesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.ids)) {
      request.idsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ids, "Ids", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.idsShrink)) {
      query["Ids"] = request.idsShrink;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteFlowRules",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteFlowRulesResponse>(await this.callApi(params, req, runtime), new DeleteFlowRulesResponse({}));
  }

  /**
   * Deletes throttling rules.
   * 
   * @param request - DeleteFlowRulesRequest
   * @returns DeleteFlowRulesResponse
   */
  async deleteFlowRules(request: DeleteFlowRulesRequest): Promise<DeleteFlowRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteFlowRulesWithOptions(request, runtime);
  }

  /**
   * Deletes a gateway.
   * 
   * @param request - DeleteGatewayRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteGatewayResponse
   */
  async deleteGatewayWithOptions(request: DeleteGatewayRequest, runtime: $Util.RuntimeOptions): Promise<DeleteGatewayResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.deleteSlb)) {
      query["DeleteSlb"] = request.deleteSlb;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteGateway",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteGatewayResponse>(await this.callApi(params, req, runtime), new DeleteGatewayResponse({}));
  }

  /**
   * Deletes a gateway.
   * 
   * @param request - DeleteGatewayRequest
   * @returns DeleteGatewayResponse
   */
  async deleteGateway(request: DeleteGatewayRequest): Promise<DeleteGatewayResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteGatewayWithOptions(request, runtime);
  }

  /**
   * Deletes a consumer on which a gateway performs authentication operations.
   * 
   * @param request - DeleteGatewayAuthConsumerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteGatewayAuthConsumerResponse
   */
  async deleteGatewayAuthConsumerWithOptions(request: DeleteGatewayAuthConsumerRequest, runtime: $Util.RuntimeOptions): Promise<DeleteGatewayAuthConsumerResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteGatewayAuthConsumer",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteGatewayAuthConsumerResponse>(await this.callApi(params, req, runtime), new DeleteGatewayAuthConsumerResponse({}));
  }

  /**
   * Deletes a consumer on which a gateway performs authentication operations.
   * 
   * @param request - DeleteGatewayAuthConsumerRequest
   * @returns DeleteGatewayAuthConsumerResponse
   */
  async deleteGatewayAuthConsumer(request: DeleteGatewayAuthConsumerRequest): Promise<DeleteGatewayAuthConsumerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteGatewayAuthConsumerWithOptions(request, runtime);
  }

  /**
   * Deletes resource permissions from the consumer on which a gateway performs authentication operations.
   * 
   * @param request - DeleteGatewayAuthConsumerResourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteGatewayAuthConsumerResourceResponse
   */
  async deleteGatewayAuthConsumerResourceWithOptions(request: DeleteGatewayAuthConsumerResourceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteGatewayAuthConsumerResourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.consumerId)) {
      query["ConsumerId"] = request.consumerId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.idList)) {
      query["IdList"] = request.idList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteGatewayAuthConsumerResource",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteGatewayAuthConsumerResourceResponse>(await this.callApi(params, req, runtime), new DeleteGatewayAuthConsumerResourceResponse({}));
  }

  /**
   * Deletes resource permissions from the consumer on which a gateway performs authentication operations.
   * 
   * @param request - DeleteGatewayAuthConsumerResourceRequest
   * @returns DeleteGatewayAuthConsumerResourceResponse
   */
  async deleteGatewayAuthConsumerResource(request: DeleteGatewayAuthConsumerResourceRequest): Promise<DeleteGatewayAuthConsumerResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteGatewayAuthConsumerResourceWithOptions(request, runtime);
  }

  /**
   * 删除网关路由熔断规则
   * 
   * @param request - DeleteGatewayCircuitBreakerRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteGatewayCircuitBreakerRuleResponse
   */
  async deleteGatewayCircuitBreakerRuleWithOptions(request: DeleteGatewayCircuitBreakerRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteGatewayCircuitBreakerRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.routeId)) {
      query["RouteId"] = request.routeId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteGatewayCircuitBreakerRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteGatewayCircuitBreakerRuleResponse>(await this.callApi(params, req, runtime), new DeleteGatewayCircuitBreakerRuleResponse({}));
  }

  /**
   * 删除网关路由熔断规则
   * 
   * @param request - DeleteGatewayCircuitBreakerRuleRequest
   * @returns DeleteGatewayCircuitBreakerRuleResponse
   */
  async deleteGatewayCircuitBreakerRule(request: DeleteGatewayCircuitBreakerRuleRequest): Promise<DeleteGatewayCircuitBreakerRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteGatewayCircuitBreakerRuleWithOptions(request, runtime);
  }

  /**
   * Disassociates a domain name from a gateway.
   * 
   * @param request - DeleteGatewayDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteGatewayDomainResponse
   */
  async deleteGatewayDomainWithOptions(request: DeleteGatewayDomainRequest, runtime: $Util.RuntimeOptions): Promise<DeleteGatewayDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteGatewayDomain",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteGatewayDomainResponse>(await this.callApi(params, req, runtime), new DeleteGatewayDomainResponse({}));
  }

  /**
   * Disassociates a domain name from a gateway.
   * 
   * @param request - DeleteGatewayDomainRequest
   * @returns DeleteGatewayDomainResponse
   */
  async deleteGatewayDomain(request: DeleteGatewayDomainRequest): Promise<DeleteGatewayDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteGatewayDomainWithOptions(request, runtime);
  }

  /**
   * 删除网关路由流控规则
   * 
   * @param request - DeleteGatewayFlowRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteGatewayFlowRuleResponse
   */
  async deleteGatewayFlowRuleWithOptions(request: DeleteGatewayFlowRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteGatewayFlowRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.routeId)) {
      query["RouteId"] = request.routeId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteGatewayFlowRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteGatewayFlowRuleResponse>(await this.callApi(params, req, runtime), new DeleteGatewayFlowRuleResponse({}));
  }

  /**
   * 删除网关路由流控规则
   * 
   * @param request - DeleteGatewayFlowRuleRequest
   * @returns DeleteGatewayFlowRuleResponse
   */
  async deleteGatewayFlowRule(request: DeleteGatewayFlowRuleRequest): Promise<DeleteGatewayFlowRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteGatewayFlowRuleWithOptions(request, runtime);
  }

  /**
   * 删除网关路由隔离规则
   * 
   * @param request - DeleteGatewayIsolationRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteGatewayIsolationRuleResponse
   */
  async deleteGatewayIsolationRuleWithOptions(request: DeleteGatewayIsolationRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteGatewayIsolationRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.routeId)) {
      query["RouteId"] = request.routeId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteGatewayIsolationRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteGatewayIsolationRuleResponse>(await this.callApi(params, req, runtime), new DeleteGatewayIsolationRuleResponse({}));
  }

  /**
   * 删除网关路由隔离规则
   * 
   * @param request - DeleteGatewayIsolationRuleRequest
   * @returns DeleteGatewayIsolationRuleResponse
   */
  async deleteGatewayIsolationRule(request: DeleteGatewayIsolationRuleRequest): Promise<DeleteGatewayIsolationRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteGatewayIsolationRuleWithOptions(request, runtime);
  }

  /**
   * Deletes a route from a gateway.
   * 
   * @param request - DeleteGatewayRouteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteGatewayRouteResponse
   */
  async deleteGatewayRouteWithOptions(request: DeleteGatewayRouteRequest, runtime: $Util.RuntimeOptions): Promise<DeleteGatewayRouteResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.routeId)) {
      query["RouteId"] = request.routeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteGatewayRoute",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteGatewayRouteResponse>(await this.callApi(params, req, runtime), new DeleteGatewayRouteResponse({}));
  }

  /**
   * Deletes a route from a gateway.
   * 
   * @param request - DeleteGatewayRouteRequest
   * @returns DeleteGatewayRouteResponse
   */
  async deleteGatewayRoute(request: DeleteGatewayRouteRequest): Promise<DeleteGatewayRouteResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteGatewayRouteWithOptions(request, runtime);
  }

  /**
   * Deletes a service from a gateway.
   * 
   * @param request - DeleteGatewayServiceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteGatewayServiceResponse
   */
  async deleteGatewayServiceWithOptions(request: DeleteGatewayServiceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteGatewayServiceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.serviceId)) {
      query["ServiceId"] = request.serviceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteGatewayService",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteGatewayServiceResponse>(await this.callApi(params, req, runtime), new DeleteGatewayServiceResponse({}));
  }

  /**
   * Deletes a service from a gateway.
   * 
   * @param request - DeleteGatewayServiceRequest
   * @returns DeleteGatewayServiceResponse
   */
  async deleteGatewayService(request: DeleteGatewayServiceRequest): Promise<DeleteGatewayServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteGatewayServiceWithOptions(request, runtime);
  }

  /**
   * Deletes a service version from a gateway.
   * 
   * @param request - DeleteGatewayServiceVersionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteGatewayServiceVersionResponse
   */
  async deleteGatewayServiceVersionWithOptions(request: DeleteGatewayServiceVersionRequest, runtime: $Util.RuntimeOptions): Promise<DeleteGatewayServiceVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.serviceId)) {
      query["ServiceId"] = request.serviceId;
    }

    if (!Util.isUnset(request.serviceVersion)) {
      query["ServiceVersion"] = request.serviceVersion;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteGatewayServiceVersion",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteGatewayServiceVersionResponse>(await this.callApi(params, req, runtime), new DeleteGatewayServiceVersionResponse({}));
  }

  /**
   * Deletes a service version from a gateway.
   * 
   * @param request - DeleteGatewayServiceVersionRequest
   * @returns DeleteGatewayServiceVersionResponse
   */
  async deleteGatewayServiceVersion(request: DeleteGatewayServiceVersionRequest): Promise<DeleteGatewayServiceVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteGatewayServiceVersionWithOptions(request, runtime);
  }

  /**
   * Deletes the Server Load Balancer (SLB) instance that is associated with a gateway.
   * 
   * @param request - DeleteGatewaySlbRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteGatewaySlbResponse
   */
  async deleteGatewaySlbWithOptions(request: DeleteGatewaySlbRequest, runtime: $Util.RuntimeOptions): Promise<DeleteGatewaySlbResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.deleteSlb)) {
      query["DeleteSlb"] = request.deleteSlb;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.slbId)) {
      query["SlbId"] = request.slbId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteGatewaySlb",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteGatewaySlbResponse>(await this.callApi(params, req, runtime), new DeleteGatewaySlbResponse({}));
  }

  /**
   * Deletes the Server Load Balancer (SLB) instance that is associated with a gateway.
   * 
   * @param request - DeleteGatewaySlbRequest
   * @returns DeleteGatewaySlbResponse
   */
  async deleteGatewaySlb(request: DeleteGatewaySlbRequest): Promise<DeleteGatewaySlbResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteGatewaySlbWithOptions(request, runtime);
  }

  /**
   * 删除隔离规则
   * 
   * @param tmpReq - DeleteIsolationRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteIsolationRulesResponse
   */
  async deleteIsolationRulesWithOptions(tmpReq: DeleteIsolationRulesRequest, runtime: $Util.RuntimeOptions): Promise<DeleteIsolationRulesResponse> {
    Util.validateModel(tmpReq);
    let request = new DeleteIsolationRulesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.ids)) {
      request.idsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ids, "Ids", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.idsShrink)) {
      query["Ids"] = request.idsShrink;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteIsolationRules",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteIsolationRulesResponse>(await this.callApi(params, req, runtime), new DeleteIsolationRulesResponse({}));
  }

  /**
   * 删除隔离规则
   * 
   * @param request - DeleteIsolationRulesRequest
   * @returns DeleteIsolationRulesResponse
   */
  async deleteIsolationRules(request: DeleteIsolationRulesRequest): Promise<DeleteIsolationRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteIsolationRulesWithOptions(request, runtime);
  }

  /**
   * Deletes a migration task.
   * 
   * @param request - DeleteMigrationTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteMigrationTaskResponse
   */
  async deleteMigrationTaskWithOptions(request: DeleteMigrationTaskRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMigrationTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMigrationTask",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMigrationTaskResponse>(await this.callApi(params, req, runtime), new DeleteMigrationTaskResponse({}));
  }

  /**
   * Deletes a migration task.
   * 
   * @param request - DeleteMigrationTaskRequest
   * @returns DeleteMigrationTaskResponse
   */
  async deleteMigrationTask(request: DeleteMigrationTaskRequest): Promise<DeleteMigrationTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMigrationTaskWithOptions(request, runtime);
  }

  /**
   * 删除nacos指定配置
   * 
   * @param request - DeleteNacosConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteNacosConfigResponse
   */
  async deleteNacosConfigWithOptions(request: DeleteNacosConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteNacosConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.beta)) {
      query["Beta"] = request.beta;
    }

    if (!Util.isUnset(request.dataId)) {
      query["DataId"] = request.dataId;
    }

    if (!Util.isUnset(request.group)) {
      query["Group"] = request.group;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteNacosConfig",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteNacosConfigResponse>(await this.callApi(params, req, runtime), new DeleteNacosConfigResponse({}));
  }

  /**
   * 删除nacos指定配置
   * 
   * @param request - DeleteNacosConfigRequest
   * @returns DeleteNacosConfigResponse
   */
  async deleteNacosConfig(request: DeleteNacosConfigRequest): Promise<DeleteNacosConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteNacosConfigWithOptions(request, runtime);
  }

  /**
   * Deletes multiple Nacos configurations at a time.
   * 
   * @remarks
   * >  The current API operation is not provided in Nacos SDK. For more information about the Nacos-SDK API, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - DeleteNacosConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteNacosConfigsResponse
   */
  async deleteNacosConfigsWithOptions(request: DeleteNacosConfigsRequest, runtime: $Util.RuntimeOptions): Promise<DeleteNacosConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.ids)) {
      query["Ids"] = request.ids;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteNacosConfigs",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteNacosConfigsResponse>(await this.callApi(params, req, runtime), new DeleteNacosConfigsResponse({}));
  }

  /**
   * Deletes multiple Nacos configurations at a time.
   * 
   * @remarks
   * >  The current API operation is not provided in Nacos SDK. For more information about the Nacos-SDK API, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - DeleteNacosConfigsRequest
   * @returns DeleteNacosConfigsResponse
   */
  async deleteNacosConfigs(request: DeleteNacosConfigsRequest): Promise<DeleteNacosConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteNacosConfigsWithOptions(request, runtime);
  }

  /**
   * Deletes a persistent application instance from a Microservices Engine (MSE) Nacos instance.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - DeleteNacosInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteNacosInstanceResponse
   */
  async deleteNacosInstanceWithOptions(request: DeleteNacosInstanceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteNacosInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterName)) {
      query["ClusterName"] = request.clusterName;
    }

    if (!Util.isUnset(request.ephemeral)) {
      query["Ephemeral"] = request.ephemeral;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.serviceName)) {
      query["ServiceName"] = request.serviceName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteNacosInstance",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteNacosInstanceResponse>(await this.callApi(params, req, runtime), new DeleteNacosInstanceResponse({}));
  }

  /**
   * Deletes a persistent application instance from a Microservices Engine (MSE) Nacos instance.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - DeleteNacosInstanceRequest
   * @returns DeleteNacosInstanceResponse
   */
  async deleteNacosInstance(request: DeleteNacosInstanceRequest): Promise<DeleteNacosInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteNacosInstanceWithOptions(request, runtime);
  }

  /**
   * Deletes a Nacos service.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - DeleteNacosServiceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteNacosServiceResponse
   */
  async deleteNacosServiceWithOptions(request: DeleteNacosServiceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteNacosServiceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.serviceName)) {
      query["ServiceName"] = request.serviceName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteNacosService",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteNacosServiceResponse>(await this.callApi(params, req, runtime), new DeleteNacosServiceResponse({}));
  }

  /**
   * Deletes a Nacos service.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - DeleteNacosServiceRequest
   * @returns DeleteNacosServiceResponse
   */
  async deleteNacosService(request: DeleteNacosServiceRequest): Promise<DeleteNacosServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteNacosServiceWithOptions(request, runtime);
  }

  /**
   * 删除MSE命名空间
   * 
   * @param request - DeleteNamespaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteNamespaceResponse
   */
  async deleteNamespaceWithOptions(request: DeleteNamespaceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteNamespaceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteNamespace",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteNamespaceResponse>(await this.callApi(params, req, runtime), new DeleteNamespaceResponse({}));
  }

  /**
   * 删除MSE命名空间
   * 
   * @param request - DeleteNamespaceRequest
   * @returns DeleteNamespaceResponse
   */
  async deleteNamespace(request: DeleteNamespaceRequest): Promise<DeleteNamespaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteNamespaceWithOptions(request, runtime);
  }

  /**
   * Deletes a plug-in configuration.
   * 
   * @param request - DeletePluginConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeletePluginConfigResponse
   */
  async deletePluginConfigWithOptions(request: DeletePluginConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeletePluginConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.pluginConfigId)) {
      query["PluginConfigId"] = request.pluginConfigId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeletePluginConfig",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeletePluginConfigResponse>(await this.callApi(params, req, runtime), new DeletePluginConfigResponse({}));
  }

  /**
   * Deletes a plug-in configuration.
   * 
   * @param request - DeletePluginConfigRequest
   * @returns DeletePluginConfigResponse
   */
  async deletePluginConfig(request: DeletePluginConfigRequest): Promise<DeletePluginConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deletePluginConfigWithOptions(request, runtime);
  }

  /**
   * Deletes a security group rule from a gateway.
   * 
   * @param request - DeleteSecurityGroupRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteSecurityGroupRuleResponse
   */
  async deleteSecurityGroupRuleWithOptions(request: DeleteSecurityGroupRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSecurityGroupRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.cascadingDelete)) {
      query["CascadingDelete"] = request.cascadingDelete;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSecurityGroupRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSecurityGroupRuleResponse>(await this.callApi(params, req, runtime), new DeleteSecurityGroupRuleResponse({}));
  }

  /**
   * Deletes a security group rule from a gateway.
   * 
   * @param request - DeleteSecurityGroupRuleRequest
   * @returns DeleteSecurityGroupRuleResponse
   */
  async deleteSecurityGroupRule(request: DeleteSecurityGroupRuleRequest): Promise<DeleteSecurityGroupRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSecurityGroupRuleWithOptions(request, runtime);
  }

  /**
   * Deletes a gateway service source.
   * 
   * @param request - DeleteServiceSourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteServiceSourceResponse
   */
  async deleteServiceSourceWithOptions(request: DeleteServiceSourceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteServiceSourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.sourceId)) {
      query["SourceId"] = request.sourceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteServiceSource",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteServiceSourceResponse>(await this.callApi(params, req, runtime), new DeleteServiceSourceResponse({}));
  }

  /**
   * Deletes a gateway service source.
   * 
   * @param request - DeleteServiceSourceRequest
   * @returns DeleteServiceSourceResponse
   */
  async deleteServiceSource(request: DeleteServiceSourceRequest): Promise<DeleteServiceSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteServiceSourceWithOptions(request, runtime);
  }

  /**
   * Deletes a lane.
   * 
   * @param request - DeleteSwimmingLaneRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteSwimmingLaneResponse
   */
  async deleteSwimmingLaneWithOptions(request: DeleteSwimmingLaneRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSwimmingLaneResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.laneId)) {
      query["LaneId"] = request.laneId;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSwimmingLane",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSwimmingLaneResponse>(await this.callApi(params, req, runtime), new DeleteSwimmingLaneResponse({}));
  }

  /**
   * Deletes a lane.
   * 
   * @param request - DeleteSwimmingLaneRequest
   * @returns DeleteSwimmingLaneResponse
   */
  async deleteSwimmingLane(request: DeleteSwimmingLaneRequest): Promise<DeleteSwimmingLaneResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSwimmingLaneWithOptions(request, runtime);
  }

  /**
   * Deletes a lane group.
   * 
   * @param request - DeleteSwimmingLaneGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteSwimmingLaneGroupResponse
   */
  async deleteSwimmingLaneGroupWithOptions(request: DeleteSwimmingLaneGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSwimmingLaneGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSwimmingLaneGroup",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSwimmingLaneGroupResponse>(await this.callApi(params, req, runtime), new DeleteSwimmingLaneGroupResponse({}));
  }

  /**
   * Deletes a lane group.
   * 
   * @param request - DeleteSwimmingLaneGroupRequest
   * @returns DeleteSwimmingLaneGroupResponse
   */
  async deleteSwimmingLaneGroup(request: DeleteSwimmingLaneGroupRequest): Promise<DeleteSwimmingLaneGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSwimmingLaneGroupWithOptions(request, runtime);
  }

  /**
   * Deletes a ZooKeeper node.
   * 
   * @param request - DeleteZnodeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteZnodeResponse
   */
  async deleteZnodeWithOptions(request: DeleteZnodeRequest, runtime: $Util.RuntimeOptions): Promise<DeleteZnodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.path)) {
      query["Path"] = request.path;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteZnode",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteZnodeResponse>(await this.callApi(params, req, runtime), new DeleteZnodeResponse({}));
  }

  /**
   * Deletes a ZooKeeper node.
   * 
   * @param request - DeleteZnodeRequest
   * @returns DeleteZnodeResponse
   */
  async deleteZnode(request: DeleteZnodeRequest): Promise<DeleteZnodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteZnodeWithOptions(request, runtime);
  }

  /**
   * Enables HTTP/2 for negotiation between the server and client. The modification takes effect in one to two minutes.
   * 
   * @param request - EnableHttp2Request
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnableHttp2Response
   */
  async enableHttp2WithOptions(request: EnableHttp2Request, runtime: $Util.RuntimeOptions): Promise<EnableHttp2Response> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.enableHttp2)) {
      query["EnableHttp2"] = request.enableHttp2;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableHttp2",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableHttp2Response>(await this.callApi(params, req, runtime), new EnableHttp2Response({}));
  }

  /**
   * Enables HTTP/2 for negotiation between the server and client. The modification takes effect in one to two minutes.
   * 
   * @param request - EnableHttp2Request
   * @returns EnableHttp2Response
   */
  async enableHttp2(request: EnableHttp2Request): Promise<EnableHttp2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableHttp2WithOptions(request, runtime);
  }

  /**
   * Enables the proxy protocol. When an NLB instance is used as an ingress, you cannot obtain the real IP address of the client if you do not enable the proxy protocol. After you enable the proxy protocol, non-proxy requests are not adversely affected.
   * 
   * @param request - EnableProxyProtocolRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnableProxyProtocolResponse
   */
  async enableProxyProtocolWithOptions(request: EnableProxyProtocolRequest, runtime: $Util.RuntimeOptions): Promise<EnableProxyProtocolResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.enableProxyProtocol)) {
      query["EnableProxyProtocol"] = request.enableProxyProtocol;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableProxyProtocol",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableProxyProtocolResponse>(await this.callApi(params, req, runtime), new EnableProxyProtocolResponse({}));
  }

  /**
   * Enables the proxy protocol. When an NLB instance is used as an ingress, you cannot obtain the real IP address of the client if you do not enable the proxy protocol. After you enable the proxy protocol, non-proxy requests are not adversely affected.
   * 
   * @param request - EnableProxyProtocolRequest
   * @returns EnableProxyProtocolResponse
   */
  async enableProxyProtocol(request: EnableProxyProtocolRequest): Promise<EnableProxyProtocolResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableProxyProtocolWithOptions(request, runtime);
  }

  /**
   * Exports specified Nacos configurations.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - ExportNacosConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExportNacosConfigResponse
   */
  async exportNacosConfigWithOptions(request: ExportNacosConfigRequest, runtime: $Util.RuntimeOptions): Promise<ExportNacosConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.dataId)) {
      query["DataId"] = request.dataId;
    }

    if (!Util.isUnset(request.dataIds)) {
      query["DataIds"] = request.dataIds;
    }

    if (!Util.isUnset(request.group)) {
      query["Group"] = request.group;
    }

    if (!Util.isUnset(request.ids)) {
      query["Ids"] = request.ids;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ExportNacosConfig",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExportNacosConfigResponse>(await this.callApi(params, req, runtime), new ExportNacosConfigResponse({}));
  }

  /**
   * Exports specified Nacos configurations.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - ExportNacosConfigRequest
   * @returns ExportNacosConfigResponse
   */
  async exportNacosConfig(request: ExportNacosConfigRequest): Promise<ExportNacosConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.exportNacosConfigWithOptions(request, runtime);
  }

  /**
   * Initiates a task to export ZooKeeper data.
   * 
   * @remarks
   * Only one task can run at a time.
   * 
   * @param request - ExportZookeeperDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExportZookeeperDataResponse
   */
  async exportZookeeperDataWithOptions(request: ExportZookeeperDataRequest, runtime: $Util.RuntimeOptions): Promise<ExportZookeeperDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.exportType)) {
      query["ExportType"] = request.exportType;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ExportZookeeperData",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExportZookeeperDataResponse>(await this.callApi(params, req, runtime), new ExportZookeeperDataResponse({}));
  }

  /**
   * Initiates a task to export ZooKeeper data.
   * 
   * @remarks
   * Only one task can run at a time.
   * 
   * @param request - ExportZookeeperDataRequest
   * @returns ExportZookeeperDataResponse
   */
  async exportZookeeperData(request: ExportZookeeperDataRequest): Promise<ExportZookeeperDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.exportZookeeperDataWithOptions(request, runtime);
  }

  /**
   * Obtains the rules for graceful start and shutdown.
   * 
   * @remarks
   * You can call this operation to query the rules for graceful start and shutdown.
   * 
   * @param request - FetchLosslessRuleListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns FetchLosslessRuleListResponse
   */
  async fetchLosslessRuleListWithOptions(request: FetchLosslessRuleListRequest, runtime: $Util.RuntimeOptions): Promise<FetchLosslessRuleListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "FetchLosslessRuleList",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<FetchLosslessRuleListResponse>(await this.callApi(params, req, runtime), new FetchLosslessRuleListResponse({}));
  }

  /**
   * Obtains the rules for graceful start and shutdown.
   * 
   * @remarks
   * You can call this operation to query the rules for graceful start and shutdown.
   * 
   * @param request - FetchLosslessRuleListRequest
   * @returns FetchLosslessRuleListResponse
   */
  async fetchLosslessRuleList(request: FetchLosslessRuleListRequest): Promise<FetchLosslessRuleListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.fetchLosslessRuleListWithOptions(request, runtime);
  }

  /**
   * Queries a list of blacklists and whitelists of a gateway.
   * 
   * @param tmpReq - GatewayBlackWhiteListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GatewayBlackWhiteListResponse
   */
  async gatewayBlackWhiteListWithOptions(tmpReq: GatewayBlackWhiteListRequest, runtime: $Util.RuntimeOptions): Promise<GatewayBlackWhiteListResponse> {
    Util.validateModel(tmpReq);
    let request = new GatewayBlackWhiteListShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.filterParams)) {
      request.filterParamsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterParams, "FilterParams", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.descSort)) {
      query["DescSort"] = request.descSort;
    }

    if (!Util.isUnset(request.filterParamsShrink)) {
      query["FilterParams"] = request.filterParamsShrink;
    }

    if (!Util.isUnset(request.orderItem)) {
      query["OrderItem"] = request.orderItem;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GatewayBlackWhiteList",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GatewayBlackWhiteListResponse>(await this.callApi(params, req, runtime), new GatewayBlackWhiteListResponse({}));
  }

  /**
   * Queries a list of blacklists and whitelists of a gateway.
   * 
   * @param request - GatewayBlackWhiteListRequest
   * @returns GatewayBlackWhiteListResponse
   */
  async gatewayBlackWhiteList(request: GatewayBlackWhiteListRequest): Promise<GatewayBlackWhiteListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.gatewayBlackWhiteListWithOptions(request, runtime);
  }

  /**
   * Queries information about canary release for messaging of an application.
   * 
   * @param request - GetAppMessageQueueRouteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetAppMessageQueueRouteResponse
   */
  async getAppMessageQueueRouteWithOptions(request: GetAppMessageQueueRouteRequest, runtime: $Util.RuntimeOptions): Promise<GetAppMessageQueueRouteResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetAppMessageQueueRoute",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetAppMessageQueueRouteResponse>(await this.callApi(params, req, runtime), new GetAppMessageQueueRouteResponse({}));
  }

  /**
   * Queries information about canary release for messaging of an application.
   * 
   * @param request - GetAppMessageQueueRouteRequest
   * @returns GetAppMessageQueueRouteResponse
   */
  async getAppMessageQueueRoute(request: GetAppMessageQueueRouteRequest): Promise<GetAppMessageQueueRouteResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAppMessageQueueRouteWithOptions(request, runtime);
  }

  /**
   * Queries the list of microservice application instances.
   * 
   * @param request - GetApplicationInstanceListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetApplicationInstanceListResponse
   */
  async getApplicationInstanceListWithOptions(request: GetApplicationInstanceListRequest, runtime: $Util.RuntimeOptions): Promise<GetApplicationInstanceListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetApplicationInstanceList",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetApplicationInstanceListResponse>(await this.callApi(params, req, runtime), new GetApplicationInstanceListResponse({}));
  }

  /**
   * Queries the list of microservice application instances.
   * 
   * @param request - GetApplicationInstanceListRequest
   * @returns GetApplicationInstanceListResponse
   */
  async getApplicationInstanceList(request: GetApplicationInstanceListRequest): Promise<GetApplicationInstanceListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getApplicationInstanceListWithOptions(request, runtime);
  }

  /**
   * Obtains the list of applications.
   * 
   * @param request - GetApplicationListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetApplicationListResponse
   */
  async getApplicationListWithOptions(request: GetApplicationListRequest, runtime: $Util.RuntimeOptions): Promise<GetApplicationListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.language)) {
      query["Language"] = request.language;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.sentinelEnable)) {
      query["SentinelEnable"] = request.sentinelEnable;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.switchEnable)) {
      query["SwitchEnable"] = request.switchEnable;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetApplicationList",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetApplicationListResponse>(await this.callApi(params, req, runtime), new GetApplicationListResponse({}));
  }

  /**
   * Obtains the list of applications.
   * 
   * @param request - GetApplicationListRequest
   * @returns GetApplicationListResponse
   */
  async getApplicationList(request: GetApplicationListRequest): Promise<GetApplicationListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getApplicationListWithOptions(request, runtime);
  }

  /**
   * Queries the blacklist or whitelist of a gateway.
   * 
   * @deprecated OpenAPI GetBlackWhiteList is deprecated, please use mse::2019-05-31::GatewayBlackWhiteList instead.
   * 
   * @param request - GetBlackWhiteListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetBlackWhiteListResponse
   */
  // Deprecated
  async getBlackWhiteListWithOptions(request: GetBlackWhiteListRequest, runtime: $Util.RuntimeOptions): Promise<GetBlackWhiteListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.isWhite)) {
      query["IsWhite"] = request.isWhite;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetBlackWhiteList",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetBlackWhiteListResponse>(await this.callApi(params, req, runtime), new GetBlackWhiteListResponse({}));
  }

  /**
   * Queries the blacklist or whitelist of a gateway.
   * 
   * @deprecated OpenAPI GetBlackWhiteList is deprecated, please use mse::2019-05-31::GatewayBlackWhiteList instead.
   * 
   * @param request - GetBlackWhiteListRequest
   * @returns GetBlackWhiteListResponse
   */
  // Deprecated
  async getBlackWhiteList(request: GetBlackWhiteListRequest): Promise<GetBlackWhiteListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getBlackWhiteListWithOptions(request, runtime);
  }

  /**
   * Queries the namespaces of a Nacos instance.
   * 
   * @param request - GetEngineNamepaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetEngineNamepaceResponse
   */
  async getEngineNamepaceWithOptions(request: GetEngineNamepaceRequest, runtime: $Util.RuntimeOptions): Promise<GetEngineNamepaceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetEngineNamepace",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetEngineNamepaceResponse>(await this.callApi(params, req, runtime), new GetEngineNamepaceResponse({}));
  }

  /**
   * Queries the namespaces of a Nacos instance.
   * 
   * @param request - GetEngineNamepaceRequest
   * @returns GetEngineNamepaceResponse
   */
  async getEngineNamepace(request: GetEngineNamepaceRequest): Promise<GetEngineNamepaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getEngineNamepaceWithOptions(request, runtime);
  }

  /**
   * Obtains the basic information about a gateway, such as the virtual private cloud (VPC) and vSwitch to which the gateway belongs.
   * 
   * @param request - GetGatewayRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetGatewayResponse
   */
  async getGatewayWithOptions(request: GetGatewayRequest, runtime: $Util.RuntimeOptions): Promise<GetGatewayResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetGateway",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetGatewayResponse>(await this.callApi(params, req, runtime), new GetGatewayResponse({}));
  }

  /**
   * Obtains the basic information about a gateway, such as the virtual private cloud (VPC) and vSwitch to which the gateway belongs.
   * 
   * @param request - GetGatewayRequest
   * @returns GetGatewayResponse
   */
  async getGateway(request: GetGatewayRequest): Promise<GetGatewayResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getGatewayWithOptions(request, runtime);
  }

  /**
   * Queries the details of the consumer on which a gateway performs authentication operations.
   * 
   * @param request - GetGatewayAuthConsumerDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetGatewayAuthConsumerDetailResponse
   */
  async getGatewayAuthConsumerDetailWithOptions(request: GetGatewayAuthConsumerDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetGatewayAuthConsumerDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetGatewayAuthConsumerDetail",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetGatewayAuthConsumerDetailResponse>(await this.callApi(params, req, runtime), new GetGatewayAuthConsumerDetailResponse({}));
  }

  /**
   * Queries the details of the consumer on which a gateway performs authentication operations.
   * 
   * @param request - GetGatewayAuthConsumerDetailRequest
   * @returns GetGatewayAuthConsumerDetailResponse
   */
  async getGatewayAuthConsumerDetail(request: GetGatewayAuthConsumerDetailRequest): Promise<GetGatewayAuthConsumerDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getGatewayAuthConsumerDetailWithOptions(request, runtime);
  }

  /**
   * 查询网关认证详情
   * 
   * @param request - GetGatewayAuthDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetGatewayAuthDetailResponse
   */
  async getGatewayAuthDetailWithOptions(request: GetGatewayAuthDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetGatewayAuthDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetGatewayAuthDetail",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetGatewayAuthDetailResponse>(await this.callApi(params, req, runtime), new GetGatewayAuthDetailResponse({}));
  }

  /**
   * 查询网关认证详情
   * 
   * @param request - GetGatewayAuthDetailRequest
   * @returns GetGatewayAuthDetailResponse
   */
  async getGatewayAuthDetail(request: GetGatewayAuthDetailRequest): Promise<GetGatewayAuthDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getGatewayAuthDetailWithOptions(request, runtime);
  }

  /**
   * 获取网关全局配置
   * 
   * @param request - GetGatewayConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetGatewayConfigResponse
   */
  async getGatewayConfigWithOptions(request: GetGatewayConfigRequest, runtime: $Util.RuntimeOptions): Promise<GetGatewayConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetGatewayConfig",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetGatewayConfigResponse>(await this.callApi(params, req, runtime), new GetGatewayConfigResponse({}));
  }

  /**
   * 获取网关全局配置
   * 
   * @param request - GetGatewayConfigRequest
   * @returns GetGatewayConfigResponse
   */
  async getGatewayConfig(request: GetGatewayConfigRequest): Promise<GetGatewayConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getGatewayConfigWithOptions(request, runtime);
  }

  /**
   * Queries the details of a domain name associated with a gateway.
   * 
   * @param request - GetGatewayDomainDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetGatewayDomainDetailResponse
   */
  async getGatewayDomainDetailWithOptions(request: GetGatewayDomainDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetGatewayDomainDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetGatewayDomainDetail",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetGatewayDomainDetailResponse>(await this.callApi(params, req, runtime), new GetGatewayDomainDetailResponse({}));
  }

  /**
   * Queries the details of a domain name associated with a gateway.
   * 
   * @param request - GetGatewayDomainDetailRequest
   * @returns GetGatewayDomainDetailResponse
   */
  async getGatewayDomainDetail(request: GetGatewayDomainDetailRequest): Promise<GetGatewayDomainDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getGatewayDomainDetailWithOptions(request, runtime);
  }

  /**
   * Obtains the global parameters of a gateway.
   * 
   * @param request - GetGatewayOptionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetGatewayOptionResponse
   */
  async getGatewayOptionWithOptions(request: GetGatewayOptionRequest, runtime: $Util.RuntimeOptions): Promise<GetGatewayOptionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetGatewayOption",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetGatewayOptionResponse>(await this.callApi(params, req, runtime), new GetGatewayOptionResponse({}));
  }

  /**
   * Obtains the global parameters of a gateway.
   * 
   * @param request - GetGatewayOptionRequest
   * @returns GetGatewayOptionResponse
   */
  async getGatewayOption(request: GetGatewayOptionRequest): Promise<GetGatewayOptionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getGatewayOptionWithOptions(request, runtime);
  }

  /**
   * Queries the details of a route for a gateway.
   * 
   * @param request - GetGatewayRouteDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetGatewayRouteDetailResponse
   */
  async getGatewayRouteDetailWithOptions(request: GetGatewayRouteDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetGatewayRouteDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.routeId)) {
      query["RouteId"] = request.routeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetGatewayRouteDetail",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetGatewayRouteDetailResponse>(await this.callApi(params, req, runtime), new GetGatewayRouteDetailResponse({}));
  }

  /**
   * Queries the details of a route for a gateway.
   * 
   * @param request - GetGatewayRouteDetailRequest
   * @returns GetGatewayRouteDetailResponse
   */
  async getGatewayRouteDetail(request: GetGatewayRouteDetailRequest): Promise<GetGatewayRouteDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getGatewayRouteDetailWithOptions(request, runtime);
  }

  /**
   * Queries the details of a service.
   * 
   * @param request - GetGatewayServiceDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetGatewayServiceDetailResponse
   */
  async getGatewayServiceDetailWithOptions(request: GetGatewayServiceDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetGatewayServiceDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.serviceId)) {
      query["ServiceId"] = request.serviceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetGatewayServiceDetail",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetGatewayServiceDetailResponse>(await this.callApi(params, req, runtime), new GetGatewayServiceDetailResponse({}));
  }

  /**
   * Queries the details of a service.
   * 
   * @param request - GetGatewayServiceDetailRequest
   * @returns GetGatewayServiceDetailResponse
   */
  async getGatewayServiceDetail(request: GetGatewayServiceDetailRequest): Promise<GetGatewayServiceDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getGatewayServiceDetailWithOptions(request, runtime);
  }

  /**
   * Queries the information about a Container Service for Kubernetes (ACK) cluster for which Microservices Governance is enabled.
   * 
   * @param request - GetGovernanceKubernetesClusterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetGovernanceKubernetesClusterResponse
   */
  async getGovernanceKubernetesClusterWithOptions(request: GetGovernanceKubernetesClusterRequest, runtime: $Util.RuntimeOptions): Promise<GetGovernanceKubernetesClusterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetGovernanceKubernetesCluster",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetGovernanceKubernetesClusterResponse>(await this.callApi(params, req, runtime), new GetGovernanceKubernetesClusterResponse({}));
  }

  /**
   * Queries the information about a Container Service for Kubernetes (ACK) cluster for which Microservices Governance is enabled.
   * 
   * @param request - GetGovernanceKubernetesClusterRequest
   * @returns GetGovernanceKubernetesClusterResponse
   */
  async getGovernanceKubernetesCluster(request: GetGovernanceKubernetesClusterRequest): Promise<GetGovernanceKubernetesClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getGovernanceKubernetesClusterWithOptions(request, runtime);
  }

  /**
   * Queries the maximum version number to which the current version can be upgraded.
   * 
   * @param request - GetImageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetImageResponse
   */
  async getImageWithOptions(request: GetImageRequest, runtime: $Util.RuntimeOptions): Promise<GetImageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.versionCode)) {
      query["VersionCode"] = request.versionCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetImage",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetImageResponse>(await this.callApi(params, req, runtime), new GetImageResponse({}));
  }

  /**
   * Queries the maximum version number to which the current version can be upgraded.
   * 
   * @param request - GetImageRequest
   * @returns GetImageResponse
   */
  async getImage(request: GetImageRequest): Promise<GetImageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getImageWithOptions(request, runtime);
  }

  /**
   * Obtains the URL that is used to upload a configuration file when you import the configuration file into a Microservices Engine (MSE) Nacos instance.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).\\n
   * 
   * @param request - GetImportFileUrlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetImportFileUrlResponse
   */
  async getImportFileUrlWithOptions(request: GetImportFileUrlRequest, runtime: $Util.RuntimeOptions): Promise<GetImportFileUrlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.contentType)) {
      query["ContentType"] = request.contentType;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetImportFileUrl",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetImportFileUrlResponse>(await this.callApi(params, req, runtime), new GetImportFileUrlResponse({}));
  }

  /**
   * Obtains the URL that is used to upload a configuration file when you import the configuration file into a Microservices Engine (MSE) Nacos instance.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).\\n
   * 
   * @param request - GetImportFileUrlRequest
   * @returns GetImportFileUrlResponse
   */
  async getImportFileUrl(request: GetImportFileUrlRequest): Promise<GetImportFileUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getImportFileUrlWithOptions(request, runtime);
  }

  /**
   * Obtains sources of all Container Service for Kubernetes (ACK) services in a gateway.
   * 
   * @param request - GetKubernetesSourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetKubernetesSourceResponse
   */
  async getKubernetesSourceWithOptions(request: GetKubernetesSourceRequest, runtime: $Util.RuntimeOptions): Promise<GetKubernetesSourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.isAll)) {
      query["IsAll"] = request.isAll;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetKubernetesSource",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetKubernetesSourceResponse>(await this.callApi(params, req, runtime), new GetKubernetesSourceResponse({}));
  }

  /**
   * Obtains sources of all Container Service for Kubernetes (ACK) services in a gateway.
   * 
   * @param request - GetKubernetesSourceRequest
   * @returns GetKubernetesSourceResponse
   */
  async getKubernetesSource(request: GetKubernetesSourceRequest): Promise<GetKubernetesSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getKubernetesSourceWithOptions(request, runtime);
  }

  /**
   * Queries the rules for graceful start and shutdown of an application.
   * 
   * @remarks
   * You can call this operation to query the rules for graceful start and shutdown of an application.
   * You can query the rules for graceful start and shutdown of an application preferentially by using the AppId parameter.
   * If the AppId parameter is left empty, you can use the RegionId, Namespace, and AppName parameters to query the rules for graceful start and shutdown of an application.
   * 
   * @param request - GetLosslessRuleByAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetLosslessRuleByAppResponse
   */
  async getLosslessRuleByAppWithOptions(request: GetLosslessRuleByAppRequest, runtime: $Util.RuntimeOptions): Promise<GetLosslessRuleByAppResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetLosslessRuleByApp",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetLosslessRuleByAppResponse>(await this.callApi(params, req, runtime), new GetLosslessRuleByAppResponse({}));
  }

  /**
   * Queries the rules for graceful start and shutdown of an application.
   * 
   * @remarks
   * You can call this operation to query the rules for graceful start and shutdown of an application.
   * You can query the rules for graceful start and shutdown of an application preferentially by using the AppId parameter.
   * If the AppId parameter is left empty, you can use the RegionId, Namespace, and AppName parameters to query the rules for graceful start and shutdown of an application.
   * 
   * @param request - GetLosslessRuleByAppRequest
   * @returns GetLosslessRuleByAppResponse
   */
  async getLosslessRuleByApp(request: GetLosslessRuleByAppRequest): Promise<GetLosslessRuleByAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getLosslessRuleByAppWithOptions(request, runtime);
  }

  /**
   * Queries the information about the MSE feature switch.
   * 
   * @param request - GetMseFeatureSwitchRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMseFeatureSwitchResponse
   */
  async getMseFeatureSwitchWithOptions(request: GetMseFeatureSwitchRequest, runtime: $Util.RuntimeOptions): Promise<GetMseFeatureSwitchResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMseFeatureSwitch",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMseFeatureSwitchResponse>(await this.callApi(params, req, runtime), new GetMseFeatureSwitchResponse({}));
  }

  /**
   * Queries the information about the MSE feature switch.
   * 
   * @param request - GetMseFeatureSwitchRequest
   * @returns GetMseFeatureSwitchResponse
   */
  async getMseFeatureSwitch(request: GetMseFeatureSwitchRequest): Promise<GetMseFeatureSwitchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMseFeatureSwitchWithOptions(request, runtime);
  }

  /**
   * Queries the existing Microservices Engine (MSE) Nacos instances that are service sources of a gateway.
   * 
   * @param request - GetMseSourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMseSourceResponse
   */
  async getMseSourceWithOptions(request: GetMseSourceRequest, runtime: $Util.RuntimeOptions): Promise<GetMseSourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMseSource",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMseSourceResponse>(await this.callApi(params, req, runtime), new GetMseSourceResponse({}));
  }

  /**
   * Queries the existing Microservices Engine (MSE) Nacos instances that are service sources of a gateway.
   * 
   * @param request - GetMseSourceRequest
   * @returns GetMseSourceResponse
   */
  async getMseSource(request: GetMseSourceRequest): Promise<GetMseSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMseSourceWithOptions(request, runtime);
  }

  /**
   * Queries Nacos configurations.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - GetNacosConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetNacosConfigResponse
   */
  async getNacosConfigWithOptions(request: GetNacosConfigRequest, runtime: $Util.RuntimeOptions): Promise<GetNacosConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.beta)) {
      query["Beta"] = request.beta;
    }

    if (!Util.isUnset(request.dataId)) {
      query["DataId"] = request.dataId;
    }

    if (!Util.isUnset(request.group)) {
      query["Group"] = request.group;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetNacosConfig",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetNacosConfigResponse>(await this.callApi(params, req, runtime), new GetNacosConfigResponse({}));
  }

  /**
   * Queries Nacos configurations.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - GetNacosConfigRequest
   * @returns GetNacosConfigResponse
   */
  async getNacosConfig(request: GetNacosConfigRequest): Promise<GetNacosConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getNacosConfigWithOptions(request, runtime);
  }

  /**
   * Queries the historical details of Nacos configuration changes.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - GetNacosHistoryConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetNacosHistoryConfigResponse
   */
  async getNacosHistoryConfigWithOptions(request: GetNacosHistoryConfigRequest, runtime: $Util.RuntimeOptions): Promise<GetNacosHistoryConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.dataId)) {
      query["DataId"] = request.dataId;
    }

    if (!Util.isUnset(request.group)) {
      query["Group"] = request.group;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.nid)) {
      query["Nid"] = request.nid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetNacosHistoryConfig",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetNacosHistoryConfigResponse>(await this.callApi(params, req, runtime), new GetNacosHistoryConfigResponse({}));
  }

  /**
   * Queries the historical details of Nacos configuration changes.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - GetNacosHistoryConfigRequest
   * @returns GetNacosHistoryConfigResponse
   */
  async getNacosHistoryConfig(request: GetNacosHistoryConfigRequest): Promise<GetNacosHistoryConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getNacosHistoryConfigWithOptions(request, runtime);
  }

  /**
   * Queries information about service governance.
   * 
   * @remarks
   * You can call this operation to query overview information about service governance.
   * 
   * @param request - GetOverviewRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetOverviewResponse
   */
  async getOverviewWithOptions(request: GetOverviewRequest, runtime: $Util.RuntimeOptions): Promise<GetOverviewResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOverview",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOverviewResponse>(await this.callApi(params, req, runtime), new GetOverviewResponse({}));
  }

  /**
   * Queries information about service governance.
   * 
   * @remarks
   * You can call this operation to query overview information about service governance.
   * 
   * @param request - GetOverviewRequest
   * @returns GetOverviewResponse
   */
  async getOverview(request: GetOverviewRequest): Promise<GetOverviewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOverviewWithOptions(request, runtime);
  }

  /**
   * Obtains plug-in configurations.
   * 
   * @param request - GetPluginConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPluginConfigResponse
   */
  async getPluginConfigWithOptions(request: GetPluginConfigRequest, runtime: $Util.RuntimeOptions): Promise<GetPluginConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.pluginId)) {
      query["PluginId"] = request.pluginId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPluginConfig",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetPluginConfigResponse>(await this.callApi(params, req, runtime), new GetPluginConfigResponse({}));
  }

  /**
   * Obtains plug-in configurations.
   * 
   * @param request - GetPluginConfigRequest
   * @returns GetPluginConfigResponse
   */
  async getPluginConfig(request: GetPluginConfigRequest): Promise<GetPluginConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getPluginConfigWithOptions(request, runtime);
  }

  /**
   * Obtains plug-ins.
   * 
   * @param request - GetPluginsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPluginsResponse
   */
  async getPluginsWithOptions(request: GetPluginsRequest, runtime: $Util.RuntimeOptions): Promise<GetPluginsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.category)) {
      query["Category"] = request.category;
    }

    if (!Util.isUnset(request.enableOnly)) {
      query["EnableOnly"] = request.enableOnly;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPlugins",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetPluginsResponse>(await this.callApi(params, req, runtime), new GetPluginsResponse({}));
  }

  /**
   * Obtains plug-ins.
   * 
   * @param request - GetPluginsRequest
   * @returns GetPluginsResponse
   */
  async getPlugins(request: GetPluginsRequest): Promise<GetPluginsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getPluginsWithOptions(request, runtime);
  }

  /**
   * Queries the services of an application.
   * 
   * @param request - GetServiceListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetServiceListResponse
   */
  async getServiceListWithOptions(request: GetServiceListRequest, runtime: $Util.RuntimeOptions): Promise<GetServiceListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.serviceName)) {
      query["ServiceName"] = request.serviceName;
    }

    if (!Util.isUnset(request.serviceType)) {
      query["ServiceType"] = request.serviceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetServiceList",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetServiceListResponse>(await this.callApi(params, req, runtime), new GetServiceListResponse({}));
  }

  /**
   * Queries the services of an application.
   * 
   * @param request - GetServiceListRequest
   * @returns GetServiceListResponse
   */
  async getServiceList(request: GetServiceListRequest): Promise<GetServiceListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getServiceListWithOptions(request, runtime);
  }

  /**
   * Queries the version of a microservices application.
   * 
   * @param request - GetServiceListPageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetServiceListPageResponse
   */
  async getServiceListPageWithOptions(request: GetServiceListPageRequest, runtime: $Util.RuntimeOptions): Promise<GetServiceListPageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.serviceName)) {
      query["ServiceName"] = request.serviceName;
    }

    if (!Util.isUnset(request.serviceType)) {
      query["ServiceType"] = request.serviceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetServiceListPage",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetServiceListPageResponse>(await this.callApi(params, req, runtime), new GetServiceListPageResponse({}));
  }

  /**
   * Queries the version of a microservices application.
   * 
   * @param request - GetServiceListPageRequest
   * @returns GetServiceListPageResponse
   */
  async getServiceListPage(request: GetServiceListPageRequest): Promise<GetServiceListPageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getServiceListPageWithOptions(request, runtime);
  }

  /**
   * Queries the list of listeners for the destination service.
   * 
   * @param request - GetServiceListenersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetServiceListenersResponse
   */
  async getServiceListenersWithOptions(request: GetServiceListenersRequest, runtime: $Util.RuntimeOptions): Promise<GetServiceListenersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.clusterName)) {
      query["ClusterName"] = request.clusterName;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.hasIpCount)) {
      query["HasIpCount"] = request.hasIpCount;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    if (!Util.isUnset(request.serviceName)) {
      query["ServiceName"] = request.serviceName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetServiceListeners",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetServiceListenersResponse>(await this.callApi(params, req, runtime), new GetServiceListenersResponse({}));
  }

  /**
   * Queries the list of listeners for the destination service.
   * 
   * @param request - GetServiceListenersRequest
   * @returns GetServiceListenersResponse
   */
  async getServiceListeners(request: GetServiceListenersRequest): Promise<GetServiceListenersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getServiceListenersWithOptions(request, runtime);
  }

  /**
   * 获取服务接口列表
   * 
   * @param request - GetServiceMethodPageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetServiceMethodPageResponse
   */
  async getServiceMethodPageWithOptions(request: GetServiceMethodPageRequest, runtime: $Util.RuntimeOptions): Promise<GetServiceMethodPageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.methodController)) {
      query["MethodController"] = request.methodController;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.path)) {
      query["Path"] = request.path;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.serviceGroup)) {
      query["ServiceGroup"] = request.serviceGroup;
    }

    if (!Util.isUnset(request.serviceName)) {
      query["ServiceName"] = request.serviceName;
    }

    if (!Util.isUnset(request.serviceType)) {
      query["ServiceType"] = request.serviceType;
    }

    if (!Util.isUnset(request.serviceVersion)) {
      query["ServiceVersion"] = request.serviceVersion;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetServiceMethodPage",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetServiceMethodPageResponse>(await this.callApi(params, req, runtime), new GetServiceMethodPageResponse({}));
  }

  /**
   * 获取服务接口列表
   * 
   * @param request - GetServiceMethodPageRequest
   * @returns GetServiceMethodPageResponse
   */
  async getServiceMethodPage(request: GetServiceMethodPageRequest): Promise<GetServiceMethodPageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getServiceMethodPageWithOptions(request, runtime);
  }

  /**
   * Obtains all tags in the current lane group.
   * 
   * @param request - GetTagsBySwimmingLaneGroupIdRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetTagsBySwimmingLaneGroupIdResponse
   */
  async getTagsBySwimmingLaneGroupIdWithOptions(request: GetTagsBySwimmingLaneGroupIdRequest, runtime: $Util.RuntimeOptions): Promise<GetTagsBySwimmingLaneGroupIdResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTagsBySwimmingLaneGroupId",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTagsBySwimmingLaneGroupIdResponse>(await this.callApi(params, req, runtime), new GetTagsBySwimmingLaneGroupIdResponse({}));
  }

  /**
   * Obtains all tags in the current lane group.
   * 
   * @param request - GetTagsBySwimmingLaneGroupIdRequest
   * @returns GetTagsBySwimmingLaneGroupIdResponse
   */
  async getTagsBySwimmingLaneGroupId(request: GetTagsBySwimmingLaneGroupIdRequest): Promise<GetTagsBySwimmingLaneGroupIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTagsBySwimmingLaneGroupIdWithOptions(request, runtime);
  }

  /**
   * mse-200-105
   * 
   * @param request - GetZookeeperDataImportUrlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetZookeeperDataImportUrlResponse
   */
  async getZookeeperDataImportUrlWithOptions(request: GetZookeeperDataImportUrlRequest, runtime: $Util.RuntimeOptions): Promise<GetZookeeperDataImportUrlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.contentType)) {
      query["ContentType"] = request.contentType;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetZookeeperDataImportUrl",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetZookeeperDataImportUrlResponse>(await this.callApi(params, req, runtime), new GetZookeeperDataImportUrlResponse({}));
  }

  /**
   * mse-200-105
   * 
   * @param request - GetZookeeperDataImportUrlRequest
   * @returns GetZookeeperDataImportUrlResponse
   */
  async getZookeeperDataImportUrl(request: GetZookeeperDataImportUrlRequest): Promise<GetZookeeperDataImportUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getZookeeperDataImportUrlWithOptions(request, runtime);
  }

  /**
   * Imports Nacos configurations as a file.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - ImportNacosConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ImportNacosConfigResponse
   */
  async importNacosConfigWithOptions(request: ImportNacosConfigRequest, runtime: $Util.RuntimeOptions): Promise<ImportNacosConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.fileUrl)) {
      query["FileUrl"] = request.fileUrl;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.policy)) {
      query["Policy"] = request.policy;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ImportNacosConfig",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ImportNacosConfigResponse>(await this.callApi(params, req, runtime), new ImportNacosConfigResponse({}));
  }

  /**
   * Imports Nacos configurations as a file.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - ImportNacosConfigRequest
   * @returns ImportNacosConfigResponse
   */
  async importNacosConfig(request: ImportNacosConfigRequest): Promise<ImportNacosConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.importNacosConfigWithOptions(request, runtime);
  }

  /**
   * Imports services to a gateway.
   * 
   * @param tmpReq - ImportServicesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ImportServicesResponse
   */
  async importServicesWithOptions(tmpReq: ImportServicesRequest, runtime: $Util.RuntimeOptions): Promise<ImportServicesResponse> {
    Util.validateModel(tmpReq);
    let request = new ImportServicesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.serviceList)) {
      request.serviceListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.serviceList, "ServiceList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.fcAlias)) {
      query["FcAlias"] = request.fcAlias;
    }

    if (!Util.isUnset(request.fcServiceName)) {
      query["FcServiceName"] = request.fcServiceName;
    }

    if (!Util.isUnset(request.fcVersion)) {
      query["FcVersion"] = request.fcVersion;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.serviceListShrink)) {
      query["ServiceList"] = request.serviceListShrink;
    }

    if (!Util.isUnset(request.sourceType)) {
      query["SourceType"] = request.sourceType;
    }

    if (!Util.isUnset(request.tlsSetting)) {
      query["TlsSetting"] = request.tlsSetting;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ImportServices",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ImportServicesResponse>(await this.callApi(params, req, runtime), new ImportServicesResponse({}));
  }

  /**
   * Imports services to a gateway.
   * 
   * @param request - ImportServicesRequest
   * @returns ImportServicesResponse
   */
  async importServices(request: ImportServicesRequest): Promise<ImportServicesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.importServicesWithOptions(request, runtime);
  }

  /**
   * Initiates a task to import data from a destination URL to a Microservices Engine (MSE) ZooKeeper instance.
   * 
   * @remarks
   * *Danger** This operation clears existing data. Exercise caution when you call this API operation.
   * 
   * @param request - ImportZookeeperDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ImportZookeeperDataResponse
   */
  async importZookeeperDataWithOptions(request: ImportZookeeperDataRequest, runtime: $Util.RuntimeOptions): Promise<ImportZookeeperDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.fileName)) {
      query["FileName"] = request.fileName;
    }

    if (!Util.isUnset(request.fileUrl)) {
      query["FileUrl"] = request.fileUrl;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ImportZookeeperData",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ImportZookeeperDataResponse>(await this.callApi(params, req, runtime), new ImportZookeeperDataResponse({}));
  }

  /**
   * Initiates a task to import data from a destination URL to a Microservices Engine (MSE) ZooKeeper instance.
   * 
   * @remarks
   * *Danger** This operation clears existing data. Exercise caution when you call this API operation.
   * 
   * @param request - ImportZookeeperDataRequest
   * @returns ImportZookeeperDataResponse
   */
  async importZookeeperData(request: ImportZookeeperDataRequest): Promise<ImportZookeeperDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.importZookeeperDataWithOptions(request, runtime);
  }

  /**
   * Queries application instances that are registered with a Microservices Engine (MSE) Nacos instance.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - ListAnsInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListAnsInstancesResponse
   */
  async listAnsInstancesWithOptions(request: ListAnsInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ListAnsInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.clusterName)) {
      query["ClusterName"] = request.clusterName;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    if (!Util.isUnset(request.serviceName)) {
      query["ServiceName"] = request.serviceName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAnsInstances",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAnsInstancesResponse>(await this.callApi(params, req, runtime), new ListAnsInstancesResponse({}));
  }

  /**
   * Queries application instances that are registered with a Microservices Engine (MSE) Nacos instance.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - ListAnsInstancesRequest
   * @returns ListAnsInstancesResponse
   */
  async listAnsInstances(request: ListAnsInstancesRequest): Promise<ListAnsInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAnsInstancesWithOptions(request, runtime);
  }

  /**
   * Queries the clusters of a Nacos service.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - ListAnsServiceClustersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListAnsServiceClustersResponse
   */
  async listAnsServiceClustersWithOptions(request: ListAnsServiceClustersRequest, runtime: $Util.RuntimeOptions): Promise<ListAnsServiceClustersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.clusterName)) {
      query["ClusterName"] = request.clusterName;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.serviceName)) {
      query["ServiceName"] = request.serviceName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAnsServiceClusters",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAnsServiceClustersResponse>(await this.callApi(params, req, runtime), new ListAnsServiceClustersResponse({}));
  }

  /**
   * Queries the clusters of a Nacos service.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - ListAnsServiceClustersRequest
   * @returns ListAnsServiceClustersResponse
   */
  async listAnsServiceClusters(request: ListAnsServiceClustersRequest): Promise<ListAnsServiceClustersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAnsServiceClustersWithOptions(request, runtime);
  }

  /**
   * Queries Nacos services.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - ListAnsServicesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListAnsServicesResponse
   */
  async listAnsServicesWithOptions(request: ListAnsServicesRequest, runtime: $Util.RuntimeOptions): Promise<ListAnsServicesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.clusterName)) {
      query["ClusterName"] = request.clusterName;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.hasIpCount)) {
      query["HasIpCount"] = request.hasIpCount;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    if (!Util.isUnset(request.serviceName)) {
      query["ServiceName"] = request.serviceName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAnsServices",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAnsServicesResponse>(await this.callApi(params, req, runtime), new ListAnsServicesResponse({}));
  }

  /**
   * Queries Nacos services.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - ListAnsServicesRequest
   * @returns ListAnsServicesResponse
   */
  async listAnsServices(request: ListAnsServicesRequest): Promise<ListAnsServicesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAnsServicesWithOptions(request, runtime);
  }

  /**
   * Queries the applications in a lane group by tag.
   * 
   * @deprecated OpenAPI ListAppBySwimmingLaneGroupTag is deprecated, please use mse::2019-05-31::ListAppBySwimmingLaneGroupTags instead.
   * 
   * @param request - ListAppBySwimmingLaneGroupTagRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListAppBySwimmingLaneGroupTagResponse
   */
  // Deprecated
  async listAppBySwimmingLaneGroupTagWithOptions(request: ListAppBySwimmingLaneGroupTagRequest, runtime: $Util.RuntimeOptions): Promise<ListAppBySwimmingLaneGroupTagResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAppBySwimmingLaneGroupTag",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAppBySwimmingLaneGroupTagResponse>(await this.callApi(params, req, runtime), new ListAppBySwimmingLaneGroupTagResponse({}));
  }

  /**
   * Queries the applications in a lane group by tag.
   * 
   * @deprecated OpenAPI ListAppBySwimmingLaneGroupTag is deprecated, please use mse::2019-05-31::ListAppBySwimmingLaneGroupTags instead.
   * 
   * @param request - ListAppBySwimmingLaneGroupTagRequest
   * @returns ListAppBySwimmingLaneGroupTagResponse
   */
  // Deprecated
  async listAppBySwimmingLaneGroupTag(request: ListAppBySwimmingLaneGroupTagRequest): Promise<ListAppBySwimmingLaneGroupTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAppBySwimmingLaneGroupTagWithOptions(request, runtime);
  }

  /**
   * Lists applications by tag in a specified lane group.
   * 
   * @param tmpReq - ListAppBySwimmingLaneGroupTagsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListAppBySwimmingLaneGroupTagsResponse
   */
  async listAppBySwimmingLaneGroupTagsWithOptions(tmpReq: ListAppBySwimmingLaneGroupTagsRequest, runtime: $Util.RuntimeOptions): Promise<ListAppBySwimmingLaneGroupTagsResponse> {
    Util.validateModel(tmpReq);
    let request = new ListAppBySwimmingLaneGroupTagsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.tags)) {
      request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, "Tags", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.tagsShrink)) {
      query["Tags"] = request.tagsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAppBySwimmingLaneGroupTags",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAppBySwimmingLaneGroupTagsResponse>(await this.callApi(params, req, runtime), new ListAppBySwimmingLaneGroupTagsResponse({}));
  }

  /**
   * Lists applications by tag in a specified lane group.
   * 
   * @param request - ListAppBySwimmingLaneGroupTagsRequest
   * @returns ListAppBySwimmingLaneGroupTagsResponse
   */
  async listAppBySwimmingLaneGroupTags(request: ListAppBySwimmingLaneGroupTagsRequest): Promise<ListAppBySwimmingLaneGroupTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAppBySwimmingLaneGroupTagsWithOptions(request, runtime);
  }

  /**
   * Queries the routing rules of an application.
   * 
   * @param request - ListApplicationsWithTagRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListApplicationsWithTagRulesResponse
   */
  async listApplicationsWithTagRulesWithOptions(request: ListApplicationsWithTagRulesRequest, runtime: $Util.RuntimeOptions): Promise<ListApplicationsWithTagRulesResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListApplicationsWithTagRules",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListApplicationsWithTagRulesResponse>(await this.callApi(params, req, runtime), new ListApplicationsWithTagRulesResponse({}));
  }

  /**
   * Queries the routing rules of an application.
   * 
   * @param request - ListApplicationsWithTagRulesRequest
   * @returns ListApplicationsWithTagRulesResponse
   */
  async listApplicationsWithTagRules(request: ListApplicationsWithTagRulesRequest): Promise<ListApplicationsWithTagRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listApplicationsWithTagRulesWithOptions(request, runtime);
  }

  /**
   * Queries a list of service authentication rules.
   * 
   * @param request - ListAuthPolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListAuthPolicyResponse
   */
  async listAuthPolicyWithOptions(request: ListAuthPolicyRequest, runtime: $Util.RuntimeOptions): Promise<ListAuthPolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.protocol)) {
      query["Protocol"] = request.protocol;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAuthPolicy",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAuthPolicyResponse>(await this.callApi(params, req, runtime), new ListAuthPolicyResponse({}));
  }

  /**
   * Queries a list of service authentication rules.
   * 
   * @param request - ListAuthPolicyRequest
   * @returns ListAuthPolicyResponse
   */
  async listAuthPolicy(request: ListAuthPolicyRequest): Promise<ListAuthPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAuthPolicyWithOptions(request, runtime);
  }

  /**
   * Queries a list of circuit breaking rules.
   * 
   * @param request - ListCircuitBreakerRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListCircuitBreakerRulesResponse
   */
  async listCircuitBreakerRulesWithOptions(request: ListCircuitBreakerRulesRequest, runtime: $Util.RuntimeOptions): Promise<ListCircuitBreakerRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pageIndex)) {
      query["PageIndex"] = request.pageIndex;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resource)) {
      query["Resource"] = request.resource;
    }

    if (!Util.isUnset(request.resourceSearchKey)) {
      query["ResourceSearchKey"] = request.resourceSearchKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCircuitBreakerRules",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListCircuitBreakerRulesResponse>(await this.callApi(params, req, runtime), new ListCircuitBreakerRulesResponse({}));
  }

  /**
   * Queries a list of circuit breaking rules.
   * 
   * @param request - ListCircuitBreakerRulesRequest
   * @returns ListCircuitBreakerRulesResponse
   */
  async listCircuitBreakerRules(request: ListCircuitBreakerRulesRequest): Promise<ListCircuitBreakerRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCircuitBreakerRulesWithOptions(request, runtime);
  }

  /**
   * Queries available cluster connection types.
   * 
   * @param request - ListClusterConnectionTypesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListClusterConnectionTypesResponse
   */
  async listClusterConnectionTypesWithOptions(request: ListClusterConnectionTypesRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterConnectionTypesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterConnectionTypes",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListClusterConnectionTypesResponse>(await this.callApi(params, req, runtime), new ListClusterConnectionTypesResponse({}));
  }

  /**
   * Queries available cluster connection types.
   * 
   * @param request - ListClusterConnectionTypesRequest
   * @returns ListClusterConnectionTypesResponse
   */
  async listClusterConnectionTypes(request: ListClusterConnectionTypesRequest): Promise<ListClusterConnectionTypesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterConnectionTypesWithOptions(request, runtime);
  }

  /**
   * Obtains information about historical health check tasks.
   * 
   * @param request - ListClusterHealthCheckTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListClusterHealthCheckTaskResponse
   */
  async listClusterHealthCheckTaskWithOptions(request: ListClusterHealthCheckTaskRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterHealthCheckTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterHealthCheckTask",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListClusterHealthCheckTaskResponse>(await this.callApi(params, req, runtime), new ListClusterHealthCheckTaskResponse({}));
  }

  /**
   * Obtains information about historical health check tasks.
   * 
   * @param request - ListClusterHealthCheckTaskRequest
   * @returns ListClusterHealthCheckTaskResponse
   */
  async listClusterHealthCheckTask(request: ListClusterHealthCheckTaskRequest): Promise<ListClusterHealthCheckTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterHealthCheckTaskWithOptions(request, runtime);
  }

  /**
   * Queries the engine types that can be activated.
   * 
   * @param request - ListClusterTypesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListClusterTypesResponse
   */
  async listClusterTypesWithOptions(request: ListClusterTypesRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterTypesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.connectType)) {
      query["ConnectType"] = request.connectType;
    }

    if (!Util.isUnset(request.mseVersion)) {
      query["MseVersion"] = request.mseVersion;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterTypes",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListClusterTypesResponse>(await this.callApi(params, req, runtime), new ListClusterTypesResponse({}));
  }

  /**
   * Queries the engine types that can be activated.
   * 
   * @param request - ListClusterTypesRequest
   * @returns ListClusterTypesResponse
   */
  async listClusterTypes(request: ListClusterTypesRequest): Promise<ListClusterTypesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterTypesWithOptions(request, runtime);
  }

  /**
   * Queries the information about supported instance versions.
   * 
   * @param request - ListClusterVersionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListClusterVersionsResponse
   */
  async listClusterVersionsWithOptions(request: ListClusterVersionsRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterVersionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterType)) {
      query["ClusterType"] = request.clusterType;
    }

    if (!Util.isUnset(request.mseVersion)) {
      query["MseVersion"] = request.mseVersion;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterVersions",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListClusterVersionsResponse>(await this.callApi(params, req, runtime), new ListClusterVersionsResponse({}));
  }

  /**
   * Queries the information about supported instance versions.
   * 
   * @param request - ListClusterVersionsRequest
   * @returns ListClusterVersionsResponse
   */
  async listClusterVersions(request: ListClusterVersionsRequest): Promise<ListClusterVersionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterVersionsWithOptions(request, runtime);
  }

  /**
   * Queries Microservices Engine (MSE) instances.
   * 
   * @param request - ListClustersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListClustersResponse
   */
  async listClustersWithOptions(request: ListClustersRequest, runtime: $Util.RuntimeOptions): Promise<ListClustersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterAliasName)) {
      query["ClusterAliasName"] = request.clusterAliasName;
    }

    if (!Util.isUnset(request.keyId)) {
      query["KeyId"] = request.keyId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListClusters",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListClustersResponse>(await this.callApi(params, req, runtime), new ListClustersResponse({}));
  }

  /**
   * Queries Microservices Engine (MSE) instances.
   * 
   * @param request - ListClustersRequest
   * @returns ListClustersResponse
   */
  async listClusters(request: ListClustersRequest): Promise<ListClustersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClustersWithOptions(request, runtime);
  }

  /**
   * Obtains the track data of a Nacos configuration center.
   * 
   * @param request - ListConfigTrackRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListConfigTrackResponse
   */
  async listConfigTrackWithOptions(request: ListConfigTrackRequest, runtime: $Util.RuntimeOptions): Promise<ListConfigTrackResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.dataId)) {
      query["DataId"] = request.dataId;
    }

    if (!Util.isUnset(request.endTs)) {
      query["EndTs"] = request.endTs;
    }

    if (!Util.isUnset(request.group)) {
      query["Group"] = request.group;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    if (!Util.isUnset(request.reverse)) {
      query["Reverse"] = request.reverse;
    }

    if (!Util.isUnset(request.startTs)) {
      query["StartTs"] = request.startTs;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListConfigTrack",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListConfigTrackResponse>(await this.callApi(params, req, runtime), new ListConfigTrackResponse({}));
  }

  /**
   * Obtains the track data of a Nacos configuration center.
   * 
   * @param request - ListConfigTrackRequest
   * @returns ListConfigTrackResponse
   */
  async listConfigTrack(request: ListConfigTrackRequest): Promise<ListConfigTrackResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listConfigTrackWithOptions(request, runtime);
  }

  /**
   * Queries the namespaces of a Nacos instance.
   * 
   * @param request - ListEngineNamespacesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEngineNamespacesResponse
   */
  async listEngineNamespacesWithOptions(request: ListEngineNamespacesRequest, runtime: $Util.RuntimeOptions): Promise<ListEngineNamespacesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListEngineNamespaces",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListEngineNamespacesResponse>(await this.callApi(params, req, runtime), new ListEngineNamespacesResponse({}));
  }

  /**
   * Queries the namespaces of a Nacos instance.
   * 
   * @param request - ListEngineNamespacesRequest
   * @returns ListEngineNamespacesResponse
   */
  async listEngineNamespaces(request: ListEngineNamespacesRequest): Promise<ListEngineNamespacesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEngineNamespacesWithOptions(request, runtime);
  }

  /**
   * Queries Eureka instances.
   * 
   * @param request - ListEurekaInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEurekaInstancesResponse
   */
  async listEurekaInstancesWithOptions(request: ListEurekaInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ListEurekaInstancesResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListEurekaInstances",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListEurekaInstancesResponse>(await this.callApi(params, req, runtime), new ListEurekaInstancesResponse({}));
  }

  /**
   * Queries Eureka instances.
   * 
   * @param request - ListEurekaInstancesRequest
   * @returns ListEurekaInstancesResponse
   */
  async listEurekaInstances(request: ListEurekaInstancesRequest): Promise<ListEurekaInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEurekaInstancesWithOptions(request, runtime);
  }

  /**
   * Queries Eureka services.
   * 
   * @param request - ListEurekaServicesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEurekaServicesResponse
   */
  async listEurekaServicesWithOptions(request: ListEurekaServicesRequest, runtime: $Util.RuntimeOptions): Promise<ListEurekaServicesResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListEurekaServices",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListEurekaServicesResponse>(await this.callApi(params, req, runtime), new ListEurekaServicesResponse({}));
  }

  /**
   * Queries Eureka services.
   * 
   * @param request - ListEurekaServicesRequest
   * @returns ListEurekaServicesResponse
   */
  async listEurekaServices(request: ListEurekaServicesRequest): Promise<ListEurekaServicesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEurekaServicesWithOptions(request, runtime);
  }

  /**
   * Lists historical data export tasks of a Microservices Engine (MSE) Zookeeper instance.
   * 
   * @param request - ListExportZookeeperDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListExportZookeeperDataResponse
   */
  async listExportZookeeperDataWithOptions(request: ListExportZookeeperDataRequest, runtime: $Util.RuntimeOptions): Promise<ListExportZookeeperDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListExportZookeeperData",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListExportZookeeperDataResponse>(await this.callApi(params, req, runtime), new ListExportZookeeperDataResponse({}));
  }

  /**
   * Lists historical data export tasks of a Microservices Engine (MSE) Zookeeper instance.
   * 
   * @param request - ListExportZookeeperDataRequest
   * @returns ListExportZookeeperDataResponse
   */
  async listExportZookeeperData(request: ListExportZookeeperDataRequest): Promise<ListExportZookeeperDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listExportZookeeperDataWithOptions(request, runtime);
  }

  /**
   * Obtains a list of throttling rules.
   * 
   * @param request - ListFlowRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListFlowRulesResponse
   */
  async listFlowRulesWithOptions(request: ListFlowRulesRequest, runtime: $Util.RuntimeOptions): Promise<ListFlowRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pageIndex)) {
      query["PageIndex"] = request.pageIndex;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resource)) {
      query["Resource"] = request.resource;
    }

    if (!Util.isUnset(request.resourceSearchKey)) {
      query["ResourceSearchKey"] = request.resourceSearchKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListFlowRules",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListFlowRulesResponse>(await this.callApi(params, req, runtime), new ListFlowRulesResponse({}));
  }

  /**
   * Obtains a list of throttling rules.
   * 
   * @param request - ListFlowRulesRequest
   * @returns ListFlowRulesResponse
   */
  async listFlowRules(request: ListFlowRulesRequest): Promise<ListFlowRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFlowRulesWithOptions(request, runtime);
  }

  /**
   * Queries a list of gateways.
   * 
   * @param tmpReq - ListGatewayRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListGatewayResponse
   */
  async listGatewayWithOptions(tmpReq: ListGatewayRequest, runtime: $Util.RuntimeOptions): Promise<ListGatewayResponse> {
    Util.validateModel(tmpReq);
    let request = new ListGatewayShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.filterParams)) {
      request.filterParamsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterParams, "FilterParams", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.descSort)) {
      query["DescSort"] = request.descSort;
    }

    if (!Util.isUnset(request.filterParamsShrink)) {
      query["FilterParams"] = request.filterParamsShrink;
    }

    if (!Util.isUnset(request.orderItem)) {
      query["OrderItem"] = request.orderItem;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListGateway",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListGatewayResponse>(await this.callApi(params, req, runtime), new ListGatewayResponse({}));
  }

  /**
   * Queries a list of gateways.
   * 
   * @param request - ListGatewayRequest
   * @returns ListGatewayResponse
   */
  async listGateway(request: ListGatewayRequest): Promise<ListGatewayResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listGatewayWithOptions(request, runtime);
  }

  /**
   * Queries the list of consumers on which a gateway performs authentication operations.
   * 
   * @param request - ListGatewayAuthConsumerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListGatewayAuthConsumerResponse
   */
  async listGatewayAuthConsumerWithOptions(request: ListGatewayAuthConsumerRequest, runtime: $Util.RuntimeOptions): Promise<ListGatewayAuthConsumerResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.consumerStatus)) {
      query["ConsumerStatus"] = request.consumerStatus;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListGatewayAuthConsumer",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListGatewayAuthConsumerResponse>(await this.callApi(params, req, runtime), new ListGatewayAuthConsumerResponse({}));
  }

  /**
   * Queries the list of consumers on which a gateway performs authentication operations.
   * 
   * @param request - ListGatewayAuthConsumerRequest
   * @returns ListGatewayAuthConsumerResponse
   */
  async listGatewayAuthConsumer(request: ListGatewayAuthConsumerRequest): Promise<ListGatewayAuthConsumerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listGatewayAuthConsumerWithOptions(request, runtime);
  }

  /**
   * Queries the list of authorized resources for the consumer on which a gateway performs authentication operations.
   * 
   * @param request - ListGatewayAuthConsumerResourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListGatewayAuthConsumerResourceResponse
   */
  async listGatewayAuthConsumerResourceWithOptions(request: ListGatewayAuthConsumerResourceRequest, runtime: $Util.RuntimeOptions): Promise<ListGatewayAuthConsumerResourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.consumerId)) {
      query["ConsumerId"] = request.consumerId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceStatus)) {
      query["ResourceStatus"] = request.resourceStatus;
    }

    if (!Util.isUnset(request.routeName)) {
      query["RouteName"] = request.routeName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListGatewayAuthConsumerResource",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListGatewayAuthConsumerResourceResponse>(await this.callApi(params, req, runtime), new ListGatewayAuthConsumerResourceResponse({}));
  }

  /**
   * Queries the list of authorized resources for the consumer on which a gateway performs authentication operations.
   * 
   * @param request - ListGatewayAuthConsumerResourceRequest
   * @returns ListGatewayAuthConsumerResourceResponse
   */
  async listGatewayAuthConsumerResource(request: ListGatewayAuthConsumerResourceRequest): Promise<ListGatewayAuthConsumerResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listGatewayAuthConsumerResourceWithOptions(request, runtime);
  }

  /**
   * 查看网关路由熔断规则
   * 
   * @param request - ListGatewayCircuitBreakerRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListGatewayCircuitBreakerRuleResponse
   */
  async listGatewayCircuitBreakerRuleWithOptions(request: ListGatewayCircuitBreakerRuleRequest, runtime: $Util.RuntimeOptions): Promise<ListGatewayCircuitBreakerRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.filterParams)) {
      query["FilterParams"] = request.filterParams;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListGatewayCircuitBreakerRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListGatewayCircuitBreakerRuleResponse>(await this.callApi(params, req, runtime), new ListGatewayCircuitBreakerRuleResponse({}));
  }

  /**
   * 查看网关路由熔断规则
   * 
   * @param request - ListGatewayCircuitBreakerRuleRequest
   * @returns ListGatewayCircuitBreakerRuleResponse
   */
  async listGatewayCircuitBreakerRule(request: ListGatewayCircuitBreakerRuleRequest): Promise<ListGatewayCircuitBreakerRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listGatewayCircuitBreakerRuleWithOptions(request, runtime);
  }

  /**
   * Queries the domain names that are associated with a gateway.
   * 
   * @param request - ListGatewayDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListGatewayDomainResponse
   */
  async listGatewayDomainWithOptions(request: ListGatewayDomainRequest, runtime: $Util.RuntimeOptions): Promise<ListGatewayDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListGatewayDomain",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListGatewayDomainResponse>(await this.callApi(params, req, runtime), new ListGatewayDomainResponse({}));
  }

  /**
   * Queries the domain names that are associated with a gateway.
   * 
   * @param request - ListGatewayDomainRequest
   * @returns ListGatewayDomainResponse
   */
  async listGatewayDomain(request: ListGatewayDomainRequest): Promise<ListGatewayDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listGatewayDomainWithOptions(request, runtime);
  }

  /**
   * 查看网关路由流控规则
   * 
   * @param request - ListGatewayFlowRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListGatewayFlowRuleResponse
   */
  async listGatewayFlowRuleWithOptions(request: ListGatewayFlowRuleRequest, runtime: $Util.RuntimeOptions): Promise<ListGatewayFlowRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.filterParams)) {
      query["FilterParams"] = request.filterParams;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListGatewayFlowRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListGatewayFlowRuleResponse>(await this.callApi(params, req, runtime), new ListGatewayFlowRuleResponse({}));
  }

  /**
   * 查看网关路由流控规则
   * 
   * @param request - ListGatewayFlowRuleRequest
   * @returns ListGatewayFlowRuleResponse
   */
  async listGatewayFlowRule(request: ListGatewayFlowRuleRequest): Promise<ListGatewayFlowRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listGatewayFlowRuleWithOptions(request, runtime);
  }

  /**
   * 查看网关路由隔离规则
   * 
   * @param request - ListGatewayIsolationRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListGatewayIsolationRuleResponse
   */
  async listGatewayIsolationRuleWithOptions(request: ListGatewayIsolationRuleRequest, runtime: $Util.RuntimeOptions): Promise<ListGatewayIsolationRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.filterParams)) {
      query["FilterParams"] = request.filterParams;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListGatewayIsolationRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListGatewayIsolationRuleResponse>(await this.callApi(params, req, runtime), new ListGatewayIsolationRuleResponse({}));
  }

  /**
   * 查看网关路由隔离规则
   * 
   * @param request - ListGatewayIsolationRuleRequest
   * @returns ListGatewayIsolationRuleResponse
   */
  async listGatewayIsolationRule(request: ListGatewayIsolationRuleRequest): Promise<ListGatewayIsolationRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listGatewayIsolationRuleWithOptions(request, runtime);
  }

  /**
   * Queries the routes of a gateway.
   * 
   * @param tmpReq - ListGatewayRouteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListGatewayRouteResponse
   */
  async listGatewayRouteWithOptions(tmpReq: ListGatewayRouteRequest, runtime: $Util.RuntimeOptions): Promise<ListGatewayRouteResponse> {
    Util.validateModel(tmpReq);
    let request = new ListGatewayRouteShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.filterParams)) {
      request.filterParamsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterParams, "FilterParams", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.descSort)) {
      query["DescSort"] = request.descSort;
    }

    if (!Util.isUnset(request.filterParamsShrink)) {
      query["FilterParams"] = request.filterParamsShrink;
    }

    if (!Util.isUnset(request.orderItem)) {
      query["OrderItem"] = request.orderItem;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListGatewayRoute",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListGatewayRouteResponse>(await this.callApi(params, req, runtime), new ListGatewayRouteResponse({}));
  }

  /**
   * Queries the routes of a gateway.
   * 
   * @param request - ListGatewayRouteRequest
   * @returns ListGatewayRouteResponse
   */
  async listGatewayRoute(request: ListGatewayRouteRequest): Promise<ListGatewayRouteResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listGatewayRouteWithOptions(request, runtime);
  }

  /**
   * Queries a list of routes for which authentication is enabled.
   * 
   * @param request - ListGatewayRouteOnAuthRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListGatewayRouteOnAuthResponse
   */
  async listGatewayRouteOnAuthWithOptions(request: ListGatewayRouteOnAuthRequest, runtime: $Util.RuntimeOptions): Promise<ListGatewayRouteOnAuthResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListGatewayRouteOnAuth",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListGatewayRouteOnAuthResponse>(await this.callApi(params, req, runtime), new ListGatewayRouteOnAuthResponse({}));
  }

  /**
   * Queries a list of routes for which authentication is enabled.
   * 
   * @param request - ListGatewayRouteOnAuthRequest
   * @returns ListGatewayRouteOnAuthResponse
   */
  async listGatewayRouteOnAuth(request: ListGatewayRouteOnAuthRequest): Promise<ListGatewayRouteOnAuthResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listGatewayRouteOnAuthWithOptions(request, runtime);
  }

  /**
   * Queries a list of services that are subscribed with a gateway.
   * 
   * @param tmpReq - ListGatewayServiceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListGatewayServiceResponse
   */
  async listGatewayServiceWithOptions(tmpReq: ListGatewayServiceRequest, runtime: $Util.RuntimeOptions): Promise<ListGatewayServiceResponse> {
    Util.validateModel(tmpReq);
    let request = new ListGatewayServiceShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.filterParams)) {
      request.filterParamsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterParams, "FilterParams", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.descSort)) {
      query["DescSort"] = request.descSort;
    }

    if (!Util.isUnset(request.filterParamsShrink)) {
      query["FilterParams"] = request.filterParamsShrink;
    }

    if (!Util.isUnset(request.orderItem)) {
      query["OrderItem"] = request.orderItem;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListGatewayService",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListGatewayServiceResponse>(await this.callApi(params, req, runtime), new ListGatewayServiceResponse({}));
  }

  /**
   * Queries a list of services that are subscribed with a gateway.
   * 
   * @param request - ListGatewayServiceRequest
   * @returns ListGatewayServiceResponse
   */
  async listGatewayService(request: ListGatewayServiceRequest): Promise<ListGatewayServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listGatewayServiceWithOptions(request, runtime);
  }

  /**
   * Queries the Server Load Balancer (SLB) instances that are associated with a gateway.
   * 
   * @param request - ListGatewaySlbRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListGatewaySlbResponse
   */
  async listGatewaySlbWithOptions(request: ListGatewaySlbRequest, runtime: $Util.RuntimeOptions): Promise<ListGatewaySlbResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListGatewaySlb",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListGatewaySlbResponse>(await this.callApi(params, req, runtime), new ListGatewaySlbResponse({}));
  }

  /**
   * Queries the Server Load Balancer (SLB) instances that are associated with a gateway.
   * 
   * @param request - ListGatewaySlbRequest
   * @returns ListGatewaySlbResponse
   */
  async listGatewaySlb(request: ListGatewaySlbRequest): Promise<ListGatewaySlbResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listGatewaySlbWithOptions(request, runtime);
  }

  /**
   * Obtains a list of zones where a gateway is available.
   * 
   * @param request - ListGatewayZoneRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListGatewayZoneResponse
   */
  async listGatewayZoneWithOptions(request: ListGatewayZoneRequest, runtime: $Util.RuntimeOptions): Promise<ListGatewayZoneResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListGatewayZone",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListGatewayZoneResponse>(await this.callApi(params, req, runtime), new ListGatewayZoneResponse({}));
  }

  /**
   * Obtains a list of zones where a gateway is available.
   * 
   * @param request - ListGatewayZoneRequest
   * @returns ListGatewayZoneResponse
   */
  async listGatewayZone(request: ListGatewayZoneRequest): Promise<ListGatewayZoneResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listGatewayZoneWithOptions(request, runtime);
  }

  /**
   * Displays the number of nodes that can be deployed for an instance.
   * 
   * @param request - ListInstanceCountRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListInstanceCountResponse
   */
  async listInstanceCountWithOptions(request: ListInstanceCountRequest, runtime: $Util.RuntimeOptions): Promise<ListInstanceCountResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterType)) {
      query["ClusterType"] = request.clusterType;
    }

    if (!Util.isUnset(request.mseVersion)) {
      query["MseVersion"] = request.mseVersion;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListInstanceCount",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListInstanceCountResponse>(await this.callApi(params, req, runtime), new ListInstanceCountResponse({}));
  }

  /**
   * Displays the number of nodes that can be deployed for an instance.
   * 
   * @param request - ListInstanceCountRequest
   * @returns ListInstanceCountResponse
   */
  async listInstanceCount(request: ListInstanceCountRequest): Promise<ListInstanceCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listInstanceCountWithOptions(request, runtime);
  }

  /**
   * 查询隔离规则
   * 
   * @param request - ListIsolationRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListIsolationRulesResponse
   */
  async listIsolationRulesWithOptions(request: ListIsolationRulesRequest, runtime: $Util.RuntimeOptions): Promise<ListIsolationRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pageIndex)) {
      query["PageIndex"] = request.pageIndex;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resource)) {
      query["Resource"] = request.resource;
    }

    if (!Util.isUnset(request.resourceSearchKey)) {
      query["ResourceSearchKey"] = request.resourceSearchKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListIsolationRules",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListIsolationRulesResponse>(await this.callApi(params, req, runtime), new ListIsolationRulesResponse({}));
  }

  /**
   * 查询隔离规则
   * 
   * @param request - ListIsolationRulesRequest
   * @returns ListIsolationRulesResponse
   */
  async listIsolationRules(request: ListIsolationRulesRequest): Promise<ListIsolationRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listIsolationRulesWithOptions(request, runtime);
  }

  /**
   * Queries listeners based on configuration information.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - ListListenersByConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListListenersByConfigResponse
   */
  async listListenersByConfigWithOptions(request: ListListenersByConfigRequest, runtime: $Util.RuntimeOptions): Promise<ListListenersByConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.dataId)) {
      query["DataId"] = request.dataId;
    }

    if (!Util.isUnset(request.group)) {
      query["Group"] = request.group;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListListenersByConfig",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListListenersByConfigResponse>(await this.callApi(params, req, runtime), new ListListenersByConfigResponse({}));
  }

  /**
   * Queries listeners based on configuration information.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - ListListenersByConfigRequest
   * @returns ListListenersByConfigResponse
   */
  async listListenersByConfig(request: ListListenersByConfigRequest): Promise<ListListenersByConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listListenersByConfigWithOptions(request, runtime);
  }

  /**
   * Queries the information about listeners based on IP addresses.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - ListListenersByIpRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListListenersByIpResponse
   */
  async listListenersByIpWithOptions(request: ListListenersByIpRequest, runtime: $Util.RuntimeOptions): Promise<ListListenersByIpResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListListenersByIp",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListListenersByIpResponse>(await this.callApi(params, req, runtime), new ListListenersByIpResponse({}));
  }

  /**
   * Queries the information about listeners based on IP addresses.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - ListListenersByIpRequest
   * @returns ListListenersByIpResponse
   */
  async listListenersByIp(request: ListListenersByIpRequest): Promise<ListListenersByIpResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listListenersByIpWithOptions(request, runtime);
  }

  /**
   * Queries information about a migration task.
   * 
   * @param request - ListMigrationTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListMigrationTaskResponse
   */
  async listMigrationTaskWithOptions(request: ListMigrationTaskRequest, runtime: $Util.RuntimeOptions): Promise<ListMigrationTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.originInstanceName)) {
      query["OriginInstanceName"] = request.originInstanceName;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListMigrationTask",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListMigrationTaskResponse>(await this.callApi(params, req, runtime), new ListMigrationTaskResponse({}));
  }

  /**
   * Queries information about a migration task.
   * 
   * @param request - ListMigrationTaskRequest
   * @returns ListMigrationTaskResponse
   */
  async listMigrationTask(request: ListMigrationTaskRequest): Promise<ListMigrationTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listMigrationTaskWithOptions(request, runtime);
  }

  /**
   * Queries Nacos configurations.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - ListNacosConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListNacosConfigsResponse
   */
  async listNacosConfigsWithOptions(request: ListNacosConfigsRequest, runtime: $Util.RuntimeOptions): Promise<ListNacosConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.dataId)) {
      query["DataId"] = request.dataId;
    }

    if (!Util.isUnset(request.group)) {
      query["Group"] = request.group;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListNacosConfigs",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListNacosConfigsResponse>(await this.callApi(params, req, runtime), new ListNacosConfigsResponse({}));
  }

  /**
   * Queries Nacos configurations.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - ListNacosConfigsRequest
   * @returns ListNacosConfigsResponse
   */
  async listNacosConfigs(request: ListNacosConfigsRequest): Promise<ListNacosConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listNacosConfigsWithOptions(request, runtime);
  }

  /**
   * Queries the configuration history of a Microservices Engine (MSE) Nacos instance.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - ListNacosHistoryConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListNacosHistoryConfigsResponse
   */
  async listNacosHistoryConfigsWithOptions(request: ListNacosHistoryConfigsRequest, runtime: $Util.RuntimeOptions): Promise<ListNacosHistoryConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.dataId)) {
      query["DataId"] = request.dataId;
    }

    if (!Util.isUnset(request.group)) {
      query["Group"] = request.group;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListNacosHistoryConfigs",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListNacosHistoryConfigsResponse>(await this.callApi(params, req, runtime), new ListNacosHistoryConfigsResponse({}));
  }

  /**
   * Queries the configuration history of a Microservices Engine (MSE) Nacos instance.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - ListNacosHistoryConfigsRequest
   * @returns ListNacosHistoryConfigsResponse
   */
  async listNacosHistoryConfigs(request: ListNacosHistoryConfigsRequest): Promise<ListNacosHistoryConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listNacosHistoryConfigsWithOptions(request, runtime);
  }

  /**
   * Obtains the trajectory data of a Nacos registry.
   * 
   * @param request - ListNamingTrackRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListNamingTrackResponse
   */
  async listNamingTrackWithOptions(request: ListNamingTrackRequest, runtime: $Util.RuntimeOptions): Promise<ListNamingTrackResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListNamingTrack",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListNamingTrackResponse>(await this.callApi(params, req, runtime), new ListNamingTrackResponse({}));
  }

  /**
   * Obtains the trajectory data of a Nacos registry.
   * 
   * @param request - ListNamingTrackRequest
   * @returns ListNamingTrackResponse
   */
  async listNamingTrack(request: ListNamingTrackRequest): Promise<ListNamingTrackResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listNamingTrackWithOptions(request, runtime);
  }

  /**
   * Obtains a list of gateway certificates.
   * 
   * @param request - ListSSLCertRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSSLCertResponse
   */
  async listSSLCertWithOptions(request: ListSSLCertRequest, runtime: $Util.RuntimeOptions): Promise<ListSSLCertResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.certName)) {
      query["CertName"] = request.certName;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSSLCert",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSSLCertResponse>(await this.callApi(params, req, runtime), new ListSSLCertResponse({}));
  }

  /**
   * Obtains a list of gateway certificates.
   * 
   * @param request - ListSSLCertRequest
   * @returns ListSSLCertResponse
   */
  async listSSLCert(request: ListSSLCertRequest): Promise<ListSSLCertResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSSLCertWithOptions(request, runtime);
  }

  /**
   * Obtains the information about security groups.
   * 
   * @param request - ListSecurityGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSecurityGroupResponse
   */
  async listSecurityGroupWithOptions(request: ListSecurityGroupRequest, runtime: $Util.RuntimeOptions): Promise<ListSecurityGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSecurityGroup",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSecurityGroupResponse>(await this.callApi(params, req, runtime), new ListSecurityGroupResponse({}));
  }

  /**
   * Obtains the information about security groups.
   * 
   * @param request - ListSecurityGroupRequest
   * @returns ListSecurityGroupResponse
   */
  async listSecurityGroup(request: ListSecurityGroupRequest): Promise<ListSecurityGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSecurityGroupWithOptions(request, runtime);
  }

  /**
   * Queries the security group rules of a gateway.
   * 
   * @param request - ListSecurityGroupRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSecurityGroupRuleResponse
   */
  async listSecurityGroupRuleWithOptions(request: ListSecurityGroupRuleRequest, runtime: $Util.RuntimeOptions): Promise<ListSecurityGroupRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSecurityGroupRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSecurityGroupRuleResponse>(await this.callApi(params, req, runtime), new ListSecurityGroupRuleResponse({}));
  }

  /**
   * Queries the security group rules of a gateway.
   * 
   * @param request - ListSecurityGroupRuleRequest
   * @returns ListSecurityGroupRuleResponse
   */
  async listSecurityGroupRule(request: ListSecurityGroupRuleRequest): Promise<ListSecurityGroupRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSecurityGroupRuleWithOptions(request, runtime);
  }

  /**
   * 查询流量防护行为
   * 
   * @param tmpReq - ListSentinelBlockFallbackDefinitionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSentinelBlockFallbackDefinitionsResponse
   */
  async listSentinelBlockFallbackDefinitionsWithOptions(tmpReq: ListSentinelBlockFallbackDefinitionsRequest, runtime: $Util.RuntimeOptions): Promise<ListSentinelBlockFallbackDefinitionsResponse> {
    Util.validateModel(tmpReq);
    let request = new ListSentinelBlockFallbackDefinitionsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.classificationSet)) {
      request.classificationSetShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.classificationSet, "ClassificationSet", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.classificationSetShrink)) {
      query["ClassificationSet"] = request.classificationSetShrink;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSentinelBlockFallbackDefinitions",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSentinelBlockFallbackDefinitionsResponse>(await this.callApi(params, req, runtime), new ListSentinelBlockFallbackDefinitionsResponse({}));
  }

  /**
   * 查询流量防护行为
   * 
   * @param request - ListSentinelBlockFallbackDefinitionsRequest
   * @returns ListSentinelBlockFallbackDefinitionsResponse
   */
  async listSentinelBlockFallbackDefinitions(request: ListSentinelBlockFallbackDefinitionsRequest): Promise<ListSentinelBlockFallbackDefinitionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSentinelBlockFallbackDefinitionsWithOptions(request, runtime);
  }

  /**
   * Queries a list of associated sources.
   * 
   * @param request - ListServiceSourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListServiceSourceResponse
   */
  async listServiceSourceWithOptions(request: ListServiceSourceRequest, runtime: $Util.RuntimeOptions): Promise<ListServiceSourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListServiceSource",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListServiceSourceResponse>(await this.callApi(params, req, runtime), new ListServiceSourceResponse({}));
  }

  /**
   * Queries a list of associated sources.
   * 
   * @param request - ListServiceSourceRequest
   * @returns ListServiceSourceResponse
   */
  async listServiceSource(request: ListServiceSourceRequest): Promise<ListServiceSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listServiceSourceWithOptions(request, runtime);
  }

  /**
   * Queries tagged resources.
   * 
   * @param request - ListTagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTagResourcesResponse
   */
  async listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<ListTagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTagResources",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTagResourcesResponse>(await this.callApi(params, req, runtime), new ListTagResourcesResponse({}));
  }

  /**
   * Queries tagged resources.
   * 
   * @param request - ListTagResourcesRequest
   * @returns ListTagResourcesResponse
   */
  async listTagResources(request: ListTagResourcesRequest): Promise<ListTagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTagResourcesWithOptions(request, runtime);
  }

  /**
   * Obtains the track data of a ZooKeeper instance.
   * 
   * @param request - ListZkTrackRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListZkTrackResponse
   */
  async listZkTrackWithOptions(request: ListZkTrackRequest, runtime: $Util.RuntimeOptions): Promise<ListZkTrackResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.endTs)) {
      query["EndTs"] = request.endTs;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.path)) {
      query["Path"] = request.path;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    if (!Util.isUnset(request.reverse)) {
      query["Reverse"] = request.reverse;
    }

    if (!Util.isUnset(request.sessionId)) {
      query["SessionId"] = request.sessionId;
    }

    if (!Util.isUnset(request.startTs)) {
      query["StartTs"] = request.startTs;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListZkTrack",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListZkTrackResponse>(await this.callApi(params, req, runtime), new ListZkTrackResponse({}));
  }

  /**
   * Obtains the track data of a ZooKeeper instance.
   * 
   * @param request - ListZkTrackRequest
   * @returns ListZkTrackResponse
   */
  async listZkTrack(request: ListZkTrackRequest): Promise<ListZkTrackResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listZkTrackWithOptions(request, runtime);
  }

  /**
   * Queries the child nodes of a ZooKeeper node.
   * 
   * @param request - ListZnodeChildrenRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListZnodeChildrenResponse
   */
  async listZnodeChildrenWithOptions(request: ListZnodeChildrenRequest, runtime: $Util.RuntimeOptions): Promise<ListZnodeChildrenResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.path)) {
      query["Path"] = request.path;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListZnodeChildren",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListZnodeChildrenResponse>(await this.callApi(params, req, runtime), new ListZnodeChildrenResponse({}));
  }

  /**
   * Queries the child nodes of a ZooKeeper node.
   * 
   * @param request - ListZnodeChildrenRequest
   * @returns ListZnodeChildrenResponse
   */
  async listZnodeChildren(request: ListZnodeChildrenRequest): Promise<ListZnodeChildrenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listZnodeChildrenWithOptions(request, runtime);
  }

  /**
   * Modifies the information about a cluster for which Microservice Governance is enabled.
   * 
   * @param tmpReq - ModifyGovernanceKubernetesClusterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyGovernanceKubernetesClusterResponse
   */
  async modifyGovernanceKubernetesClusterWithOptions(tmpReq: ModifyGovernanceKubernetesClusterRequest, runtime: $Util.RuntimeOptions): Promise<ModifyGovernanceKubernetesClusterResponse> {
    Util.validateModel(tmpReq);
    let request = new ModifyGovernanceKubernetesClusterShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.namespaceInfos)) {
      request.namespaceInfosShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.namespaceInfos, "NamespaceInfos", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.namespaceInfosShrink)) {
      body["NamespaceInfos"] = request.namespaceInfosShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyGovernanceKubernetesCluster",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyGovernanceKubernetesClusterResponse>(await this.callApi(params, req, runtime), new ModifyGovernanceKubernetesClusterResponse({}));
  }

  /**
   * Modifies the information about a cluster for which Microservice Governance is enabled.
   * 
   * @param request - ModifyGovernanceKubernetesClusterRequest
   * @returns ModifyGovernanceKubernetesClusterResponse
   */
  async modifyGovernanceKubernetesCluster(request: ModifyGovernanceKubernetesClusterRequest): Promise<ModifyGovernanceKubernetesClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyGovernanceKubernetesClusterWithOptions(request, runtime);
  }

  /**
   * Modifies configurations of the lossless online and offline feature.
   * 
   * @param request - ModifyLosslessRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyLosslessRuleResponse
   */
  async modifyLosslessRuleWithOptions(request: ModifyLosslessRuleRequest, runtime: $Util.RuntimeOptions): Promise<ModifyLosslessRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.aligned)) {
      query["Aligned"] = request.aligned;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.delayTime)) {
      query["DelayTime"] = request.delayTime;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.funcType)) {
      query["FuncType"] = request.funcType;
    }

    if (!Util.isUnset(request.lossLessDetail)) {
      query["LossLessDetail"] = request.lossLessDetail;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.notice)) {
      query["Notice"] = request.notice;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.related)) {
      query["Related"] = request.related;
    }

    if (!Util.isUnset(request.warmupTime)) {
      query["WarmupTime"] = request.warmupTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyLosslessRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyLosslessRuleResponse>(await this.callApi(params, req, runtime), new ModifyLosslessRuleResponse({}));
  }

  /**
   * Modifies configurations of the lossless online and offline feature.
   * 
   * @param request - ModifyLosslessRuleRequest
   * @returns ModifyLosslessRuleResponse
   */
  async modifyLosslessRule(request: ModifyLosslessRuleRequest): Promise<ModifyLosslessRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyLosslessRuleWithOptions(request, runtime);
  }

  /**
   * Unpublishes a route for a gateway.
   * 
   * @param request - OfflineGatewayRouteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns OfflineGatewayRouteResponse
   */
  async offlineGatewayRouteWithOptions(request: OfflineGatewayRouteRequest, runtime: $Util.RuntimeOptions): Promise<OfflineGatewayRouteResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.routeId)) {
      query["RouteId"] = request.routeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OfflineGatewayRoute",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OfflineGatewayRouteResponse>(await this.callApi(params, req, runtime), new OfflineGatewayRouteResponse({}));
  }

  /**
   * Unpublishes a route for a gateway.
   * 
   * @param request - OfflineGatewayRouteRequest
   * @returns OfflineGatewayRouteResponse
   */
  async offlineGatewayRoute(request: OfflineGatewayRouteRequest): Promise<OfflineGatewayRouteResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.offlineGatewayRouteWithOptions(request, runtime);
  }

  /**
   * Subscribes to the notification feature if a risk is detected during a health check.
   * 
   * @param request - OrderClusterHealthCheckRiskNoticeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns OrderClusterHealthCheckRiskNoticeResponse
   */
  async orderClusterHealthCheckRiskNoticeWithOptions(request: OrderClusterHealthCheckRiskNoticeRequest, runtime: $Util.RuntimeOptions): Promise<OrderClusterHealthCheckRiskNoticeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.mute)) {
      query["Mute"] = request.mute;
    }

    if (!Util.isUnset(request.noticeType)) {
      query["NoticeType"] = request.noticeType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    if (!Util.isUnset(request.riskCode)) {
      query["RiskCode"] = request.riskCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OrderClusterHealthCheckRiskNotice",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OrderClusterHealthCheckRiskNoticeResponse>(await this.callApi(params, req, runtime), new OrderClusterHealthCheckRiskNoticeResponse({}));
  }

  /**
   * Subscribes to the notification feature if a risk is detected during a health check.
   * 
   * @param request - OrderClusterHealthCheckRiskNoticeRequest
   * @returns OrderClusterHealthCheckRiskNoticeResponse
   */
  async orderClusterHealthCheckRiskNotice(request: OrderClusterHealthCheckRiskNoticeRequest): Promise<OrderClusterHealthCheckRiskNoticeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.orderClusterHealthCheckRiskNoticeWithOptions(request, runtime);
  }

  /**
   * Specifies whether to convert all letters of a header into lowercase letters. For requests and responses, HTTP/1.1 headers are not case-sensitive. By default, all letters of headers are converted into lowercase letters.
   * 
   * @param request - PreserveHeaderFormatRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PreserveHeaderFormatResponse
   */
  async preserveHeaderFormatWithOptions(request: PreserveHeaderFormatRequest, runtime: $Util.RuntimeOptions): Promise<PreserveHeaderFormatResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.preserveHeaderFormat)) {
      query["PreserveHeaderFormat"] = request.preserveHeaderFormat;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PreserveHeaderFormat",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PreserveHeaderFormatResponse>(await this.callApi(params, req, runtime), new PreserveHeaderFormatResponse({}));
  }

  /**
   * Specifies whether to convert all letters of a header into lowercase letters. For requests and responses, HTTP/1.1 headers are not case-sensitive. By default, all letters of headers are converted into lowercase letters.
   * 
   * @param request - PreserveHeaderFormatRequest
   * @returns PreserveHeaderFormatResponse
   */
  async preserveHeaderFormat(request: PreserveHeaderFormatRequest): Promise<PreserveHeaderFormatResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.preserveHeaderFormatWithOptions(request, runtime);
  }

  /**
   * Queries all the microservices of a service source.
   * 
   * @param request - PullServicesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PullServicesResponse
   */
  async pullServicesWithOptions(request: PullServicesRequest, runtime: $Util.RuntimeOptions): Promise<PullServicesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.sourceType)) {
      query["SourceType"] = request.sourceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PullServices",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PullServicesResponse>(await this.callApi(params, req, runtime), new PullServicesResponse({}));
  }

  /**
   * Queries all the microservices of a service source.
   * 
   * @param request - PullServicesRequest
   * @returns PullServicesResponse
   */
  async pullServices(request: PullServicesRequest): Promise<PullServicesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.pullServicesWithOptions(request, runtime);
  }

  /**
   * Initiates a task to check risk evaluation for an instance.
   * 
   * @param request - PutClusterHealthCheckTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutClusterHealthCheckTaskResponse
   */
  async putClusterHealthCheckTaskWithOptions(request: PutClusterHealthCheckTaskRequest, runtime: $Util.RuntimeOptions): Promise<PutClusterHealthCheckTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutClusterHealthCheckTask",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutClusterHealthCheckTaskResponse>(await this.callApi(params, req, runtime), new PutClusterHealthCheckTaskResponse({}));
  }

  /**
   * Initiates a task to check risk evaluation for an instance.
   * 
   * @param request - PutClusterHealthCheckTaskRequest
   * @returns PutClusterHealthCheckTaskResponse
   */
  async putClusterHealthCheckTask(request: PutClusterHealthCheckTaskRequest): Promise<PutClusterHealthCheckTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putClusterHealthCheckTaskWithOptions(request, runtime);
  }

  /**
   * Queries all the lanes in a lane group.
   * 
   * @param request - QueryAllSwimmingLaneRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryAllSwimmingLaneResponse
   */
  async queryAllSwimmingLaneWithOptions(request: QueryAllSwimmingLaneRequest, runtime: $Util.RuntimeOptions): Promise<QueryAllSwimmingLaneResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryAllSwimmingLane",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryAllSwimmingLaneResponse>(await this.callApi(params, req, runtime), new QueryAllSwimmingLaneResponse({}));
  }

  /**
   * Queries all the lanes in a lane group.
   * 
   * @param request - QueryAllSwimmingLaneRequest
   * @returns QueryAllSwimmingLaneResponse
   */
  async queryAllSwimmingLane(request: QueryAllSwimmingLaneRequest): Promise<QueryAllSwimmingLaneResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryAllSwimmingLaneWithOptions(request, runtime);
  }

  /**
   * Queries all lane groups.
   * 
   * @param request - QueryAllSwimmingLaneGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryAllSwimmingLaneGroupResponse
   */
  async queryAllSwimmingLaneGroupWithOptions(request: QueryAllSwimmingLaneGroupRequest, runtime: $Util.RuntimeOptions): Promise<QueryAllSwimmingLaneGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryAllSwimmingLaneGroup",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryAllSwimmingLaneGroupResponse>(await this.callApi(params, req, runtime), new QueryAllSwimmingLaneGroupResponse({}));
  }

  /**
   * Queries all lane groups.
   * 
   * @param request - QueryAllSwimmingLaneGroupRequest
   * @returns QueryAllSwimmingLaneGroupResponse
   */
  async queryAllSwimmingLaneGroup(request: QueryAllSwimmingLaneGroupRequest): Promise<QueryAllSwimmingLaneGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryAllSwimmingLaneGroupWithOptions(request, runtime);
  }

  /**
   * Queries information about regions.
   * 
   * @param request - QueryBusinessLocationsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryBusinessLocationsResponse
   */
  async queryBusinessLocationsWithOptions(request: QueryBusinessLocationsRequest, runtime: $Util.RuntimeOptions): Promise<QueryBusinessLocationsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryBusinessLocations",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryBusinessLocationsResponse>(await this.callApi(params, req, runtime), new QueryBusinessLocationsResponse({}));
  }

  /**
   * Queries information about regions.
   * 
   * @param request - QueryBusinessLocationsRequest
   * @returns QueryBusinessLocationsResponse
   */
  async queryBusinessLocations(request: QueryBusinessLocationsRequest): Promise<QueryBusinessLocationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryBusinessLocationsWithOptions(request, runtime);
  }

  /**
   * Queries the details of an instance.
   * 
   * @param request - QueryClusterDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryClusterDetailResponse
   */
  async queryClusterDetailWithOptions(request: QueryClusterDetailRequest, runtime: $Util.RuntimeOptions): Promise<QueryClusterDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.aclSwitch)) {
      query["AclSwitch"] = request.aclSwitch;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryClusterDetail",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryClusterDetailResponse>(await this.callApi(params, req, runtime), new QueryClusterDetailResponse({}));
  }

  /**
   * Queries the details of an instance.
   * 
   * @param request - QueryClusterDetailRequest
   * @returns QueryClusterDetailResponse
   */
  async queryClusterDetail(request: QueryClusterDetailRequest): Promise<QueryClusterDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryClusterDetailWithOptions(request, runtime);
  }

  /**
   * Queries disk specifications that are supported by an instance.
   * 
   * @param request - QueryClusterDiskSpecificationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryClusterDiskSpecificationResponse
   */
  async queryClusterDiskSpecificationWithOptions(request: QueryClusterDiskSpecificationRequest, runtime: $Util.RuntimeOptions): Promise<QueryClusterDiskSpecificationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterType)) {
      query["ClusterType"] = request.clusterType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryClusterDiskSpecification",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryClusterDiskSpecificationResponse>(await this.callApi(params, req, runtime), new QueryClusterDiskSpecificationResponse({}));
  }

  /**
   * Queries disk specifications that are supported by an instance.
   * 
   * @param request - QueryClusterDiskSpecificationRequest
   * @returns QueryClusterDiskSpecificationResponse
   */
  async queryClusterDiskSpecification(request: QueryClusterDiskSpecificationRequest): Promise<QueryClusterDiskSpecificationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryClusterDiskSpecificationWithOptions(request, runtime);
  }

  /**
   * Queries the static information of an instance.
   * 
   * @param request - QueryClusterInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryClusterInfoResponse
   */
  async queryClusterInfoWithOptions(request: QueryClusterInfoRequest, runtime: $Util.RuntimeOptions): Promise<QueryClusterInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.aclSwitch)) {
      query["AclSwitch"] = request.aclSwitch;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryClusterInfo",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryClusterInfoResponse>(await this.callApi(params, req, runtime), new QueryClusterInfoResponse({}));
  }

  /**
   * Queries the static information of an instance.
   * 
   * @param request - QueryClusterInfoRequest
   * @returns QueryClusterInfoResponse
   */
  async queryClusterInfo(request: QueryClusterInfoRequest): Promise<QueryClusterInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryClusterInfoWithOptions(request, runtime);
  }

  /**
   * Queries the information of supported instance specifications.
   * 
   * @param request - QueryClusterSpecificationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryClusterSpecificationResponse
   */
  async queryClusterSpecificationWithOptions(request: QueryClusterSpecificationRequest, runtime: $Util.RuntimeOptions): Promise<QueryClusterSpecificationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.connectType)) {
      query["ConnectType"] = request.connectType;
    }

    if (!Util.isUnset(request.mseVersion)) {
      query["MseVersion"] = request.mseVersion;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryClusterSpecification",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryClusterSpecificationResponse>(await this.callApi(params, req, runtime), new QueryClusterSpecificationResponse({}));
  }

  /**
   * Queries the information of supported instance specifications.
   * 
   * @param request - QueryClusterSpecificationRequest
   * @returns QueryClusterSpecificationResponse
   */
  async queryClusterSpecification(request: QueryClusterSpecificationRequest): Promise<QueryClusterSpecificationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryClusterSpecificationWithOptions(request, runtime);
  }

  /**
   * Queries configuration information of an instance.
   * 
   * @param request - QueryConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryConfigResponse
   */
  async queryConfigWithOptions(request: QueryConfigRequest, runtime: $Util.RuntimeOptions): Promise<QueryConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.configType)) {
      query["ConfigType"] = request.configType;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.needRunningConf)) {
      query["NeedRunningConf"] = request.needRunningConf;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryConfig",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryConfigResponse>(await this.callApi(params, req, runtime), new QueryConfigResponse({}));
  }

  /**
   * Queries configuration information of an instance.
   * 
   * @param request - QueryConfigRequest
   * @returns QueryConfigResponse
   */
  async queryConfig(request: QueryConfigRequest): Promise<QueryConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryConfigWithOptions(request, runtime);
  }

  /**
   * Queries the regions supported by a gateway.
   * 
   * @param request - QueryGatewayRegionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryGatewayRegionResponse
   */
  async queryGatewayRegionWithOptions(request: QueryGatewayRegionRequest, runtime: $Util.RuntimeOptions): Promise<QueryGatewayRegionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryGatewayRegion",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryGatewayRegionResponse>(await this.callApi(params, req, runtime), new QueryGatewayRegionResponse({}));
  }

  /**
   * Queries the regions supported by a gateway.
   * 
   * @param request - QueryGatewayRegionRequest
   * @returns QueryGatewayRegionResponse
   */
  async queryGatewayRegion(request: QueryGatewayRegionRequest): Promise<QueryGatewayRegionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryGatewayRegionWithOptions(request, runtime);
  }

  /**
   * Queries available gateway types.
   * 
   * @param request - QueryGatewayTypeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryGatewayTypeResponse
   */
  async queryGatewayTypeWithOptions(request: QueryGatewayTypeRequest, runtime: $Util.RuntimeOptions): Promise<QueryGatewayTypeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryGatewayType",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryGatewayTypeResponse>(await this.callApi(params, req, runtime), new QueryGatewayTypeResponse({}));
  }

  /**
   * Queries available gateway types.
   * 
   * @param request - QueryGatewayTypeRequest
   * @returns QueryGatewayTypeResponse
   */
  async queryGatewayType(request: QueryGatewayTypeRequest): Promise<QueryGatewayTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryGatewayTypeWithOptions(request, runtime);
  }

  /**
   * Queries the Kubernetes clusters for which Microservices Governance is activated.
   * 
   * @param request - QueryGovernanceKubernetesClusterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryGovernanceKubernetesClusterResponse
   */
  async queryGovernanceKubernetesClusterWithOptions(request: QueryGovernanceKubernetesClusterRequest, runtime: $Util.RuntimeOptions): Promise<QueryGovernanceKubernetesClusterResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryGovernanceKubernetesCluster",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryGovernanceKubernetesClusterResponse>(await this.callApi(params, req, runtime), new QueryGovernanceKubernetesClusterResponse({}));
  }

  /**
   * Queries the Kubernetes clusters for which Microservices Governance is activated.
   * 
   * @param request - QueryGovernanceKubernetesClusterRequest
   * @returns QueryGovernanceKubernetesClusterResponse
   */
  async queryGovernanceKubernetesCluster(request: QueryGovernanceKubernetesClusterRequest): Promise<QueryGovernanceKubernetesClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryGovernanceKubernetesClusterWithOptions(request, runtime);
  }

  /**
   * Queries the runtime data of a specified cluster.
   * 
   * @param request - QueryInstancesInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryInstancesInfoResponse
   */
  async queryInstancesInfoWithOptions(request: QueryInstancesInfoRequest, runtime: $Util.RuntimeOptions): Promise<QueryInstancesInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryInstancesInfo",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryInstancesInfoResponse>(await this.callApi(params, req, runtime), new QueryInstancesInfoResponse({}));
  }

  /**
   * Queries the runtime data of a specified cluster.
   * 
   * @param request - QueryInstancesInfoRequest
   * @returns QueryInstancesInfoResponse
   */
  async queryInstancesInfo(request: QueryInstancesInfoRequest): Promise<QueryInstancesInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryInstancesInfoWithOptions(request, runtime);
  }

  /**
   * Queries monitoring information.
   * 
   * @param request - QueryMonitorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryMonitorResponse
   */
  async queryMonitorWithOptions(request: QueryMonitorRequest, runtime: $Util.RuntimeOptions): Promise<QueryMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.monitorType)) {
      query["MonitorType"] = request.monitorType;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.step)) {
      query["Step"] = request.step;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryMonitor",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryMonitorResponse>(await this.callApi(params, req, runtime), new QueryMonitorResponse({}));
  }

  /**
   * Queries monitoring information.
   * 
   * @param request - QueryMonitorRequest
   * @returns QueryMonitorResponse
   */
  async queryMonitor(request: QueryMonitorRequest): Promise<QueryMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryMonitorWithOptions(request, runtime);
  }

  /**
   * 查询MSE命名空间
   * 
   * @param request - QueryNamespaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryNamespaceResponse
   */
  async queryNamespaceWithOptions(request: QueryNamespaceRequest, runtime: $Util.RuntimeOptions): Promise<QueryNamespaceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryNamespace",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryNamespaceResponse>(await this.callApi(params, req, runtime), new QueryNamespaceResponse({}));
  }

  /**
   * 查询MSE命名空间
   * 
   * @param request - QueryNamespaceRequest
   * @returns QueryNamespaceResponse
   */
  async queryNamespace(request: QueryNamespaceRequest): Promise<QueryNamespaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryNamespaceWithOptions(request, runtime);
  }

  /**
   * Queries the type of a Server Load Balancer (SLB) instance.
   * 
   * @param request - QuerySlbSpecRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QuerySlbSpecResponse
   */
  async querySlbSpecWithOptions(request: QuerySlbSpecRequest, runtime: $Util.RuntimeOptions): Promise<QuerySlbSpecResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QuerySlbSpec",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySlbSpecResponse>(await this.callApi(params, req, runtime), new QuerySlbSpecResponse({}));
  }

  /**
   * Queries the type of a Server Load Balancer (SLB) instance.
   * 
   * @param request - QuerySlbSpecRequest
   * @returns QuerySlbSpecResponse
   */
  async querySlbSpec(request: QuerySlbSpecRequest): Promise<QuerySlbSpecResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySlbSpecWithOptions(request, runtime);
  }

  /**
   * Queries the information about a lane based on the lane ID.
   * 
   * @param request - QuerySwimmingLaneByIdRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QuerySwimmingLaneByIdResponse
   */
  async querySwimmingLaneByIdWithOptions(request: QuerySwimmingLaneByIdRequest, runtime: $Util.RuntimeOptions): Promise<QuerySwimmingLaneByIdResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.laneId)) {
      query["LaneId"] = request.laneId;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QuerySwimmingLaneById",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySwimmingLaneByIdResponse>(await this.callApi(params, req, runtime), new QuerySwimmingLaneByIdResponse({}));
  }

  /**
   * Queries the information about a lane based on the lane ID.
   * 
   * @param request - QuerySwimmingLaneByIdRequest
   * @returns QuerySwimmingLaneByIdResponse
   */
  async querySwimmingLaneById(request: QuerySwimmingLaneByIdRequest): Promise<QuerySwimmingLaneByIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySwimmingLaneByIdWithOptions(request, runtime);
  }

  /**
   * Queries the information about a ZooKeeper node.
   * 
   * @param request - QueryZnodeDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryZnodeDetailResponse
   */
  async queryZnodeDetailWithOptions(request: QueryZnodeDetailRequest, runtime: $Util.RuntimeOptions): Promise<QueryZnodeDetailResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryZnodeDetail",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryZnodeDetailResponse>(await this.callApi(params, req, runtime), new QueryZnodeDetailResponse({}));
  }

  /**
   * Queries the information about a ZooKeeper node.
   * 
   * @param request - QueryZnodeDetailRequest
   * @returns QueryZnodeDetailResponse
   */
  async queryZnodeDetail(request: QueryZnodeDetailRequest): Promise<QueryZnodeDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryZnodeDetailWithOptions(request, runtime);
  }

  /**
   * 删除单个应用
   * 
   * @param request - RemoveApplicationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveApplicationResponse
   */
  async removeApplicationWithOptions(request: RemoveApplicationRequest, runtime: $Util.RuntimeOptions): Promise<RemoveApplicationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveApplication",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveApplicationResponse>(await this.callApi(params, req, runtime), new RemoveApplicationResponse({}));
  }

  /**
   * 删除单个应用
   * 
   * @param request - RemoveApplicationRequest
   * @returns RemoveApplicationResponse
   */
  async removeApplication(request: RemoveApplicationRequest): Promise<RemoveApplicationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeApplicationWithOptions(request, runtime);
  }

  /**
   * @param request - RemoveAuthPolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveAuthPolicyResponse
   */
  async removeAuthPolicyWithOptions(request: RemoveAuthPolicyRequest, runtime: $Util.RuntimeOptions): Promise<RemoveAuthPolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveAuthPolicy",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveAuthPolicyResponse>(await this.callApi(params, req, runtime), new RemoveAuthPolicyResponse({}));
  }

  /**
   * @param request - RemoveAuthPolicyRequest
   * @returns RemoveAuthPolicyResponse
   */
  async removeAuthPolicy(request: RemoveAuthPolicyRequest): Promise<RemoveAuthPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeAuthPolicyWithOptions(request, runtime);
  }

  /**
   * Restarts a registry.
   * 
   * @param request - RestartClusterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RestartClusterResponse
   */
  async restartClusterWithOptions(request: RestartClusterRequest, runtime: $Util.RuntimeOptions): Promise<RestartClusterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.podNameList)) {
      query["PodNameList"] = request.podNameList;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RestartCluster",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RestartClusterResponse>(await this.callApi(params, req, runtime), new RestartClusterResponse({}));
  }

  /**
   * Restarts a registry.
   * 
   * @param request - RestartClusterRequest
   * @returns RestartClusterResponse
   */
  async restartCluster(request: RestartClusterRequest): Promise<RestartClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.restartClusterWithOptions(request, runtime);
  }

  /**
   * Retries a cluster.
   * 
   * @param request - RetryClusterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RetryClusterResponse
   */
  async retryClusterWithOptions(request: RetryClusterRequest, runtime: $Util.RuntimeOptions): Promise<RetryClusterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RetryCluster",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RetryClusterResponse>(await this.callApi(params, req, runtime), new RetryClusterResponse({}));
  }

  /**
   * Retries a cluster.
   * 
   * @param request - RetryClusterRequest
   * @returns RetryClusterResponse
   */
  async retryCluster(request: RetryClusterRequest): Promise<RetryClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.retryClusterWithOptions(request, runtime);
  }

  /**
   * Queries an idle Server Load Balancer (SLB) instance that is associated with a gateway.
   * 
   * @param request - SelectGatewaySlbRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SelectGatewaySlbResponse
   */
  async selectGatewaySlbWithOptions(request: SelectGatewaySlbRequest, runtime: $Util.RuntimeOptions): Promise<SelectGatewaySlbResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SelectGatewaySlb",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SelectGatewaySlbResponse>(await this.callApi(params, req, runtime), new SelectGatewaySlbResponse({}));
  }

  /**
   * Queries an idle Server Load Balancer (SLB) instance that is associated with a gateway.
   * 
   * @param request - SelectGatewaySlbRequest
   * @returns SelectGatewaySlbResponse
   */
  async selectGatewaySlb(request: SelectGatewaySlbRequest): Promise<SelectGatewaySlbResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.selectGatewaySlbWithOptions(request, runtime);
  }

  /**
   * Tags a specified resource.
   * 
   * @param request - TagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns TagResourcesResponse
   */
  async tagResourcesWithOptions(request: TagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<TagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "TagResources",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<TagResourcesResponse>(await this.callApi(params, req, runtime), new TagResourcesResponse({}));
  }

  /**
   * Tags a specified resource.
   * 
   * @param request - TagResourcesRequest
   * @returns TagResourcesResponse
   */
  async tagResources(request: TagResourcesRequest): Promise<TagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.tagResourcesWithOptions(request, runtime);
  }

  /**
   * Untags resources.
   * 
   * @param request - UntagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UntagResourcesResponse
   */
  async untagResourcesWithOptions(request: UntagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<UntagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.all)) {
      query["All"] = request.all;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tagKey)) {
      query["TagKey"] = request.tagKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UntagResources",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UntagResourcesResponse>(await this.callApi(params, req, runtime), new UntagResourcesResponse({}));
  }

  /**
   * Untags resources.
   * 
   * @param request - UntagResourcesRequest
   * @returns UntagResourcesResponse
   */
  async untagResources(request: UntagResourcesRequest): Promise<UntagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.untagResourcesWithOptions(request, runtime);
  }

  /**
   * Modifies an IP address whitelist.
   * 
   * @param request - UpdateAclRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateAclResponse
   */
  async updateAclWithOptions(request: UpdateAclRequest, runtime: $Util.RuntimeOptions): Promise<UpdateAclResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.aclEntryList)) {
      query["AclEntryList"] = request.aclEntryList;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateAcl",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateAclResponse>(await this.callApi(params, req, runtime), new UpdateAclResponse({}));
  }

  /**
   * Modifies an IP address whitelist.
   * 
   * @param request - UpdateAclRequest
   * @returns UpdateAclResponse
   */
  async updateAcl(request: UpdateAclRequest): Promise<UpdateAclResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateAclWithOptions(request, runtime);
  }

  /**
   * Updates a service authentication rule.
   * 
   * @param request - UpdateAuthPolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateAuthPolicyResponse
   */
  async updateAuthPolicyWithOptions(request: UpdateAuthPolicyRequest, runtime: $Util.RuntimeOptions): Promise<UpdateAuthPolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.authRule)) {
      query["AuthRule"] = request.authRule;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.k8sNamespace)) {
      query["K8sNamespace"] = request.k8sNamespace;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.protocol)) {
      query["Protocol"] = request.protocol;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateAuthPolicy",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateAuthPolicyResponse>(await this.callApi(params, req, runtime), new UpdateAuthPolicyResponse({}));
  }

  /**
   * Updates a service authentication rule.
   * 
   * @param request - UpdateAuthPolicyRequest
   * @returns UpdateAuthPolicyResponse
   */
  async updateAuthPolicy(request: UpdateAuthPolicyRequest): Promise<UpdateAuthPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateAuthPolicyWithOptions(request, runtime);
  }

  /**
   * Modifies the blacklist or whitelist of a gateway.
   * 
   * @param request - UpdateBlackWhiteListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateBlackWhiteListResponse
   */
  async updateBlackWhiteListWithOptions(request: UpdateBlackWhiteListRequest, runtime: $Util.RuntimeOptions): Promise<UpdateBlackWhiteListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.content)) {
      query["Content"] = request.content;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.isWhite)) {
      query["IsWhite"] = request.isWhite;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.note)) {
      query["Note"] = request.note;
    }

    if (!Util.isUnset(request.resourceIdJsonList)) {
      query["ResourceIdJsonList"] = request.resourceIdJsonList;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateBlackWhiteList",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateBlackWhiteListResponse>(await this.callApi(params, req, runtime), new UpdateBlackWhiteListResponse({}));
  }

  /**
   * Modifies the blacklist or whitelist of a gateway.
   * 
   * @param request - UpdateBlackWhiteListRequest
   * @returns UpdateBlackWhiteListResponse
   */
  async updateBlackWhiteList(request: UpdateBlackWhiteListRequest): Promise<UpdateBlackWhiteListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateBlackWhiteListWithOptions(request, runtime);
  }

  /**
   * Updates a circuit breaking rule.
   * 
   * @param request - UpdateCircuitBreakerRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCircuitBreakerRuleResponse
   */
  async updateCircuitBreakerRuleWithOptions(request: UpdateCircuitBreakerRuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCircuitBreakerRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.halfOpenBaseAmountPerStep)) {
      query["HalfOpenBaseAmountPerStep"] = request.halfOpenBaseAmountPerStep;
    }

    if (!Util.isUnset(request.halfOpenRecoveryStepNum)) {
      query["HalfOpenRecoveryStepNum"] = request.halfOpenRecoveryStepNum;
    }

    if (!Util.isUnset(request.maxAllowedRtMs)) {
      query["MaxAllowedRtMs"] = request.maxAllowedRtMs;
    }

    if (!Util.isUnset(request.minRequestAmount)) {
      query["MinRequestAmount"] = request.minRequestAmount;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.retryTimeoutMs)) {
      query["RetryTimeoutMs"] = request.retryTimeoutMs;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.statIntervalMs)) {
      query["StatIntervalMs"] = request.statIntervalMs;
    }

    if (!Util.isUnset(request.strategy)) {
      query["Strategy"] = request.strategy;
    }

    if (!Util.isUnset(request.threshold)) {
      query["Threshold"] = request.threshold;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCircuitBreakerRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCircuitBreakerRuleResponse>(await this.callApi(params, req, runtime), new UpdateCircuitBreakerRuleResponse({}));
  }

  /**
   * Updates a circuit breaking rule.
   * 
   * @param request - UpdateCircuitBreakerRuleRequest
   * @returns UpdateCircuitBreakerRuleResponse
   */
  async updateCircuitBreakerRule(request: UpdateCircuitBreakerRuleRequest): Promise<UpdateCircuitBreakerRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCircuitBreakerRuleWithOptions(request, runtime);
  }

  /**
   * Modifies the information about an instance.
   * 
   * @param request - UpdateClusterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateClusterResponse
   */
  async updateClusterWithOptions(request: UpdateClusterRequest, runtime: $Util.RuntimeOptions): Promise<UpdateClusterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterAliasName)) {
      query["ClusterAliasName"] = request.clusterAliasName;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.maintenanceEndTime)) {
      query["MaintenanceEndTime"] = request.maintenanceEndTime;
    }

    if (!Util.isUnset(request.maintenanceStartTime)) {
      query["MaintenanceStartTime"] = request.maintenanceStartTime;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCluster",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateClusterResponse>(await this.callApi(params, req, runtime), new UpdateClusterResponse({}));
  }

  /**
   * Modifies the information about an instance.
   * 
   * @param request - UpdateClusterRequest
   * @returns UpdateClusterResponse
   */
  async updateCluster(request: UpdateClusterRequest): Promise<UpdateClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateClusterWithOptions(request, runtime);
  }

  /**
   * Updates the number or specifications of nodes in a pay-as-you-go Microservices Engine (MSE) instance.
   * 
   * @remarks
   * You can call this operation to update the number or specifications of nodes in a pay-as-you-go MSE instance. You are charged when you add nodes or upgrade node specifications. For more information, see [Pricing] (`~~1806469~~`).
   * 
   * @param request - UpdateClusterSpecRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateClusterSpecResponse
   */
  async updateClusterSpecWithOptions(request: UpdateClusterSpecRequest, runtime: $Util.RuntimeOptions): Promise<UpdateClusterSpecResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.autoPay)) {
      query["AutoPay"] = request.autoPay;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.clusterSpecification)) {
      query["ClusterSpecification"] = request.clusterSpecification;
    }

    if (!Util.isUnset(request.instanceCount)) {
      query["InstanceCount"] = request.instanceCount;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.mseVersion)) {
      query["MseVersion"] = request.mseVersion;
    }

    if (!Util.isUnset(request.pubNetworkFlow)) {
      query["PubNetworkFlow"] = request.pubNetworkFlow;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateClusterSpec",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateClusterSpecResponse>(await this.callApi(params, req, runtime), new UpdateClusterSpecResponse({}));
  }

  /**
   * Updates the number or specifications of nodes in a pay-as-you-go Microservices Engine (MSE) instance.
   * 
   * @remarks
   * You can call this operation to update the number or specifications of nodes in a pay-as-you-go MSE instance. You are charged when you add nodes or upgrade node specifications. For more information, see [Pricing] (`~~1806469~~`).
   * 
   * @param request - UpdateClusterSpecRequest
   * @returns UpdateClusterSpecResponse
   */
  async updateClusterSpec(request: UpdateClusterSpecRequest): Promise<UpdateClusterSpecResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateClusterSpecWithOptions(request, runtime);
  }

  /**
   * Updates the configurations of an instance.
   * 
   * @param request - UpdateConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateConfigResponse
   */
  async updateConfigWithOptions(request: UpdateConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.authEnabled)) {
      query["AuthEnabled"] = request.authEnabled;
    }

    if (!Util.isUnset(request.autopurgePurgeInterval)) {
      query["AutopurgePurgeInterval"] = request.autopurgePurgeInterval;
    }

    if (!Util.isUnset(request.autopurgeSnapRetainCount)) {
      query["AutopurgeSnapRetainCount"] = request.autopurgeSnapRetainCount;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.configAuthEnabled)) {
      query["ConfigAuthEnabled"] = request.configAuthEnabled;
    }

    if (!Util.isUnset(request.configSecretEnabled)) {
      query["ConfigSecretEnabled"] = request.configSecretEnabled;
    }

    if (!Util.isUnset(request.configType)) {
      query["ConfigType"] = request.configType;
    }

    if (!Util.isUnset(request.consoleUIEnabled)) {
      query["ConsoleUIEnabled"] = request.consoleUIEnabled;
    }

    if (!Util.isUnset(request.enable4lw)) {
      query["Enable4lw"] = request.enable4lw;
    }

    if (!Util.isUnset(request.eurekaSupported)) {
      query["EurekaSupported"] = request.eurekaSupported;
    }

    if (!Util.isUnset(request.extendedTypesEnable)) {
      query["ExtendedTypesEnable"] = request.extendedTypesEnable;
    }

    if (!Util.isUnset(request.initLimit)) {
      query["InitLimit"] = request.initLimit;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.juteMaxbuffer)) {
      query["JuteMaxbuffer"] = request.juteMaxbuffer;
    }

    if (!Util.isUnset(request.MCPEnabled)) {
      query["MCPEnabled"] = request.MCPEnabled;
    }

    if (!Util.isUnset(request.maxClientCnxns)) {
      query["MaxClientCnxns"] = request.maxClientCnxns;
    }

    if (!Util.isUnset(request.maxSessionTimeout)) {
      query["MaxSessionTimeout"] = request.maxSessionTimeout;
    }

    if (!Util.isUnset(request.minSessionTimeout)) {
      query["MinSessionTimeout"] = request.minSessionTimeout;
    }

    if (!Util.isUnset(request.namingAuthEnabled)) {
      query["NamingAuthEnabled"] = request.namingAuthEnabled;
    }

    if (!Util.isUnset(request.passWord)) {
      query["PassWord"] = request.passWord;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    if (!Util.isUnset(request.snapshotCount)) {
      query["SnapshotCount"] = request.snapshotCount;
    }

    if (!Util.isUnset(request.syncLimit)) {
      query["SyncLimit"] = request.syncLimit;
    }

    if (!Util.isUnset(request.TLSEnabled)) {
      query["TLSEnabled"] = request.TLSEnabled;
    }

    if (!Util.isUnset(request.tickTime)) {
      query["TickTime"] = request.tickTime;
    }

    if (!Util.isUnset(request.userName)) {
      query["UserName"] = request.userName;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.openSuperAcl)) {
      body["OpenSuperAcl"] = request.openSuperAcl;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateConfig",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateConfigResponse>(await this.callApi(params, req, runtime), new UpdateConfigResponse({}));
  }

  /**
   * Updates the configurations of an instance.
   * 
   * @param request - UpdateConfigRequest
   * @returns UpdateConfigResponse
   */
  async updateConfig(request: UpdateConfigRequest): Promise<UpdateConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateConfigWithOptions(request, runtime);
  }

  /**
   * Updates a namespace for the Nacos engine.
   * 
   * @param request - UpdateEngineNamespaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateEngineNamespaceResponse
   */
  async updateEngineNamespaceWithOptions(request: UpdateEngineNamespaceRequest, runtime: $Util.RuntimeOptions): Promise<UpdateEngineNamespaceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.desc)) {
      query["Desc"] = request.desc;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.serviceCount)) {
      query["ServiceCount"] = request.serviceCount;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateEngineNamespace",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateEngineNamespaceResponse>(await this.callApi(params, req, runtime), new UpdateEngineNamespaceResponse({}));
  }

  /**
   * Updates a namespace for the Nacos engine.
   * 
   * @param request - UpdateEngineNamespaceRequest
   * @returns UpdateEngineNamespaceResponse
   */
  async updateEngineNamespace(request: UpdateEngineNamespaceRequest): Promise<UpdateEngineNamespaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateEngineNamespaceWithOptions(request, runtime);
  }

  /**
   * Updates a throttling rule.
   * 
   * @param request - UpdateFlowRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateFlowRuleResponse
   */
  async updateFlowRuleWithOptions(request: UpdateFlowRuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateFlowRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.controlBehavior)) {
      query["ControlBehavior"] = request.controlBehavior;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.maxQueueingTimeMs)) {
      query["MaxQueueingTimeMs"] = request.maxQueueingTimeMs;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.threshold)) {
      query["Threshold"] = request.threshold;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateFlowRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateFlowRuleResponse>(await this.callApi(params, req, runtime), new UpdateFlowRuleResponse({}));
  }

  /**
   * Updates a throttling rule.
   * 
   * @param request - UpdateFlowRuleRequest
   * @returns UpdateFlowRuleResponse
   */
  async updateFlowRule(request: UpdateFlowRuleRequest): Promise<UpdateFlowRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateFlowRuleWithOptions(request, runtime);
  }

  /**
   * Updates the consumer on which a gateway performs authentication operations.
   * 
   * @param request - UpdateGatewayAuthConsumerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayAuthConsumerResponse
   */
  async updateGatewayAuthConsumerWithOptions(request: UpdateGatewayAuthConsumerRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewayAuthConsumerResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.encodeType)) {
      query["EncodeType"] = request.encodeType;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.jwks)) {
      query["Jwks"] = request.jwks;
    }

    if (!Util.isUnset(request.keyName)) {
      query["KeyName"] = request.keyName;
    }

    if (!Util.isUnset(request.keyValue)) {
      query["KeyValue"] = request.keyValue;
    }

    if (!Util.isUnset(request.tokenName)) {
      query["TokenName"] = request.tokenName;
    }

    if (!Util.isUnset(request.tokenPass)) {
      query["TokenPass"] = request.tokenPass;
    }

    if (!Util.isUnset(request.tokenPosition)) {
      query["TokenPosition"] = request.tokenPosition;
    }

    if (!Util.isUnset(request.tokenPrefix)) {
      query["TokenPrefix"] = request.tokenPrefix;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewayAuthConsumer",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewayAuthConsumerResponse>(await this.callApi(params, req, runtime), new UpdateGatewayAuthConsumerResponse({}));
  }

  /**
   * Updates the consumer on which a gateway performs authentication operations.
   * 
   * @param request - UpdateGatewayAuthConsumerRequest
   * @returns UpdateGatewayAuthConsumerResponse
   */
  async updateGatewayAuthConsumer(request: UpdateGatewayAuthConsumerRequest): Promise<UpdateGatewayAuthConsumerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewayAuthConsumerWithOptions(request, runtime);
  }

  /**
   * Updates a list of resources on which permissions are granted to a gateway authentication consumer.
   * 
   * @param tmpReq - UpdateGatewayAuthConsumerResourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayAuthConsumerResourceResponse
   */
  async updateGatewayAuthConsumerResourceWithOptions(tmpReq: UpdateGatewayAuthConsumerResourceRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewayAuthConsumerResourceResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateGatewayAuthConsumerResourceShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.resourceList)) {
      request.resourceListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceList, "ResourceList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.consumerId)) {
      query["ConsumerId"] = request.consumerId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.resourceListShrink)) {
      query["ResourceList"] = request.resourceListShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewayAuthConsumerResource",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewayAuthConsumerResourceResponse>(await this.callApi(params, req, runtime), new UpdateGatewayAuthConsumerResourceResponse({}));
  }

  /**
   * Updates a list of resources on which permissions are granted to a gateway authentication consumer.
   * 
   * @param request - UpdateGatewayAuthConsumerResourceRequest
   * @returns UpdateGatewayAuthConsumerResourceResponse
   */
  async updateGatewayAuthConsumerResource(request: UpdateGatewayAuthConsumerResourceRequest): Promise<UpdateGatewayAuthConsumerResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewayAuthConsumerResourceWithOptions(request, runtime);
  }

  /**
   * Updates the resource authorization status for the consumer on which a gateway performs authentication operations.
   * 
   * @param request - UpdateGatewayAuthConsumerResourceStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayAuthConsumerResourceStatusResponse
   */
  async updateGatewayAuthConsumerResourceStatusWithOptions(request: UpdateGatewayAuthConsumerResourceStatusRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewayAuthConsumerResourceStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.consumerId)) {
      query["ConsumerId"] = request.consumerId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.idList)) {
      query["IdList"] = request.idList;
    }

    if (!Util.isUnset(request.resourceStatus)) {
      query["ResourceStatus"] = request.resourceStatus;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewayAuthConsumerResourceStatus",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewayAuthConsumerResourceStatusResponse>(await this.callApi(params, req, runtime), new UpdateGatewayAuthConsumerResourceStatusResponse({}));
  }

  /**
   * Updates the resource authorization status for the consumer on which a gateway performs authentication operations.
   * 
   * @param request - UpdateGatewayAuthConsumerResourceStatusRequest
   * @returns UpdateGatewayAuthConsumerResourceStatusResponse
   */
  async updateGatewayAuthConsumerResourceStatus(request: UpdateGatewayAuthConsumerResourceStatusRequest): Promise<UpdateGatewayAuthConsumerResourceStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewayAuthConsumerResourceStatusWithOptions(request, runtime);
  }

  /**
   * Updates the status of the consumer on which a gateway performs authentication operations.
   * 
   * @param request - UpdateGatewayAuthConsumerStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayAuthConsumerStatusResponse
   */
  async updateGatewayAuthConsumerStatusWithOptions(request: UpdateGatewayAuthConsumerStatusRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewayAuthConsumerStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.consumerStatus)) {
      query["ConsumerStatus"] = request.consumerStatus;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewayAuthConsumerStatus",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewayAuthConsumerStatusResponse>(await this.callApi(params, req, runtime), new UpdateGatewayAuthConsumerStatusResponse({}));
  }

  /**
   * Updates the status of the consumer on which a gateway performs authentication operations.
   * 
   * @param request - UpdateGatewayAuthConsumerStatusRequest
   * @returns UpdateGatewayAuthConsumerStatusResponse
   */
  async updateGatewayAuthConsumerStatus(request: UpdateGatewayAuthConsumerStatusRequest): Promise<UpdateGatewayAuthConsumerStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewayAuthConsumerStatusWithOptions(request, runtime);
  }

  /**
   * 更新网关路由熔断规则
   * 
   * @param request - UpdateGatewayCircuitBreakerRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayCircuitBreakerRuleResponse
   */
  async updateGatewayCircuitBreakerRuleWithOptions(request: UpdateGatewayCircuitBreakerRuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewayCircuitBreakerRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.behaviorType)) {
      query["BehaviorType"] = request.behaviorType;
    }

    if (!Util.isUnset(request.bodyEncoding)) {
      query["BodyEncoding"] = request.bodyEncoding;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.maxAllowedMs)) {
      query["MaxAllowedMs"] = request.maxAllowedMs;
    }

    if (!Util.isUnset(request.minRequestAmount)) {
      query["MinRequestAmount"] = request.minRequestAmount;
    }

    if (!Util.isUnset(request.recoveryTimeoutSec)) {
      query["RecoveryTimeoutSec"] = request.recoveryTimeoutSec;
    }

    if (!Util.isUnset(request.responseContentBody)) {
      query["ResponseContentBody"] = request.responseContentBody;
    }

    if (!Util.isUnset(request.responseRedirectUrl)) {
      query["ResponseRedirectUrl"] = request.responseRedirectUrl;
    }

    if (!Util.isUnset(request.responseStatusCode)) {
      query["ResponseStatusCode"] = request.responseStatusCode;
    }

    if (!Util.isUnset(request.routeId)) {
      query["RouteId"] = request.routeId;
    }

    if (!Util.isUnset(request.routeName)) {
      query["RouteName"] = request.routeName;
    }

    if (!Util.isUnset(request.statDurationSec)) {
      query["StatDurationSec"] = request.statDurationSec;
    }

    if (!Util.isUnset(request.strategy)) {
      query["Strategy"] = request.strategy;
    }

    if (!Util.isUnset(request.triggerRatio)) {
      query["TriggerRatio"] = request.triggerRatio;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewayCircuitBreakerRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewayCircuitBreakerRuleResponse>(await this.callApi(params, req, runtime), new UpdateGatewayCircuitBreakerRuleResponse({}));
  }

  /**
   * 更新网关路由熔断规则
   * 
   * @param request - UpdateGatewayCircuitBreakerRuleRequest
   * @returns UpdateGatewayCircuitBreakerRuleResponse
   */
  async updateGatewayCircuitBreakerRule(request: UpdateGatewayCircuitBreakerRuleRequest): Promise<UpdateGatewayCircuitBreakerRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewayCircuitBreakerRuleWithOptions(request, runtime);
  }

  /**
   * Modifies the information about the domain name associated with a gateway.
   * 
   * @param request - UpdateGatewayDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayDomainResponse
   */
  async updateGatewayDomainWithOptions(request: UpdateGatewayDomainRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewayDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.certIdentifier)) {
      query["CertIdentifier"] = request.certIdentifier;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.http2)) {
      query["Http2"] = request.http2;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.mustHttps)) {
      query["MustHttps"] = request.mustHttps;
    }

    if (!Util.isUnset(request.protocol)) {
      query["Protocol"] = request.protocol;
    }

    if (!Util.isUnset(request.tlsMax)) {
      query["TlsMax"] = request.tlsMax;
    }

    if (!Util.isUnset(request.tlsMin)) {
      query["TlsMin"] = request.tlsMin;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewayDomain",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewayDomainResponse>(await this.callApi(params, req, runtime), new UpdateGatewayDomainResponse({}));
  }

  /**
   * Modifies the information about the domain name associated with a gateway.
   * 
   * @param request - UpdateGatewayDomainRequest
   * @returns UpdateGatewayDomainResponse
   */
  async updateGatewayDomain(request: UpdateGatewayDomainRequest): Promise<UpdateGatewayDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewayDomainWithOptions(request, runtime);
  }

  /**
   * 更新网关路由流控规则
   * 
   * @param request - UpdateGatewayFlowRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayFlowRuleResponse
   */
  async updateGatewayFlowRuleWithOptions(request: UpdateGatewayFlowRuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewayFlowRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.behaviorType)) {
      query["BehaviorType"] = request.behaviorType;
    }

    if (!Util.isUnset(request.bodyEncoding)) {
      query["BodyEncoding"] = request.bodyEncoding;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.responseContentBody)) {
      query["ResponseContentBody"] = request.responseContentBody;
    }

    if (!Util.isUnset(request.responseRedirectUrl)) {
      query["ResponseRedirectUrl"] = request.responseRedirectUrl;
    }

    if (!Util.isUnset(request.responseStatusCode)) {
      query["ResponseStatusCode"] = request.responseStatusCode;
    }

    if (!Util.isUnset(request.routeId)) {
      query["RouteId"] = request.routeId;
    }

    if (!Util.isUnset(request.routeName)) {
      query["RouteName"] = request.routeName;
    }

    if (!Util.isUnset(request.threshold)) {
      query["Threshold"] = request.threshold;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewayFlowRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewayFlowRuleResponse>(await this.callApi(params, req, runtime), new UpdateGatewayFlowRuleResponse({}));
  }

  /**
   * 更新网关路由流控规则
   * 
   * @param request - UpdateGatewayFlowRuleRequest
   * @returns UpdateGatewayFlowRuleResponse
   */
  async updateGatewayFlowRule(request: UpdateGatewayFlowRuleRequest): Promise<UpdateGatewayFlowRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewayFlowRuleWithOptions(request, runtime);
  }

  /**
   * 更新网关路由隔离规则
   * 
   * @param request - UpdateGatewayIsolationRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayIsolationRuleResponse
   */
  async updateGatewayIsolationRuleWithOptions(request: UpdateGatewayIsolationRuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewayIsolationRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.behaviorType)) {
      query["BehaviorType"] = request.behaviorType;
    }

    if (!Util.isUnset(request.bodyEncoding)) {
      query["BodyEncoding"] = request.bodyEncoding;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.maxConcurrency)) {
      query["MaxConcurrency"] = request.maxConcurrency;
    }

    if (!Util.isUnset(request.responseContentBody)) {
      query["ResponseContentBody"] = request.responseContentBody;
    }

    if (!Util.isUnset(request.responseRedirectUrl)) {
      query["ResponseRedirectUrl"] = request.responseRedirectUrl;
    }

    if (!Util.isUnset(request.responseStatusCode)) {
      query["ResponseStatusCode"] = request.responseStatusCode;
    }

    if (!Util.isUnset(request.routeId)) {
      query["RouteId"] = request.routeId;
    }

    if (!Util.isUnset(request.routeName)) {
      query["RouteName"] = request.routeName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewayIsolationRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewayIsolationRuleResponse>(await this.callApi(params, req, runtime), new UpdateGatewayIsolationRuleResponse({}));
  }

  /**
   * 更新网关路由隔离规则
   * 
   * @param request - UpdateGatewayIsolationRuleRequest
   * @returns UpdateGatewayIsolationRuleResponse
   */
  async updateGatewayIsolationRule(request: UpdateGatewayIsolationRuleRequest): Promise<UpdateGatewayIsolationRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewayIsolationRuleWithOptions(request, runtime);
  }

  /**
   * Renames a gateway.
   * 
   * @param request - UpdateGatewayNameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayNameResponse
   */
  async updateGatewayNameWithOptions(request: UpdateGatewayNameRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewayNameResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewayName",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewayNameResponse>(await this.callApi(params, req, runtime), new UpdateGatewayNameResponse({}));
  }

  /**
   * Renames a gateway.
   * 
   * @param request - UpdateGatewayNameRequest
   * @returns UpdateGatewayNameResponse
   */
  async updateGatewayName(request: UpdateGatewayNameRequest): Promise<UpdateGatewayNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewayNameWithOptions(request, runtime);
  }

  /**
   * Updates the configurations of a gateway.
   * 
   * @param tmpReq - UpdateGatewayOptionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayOptionResponse
   */
  async updateGatewayOptionWithOptions(tmpReq: UpdateGatewayOptionRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewayOptionResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateGatewayOptionShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.gatewayOption)) {
      request.gatewayOptionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.gatewayOption, "GatewayOption", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!Util.isUnset(request.gatewayOptionShrink)) {
      query["GatewayOption"] = request.gatewayOptionShrink;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewayOption",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewayOptionResponse>(await this.callApi(params, req, runtime), new UpdateGatewayOptionResponse({}));
  }

  /**
   * Updates the configurations of a gateway.
   * 
   * @param request - UpdateGatewayOptionRequest
   * @returns UpdateGatewayOptionResponse
   */
  async updateGatewayOption(request: UpdateGatewayOptionRequest): Promise<UpdateGatewayOptionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewayOptionWithOptions(request, runtime);
  }

  /**
   * Updates a route for a gateway.
   * 
   * @param tmpReq - UpdateGatewayRouteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayRouteResponse
   */
  async updateGatewayRouteWithOptions(tmpReq: UpdateGatewayRouteRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewayRouteResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateGatewayRouteShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.directResponseJSON)) {
      request.directResponseJSONShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.directResponseJSON, "DirectResponseJSON", "json");
    }

    if (!Util.isUnset(tmpReq.fallbackServices)) {
      request.fallbackServicesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fallbackServices, "FallbackServices", "json");
    }

    if (!Util.isUnset(tmpReq.predicates)) {
      request.predicatesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.predicates, "Predicates", "json");
    }

    if (!Util.isUnset(tmpReq.redirectJSON)) {
      request.redirectJSONShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.redirectJSON, "RedirectJSON", "json");
    }

    if (!Util.isUnset(tmpReq.services)) {
      request.servicesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.services, "Services", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.destinationType)) {
      query["DestinationType"] = request.destinationType;
    }

    if (!Util.isUnset(request.directResponseJSONShrink)) {
      query["DirectResponseJSON"] = request.directResponseJSONShrink;
    }

    if (!Util.isUnset(request.domainIdListJSON)) {
      query["DomainIdListJSON"] = request.domainIdListJSON;
    }

    if (!Util.isUnset(request.enableWaf)) {
      query["EnableWaf"] = request.enableWaf;
    }

    if (!Util.isUnset(request.fallback)) {
      query["Fallback"] = request.fallback;
    }

    if (!Util.isUnset(request.fallbackServicesShrink)) {
      query["FallbackServices"] = request.fallbackServicesShrink;
    }

    if (!Util.isUnset(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.predicatesShrink)) {
      query["Predicates"] = request.predicatesShrink;
    }

    if (!Util.isUnset(request.redirectJSONShrink)) {
      query["RedirectJSON"] = request.redirectJSONShrink;
    }

    if (!Util.isUnset(request.routeOrder)) {
      query["RouteOrder"] = request.routeOrder;
    }

    if (!Util.isUnset(request.servicesShrink)) {
      query["Services"] = request.servicesShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewayRoute",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewayRouteResponse>(await this.callApi(params, req, runtime), new UpdateGatewayRouteResponse({}));
  }

  /**
   * Updates a route for a gateway.
   * 
   * @param request - UpdateGatewayRouteRequest
   * @returns UpdateGatewayRouteResponse
   */
  async updateGatewayRoute(request: UpdateGatewayRouteRequest): Promise<UpdateGatewayRouteResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewayRouteWithOptions(request, runtime);
  }

  /**
   * Updates the authentication configurations of a route.
   * 
   * @param tmpReq - UpdateGatewayRouteAuthRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayRouteAuthResponse
   */
  async updateGatewayRouteAuthWithOptions(tmpReq: UpdateGatewayRouteAuthRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewayRouteAuthResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateGatewayRouteAuthShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.authJSON)) {
      request.authJSONShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.authJSON, "AuthJSON", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.authJSONShrink)) {
      query["AuthJSON"] = request.authJSONShrink;
    }

    if (!Util.isUnset(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewayRouteAuth",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewayRouteAuthResponse>(await this.callApi(params, req, runtime), new UpdateGatewayRouteAuthResponse({}));
  }

  /**
   * Updates the authentication configurations of a route.
   * 
   * @param request - UpdateGatewayRouteAuthRequest
   * @returns UpdateGatewayRouteAuthResponse
   */
  async updateGatewayRouteAuth(request: UpdateGatewayRouteAuthRequest): Promise<UpdateGatewayRouteAuthResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewayRouteAuthWithOptions(request, runtime);
  }

  /**
   * Modifies the cross-origin resource sharing (CORS) policy of a route.
   * 
   * @param tmpReq - UpdateGatewayRouteCORSRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayRouteCORSResponse
   */
  async updateGatewayRouteCORSWithOptions(tmpReq: UpdateGatewayRouteCORSRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewayRouteCORSResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateGatewayRouteCORSShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.corsJSON)) {
      request.corsJSONShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.corsJSON, "CorsJSON", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.corsJSONShrink)) {
      query["CorsJSON"] = request.corsJSONShrink;
    }

    if (!Util.isUnset(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewayRouteCORS",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewayRouteCORSResponse>(await this.callApi(params, req, runtime), new UpdateGatewayRouteCORSResponse({}));
  }

  /**
   * Modifies the cross-origin resource sharing (CORS) policy of a route.
   * 
   * @param request - UpdateGatewayRouteCORSRequest
   * @returns UpdateGatewayRouteCORSResponse
   */
  async updateGatewayRouteCORS(request: UpdateGatewayRouteCORSRequest): Promise<UpdateGatewayRouteCORSResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewayRouteCORSWithOptions(request, runtime);
  }

  /**
   * Updates the rewrite policy of a route for a gateway.
   * 
   * @param request - UpdateGatewayRouteHTTPRewriteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayRouteHTTPRewriteResponse
   */
  async updateGatewayRouteHTTPRewriteWithOptions(request: UpdateGatewayRouteHTTPRewriteRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewayRouteHTTPRewriteResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.httpRewriteJSON)) {
      query["HttpRewriteJSON"] = request.httpRewriteJSON;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewayRouteHTTPRewrite",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewayRouteHTTPRewriteResponse>(await this.callApi(params, req, runtime), new UpdateGatewayRouteHTTPRewriteResponse({}));
  }

  /**
   * Updates the rewrite policy of a route for a gateway.
   * 
   * @param request - UpdateGatewayRouteHTTPRewriteRequest
   * @returns UpdateGatewayRouteHTTPRewriteResponse
   */
  async updateGatewayRouteHTTPRewrite(request: UpdateGatewayRouteHTTPRewriteRequest): Promise<UpdateGatewayRouteHTTPRewriteResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewayRouteHTTPRewriteWithOptions(request, runtime);
  }

  /**
   * Modifies the header configuration policy of a route.
   * 
   * @param request - UpdateGatewayRouteHeaderOpRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayRouteHeaderOpResponse
   */
  async updateGatewayRouteHeaderOpWithOptions(request: UpdateGatewayRouteHeaderOpRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewayRouteHeaderOpResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.headerOpJSON)) {
      query["HeaderOpJSON"] = request.headerOpJSON;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewayRouteHeaderOp",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewayRouteHeaderOpResponse>(await this.callApi(params, req, runtime), new UpdateGatewayRouteHeaderOpResponse({}));
  }

  /**
   * Modifies the header configuration policy of a route.
   * 
   * @param request - UpdateGatewayRouteHeaderOpRequest
   * @returns UpdateGatewayRouteHeaderOpResponse
   */
  async updateGatewayRouteHeaderOp(request: UpdateGatewayRouteHeaderOpRequest): Promise<UpdateGatewayRouteHeaderOpResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewayRouteHeaderOpWithOptions(request, runtime);
  }

  /**
   * Modifies the retry policy of a route.
   * 
   * @param tmpReq - UpdateGatewayRouteRetryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayRouteRetryResponse
   */
  async updateGatewayRouteRetryWithOptions(tmpReq: UpdateGatewayRouteRetryRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewayRouteRetryResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateGatewayRouteRetryShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.retryJSON)) {
      request.retryJSONShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.retryJSON, "RetryJSON", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.retryJSONShrink)) {
      query["RetryJSON"] = request.retryJSONShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewayRouteRetry",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewayRouteRetryResponse>(await this.callApi(params, req, runtime), new UpdateGatewayRouteRetryResponse({}));
  }

  /**
   * Modifies the retry policy of a route.
   * 
   * @param request - UpdateGatewayRouteRetryRequest
   * @returns UpdateGatewayRouteRetryResponse
   */
  async updateGatewayRouteRetry(request: UpdateGatewayRouteRetryRequest): Promise<UpdateGatewayRouteRetryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewayRouteRetryWithOptions(request, runtime);
  }

  /**
   * Modifies the timeout policy of a route.
   * 
   * @param tmpReq - UpdateGatewayRouteTimeoutRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayRouteTimeoutResponse
   */
  async updateGatewayRouteTimeoutWithOptions(tmpReq: UpdateGatewayRouteTimeoutRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewayRouteTimeoutResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateGatewayRouteTimeoutShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.timeoutJSON)) {
      request.timeoutJSONShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.timeoutJSON, "TimeoutJSON", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.timeoutJSONShrink)) {
      query["TimeoutJSON"] = request.timeoutJSONShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewayRouteTimeout",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewayRouteTimeoutResponse>(await this.callApi(params, req, runtime), new UpdateGatewayRouteTimeoutResponse({}));
  }

  /**
   * Modifies the timeout policy of a route.
   * 
   * @param request - UpdateGatewayRouteTimeoutRequest
   * @returns UpdateGatewayRouteTimeoutResponse
   */
  async updateGatewayRouteTimeout(request: UpdateGatewayRouteTimeoutRequest): Promise<UpdateGatewayRouteTimeoutResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewayRouteTimeoutWithOptions(request, runtime);
  }

  /**
   * Updates the WAF status of a route.
   * 
   * @param request - UpdateGatewayRouteWafStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayRouteWafStatusResponse
   */
  async updateGatewayRouteWafStatusWithOptions(request: UpdateGatewayRouteWafStatusRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewayRouteWafStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.enableWaf)) {
      query["EnableWaf"] = request.enableWaf;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.routeId)) {
      query["RouteId"] = request.routeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewayRouteWafStatus",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewayRouteWafStatusResponse>(await this.callApi(params, req, runtime), new UpdateGatewayRouteWafStatusResponse({}));
  }

  /**
   * Updates the WAF status of a route.
   * 
   * @param request - UpdateGatewayRouteWafStatusRequest
   * @returns UpdateGatewayRouteWafStatusResponse
   */
  async updateGatewayRouteWafStatus(request: UpdateGatewayRouteWafStatusRequest): Promise<UpdateGatewayRouteWafStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewayRouteWafStatusWithOptions(request, runtime);
  }

  /**
   * Updates the health check policy of a specified service in a cloud-native gateway.
   * 
   * @param tmpReq - UpdateGatewayServiceCheckRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayServiceCheckResponse
   */
  async updateGatewayServiceCheckWithOptions(tmpReq: UpdateGatewayServiceCheckRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewayServiceCheckResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateGatewayServiceCheckShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.expectedStatuses)) {
      request.expectedStatusesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.expectedStatuses, "ExpectedStatuses", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.check)) {
      query["Check"] = request.check;
    }

    if (!Util.isUnset(request.expectedStatusesShrink)) {
      query["ExpectedStatuses"] = request.expectedStatusesShrink;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.healthyThreshold)) {
      query["HealthyThreshold"] = request.healthyThreshold;
    }

    if (!Util.isUnset(request.httpHost)) {
      query["HttpHost"] = request.httpHost;
    }

    if (!Util.isUnset(request.httpPath)) {
      query["HttpPath"] = request.httpPath;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.protocol)) {
      query["Protocol"] = request.protocol;
    }

    if (!Util.isUnset(request.serviceId)) {
      query["ServiceId"] = request.serviceId;
    }

    if (!Util.isUnset(request.timeout)) {
      query["Timeout"] = request.timeout;
    }

    if (!Util.isUnset(request.unhealthyThreshold)) {
      query["UnhealthyThreshold"] = request.unhealthyThreshold;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewayServiceCheck",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewayServiceCheckResponse>(await this.callApi(params, req, runtime), new UpdateGatewayServiceCheckResponse({}));
  }

  /**
   * Updates the health check policy of a specified service in a cloud-native gateway.
   * 
   * @param request - UpdateGatewayServiceCheckRequest
   * @returns UpdateGatewayServiceCheckResponse
   */
  async updateGatewayServiceCheck(request: UpdateGatewayServiceCheckRequest): Promise<UpdateGatewayServiceCheckResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewayServiceCheckWithOptions(request, runtime);
  }

  /**
   * Updates the traffic policy of a service.
   * 
   * @param tmpReq - UpdateGatewayServiceTrafficPolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayServiceTrafficPolicyResponse
   */
  async updateGatewayServiceTrafficPolicyWithOptions(tmpReq: UpdateGatewayServiceTrafficPolicyRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewayServiceTrafficPolicyResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateGatewayServiceTrafficPolicyShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.gatewayTrafficPolicy)) {
      request.gatewayTrafficPolicyShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.gatewayTrafficPolicy, "GatewayTrafficPolicy", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!Util.isUnset(request.gatewayTrafficPolicyShrink)) {
      query["GatewayTrafficPolicy"] = request.gatewayTrafficPolicyShrink;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.serviceId)) {
      query["ServiceId"] = request.serviceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewayServiceTrafficPolicy",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewayServiceTrafficPolicyResponse>(await this.callApi(params, req, runtime), new UpdateGatewayServiceTrafficPolicyResponse({}));
  }

  /**
   * Updates the traffic policy of a service.
   * 
   * @param request - UpdateGatewayServiceTrafficPolicyRequest
   * @returns UpdateGatewayServiceTrafficPolicyResponse
   */
  async updateGatewayServiceTrafficPolicy(request: UpdateGatewayServiceTrafficPolicyRequest): Promise<UpdateGatewayServiceTrafficPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewayServiceTrafficPolicyWithOptions(request, runtime);
  }

  /**
   * Modifies the version of a service.
   * 
   * @param request - UpdateGatewayServiceVersionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewayServiceVersionResponse
   */
  async updateGatewayServiceVersionWithOptions(request: UpdateGatewayServiceVersionRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewayServiceVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.serviceId)) {
      query["ServiceId"] = request.serviceId;
    }

    if (!Util.isUnset(request.serviceVersion)) {
      query["ServiceVersion"] = request.serviceVersion;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewayServiceVersion",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewayServiceVersionResponse>(await this.callApi(params, req, runtime), new UpdateGatewayServiceVersionResponse({}));
  }

  /**
   * Modifies the version of a service.
   * 
   * @param request - UpdateGatewayServiceVersionRequest
   * @returns UpdateGatewayServiceVersionResponse
   */
  async updateGatewayServiceVersion(request: UpdateGatewayServiceVersionRequest): Promise<UpdateGatewayServiceVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewayServiceVersionWithOptions(request, runtime);
  }

  /**
   * Updates the number of nodes or the specifications of nodes in a pay-as-you-go or subscription cloud-native gateway.
   * 
   * @remarks
   * You can call this operation to update the number of nodes or the specifications of nodes in a pay-as-you-go or subscription cloud-native gateway. If you add nodes or increase the specifications, you will incur fees. For more information, see [Pricing](https://help.aliyun.com/document_detail/250950.html).
   * 
   * @param request - UpdateGatewaySpecRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGatewaySpecResponse
   */
  async updateGatewaySpecWithOptions(request: UpdateGatewaySpecRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGatewaySpecResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.replica)) {
      query["Replica"] = request.replica;
    }

    if (!Util.isUnset(request.spec)) {
      query["Spec"] = request.spec;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGatewaySpec",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGatewaySpecResponse>(await this.callApi(params, req, runtime), new UpdateGatewaySpecResponse({}));
  }

  /**
   * Updates the number of nodes or the specifications of nodes in a pay-as-you-go or subscription cloud-native gateway.
   * 
   * @remarks
   * You can call this operation to update the number of nodes or the specifications of nodes in a pay-as-you-go or subscription cloud-native gateway. If you add nodes or increase the specifications, you will incur fees. For more information, see [Pricing](https://help.aliyun.com/document_detail/250950.html).
   * 
   * @param request - UpdateGatewaySpecRequest
   * @returns UpdateGatewaySpecResponse
   */
  async updateGatewaySpec(request: UpdateGatewaySpecRequest): Promise<UpdateGatewaySpecResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGatewaySpecWithOptions(request, runtime);
  }

  /**
   * Updates the version number of the destination cluster.
   * 
   * @param request - UpdateImageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateImageResponse
   */
  async updateImageWithOptions(request: UpdateImageRequest, runtime: $Util.RuntimeOptions): Promise<UpdateImageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.versionCode)) {
      query["VersionCode"] = request.versionCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateImage",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateImageResponse>(await this.callApi(params, req, runtime), new UpdateImageResponse({}));
  }

  /**
   * Updates the version number of the destination cluster.
   * 
   * @param request - UpdateImageRequest
   * @returns UpdateImageResponse
   */
  async updateImage(request: UpdateImageRequest): Promise<UpdateImageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateImageWithOptions(request, runtime);
  }

  /**
   * 更新隔离规则
   * 
   * @param request - UpdateIsolationRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateIsolationRuleResponse
   */
  async updateIsolationRuleWithOptions(request: UpdateIsolationRuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateIsolationRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.threshold)) {
      query["Threshold"] = request.threshold;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateIsolationRule",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateIsolationRuleResponse>(await this.callApi(params, req, runtime), new UpdateIsolationRuleResponse({}));
  }

  /**
   * 更新隔离规则
   * 
   * @param request - UpdateIsolationRuleRequest
   * @returns UpdateIsolationRuleResponse
   */
  async updateIsolationRule(request: UpdateIsolationRuleRequest): Promise<UpdateIsolationRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateIsolationRuleWithOptions(request, runtime);
  }

  /**
   * Updates the configuration of a canary release for messaging of an application.
   * 
   * @param tmpReq - UpdateMessageQueueRouteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateMessageQueueRouteResponse
   */
  async updateMessageQueueRouteWithOptions(tmpReq: UpdateMessageQueueRouteRequest, runtime: $Util.RuntimeOptions): Promise<UpdateMessageQueueRouteResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateMessageQueueRouteShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.tags)) {
      request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, "Tags", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.filterSide)) {
      query["FilterSide"] = request.filterSide;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.tagsShrink)) {
      query["Tags"] = request.tagsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateMessageQueueRoute",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateMessageQueueRouteResponse>(await this.callApi(params, req, runtime), new UpdateMessageQueueRouteResponse({}));
  }

  /**
   * Updates the configuration of a canary release for messaging of an application.
   * 
   * @param request - UpdateMessageQueueRouteRequest
   * @returns UpdateMessageQueueRouteResponse
   */
  async updateMessageQueueRoute(request: UpdateMessageQueueRouteRequest): Promise<UpdateMessageQueueRouteResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateMessageQueueRouteWithOptions(request, runtime);
  }

  /**
   * Updates a migration task.
   * 
   * @param request - UpdateMigrationTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateMigrationTaskResponse
   */
  async updateMigrationTaskWithOptions(request: UpdateMigrationTaskRequest, runtime: $Util.RuntimeOptions): Promise<UpdateMigrationTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterType)) {
      query["ClusterType"] = request.clusterType;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.originInstanceAddress)) {
      query["OriginInstanceAddress"] = request.originInstanceAddress;
    }

    if (!Util.isUnset(request.originInstanceName)) {
      query["OriginInstanceName"] = request.originInstanceName;
    }

    if (!Util.isUnset(request.originInstanceNamespace)) {
      query["OriginInstanceNamespace"] = request.originInstanceNamespace;
    }

    if (!Util.isUnset(request.projectDesc)) {
      query["ProjectDesc"] = request.projectDesc;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    if (!Util.isUnset(request.syncType)) {
      query["SyncType"] = request.syncType;
    }

    if (!Util.isUnset(request.targetClusterName)) {
      query["TargetClusterName"] = request.targetClusterName;
    }

    if (!Util.isUnset(request.targetClusterUrl)) {
      query["TargetClusterUrl"] = request.targetClusterUrl;
    }

    if (!Util.isUnset(request.targetInstanceId)) {
      query["TargetInstanceId"] = request.targetInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateMigrationTask",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateMigrationTaskResponse>(await this.callApi(params, req, runtime), new UpdateMigrationTaskResponse({}));
  }

  /**
   * Updates a migration task.
   * 
   * @param request - UpdateMigrationTaskRequest
   * @returns UpdateMigrationTaskResponse
   */
  async updateMigrationTask(request: UpdateMigrationTaskRequest): Promise<UpdateMigrationTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateMigrationTaskWithOptions(request, runtime);
  }

  /**
   * Updates the information about a Nacos cluster.
   * 
   * @param request - UpdateNacosClusterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateNacosClusterResponse
   */
  async updateNacosClusterWithOptions(request: UpdateNacosClusterRequest, runtime: $Util.RuntimeOptions): Promise<UpdateNacosClusterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.checkPort)) {
      query["CheckPort"] = request.checkPort;
    }

    if (!Util.isUnset(request.clusterName)) {
      query["ClusterName"] = request.clusterName;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.healthChecker)) {
      query["HealthChecker"] = request.healthChecker;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.serviceName)) {
      query["ServiceName"] = request.serviceName;
    }

    if (!Util.isUnset(request.useInstancePortForCheck)) {
      query["UseInstancePortForCheck"] = request.useInstancePortForCheck;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateNacosCluster",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateNacosClusterResponse>(await this.callApi(params, req, runtime), new UpdateNacosClusterResponse({}));
  }

  /**
   * Updates the information about a Nacos cluster.
   * 
   * @param request - UpdateNacosClusterRequest
   * @returns UpdateNacosClusterResponse
   */
  async updateNacosCluster(request: UpdateNacosClusterRequest): Promise<UpdateNacosClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateNacosClusterWithOptions(request, runtime);
  }

  /**
   * Updates a Nacos configuration.
   * 
   * @remarks
   * >  The current API operation is not provided in Nacos SDK. For more information about Nacos SDK, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - UpdateNacosConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateNacosConfigResponse
   */
  async updateNacosConfigWithOptions(request: UpdateNacosConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateNacosConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.betaIps)) {
      query["BetaIps"] = request.betaIps;
    }

    if (!Util.isUnset(request.content)) {
      query["Content"] = request.content;
    }

    if (!Util.isUnset(request.dataId)) {
      query["DataId"] = request.dataId;
    }

    if (!Util.isUnset(request.desc)) {
      query["Desc"] = request.desc;
    }

    if (!Util.isUnset(request.encryptedDataKey)) {
      query["EncryptedDataKey"] = request.encryptedDataKey;
    }

    if (!Util.isUnset(request.group)) {
      query["Group"] = request.group;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.md5)) {
      query["Md5"] = request.md5;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateNacosConfig",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateNacosConfigResponse>(await this.callApi(params, req, runtime), new UpdateNacosConfigResponse({}));
  }

  /**
   * Updates a Nacos configuration.
   * 
   * @remarks
   * >  The current API operation is not provided in Nacos SDK. For more information about Nacos SDK, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - UpdateNacosConfigRequest
   * @returns UpdateNacosConfigResponse
   */
  async updateNacosConfig(request: UpdateNacosConfigRequest): Promise<UpdateNacosConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateNacosConfigWithOptions(request, runtime);
  }

  /**
   * 更新nacos灰度配置
   * 
   * @param request - UpdateNacosGrayConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateNacosGrayConfigResponse
   */
  async updateNacosGrayConfigWithOptions(request: UpdateNacosGrayConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateNacosGrayConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.content)) {
      query["Content"] = request.content;
    }

    if (!Util.isUnset(request.dataId)) {
      query["DataId"] = request.dataId;
    }

    if (!Util.isUnset(request.grayRule)) {
      query["GrayRule"] = request.grayRule;
    }

    if (!Util.isUnset(request.grayType)) {
      query["GrayType"] = request.grayType;
    }

    if (!Util.isUnset(request.group)) {
      query["Group"] = request.group;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    if (!Util.isUnset(request.stopGray)) {
      query["StopGray"] = request.stopGray;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateNacosGrayConfig",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateNacosGrayConfigResponse>(await this.callApi(params, req, runtime), new UpdateNacosGrayConfigResponse({}));
  }

  /**
   * 更新nacos灰度配置
   * 
   * @param request - UpdateNacosGrayConfigRequest
   * @returns UpdateNacosGrayConfigResponse
   */
  async updateNacosGrayConfig(request: UpdateNacosGrayConfigRequest): Promise<UpdateNacosGrayConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateNacosGrayConfigWithOptions(request, runtime);
  }

  /**
   * Updates the information about application instances that are registered with a Nacos instance.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - UpdateNacosInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateNacosInstanceResponse
   */
  async updateNacosInstanceWithOptions(request: UpdateNacosInstanceRequest, runtime: $Util.RuntimeOptions): Promise<UpdateNacosInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterName)) {
      query["ClusterName"] = request.clusterName;
    }

    if (!Util.isUnset(request.enabled)) {
      query["Enabled"] = request.enabled;
    }

    if (!Util.isUnset(request.ephemeral)) {
      query["Ephemeral"] = request.ephemeral;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.serviceName)) {
      query["ServiceName"] = request.serviceName;
    }

    if (!Util.isUnset(request.weight)) {
      query["Weight"] = request.weight;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.metadata)) {
      body["Metadata"] = request.metadata;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateNacosInstance",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateNacosInstanceResponse>(await this.callApi(params, req, runtime), new UpdateNacosInstanceResponse({}));
  }

  /**
   * Updates the information about application instances that are registered with a Nacos instance.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - UpdateNacosInstanceRequest
   * @returns UpdateNacosInstanceResponse
   */
  async updateNacosInstance(request: UpdateNacosInstanceRequest): Promise<UpdateNacosInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateNacosInstanceWithOptions(request, runtime);
  }

  /**
   * Updates the information about a Nacos service.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - UpdateNacosServiceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateNacosServiceResponse
   */
  async updateNacosServiceWithOptions(request: UpdateNacosServiceRequest, runtime: $Util.RuntimeOptions): Promise<UpdateNacosServiceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.protectThreshold)) {
      query["ProtectThreshold"] = request.protectThreshold;
    }

    if (!Util.isUnset(request.serviceName)) {
      query["ServiceName"] = request.serviceName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateNacosService",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateNacosServiceResponse>(await this.callApi(params, req, runtime), new UpdateNacosServiceResponse({}));
  }

  /**
   * Updates the information about a Nacos service.
   * 
   * @remarks
   * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
   * 
   * @param request - UpdateNacosServiceRequest
   * @returns UpdateNacosServiceResponse
   */
  async updateNacosService(request: UpdateNacosServiceRequest): Promise<UpdateNacosServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateNacosServiceWithOptions(request, runtime);
  }

  /**
   * Updates the configuration of a plug-in.
   * 
   * @param tmpReq - UpdatePluginConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdatePluginConfigResponse
   */
  async updatePluginConfigWithOptions(tmpReq: UpdatePluginConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdatePluginConfigResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdatePluginConfigShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.resourceIdList)) {
      request.resourceIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceIdList, "ResourceIdList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.configLevel)) {
      query["ConfigLevel"] = request.configLevel;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.gmtCreate)) {
      query["GmtCreate"] = request.gmtCreate;
    }

    if (!Util.isUnset(request.gmtModified)) {
      query["GmtModified"] = request.gmtModified;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.pluginId)) {
      query["PluginId"] = request.pluginId;
    }

    if (!Util.isUnset(request.resourceIdListShrink)) {
      query["ResourceIdList"] = request.resourceIdListShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdatePluginConfig",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdatePluginConfigResponse>(await this.callApi(params, req, runtime), new UpdatePluginConfigResponse({}));
  }

  /**
   * Updates the configuration of a plug-in.
   * 
   * @param request - UpdatePluginConfigRequest
   * @returns UpdatePluginConfigResponse
   */
  async updatePluginConfig(request: UpdatePluginConfigRequest): Promise<UpdatePluginConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updatePluginConfigWithOptions(request, runtime);
  }

  /**
   * Updates a certificate.
   * 
   * @param request - UpdateSSLCertRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateSSLCertResponse
   */
  async updateSSLCertWithOptions(request: UpdateSSLCertRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSSLCertResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.certIdentifier)) {
      query["CertIdentifier"] = request.certIdentifier;
    }

    if (!Util.isUnset(request.domainId)) {
      query["DomainId"] = request.domainId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSSLCert",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSSLCertResponse>(await this.callApi(params, req, runtime), new UpdateSSLCertResponse({}));
  }

  /**
   * Updates a certificate.
   * 
   * @param request - UpdateSSLCertRequest
   * @returns UpdateSSLCertResponse
   */
  async updateSSLCert(request: UpdateSSLCertRequest): Promise<UpdateSSLCertResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSSLCertWithOptions(request, runtime);
  }

  /**
   * Modifies service sources of a cloud-native gateway. You can modify only Container Service for Kubernetes (ACK) service sources that contain configurations related to Ingress resource monitoring.
   * 
   * @param tmpReq - UpdateServiceSourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateServiceSourceResponse
   */
  async updateServiceSourceWithOptions(tmpReq: UpdateServiceSourceRequest, runtime: $Util.RuntimeOptions): Promise<UpdateServiceSourceResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateServiceSourceShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.ingressOptionsRequest)) {
      request.ingressOptionsRequestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ingressOptionsRequest, "IngressOptionsRequest", "json");
    }

    if (!Util.isUnset(tmpReq.pathList)) {
      request.pathListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.pathList, "PathList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.address)) {
      query["Address"] = request.address;
    }

    if (!Util.isUnset(request.gatewayId)) {
      query["GatewayId"] = request.gatewayId;
    }

    if (!Util.isUnset(request.gatewayUniqueId)) {
      query["GatewayUniqueId"] = request.gatewayUniqueId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.ingressOptionsRequestShrink)) {
      query["IngressOptionsRequest"] = request.ingressOptionsRequestShrink;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.pathListShrink)) {
      query["PathList"] = request.pathListShrink;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateServiceSource",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateServiceSourceResponse>(await this.callApi(params, req, runtime), new UpdateServiceSourceResponse({}));
  }

  /**
   * Modifies service sources of a cloud-native gateway. You can modify only Container Service for Kubernetes (ACK) service sources that contain configurations related to Ingress resource monitoring.
   * 
   * @param request - UpdateServiceSourceRequest
   * @returns UpdateServiceSourceResponse
   */
  async updateServiceSource(request: UpdateServiceSourceRequest): Promise<UpdateServiceSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateServiceSourceWithOptions(request, runtime);
  }

  /**
   * Updates the information about a ZooKeeper node.
   * 
   * @param request - UpdateZnodeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateZnodeResponse
   */
  async updateZnodeWithOptions(request: UpdateZnodeRequest, runtime: $Util.RuntimeOptions): Promise<UpdateZnodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.data)) {
      query["Data"] = request.data;
    }

    if (!Util.isUnset(request.path)) {
      query["Path"] = request.path;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateZnode",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateZnodeResponse>(await this.callApi(params, req, runtime), new UpdateZnodeResponse({}));
  }

  /**
   * Updates the information about a ZooKeeper node.
   * 
   * @param request - UpdateZnodeRequest
   * @returns UpdateZnodeResponse
   */
  async updateZnode(request: UpdateZnodeRequest): Promise<UpdateZnodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateZnodeWithOptions(request, runtime);
  }

  /**
   * Upgrades the version of a cluster.
   * 
   * @param request - UpgradeClusterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpgradeClusterResponse
   */
  async upgradeClusterWithOptions(request: UpgradeClusterRequest, runtime: $Util.RuntimeOptions): Promise<UpgradeClusterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.requestPars)) {
      query["RequestPars"] = request.requestPars;
    }

    if (!Util.isUnset(request.upgradeVersion)) {
      query["UpgradeVersion"] = request.upgradeVersion;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpgradeCluster",
      version: "2019-05-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpgradeClusterResponse>(await this.callApi(params, req, runtime), new UpgradeClusterResponse({}));
  }

  /**
   * Upgrades the version of a cluster.
   * 
   * @param request - UpgradeClusterRequest
   * @returns UpgradeClusterResponse
   */
  async upgradeCluster(request: UpgradeClusterRequest): Promise<UpgradeClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.upgradeClusterWithOptions(request, runtime);
  }

}
